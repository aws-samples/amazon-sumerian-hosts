/*! For license information please see host.core.js.LICENSE.txt */
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("HOST_CORE",[],t):"object"==typeof exports?exports.HOST_CORE=t():e.HOST_CORE=t()}("undefined"!=typeof self?self:"undefined"!=typeof global?global:this,(function(){return(()=>{"use strict";var __webpack_modules__={437:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "default": () => (/* binding */ core)\n});\n\n;// CONCATENATED MODULE: ./src/core/Deferred.js\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\r\n * The built-in class for asynchronous Promises.\r\n * @external Promise\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\r\n */\n\n/**\r\n * A Promise object that can be resolved, rejected or canceled at any time by the\r\n * user.\r\n *\r\n * @extends external:Promise\r\n */\nvar Deferred = /*#__PURE__*/function (_Promise) {\n  _inherits(Deferred, _Promise);\n\n  var _super = _createSuper(Deferred);\n\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {Function} [executable=() => {}] - The function to be executed by the\r\n   * constructor, during the process of constructing the promise. The signature\r\n   * of this is expected to be: executable(  resolutionFunc, rejectionFunc, cancellationFunc ).\r\n   * @param {Function=} onResolve - Optional function to execute once the promise\r\n   * is resolved.\r\n   * @param {Function=} onReject - Optional function to execute once the promise\r\n   * is rejected.\r\n   * @param {Function=} onCancel - Optional function to execute if the user cancels\r\n   * the promise. Canceling results in the promise having a status of \'resolved\'.\r\n   */\n  function Deferred() {\n    var _this;\n\n    var executable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n    var onResolve = arguments.length > 1 ? arguments[1] : undefined;\n    var onReject = arguments.length > 2 ? arguments[2] : undefined;\n    var onCancel = arguments.length > 3 ? arguments[3] : undefined;\n\n    _classCallCheck(this, Deferred);\n\n    if (typeof executable !== \'function\') {\n      throw new Error("Cannot create new Deferred. Executable must be a function.");\n    }\n\n    if (typeof onResolve !== \'undefined\' && typeof onResolve !== \'function\') {\n      throw new Error("Cannot create new Deferred. OnResolve must be a function.");\n    }\n\n    if (typeof onReject !== \'undefined\' && typeof onReject !== \'function\') {\n      throw new Error("Cannot create new Deferred. OnReject must be a function.");\n    }\n\n    if (typeof onCancel !== \'undefined\' && typeof onCancel !== \'function\') {\n      throw new Error("Cannot create new Deferred. OnCancel must be a function.");\n    }\n\n    var res;\n    var rej;\n    var cancel;\n    var status = {\n      resolved: false,\n      rejected: false,\n      canceled: false,\n      pending: true\n    };\n    _this = _super.call(this, function (resolve, reject) {\n      // Store the resolver\n      res = function res(value) {\n        if (status.pending) {\n          status.resolved = true;\n          status.pending = false;\n\n          if (typeof onResolve === \'function\') {\n            value = onResolve(value);\n          }\n\n          return resolve(value);\n        }\n      }; // Store the rejecter\n\n\n      rej = function rej(value) {\n        if (status.pending) {\n          status.rejected = true;\n          status.pending = false;\n\n          if (typeof onReject === \'function\') {\n            value = onReject(value);\n          }\n\n          return reject(value);\n        }\n      }; // Store the canceler\n\n\n      cancel = function cancel(value) {\n        if (status.pending) {\n          status.canceled = true;\n          status.pending = false;\n\n          if (typeof onCancel === \'function\') {\n            value = onCancel(value);\n          }\n\n          return resolve(value);\n        }\n      }; // Run the executable with custom resolver and rejecter\n\n\n      executable(res, rej, cancel);\n    });\n    _this._status = status;\n    _this._resolve = res;\n    _this._reject = rej;\n    _this._cancel = cancel;\n    _this._executable = executable;\n    return _this;\n  }\n  /**\r\n   * Gets the resolved state of the promise.\r\n   *\r\n   * @readonly\r\n   */\n\n\n  _createClass(Deferred, [{\n    key: "resolved",\n    get: function get() {\n      return this._status.resolved;\n    }\n    /**\r\n     * Gets the rejected state of the promise.\r\n     *\r\n     * @readonly\r\n     */\n\n  }, {\n    key: "rejected",\n    get: function get() {\n      return this._status.rejected;\n    }\n    /**\r\n     * Gets the canceled state of the promise.\r\n     *\r\n     * @readonly\r\n     */\n\n  }, {\n    key: "canceled",\n    get: function get() {\n      return this._status.canceled;\n    }\n    /**\r\n     * Gets the pending state of the promise.\r\n     *\r\n     * @readonly\r\n     */\n\n  }, {\n    key: "pending",\n    get: function get() {\n      return this._status.pending;\n    }\n    /**\r\n     * Force the promise to resolve.\r\n     *\r\n     * @param {any=} value - Value to pass to the resolver.\r\n     *\r\n     * @returns {any} - The return value of the resolver function.\r\n     */\n\n  }, {\n    key: "resolve",\n    value: function resolve(value) {\n      return this._resolve(value);\n    }\n    /**\r\n     * Force the promise to reject.\r\n     *\r\n     * @param {any=} value - Value to pass to the rejecter.\r\n     *\r\n     * @returns {any} - The return value of the rejecter function.\r\n     */\n\n  }, {\n    key: "reject",\n    value: function reject(value) {\n      return this._reject(value);\n    }\n    /**\r\n     * Force the promise to resolve and set the canceled state to true.\r\n     *\r\n     * @param {any=} value - Value to pass to the canceller.\r\n     *\r\n     * @returns {any} - The return value of the canceller function.\r\n     */\n\n  }, {\n    key: "cancel",\n    value: function cancel(value) {\n      return this._cancel(value);\n    }\n    /**\r\n     * Run the promise function to try to resolve the promise. Promise must be\r\n     * pending.\r\n     *\r\n     * @param {...any} args - Optional arguments to pass after resolve and reject.\r\n     */\n\n  }, {\n    key: "execute",\n    value: function execute() {\n      if (this.pending) {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        this._executable.apply(this, [this._resolve, this._reject, this._cancel].concat(args));\n      }\n    }\n    /**\r\n     * Return a canceled deferred promise.\r\n     *\r\n     * @param {any=} value - Value to cancel the promise with.\r\n     *\r\n     * @returns {Deferred}\r\n     */\n\n  }], [{\n    key: "cancel",\n    value: function cancel(value) {\n      return new Deferred(function (_resolve, _reject, cancel) {\n        cancel(value);\n      });\n    }\n    /**\r\n     * Return a new Deferred promise that will resolve or reject once all promises\r\n     * in the input array have been resolved or one promise is canceled or rejected.\r\n     * Promises in the array that are Deferred promises will be manually resolved,\r\n     * rejected or canceled when calling resolve, reject or cancel on the return promise.\r\n     *\r\n     * @param {Array.<any>} iterable - An iterable such as an array.\r\n     * @param {Function=} onResolve - Optional function to execute once the promise\r\n     * is resolved.\r\n     * @param {Function=} onReject - Optional function to execute once the promise\r\n     * is rejected.\r\n     * @param {Function=} onCancel - Optional function to execute if the user cancels\r\n     * the promise. Canceling results in the promise having a status of \'canceled\'.\r\n     *\r\n     * @returns Deferred\r\n     */\n\n  }, {\n    key: "all",\n    value: function all(iterable, onResolve, onReject, onCancel) {\n      if (iterable == null || typeof iterable[Symbol.iterator] !== \'function\') {\n        var e = "Cannot execute Deferred.all. First argument must be iterable.";\n\n        if (typeof onReject === \'function\') {\n          e = onReject(e);\n        }\n\n        return Deferred.reject(e);\n      }\n\n      var array = _toConsumableArray(iterable);\n\n      var deferred = array.filter(function (item) {\n        return item instanceof Deferred;\n      });\n      var result = new Deferred(undefined, function (resolveValue) {\n        deferred.forEach(function (item) {\n          item.resolve(resolveValue);\n        });\n        deferred.length = 0;\n\n        if (typeof onResolve === \'function\') {\n          return onResolve(resolveValue);\n        } else {\n          return resolveValue;\n        }\n      }, function (error) {\n        deferred.forEach(function (item) {\n          item.reject(error);\n        });\n        deferred.length = 0;\n\n        if (typeof onReject === \'function\') {\n          return onReject(error);\n        } else {\n          return error;\n        }\n      }, function (cancelValue) {\n        deferred.forEach(function (item) {\n          item.cancel(cancelValue);\n        });\n        deferred.length = 0;\n\n        if (typeof onCancel === \'function\') {\n          return onCancel(cancelValue);\n        } else {\n          return cancelValue;\n        }\n      });\n      var numItems = array.length;\n      var itemTracker = {\n        failed: false,\n        numResolved: 0,\n        resolutions: []\n      };\n      array.forEach(function (item, index) {\n        if (itemTracker.failed) {\n          return;\n        } else if (!(item instanceof Promise)) {\n          itemTracker.resolutions[index] = item;\n          itemTracker.numResolved += 1;\n\n          if (itemTracker.numResolved === numItems) {\n            result.resolve(itemTracker.resolutions);\n          }\n\n          return;\n        }\n\n        item.then(function (value) {\n          if (!itemTracker.failed && !item.canceled) {\n            itemTracker.resolutions[index] = value;\n            itemTracker.numResolved += 1;\n\n            if (itemTracker.numResolved === numItems) {\n              result.resolve(itemTracker.resolutions);\n            }\n          } else if (!itemTracker.failed) {\n            itemTracker.failed = true;\n            result.cancel(value);\n          }\n        }, function (error) {\n          if (!itemTracker.failed) {\n            itemTracker.failed = true;\n            result.reject(error);\n          }\n        });\n      });\n      return result;\n    }\n  }]);\n\n  return Deferred;\n}( /*#__PURE__*/_wrapNativeSuper(Promise));\n\n/* harmony default export */ const core_Deferred = (Deferred);\n;// CONCATENATED MODULE: ./src/core/Utils.js\nfunction Utils_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Utils_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Utils_createClass(Constructor, protoProps, staticProps) { if (protoProps) Utils_defineProperties(Constructor.prototype, protoProps); if (staticProps) Utils_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\r\n * A collection of useful generic functions.\r\n *\r\n * @hideconstructor\r\n */\n\nvar Utils = /*#__PURE__*/function () {\n  function Utils() {\n    Utils_classCallCheck(this, Utils);\n  }\n\n  Utils_createClass(Utils, null, [{\n    key: "createId",\n    value:\n    /**\r\n     * @static\r\n     *\r\n     * Generate a unique id\r\n     *\r\n     * @returns {String}\r\n     */\n    function createId() {\n      return \'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx\'.replace(/[xy]/g, function (c) {\n        var randomNumber = Math.floor((Date.now() + Math.random() * 16) % 16);\n\n        if (c === \'x\') {\n          return randomNumber.toString(16);\n        } // Set bit 6 and 7 to 0 and 1\n\n\n        return (randomNumber & 0x3 | 0x8).toString(16);\n      });\n    }\n    /**\r\n     * @static\r\n     *\r\n     * Check a name string against an array of strings to determine if it is unique.\r\n     * If it isn\'t, append incremented trailing integers to the end of the name\r\n     * until it is unique.\r\n     *\r\n     * @param {string} name - String name to make unique.\r\n     * @param {Array.<string>=} nameArray - Array of string names to check agains.\r\n     *\r\n     * @returns {string}\r\n     */\n\n  }, {\n    key: "getUniqueName",\n    value: function getUniqueName(name) {\n      var nameArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n      // If the name isn\'t in the array return it right away\n      if (!nameArray.includes(name)) {\n        return name;\n      }\n\n      var nameSet = new Set(nameArray); // Separate the name into string and trailing numbers\n\n      var matchGroup = name.match(/\\d*$/);\n      var index = matchGroup.index;\n      var baseName = name.slice(0, index);\n      var increment = Number(matchGroup[0]); // Find the highest trailing number value for the base of the name\n\n      nameSet.forEach(function (setName) {\n        var setMatchGroup = setName.match(/\\d*$/);\n\n        if (setName.slice(0, setMatchGroup.index) === baseName) {\n          var setIncrement = Number(setMatchGroup[0]);\n\n          if (setIncrement > increment) {\n            increment = setIncrement;\n          }\n        }\n      }); // Increment the highest trailing number and append to the name\n\n      return "".concat(baseName).concat(increment + 1);\n    }\n    /**\r\n     * Return a deferred promise that will wait a given number of seconds before\r\n     * resolving. Pass delta time in milliseconds to the deferred promise\'s execute\r\n     * method in an update loop to progress time.\r\n     *\r\n     * @param {number} [seconds=0] - Number of seconds to wait before resolving.\r\n     * @param {Object=} options - Optional options object\r\n     * @param {Function} [options.onFinish] - Callback to execute once the wait time\r\n     * is met.\r\n     * @param {Function=} options.onProgress - Callback to execute each time the wait\r\n     * time progresses towards the target number of seconds. The amount of progress\r\n     * as a 0-1 percentage is passed as an argument.\r\n     * @param {Function=} options.onCancel - Callback to execute if the user cancels\r\n     * the wait before completion.\r\n     * @param {Function=} options.onError - Callback to execute if the wait stops\r\n     * because an error is encountered. The error message is passed as a parameter.\r\n     *\r\n     * @returns {Deferred}\r\n     */\n\n  }, {\n    key: "wait",\n    value: function wait() {\n      var seconds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          onFinish = _ref.onFinish,\n          onProgress = _ref.onProgress,\n          onCancel = _ref.onCancel,\n          onError = _ref.onError;\n\n      // Make sure seconds is numeric\n      if (typeof seconds !== \'number\') {\n        console.warn("Invalid seconds value ".concat(seconds, " for wait. Defaulting to 0."));\n        seconds = 0;\n      } // Resolve immediately if the wait time is not greater than 0\n\n\n      if (seconds <= 0) {\n        if (typeof onFinish === \'function\') {\n          onFinish();\n        }\n\n        return core_Deferred.resolve();\n      }\n\n      var currentTime = 0;\n      var totalTime = seconds * 1000; // convert to milliseconds\n      // Executable to pass to Deferred, meant to be run in an update loop\n\n      var onUpdate = function onUpdate(resolve, reject, _cancel) {\n        var deltaTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n        if (typeof deltaTime !== \'number\') {\n          var e = new Error("Invalid property wait deltaTime. DeltaTime must be a number.");\n          reject(e);\n          return;\n        } // Make sure time has passed\n\n\n        if (deltaTime === 0) {\n          return;\n        } // Signal progress\n\n\n        currentTime += deltaTime;\n\n        if (currentTime < 0) {\n          currentTime = 0;\n        }\n\n        if (typeof onProgress === \'function\') {\n          onProgress(Math.min(currentTime / totalTime, 1));\n        } // Signal completion once time is up\n\n\n        if (currentTime >= totalTime) {\n          resolve();\n        }\n      };\n\n      return new core_Deferred(onUpdate, onFinish, onError, onCancel);\n    }\n    /**\r\n      * Get a random float number between a min (inclusive) and max (exclusive) value\r\n      * @param {number} min minimum value\r\n      * @param {number} max maximum value\r\n      * @returns {float}\r\n      */\n\n  }, {\n    key: "getRandomFloat",\n    value: function getRandomFloat(min, max) {\n      return Math.random() * (max - min) + min;\n    }\n    /**\r\n      * Get a random integer number between a min (inclusive) and max (exclusive) value\r\n      * @param {number} min minimum value\r\n      * @param {number} max maximum value\r\n      * @returns {integer}\r\n      */\n\n  }, {\n    key: "getRandomInt",\n    value: function getRandomInt(min, max) {\n      min = Math.ceil(min);\n      max = Math.floor(max);\n      return Math.floor(Math.random() * (max - min)) + min;\n    }\n  }]);\n\n  return Utils;\n}();\n\n/* harmony default export */ const core_Utils = (Utils);\n;// CONCATENATED MODULE: ./src/core/MathUtils.js\nfunction MathUtils_toConsumableArray(arr) { return MathUtils_arrayWithoutHoles(arr) || MathUtils_iterableToArray(arr) || MathUtils_unsupportedIterableToArray(arr) || MathUtils_nonIterableSpread(); }\n\nfunction MathUtils_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction MathUtils_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return MathUtils_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return MathUtils_arrayLikeToArray(o, minLen); }\n\nfunction MathUtils_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction MathUtils_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return MathUtils_arrayLikeToArray(arr); }\n\nfunction MathUtils_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction MathUtils_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction MathUtils_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction MathUtils_createClass(Constructor, protoProps, staticProps) { if (protoProps) MathUtils_defineProperties(Constructor.prototype, protoProps); if (staticProps) MathUtils_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\nvar RadianToDegree = 180 / Math.PI;\nvar DegreeToRadian = Math.PI / 180;\n/**\r\n * A collection of useful math functions.\r\n *\r\n * @hideconstructor\r\n */\n\nvar MathUtils = /*#__PURE__*/function () {\n  function MathUtils() {\n    MathUtils_classCallCheck(this, MathUtils);\n  }\n\n  MathUtils_createClass(MathUtils, null, [{\n    key: "toDegrees",\n    value:\n    /**\r\n     * Convert the given angle from radians to degrees.\r\n     *\r\n     * @param {number} radians - Angle in radians.\r\n     *\r\n     * @returns {number} - Angle in degrees.\r\n     */\n    function toDegrees(radians) {\n      return radians * RadianToDegree;\n    }\n    /**\r\n     * Convert the given angle from degrees to radians.\r\n     *\r\n     * @param {number} degrees - Angle in degrees.\r\n     *\r\n     * @returns {number} - Angle in radians.\r\n     */\n\n  }, {\n    key: "toRadians",\n    value: function toRadians(degrees) {\n      return degrees * DegreeToRadian;\n    }\n    /**\r\n     * Linearly interpolate between two values.\r\n     *\r\n     * @param {number} from - Start value.\r\n     * @param {number} to - Target value.\r\n     * @param {number} factor - 0-1 amount to interpolate between from and to.\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: "lerp",\n    value: function lerp(from, to, factor) {\n      return from + (to - from) * factor;\n    }\n    /**\r\n     * Clamp a number between 2 values.\r\n     *\r\n     * @param {number} value - Value to clamp.\r\n     * @param {number} [min=0] - Minumum value.\r\n     * @param {number} [max=1] - Maximum value.\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: "clamp",\n    value: function clamp(value) {\n      var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      return Math.max(min, Math.min(value, max));\n    }\n    /**\r\n     * Calculates the closest point on a given 2D line segement\r\n     * from a given 2D point.\r\n     *\r\n     * @param {Array.<number>} a - First point on line segment.\r\n     * @param {Array.<number>} b - Second point on line segment.\r\n     * @param {Array.<number>} p - 2D point.\r\n     *\r\n     * @returns {Array.<number>}\r\n     */\n\n  }, {\n    key: "closestPointOnLine",\n    value: function closestPointOnLine(a, b, p) {\n      var distSqr = MathUtils.distanceSquared(a, b); // Line segment is a single point\n\n      if (distSqr === 0) {\n        return a;\n      }\n\n      var t = ((p[0] - a[0]) * (b[0] - a[0]) + (p[1] - a[1]) * (b[1] - a[1])) / distSqr;\n\n      var point = MathUtils_toConsumableArray(a);\n\n      if (t > 1) {\n        point = MathUtils_toConsumableArray(b);\n      } else if (t > 0) {\n        point = [a[0] + t * (b[0] - a[0]), a[1] + t * (b[1] - a[1])];\n      }\n\n      return point;\n    }\n    /**\r\n     * Gets the distance squared for two 2D points.\r\n     * @param {Array.<number>} a - 2D point.\r\n     * @param {Array.<number>} b - 2D point.\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: "distanceSquared",\n    value: function distanceSquared(a, b) {\n      return (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]);\n    }\n    /**\r\n     * Triangulates a set of 2D points using an implementation\r\n     * of the Bowyer-Watson incremental Delaunay triangulation.\r\n     *\r\n     * @param {Array.<Array.<number>>} vertices - Array of 2D points.\r\n     *\r\n     * @returns {Array.<Array<number>>} - Array of triangle indices.\r\n     */\n\n  }, {\n    key: "getDelaunayTriangulation",\n    value: function getDelaunayTriangulation(vertices) {\n      if (!vertices || vertices.length < 3) {\n        throw new Error("Cannot get delaunay triangulation for points ".concat(vertices, ". Input must contain at least three points."));\n      }\n\n      var minX = Number.POSITIVE_INFINITY;\n      var minY = Number.POSITIVE_INFINITY;\n      var maxX = Number.NEGATIVE_INFINITY;\n      var maxY = Number.NEGATIVE_INFINITY;\n      vertices.forEach(function (v) {\n        minX = v[0] < minX ? v[0] : minX;\n        minY = v[1] < minY ? v[1] : minY;\n        maxX = v[0] > maxX ? v[0] : maxX;\n        maxY = v[1] > maxY ? v[1] : maxY;\n      });\n      var dX = maxX - minX;\n      var dY = maxY - minY;\n      var midX = (minX + maxX) / 2;\n      var midY = (minY + maxY) / 2;\n      var dMax = dX > dY ? dX : dY;\n      var superIndices = [vertices.length, vertices.length + 1, vertices.length + 2];\n      var vertsWithSuper = [].concat(MathUtils_toConsumableArray(vertices), [[midX - 20 * dMax, midY - dMax], [midX, midY + 20 * dMax], [midX + 20 * dMax, midY - dMax]]);\n      var superSortedIndices = MathUtils.sortPointsCCW(superIndices, vertsWithSuper);\n      var superTriangle = {\n        indices: superSortedIndices,\n        edges: [[superSortedIndices[0], superSortedIndices[1]], [superSortedIndices[1], superSortedIndices[2]], [superSortedIndices[2], superSortedIndices[0]]]\n      };\n      var triangles = [superTriangle];\n      vertsWithSuper.forEach(function (newVert, newIndex) {\n        var invalidTriangles = [];\n        triangles.forEach(function (triangle) {\n          if (MathUtils.isPointInCircumCircle(vertsWithSuper[triangle.indices[0]], vertsWithSuper[triangle.indices[1]], vertsWithSuper[triangle.indices[2]], newVert)) {\n            invalidTriangles.push(triangle);\n          }\n        });\n        var boundingPoly = [];\n        invalidTriangles.forEach(function (triangle) {\n          triangle.edges.forEach(function (edge) {\n            var count = 0;\n            invalidTriangles.forEach(function (otherTriangle) {\n              if (triangle !== otherTriangle) {\n                otherTriangle.edges.forEach(function (otherEdge) {\n                  if (edge[0] === otherEdge[0] && edge[1] === otherEdge[1] || edge[1] === otherEdge[0] && edge[0] === otherEdge[1]) {\n                    count += 1;\n                  }\n                });\n              }\n            });\n            if (count === 0) boundingPoly.push(edge);\n          });\n        });\n        invalidTriangles.forEach(function (triangle) {\n          triangles.splice(triangles.indexOf(triangle), 1);\n        });\n        boundingPoly.forEach(function (edge) {\n          var sortedIndices = MathUtils.sortPointsCCW([edge[0], edge[1], newIndex], vertsWithSuper);\n          triangles.push({\n            indices: sortedIndices,\n            edges: [[sortedIndices[0], sortedIndices[1]], [sortedIndices[1], sortedIndices[2]], [sortedIndices[2], sortedIndices[0]]]\n          });\n        });\n      });\n      var trianglesToRemove = [];\n      triangles.forEach(function (triangle) {\n        triangle.indices.forEach(function (index) {\n          if (superIndices.includes(index)) {\n            trianglesToRemove.push(triangle);\n          }\n        });\n      });\n      trianglesToRemove.forEach(function (triangle) {\n        var index = triangles.indexOf(triangle);\n\n        if (index !== -1) {\n          triangles.splice(index, 1);\n        }\n      });\n      return triangles.map(function (triangle) {\n        return triangle.indices;\n      });\n    }\n    /**\r\n     * Determines if a given 2D point is within the cicrumcircle\r\n     * defined by three 2D points. The triangle points must be in\r\n     * counter-clockwise order a -> b -> c.\r\n     *\r\n     * @param {Array.<number>} a - First triangle point.\r\n     * @param {Array.<number>} b - Second triangle point.\r\n     * @param {Array.<number>} c - Third triangle point.\r\n     * @param {Array.<number>} p - 2D point.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "isPointInCircumCircle",\n    value: function isPointInCircumCircle(a, b, c, p) {\n      var ax = a[0] - p[0];\n      var ay = a[1] - p[1];\n      var bx = b[0] - p[0];\n      var by = b[1] - p[1];\n      var cx = c[0] - p[0];\n      var cy = c[1] - p[1];\n      return (ax * ax + ay * ay) * (bx * cy - cx * by) - (bx * bx + by * by) * (ax * cy - cx * ay) + (cx * cx + cy * cy) * (ax * by - bx * ay) > 0;\n    }\n    /**\r\n     * Determines if a given 2D point is within a given triangle.\r\n     *\r\n     * @param {Array.<number>} a - First triangle point.\r\n     * @param {Array.<number>} b - Second triangle point.\r\n     * @param {Array.<number>} c - Third triangle point.\r\n     * @param {Array.<number>} p - 2D point.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "isPointInTriangle",\n    value: function isPointInTriangle(a, b, c, p) {\n      var denom = (b[1] - c[1]) * (a[0] - c[0]) + (c[0] - b[0]) * (a[1] - c[1]);\n      var aVal = ((b[1] - c[1]) * (p[0] - c[0]) + (c[0] - b[0]) * (p[1] - c[1])) / denom;\n      var bVal = ((c[1] - a[1]) * (p[0] - c[0]) + (a[0] - c[0]) * (p[1] - c[1])) / denom;\n      var cVal = 1 - aVal - bVal;\n      return aVal >= 0 && aVal <= 1 && bVal >= 0 && bVal <= 1 && cVal >= 0 && cVal <= 1;\n    }\n    /**\r\n     * Gets the sorted indices of a given set of 2D points in\r\n     * counter-clockwise order.\r\n     *\r\n     * @param {Array.<number>} indices - List of indices.\r\n     * @param {Array.<Array.<number>>} vertices - List of 2D points.\r\n     *\r\n     * @returns {Array.<Array.<number>>} - List of sorted indices.\r\n     */\n\n  }, {\n    key: "sortPointsCCW",\n    value: function sortPointsCCW(indices, vertices) {\n      var centroid = [0, 0];\n      indices.forEach(function (index) {\n        centroid[0] += vertices[index][0];\n        centroid[1] += vertices[index][1];\n      });\n      centroid[0] /= indices.length;\n      centroid[1] /= indices.length;\n      indices.sort(function (a, b) {\n        var bVal = Math.atan2(vertices[b][1] - centroid[1], vertices[b][0] - centroid[0]);\n        var aVal = Math.atan2(vertices[a][1] - centroid[1], vertices[a][0] - centroid[0]);\n        return aVal - bVal;\n      });\n      return indices;\n    }\n    /**\r\n     * Cacluates the area of a triangle\r\n     * @param {Array.<number>} a - First triangle point.\r\n     * @param {Array.<number>} b - Second triangle point.\r\n     * @param {Array.<number>} c - Third triangle point.\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: "triangleArea",\n    value: function triangleArea(a, b, c) {\n      return Math.abs((a[0] * (b[1] - c[1]) + b[0] * (c[1] - a[1]) + c[0] * (a[1] - b[1])) * 0.5);\n    }\n    /**\r\n     * Return the magnitude of a given vector array.\r\n     *\r\n     * @param {Array.<number>} vector - Array consisting of numbers.\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: "getVectorMagnitude",\n    value: function getVectorMagnitude(vector) {\n      if (!(vector instanceof Array)) {\n        throw new Error("Cannot get magnitude for vector ".concat(vector, ". Input must be an Array numbers."));\n      }\n\n      var reducer = function reducer(accumulator, currentValue) {\n        if (typeof currentValue !== \'number\') {\n          throw new Error("Cannot get magnitude for vector ".concat(vector, ". All items in the input Array must be numbers."));\n        }\n\n        return accumulator + Math.pow(currentValue, 2);\n      };\n\n      return Math.sqrt(vector.reduce(reducer, 0));\n    }\n    /**\r\n     * Return the dot product between two vectors.\r\n     *\r\n     * @param {Array.<number>} vectorA - Array consisting of numbers.\r\n     * @param {Array.<number>} vectorB - Array consisting of numbers.\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: "getDotProduct",\n    value: function getDotProduct(vectorA, vectorB) {\n      if (!(vectorA instanceof Array) || !(vectorB instanceof Array) || vectorA.length !== vectorB.length) {\n        throw new Error("Cannot get dot product between ".concat(vectorA, " and ").concat(vectorB, ". Inputs must be vectors of the same length."));\n      }\n\n      var result = 0;\n      vectorA.forEach(function (valueA, index) {\n        var valueB = vectorB[index];\n\n        if (typeof valueA !== \'number\' || typeof valueB !== \'number\') {\n          throw new Error("Cannot get dot product between ".concat(vectorA, " and ").concat(vectorB, ". Vectors must only consist of numeric values."));\n        }\n\n        result += valueA * valueB;\n      });\n      return result;\n    }\n    /**\r\n     * Return the angle in radians between vectorA and vectorB.\r\n     *\r\n     * @param {Array.<number>} vectorA - Array consisting of numbers.\r\n     * @param {Array.<number>} vectorB - Array consisting of numbers.\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: "getAngleBetween",\n    value: function getAngleBetween(vectorA, vectorB) {\n      var normalA = this.normalizeVector(MathUtils_toConsumableArray(vectorA));\n      var normalB = this.normalizeVector(MathUtils_toConsumableArray(vectorB));\n      var dot = this.getDotProduct(normalA, normalB);\n      return Math.acos(this.clamp(dot, -1, 1));\n    }\n    /**\r\n     * Multiply a 3x3 rotation matrix with a vector3.\r\n     *\r\n     * @param {Array.<number>} vector3 - Array consisting of 3 numbers representing\r\n     * a direction vector.\r\n     * @param {Array.<number>} matrix3 - An array of 9 numbers representing a row\r\n     * major rotation matrix.\r\n     *\r\n     * @returns {Array.<number>} - An array of 3 numbers representing the new direction\r\n     * of the vector.\r\n     */\n\n  }, {\n    key: "rotateVector",\n    value: function rotateVector(vector3, matrix3) {\n      if (!(vector3 instanceof Array) || vector3.length !== 3 || !vector3.every(function (v) {\n        return typeof v === \'number\';\n      })) {\n        throw new Error("Cannot rotate vector ".concat(vector3, " by rotation matrix ").concat(matrix3, ". Input vector must be an array of 3 numbers."));\n      }\n\n      if (!(matrix3 instanceof Array) || matrix3.length !== 9 || !matrix3.every(function (v) {\n        return typeof v === \'number\';\n      })) {\n        throw new Error("Cannot rotate vector ".concat(vector3, " by rotation matrix ").concat(matrix3, ". Input matrix3 must be an array of 9 numbers."));\n      }\n\n      var x = matrix3[0] * vector3[0] + matrix3[3] * vector3[1] + matrix3[6] * vector3[2];\n      var y = matrix3[1] * vector3[0] + matrix3[4] * vector3[1] + matrix3[7] * vector3[2];\n      var z = matrix3[2] * vector3[0] + matrix3[5] * vector3[1] + matrix3[8] * vector3[2];\n      return [x, y, z];\n    }\n    /**\r\n     * Normalize a given vector array.\r\n     *\r\n     * @param {Array.<number>} vector - Array consisting of numbers.\r\n     *\r\n     * @returns {Array.<number>} The original vector with normalized values, for chaining.\r\n     */\n\n  }, {\n    key: "normalizeVector",\n    value: function normalizeVector(vector) {\n      var magnitude = this.getVectorMagnitude(vector);\n\n      if (magnitude === 0) {\n        vector.fill(0);\n      } else {\n        vector.forEach(function (value, index) {\n          vector[index] = value / magnitude;\n        });\n      }\n\n      return vector;\n    }\n    /**\r\n     * Extract the 3x3 rotation matrix from a given 4x4 transformation matrix.\r\n     *\r\n     * @param {Array.<number>} matrix4 - An array of 16 numbers representing a row\r\n     * major transformation matrix.\r\n     *\r\n     * @returns {Array.<number>} - An array of 9 numbers representing a row major\r\n     * rotation matrix.\r\n     */\n\n  }, {\n    key: "getRotationMatrix",\n    value: function getRotationMatrix(matrix4) {\n      if (!(matrix4 instanceof Array) || matrix4.length !== 16 || !matrix4.every(function (v) {\n        return typeof v === \'number\';\n      })) {\n        throw new Error("Cannot convert matrix ".concat(matrix4, " to a rotation matrix. Input matrix must be an array of 16 numbers."));\n      } // Extract scale\n\n\n      var scaleX = 1 / (this.getVectorMagnitude(matrix4.slice(0, 4)) || 1);\n      var scaleY = 1 / (this.getVectorMagnitude(matrix4.slice(4, 8)) || 1);\n      var scaleZ = 1 / (this.getVectorMagnitude(matrix4.slice(8, 12)) || 1);\n      return [matrix4[0] * scaleX, matrix4[1] * scaleX, matrix4[2] * scaleX, matrix4[4] * scaleY, matrix4[5] * scaleY, matrix4[6] * scaleY, matrix4[8] * scaleZ, matrix4[9] * scaleZ, matrix4[10] * scaleZ];\n    }\n    /**\r\n     * Return an array containing the spherical coordinates of the given cartesian\r\n     * xyz coordinates.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {number} x - Position along the x axis.\r\n     * @param {number} y - Position along the y axis.\r\n     * @param {number} z - Position along the z axis.\r\n     *\r\n     * @returns {Array.<number>} - An array consisting of three numberes where index\r\n     * 0 represents the radius, index 1 represents the vertical/polar angle in radians\r\n     * and index 2 represents the horizontal/azimuthal angle in radians.\r\n     */\n\n  }, {\n    key: "cartesianToSpherical",\n    value: function cartesianToSpherical(x, y, z) {\n      var r = this.getVectorMagnitude([x, y, z]); // Return identity if the vector has no length\n\n      if (r === 0) {\n        return [0, 0, 0];\n      }\n\n      return [r, Math.acos(this.clamp(y / r, -1, 1)), Math.atan2(x, z)];\n    }\n    /**\r\n     * Gradually change a value of a numeric property towards a goal over time using\r\n     * a critically damped spring function.\r\n     *\r\n     * @param {number} currentValue - The starting value.\r\n     * @param {number} targetValue- The goal value.\r\n     * @param {Array.<number>} [valueStore = [0, 0]] - An Array consisting of two\r\n     * numbers where the first number holds the result value and the second holds\r\n     * the velocity that resulted in that value. The same array should be provided\r\n     * with each call to this function.\r\n     * @param {number} [deltaTime = 1e-7] - The time since the last call to this function\r\n     * in seconds.\r\n     * @param {number} [smoothTime = 0.3] - The approximate amount of time in seconds\r\n     * it should take to reach the target value.\r\n     * @param {number} [maxSpeed = 1e7] - A clamping value for the maximum speed the\r\n     * value can change.\r\n     *\r\n     * @returns {Array.<number>} - The valueStore array.\r\n     */\n\n  }, {\n    key: "dampValue",\n    value: function dampValue(currentValue, targetValue) {\n      var valueStore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0];\n      var deltaTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1e-7;\n      var smoothTime = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.3;\n      var maxSpeed = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1e7;\n      smoothTime = Math.max(0.0001, smoothTime);\n      deltaTime = Math.max(1e-7, deltaTime); // Find the delta between values and use it to estimate the previous value\n\n      var clampTime = maxSpeed * smoothTime;\n      var deltaValue = currentValue - targetValue;\n      var clampDeltaValue = this.clamp(deltaValue, -clampTime, clampTime);\n      var lastValue = currentValue - clampDeltaValue; // Calculate damping factors\n\n      var d1 = 2 / smoothTime;\n      var d2 = d1 * deltaTime;\n      var d3 = 1 / (1 + d2 + 0.5 * Math.pow(d2, 2) + 0.25 * Math.pow(d2, 3));\n      var d4 = (valueStore[1] + d1 * clampDeltaValue) * deltaTime; // Damp the target value and update the velocity\n\n      valueStore[0] = lastValue + (clampDeltaValue + d4) * d3;\n      valueStore[1] = (valueStore[1] - d1 * d4) * d3; // Prevent overshooting\n\n      if (targetValue - currentValue > 0 === valueStore[0] > targetValue) {\n        valueStore[0] = targetValue;\n        valueStore[1] = (valueStore[0] - targetValue) / deltaTime;\n      }\n\n      return valueStore;\n    }\n  }]);\n\n  return MathUtils;\n}();\n\n/* harmony default export */ const core_MathUtils = (MathUtils);\n;// CONCATENATED MODULE: ./src/core/HostEnvironment.js\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable import/prefer-default-export */\n\n/**\r\n * Indicates the type of host build.\r\n *\r\n * @type {string}\r\n */\nvar env = \'core\';\n\n;// CONCATENATED MODULE: ./src/core/Messenger.js\nfunction Messenger_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Messenger_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Messenger_createClass(Constructor, protoProps, staticProps) { if (protoProps) Messenger_defineProperties(Constructor.prototype, protoProps); if (staticProps) Messenger_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable no-underscore-dangle */\n\n/**\r\n * Class that can execute functions when local messages are received. Local messages\r\n * are prefixed with the instance\'s id.\r\n *\r\n * @alias core/Messenger\r\n *\r\n * @property {core/Messenger} GlobalMessenger - A messenger that can be used for\r\n * global messaging. When using static listen and emit methods they are executed\r\n * on this messenger.\r\n * @property {Object} EVENTS - Built-in events that the Messenger emits.\r\n */\n\nvar Messenger = /*#__PURE__*/function () {\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {any=} id - Id for the object. If none is provided a new id will\r\n   * be created. Id should be able to be represented as a string.\r\n   */\n  function Messenger(id) {\n    Messenger_classCallCheck(this, Messenger);\n\n    this._id = id !== undefined ? id : core_Utils.createId();\n    this._dispatcher = window;\n    this._callbacks = {};\n    this._eventListeners = {};\n  }\n  /**\r\n   * Gets the string id of the object.\r\n   *\r\n   * @readonly\r\n   * @type {string}\r\n   */\n\n\n  Messenger_createClass(Messenger, [{\n    key: "id",\n    get: function get() {\n      return this._id;\n    }\n    /**\r\n     * Prefix a message with the instance id.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} message\r\n     *\r\n     * @returns {string}\r\n     */\n\n  }, {\n    key: "_createLocalMessage",\n    value: function _createLocalMessage(message) {\n      return "".concat(this.id, ".").concat(message);\n    }\n    /**\r\n     * Return a function that will call a callback function and supply the event\'s\r\n     * detail property as an argument.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {Function} callback\r\n     *\r\n     * @returns {Function}\r\n     */\n\n  }, {\n    key: "_createListener",\n    value: function _createListener(callback) {\n      return function (e) {\n        var value;\n\n        if (e.detail !== null) {\n          value = e.detail;\n        }\n\n        callback(value);\n      };\n    }\n    /**\r\n     * Create an event object and send it to listeners.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} message - Event type name.\r\n     * @param {any=} value - Value to send to listeners.\r\n     *\r\n     * @returns {CustomEvent}\r\n     */\n\n  }, {\n    key: "_createEvent",\n    value: function _createEvent(message, value) {\n      return new CustomEvent(message, {\n        detail: value\n      });\n    }\n    /**\r\n     * Register an event.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} message - Event type name.\r\n     * @param {Function} listener - A listener function generated using _createListener.\r\n     */\n\n  }, {\n    key: "_addListener",\n    value: function _addListener(message, listener) {\n      this._dispatcher.addEventListener(this._createLocalMessage(message), listener);\n    }\n    /**\r\n     * Unregister an event.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} message - Event type name.\r\n     * @param {Function} listener - A listener function generated using _createListener.\r\n     */\n\n  }, {\n    key: "_removeListener",\n    value: function _removeListener(message, listener) {\n      this._dispatcher.removeEventListener(this._createLocalMessage(message), listener);\n    }\n    /**\r\n     * Execute a function when a message is received for this object.\r\n     *\r\n     * @param {string} message - The message to listen for.\r\n     * @param {Function} callback - Function to execute once the message is received.\r\n     */\n\n  }, {\n    key: "listenTo",\n    value: function listenTo(message, callback) {\n      if (typeof callback !== \'function\') {\n        throw new Error("Cannot add listener for ".concat(message, " on ").concat(this.id, ". Callback must be a function."));\n      }\n\n      if (this._callbacks[message] === undefined) {\n        this._callbacks[message] = [];\n        this._eventListeners[message] = [];\n      }\n\n      var listener = this._createListener(callback);\n\n      this._callbacks[message].push(callback);\n\n      this._eventListeners[message].push(listener);\n\n      this._addListener(message, listener);\n    }\n    /**\r\n     * Prevent a function from being executed when a message is received for this\r\n     * object.\r\n     *\r\n     * @param {string} message - The message to stop listening for.\r\n     * @param {Function=} callback - Optional callback to remove. If none is defined,\r\n     * remove all callbacks for the message.\r\n     */\n\n  }, {\n    key: "stopListening",\n    value: function stopListening(message, callback) {\n      if (this._callbacks[message] === undefined) {\n        return;\n      } else if (callback === undefined) {\n        // If no callback was defined, call stopListening on all callbacks for the message\n        for (var i = this._callbacks[message].length - 1; i > -1; i--) {\n          this.stopListening(message, this._callbacks[message][i]);\n        }\n\n        return;\n      } // If a callback was defined, make sure it\'s a listener\n\n\n      var index = this._callbacks[message].indexOf(callback);\n\n      if (index === -1) {\n        return;\n      }\n\n      var listener = this._eventListeners[message][index];\n\n      this._removeListener(message, listener);\n\n      this._callbacks[message].splice(index, 1);\n\n      this._eventListeners[message].splice(index, 1);\n\n      if (this._callbacks[message].length === 0) {\n        delete this._callbacks[message];\n        delete this._eventListeners[message];\n      }\n    }\n    /**\r\n     * De-register callback(s) from being executed when messages matching the given\r\n     * regular expression are received.\r\n     *\r\n     * @param {Regexp} regexp - regexp - The regular expression to filter messages with.\r\n     * @param {Function=} callback - Optional callback to remove. If none is defined,\r\n     * remove all callbacks for messages matching the regular expression.\r\n     */\n\n  }, {\n    key: "stopListeningByRegexp",\n    value: function stopListeningByRegexp(regexp, callback) {\n      var _this = this;\n\n      var messages = Object.keys(this._callbacks).filter(function (message) {\n        return regexp.test(message);\n      });\n      messages.forEach(function (message) {\n        _this.stopListening(message, callback);\n      });\n    }\n    /**\r\n     * Prevent any functions from being executed when any message is received for\r\n     * this object.\r\n     */\n\n  }, {\n    key: "stopListeningToAll",\n    value: function stopListeningToAll() {\n      var messages = Object.keys(this._callbacks);\n\n      for (var i = messages.length - 1; i > -1; i--) {\n        this.stopListening(messages[i]);\n      }\n    }\n    /**\r\n     * Send a message, causing listener functions for the message on this object\r\n     * to be executed.\r\n     *\r\n     * @param {string} message - The message to emit.\r\n     * @param {any=} value - Optional argument to pass to listener callbacks.\r\n     */\n\n  }, {\n    key: "emit",\n    value: function emit(message, value) {\n      if (this._callbacks[message] === undefined) {\n        return;\n      }\n\n      message = this._createLocalMessage(message);\n\n      var event = this._createEvent(message, value);\n\n      this._dispatcher.dispatchEvent(event);\n    }\n    /**\r\n     * Execute a function when a message is received for the global Messenger instance.\r\n     *\r\n     * @static\r\n     *\r\n     * @param {string} message - The message to listen for.\r\n     * @param {Function} callback - Function to execute once the message is received.\r\n     */\n\n  }], [{\n    key: "listenTo",\n    value: function listenTo(message, callback, messenger) {\n      this.GlobalMessenger.listenTo(message, callback, messenger);\n    }\n    /**\r\n     * Prevent a function from being executed when a message is received for the\r\n     * global Messenger instance.\r\n     *\r\n     * @static\r\n     *\r\n     * @param {string} message - The message to stop listening for.\r\n     * @param {Function=} callback - Optional callback to remove. If none is defined,\r\n     * remove all callbacks for the message.\r\n     */\n\n  }, {\n    key: "stopListening",\n    value: function stopListening(message, callback) {\n      this.GlobalMessenger.stopListening(message, callback);\n    }\n    /**\r\n     * De-register callback(s) from being executed on the global messengerr instance\r\n     * when messages matching the given regular expression are received.\r\n     *\r\n     * @param {Regexp} regexp - regexp - The regular expression to filter messages with.\r\n     * @param {Function=} callback - Optional callback to remove. If none is defined,\r\n     * remove all callbacks for messages matching the regular expression.\r\n     */\n\n  }, {\n    key: "stopListeningByRegexp",\n    value: function stopListeningByRegexp(regexp, callback) {\n      var _this2 = this;\n\n      var messages = Object.keys(this.GlobalMessenger._callbacks).filter(function (message) {\n        return regexp.test(message);\n      });\n      messages.forEach(function (message) {\n        _this2.stopListening(message, callback);\n      });\n    }\n    /**\r\n     * Prevent any functions from being executed when any message is received for\r\n     * the global Messenger instance.\r\n     *\r\n     * @static\r\n     */\n\n  }, {\n    key: "stopListeningToAll",\n    value: function stopListeningToAll() {\n      this.GlobalMessenger.stopListeningToAll();\n    }\n    /**\r\n     * Send a message, causing listener functions for the message on the global Messenger\r\n     * instance to be executed.\r\n     *\r\n     * @static\r\n     *\r\n     * @param {string} message - The message to emit.\r\n     * @param {any=} value - Optional argument to pass to listener callbacks.\r\n     */\n\n  }, {\n    key: "emit",\n    value: function emit(message, value) {\n      this.GlobalMessenger.emit(message, value);\n    }\n  }]);\n\n  return Messenger;\n}();\n\nObject.defineProperties(Messenger, {\n  GlobalMessenger: {\n    value: new Messenger(),\n    writable: false\n  },\n  EVENTS: {\n    value: {},\n    writable: false\n  }\n});\n/* harmony default export */ const core_Messenger = (Messenger);\n;// CONCATENATED MODULE: ./src/core/AbstractHostFeature.js\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || AbstractHostFeature_unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction AbstractHostFeature_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return AbstractHostFeature_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return AbstractHostFeature_arrayLikeToArray(o, minLen); }\n\nfunction AbstractHostFeature_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction AbstractHostFeature_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AbstractHostFeature_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AbstractHostFeature_createClass(Constructor, protoProps, staticProps) { if (protoProps) AbstractHostFeature_defineProperties(Constructor.prototype, protoProps); if (staticProps) AbstractHostFeature_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\r\n * Base class for all host features. Keeps a reference to the host object managing\r\n * the feature.\r\n *\r\n * @abstract\r\n *\r\n * @property {Object} EVENTS - Built-in messages that the feature emits. When the\r\n * feature is added to a {@link core/HostObject}, event names will be prefixed by the\r\n * name of the feature class + \'.\'.\r\n * @property {string} [EVENTS.update=onUpdate] - Message that is emitted after\r\n * each call to [update]{@link AbstractHostFeature#update}.\r\n * @property {Object} SERVICES - Any AWS services that are necessary for the\r\n * feature to function.\r\n */\n\nvar AbstractHostFeature = /*#__PURE__*/function () {\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {core/HostObject} host - The HostObject managing the feature.\r\n   */\n  function AbstractHostFeature(host) {\n    AbstractHostFeature_classCallCheck(this, AbstractHostFeature);\n\n    this._host = host;\n  }\n  /**\r\n   * Adds a namespace to the host with the name of the feature to contain properties\r\n   * and methods from the feature that users of the host need access to.\r\n   */\n\n\n  AbstractHostFeature_createClass(AbstractHostFeature, [{\n    key: "installApi",\n    value: function installApi() {\n      var _this = this;\n\n      var events = {};\n      var api = {\n        EVENTS: events\n      }; // Add the class name to event names\n\n      Object.entries(this.constructor.EVENTS).forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            name = _ref2[0],\n            value = _ref2[1];\n\n        events[name] = "".concat(_this.constructor.name, ".").concat(value);\n      });\n      this._host[this.constructor.name] = api;\n      return api;\n    }\n    /**\r\n     * Gets the host that manages the feature.\r\n     *\r\n     * @readonly\r\n     */\n\n  }, {\n    key: "host",\n    get: function get() {\n      return this._host;\n    }\n    /**\r\n     * Gets the engine owner object of the host.\r\n     *\r\n     * @readonly\r\n     */\n\n  }, {\n    key: "owner",\n    get: function get() {\n      return this._host.owner;\n    }\n    /**\r\n     * Listen to a feature message from the host object.\r\n     *\r\n     * @param {string} message - Message to listen for.\r\n     * @param {Function} callback - The callback to execute when the message is received.\r\n     */\n\n  }, {\n    key: "listenTo",\n    value: function listenTo(message, callback) {\n      this._host.listenTo(message, callback);\n    }\n    /**\r\n     * Listen to a feature message from the global messenger. Feature messages will\r\n     * be prefixed with the class name of the feature.\r\n     *\r\n     * @param {string} message - Message to listen for.\r\n     * @param {Function} callback - The callback to execute when the message is received.\r\n     */\n\n  }, {\n    key: "stopListening",\n    value:\n    /**\r\n     * Stop listening to a message from the host object.\r\n     *\r\n     * @param {string} message - Message to stop listening for.\r\n     * @param {Function=} callback - Optional callback to remove. If none is defined,\r\n     * remove all callbacks for the message.\r\n     */\n    function stopListening(message, callback) {\n      this._host.stopListening(message, callback);\n    }\n    /**\r\n     * Stop listening to a message from the global messenger.\r\n     *\r\n     * @param {string} message - Message to stop listening for.\r\n     * @param {Function=} callback - Optional callback to remove. If none is defined,\r\n     * remove all callbacks for the message.\r\n     */\n\n  }, {\n    key: "stopListeningByRegexp",\n    value:\n    /**\r\n     * Stop listening to a message matching the given regular expression from the\r\n     * host object.\r\n     *\r\n     * @param {Regexp} regexp - The regular expression to stop listening for.\r\n     * @param {Function=} callback - Optional callback to remove. If none is defined,\r\n     * remove all callbacks for the message.\r\n     */\n    function stopListeningByRegexp(regexp, callback) {\n      this._host.stopListeningByRegexp(regexp, callback);\n    }\n    /**\r\n     * Stop listening to a message matching the given regular expression from the\r\n     * global messenger.\r\n     *\r\n     * @param {Regexp} regexp - The regular expression to stop listening for.\r\n     * @param {Function=} callback - Optional callback to remove. If none is defined,\r\n     * remove all callbacks for the message.\r\n     */\n\n  }, {\n    key: "stopListeningToAll",\n    value:\n    /**\r\n     * Stop listening to all messages.\r\n     */\n    function stopListeningToAll() {\n      this._host.stopListeningToAll();\n    }\n    /**\r\n     * Stop listening to all feature messages.\r\n     */\n\n  }, {\n    key: "emit",\n    value:\n    /**\r\n     * Emit feature messages from the host. Feature messages will be prefixed with\r\n     * the class name of the feature.\r\n     *\r\n     * @param {string} message - The message to emit.\r\n     * @param {any=} value - Optional parameter to pass to listener callbacks.\r\n     */\n    function emit(message, value) {\n      message = "".concat(this.constructor.name, ".").concat(message);\n\n      this._host.emit(message, value);\n    }\n    /**\r\n     * Emit feature messages from the global messenger. Feature messages will be prefixed\r\n     * with the class name of the feature.\r\n     *\r\n     * @param {string} message - The message to emit.\r\n     * @param {any=} value - Optional parameter to pass to listener callbacks.\r\n     */\n\n  }, {\n    key: "update",\n    value:\n    /**\r\n     * Executes each time the host is updated.\r\n     *\r\n     * @param {number} deltaTime - Amount of time since the last host update was\r\n     * called.\r\n     */\n    function update(deltaTime) {\n      this.emit(this.constructor.EVENTS.update, deltaTime);\n    }\n    /**\r\n     * Clean up once the feature is no longer in use. Remove the feature namespace\r\n     * from the host and remove reference to the host.\r\n     */\n\n  }, {\n    key: "discard",\n    value: function discard() {\n      var _this2 = this;\n\n      Object.keys(this._host[this.constructor.name]).forEach(function (name) {\n        delete _this2._host[_this2.constructor.name][name];\n      });\n      delete this._host[this.constructor.name];\n      delete this._host;\n    }\n    /**\r\n     * Applies a sequence of mixin class factory functions to this class and\r\n     * returns the result. Each function is expected to return a class that\r\n     * extends the class it was given. The functions are applied in the order\r\n     * that parameters are given, meaning that the first factory will\r\n     * extend this base class.\r\n     *\r\n     * @param {...Function} mixinClassFactories Class factory functions that will\r\n     * be applied.\r\n     *\r\n     * @returns {Class} A class that is the result of applying the factory functions.\r\n     * The resulting class will always inherit from AbstractHostFeature.\r\n     */\n\n  }], [{\n    key: "listenTo",\n    value: function listenTo(message, callback) {\n      message = "".concat(this.name, ".").concat(message);\n      core_Messenger.listenTo(message, callback);\n    }\n  }, {\n    key: "stopListening",\n    value: function stopListening(message, callback) {\n      message = "".concat(this.name, ".").concat(message);\n      core_Messenger.stopListening(message, callback);\n    }\n  }, {\n    key: "stopListeningByRegexp",\n    value: function stopListeningByRegexp(regexp, callback) {\n      regexp = new RegExp("^".concat(this.name, ".").concat(regexp.source.replace(/\\^/, \'\')));\n      core_Messenger.stopListeningByRegexp(regexp, callback);\n    }\n  }, {\n    key: "stopListeningToAll",\n    value: function stopListeningToAll() {\n      core_Messenger.stopListeningByRegexp(new RegExp("^".concat(this.name, ".")));\n    }\n  }, {\n    key: "emit",\n    value: function emit(message, value) {\n      message = "".concat(this.name, ".").concat(message);\n      core_Messenger.emit(message, value);\n    }\n  }, {\n    key: "mix",\n    value: function mix() {\n      var ResultClass = this;\n\n      for (var _len = arguments.length, mixinClassFactories = new Array(_len), _key = 0; _key < _len; _key++) {\n        mixinClassFactories[_key] = arguments[_key];\n      }\n\n      mixinClassFactories.forEach(function (mixinClassFactory) {\n        ResultClass = mixinClassFactory(ResultClass);\n      });\n      return ResultClass;\n    }\n  }]);\n\n  return AbstractHostFeature;\n}();\n\nObject.defineProperties(AbstractHostFeature, {\n  EVENTS: {\n    value: {\n      update: \'onUpdate\'\n    },\n    writable: false\n  },\n  SERVICES: {\n    value: {},\n    writable: false\n  }\n});\n/* harmony default export */ const core_AbstractHostFeature = (AbstractHostFeature);\n;// CONCATENATED MODULE: ./src/core/HostObject.js\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction HostObject_construct(Parent, args, Class) { if (HostObject_isNativeReflectConstruct()) { HostObject_construct = Reflect.construct; } else { HostObject_construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) HostObject_setPrototypeOf(instance, Class.prototype); return instance; }; } return HostObject_construct.apply(null, arguments); }\n\nfunction HostObject_typeof(obj) { "@babel/helpers - typeof"; return HostObject_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, HostObject_typeof(obj); }\n\nfunction HostObject_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction HostObject_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction HostObject_createClass(Constructor, protoProps, staticProps) { if (protoProps) HostObject_defineProperties(Constructor.prototype, protoProps); if (staticProps) HostObject_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction HostObject_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) HostObject_setPrototypeOf(subClass, superClass); }\n\nfunction HostObject_setPrototypeOf(o, p) { HostObject_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return HostObject_setPrototypeOf(o, p); }\n\nfunction HostObject_createSuper(Derived) { var hasNativeReflectConstruct = HostObject_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = HostObject_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = HostObject_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return HostObject_possibleConstructorReturn(this, result); }; }\n\nfunction HostObject_possibleConstructorReturn(self, call) { if (call && (HostObject_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return HostObject_assertThisInitialized(self); }\n\nfunction HostObject_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction HostObject_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction HostObject_getPrototypeOf(o) { HostObject_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return HostObject_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n/**\r\n * Object that manages access to all Host features. Contains a reference to\r\n * engine-specific visuals if applicable.\r\n *\r\n * @extends core/Messenger\r\n * @alias core/HostObject\r\n *\r\n * @property {Object} EVENTS - Built-in messages that the Messenger emits.\r\n * @property {string} [EVENTS.update=\'onUpdate\'] - Message that is emitted after\r\n * each call to [update]{@link core/HostObject#update}.\r\n * @property {string} [EVENTS.addFeature=\'onAddFeature\'] - Message that is emitted\r\n * after each call to [addFeature]{@link core/HostObject#addFeature}.\r\n * @property {string} [EVENTS.removeFeature=\'onRemoveFeature\'] - Message that is emitted\r\n * after each call to [removeFeature]{@link core/HostObject#removeFeature}.\r\n */\n\nvar HostObject = /*#__PURE__*/function (_Messenger) {\n  HostObject_inherits(HostObject, _Messenger);\n\n  var _super = HostObject_createSuper(HostObject);\n\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {Object=} options - Options for the host.\r\n   * @param {Object=} options.owner - Optional engine-specific owner of the host.\r\n   */\n  function HostObject() {\n    var _this;\n\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$owner = _ref.owner,\n        owner = _ref$owner === void 0 ? {} : _ref$owner;\n\n    HostObject_classCallCheck(this, HostObject);\n\n    // If an owner is specified, use its id for messaging\n    _this = _super.call(this, owner.id);\n    _this._owner = owner;\n    _this._features = {};\n    _this._waits = [];\n    _this._lastUpdate = _this.now;\n    return _this;\n  }\n  /**\r\n   * Gets the engine owner object of the host.\r\n   *\r\n   * @readonly\r\n   * @type {Object}\r\n   */\n\n\n  HostObject_createClass(HostObject, [{\n    key: "owner",\n    get: function get() {\n      return this._owner;\n    }\n    /**\r\n     * Gets the current time in milliseconds.\r\n     *\r\n     * @readonly\r\n     * @type {number}\r\n     */\n\n  }, {\n    key: "now",\n    get: function get() {\n      return Date.now();\n    }\n    /**\r\n     * Gets the amount of time in milliseconds since update was last called.\r\n     *\r\n     * @readonly\r\n     * @type {number}\r\n     */\n\n  }, {\n    key: "deltaTime",\n    get: function get() {\n      return this.now - this._lastUpdate;\n    }\n    /**\r\n     * This function should be called in the engine\'s render loop. Executes update\r\n     * loops for all features.\r\n     */\n\n  }, {\n    key: "update",\n    value: function update() {\n      var currentTime = this.now;\n      var dt = this.deltaTime; // Progress stored waits\n\n      this._waits.forEach(function (wait) {\n        wait.execute(dt);\n      }); // Update all features\n\n\n      Object.values(this._features).forEach(function (feature) {\n        feature.update(dt);\n      }); // Notify listeners an update occured\n\n      this.emit(this.constructor.EVENTS.update, dt);\n      this._lastUpdate = currentTime;\n    }\n    /**\r\n     * Return a deferred promise that will wait a given number of seconds before\r\n     * resolving. The host will continuously update the wait promise during the\r\n     * update loop until it resolves.\r\n     *\r\n     * @param {number} [seconds=0] - Number of seconds to wait before resolving.\r\n     * @param {Object=} options - Optional options object\r\n     * @param {Function} [options.onFinish] - Callback to execute once the wait time\r\n     * is met.\r\n     * @param {Function=} options.onProgress - Callback to execute each time the wait\r\n     * time progresses towards the target number of seconds. The amount of progress\r\n     * as a 0-1 percentage is passed as an argument.\r\n     * @param {Function=} options.onCancel - Callback to execute if the user cancels\r\n     * the wait before completion.\r\n     * @param {Function=} options.onError - Callback to execute if the wait stops\r\n     * because an error is encountered. The error message is passed as a parameter.\r\n     *\r\n     * @returns {Deferred}\r\n     */\n\n  }, {\n    key: "wait",\n    value: function wait(seconds) {\n      var _this2 = this;\n\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          onFinish = _ref2.onFinish,\n          onProgress = _ref2.onProgress,\n          onCancel = _ref2.onCancel,\n          onError = _ref2.onError;\n\n      var wait = core_Utils.wait(seconds, {\n        onFinish: onFinish,\n        onProgress: onProgress,\n        onCancel: onCancel,\n        onError: onError\n      });\n\n      this._waits.push(wait); // Once the wait promise is no longer pending remove it from the waits array\n\n\n      var onComplete = function onComplete() {\n        _this2._waits.splice(_this2._waits.indexOf(wait), 1);\n      };\n\n      wait.then(onComplete, onComplete);\n      return wait;\n    }\n    /**\r\n     * Instantiate a new Host feature and store it. Features must inherit from\r\n     * AbstractHostFeature.\r\n     *\r\n     * @param {Class} FeatureClass - Class that will instantiate the feature. Must\r\n     * extend {@link AbstractHostFeature}.\r\n     * @param {boolean} [force=false] - Whether or not to overwrite an existing\r\n     * feature if one of this type already exists on the object.\r\n     * @param  {...any} args - Additional arguments to pass to the FeatureClass\r\n     * constructor. The HostObject will always be passed as the first argument.\r\n     *\r\n     * @returns {boolean} - Whether or not a feature was successfully added.\r\n     */\n\n  }, {\n    key: "addFeature",\n    value: function addFeature(FeatureClass) {\n      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      var inputType = HostObject_typeof(FeatureClass); // Make sure the FeatureClass can be executed\n\n\n      if (inputType !== \'function\') {\n        throw new Error("Cannot add feature to host ".concat(this.id, ". FeatureClass must be a class."));\n      } // Make sure the feature is a host feature\n      else if (!(FeatureClass.prototype instanceof core_AbstractHostFeature)) {\n        throw new Error("Cannot add feature ".concat(FeatureClass.name, " to host ").concat(this.id, ". FeatureClass must extend AbstractHostFeature."));\n      } // Check if the FeatureClass already exists on this object\n\n\n      if (this._features[FeatureClass.name] !== undefined) {\n        if (force) {\n          console.warn("Feature ".concat(FeatureClass.name, " already exists on host ").concat(this.id, ". Existing feature will be overwritten."));\n        } else {\n          throw new Error("Feature ".concat(FeatureClass.name, " already exists on host ").concat(this.id, ". Use \'force\' argument to overwrite the feature."));\n        }\n      } // Initialize the feature\n\n\n      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n      }\n\n      var feature = HostObject_construct(FeatureClass, [this].concat(args));\n\n      feature.installApi();\n      this._features[FeatureClass.name] = feature;\n      this.emit(this.constructor.EVENTS.addFeature, FeatureClass.name);\n      return true;\n    }\n    /**\r\n     * Remove a feature from the object.\r\n     *\r\n     * @param {string} typeName - Name of the type of feature to remove.\r\n     *\r\n     * @returns {boolean} - Whether or not a feature was successfully removed.\r\n     */\n\n  }, {\n    key: "removeFeature",\n    value: function removeFeature(typeName) {\n      if (this._features[typeName] === undefined) {\n        console.warn("Feature of type ".concat(typeName, " does not exist on host ").concat(this.id, ". No feature will be removed."));\n        return false;\n      } else {\n        // Remove the feature\n        this.emit(this.constructor.EVENTS.removeFeature, typeName);\n\n        this._features[typeName].discard();\n\n        delete this._features[typeName];\n        return true;\n      }\n    }\n    /**\r\n     * Indicate whether a specified feature is installed on the host.\r\n     *\r\n     * @param {string} typeName - Name of the type of feature to look for.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "hasFeature",\n    value: function hasFeature(typeName) {\n      return !!this._features[typeName];\n    }\n    /**\r\n     * List the names of the features installed on the host.\r\n     *\r\n     * @returns {Array.<string>}\r\n     */\n\n  }, {\n    key: "listFeatures",\n    value: function listFeatures() {\n      return Object.keys(this._features);\n    }\n  }]);\n\n  return HostObject;\n}(core_Messenger);\n\nObject.defineProperty(HostObject, \'EVENTS\', {\n  value: _objectSpread(_objectSpread({}, Object.getPrototypeOf(HostObject).EVENTS), {}, {\n    update: \'onUpdate\',\n    addFeature: \'onAddFeature\',\n    removeFeature: \'onRemoveFeature\'\n  }),\n  writable: false\n});\n/* harmony default export */ const core_HostObject = (HostObject);\n;// CONCATENATED MODULE: ./src/core/animpack/Easing.js\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\r\n * @typedef {Object} EasingObject Object containing easing functions\r\n * @property {Function} In - Easing \'In\' function. Should use the signature (k:number):number.\r\n * @property {Function} Out - Easing \'Out\' function. Should use the signature (k:number):number.\r\n * @property {Function} InOut - Easing \'InOut\' function. Should use the signature (k:number):number.\r\n */\n\n/**\r\n * Linear Easing\r\n * @type {EasingObject}\r\n */\nvar Linear = {\n  None: function None(k) {\n    return k;\n  },\n  In: function In(k) {\n    return k;\n  },\n  Out: function Out(k) {\n    return k;\n  },\n  InOut: function InOut(k) {\n    return k;\n  }\n};\n/**\r\n * Quadratic Easing\r\n * @type {EasingObject}\r\n */\n\nvar Quadratic = {\n  In: function In(k) {\n    return k * k;\n  },\n  Out: function Out(k) {\n    return k * (2 - k);\n  },\n  InOut: function InOut(k) {\n    k *= 2;\n\n    if (k < 1) {\n      return 0.5 * k * k;\n    }\n\n    return -0.5 * (--k * (k - 2) - 1);\n  }\n};\n/**\r\n * Cubic Easing\r\n * @type {EasingObject}\r\n */\n\nvar Cubic = {\n  In: function In(k) {\n    return k * k * k;\n  },\n  Out: function Out(k) {\n    return --k * k * k + 1;\n  },\n  InOut: function InOut(k) {\n    k *= 2;\n\n    if (k < 1) {\n      return 0.5 * k * k * k;\n    }\n\n    k -= 2;\n    return 0.5 * (k * k * k + 2);\n  }\n};\n/**\r\n * Quartic Easing\r\n * @type {EasingObject}\r\n */\n\nvar Quartic = {\n  In: function In(k) {\n    return k * k * k * k;\n  },\n  Out: function Out(k) {\n    return 1 - --k * k * k * k;\n  },\n  InOut: function InOut(k) {\n    k *= 2;\n\n    if (k < 1) {\n      return 0.5 * k * k * k * k;\n    }\n\n    k -= 2;\n    return -0.5 * (k * k * k * k - 2);\n  }\n};\n/**\r\n * Quintic Easing\r\n * @type {EasingObject}\r\n */\n\nvar Quintic = {\n  In: function In(k) {\n    return k * k * k * k * k;\n  },\n  Out: function Out(k) {\n    return --k * k * k * k * k + 1;\n  },\n  InOut: function InOut(k) {\n    k *= 2;\n\n    if (k < 1) {\n      return 0.5 * k * k * k * k * k;\n    }\n\n    k -= 2;\n    return 0.5 * (k * k * k * k * k + 2);\n  }\n};\n/**\r\n * Sinusoidal Easing\r\n * @type {EasingObject}\r\n */\n\nvar Sinusoidal = {\n  In: function In(k) {\n    return 1 - Math.cos(k * Math.PI / 2);\n  },\n  Out: function Out(k) {\n    return Math.sin(k * Math.PI / 2);\n  },\n  InOut: function InOut(k) {\n    return 0.5 * (1 - Math.cos(Math.PI * k));\n  }\n};\n/**\r\n * Exponential Easing\r\n * @type {EasingObject}\r\n */\n\nvar Exponential = {\n  In: function In(k) {\n    return k === 0 ? 0 : Math.pow(1024, k - 1);\n  },\n  Out: function Out(k) {\n    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n  },\n  InOut: function InOut(k) {\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    k *= 2;\n\n    if (k < 1) {\n      return 0.5 * Math.pow(1024, k - 1);\n    }\n\n    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n  }\n};\n/**\r\n * Circular Easing\r\n * @type {EasingObject}\r\n */\n\nvar Circular = {\n  In: function In(k) {\n    return 1 - Math.sqrt(1 - k * k);\n  },\n  Out: function Out(k) {\n    return Math.sqrt(1 - --k * k);\n  },\n  InOut: function InOut(k) {\n    k *= 2;\n\n    if (k < 1) {\n      return -0.5 * (Math.sqrt(1 - k * k) - 1);\n    }\n\n    k -= 2;\n    return 0.5 * (Math.sqrt(1 - k * k) + 1);\n  }\n};\n/**\r\n * Elastic Easing\r\n * @type {EasingObject}\r\n */\n\nvar Elastic = {\n  In: function In(k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * Math.asin(1 / a) / (2 * Math.PI);\n    }\n\n    k -= 1;\n    return -(a * Math.pow(2, 10 * k) * Math.sin((k - s) * (2 * Math.PI) / p));\n  },\n  Out: function Out(k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * Math.asin(1 / a) / (2 * Math.PI);\n    }\n\n    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;\n  },\n  InOut: function InOut(k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * Math.asin(1 / a) / (2 * Math.PI);\n    }\n\n    k *= 2;\n\n    if (k < 1) {\n      k -= 1;\n      return -0.5 * (a * Math.pow(2, 10 * k) * Math.sin((k - s) * (2 * Math.PI) / p));\n    }\n\n    k -= 1;\n    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n  }\n};\n/**\r\n * Back Easing\r\n * @type {EasingObject}\r\n */\n\nvar Back = {\n  In: function In(k) {\n    var s = 1.70158;\n    return k * k * ((s + 1) * k - s);\n  },\n  Out: function Out(k) {\n    var s = 1.70158;\n    return --k * k * ((s + 1) * k + s) + 1;\n  },\n  InOut: function InOut(k) {\n    var s = 1.70158 * 1.525;\n    k *= 2;\n\n    if (k < 1) {\n      return 0.5 * (k * k * ((s + 1) * k - s));\n    }\n\n    k -= 2;\n    return 0.5 * (k * k * ((s + 1) * k + s) + 2);\n  }\n};\n/**\r\n * Bounce Easing\r\n * @type {EasingObject}\r\n */\n\nvar Bounce = {\n  In: function In(k) {\n    return 1 - Bounce.Out(1 - k);\n  },\n  Out: function Out(k) {\n    if (k < 1 / 2.75) {\n      return 7.5625 * k * k;\n    } else if (k < 2 / 2.75) {\n      k -= 1.5;\n      return 7.5625 * (k / 2.75) * k + 0.75;\n    } else if (k < 2.5 / 2.75) {\n      k -= 2.25;\n      return 7.5625 * (k / 2.75) * k + 0.9375;\n    }\n\n    k -= 2.625;\n    return 7.5625 * (k / 2.75) * k + 0.984375;\n  },\n  InOut: function InOut(k) {\n    if (k < 0.5) {\n      return Bounce.In(k * 2) * 0.5;\n    }\n\n    return Bounce.Out(k * 2 - 1) * 0.5 + 0.5;\n  }\n};\n;// CONCATENATED MODULE: ./src/core/FeatureDependentInterface.js\nfunction FeatureDependentInterface_typeof(obj) { "@babel/helpers - typeof"; return FeatureDependentInterface_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, FeatureDependentInterface_typeof(obj); }\n\nfunction FeatureDependentInterface_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction FeatureDependentInterface_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? FeatureDependentInterface_ownKeys(Object(source), !0).forEach(function (key) { FeatureDependentInterface_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : FeatureDependentInterface_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction FeatureDependentInterface_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction FeatureDependentInterface_slicedToArray(arr, i) { return FeatureDependentInterface_arrayWithHoles(arr) || FeatureDependentInterface_iterableToArrayLimit(arr, i) || FeatureDependentInterface_unsupportedIterableToArray(arr, i) || FeatureDependentInterface_nonIterableRest(); }\n\nfunction FeatureDependentInterface_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction FeatureDependentInterface_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return FeatureDependentInterface_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return FeatureDependentInterface_arrayLikeToArray(o, minLen); }\n\nfunction FeatureDependentInterface_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction FeatureDependentInterface_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction FeatureDependentInterface_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = FeatureDependentInterface_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction FeatureDependentInterface_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) FeatureDependentInterface_setPrototypeOf(subClass, superClass); }\n\nfunction FeatureDependentInterface_setPrototypeOf(o, p) { FeatureDependentInterface_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return FeatureDependentInterface_setPrototypeOf(o, p); }\n\nfunction FeatureDependentInterface_createSuper(Derived) { var hasNativeReflectConstruct = FeatureDependentInterface_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = FeatureDependentInterface_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = FeatureDependentInterface_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return FeatureDependentInterface_possibleConstructorReturn(this, result); }; }\n\nfunction FeatureDependentInterface_possibleConstructorReturn(self, call) { if (call && (FeatureDependentInterface_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return FeatureDependentInterface_assertThisInitialized(self); }\n\nfunction FeatureDependentInterface_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction FeatureDependentInterface_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction FeatureDependentInterface_getPrototypeOf(o) { FeatureDependentInterface_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return FeatureDependentInterface_getPrototypeOf(o); }\n\nfunction FeatureDependentInterface_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction FeatureDependentInterface_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction FeatureDependentInterface_createClass(Constructor, protoProps, staticProps) { if (protoProps) FeatureDependentInterface_defineProperties(Constructor.prototype, protoProps); if (staticProps) FeatureDependentInterface_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable no-unused-vars */\n\n/* eslint-disable max-classes-per-file */\n\n/**\r\n * Class factory interface for features that are dependent on other features being\r\n * present on the host. Event dependencies will be listened for when a feature of\r\n * matching type is added to the host and will stop being listened for when one\r\n * is removed. If the feature is already present when constructed, events will\r\n * be listened for right away.\r\n *\r\n * @interface\r\n *\r\n * @property {Object} EVENT_DEPENDENCIES - Events that the feature should start/stop\r\n * listening for when a feature of type FeatureName is added/removed from the host.\r\n * Event dependencies should follow the signature:\r\n *  { FeatureName: { eventName: callbackName, ... }, ... }\r\n */\n\nvar FeatureDependentInterface = /*#__PURE__*/function () {\n  function FeatureDependentInterface() {\n    FeatureDependentInterface_classCallCheck(this, FeatureDependentInterface);\n  }\n\n  FeatureDependentInterface_createClass(FeatureDependentInterface, [{\n    key: "_onFeatureAdded",\n    value:\n    /**\r\n     * Start listening for event dependencies that match the given feature type.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} typeName - type of feature to listen for.\r\n     */\n    function _onFeatureAdded(typeName) {}\n    /**\r\n     * Stop listening for event dependencies that match the given feature type.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} typeName - type of feature to stop listening for.\r\n     */\n\n  }, {\n    key: "_onFeatureRemoved",\n    value: function _onFeatureRemoved(typeName) {}\n    /**\r\n     * @augments {@link AbstractHostFeature#discard}\r\n     */\n\n  }, {\n    key: "discard",\n    value: function discard() {}\n    /**\r\n     * Creates a class that implements {@link FeatureDependentInterface} and extends\r\n     * a specified base class.\r\n     *\r\n     * @param {Class} BaseClass - The class to extend.\r\n     *\r\n     * @return {Class} A class that extends `BaseClass` and implements {@link FeatureDependentInterface}.\r\n     */\n\n  }], [{\n    key: "Mixin",\n    value: function Mixin(BaseClass) {\n      var FeatureDependentMixin = /*#__PURE__*/function (_BaseClass) {\n        FeatureDependentInterface_inherits(FeatureDependentMixin, _BaseClass);\n\n        var _super = FeatureDependentInterface_createSuper(FeatureDependentMixin);\n\n        function FeatureDependentMixin(host) {\n          var _this;\n\n          FeatureDependentInterface_classCallCheck(this, FeatureDependentMixin);\n\n          _this = _super.call(this, host);\n          _this._host = host; // No need to listen for events if the mixin is in the prototype chain multiple times\n\n          if (!_this._initialized) {\n            _this._initialized = true; // Start listening for feature events\n\n            _this._onFeatureAdded = _this._onFeatureAdded.bind(FeatureDependentInterface_assertThisInitialized(_this));\n            _this._onFeatureRemoved = _this._onFeatureRemoved.bind(FeatureDependentInterface_assertThisInitialized(_this));\n\n            _this._host.listenTo(core_HostObject.EVENTS.addFeature, _this._onFeatureAdded);\n\n            _this._host.listenTo(core_HostObject.EVENTS.removeFeature, _this._onFeatureRemoved); // Register features that already exist\n\n\n            Object.keys(_this.constructor.EVENT_DEPENDENCIES).forEach(function (typeName) {\n              if (_this._host[typeName] !== undefined) {\n                _this._onFeatureAdded(typeName);\n              }\n            });\n          }\n\n          return _this;\n        }\n\n        FeatureDependentInterface_createClass(FeatureDependentMixin, [{\n          key: "_onFeatureAdded",\n          value: function _onFeatureAdded(typeName) {\n            var _this2 = this;\n\n            if (this.constructor.EVENT_DEPENDENCIES[typeName] !== undefined) {\n              var events = this.constructor.EVENT_DEPENDENCIES[typeName];\n              Object.entries(events).forEach(function (_ref) {\n                var _ref2 = FeatureDependentInterface_slicedToArray(_ref, 2),\n                    eventName = _ref2[0],\n                    callback = _ref2[1];\n\n                _this2[callback] = _this2[callback].bind(_this2);\n\n                _this2._host.listenTo(_this2._host[typeName].EVENTS[eventName], _this2[callback]);\n              });\n            }\n          }\n        }, {\n          key: "_onFeatureRemoved",\n          value: function _onFeatureRemoved(typeName) {\n            var _this3 = this;\n\n            if (this.constructor.EVENT_DEPENDENCIES[typeName] !== undefined) {\n              var events = this.constructor.EVENT_DEPENDENCIES[typeName];\n              Object.entries(events).forEach(function (_ref3) {\n                var _ref4 = FeatureDependentInterface_slicedToArray(_ref3, 2),\n                    eventName = _ref4[0],\n                    callback = _ref4[1];\n\n                _this3._host.stopListening(_this3._host[typeName].EVENTS[eventName], _this3[callback]);\n              });\n            }\n          }\n        }, {\n          key: "discard",\n          value: function discard() {\n            var _this4 = this;\n\n            // Stop listening for feature events\n            this._host.stopListening(core_HostObject.EVENTS.addFeature, this._onFeatureAdded);\n\n            this._host.stopListening(core_HostObject.EVENTS.removeFeature, this._onFeatureRemoved); // Stop listening to feature-specific events\n\n\n            Object.keys(this.constructor.EVENT_DEPENDENCIES).forEach(function (typeName) {\n              if (_this4._host[typeName] !== undefined) {\n                _this4._onFeatureRemoved(typeName);\n              }\n            });\n\n            _get(FeatureDependentInterface_getPrototypeOf(FeatureDependentMixin.prototype), "discard", this).call(this);\n          }\n        }]);\n\n        return FeatureDependentMixin;\n      }(BaseClass);\n\n      var EVENT_DEPENDENCIES = BaseClass.EVENT_DEPENDENCIES || {};\n      Object.defineProperties(FeatureDependentMixin, {\n        EVENT_DEPENDENCIES: {\n          value: FeatureDependentInterface_objectSpread({}, EVENT_DEPENDENCIES),\n          writable: false\n        }\n      });\n      return FeatureDependentMixin;\n    }\n  }]);\n\n  return FeatureDependentInterface;\n}();\n/**\r\n * Event dependencies should follow the signature:\r\n * {\r\n *  FeatureName: {\r\n *    // Events that the feature should start/stop listening for when a feature\r\n *    // of type FeatureName is added/removed from the host\r\n *    {\r\n *      eventName: callbackName,\r\n *      ...\r\n *    },\r\n *  }\r\n * }\r\n */\n\n\nObject.defineProperties(FeatureDependentInterface, {\n  EVENT_DEPENDENCIES: {\n    value: {},\n    writable: false\n  }\n});\n/* harmony default export */ const core_FeatureDependentInterface = (FeatureDependentInterface);\n;// CONCATENATED MODULE: ./src/core/animpack/AnimationFeatureDependentInterface.js\nfunction AnimationFeatureDependentInterface_typeof(obj) { "@babel/helpers - typeof"; return AnimationFeatureDependentInterface_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, AnimationFeatureDependentInterface_typeof(obj); }\n\nfunction AnimationFeatureDependentInterface_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction AnimationFeatureDependentInterface_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? AnimationFeatureDependentInterface_ownKeys(Object(source), !0).forEach(function (key) { AnimationFeatureDependentInterface_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : AnimationFeatureDependentInterface_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction AnimationFeatureDependentInterface_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction AnimationFeatureDependentInterface_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AnimationFeatureDependentInterface_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AnimationFeatureDependentInterface_createClass(Constructor, protoProps, staticProps) { if (protoProps) AnimationFeatureDependentInterface_defineProperties(Constructor.prototype, protoProps); if (staticProps) AnimationFeatureDependentInterface_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction AnimationFeatureDependentInterface_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) AnimationFeatureDependentInterface_setPrototypeOf(subClass, superClass); }\n\nfunction AnimationFeatureDependentInterface_setPrototypeOf(o, p) { AnimationFeatureDependentInterface_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return AnimationFeatureDependentInterface_setPrototypeOf(o, p); }\n\nfunction AnimationFeatureDependentInterface_createSuper(Derived) { var hasNativeReflectConstruct = AnimationFeatureDependentInterface_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = AnimationFeatureDependentInterface_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = AnimationFeatureDependentInterface_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return AnimationFeatureDependentInterface_possibleConstructorReturn(this, result); }; }\n\nfunction AnimationFeatureDependentInterface_possibleConstructorReturn(self, call) { if (call && (AnimationFeatureDependentInterface_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return AnimationFeatureDependentInterface_assertThisInitialized(self); }\n\nfunction AnimationFeatureDependentInterface_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction AnimationFeatureDependentInterface_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction AnimationFeatureDependentInterface_getPrototypeOf(o) { AnimationFeatureDependentInterface_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return AnimationFeatureDependentInterface_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable no-unused-vars */\n\n/* eslint-disable max-classes-per-file */\n\n/**\r\n * Class factory interface for features that are dependent on the AnimationFeature\r\n * being present on the host. Layer and animation events will automatically be\r\n * listened for once a AnimationFeature is added to the host and stopped once it\r\n * is removed.\r\n *\r\n * @interface\r\n * @extends FeatureDependentInterface\r\n *\r\n * @property {Object} EVENT_DEPENDENCIES - Events that the feature should start/stop\r\n * listening for when a feature of type FeatureName is added/removed from the host.\r\n * @property {Object} EVENT_DEPENDENCIES.AnimationFeature - Events that are\r\n * specific to the AnimationFeature.\r\n * @property {string} [EVENT_DEPENDENCIES.AnimationFeature.addLayer=\'_onLayerAdded\'] -\r\n * The name of the method that will be executed when AnimationFeature addLayer\r\n * events are emitted.\r\n * @property {string} [EVENT_DEPENDENCIES.AnimationFeature.removeLayer=\'_onLayerRemoved\'] -\r\n * The name of the method that will be executed when AnimationFeature removeLayer\r\n * events are emitted.\r\n * @property {string} [EVENT_DEPENDENCIES.AnimationFeature.renameLayer=\'_onLayerRenamed\'] -\r\n * The name of the method that will be executed when AnimationFeature renameLayer\r\n * events are emitted.\r\n * @property {string} [EVENT_DEPENDENCIES.AnimationFeature.addAnimation=\'_onAnimationAdded\'] -\r\n * The name of the method that will be executed when AnimationFeature addAnimation\r\n * events are emitted.\r\n * @property {string} [EVENT_DEPENDENCIES.AnimationFeature.removeAnimation=\'_onAnimationRemoved\'] -\r\n * The name of the method that will be executed when AnimationFeature removeAnimation\r\n * events are emitted.\r\n * @property {string} [EVENT_DEPENDENCIES.AnimationFeature.renameAnimation=\'_onAnimationRenamed\'] -\r\n * The name of the method that will be executed when AnimationFeature renameAnimation\r\n * events are emitted.\r\n */\n\nvar AnimationFeatureDependentInterface = /*#__PURE__*/function (_FeatureDependentInte) {\n  AnimationFeatureDependentInterface_inherits(AnimationFeatureDependentInterface, _FeatureDependentInte);\n\n  var _super = AnimationFeatureDependentInterface_createSuper(AnimationFeatureDependentInterface);\n\n  function AnimationFeatureDependentInterface() {\n    AnimationFeatureDependentInterface_classCallCheck(this, AnimationFeatureDependentInterface);\n\n    return _super.apply(this, arguments);\n  }\n\n  AnimationFeatureDependentInterface_createClass(AnimationFeatureDependentInterface, [{\n    key: "_onLayerAdded",\n    value:\n    /**\r\n     * Executed when animation layer added events are caught.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} name - Name of the layer that was added.\r\n     */\n    function _onLayerAdded(_ref) {\n      var name = _ref.name;\n    }\n    /**\r\n     * Executed when animation layer removed events are caught.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} name - Name of the layer that was removed.\r\n     */\n\n  }, {\n    key: "_onLayerRemoved",\n    value: function _onLayerRemoved(_ref2) {\n      var name = _ref2.name;\n    }\n    /**\r\n     * Executed when animation layer renamed events are caught.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} oldName - Name of the layer that was renamed.\r\n     * @param {string} newName - New name of the layer.\r\n     */\n\n  }, {\n    key: "_onLayerRenamed",\n    value: function _onLayerRenamed(_ref3) {\n      var oldName = _ref3.oldName,\n          newName = _ref3.newName;\n    }\n    /**\r\n     * Executed when animation added events are caught.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} layerName - Name of the layer that an animation was added to.\r\n     * @param {string} animationName - Name of the animation that was added.\r\n     */\n\n  }, {\n    key: "_onAnimationAdded",\n    value: function _onAnimationAdded(_ref4) {\n      var layerName = _ref4.layerName,\n          animationName = _ref4.animationName;\n    }\n    /**\r\n     * Executed when animation removed events are caught.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} layerName - Name of the layer that an animation was removed from.\r\n     * @param {string} animationName - Name of the animation that was removed.\r\n     */\n\n  }, {\n    key: "_onAnimationRemoved",\n    value: function _onAnimationRemoved(_ref5) {\n      var layerName = _ref5.layerName,\n          animationName = _ref5.animationName;\n    }\n    /**\r\n     * Executed when animation renamed events are caught.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} layerName - Name of the layer that an animation belongs to.\r\n     * @param {string} oldName - Name of the animation that was renamed.\r\n     * @param {string} newName - New name of the animation.\r\n     */\n\n  }, {\n    key: "_onAnimationRenamed",\n    value: function _onAnimationRenamed(_ref6) {\n      var layerName = _ref6.layerName,\n          oldName = _ref6.oldName,\n          newName = _ref6.newName;\n    }\n    /**\r\n     * Creates a class that implements {@link AnimationFeatureDependentInterface}\r\n     * and extends a specified base class.\r\n     *\r\n     * @param {Class} BaseClass - The class to extend.\r\n     *\r\n     * @return {Class} A class that extends `BaseClass` and implements {@link AnimationFeatureDependentInterface}.\r\n     */\n\n  }], [{\n    key: "Mixin",\n    value: function Mixin(BaseClass) {\n      var ParentClass = core_FeatureDependentInterface.Mixin(BaseClass);\n\n      var AnimationFeatureDependentMixin = /*#__PURE__*/function (_ParentClass) {\n        AnimationFeatureDependentInterface_inherits(AnimationFeatureDependentMixin, _ParentClass);\n\n        var _super2 = AnimationFeatureDependentInterface_createSuper(AnimationFeatureDependentMixin);\n\n        function AnimationFeatureDependentMixin() {\n          AnimationFeatureDependentInterface_classCallCheck(this, AnimationFeatureDependentMixin);\n\n          return _super2.apply(this, arguments);\n        }\n\n        AnimationFeatureDependentInterface_createClass(AnimationFeatureDependentMixin, [{\n          key: "_onLayerAdded",\n          value: function _onLayerAdded(_ref7) {\n            var name = _ref7.name;\n          }\n        }, {\n          key: "_onLayerRemoved",\n          value: function _onLayerRemoved(_ref8) {\n            var name = _ref8.name;\n          }\n        }, {\n          key: "_onLayerRenamed",\n          value: function _onLayerRenamed(_ref9) {\n            var oldName = _ref9.oldName,\n                newName = _ref9.newName;\n          }\n        }, {\n          key: "_onAnimationAdded",\n          value: function _onAnimationAdded(_ref10) {\n            var layerName = _ref10.layerName,\n                animationName = _ref10.animationName;\n          }\n        }, {\n          key: "_onAnimationRemoved",\n          value: function _onAnimationRemoved(_ref11) {\n            var layerName = _ref11.layerName,\n                animationName = _ref11.animationName;\n          }\n        }, {\n          key: "_onAnimationRenamed",\n          value: function _onAnimationRenamed(_ref12) {\n            var layerName = _ref12.layerName,\n                oldName = _ref12.oldName,\n                newName = _ref12.newName;\n          }\n        }]);\n\n        return AnimationFeatureDependentMixin;\n      }(ParentClass);\n\n      Object.defineProperties(AnimationFeatureDependentMixin, {\n        EVENT_DEPENDENCIES: {\n          value: AnimationFeatureDependentInterface_objectSpread(AnimationFeatureDependentInterface_objectSpread({}, ParentClass.EVENT_DEPENDENCIES), AnimationFeatureDependentInterface.EVENT_DEPENDENCIES),\n          writable: false\n        }\n      });\n      return AnimationFeatureDependentMixin;\n    }\n  }]);\n\n  return AnimationFeatureDependentInterface;\n}(core_FeatureDependentInterface);\n\nObject.defineProperties(AnimationFeatureDependentInterface, {\n  EVENT_DEPENDENCIES: {\n    value: {\n      AnimationFeature: {\n        addLayer: \'_onLayerAdded\',\n        removeLayer: \'_onLayerRemoved\',\n        renameLayer: \'_onLayerRenamed\',\n        addAnimation: \'_onAnimationAdded\',\n        removeAnimation: \'_onAnimationRemoved\',\n        renameAnimation: \'_onAnimationRenamed\'\n      }\n    },\n    writable: false\n  }\n});\n/* harmony default export */ const animpack_AnimationFeatureDependentInterface = (AnimationFeatureDependentInterface);\n;// CONCATENATED MODULE: ./src/core/animpack/ManagedAnimationLayerInterface.js\nfunction ManagedAnimationLayerInterface_typeof(obj) { "@babel/helpers - typeof"; return ManagedAnimationLayerInterface_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, ManagedAnimationLayerInterface_typeof(obj); }\n\nfunction ManagedAnimationLayerInterface_slicedToArray(arr, i) { return ManagedAnimationLayerInterface_arrayWithHoles(arr) || ManagedAnimationLayerInterface_iterableToArrayLimit(arr, i) || ManagedAnimationLayerInterface_unsupportedIterableToArray(arr, i) || ManagedAnimationLayerInterface_nonIterableRest(); }\n\nfunction ManagedAnimationLayerInterface_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction ManagedAnimationLayerInterface_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return ManagedAnimationLayerInterface_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return ManagedAnimationLayerInterface_arrayLikeToArray(o, minLen); }\n\nfunction ManagedAnimationLayerInterface_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ManagedAnimationLayerInterface_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction ManagedAnimationLayerInterface_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction ManagedAnimationLayerInterface_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction ManagedAnimationLayerInterface_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ManagedAnimationLayerInterface_ownKeys(Object(source), !0).forEach(function (key) { ManagedAnimationLayerInterface_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ManagedAnimationLayerInterface_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction ManagedAnimationLayerInterface_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ManagedAnimationLayerInterface_get() { if (typeof Reflect !== "undefined" && Reflect.get) { ManagedAnimationLayerInterface_get = Reflect.get; } else { ManagedAnimationLayerInterface_get = function _get(target, property, receiver) { var base = ManagedAnimationLayerInterface_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return ManagedAnimationLayerInterface_get.apply(this, arguments); }\n\nfunction ManagedAnimationLayerInterface_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = ManagedAnimationLayerInterface_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction ManagedAnimationLayerInterface_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction ManagedAnimationLayerInterface_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction ManagedAnimationLayerInterface_createClass(Constructor, protoProps, staticProps) { if (protoProps) ManagedAnimationLayerInterface_defineProperties(Constructor.prototype, protoProps); if (staticProps) ManagedAnimationLayerInterface_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction ManagedAnimationLayerInterface_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) ManagedAnimationLayerInterface_setPrototypeOf(subClass, superClass); }\n\nfunction ManagedAnimationLayerInterface_setPrototypeOf(o, p) { ManagedAnimationLayerInterface_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return ManagedAnimationLayerInterface_setPrototypeOf(o, p); }\n\nfunction ManagedAnimationLayerInterface_createSuper(Derived) { var hasNativeReflectConstruct = ManagedAnimationLayerInterface_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = ManagedAnimationLayerInterface_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = ManagedAnimationLayerInterface_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return ManagedAnimationLayerInterface_possibleConstructorReturn(this, result); }; }\n\nfunction ManagedAnimationLayerInterface_possibleConstructorReturn(self, call) { if (call && (ManagedAnimationLayerInterface_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return ManagedAnimationLayerInterface_assertThisInitialized(self); }\n\nfunction ManagedAnimationLayerInterface_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction ManagedAnimationLayerInterface_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction ManagedAnimationLayerInterface_getPrototypeOf(o) { ManagedAnimationLayerInterface_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return ManagedAnimationLayerInterface_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable no-unused-vars */\n\n/* eslint-disable max-classes-per-file */\n\n/**\r\n * Class factory interface for that keeps track of layers and animations on a host.\r\n * Tracked assets are marked as inactive until layers and animations with matching\r\n * names are detected as present on the host.\r\n *\r\n * @interface\r\n * @extends AnimationFeatureDependentInterface\r\n *\r\n * @property {Object} DEFAULT_LAYER_OPTIONS - Default options to use when executing\r\n * {@link AnimationLayer} methods.\r\n * @property {number} [DEFAULT_LAYER_OPTIONS.blendTime=0.5] - Default time in seconds\r\n * to use when executing {@link AnimationLayer.setBlendWeight}.\r\n * @property {Object} [DEFAULT_LAYER_OPTIONS.animations={}] - Maps animation names\r\n * to default options objects to use for managed animations.\r\n */\n\nvar ManagedAnimationLayerInterface = /*#__PURE__*/function (_AnimationFeatureDepe) {\n  ManagedAnimationLayerInterface_inherits(ManagedAnimationLayerInterface, _AnimationFeatureDepe);\n\n  var _super = ManagedAnimationLayerInterface_createSuper(ManagedAnimationLayerInterface);\n\n  function ManagedAnimationLayerInterface() {\n    ManagedAnimationLayerInterface_classCallCheck(this, ManagedAnimationLayerInterface);\n\n    return _super.apply(this, arguments);\n  }\n\n  ManagedAnimationLayerInterface_createClass(ManagedAnimationLayerInterface, [{\n    key: "registerLayer",\n    value:\n    /**\r\n     * Start tracking keeping track of whether a layer with the given name is present\r\n     * on the host.\r\n     *\r\n     * @param {string} name - Name of the layer to keep track of.\r\n     * @param {Object=} options - Options for the layer.\r\n     * @param {number=} options.blendTime - Default amount of time to use when\r\n     * manipulating layer weights on this layer.\r\n     * @param {Function=} options.easingFn - Default easing function to use when\r\n     * manipulating layer weights on this layer.\r\n     * @param {Object=} options.animations - Animations to keep track of on the layer.\r\n     * Animations are represented as key/value pairs of animation names and their\r\n     * options.\r\n     */\n    function registerLayer(name) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    }\n    /**\r\n     * Start tracking keeping track of whether an animation with the given name is\r\n     * present on the host.\r\n     *\r\n     * @param {string} layerName - Name of the layer that will own the animation.\r\n     * @param {string} animationName - Name of the animation to keep track of.\r\n     * @param {Object=} options - Options for the animation.\r\n     */\n\n  }, {\n    key: "registerAnimation",\n    value: function registerAnimation(layerName, animationName) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    }\n    /**\r\n     * Set layer weights on tracked layers.\r\n     *\r\n     * @param {Function=} nameFilter - Predicate function to test each tracked layer\r\n     * with. By default all layers will pass.\r\n     * @param {number} weight - Weight value to set on layers.\r\n     * @param {number=} seconds - Number of seconds it will take to reach the weight\r\n     * on each layer. If undefined, each layers\' blendTime option is used.\r\n     * @param {Function=} easingFn - Easing function to use when setting weight\r\n     * on each layer. If undefined, each layers\' easingFn option is used.\r\n     */\n\n  }, {\n    key: "setLayerWeights",\n    value: function setLayerWeights() {\n      var nameFilter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {\n        return true;\n      };\n      var weight = arguments.length > 1 ? arguments[1] : undefined;\n      var seconds = arguments.length > 2 ? arguments[2] : undefined;\n      var easingFn = arguments.length > 3 ? arguments[3] : undefined;\n    }\n    /**\r\n     * Set all tracked layers\' weights to 1.\r\n     *\r\n     * @param {number=} seconds - Number of seconds it will take to reach the weight\r\n     * on each layer. If undefined, each layers\' blendTime option is used.\r\n     * @param {Function=} easingFn - Easing function to use when setting weight\r\n     * on each layer. If undefined, each layers\' easingFn option is used.\r\n     */\n\n  }, {\n    key: "enable",\n    value: function enable(seconds, easingFn) {}\n    /**\r\n     * Set all tracked layers\' weights to 0.\r\n     *\r\n     * @param {number=} seconds - Number of seconds it will take to reach the weight\r\n     * on each layer. If undefined, each layers\' blendTime option is used.\r\n     * @param {Function=} easingFn - Easing function to use when setting weight\r\n     * on each layer. If undefined, each layers\' easingFn option is used.\r\n     */\n\n  }, {\n    key: "disable",\n    value: function disable(seconds, easingFn) {}\n    /**\r\n     * Creates a class that implements {@link ManagedAnimationLayerInterface}\r\n     * and extends a specified base class.\r\n     *\r\n     * @param {Class} BaseClass - The class to extend.\r\n     *\r\n     * @return {Class} A class that extends `BaseClass` and implements {@link ManagedAnimationLayerInterface}.\r\n     */\n\n  }], [{\n    key: "Mixin",\n    value: function Mixin(BaseClass) {\n      var ParentClass = animpack_AnimationFeatureDependentInterface.Mixin(BaseClass);\n\n      var ManagedAnimationLayerMixin = /*#__PURE__*/function (_ParentClass) {\n        ManagedAnimationLayerInterface_inherits(ManagedAnimationLayerMixin, _ParentClass);\n\n        var _super2 = ManagedAnimationLayerInterface_createSuper(ManagedAnimationLayerMixin);\n\n        function ManagedAnimationLayerMixin() {\n          var _this;\n\n          ManagedAnimationLayerInterface_classCallCheck(this, ManagedAnimationLayerMixin);\n\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          _this = _super2.call.apply(_super2, [this].concat(args));\n          _this._managedLayers = {};\n          return _this;\n        }\n\n        ManagedAnimationLayerInterface_createClass(ManagedAnimationLayerMixin, [{\n          key: "_onFeatureAdded",\n          value: function _onFeatureAdded(typeName) {\n            var _this2 = this;\n\n            ManagedAnimationLayerInterface_get(ManagedAnimationLayerInterface_getPrototypeOf(ManagedAnimationLayerMixin.prototype), "_onFeatureAdded", this).call(this, typeName);\n\n            if (typeName !== \'AnimationFeature\') {\n              return;\n            }\n\n            this._managedLayers = this._managedLayers || {}; // Detect new layers\n\n            this._host.AnimationFeature.layers.forEach(function (name) {\n              _this2._onLayerAdded({\n                name: name\n              });\n            });\n          }\n        }, {\n          key: "_onFeatureRemoved",\n          value: function _onFeatureRemoved(typeName) {\n            var _this3 = this;\n\n            ManagedAnimationLayerInterface_get(ManagedAnimationLayerInterface_getPrototypeOf(ManagedAnimationLayerMixin.prototype), "_onFeatureRemoved", this).call(this, typeName);\n\n            if (typeName !== \'AnimationFeature\') {\n              return;\n            }\n\n            this._managedLayers = this._managedLayers || {}; // Deactivate the layers\n\n            Object.keys(this._managedLayers).forEach(function (name) {\n              _this3._onLayerRemoved({\n                name: name\n              });\n            });\n          }\n        }, {\n          key: "_onLayerAdded",\n          value: function _onLayerAdded(_ref) {\n            var _this4 = this;\n\n            var name = _ref.name;\n\n            // Mark the layer as active if it is managed\n            if (this._managedLayers[name] !== undefined) {\n              this._managedLayers[name].isActive = true; // Detect new animations\n\n              this._host.AnimationFeature.getAnimations(name).forEach(function (animName) {\n                _this4._onAnimationAdded({\n                  layerName: name,\n                  animationName: animName\n                });\n              });\n            }\n          }\n        }, {\n          key: "_onLayerRemoved",\n          value: function _onLayerRemoved(_ref2) {\n            var _this5 = this;\n\n            var name = _ref2.name;\n\n            // Deactivate the layer if it is managed\n            if (this._managedLayers[name] !== undefined) {\n              this._managedLayers[name].isActive = false; // Deactivate the animations\n\n              Object.keys(this._managedLayers[name].animations).forEach(function (animName) {\n                _this5._onAnimationRemoved({\n                  layerName: name,\n                  animationName: animName\n                });\n              });\n            }\n          }\n        }, {\n          key: "_onLayerRenamed",\n          value: function _onLayerRenamed(_ref3) {\n            var oldName = _ref3.oldName,\n                newName = _ref3.newName;\n            var layerOptions = this._managedLayers[oldName]; // Replace the layer key with the new name\n\n            if (layerOptions !== undefined) {\n              delete this._managedLayers[oldName];\n              this._managedLayers[newName] = layerOptions;\n            }\n          }\n        }, {\n          key: "_onAnimationAdded",\n          value: function _onAnimationAdded(_ref4) {\n            var layerName = _ref4.layerName,\n                animationName = _ref4.animationName;\n\n            // Mark the animation as active if it is managed\n            if (this._managedLayers[layerName] !== undefined && this._managedLayers[layerName].animations[animationName] !== undefined) {\n              this._managedLayers[layerName].animations[animationName].isActive = true;\n            }\n          }\n        }, {\n          key: "_onAnimationRemoved",\n          value: function _onAnimationRemoved(_ref5) {\n            var layerName = _ref5.layerName,\n                animationName = _ref5.animationName;\n\n            // Deactivate the animation if it is managed\n            if (this._managedLayers[layerName] !== undefined && this._managedLayers[layerName].animations[animationName] !== undefined) {\n              this._managedLayers[layerName].animations[animationName].isActive = false;\n            }\n          }\n        }, {\n          key: "_onAnimationRenamed",\n          value: function _onAnimationRenamed(_ref6) {\n            var layerName = _ref6.layerName,\n                oldName = _ref6.oldName,\n                newName = _ref6.newName;\n\n            if (this._managedLayers[layerName] !== undefined && this._managedLayers[layerName].animations[oldName] !== undefined) {\n              // Replace the animation key with the new name\n              var animOptions = this._managedLayers[layerName].animations[oldName];\n              delete this._managedLayers[layerName].animations[oldName];\n              this._managedLayers[layerName].animations[newName] = animOptions;\n            }\n          }\n        }, {\n          key: "registerLayer",\n          value: function registerLayer(name) {\n            var _this6 = this;\n\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            // Start with default options for each new layer\n            if (this._managedLayers[name] === undefined) {\n              this._managedLayers[name] = ManagedAnimationLayerInterface_objectSpread(ManagedAnimationLayerInterface_objectSpread({}, this.constructor.DEFAULT_LAYER_OPTIONS), {}, {\n                animations: {}\n              });\n            } // Update all options except animations\n\n\n            var layerOptions = this._managedLayers[name];\n            options = ManagedAnimationLayerInterface_objectSpread({}, options);\n            var animationOptions = options.animations || {};\n            delete options.animations;\n            Object.assign(layerOptions, options); // Check whether the layer can be manipulated now\n\n            layerOptions.isActive = this._host.AnimationFeature !== undefined && this._host.AnimationFeature.layers.includes(name); // Register the animations\n\n            Object.entries(animationOptions).forEach(function (_ref7) {\n              var _ref8 = ManagedAnimationLayerInterface_slicedToArray(_ref7, 2),\n                  animName = _ref8[0],\n                  animOptions = _ref8[1];\n\n              _this6.registerAnimation(name, animName, animOptions);\n            });\n          }\n        }, {\n          key: "registerAnimation",\n          value: function registerAnimation(layerName, animationName) {\n            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n            // Register the layer if it hasn\'t been registered yet\n            if (this._managedLayers[layerName] === undefined) {\n              this.registerLayer(layerName);\n            } // Update animation options\n\n\n            var animOptions = this._managedLayers[layerName].animations[animationName] || {};\n            Object.assign(animOptions, options);\n            this._managedLayers[layerName].animations[animationName] = animOptions; // Check whether the animation can be manipulated now\n\n            this._managedLayers[layerName].animations[animationName].isActive = this._managedLayers[layerName].isActive && this._host.AnimationFeature.getAnimations(layerName).includes(animationName);\n          }\n        }, {\n          key: "setLayerWeights",\n          value: function setLayerWeights() {\n            var _this7 = this;\n\n            var nameFilter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {\n              return true;\n            };\n            var weight = arguments.length > 1 ? arguments[1] : undefined;\n            var seconds = arguments.length > 2 ? arguments[2] : undefined;\n            var easingFn = arguments.length > 3 ? arguments[3] : undefined;\n            var layerNames = Object.keys(this._managedLayers).filter(nameFilter);\n            layerNames.forEach(function (name) {\n              var layerOptions = _this7._managedLayers[name];\n\n              if (layerOptions.isActive) {\n                _this7._host.AnimationFeature.setLayerWeight(name, weight, seconds !== undefined ? seconds : layerOptions.blendTime, easingFn || layerOptions.easingFn);\n              }\n            });\n          }\n        }, {\n          key: "enable",\n          value: function enable(seconds, easingFn) {\n            this.setLayerWeights(undefined, 1, seconds, easingFn);\n          }\n        }, {\n          key: "disable",\n          value: function disable(seconds, easingFn) {\n            this.setLayerWeights(undefined, 0, seconds, easingFn);\n          }\n        }, {\n          key: "installApi",\n          value: function installApi() {\n            var api = ManagedAnimationLayerInterface_get(ManagedAnimationLayerInterface_getPrototypeOf(ManagedAnimationLayerMixin.prototype), "installApi", this).call(this);\n\n            Object.assign(api, {\n              registerLayer: this.registerLayer.bind(this),\n              registerAnimation: this.registerAnimation.bind(this),\n              setLayerWeights: this.setLayerWeights.bind(this),\n              enable: this.enable.bind(this),\n              disable: this.disable.bind(this)\n            });\n            return api;\n          }\n        }]);\n\n        return ManagedAnimationLayerMixin;\n      }(ParentClass);\n\n      Object.defineProperties(ManagedAnimationLayerMixin, {\n        DEFAULT_LAYER_OPTIONS: {\n          value: ManagedAnimationLayerInterface.DEFAULT_LAYER_OPTIONS,\n          writable: false\n        }\n      });\n      return ManagedAnimationLayerMixin;\n    }\n  }]);\n\n  return ManagedAnimationLayerInterface;\n}(animpack_AnimationFeatureDependentInterface);\n\nObject.defineProperties(ManagedAnimationLayerInterface, {\n  DEFAULT_LAYER_OPTIONS: {\n    value: {\n      blendTime: 0.5,\n      animations: {}\n    },\n    writable: false\n  }\n});\n/* harmony default export */ const animpack_ManagedAnimationLayerInterface = (ManagedAnimationLayerInterface);\n;// CONCATENATED MODULE: ./src/core/awspack/TextToSpeechFeatureDependentInterface.js\nfunction TextToSpeechFeatureDependentInterface_typeof(obj) { "@babel/helpers - typeof"; return TextToSpeechFeatureDependentInterface_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, TextToSpeechFeatureDependentInterface_typeof(obj); }\n\nfunction TextToSpeechFeatureDependentInterface_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction TextToSpeechFeatureDependentInterface_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? TextToSpeechFeatureDependentInterface_ownKeys(Object(source), !0).forEach(function (key) { TextToSpeechFeatureDependentInterface_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : TextToSpeechFeatureDependentInterface_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction TextToSpeechFeatureDependentInterface_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TextToSpeechFeatureDependentInterface_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction TextToSpeechFeatureDependentInterface_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction TextToSpeechFeatureDependentInterface_createClass(Constructor, protoProps, staticProps) { if (protoProps) TextToSpeechFeatureDependentInterface_defineProperties(Constructor.prototype, protoProps); if (staticProps) TextToSpeechFeatureDependentInterface_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction TextToSpeechFeatureDependentInterface_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) TextToSpeechFeatureDependentInterface_setPrototypeOf(subClass, superClass); }\n\nfunction TextToSpeechFeatureDependentInterface_setPrototypeOf(o, p) { TextToSpeechFeatureDependentInterface_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return TextToSpeechFeatureDependentInterface_setPrototypeOf(o, p); }\n\nfunction TextToSpeechFeatureDependentInterface_createSuper(Derived) { var hasNativeReflectConstruct = TextToSpeechFeatureDependentInterface_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = TextToSpeechFeatureDependentInterface_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = TextToSpeechFeatureDependentInterface_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return TextToSpeechFeatureDependentInterface_possibleConstructorReturn(this, result); }; }\n\nfunction TextToSpeechFeatureDependentInterface_possibleConstructorReturn(self, call) { if (call && (TextToSpeechFeatureDependentInterface_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return TextToSpeechFeatureDependentInterface_assertThisInitialized(self); }\n\nfunction TextToSpeechFeatureDependentInterface_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction TextToSpeechFeatureDependentInterface_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction TextToSpeechFeatureDependentInterface_getPrototypeOf(o) { TextToSpeechFeatureDependentInterface_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return TextToSpeechFeatureDependentInterface_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable max-classes-per-file */\n\n/**\r\n * Class factory interface for features that are dependent on the TextToSpeechFeature\r\n * being present on the host. Speech events will automatically be listened for once a\r\n * TextToSpeechFeature is added to the host and stopped once it is removed.\r\n *\r\n * @interface\r\n * @extends FeatureDependentInterface\r\n *\r\n * @property {Object} EVENT_DEPENDENCIES - Events that the feature should start/stop\r\n * listening for when a feature of type FeatureName is added/removed from the host.\r\n * @property {Object} EVENT_DEPENDENCIES.TextToSpeechFeature - Events that are\r\n * specific to the TextToSpeechFeature.\r\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.play=\'_onPlay\'] -\r\n * The name of the method that will be executed when TextToSpeechFeature play\r\n * events are emitted.\r\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.pause=\'_onPause\'] -\r\n * The name of the method that will be executed when TextToSpeechFeature pause\r\n * events are emitted.\r\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.resume=\'_onResume\'] -\r\n * The name of the method that will be executed when TextToSpeechFeature resume\r\n * events are emitted.\r\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.stop=\'_onStop\'] -\r\n * The name of the method that will be executed when TextToSpeechFeature stop\r\n * events are emitted.\r\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.sentence=\'_onSentence\'] -\r\n * The name of the method that will be executed when TextToSpeechFeature sentence\r\n * events are emitted.\r\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.word=\'_onWord\'] -\r\n * The name of the method that will be executed when TextToSpeechFeature word\r\n * events are emitted.\r\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.viseme=\'_onViseme\'] -\r\n * The name of the method that will be executed when TextToSpeechFeature viseme\r\n * events are emitted.\r\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.ssml=\'_onSsml\'] -\r\n * The name of the method that will be executed when TextToSpeechFeature ssml\r\n * events are emitted.\r\n */\n\nvar TextToSpeechFeatureDependentInterface = /*#__PURE__*/function (_FeatureDependentInte) {\n  TextToSpeechFeatureDependentInterface_inherits(TextToSpeechFeatureDependentInterface, _FeatureDependentInte);\n\n  var _super = TextToSpeechFeatureDependentInterface_createSuper(TextToSpeechFeatureDependentInterface);\n\n  function TextToSpeechFeatureDependentInterface() {\n    TextToSpeechFeatureDependentInterface_classCallCheck(this, TextToSpeechFeatureDependentInterface);\n\n    return _super.apply(this, arguments);\n  }\n\n  TextToSpeechFeatureDependentInterface_createClass(TextToSpeechFeatureDependentInterface, [{\n    key: "_onPlay",\n    value:\n    /**\r\n     * Executed when speech play events are caught.\r\n     *\r\n     * @private\r\n     */\n    function _onPlay() {}\n    /**\r\n     * Executed when speech pause events are caught.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_onPause",\n    value: function _onPause() {}\n    /**\r\n     * Executed when speech resume events are caught.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_onResume",\n    value: function _onResume() {}\n    /**\r\n     * Executed when speech stop events are caught.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_onStop",\n    value: function _onStop() {}\n    /**\r\n     * Executed when speech sentence events are caught.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_onSentence",\n    value: function _onSentence() {}\n    /**\r\n     * Executed when speech word events are caught.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_onWord",\n    value: function _onWord() {}\n    /**\r\n     * Executed when speech viseme events are caught.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_onViseme",\n    value: function _onViseme() {}\n    /**\r\n     * Executed when speech ssml events are caught.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_onSsml",\n    value: function _onSsml() {}\n    /**\r\n     * Creates a class that implements {@link TextToSpeechFeatureDependentInterface}\r\n     * and extends a specified base class.\r\n     *\r\n     * @param {Class} BaseClass - The class to extend.\r\n     *\r\n     * @return {Class} A class that extends `BaseClass` and implements {@link TextToSpeechFeatureDependentInterface}.\r\n     */\n\n  }], [{\n    key: "Mixin",\n    value: function Mixin(BaseClass) {\n      var ParentClass = core_FeatureDependentInterface.Mixin(BaseClass);\n\n      var TextToSpeechFeatureDependentMixin = /*#__PURE__*/function (_ParentClass) {\n        TextToSpeechFeatureDependentInterface_inherits(TextToSpeechFeatureDependentMixin, _ParentClass);\n\n        var _super2 = TextToSpeechFeatureDependentInterface_createSuper(TextToSpeechFeatureDependentMixin);\n\n        function TextToSpeechFeatureDependentMixin() {\n          TextToSpeechFeatureDependentInterface_classCallCheck(this, TextToSpeechFeatureDependentMixin);\n\n          return _super2.apply(this, arguments);\n        }\n\n        TextToSpeechFeatureDependentInterface_createClass(TextToSpeechFeatureDependentMixin, [{\n          key: "_onPlay",\n          value: function _onPlay() {}\n        }, {\n          key: "_onPause",\n          value: function _onPause() {}\n        }, {\n          key: "_onResume",\n          value: function _onResume() {}\n        }, {\n          key: "_onStop",\n          value: function _onStop() {}\n        }, {\n          key: "_onSentence",\n          value: function _onSentence() {}\n        }, {\n          key: "_onWord",\n          value: function _onWord() {}\n        }, {\n          key: "_onViseme",\n          value: function _onViseme() {}\n        }, {\n          key: "_onSsml",\n          value: function _onSsml() {}\n        }]);\n\n        return TextToSpeechFeatureDependentMixin;\n      }(ParentClass);\n\n      Object.defineProperties(TextToSpeechFeatureDependentMixin, {\n        EVENT_DEPENDENCIES: {\n          value: TextToSpeechFeatureDependentInterface_objectSpread(TextToSpeechFeatureDependentInterface_objectSpread({}, ParentClass.EVENT_DEPENDENCIES), TextToSpeechFeatureDependentInterface.EVENT_DEPENDENCIES),\n          writable: false\n        }\n      });\n      return TextToSpeechFeatureDependentMixin;\n    }\n  }]);\n\n  return TextToSpeechFeatureDependentInterface;\n}(core_FeatureDependentInterface);\n\nObject.defineProperties(TextToSpeechFeatureDependentInterface, {\n  EVENT_DEPENDENCIES: {\n    value: {\n      TextToSpeechFeature: {\n        play: \'_onPlay\',\n        pause: \'_onPause\',\n        resume: \'_onResume\',\n        stop: \'_onStop\',\n        sentence: \'_onSentence\',\n        word: \'_onWord\',\n        viseme: \'_onViseme\',\n        ssml: \'_onSsml\'\n      }\n    },\n    writable: false\n  }\n});\n/* harmony default export */ const awspack_TextToSpeechFeatureDependentInterface = (TextToSpeechFeatureDependentInterface);\n;// CONCATENATED MODULE: ./src/core/LipsyncFeature.js\nfunction LipsyncFeature_typeof(obj) { "@babel/helpers - typeof"; return LipsyncFeature_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, LipsyncFeature_typeof(obj); }\n\nfunction LipsyncFeature_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction LipsyncFeature_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? LipsyncFeature_ownKeys(Object(source), !0).forEach(function (key) { LipsyncFeature_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : LipsyncFeature_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction LipsyncFeature_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\nfunction LipsyncFeature_slicedToArray(arr, i) { return LipsyncFeature_arrayWithHoles(arr) || LipsyncFeature_iterableToArrayLimit(arr, i) || LipsyncFeature_unsupportedIterableToArray(arr, i) || LipsyncFeature_nonIterableRest(); }\n\nfunction LipsyncFeature_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction LipsyncFeature_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return LipsyncFeature_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return LipsyncFeature_arrayLikeToArray(o, minLen); }\n\nfunction LipsyncFeature_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction LipsyncFeature_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction LipsyncFeature_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction LipsyncFeature_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction LipsyncFeature_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction LipsyncFeature_createClass(Constructor, protoProps, staticProps) { if (protoProps) LipsyncFeature_defineProperties(Constructor.prototype, protoProps); if (staticProps) LipsyncFeature_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction LipsyncFeature_get() { if (typeof Reflect !== "undefined" && Reflect.get) { LipsyncFeature_get = Reflect.get; } else { LipsyncFeature_get = function _get(target, property, receiver) { var base = LipsyncFeature_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return LipsyncFeature_get.apply(this, arguments); }\n\nfunction LipsyncFeature_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = LipsyncFeature_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction LipsyncFeature_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) LipsyncFeature_setPrototypeOf(subClass, superClass); }\n\nfunction LipsyncFeature_setPrototypeOf(o, p) { LipsyncFeature_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return LipsyncFeature_setPrototypeOf(o, p); }\n\nfunction LipsyncFeature_createSuper(Derived) { var hasNativeReflectConstruct = LipsyncFeature_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = LipsyncFeature_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = LipsyncFeature_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return LipsyncFeature_possibleConstructorReturn(this, result); }; }\n\nfunction LipsyncFeature_possibleConstructorReturn(self, call) { if (call && (LipsyncFeature_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return LipsyncFeature_assertThisInitialized(self); }\n\nfunction LipsyncFeature_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction LipsyncFeature_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction LipsyncFeature_getPrototypeOf(o) { LipsyncFeature_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return LipsyncFeature_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n\n/**\r\n * Default mapping of Polly viseme names to animation options objects.\r\n *\r\n * @property {Object} [sil={name: \'sil\'}]\r\n * @property {Object} [p={name: \'p\', overrideWeight: 0.9}]\r\n * @property {Object} [t={name: \'t\', blendTime: 0.2}]\r\n * @property {Object} [S={name: \'S\'}]\r\n * @property {Object} [T={name: \'T\'}]\r\n * @property {Object} [f={name: \'f\', overrideWeight: 0.75}]\r\n * @property {Object} [k={name: \'k\'}]\r\n * @property {Object} [i={name: \'i\'}]\r\n * @property {Object} [r={name: \'r\'}]\r\n * @property {Object} [s={name: \'s\', blendTime: 0.25}]\r\n * @property {Object} [u={name: \'u\'}]\r\n * @property {Object} [@={name: \'@\'}]\r\n * @property {Object} [a={name: \'a\'}]\r\n * @property {Object} [e={name: \'e\', blendTime: 0.2}]\r\n * @property {Object} [E={name: \'E\'}]\r\n * @property {Object} [o={name: \'o\'}]\r\n * @property {Object} [O={name: \'O\'}]\r\n */\n\nvar DefaultVisemeMap = {\n  sil: {\n    name: \'sil\'\n  },\n  p: {\n    name: \'p\',\n    overrideWeight: 0.9\n  },\n  t: {\n    name: \'t\',\n    blendTime: 0.2\n  },\n  S: {\n    name: \'S\'\n  },\n  T: {\n    name: \'T\'\n  },\n  f: {\n    name: \'f\',\n    overrideWeight: 0.75\n  },\n  k: {\n    name: \'k\'\n  },\n  i: {\n    name: \'i\'\n  },\n  r: {\n    name: \'r\'\n  },\n  s: {\n    name: \'s\',\n    blendTime: 0.25\n  },\n  u: {\n    name: \'u\'\n  },\n  \'@\': {\n    name: \'@\'\n  },\n  a: {\n    name: \'a\'\n  },\n  e: {\n    name: \'e\',\n    blendTime: 0.2\n  },\n  E: {\n    name: \'E\'\n  },\n  o: {\n    name: \'o\'\n  },\n  O: {\n    name: \'O\'\n  }\n};\n/**\r\n * Lipsync controls two types of movement: idle animation that should play while\r\n * speech is playing and viseme animations corresponding to Polly visemes whose\r\n * weights should be turned on and off as they are encountered in the Polly SSML\r\n * transcript. Layers owned by this feature will be enabled while speech is playing\r\n * and disabled once it stops.\r\n *\r\n * @extends AbstractHostFeature\r\n * @alias core/LipsyncFeature\r\n * @implements TextToSpeechFeatureDependentInterface\r\n * @implements ManagedAnimationLayerInterface\r\n */\n\nvar LipsyncFeature = /*#__PURE__*/function (_AbstractHostFeature$) {\n  LipsyncFeature_inherits(LipsyncFeature, _AbstractHostFeature$);\n\n  var _super = LipsyncFeature_createSuper(LipsyncFeature);\n\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {core/HostObject} host - Host that owns the feature.\r\n   * @param {Object=} visemeOptions - Options for the viseme layers.\r\n   * @param {number} [visemeOptions.blendTime=0.15] - Default amount of time it\r\n   * will take to manipulate each freeBlend weight on the viseme states.\r\n   * @param {Object} [visemeOptions.decayRate={amount: .5, seconds: .5}] - An object\r\n   * describing the 0-1 factor viseme weight will decay if the viseme duration is\r\n   * longer than the blendTime and the number of seconds it would take to decay\r\n   * by that factor.\r\n   * @param {number} [visemeOptions.easingFn=Quadratic.InOut] - Default easing function\r\n   * to use when manipulating viseme freeBlend weights.\r\n   * @param {Array.<Object>} [visemeOptions..layers=[]] - An array of layer options\r\n   * objects to register as viseme layers.\r\n   * @param {Object=} talkingOptions - Options for the talking layers.\r\n   * @param {number} [talkingOptions.blendTime=0.75] - Default amount of time to\r\n   * enable and disable the talking idle layers\r\n   * @param {number} [talkingOptions.easingFn=Quadratic.InOut] - Default easing\r\n   * function to use when manipulating weights on the talking idle layers.\r\n   * @param {Array.<Object>} [talkingOptions.layers=[]] - An array of layer options\r\n   * objects to register as talking layers.\r\n   * @param {number} [visemeLeadTime=.067] - The amount of time to instruct the\r\n   * TextToSpeechFeature to emit speechmarks before each one\'s actual timestamp\r\n   * is reached. This will set the \'speechMarkOffset\' variable on the TextToSpeechFeature.\r\n   */\n  function LipsyncFeature(host) {\n    var _this;\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$blendTime = _ref.blendTime,\n        visemeBlendTime = _ref$blendTime === void 0 ? 0.15 : _ref$blendTime,\n        _ref$decayRate = _ref.decayRate;\n\n    _ref$decayRate = _ref$decayRate === void 0 ? {} : _ref$decayRate;\n    var _ref$decayRate$amount = _ref$decayRate.amount,\n        amount = _ref$decayRate$amount === void 0 ? 0.5 : _ref$decayRate$amount,\n        _ref$decayRate$second = _ref$decayRate.seconds,\n        seconds = _ref$decayRate$second === void 0 ? 0.5 : _ref$decayRate$second,\n        _ref$easingFn = _ref.easingFn,\n        visemeEasingFn = _ref$easingFn === void 0 ? Quadratic.InOut : _ref$easingFn,\n        _ref$layers = _ref.layers,\n        visemeLayers = _ref$layers === void 0 ? [] : _ref$layers;\n\n    var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref2$blendTime = _ref2.blendTime,\n        talkingBlendTime = _ref2$blendTime === void 0 ? 0.75 : _ref2$blendTime,\n        _ref2$easingFn = _ref2.easingFn,\n        talkingEasingFn = _ref2$easingFn === void 0 ? Quadratic.InOut : _ref2$easingFn,\n        _ref2$layers = _ref2.layers,\n        talkingLayers = _ref2$layers === void 0 ? [] : _ref2$layers;\n\n    var visemeLeadTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.067;\n\n    LipsyncFeature_classCallCheck(this, LipsyncFeature);\n\n    _this = _super.call(this, host);\n    _this._visemeLayers = {};\n    _this._talkingLayers = {};\n    _this.visemeLeadTime = visemeLeadTime; // Register the viseme layers\n\n    visemeLayers.forEach(function (_ref3) {\n      var name = _ref3.name,\n          animation = _ref3.animation,\n          _ref3$visemeMap = _ref3.visemeMap,\n          visemeMap = _ref3$visemeMap === void 0 ? DefaultVisemeMap : _ref3$visemeMap;\n\n      _this.registerVisemeLayer(name, {\n        animation: animation,\n        visemeMap: visemeMap,\n        decayRate: {\n          amount: amount,\n          seconds: seconds\n        },\n        blendTime: visemeBlendTime,\n        easingFn: visemeEasingFn\n      });\n    }); // Register the talking layers\n\n    talkingLayers.forEach(function (_ref4) {\n      var name = _ref4.name,\n          animation = _ref4.animation;\n\n      _this.registerTalkingLayer(name, {\n        animation: animation,\n        blendTime: talkingBlendTime,\n        easingFn: talkingEasingFn\n      });\n    });\n    return _this;\n  }\n  /**\r\n   * Ensure that registered viseme animations are FreeBlendStates.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} layerName - Name of the layer that contains the viseme animation.\r\n   * @param {string} animationName - Name of the animation.\r\n   */\n\n\n  LipsyncFeature_createClass(LipsyncFeature, [{\n    key: "_registerVisemeAnimation",\n    value: function _registerVisemeAnimation(layerName, animationName) {\n      if (this._managedLayers[layerName].animations[animationName].isActive) {\n        if (this._host.AnimationFeature.getAnimationType(layerName, animationName) !== \'freeBlend\') {\n          // Warn and deactivate if the registered state is not freeBlend\n          console.warn("Cannot register Lipsync viseme animation ".concat(animationName, " on layer ").concat(layerName, " for host ").concat(this._host.id, ". Viseme animations must be of type \'freeBlend\'."));\n          this._managedLayers[layerName].animations[animationName].isActive = false;\n        } else {\n          // Check if the blendWeights can be manipulated now\n          var weightNames = this._host.AnimationFeature.getAnimationBlendNames(layerName, animationName);\n\n          var visemeMap = this._managedLayers[layerName].animations[animationName].visemeMap;\n          Object.values(visemeMap).forEach(function (visemeOptions) {\n            visemeOptions.isActive = weightNames.includes(visemeOptions.name);\n          });\n        }\n      }\n    }\n    /**\r\n     * If the added feature is TextToSpeech, update its speechMarkOffset variable.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} typeName - Name of the type of feature that was added.\r\n     */\n\n  }, {\n    key: "_onFeatureAdded",\n    value: function _onFeatureAdded(typeName) {\n      this._visemeLayers = this._visemeLayers || {};\n      this._talkingLayers = this._talkingLayers || {};\n\n      LipsyncFeature_get(LipsyncFeature_getPrototypeOf(LipsyncFeature.prototype), "_onFeatureAdded", this).call(this, typeName);\n\n      if (typeName === \'TextToSpeechFeature\') {\n        this._host.TextToSpeechFeature.speechmarkOffset = -this._visemeLeadTime || 0;\n      }\n    }\n  }, {\n    key: "_onLayerAdded",\n    value: function _onLayerAdded(_ref5) {\n      var name = _ref5.name;\n\n      LipsyncFeature_get(LipsyncFeature_getPrototypeOf(LipsyncFeature.prototype), "_onLayerAdded", this).call(this, {\n        name: name\n      }); // Validate the viseme animation\n\n\n      if (this._visemeLayers[name] !== undefined) {\n        this._registerVisemeAnimation(name, this._visemeLayers[name]);\n      }\n    }\n  }, {\n    key: "_onAnimationAdded",\n    value: function _onAnimationAdded(_ref6) {\n      var layerName = _ref6.layerName,\n          animationName = _ref6.animationName;\n\n      LipsyncFeature_get(LipsyncFeature_getPrototypeOf(LipsyncFeature.prototype), "_onAnimationAdded", this).call(this, {\n        layerName: layerName\n      }); // Validate the viseme animation\n\n\n      if (this._visemeLayers[layerName] === animationName) {\n        this._registerVisemeAnimation(layerName, this._visemeLayers[layerName]);\n      }\n    }\n  }, {\n    key: "_onPlay",\n    value: function _onPlay() {\n      var _this2 = this;\n\n      // Turn on the layer weights\n      this.enable(); // Set the current animations\n\n      [this._visemeLayers, this._talkingLayers].forEach(function (layers) {\n        Object.entries(layers).forEach(function (_ref7) {\n          var _ref8 = LipsyncFeature_slicedToArray(_ref7, 2),\n              layerName = _ref8[0],\n              animationName = _ref8[1];\n\n          if (_this2._managedLayers[layerName].animations[animationName].isActive) {\n            _this2._host.AnimationFeature.resumeAnimation(layerName, animationName);\n          }\n        });\n      });\n    }\n  }, {\n    key: "_onPause",\n    value: function _onPause() {\n      this._onStop();\n    }\n  }, {\n    key: "_onResume",\n    value: function _onResume() {\n      this._onPlay();\n    }\n  }, {\n    key: "_onStop",\n    value: function _onStop() {\n      var _this3 = this;\n\n      // Turn off the layer weights\n      this.disable(); // Pause the current animations\n\n      [this._visemeLayers, this._talkingLayers].forEach(function (layers) {\n        Object.entries(layers).forEach(function (_ref9) {\n          var _ref10 = LipsyncFeature_slicedToArray(_ref9, 2),\n              layerName = _ref10[0],\n              animationName = _ref10[1];\n\n          if (_this3._managedLayers[layerName].animations[animationName].isActive) {\n            _this3._host.AnimationFeature.pauseAnimation(layerName, animationName);\n          }\n        });\n      });\n    }\n    /**\r\n     * When viseme events are caught, turn on weight of the new viseme for the duration\r\n     * of the speech mark, then turn weight back off.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {Object} event - Event data passed from the speech.\r\n     * @param {Object} event.mark - Speechmark object.\r\n     */\n\n  }, {\n    key: "_onViseme",\n    value: function () {\n      var _onViseme2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref11) {\n        var _this4 = this;\n\n        var mark;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                mark = _ref11.mark;\n                Object.entries(this._visemeLayers).forEach(function (_ref12) {\n                  var _ref13 = LipsyncFeature_slicedToArray(_ref12, 2),\n                      layerName = _ref13[0],\n                      animName = _ref13[1];\n\n                  // Make sure the layer can be manipulated\n                  var _this4$_managedLayers = _this4._managedLayers[layerName].animations[animName],\n                      isActive = _this4$_managedLayers.isActive,\n                      visemeMap = _this4$_managedLayers.visemeMap;\n\n                  if (!isActive) {\n                    return;\n                  } // Take variables from the viseme if they exist and default to the layer\n\n\n                  var _this4$_managedLayers2 = LipsyncFeature_objectSpread(LipsyncFeature_objectSpread({}, _this4._managedLayers[layerName]), visemeMap[mark.value]),\n                      viseme = _this4$_managedLayers2.name,\n                      isVisemeActive = _this4$_managedLayers2.isActive,\n                      decayRate = _this4$_managedLayers2.decayRate,\n                      blendTime = _this4$_managedLayers2.blendTime,\n                      easingFn = _this4$_managedLayers2.easingFn,\n                      overrideWeight = _this4$_managedLayers2.overrideWeight;\n\n                  var visemeNames = _this4._host.AnimationFeature.getAnimationBlendNames(layerName, animName); // Make sure the new viseme has an active freeBlend weight\n\n\n                  if (!isVisemeActive || !visemeNames.includes(viseme)) {\n                    return;\n                  } // Find the peak weight for the viseme and the amount of time it should\n                  // take to reach it\n\n\n                  var weight = 1;\n                  var duration = mark.duration / 1000;\n\n                  if (duration < blendTime) {\n                    var lerpFactor = blendTime > 0 ? duration / blendTime : 1;\n                    weight = overrideWeight !== undefined ? overrideWeight : core_MathUtils.lerp(0, 1, lerpFactor);\n                  }\n\n                  var blendInTime = Math.min(duration, blendTime); // Find the amount and time viseme will be held for\n\n                  var holdTime = duration - blendTime;\n\n                  if (holdTime < 0) {\n                    // Perform in -> out animation\n                    _this4._animateSimpleViseme(layerName, animName, viseme, weight, blendInTime, blendTime, easingFn);\n                  } else {\n                    var _lerpFactor = decayRate.seconds > 0 ? holdTime / decayRate.seconds : 1; // Perform in -> hold -> out animation\n\n\n                    var decayWeight = core_MathUtils.lerp(weight, weight * decayRate.amount, Math.min(1, _lerpFactor));\n\n                    _this4._animateHeldViseme(layerName, animName, viseme, weight, decayWeight, blendInTime, holdTime, blendTime, easingFn);\n                  }\n                });\n\n              case 2:\n              case "end":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _onViseme(_x) {\n        return _onViseme2.apply(this, arguments);\n      }\n\n      return _onViseme;\n    }()\n    /**\r\n     * Animate a viseme blend weight towards a value and then back to zero.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} layerName - Name of the layer that contains the viseme.\r\n     * @param {string} animName - Name of the freeblend animation that contains\r\n     * the viseme.\r\n     * @param {string} visemeName - Name of the blend weight to manipulate.\r\n     * @param {number} weight - Peak weight to animate towards.\r\n     * @param {number} blendInTime - Amount of time it should take to reach the\r\n     * peak weight.\r\n     * @param {number} blendOutTime - Amount of time it should take to animate back\r\n     * to zero after reaching the peak weight.\r\n     * @param {Function} easingFn - Easing function to use during animation.\r\n     */\n\n  }, {\n    key: "_animateSimpleViseme",\n    value: function _animateSimpleViseme(layerName, animName, visemeName, peakWeight, blendInTime, blendOutTime, easingFn) {\n      var _this5 = this;\n\n      // Animate towards the peak value\n      var weightPromise = this._host.AnimationFeature.setAnimationBlendWeight(layerName, animName, visemeName, peakWeight, blendInTime, easingFn); // Animate back to zero if there was no weight interruption\n\n\n      weightPromise.then(function () {\n        if (!weightPromise.canceled) {\n          _this5._host.AnimationFeature.setAnimationBlendWeight(layerName, animName, visemeName, 0, blendOutTime, easingFn);\n        }\n      });\n    }\n    /**\r\n     * Animate a viseme blend weight towards a value and then back to zero.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} layerName - Name of the layer that contains the viseme.\r\n     * @param {string} animName - Name of the freeblend animation that contains\r\n     * the viseme.\r\n     * @param {string} visemeName - Name of the blend weight to manipulate.\r\n     * @param {number} peakWeight - Peak weight to animate towards.\r\n     * @param {number} decayWeight - Weight to animate towards after reaching the\r\n     * peak weight.\r\n     * @param {number} blendInTime - Amount of time it should take to reach the\r\n     * peak weight.\r\n     * @param {number} holdTime - Amount of time it should take to reach the decay\r\n     * weight after the peak weight has been reached.\r\n     * @param {number} blendOutTime - Amount of time it should take to animate back\r\n     * to zero after reaching the decay weight.\r\n     * @param {Function} easingFn - Easing function to use during animation.\r\n     */\n\n  }, {\n    key: "_animateHeldViseme",\n    value: function () {\n      var _animateHeldViseme2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(layerName, animName, visemeName, peakWeight, decayWeight, blendInTime, holdTime, blendOutTime, easingFn) {\n        var startPromise, holdPromise;\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                // Animate towards the peak value\n                startPromise = this._host.AnimationFeature.setAnimationBlendWeight(layerName, animName, visemeName, peakWeight, blendInTime, easingFn);\n                _context2.next = 3;\n                return startPromise;\n\n              case 3:\n                if (startPromise.canceled) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                // Animate towards the decay value if there was no weight interruption\n                holdPromise = this._host.AnimationFeature.setAnimationBlendWeight(layerName, animName, visemeName, decayWeight, holdTime, easingFn);\n                _context2.next = 7;\n                return holdPromise;\n\n              case 7:\n                if (!holdPromise.canceled) {\n                  // Animate back to zero if there was no weight interruption\n                  this._host.AnimationFeature.setAnimationBlendWeight(layerName, animName, visemeName, 0, blendOutTime, easingFn);\n                }\n\n              case 8:\n              case "end":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _animateHeldViseme(_x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9, _x10) {\n        return _animateHeldViseme2.apply(this, arguments);\n      }\n\n      return _animateHeldViseme;\n    }()\n    /**\r\n     * Gets and sets the amount of time in seconds to negatively offset speechmark\r\n     * emission by.\r\n     *\r\n     * @type {number}\r\n     */\n\n  }, {\n    key: "visemeLeadTime",\n    get: function get() {\n      return this._visemeLeadTime;\n    },\n    set: function set(seconds) {\n      this._visemeLeadTime = seconds;\n\n      if (this._host.TextToSpeechFeature) {\n        this._host.TextToSpeechFeature.speechmarkOffset = -seconds;\n      }\n    }\n    /**\r\n     * Start keeping track of an animation layer that owns a freeBlend animation\r\n     * with blendWeights corresponding to visemes.\r\n     *\r\n     * @param {string} layerName - Name of the layer to keep track of.\r\n     * @param {Object=} options - Options for the layer.\r\n     * @param {string} [options.animation=\'visemes\'] - Name of the animation on the\r\n     * layer that will be played during speech. This animation must be of type\r\n     * freeBlend.\r\n     * @param {Object=} decayRate\r\n     * @param {number} [decayRate.amount=0.5] - The percentage to decrease the viseme\'s\r\n     * peak value by over time once the peak value has been reached.\r\n     * @param {number} [decayRate.seconds=0.5] - The amount of time in seconds to\r\n     * decrease the viseme\'s weight once it has reached its peak value.\r\n     * @param {number=} [options.blendTime=[LipsyncFeature.DEFAULT_LAYER_OPTIONS.blendTime]{@link LipsyncFeature#DEFAULT_LAYER_OPTIONS#blendTime}] -\r\n     * Default amount of time to use when manipulating animation blendWeights.\r\n     * @param {Function=} options.easingFn - Default easing function to use when\r\n     * manipulating animation blendWeights.\r\n     * @param {Object} [options.visemeMap=DefaultVisemeMap] - Object containing key/value pairs of\r\n     * Polly viseme names mapped to objects containing the name of the corresponding\r\n     * animation blendWeight and any other animation options to use such as viseme\r\n     * specific blend times and easing functions.\r\n     */\n\n  }, {\n    key: "registerVisemeLayer",\n    value: function registerVisemeLayer(layerName) {\n      var _ref14 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref14$animation = _ref14.animation,\n          animation = _ref14$animation === void 0 ? \'visemes\' : _ref14$animation,\n          _ref14$decayRate = _ref14.decayRate,\n          decayRate = _ref14$decayRate === void 0 ? {\n        amount: 0.5,\n        seconds: 0.5\n      } : _ref14$decayRate,\n          _ref14$blendTime = _ref14.blendTime,\n          blendTime = _ref14$blendTime === void 0 ? LipsyncFeature.DEFAULT_LAYER_OPTIONS.blendTime : _ref14$blendTime,\n          easingFn = _ref14.easingFn,\n          _ref14$visemeMap = _ref14.visemeMap,\n          visemeMap = _ref14$visemeMap === void 0 ? DefaultVisemeMap : _ref14$visemeMap;\n\n      // Register the layer and animation\n      this.registerLayer(layerName, {\n        decayRate: decayRate,\n        blendTime: blendTime,\n        easingFn: easingFn,\n        animations: LipsyncFeature_defineProperty({}, animation, {\n          visemeMap: visemeMap\n        })\n      });\n      this._visemeLayers[layerName] = animation; // Validate the viseme animation\n\n      this._registerVisemeAnimation(layerName, animation);\n    }\n    /**\r\n     * Start keeping track of an animation layer that contains a looping animation\r\n     * to be played during speech.\r\n     *\r\n     * @param {string} layerName - Name of the layer to keep track of.\r\n     * @param {Object=} options - Options for the layer.\r\n     * @param {string} [options.animation=\'stand_talk\'] - Name of the animation on the\r\n     * layer that will be played during speech.\r\n     * @param {number} [options.blendTime=[LipsyncFeature.DEFAULT_LAYER_OPTIONS.blendTime]{@link LipsyncFeature#DEFAULT_LAYER_OPTIONS#blendTime}] -\r\n     * Default amount of time to use when manipulating the layer\'s weights.\r\n     * @param {Function=} options.easingFn - Default easing function to use when\r\n     * manipulating the layer\'s weights.\r\n     */\n\n  }, {\n    key: "registerTalkingLayer",\n    value: function registerTalkingLayer(layerName) {\n      var _ref15 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref15$animation = _ref15.animation,\n          animation = _ref15$animation === void 0 ? \'stand_talk\' : _ref15$animation,\n          _ref15$blendTime = _ref15.blendTime,\n          blendTime = _ref15$blendTime === void 0 ? LipsyncFeature.DEFAULT_LAYER_OPTIONS.blendTime : _ref15$blendTime,\n          easingFn = _ref15.easingFn;\n\n      // Register the layer and animation\n      this.registerLayer(layerName, {\n        blendTime: blendTime,\n        easingFn: easingFn,\n        animations: LipsyncFeature_defineProperty({}, animation, {})\n      });\n      this._talkingLayers[layerName] = animation;\n    }\n    /**\r\n     * Adds a namespace to the host with the name of the feature to contain properties\r\n     * and methods from the feature that users of the host need access to.\r\n     *\r\n     * @see LipsyncFeature\r\n     */\n\n  }, {\n    key: "installApi",\n    value: function installApi() {\n      var _this6 = this;\n\n      /**\r\n       * @inner\r\n       * @namespace LipsyncFeature\r\n       */\n      var api = LipsyncFeature_get(LipsyncFeature_getPrototypeOf(LipsyncFeature.prototype), "installApi", this).call(this);\n      /**\r\n       * @memberof LipsyncFeature\r\n       * @name registerLayer\r\n       * @instance\r\n       * @method\r\n       * @see ManagedAnimationLayerInterface#registerLayer\r\n       */\n\n      /**\r\n       * @memberof LipsyncFeature\r\n       * @name registerAnimation\r\n       * @instance\r\n       * @method\r\n       * @see ManagedAnimationLayerInterface#registerAnimation\r\n       */\n\n      /**\r\n       * @memberof LipsyncFeature\r\n       * @name setLayerWeights\r\n       * @instance\r\n       * @method\r\n       * @see ManagedAnimationLayerInterface#setLayerWeights\r\n       */\n\n      /**\r\n       * @memberof LipsyncFeature\r\n       * @name enable\r\n       * @instance\r\n       * @method\r\n       * @see ManagedAnimationLayerInterface#enable\r\n       */\n\n      /**\r\n       * @memberof LipsyncFeature\r\n       * @name disable\r\n       * @instance\r\n       * @method\r\n       * @see ManagedAnimationLayerInterface#disable\r\n       */\n\n\n      Object.assign(api, {\n        /**\r\n         * @memberof LipsyncFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/LipsyncFeature#registerVisemeLayer\r\n         */\n        registerVisemeLayer: this.registerVisemeLayer.bind(this),\n\n        /**\r\n         * @memberof LipsyncFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/LipsyncFeature#registerTalkingLayer\r\n         */\n        registerTalkingLayer: this.registerTalkingLayer.bind(this)\n      });\n      /**\r\n       * @memberof LipsyncFeature\r\n       * @instance\r\n       * @name visemeLeadTime\r\n       * @see core/LipsyncFeature#visemeLeadTime\r\n       */\n\n      Object.defineProperty(api, \'visemeLeadTime\', {\n        get: function get() {\n          return _this6.visemeLeadTime;\n        },\n        set: function set(seconds) {\n          _this6.visemeLeadTime = seconds;\n        }\n      });\n      return api;\n    }\n  }]);\n\n  return LipsyncFeature;\n}(core_AbstractHostFeature.mix(awspack_TextToSpeechFeatureDependentInterface.Mixin, animpack_ManagedAnimationLayerInterface.Mixin));\n\n/* harmony default export */ const core_LipsyncFeature = (LipsyncFeature);\n\n;// CONCATENATED MODULE: ./src/core/awspack/SSMLSpeechmarkInterface.js\nfunction SSMLSpeechmarkInterface_typeof(obj) { "@babel/helpers - typeof"; return SSMLSpeechmarkInterface_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, SSMLSpeechmarkInterface_typeof(obj); }\n\nfunction SSMLSpeechmarkInterface_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction SSMLSpeechmarkInterface_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction SSMLSpeechmarkInterface_createClass(Constructor, protoProps, staticProps) { if (protoProps) SSMLSpeechmarkInterface_defineProperties(Constructor.prototype, protoProps); if (staticProps) SSMLSpeechmarkInterface_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction SSMLSpeechmarkInterface_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) SSMLSpeechmarkInterface_setPrototypeOf(subClass, superClass); }\n\nfunction SSMLSpeechmarkInterface_setPrototypeOf(o, p) { SSMLSpeechmarkInterface_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return SSMLSpeechmarkInterface_setPrototypeOf(o, p); }\n\nfunction SSMLSpeechmarkInterface_createSuper(Derived) { var hasNativeReflectConstruct = SSMLSpeechmarkInterface_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = SSMLSpeechmarkInterface_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = SSMLSpeechmarkInterface_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return SSMLSpeechmarkInterface_possibleConstructorReturn(this, result); }; }\n\nfunction SSMLSpeechmarkInterface_possibleConstructorReturn(self, call) { if (call && (SSMLSpeechmarkInterface_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return SSMLSpeechmarkInterface_assertThisInitialized(self); }\n\nfunction SSMLSpeechmarkInterface_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction SSMLSpeechmarkInterface_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction SSMLSpeechmarkInterface_getPrototypeOf(o) { SSMLSpeechmarkInterface_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return SSMLSpeechmarkInterface_getPrototypeOf(o); }\n\n/* eslint-disable no-unused-vars */\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable max-classes-per-file */\n\n/* eslint-disable no-empty */\n\n/**\r\n * Class factory interface for that registers callback method when a ssml speechmark event is emitted.\r\n *\r\n * @interface\r\n * @extends TextToSpeechFeatureDependentInterface\r\n */\n\nvar SSMLSpeechmarkInterface = /*#__PURE__*/function (_TextToSpeechFeatureD) {\n  SSMLSpeechmarkInterface_inherits(SSMLSpeechmarkInterface, _TextToSpeechFeatureD);\n\n  var _super = SSMLSpeechmarkInterface_createSuper(SSMLSpeechmarkInterface);\n\n  function SSMLSpeechmarkInterface() {\n    SSMLSpeechmarkInterface_classCallCheck(this, SSMLSpeechmarkInterface);\n\n    return _super.apply(this, arguments);\n  }\n\n  SSMLSpeechmarkInterface_createClass(SSMLSpeechmarkInterface, [{\n    key: "_onSsml",\n    value:\n    /**\r\n     * When ssml events are caught, this will try to parse the speech mark value and execute any function which meets criteria defined in the value.\r\n     * Speech mark value will be treated as stringified json format containing required feature name, function name and argument array to pass in.\r\n     * Example speech mark value might look like: \'{"feature":"GestureFeature", "method":"switchToGesture", "args":["genricA", 0.5]}\'\r\n     *\r\n     * @private\r\n     *\r\n     * @param {Object} event - Event data passed from the speech.\r\n     * @param {Object} event.mark - Speechmark object.\r\n     */\n    function _onSsml(_ref) {\n      var mark = _ref.mark;\n    }\n    /**\r\n     * Creates a class that implements {@link SSMLSpeechmarkInterface}\r\n     * and extends a specified base class.\r\n     *\r\n     * @param {Class} BaseClass - The class to extend.\r\n     *\r\n     * @return {Class} A class that extends `BaseClass` and implements {@link SSMLSpeechmarkInterface}.\r\n     */\n\n  }], [{\n    key: "Mixin",\n    value: function Mixin(BaseClass) {\n      var ParentClass = awspack_TextToSpeechFeatureDependentInterface.Mixin(BaseClass);\n\n      var SSMLSpeechMarkMixin = /*#__PURE__*/function (_ParentClass) {\n        SSMLSpeechmarkInterface_inherits(SSMLSpeechMarkMixin, _ParentClass);\n\n        var _super2 = SSMLSpeechmarkInterface_createSuper(SSMLSpeechMarkMixin);\n\n        function SSMLSpeechMarkMixin() {\n          SSMLSpeechmarkInterface_classCallCheck(this, SSMLSpeechMarkMixin);\n\n          return _super2.apply(this, arguments);\n        }\n\n        SSMLSpeechmarkInterface_createClass(SSMLSpeechMarkMixin, [{\n          key: "_onSsml",\n          value: function _onSsml(_ref2) {\n            var mark = _ref2.mark;\n\n            try {\n              var _JSON$parse = JSON.parse(mark.value),\n                  feature = _JSON$parse.feature,\n                  method = _JSON$parse.method,\n                  args = _JSON$parse.args;\n\n              if (this.constructor.name === feature) {\n                var callback = this[method];\n\n                if (callback && typeof callback === \'function\') {\n                  callback.apply(this, args);\n                } else {\n                  console.warn("Function ".concat(method, " does not exist within feature ").concat(feature));\n                }\n              }\n            } catch (e) {}\n          }\n        }]);\n\n        return SSMLSpeechMarkMixin;\n      }(ParentClass);\n\n      return SSMLSpeechMarkMixin;\n    }\n  }]);\n\n  return SSMLSpeechmarkInterface;\n}(awspack_TextToSpeechFeatureDependentInterface);\n\n/* harmony default export */ const awspack_SSMLSpeechmarkInterface = (SSMLSpeechmarkInterface);\n;// CONCATENATED MODULE: ./src/core/GestureFeature.js\nfunction GestureFeature_typeof(obj) { "@babel/helpers - typeof"; return GestureFeature_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, GestureFeature_typeof(obj); }\n\nfunction GestureFeature_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction GestureFeature_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? GestureFeature_ownKeys(Object(source), !0).forEach(function (key) { GestureFeature_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : GestureFeature_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction GestureFeature_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction GestureFeature_slicedToArray(arr, i) { return GestureFeature_arrayWithHoles(arr) || GestureFeature_iterableToArrayLimit(arr, i) || GestureFeature_unsupportedIterableToArray(arr, i) || GestureFeature_nonIterableRest(); }\n\nfunction GestureFeature_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction GestureFeature_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return GestureFeature_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return GestureFeature_arrayLikeToArray(o, minLen); }\n\nfunction GestureFeature_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction GestureFeature_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction GestureFeature_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction GestureFeature_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction GestureFeature_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction GestureFeature_createClass(Constructor, protoProps, staticProps) { if (protoProps) GestureFeature_defineProperties(Constructor.prototype, protoProps); if (staticProps) GestureFeature_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction GestureFeature_get() { if (typeof Reflect !== "undefined" && Reflect.get) { GestureFeature_get = Reflect.get; } else { GestureFeature_get = function _get(target, property, receiver) { var base = GestureFeature_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return GestureFeature_get.apply(this, arguments); }\n\nfunction GestureFeature_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = GestureFeature_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction GestureFeature_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) GestureFeature_setPrototypeOf(subClass, superClass); }\n\nfunction GestureFeature_setPrototypeOf(o, p) { GestureFeature_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return GestureFeature_setPrototypeOf(o, p); }\n\nfunction GestureFeature_createSuper(Derived) { var hasNativeReflectConstruct = GestureFeature_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = GestureFeature_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = GestureFeature_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return GestureFeature_possibleConstructorReturn(this, result); }; }\n\nfunction GestureFeature_possibleConstructorReturn(self, call) { if (call && (GestureFeature_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return GestureFeature_assertThisInitialized(self); }\n\nfunction GestureFeature_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction GestureFeature_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction GestureFeature_getPrototypeOf(o) { GestureFeature_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return GestureFeature_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n\nvar DefaultGestureWords = {\n  big: [\'add\', \'above\', \'authority\', \'big\', \'cover\', \'full\', \'fly\', \'grow\', \'growth\', \'high\', \'huge\', \'increase\', \'major\', \'majority\', \'large\', \'leader\', \'lot\', \'raise\', \'rise\', \'tall\'],\n  heart: [\'accept\', \'admit\', \'believe\', \'care\', \'feeling\', \'feel\', \'friend\', \'grateful\', \'happy\', \'heart\', \'human\', \'pain\', \'save\', \'safe\', \'kind\', \'love\'],\n  "in": [\'include\', \'including\', \'inside\', \'into\', \'now\', \'near\', \'nearest\', \'closest\', \'therein\', \'within\'],\n  many: [\'all\', \'always\', \'any\', \'anyone\', \'among\', \'area\', \'around\', \'beautiful\', \'entire\', \'environment\', \'environments\', \'environmental\', \'everybody\', \'everyone\', \'everything\', \'audience\', \'total\', \'group\', \'groups\', \'million\', \'millions\', \'others\', \'billion\', \'billions\', \'hundred\', \'hundreds\', \'many\', \'thousand\', \'thousands\', \'world\', \'worlds\', \'outside\', \'reveal\'],\n  movement: [\'away\', \'across\', \'ahead\', \'along\', \'far\', \'fast\', \'follow\', \'go\', \'leave\', \'move\', \'movement\', \'through\', \'throughout\', \'toward\', \'travel\', \'turned\', \'passed\'],\n  one: [\'single\', \'one\', \'once\', \'first\', \'firstly\', \'only\', \'solo\', \'warned\', \'truly\', \'up\', \'alone\'],\n  aggressive: [\'power\', \'powers\', \'powerful\', \'assert\', \'assertive\', \'strong\', \'stronger\', \'strongest\', \'strength\', \'flex\', \'dang\', \'damn\', \'damnit\', \'darn\', \'shucks\', \'doh\', \'drat\', \'angry\', \'angrier\', \'angriest\', \'aggressive\', \'annoyed\', \'annoying\', \'attack\', \'attacking\', \'offense\', \'offensive\', \'battle\'],\n  you: [\'you\', \'yall\', "y\'all", \'your\', \'yours\', \'thou\', \'thy\'],\n  defense: [\'defense\', \'fear\', \'repulsed\', \'scared\', \'scary\', \'scarier\', \'scariest\', \'fearful\', \'afraid\', \'cower\', \'cowers\', \'cowering\', \'hideous\', \'doomed\', \'terrified\', \'terrify\', \'terrifying\', \'terrifies\', \'spooky\', \'spookier\', \'spookiest\'],\n  wave: [\'hello\', \'hi\', \'hiya\', \'howdy\', \'welcome\', \'aloha\', \'heya\', \'hey\', \'bye\', \'goodbye\', \'hola\', \'adios\', \'chao\'],\n  self: [\'my\', \'I\', \'myself\', \'self\', "I\'ve", \'Ive\', \'me\', \'mine\', \'own\']\n};\n/**\r\n * Gesture allows you to play animations on demand on one or more layers from script\r\n * or ssml. If gesture is played that is a QueueState, the queue will automatically\r\n * be progressed after a given hold time if a looping queued state is reached. Gesture\r\n * layers can optionally be automatically disabled when no gesture animation is\r\n * in progress.\r\n *\r\n * @extends AbstractHostFeature\r\n * @implements SSMLSpeechmarkInterface\r\n * @implements ManagedAnimationLayerInterface\r\n */\n\nvar GestureFeature = /*#__PURE__*/function (_AbstractHostFeature$) {\n  GestureFeature_inherits(GestureFeature, _AbstractHostFeature$);\n\n  var _super = GestureFeature_createSuper(GestureFeature);\n\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {core/HostObject} host - Host object that owns the feature.\r\n   * @param {Object=} options - Optional options for the feature.\r\n   * @param {number} [options.holdTime = 3] - Amount of time in seconds that must\r\n   * elapse before advancing a gesture that\'s a {@link QueueState} when the current\r\n   * state in the queue is set to loop infinitely.\r\n   * @param {number} [options.minimumInterval = 0.25] - The minimum amount of time\r\n   * in seconds that must elapse before another gesture can be played.\r\n   * @param  {Object} layers - An object that maps layer names to layer options.\r\n   * These are the layers that will be registered as tracked gesture layers. See\r\n   * {@link ManagedAnimationLayerInterface#registerLayer} for more information\r\n   * on expected format for each layer options object.\r\n   */\n  function GestureFeature(host) {\n    var _this;\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$holdTime = _ref.holdTime,\n        holdTime = _ref$holdTime === void 0 ? 3 : _ref$holdTime,\n        _ref$minimumInterval = _ref.minimumInterval,\n        minimumInterval = _ref$minimumInterval === void 0 ? 1 : _ref$minimumInterval,\n        _ref$layers = _ref.layers,\n        layers = _ref$layers === void 0 ? {} : _ref$layers;\n\n    GestureFeature_classCallCheck(this, GestureFeature);\n\n    _this = _super.call(this, host);\n    _this.holdTime = holdTime;\n    _this.minimumInterval = minimumInterval; // Register the gesture layers\n\n    Object.entries(layers).forEach(function (_ref2) {\n      var _ref3 = GestureFeature_slicedToArray(_ref2, 2),\n          name = _ref3[0],\n          _ref3$ = _ref3[1],\n          options = _ref3$ === void 0 ? {} : _ref3$;\n\n      _this.registerLayer(name, options);\n    });\n    return _this;\n  }\n  /**\r\n   * Return a valid hold time value. If hold time isn\'t defined for the animation,\r\n   * try to use the hold time for the layer. If that\'s not defined, fall back to\r\n   * the hold time for the feature.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {Object} layer - Managed layer options object.\r\n   * @param {Object} animation - Managed animation options object.\r\n   *\r\n   * @returns {number}\r\n   */\n\n\n  GestureFeature_createClass(GestureFeature, [{\n    key: "_getHoldTime",\n    value: function _getHoldTime(layer, animation) {\n      var layerHoldTime = layer.holdTime !== undefined ? layer.holdTime : this.holdTime;\n      return animation.holdTime !== undefined ? animation.holdTime : layerHoldTime;\n    }\n    /**\r\n     * Return a valid minimum interval value. If minimum interval isn\'t defined for\r\n     * the animation, try to use the minimum interval for the layer. If that\'s not\r\n     * defined, fall back to the minimum interval for the feature.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {Object} layer - Managed layer options object.\r\n     * @param {Object} animation - Managed animation options object.\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: "_getMinimumInterval",\n    value: function _getMinimumInterval(layer, animation) {\n      var layerMinimumInterval = layer.minimumInterval !== undefined ? layer.minimumInterval : this.minimumInterval;\n      return animation.minimumInterval !== undefined ? animation.minimumInterval : layerMinimumInterval;\n    }\n    /**\r\n     * Callback for {@link core/AnimationFeature#playNextAnimation} event. If the\r\n     * event is emitted for a managed animation and the new queued state cannot\r\n     * advance on its own, start a new timer promise that will advance the queue\r\n     * once it resolves.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {Object} options - Options object passed from playNextAnimation event.\r\n     * @param {string} layerName - Name of the layer that owns the queue state.\r\n     * @param {string} animationName - Name of the queue state animation.\r\n     * @param {boolean} canAdvance - Whether or not the current state in the queue\r\n     * can advance on its own.\r\n     * @param {boolean} isQueueEnd - Whether the current state in the queue is the last\r\n     * state in the queue.\r\n     */\n\n  }, {\n    key: "_onNext",\n    value: function _onNext(_ref4) {\n      var _this2 = this;\n\n      var layerName = _ref4.layerName,\n          animationName = _ref4.animationName,\n          canAdvance = _ref4.canAdvance,\n          isQueueEnd = _ref4.isQueueEnd;\n      // Exit if this isn\'t a managed layer\n      var layer = this._managedLayers[layerName];\n\n      if (layer === undefined) {\n        return;\n      } // Exit if it isn\'t a managed animation\n\n\n      var animation = layer.animations[animationName];\n\n      if (animation === undefined) {\n        return;\n      } // Start a new timer for looping states that aren\'t the end of the queue\n\n\n      if (!canAdvance && !isQueueEnd && layer.currentGesture === animationName) {\n        var holdTime = this._getHoldTime(layer, animation);\n\n        layer.holdTimer.cancel(); // Skip to the next animation right away if hold time is zero\n\n        if (holdTime <= 0) {\n          this._host.AnimationFeature.playNextAnimation(layerName, animationName);\n        } // Wait for the given hold time before progressing\n        else {\n          layer.holdTimer = core_Utils.wait(holdTime, {\n            onFinish: function onFinish() {\n              // Advance the queue to the next state\n              if (layer.currentGesture === animationName) {\n                _this2._host.AnimationFeature.playNextAnimation(layerName, animationName);\n              }\n            }\n          });\n        }\n      }\n    }\n    /**\r\n     * Callback for {@link core/AnimationFeature#stopAnimation} event. If the\r\n     * event is emitted for a managed animation cancel the layer\'s stored timers.\r\n     * If the layer is set to auto-disable set its weight to 0.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {Object} options - Options object passed from playNextAnimation event.\r\n     * @param {string} layerName - Name of the layer that owns the stopped animation.\r\n     * @param {string} animationName - Name of the animation that was stopped.\r\n     */\n\n  }, {\n    key: "_onStop",\n    value: function _onStop(_ref5) {\n      var layerName = _ref5.layerName,\n          animationName = _ref5.animationName;\n      // Make sure the layer is managed\n      var layer = this._managedLayers[layerName];\n\n      if (layer === undefined) {\n        return;\n      } // Make sure the animation is managed\n\n\n      var animation = layer.animations[animationName];\n\n      if (animation !== undefined && animationName === layer.currentGesture) {\n        layer.currentGesture = null;\n        layer.playTimer = null;\n        layer.holdTimer.cancel(); // Turn off layer weight\n\n        if (layer.autoDisable) {\n          this.setLayerWeights(function (name) {\n            return name === layerName;\n          }, 0);\n        }\n      }\n    }\n  }, {\n    key: "_onAnimationAdded",\n    value: function _onAnimationAdded(_ref6) {\n      var layerName = _ref6.layerName,\n          animationName = _ref6.animationName;\n      var layer = this._managedLayers[layerName];\n\n      if (layer !== undefined) {\n        var animation = layer.animations[animationName]; // Register the animation as active if it is unmanaged\n\n        if (animation === undefined) {\n          this.registerAnimation(layerName, animationName);\n        } // Mark the animation as active if it is managed\n        else {\n          animation.isActive = true;\n        }\n      }\n    }\n  }, {\n    key: "registerLayer",\n    value: function registerLayer(name) {\n      var _this3 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      GestureFeature_get(GestureFeature_getPrototypeOf(GestureFeature.prototype), "registerLayer", this).call(this, name, GestureFeature_objectSpread(GestureFeature_objectSpread({}, options), {}, {\n        holdTimer: core_Deferred.resolve(),\n        playTimer: null,\n        currentGesture: null\n      }));\n\n      if (this._managedLayers[name].isActive) {\n        this._host.AnimationFeature.getAnimations(name).forEach(function (anim) {\n          // Automatically register all animations on the layer\n          if (_this3._managedLayers[name].animations[anim] === undefined) {\n            _this3.registerAnimation(name, anim, _this3._managedLayers[name].animations[anim]);\n          }\n        });\n      }\n    }\n  }, {\n    key: "registerAnimation",\n    value: function registerAnimation(layerName, animationName) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      // Try to fall back to a default word array\n      if (!(options.words instanceof Array) && !(options.words instanceof Set)) {\n        options.words = DefaultGestureWords[animationName] || [];\n      }\n\n      GestureFeature_get(GestureFeature_getPrototypeOf(GestureFeature.prototype), "registerAnimation", this).call(this, layerName, animationName, options);\n    }\n    /**\r\n     * Create an object that maps ssml mark syntax required to play each gesture to\r\n     * the words array associated with each gesture. Words arrays are defined at when\r\n     * the gesture animation is registered. Gestures without associated words will\r\n     * be excluded from the result. The resulting object can be used as an input\r\n     * for {@link TextToSpeechUtils.autoGenerateSSMLMarks} to update a speech string\r\n     * with the markup required to play gestures timed with their associated words.\r\n     *\r\n     * @returns {Object}\r\n     */\n\n  }, {\n    key: "createGestureMap",\n    value: function createGestureMap() {\n      var _this4 = this;\n\n      var gestureMap = {};\n      Object.entries(this._managedLayers).forEach(function (_ref7) {\n        var _ref8 = GestureFeature_slicedToArray(_ref7, 2),\n            layerName = _ref8[0],\n            animations = _ref8[1].animations;\n\n        Object.entries(animations).forEach(function (_ref9) {\n          var _ref10 = GestureFeature_slicedToArray(_ref9, 2),\n              animationName = _ref10[0],\n              _ref10$ = _ref10[1],\n              holdTime = _ref10$.holdTime,\n              minimumInterval = _ref10$.minimumInterval,\n              words = _ref10$.words,\n              transitionTime = _ref10$.transitionTime;\n\n          // Only store gestures that have any associated words\n          if (words.length) {\n            var options = GestureFeature_objectSpread(GestureFeature_objectSpread(GestureFeature_objectSpread({}, holdTime && {\n              holdTime: holdTime\n            }), minimumInterval && {\n              minimumInterval: minimumInterval\n            }), transitionTime && {\n              transitionTime: transitionTime\n            });\n\n            var key = {\n              feature: _this4.constructor.name,\n              method: \'playGesture\',\n              args: [layerName, animationName, options]\n            };\n            gestureMap[JSON.stringify(key)] = words;\n          }\n        });\n      });\n      return gestureMap;\n    }\n    /**\r\n     * Create an array that contains ssml mark syntax required to play each gesture\r\n     * that does not have any associated words. The resulting array can be used as\r\n     * an input for {@link TextToSpeechUtils.autoGenerateSSMLMarks} or\r\n     * {@link TextToSpeechUtils.addMarksToUnmarkedSentences} to update a speech\r\n     * string with the markup required to play random gestures at each unmarked\r\n     * sentence in the string.\r\n     *\r\n     * @param {Array.<string>=} layers - An array of names of managed layers to generate\r\n     * marks for. If undefined, use all managed layers.\r\n     *\r\n     * @returns {Array.<string>}\r\n     */\n\n  }, {\n    key: "createGenericGestureArray",\n    value: function createGenericGestureArray(layers) {\n      var _this5 = this;\n\n      var genericGestures = [];\n      layers = layers || Object.keys(this._managedLayers);\n      layers.forEach(function (layerName) {\n        var layer = _this5._managedLayers[layerName]; // Make sure the layer is managed\n\n        if (!layer) {\n          return;\n        }\n\n        Object.entries(layer.animations).forEach(function (_ref11) {\n          var _ref12 = GestureFeature_slicedToArray(_ref11, 2),\n              animationName = _ref12[0],\n              _ref12$ = _ref12[1],\n              holdTime = _ref12$.holdTime,\n              minimumInterval = _ref12$.minimumInterval,\n              words = _ref12$.words,\n              transitionTime = _ref12$.transitionTime;\n\n          // Only store gestures that don\'t have any associated words\n          if (!words.length) {\n            var options = GestureFeature_objectSpread(GestureFeature_objectSpread(GestureFeature_objectSpread({}, holdTime && {\n              holdTime: holdTime\n            }), minimumInterval && {\n              minimumInterval: minimumInterval\n            }), transitionTime && {\n              transitionTime: transitionTime\n            });\n\n            var key = JSON.stringify({\n              feature: _this5.constructor.name,\n              method: \'playGesture\',\n              args: [layerName, animationName, options]\n            });\n\n            if (!genericGestures.includes(key)) {\n              genericGestures.push(key);\n            }\n          }\n        });\n      });\n      return genericGestures;\n    }\n    /**\r\n     * Play a managed gesture animation.\r\n     *\r\n     * @param {string} layerName - The name of the layer that contains the gesture\r\n     * animation.\r\n     * @param {string} animationName - The name of the gesture animation.\r\n     * @param {Object=} options - Optional gesture options.\r\n     * @param {number=} options.holdTime - This option only applies to {@link QueueState}\r\n     * gestures. When a QueueState gesture progresses to a looping state, this option\r\n     * defines how many seconds should elapse before moving the queue forward. If\r\n     * undefined, it will fall back first to the holdTime defined in the options when\r\n     * the gesture animation was registered and then to the holdTime defined on the\r\n     * feature.\r\n     * @param {number=} options.minimumInterval - The minimum amount of time that\r\n     * must have elapsed since the last time a gesture was played.\r\n     */\n\n  }, {\n    key: "playGesture",\n    value: function playGesture(layerName, animationName) {\n      var _ref13 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n          holdTime = _ref13.holdTime,\n          minimumInterval = _ref13.minimumInterval,\n          transitionTime = _ref13.transitionTime,\n          _ref13$force = _ref13.force,\n          force = _ref13$force === void 0 ? false : _ref13$force;\n\n      // Make sure the animation is registered\n      if (this._managedLayers[layerName] === undefined || this._managedLayers[layerName].animations[animationName] === undefined) {\n        this.registerAnimation(layerName, animationName, {\n          holdTime: holdTime,\n          minimumInterval: minimumInterval,\n          transitionTime: transitionTime\n        });\n      }\n\n      var layer = this._managedLayers[layerName];\n      var animation = layer.animations[animationName]; // Make sure the animation is active\n\n      if (!animation.isActive) {\n        // Create warning message based on which object doesn\'t exist yet\n        var typeName = layer.isActive ? \'animation\' : \'layer\';\n        var message = "Skipping gesture ".concat(animationName, " on layer ").concat(layerName, " for host ").concat(this._host.id, ". No ").concat(typeName, " exists with this name yet.");\n        console.warn(message);\n        return core_Deferred.cancel({\n          reason: \'inactive\',\n          value: typeName\n        });\n      } // Check if the gesture is already playing\n\n\n      var currentGesture = layer.currentGesture;\n\n      if (currentGesture === animationName && !force) {\n        var _message = "Skipping gesture ".concat(animationName, " on layer ").concat(layerName, " for host ").concat(this._host.id, ". The gesture is already playing. Use options.force to force the gesture replay, which may result in a hard transition.");\n\n        console.warn(_message);\n        return core_Deferred.cancel({\n          reason: \'playing\',\n          value: animationName\n        });\n      } // Update animation options\n\n\n      if (holdTime !== undefined) {\n        animation.holdTime = holdTime;\n      }\n\n      if (minimumInterval !== undefined) {\n        animation.minimumInterval = minimumInterval;\n      } else {\n        minimumInterval = this._getMinimumInterval(layer, animation);\n      } // Check the interval\n\n\n      if (!force && layer.playTimer !== null && layer.playTimer < minimumInterval) {\n        console.warn("Skipping gesture ".concat(animationName, " on layer ").concat(layerName, " for host ").concat(this._host.id, ". Minimum interval ").concat(minimumInterval, " has not been met."));\n        return core_Deferred.cancel({\n          reason: \'minimumInterval\',\n          value: minimumInterval - layer.playTimer\n        });\n      } // Play the animation\n\n\n      layer.currentGesture = animationName;\n      layer.playTimer = 0;\n      layer.holdTimer.cancel();\n\n      if (layer.autoDisable) {\n        this.setLayerWeights(function (name) {\n          return name === layerName;\n        }, 1);\n      }\n\n      return this._host.AnimationFeature.playAnimation(layerName, animationName, transitionTime);\n    }\n  }, {\n    key: "update",\n    value: function update(deltaTime) {\n      var _this6 = this;\n\n      GestureFeature_get(GestureFeature_getPrototypeOf(GestureFeature.prototype), "update", this).call(this, deltaTime); // Increment the timers\n\n\n      Object.entries(this._managedLayers).forEach(function (_ref14) {\n        var _ref15 = GestureFeature_slicedToArray(_ref14, 2),\n            name = _ref15[0],\n            options = _ref15[1];\n\n        if (options.isActive && !_this6._host.AnimationFeature.getPaused(name)) {\n          options.holdTimer.execute(deltaTime);\n\n          if (options.playTimer !== null) {\n            options.playTimer += deltaTime / 1000;\n          }\n        }\n      });\n    }\n  }, {\n    key: "installApi",\n    value: function installApi() {\n      /**\r\n       * @inner\r\n       * @namespace GestureFeature\r\n       */\n      var api = GestureFeature_get(GestureFeature_getPrototypeOf(GestureFeature.prototype), "installApi", this).call(this);\n\n      Object.assign(api, {\n        /**\r\n         * @memberof GestureFeature\r\n         * @instance\r\n         * @method\r\n         * @see GestureFeature#createGestureMap\r\n         */\n        createGestureMap: this.createGestureMap.bind(this),\n\n        /**\r\n         * @memberof GestureFeature\r\n         * @instance\r\n         * @method\r\n         * @see GestureFeature#createGenericGestureArray\r\n         */\n        createGenericGestureArray: this.createGenericGestureArray.bind(this),\n\n        /**\r\n         * @memberof GestureFeature\r\n         * @instance\r\n         * @method\r\n         * @see GestureFeature#playGesture\r\n         */\n        playGesture: this.playGesture.bind(this)\n      });\n    }\n  }]);\n\n  return GestureFeature;\n}(core_AbstractHostFeature.mix(awspack_SSMLSpeechmarkInterface.Mixin, animpack_ManagedAnimationLayerInterface.Mixin));\n\nObject.defineProperties(GestureFeature, {\n  DEFAULT_LAYER_OPTIONS: {\n    value: GestureFeature_objectSpread(GestureFeature_objectSpread({}, GestureFeature.DEFAULT_LAYER_OPTIONS), {}, {\n      autoDisable: true\n    }),\n    writable: false\n  },\n  EVENT_DEPENDENCIES: {\n    value: GestureFeature_objectSpread(GestureFeature_objectSpread({}, GestureFeature.EVENT_DEPENDENCIES), {}, {\n      AnimationFeature: GestureFeature_objectSpread(GestureFeature_objectSpread({}, GestureFeature.EVENT_DEPENDENCIES.AnimationFeature), {}, {\n        playNextAnimation: \'_onNext\',\n        stopAnimation: \'_onStop\',\n        interruptAnimation: \'_onStop\'\n      })\n    })\n  }\n});\n/* harmony default export */ const core_GestureFeature = (GestureFeature);\n\n;// CONCATENATED MODULE: ./src/core/animpack/AnimationUtils.js\nfunction AnimationUtils_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AnimationUtils_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AnimationUtils_createClass(Constructor, protoProps, staticProps) { if (protoProps) AnimationUtils_defineProperties(Constructor.prototype, protoProps); if (staticProps) AnimationUtils_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n/**\r\n * A collection of useful animation functions.\r\n *\r\n * @hideconstructor\r\n */\n\nvar AnimationUtils = /*#__PURE__*/function () {\n  function AnimationUtils() {\n    AnimationUtils_classCallCheck(this, AnimationUtils);\n  }\n\n  AnimationUtils_createClass(AnimationUtils, null, [{\n    key: "lerp",\n    value: function lerp(from, to, factor) {\n      console.warn("AnimationUtils.lerp is being deprecated. Use MathUtils.lerp instead.");\n      return core_MathUtils.lerp(from, to, factor);\n    }\n    /**\r\n     * Clamp a number between 2 values.\r\n     *\r\n     * @param {number} value - Value to clamp.\r\n     * @param {number} [min=0] - Minumum value.\r\n     * @param {number} [max=1] - Maximum value.\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: "clamp",\n    value: function clamp(value) {\n      var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      console.warn("AnimationUtils.clamp is being deprecated. Use MathUtils.clamp instead.");\n      return core_MathUtils.clamp(value, min, max);\n    }\n    /**\r\n     * Return a deferred promise that can be used to update the value of a numeric\r\n     * property of this object over time. Pass delta time in milliseconds to the\r\n     * deferred promise\'s execute method in an update loop to animate the property\r\n     * towards the target value.\r\n     *\r\n     * @param {Object} propertyOwner - Object that contains the property to animation.\r\n     * @param {string} propertyName - Name of the property to animate.\r\n     * @param {number} targetValue - Target value to reach.\r\n     * @param {Object=} options - Optional options object\r\n     * @param {number} [options.seconds=0] - Number of seconds it will take to reach\r\n     * the target value.\r\n     * @param {Function} [options.easingFn=Linear.InOut] - Easing function to use for animation.\r\n     * @param {Function} [options.onFinish] - Callback to execute once the animation completes.\r\n     * The target value is passed as a parameter.\r\n     * @param {Function=} options.onProgress - Callback to execute each time the animation\r\n     * property is updated during the animation. The property\'s value at the time of\r\n     * the update is passed as a parameter.\r\n     * @param {Function=} options.onCancel - Callback to execute if the user cancels the\r\n     * animation before completion. The animation property\'s value at the time of\r\n     * cancel is passed as a parameter.\r\n     * @param {Function=} options.onError - Callback to execute if the animation stops\r\n     * because an error is encountered. The error message is passed as a parameter.\r\n     *\r\n     * @returns {Deferred} Resolves with the property\'s value once it reaches the\r\n     * target value.\r\n     */\n\n  }, {\n    key: "interpolateProperty",\n    value: function interpolateProperty(propertyOwner, propertyName, targetValue) {\n      var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n          _ref$seconds = _ref.seconds,\n          seconds = _ref$seconds === void 0 ? 0 : _ref$seconds,\n          easingFn = _ref.easingFn,\n          _onFinish = _ref.onFinish,\n          _onProgress = _ref.onProgress,\n          _onCancel = _ref.onCancel,\n          onError = _ref.onError;\n\n      // Make sure property is an object\n      if (!(propertyOwner instanceof Object)) {\n        var e = new Error("Cannot interpolate property ".concat(propertyName, ". Property owner must be an object."));\n\n        if (typeof onError === \'function\') {\n          onError(e);\n        }\n\n        return core_Deferred.reject(e);\n      } // Make sure property is numeric\n\n\n      if (Number.isNaN(Number(propertyOwner[propertyName]))) {\n        var _e = new Error("Cannot interpolate property ".concat(propertyName, ". Property must be numeric."));\n\n        if (typeof onError === \'function\') {\n          onError(_e);\n        }\n\n        return core_Deferred.reject(_e);\n      } // Make sure the target value is numeric\n\n\n      if (Number.isNaN(Number(targetValue))) {\n        var _e2 = new Error("Cannot interpolate property ".concat(propertyName, " to value ").concat(targetValue, ". Target value must be numeric."));\n\n        if (typeof onError === \'function\') {\n          onError(_e2);\n        }\n\n        return core_Deferred.reject(_e2);\n      } // Resolve immediately if the target has already been reached\n\n\n      var startValue = propertyOwner[propertyName];\n\n      if (startValue === targetValue) {\n        if (typeof _onFinish === \'function\') {\n          _onFinish(targetValue);\n        }\n\n        return core_Deferred.resolve(targetValue);\n      } // Default to linear interpolation\n\n\n      if (typeof easingFn !== \'function\') {\n        if (easingFn !== undefined) {\n          console.warn("Invalid property interpolation easingFn. Defaulting to linear interpolation.");\n        }\n\n        easingFn = Linear.InOut;\n      }\n\n      var interpolator = core_Utils.wait(seconds, {\n        onFinish: function onFinish() {\n          propertyOwner[propertyName] = targetValue;\n\n          if (typeof _onFinish === \'function\') {\n            _onFinish(targetValue);\n          }\n        },\n        onCancel: function onCancel() {\n          if (typeof _onCancel === \'function\') {\n            _onCancel(propertyOwner[propertyName]);\n          }\n        },\n        onProgress: function onProgress(progress) {\n          if (propertyOwner[propertyName] !== targetValue) {\n            // Calculate the lerp factor\n            var easeFactor = easingFn(progress);\n\n            if (typeof easeFactor !== \'number\') {\n              var _e3 = new Error("Invalid property interpolation easingFn. EasingFn must return a number.");\n\n              interpolator.reject(_e3);\n              return;\n            } // Update the value\n\n\n            propertyOwner[propertyName] = core_MathUtils.lerp(startValue, targetValue, easeFactor);\n          } // Signal progress\n\n\n          if (typeof _onProgress === \'function\') {\n            _onProgress(propertyOwner[propertyName]);\n          } // Signal completion once time is up\n\n\n          if (progress === 1) {\n            propertyOwner[propertyName] = targetValue;\n            interpolator.resolve(targetValue);\n          }\n        },\n        onError: onError\n      });\n      return interpolator;\n    }\n  }]);\n\n  return AnimationUtils;\n}();\n\n/* harmony default export */ const animpack_AnimationUtils = (AnimationUtils);\n;// CONCATENATED MODULE: ./src/core/animpack/state/AbstractState.js\nfunction AbstractState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AbstractState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AbstractState_createClass(Constructor, protoProps, staticProps) { if (protoProps) AbstractState_defineProperties(Constructor.prototype, protoProps); if (staticProps) AbstractState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n/**\r\n * Base class for a state in our animation system.\r\n *\r\n * @abstract\r\n */\n\nvar AbstractState = /*#__PURE__*/function () {\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {Object=} options - Options for the animation state.\r\n   * @param {string=} options.name - Name for the animation state. Names must be\r\n   * unique for the container the state is applied to and should be validated at\r\n   * the container level. If no name is given it will default to the constructor\r\n   * name.\r\n   * @param {weight} [options.weight=0] - The 0-1 amount of influence the state will have.\r\n   */\n  function AbstractState() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    AbstractState_classCallCheck(this, AbstractState);\n\n    this.name = options.name !== undefined ? options.name : this.constructor.name;\n    this._weight = options.weight !== undefined ? core_MathUtils.clamp(options.weight, 0, 1) : 0;\n    this._internalWeight = this._weight;\n    this._paused = false;\n    this._promises = {\n      finish: core_Deferred.resolve(),\n      weight: core_Deferred.resolve(),\n      play: core_Deferred.resolve()\n    };\n    this._playCallbacks = {\n      onFinish: undefined,\n      onError: undefined,\n      onCancel: undefined\n    };\n  }\n  /**\r\n   * Gets whether or not the state is currently paused.\r\n   *\r\n   * @type {number}\r\n   */\n\n\n  AbstractState_createClass(AbstractState, [{\n    key: "paused",\n    get: function get() {\n      return this._paused;\n    }\n    /**\r\n     * Gets and sets the user defined weight.\r\n     *\r\n     * @type {number}\r\n     */\n\n  }, {\n    key: "weight",\n    get: function get() {\n      return this._weight;\n    },\n    set: function set(weight) {\n      this._weight = core_MathUtils.clamp(weight, 0, 1);\n    }\n    /**\r\n     * Gets whether or not the weight is currently being animated.\r\n     *\r\n     * @readonly\r\n     * @type {boolean}\r\n     */\n\n  }, {\n    key: "weightPending",\n    get: function get() {\n      return this._promises.weight && this._promises.weight.pending;\n    }\n    /**\r\n     * Updates the user defined weight over time.\r\n     *\r\n     * @param {number} weight - The target weight value.\r\n     * @param {number} [seconds=0] - The amount of time it will take to reach the\r\n     * target weight.\r\n     * @param {Function=} easingFn - The easing function to use for interpolation.\r\n     *\r\n     * @returns {Deferred}\r\n     */\n\n  }, {\n    key: "setWeight",\n    value: function setWeight(weight) {\n      var seconds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var easingFn = arguments.length > 2 ? arguments[2] : undefined;\n\n      this._promises.weight.cancel();\n\n      weight = core_MathUtils.clamp(weight);\n      this._promises.weight = animpack_AnimationUtils.interpolateProperty(this, \'weight\', weight, {\n        seconds: seconds,\n        easingFn: easingFn\n      });\n      return this._promises.weight;\n    }\n    /**\r\n     * Gets the internal weight.\r\n     *\r\n     * @readonly\r\n     * @type {number}\r\n     */\n\n  }, {\n    key: "internalWeight",\n    get: function get() {\n      return this._internalWeight;\n    }\n    /**\r\n     * Multiplies the user weight by a factor to determine the internal weight.\r\n     *\r\n     * @param {number} factor - 0-1 multiplier to apply to the user weight.\r\n     */\n\n  }, {\n    key: "updateInternalWeight",\n    value: function updateInternalWeight(factor) {\n      this._internalWeight = this._weight * factor;\n    }\n    /**\r\n     * Update any values that need to be evaluated every frame.\r\n     *\r\n     * @param {number} deltaTime - Time in milliseconds since the last update.\r\n     */\n\n  }, {\n    key: "update",\n    value: function update(deltaTime) {\n      if (!this._paused) {\n        Object.values(this._promises).forEach(function (promise) {\n          promise.execute(deltaTime);\n        });\n      }\n    }\n    /**\r\n     * Start playback of the state from the beginning.\r\n     *\r\n     * @param {Function=} onFinish - Function to execute when the state finishes.\r\n     * @param {Function=} onError - Function to execute if the state encounters\r\n     * an error during playback.\r\n     * @param {Function=} onCancel - Function to execute if playback is canceled.\r\n     *\r\n     * @returns {Deferred}\r\n     */\n\n  }, {\n    key: "play",\n    value: function play(onFinish, onError, onCancel) {\n      this._paused = false;\n      this._playCallbacks.onFinish = onFinish;\n      this._playCallbacks.onError = onError;\n      this._playCallbacks.onCancel = onCancel;\n      this._promises.play = new core_Deferred(undefined, onFinish, onError, onCancel);\n      this._promises.finish = core_Deferred.all([this._promises.play, this._promises.weight]);\n      return this._promises.finish;\n    }\n    /**\r\n     * Pause playback of the state. This prevents pending promises from being executed.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "pause",\n    value: function pause() {\n      this._paused = true;\n      return true;\n    }\n    /**\r\n     * Resume playback of the state.\r\n     *\r\n     * @param {Function=} onFinish - Function to execute when the state finishes.\r\n     * @param {Function=} onError - Function to execute if the state encounters\r\n     * an error during playback.\r\n     * @param {Function=} onCancel - Function to execute if playback is canceled.\r\n     *\r\n     * @returns {Deferred}\r\n     */\n\n  }, {\n    key: "resume",\n    value: function resume(onFinish, onError, onCancel) {\n      this._paused = false;\n\n      if (!this._promises.play.pending) {\n        this._playCallbacks.onFinish = onFinish || this._playCallbacks.onFinish;\n        this._playCallbacks.onError = onError || this._playCallbacks.onError;\n        this._playCallbacks.onCancel = onCancel || this._playCallbacks.onCancel;\n        this._promises.play = new core_Deferred(undefined, this._playCallbacks.onFinish, this._playCallbacks.onError, this._playCallbacks.onCancel);\n        this._promises.finish = core_Deferred.all([this._promises.play, this._promises.weight]);\n      }\n\n      return this._promises.finish;\n    }\n    /**\r\n     * Cancel playback of the state and cancel any pending promises.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "cancel",\n    value: function cancel() {\n      this._paused = true;\n      Object.values(this._promises).forEach(function (promise) {\n        promise.cancel();\n      });\n      return true;\n    }\n    /**\r\n     * Stop playback of the state and resolve any pending promises.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "stop",\n    value: function stop() {\n      this._paused = true;\n      Object.values(this._promises).forEach(function (promise) {\n        promise.resolve();\n      });\n      return true;\n    }\n    /**\r\n     * Cancel any pending promises and remove reference to them.\r\n     */\n\n  }, {\n    key: "discard",\n    value: function discard() {\n      this.cancel();\n      delete this._promises;\n    }\n    /**\r\n     * Force the internal weight to 0. Should be called before switching or transitioning\r\n     * to a new state.\r\n     */\n\n  }, {\n    key: "deactivate",\n    value: function deactivate() {\n      this.updateInternalWeight(0);\n    }\n  }]);\n\n  return AbstractState;\n}();\n\n/* harmony default export */ const state_AbstractState = (AbstractState);\n;// CONCATENATED MODULE: ./src/core/animpack/state/TransitionState.js\nfunction TransitionState_typeof(obj) { "@babel/helpers - typeof"; return TransitionState_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, TransitionState_typeof(obj); }\n\nfunction TransitionState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction TransitionState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction TransitionState_createClass(Constructor, protoProps, staticProps) { if (protoProps) TransitionState_defineProperties(Constructor.prototype, protoProps); if (staticProps) TransitionState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction TransitionState_get() { if (typeof Reflect !== "undefined" && Reflect.get) { TransitionState_get = Reflect.get; } else { TransitionState_get = function _get(target, property, receiver) { var base = TransitionState_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return TransitionState_get.apply(this, arguments); }\n\nfunction TransitionState_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = TransitionState_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction TransitionState_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) TransitionState_setPrototypeOf(subClass, superClass); }\n\nfunction TransitionState_setPrototypeOf(o, p) { TransitionState_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return TransitionState_setPrototypeOf(o, p); }\n\nfunction TransitionState_createSuper(Derived) { var hasNativeReflectConstruct = TransitionState_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = TransitionState_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = TransitionState_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return TransitionState_possibleConstructorReturn(this, result); }; }\n\nfunction TransitionState_possibleConstructorReturn(self, call) { if (call && (TransitionState_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return TransitionState_assertThisInitialized(self); }\n\nfunction TransitionState_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction TransitionState_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction TransitionState_getPrototypeOf(o) { TransitionState_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return TransitionState_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n/**\r\n * Class for smooth transitioning between states on an animation layer.\r\n *\r\n * @extends AbstractState\r\n */\n\nvar TransitionState = /*#__PURE__*/function (_AbstractState) {\n  TransitionState_inherits(TransitionState, _AbstractState);\n\n  var _super = TransitionState_createSuper(TransitionState);\n\n  function TransitionState() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    TransitionState_classCallCheck(this, TransitionState);\n\n    _this = _super.call(this, options);\n    _this._to = null;\n    _this._from = [];\n    _this._weightPromise = core_Deferred.resolve();\n    return _this;\n  }\n\n  TransitionState_createClass(TransitionState, [{\n    key: "internalWeight",\n    get: function get() {\n      // Find the combined weight of all sub-states\n      var totalWeight = 0;\n\n      if (this._to) {\n        totalWeight += this._to.weight;\n      }\n\n      this._from.forEach(function (state) {\n        totalWeight += state.weight;\n      });\n\n      return totalWeight * this._internalWeight;\n    }\n  }, {\n    key: "updateInternalWeight",\n    value: function updateInternalWeight(factor) {\n      var _this2 = this;\n\n      TransitionState_get(TransitionState_getPrototypeOf(TransitionState.prototype), "updateInternalWeight", this).call(this, factor);\n\n      this._from.forEach(function (state) {\n        state.updateInternalWeight(_this2._internalWeight);\n      });\n\n      if (this._to) {\n        this._to.updateInternalWeight(this._internalWeight);\n      }\n    }\n    /**\r\n     * Update sub-states the transition is controlling and start new weight\r\n     * animations on each one. This should be called each time the current state of\r\n     * an animation layer gets updated to a new value and a transition time greater\r\n     * that zero is specified.\r\n     *\r\n     * @param {Array.<AbstractState>} [currentStates=[]] - States whose weight values\r\n     * will be animated to 0.\r\n     * @param {AbstractState=} targetState - State whose weight will be animated\r\n     * to 1.\r\n     * @param {number} transitionTime - Amount of time it will in seconds take for\r\n     * weight animations to complete.\r\n     * @param {Function=} easingFn - Easing function to use for weight animations.\r\n     * Default is Easing.Linear.InOut.\r\n     * @param {Function=} onComplete - Function to execute once all weight animations\r\n     * complete.\r\n     */\n\n  }, {\n    key: "configure",\n    value: function configure() {\n      var currentStates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var targetState = arguments.length > 1 ? arguments[1] : undefined;\n      var transitionTime = arguments.length > 2 ? arguments[2] : undefined;\n      var easingFn = arguments.length > 3 ? arguments[3] : undefined;\n      var onComplete = arguments.length > 4 ? arguments[4] : undefined;\n\n      // Deactivate any states that aren\'t in the new configuration\n      if (this._to === targetState || currentStates.includes(this._to)) {\n        this._to = null;\n      }\n\n      this._from = this._from.filter(function (state) {\n        return state !== targetState && !currentStates.includes(state);\n      });\n      this.deactivate();\n      this._from = currentStates;\n      this._to = targetState;\n      this.reset(transitionTime, easingFn, onComplete);\n    }\n    /**\r\n     * Start new weight animations state the transition controls. This should be called\r\n     * if an animation is played with a transition time greater than zero and a transtion\r\n     * to that animation was already in progress.\r\n     *\r\n     * @param {number} transitionTime - Amount of time it will in seconds take for\r\n     * weight animations to complete.\r\n     * @param {Function=} easingFn - Easing function to use for weight animations.\r\n     * Default is Easing.Linear.InOut.\r\n     * @param {Function=} onComplete - Function to execute once all weight animations\r\n     * complete.\r\n     */\n\n  }, {\n    key: "reset",\n    value: function reset(transitionTime, easingFn, onComplete) {\n      var _this3 = this;\n\n      // Stop any pending promises\n      this._weightPromise.cancel(); // Start tweening weight to 0 for the current states\n\n\n      var weightPromises = this._from.map(function (state) {\n        return state.setWeight(0, transitionTime, easingFn);\n      }); // Start tweening weight to 1 for the target state\n\n\n      if (this._to) {\n        weightPromises.push(this._to.setWeight(1, transitionTime, easingFn));\n        this.name = this._to.name;\n      } else {\n        this.name = null;\n      }\n\n      this._weightPromise = core_Deferred.all(weightPromises, function () {\n        _this3._from.forEach(function (state) {\n          state.cancel();\n          state.deactivate();\n        });\n\n        if (typeof onComplete === \'function\') {\n          onComplete();\n        }\n      });\n    }\n  }, {\n    key: "play",\n    value: function play(onFinish, onError, onCancel, onNext) {\n      this._paused = false;\n      this._playCallbacks.onFinish = onFinish;\n      this._playCallbacks.onError = onError;\n      this._playCallbacks.onCancel = onCancel;\n      var promises = [this._weightPromise];\n\n      this._from.forEach(function (state) {\n        state.resume();\n      });\n\n      if (this._to) {\n        this._promises.play = this._to.play(undefined, undefined, undefined, onNext);\n        promises.push(this._promises.play);\n      }\n\n      this._promises.finish = core_Deferred.all(promises, onFinish, onError, onCancel);\n      return this._promises.finish;\n    }\n  }, {\n    key: "pause",\n    value: function pause() {\n      this._from.forEach(function (state) {\n        state.pause();\n      });\n\n      if (this._to) {\n        this._to.pause();\n      }\n\n      return TransitionState_get(TransitionState_getPrototypeOf(TransitionState.prototype), "pause", this).call(this);\n    }\n  }, {\n    key: "resume",\n    value: function resume(onFinish, onError, onCancel, onNext) {\n      this._paused = false;\n\n      if (!this._promises.play.pending) {\n        this._playCallbacks.onFinish = onFinish || this._playCallbacks.onFinish;\n        this._playCallbacks.onError = onError || this._playCallbacks.onError;\n        this._playCallbacks.onCancel = onCancel || this._playCallbacks.onCancel;\n      }\n\n      var promises = [this._weightPromise];\n\n      this._from.forEach(function (state) {\n        state.resume();\n      });\n\n      if (this._to) {\n        this._promises.play = this._to.resume(undefined, undefined, undefined, onNext);\n        promises.push(this._promises.play);\n      }\n\n      this._promises.finish = core_Deferred.all(promises, this._playCallbacks.onFinish, this._playCallbacks.onError, this._playCallbacks.onCancel);\n      return this._promises.finish;\n    }\n  }, {\n    key: "cancel",\n    value: function cancel() {\n      this._from.forEach(function (state) {\n        state.pause();\n      });\n\n      if (this._to) {\n        this._to.cancel();\n      }\n\n      this._weightPromise.cancel();\n\n      return TransitionState_get(TransitionState_getPrototypeOf(TransitionState.prototype), "cancel", this).call(this);\n    }\n  }, {\n    key: "stop",\n    value: function stop() {\n      this._from.forEach(function (state) {\n        state.pause();\n      });\n\n      if (this._to) {\n        this._to.stop();\n      }\n\n      return TransitionState_get(TransitionState_getPrototypeOf(TransitionState.prototype), "stop", this).call(this);\n    }\n  }, {\n    key: "update",\n    value: function update(deltaTime) {\n      TransitionState_get(TransitionState_getPrototypeOf(TransitionState.prototype), "update", this).call(this, deltaTime);\n\n      this._from.forEach(function (state) {\n        state.update(deltaTime);\n      });\n\n      if (this._to) {\n        this._to.update(deltaTime);\n      }\n    }\n  }, {\n    key: "discard",\n    value: function discard() {\n      TransitionState_get(TransitionState_getPrototypeOf(TransitionState.prototype), "discard", this).call(this);\n\n      this._weightPromise.cancel();\n\n      delete this._weightPromise;\n      this._to = null;\n      this._from.length = 0;\n    }\n  }, {\n    key: "deactivate",\n    value: function deactivate() {\n      if (this._to) {\n        this._to.deactivate();\n      }\n\n      this._from.forEach(function (state) {\n        state.deactivate();\n      });\n    }\n  }]);\n\n  return TransitionState;\n}(state_AbstractState);\n\n/* harmony default export */ const state_TransitionState = (TransitionState);\n;// CONCATENATED MODULE: ./src/core/animpack/AnimationPlayerInterface.js\nfunction AnimationPlayerInterface_typeof(obj) { "@babel/helpers - typeof"; return AnimationPlayerInterface_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, AnimationPlayerInterface_typeof(obj); }\n\nfunction AnimationPlayerInterface_toConsumableArray(arr) { return AnimationPlayerInterface_arrayWithoutHoles(arr) || AnimationPlayerInterface_iterableToArray(arr) || AnimationPlayerInterface_unsupportedIterableToArray(arr) || AnimationPlayerInterface_nonIterableSpread(); }\n\nfunction AnimationPlayerInterface_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction AnimationPlayerInterface_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return AnimationPlayerInterface_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return AnimationPlayerInterface_arrayLikeToArray(o, minLen); }\n\nfunction AnimationPlayerInterface_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction AnimationPlayerInterface_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return AnimationPlayerInterface_arrayLikeToArray(arr); }\n\nfunction AnimationPlayerInterface_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction AnimationPlayerInterface_get() { if (typeof Reflect !== "undefined" && Reflect.get) { AnimationPlayerInterface_get = Reflect.get; } else { AnimationPlayerInterface_get = function _get(target, property, receiver) { var base = AnimationPlayerInterface_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return AnimationPlayerInterface_get.apply(this, arguments); }\n\nfunction AnimationPlayerInterface_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = AnimationPlayerInterface_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction AnimationPlayerInterface_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) AnimationPlayerInterface_setPrototypeOf(subClass, superClass); }\n\nfunction AnimationPlayerInterface_setPrototypeOf(o, p) { AnimationPlayerInterface_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return AnimationPlayerInterface_setPrototypeOf(o, p); }\n\nfunction AnimationPlayerInterface_createSuper(Derived) { var hasNativeReflectConstruct = AnimationPlayerInterface_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = AnimationPlayerInterface_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = AnimationPlayerInterface_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return AnimationPlayerInterface_possibleConstructorReturn(this, result); }; }\n\nfunction AnimationPlayerInterface_possibleConstructorReturn(self, call) { if (call && (AnimationPlayerInterface_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return AnimationPlayerInterface_assertThisInitialized(self); }\n\nfunction AnimationPlayerInterface_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction AnimationPlayerInterface_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction AnimationPlayerInterface_getPrototypeOf(o) { AnimationPlayerInterface_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return AnimationPlayerInterface_getPrototypeOf(o); }\n\nfunction AnimationPlayerInterface_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AnimationPlayerInterface_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AnimationPlayerInterface_createClass(Constructor, protoProps, staticProps) { if (protoProps) AnimationPlayerInterface_defineProperties(Constructor.prototype, protoProps); if (staticProps) AnimationPlayerInterface_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable max-classes-per-file */\n\n/* eslint-disable no-unused-vars */\n\n/* eslint-disable no-empty-function */\n\n/* eslint-disable getter-return */\n\n/* eslint-disable no-useless-constructor */\n\n\n/**\r\n * Class factory interface for controlling playback of a collection of animations.\r\n * One animation can be played at any given time, crossfading between animations\r\n * will result in playing a {@link TransitionState}.\r\n *\r\n * @interface\r\n */\n\nvar AnimationPlayerInterface = /*#__PURE__*/function () {\n  function AnimationPlayerInterface() {\n    AnimationPlayerInterface_classCallCheck(this, AnimationPlayerInterface);\n  }\n\n  AnimationPlayerInterface_createClass(AnimationPlayerInterface, [{\n    key: "paused",\n    get:\n    /**\r\n     * Gets whether or not the player is updating states.\r\n     *\r\n     * @readonly\r\n     * @type {boolean}\r\n     */\n    function get() {\n      return this._paused;\n    }\n    /**\r\n     * Gets and sets the default number of seconds it takes to transition to a new\r\n     * animation.\r\n     *\r\n     * @type {number}\r\n     */\n\n  }, {\n    key: "transitionTime",\n    get: function get() {},\n    set: function set(seconds) {}\n    /**\r\n     * Gets and sets the default easing function to use when transitioning and\r\n     * setting weights.\r\n     *\r\n     * @type {Function}\r\n     */\n\n  }, {\n    key: "easingFn",\n    get: function get() {},\n    set: function set(fn) {}\n    /**\r\n     * Gets the state the layer is currently in control of.\r\n     *\r\n     * @readonly\r\n     * @type {AbstractState}\r\n     */\n\n  }, {\n    key: "currentState",\n    get: function get() {}\n    /**\r\n     * Gets the name of the state the layer is currently in control of.\r\n     *\r\n     * @readonly\r\n     * @type {string}\r\n     */\n\n  }, {\n    key: "currentAnimation",\n    get: function get() {}\n    /**\r\n     * Gets whether or not the layer is currently transitioning to a new animation.\r\n     *\r\n     * @readonly\r\n     * @type {boolean}\r\n     */\n\n  }, {\n    key: "isTransitioning",\n    get: function get() {}\n    /**\r\n     * Update the layer\'s current state to a new value. If transitionTime is defined\r\n     * and greater than zero, perform a smooth blend between any states that currently\r\n     * have non-zero weight values and the new state.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {(string|null)} name - Name of the state to transition to.\r\n     * @param {string} playMethod - Name of the operation being prepared for, to be\r\n     * used in error messaging.\r\n     * @param {number=} transitionTime - Amount of time in seconds it will take to\r\n     * switch to the new state.\r\n     * @param {Function=} easingFn - Easing function to use when transitioning to a\r\n     * new state over time.\r\n     * @param {Function=} onError - Function to execute if an error is encountered.\r\n     */\n\n  }, {\n    key: "_prepareCurrentState",\n    value: function _prepareCurrentState(name, playMethod, transitionTime, easingFn, onError) {}\n    /**\r\n     * Start playback an animation from the beginning.\r\n     *\r\n     * @param {string} name - Name of the animation to play.\r\n     * @param {number=} transitionTime - Amount of time it will take before the\r\n     * new state has full influence for the layer.\r\n     * @param {Function=} easingFn - Easing function to use for blending if transitionTime\r\n     * is greater than zero.\r\n     * @param {Function=} onFinish - Function to execute when the animation finishes.\r\n     * @param {Function=} onError - Function to execute if the animation encounters\r\n     * an error during playback.\r\n     * @param {Function=} onCancel - Function to execute if playback is canceled.\r\n     * @param {Function=} onNext - Function to execute if an animation queue is\r\n     * played and it advances to the next animation.\r\n     *\r\n     * @returns {Deferred}\r\n     */\n\n  }, {\n    key: "playAnimation",\n    value: function playAnimation(name, transitionTime, easingFn, onFinish, onError, onCancel, onNext) {}\n    /**\r\n     * Cancel playback of the current animation.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "cancelAnimation",\n    value: function cancelAnimation() {}\n    /**\r\n     * Pause playback of the current animation.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "pauseAnimation",\n    value: function pauseAnimation() {}\n    /**\r\n     * Resume playback of an animation.\r\n     *\r\n     * @param {string=} name - Name of the animation to resume playback for. Default\r\n     * is the layer\'s current animation name.\r\n     * @param {number=} transitionTime - Amount of time it will take before the\r\n     * new state has full influence for the layer.\r\n     * @param {Function=} onFinish - Function to execute when the state finishes.\r\n     * @param {Function=} onError - Function to execute if the state encounters\r\n     * an error during playback.\r\n     * @param {Function=} onCancel - Function to execute if playback is canceled.\r\n     * @param {Function=} onNext - Function to execute if an animation queue is\r\n     * played and it advances to the next animation.\r\n     *\r\n     * @returns {Deferred}\r\n     */\n\n  }, {\n    key: "resumeAnimation",\n    value: function resumeAnimation(name, transitionTime, easingFn, onFinish, onError, onCancel, onNext) {}\n    /**\r\n     * Stop playback of the current animation.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "stopAnimation",\n    value: function stopAnimation() {}\n    /**\r\n     * Update the current animation.\r\n     *\r\n     * @param {number} deltaTime - Time in milliseconds since the last update.\r\n     */\n\n  }, {\n    key: "update",\n    value: function update(deltaTime) {}\n    /**\r\n     * Discard the transition state.\r\n     */\n\n  }, {\n    key: "discard",\n    value: function discard() {}\n    /**\r\n     * Creates a class that implements {@link AnimationPlayerInterface} and extends\r\n     * a specified base class.\r\n     *\r\n     * @param {Class} [BaseClass = class{}] - The class to extend.\r\n     *\r\n     * @return {Class} A class that extends `BaseClass` and implements {@link AnimationPlayerInterface}.\r\n     */\n\n  }], [{\n    key: "Mixin",\n    value: function Mixin() {\n      var BaseClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : /*#__PURE__*/function () {\n        function _class() {\n          AnimationPlayerInterface_classCallCheck(this, _class);\n        }\n\n        return AnimationPlayerInterface_createClass(_class);\n      }();\n\n      var AnimationPlayerMixin = /*#__PURE__*/function (_BaseClass) {\n        AnimationPlayerInterface_inherits(AnimationPlayerMixin, _BaseClass);\n\n        var _super = AnimationPlayerInterface_createSuper(AnimationPlayerMixin);\n\n        function AnimationPlayerMixin() {\n          var _this;\n\n          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n          AnimationPlayerInterface_classCallCheck(this, AnimationPlayerMixin);\n\n          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n          }\n\n          _this = _super.call.apply(_super, [this, options].concat(args));\n          _this._transitionState = new state_TransitionState();\n          _this._states = _this._states !== undefined ? _this._states : new Map();\n          _this._currentState = null;\n          _this._paused = false;\n          _this._transitionTime = Number(options.transitionTime) >= 0 ? Number(options.transitionTime) : 0;\n          _this._easingFn = typeof options.easingFn === \'function\' ? options.easingFn : undefined;\n          return _this;\n        }\n\n        AnimationPlayerInterface_createClass(AnimationPlayerMixin, [{\n          key: "paused",\n          get: function get() {\n            return this._paused;\n          }\n        }, {\n          key: "transitionTime",\n          get: function get() {\n            return this._transitionTime;\n          },\n          set: function set(seconds) {\n            seconds = Number(seconds);\n\n            if (!(seconds >= 0)) {\n              throw new Error("Cannot set transition time for ".concat(this.constructor.name, " to ").concat(seconds, ". Seconds must be a numeric value greather than or equal to zero."));\n            }\n\n            this._transitionTime = seconds;\n          }\n        }, {\n          key: "easingFn",\n          get: function get() {\n            return this._easingFn;\n          },\n          set: function set(fn) {\n            this._easingFn = fn;\n          }\n        }, {\n          key: "currentState",\n          get: function get() {\n            return this._currentState;\n          }\n        }, {\n          key: "currentAnimation",\n          get: function get() {\n            if (this._currentState) {\n              return this._currentState.name;\n            }\n\n            return null;\n          }\n        }, {\n          key: "isTransitioning",\n          get: function get() {\n            return this._currentState === this._transitionState;\n          }\n        }, {\n          key: "_prepareCurrentState",\n          value: function _prepareCurrentState(name, playMethod, transitionTime, easingFn, onError) {\n            var _this2 = this;\n\n            if (name !== null && !this._states.has(name)) {\n              var e = new Error("Cannot ".concat(playMethod, " animation ").concat(name, ". No animation exists with this name."));\n\n              if (typeof onError === \'function\') {\n                onError(e);\n              }\n\n              throw e;\n            }\n\n            var targetState = name !== null ? this._states.get(name) : null; // Make sure the new state isn\'t already playing\n\n            if (this.currentAnimation !== name) {\n              // Switch to the new state immediately\n              if (transitionTime <= 0) {\n                // Cancel the current state and set its weight to 0\n                if (this._currentState) {\n                  this._currentState.cancel();\n\n                  this._currentState.weight = 0;\n\n                  this._currentState.deactivate();\n                }\n\n                this._currentState = targetState;\n              } // Blend to the new state over time\n              else {\n                // Make sure to transition out of any states with non-zero weight\n                var currentStates = AnimationPlayerInterface_toConsumableArray(this._states.values()).filter(function (s) {\n                  return s !== targetState && (s.weight || s.weightPending);\n                }); // Update the transition state with new inputs\n\n\n                this._transitionState.configure(currentStates, targetState, transitionTime, easingFn, function () {\n                  _this2._currentState = targetState;\n                  _this2._transitionState.weight = 0;\n                });\n\n                this._currentState = this._transitionState;\n              }\n            } else if (playMethod === \'play\') {\n              this._currentState.cancel();\n\n              if (this._currentState === this._transitionState) {\n                this._transitionState.reset(transitionTime, easingFn, function () {\n                  _this2._currentState = targetState;\n                  _this2._transitionState.weight = 0;\n                });\n              }\n            } // Update weight for the new current state so it has full influence for the player\n\n\n            this._currentState.weight = 1;\n\n            this._currentState.updateInternalWeight(this._internalWeight);\n          }\n        }, {\n          key: "playAnimation",\n          value: function playAnimation(name, transitionTime, easingFn, onFinish, onError, onCancel, onNext) {\n            var error;\n            var reject = false;\n\n            try {\n              this._prepareCurrentState(name, \'play\', transitionTime !== undefined ? transitionTime : this._transitionTime, easingFn !== undefined ? easingFn : this._easingFn, onError);\n            } catch (e) {\n              error = e;\n              reject = true;\n            }\n\n            if (reject) {\n              return core_Deferred.reject(error);\n            }\n\n            return this._currentState.play(onFinish, onError, onCancel, onNext);\n          }\n        }, {\n          key: "pauseAnimation",\n          value: function pauseAnimation() {\n            if (this._currentState) {\n              return this._currentState.pause();\n            } else {\n              return false;\n            }\n          }\n        }, {\n          key: "resumeAnimation",\n          value: function resumeAnimation(name, transitionTime, easingFn, onFinish, onError, onCancel, onNext) {\n            if (name === undefined && this._currentState) {\n              name = this._currentState.name;\n            }\n\n            var error;\n            var reject = false;\n\n            try {\n              this._prepareCurrentState(name, \'resume\', transitionTime !== undefined ? transitionTime : this._transitionTime, easingFn !== undefined ? easingFn : this._easingFn, onError);\n            } catch (e) {\n              error = e;\n              reject = true;\n            }\n\n            if (reject) {\n              return core_Deferred.reject(error);\n            }\n\n            return this._currentState.resume(onFinish, onError, onCancel, onNext);\n          }\n        }, {\n          key: "cancelAnimation",\n          value: function cancelAnimation() {\n            if (this._currentState) {\n              return this._currentState.cancel();\n            } else {\n              return false;\n            }\n          }\n        }, {\n          key: "stopAnimation",\n          value: function stopAnimation() {\n            if (this._currentState) {\n              return this._currentState.stop();\n            } else {\n              return false;\n            }\n          }\n        }, {\n          key: "update",\n          value: function update(deltaTime) {\n            if (AnimationPlayerInterface_get(AnimationPlayerInterface_getPrototypeOf(AnimationPlayerMixin.prototype), "update", this)) {\n              AnimationPlayerInterface_get(AnimationPlayerInterface_getPrototypeOf(AnimationPlayerMixin.prototype), "update", this).call(this, deltaTime);\n            }\n\n            if (this._currentState) {\n              this._currentState.update(deltaTime);\n            }\n          }\n        }, {\n          key: "discard",\n          value: function discard() {\n            if (AnimationPlayerInterface_get(AnimationPlayerInterface_getPrototypeOf(AnimationPlayerMixin.prototype), "discard", this)) {\n              AnimationPlayerInterface_get(AnimationPlayerInterface_getPrototypeOf(AnimationPlayerMixin.prototype), "discard", this).call(this);\n            }\n\n            this._transitionState.discard();\n\n            delete this._transitionState;\n          }\n        }]);\n\n        return AnimationPlayerMixin;\n      }(BaseClass);\n\n      return AnimationPlayerMixin;\n    }\n  }]);\n\n  return AnimationPlayerInterface;\n}();\n\n/* harmony default export */ const animpack_AnimationPlayerInterface = (AnimationPlayerInterface);\n;// CONCATENATED MODULE: ./src/core/animpack/state/StateContainerInterface.js\nfunction StateContainerInterface_typeof(obj) { "@babel/helpers - typeof"; return StateContainerInterface_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, StateContainerInterface_typeof(obj); }\n\nfunction StateContainerInterface_toConsumableArray(arr) { return StateContainerInterface_arrayWithoutHoles(arr) || StateContainerInterface_iterableToArray(arr) || StateContainerInterface_unsupportedIterableToArray(arr) || StateContainerInterface_nonIterableSpread(); }\n\nfunction StateContainerInterface_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction StateContainerInterface_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return StateContainerInterface_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return StateContainerInterface_arrayLikeToArray(o, minLen); }\n\nfunction StateContainerInterface_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction StateContainerInterface_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return StateContainerInterface_arrayLikeToArray(arr); }\n\nfunction StateContainerInterface_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction StateContainerInterface_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) StateContainerInterface_setPrototypeOf(subClass, superClass); }\n\nfunction StateContainerInterface_setPrototypeOf(o, p) { StateContainerInterface_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return StateContainerInterface_setPrototypeOf(o, p); }\n\nfunction StateContainerInterface_createSuper(Derived) { var hasNativeReflectConstruct = StateContainerInterface_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = StateContainerInterface_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = StateContainerInterface_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return StateContainerInterface_possibleConstructorReturn(this, result); }; }\n\nfunction StateContainerInterface_possibleConstructorReturn(self, call) { if (call && (StateContainerInterface_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return StateContainerInterface_assertThisInitialized(self); }\n\nfunction StateContainerInterface_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction StateContainerInterface_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction StateContainerInterface_getPrototypeOf(o) { StateContainerInterface_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return StateContainerInterface_getPrototypeOf(o); }\n\nfunction StateContainerInterface_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction StateContainerInterface_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction StateContainerInterface_createClass(Constructor, protoProps, staticProps) { if (protoProps) StateContainerInterface_defineProperties(Constructor.prototype, protoProps); if (staticProps) StateContainerInterface_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable max-classes-per-file */\n\n/* eslint-disable no-unused-vars */\n\n/* eslint-disable no-empty-function */\n\n/* eslint-disable getter-return */\n\n/**\r\n * Class factory interface for manipulating a collection of {@link AbstractState}.\r\n *\r\n * @interface\r\n */\n\nvar StateContainerInterface = /*#__PURE__*/function () {\n  function StateContainerInterface() {\n    StateContainerInterface_classCallCheck(this, StateContainerInterface);\n  }\n\n  StateContainerInterface_createClass(StateContainerInterface, [{\n    key: "getState",\n    value:\n    /**\r\n     * Return the state with the given name.\r\n     *\r\n     * @param {string} name - Name of the state.\r\n     *\r\n     * @returns {AbstractState}\r\n     */\n    function getState(name) {}\n    /**\r\n     * Gets an array of the names of all states in the container.\r\n     *\r\n     * @type {Array.<string>}\r\n     */\n\n  }, {\n    key: "getStateNames",\n    value: function getStateNames() {}\n    /**\r\n     * Add a new state to be controlled by the container. States are stored keyed\r\n     * by their name property, which must be unique. If it isn\'t, a number will\r\n     * be added or incremented until a unique key is generated.\r\n     *\r\n     * @param {AbstractState} state - State to add to the container.\r\n     *\r\n     * @returns {string} - Unique name of the state.\r\n     */\n\n  }, {\n    key: "addState",\n    value: function addState(state) {}\n    /**\r\n     * Removes a state with the given name from the container.\r\n     *\r\n     * @param {string} name - Name of the state to remove.\r\n     *\r\n     * @returns {boolean} - Whether or not a state was removed.\r\n     */\n\n  }, {\n    key: "removeState",\n    value: function removeState(name) {}\n    /**\r\n     * Renames a state with the given name in the container. Name must be unique\r\n     * to the container, if it isn\'t the name will be incremented until it is unique.\r\n     *\r\n     * @param {string} currentName - Name of the state to rename.\r\n     * @param {string} newName - Name to update the state with.\r\n     *\r\n     * @returns {string} - Updated name for the state.\r\n     */\n\n  }, {\n    key: "renameState",\n    value: function renameState(currentName, newName) {}\n    /**\r\n     * Discards all states.\r\n     */\n\n  }, {\n    key: "discardStates",\n    value: function discardStates() {}\n    /**\r\n     * Creates a class that implements {@link StateContainerInterface} and extends\r\n     * a specified base class.\r\n     *\r\n     * @param {Class} [BaseClass = class{}] - The class to extend.\r\n     *\r\n     * @return {Class} A class that extends `BaseClass` and implements {@link StateContainerInterface}.\r\n     */\n\n  }], [{\n    key: "Mixin",\n    value: function Mixin() {\n      var BaseClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : /*#__PURE__*/function () {\n        function _class() {\n          StateContainerInterface_classCallCheck(this, _class);\n        }\n\n        return StateContainerInterface_createClass(_class);\n      }();\n\n      /**\r\n       * This mixin adds functionality for manipulating uniquely-named animation states in\r\n       * a map.\r\n       */\n      var StateContainerMixin = /*#__PURE__*/function (_BaseClass) {\n        StateContainerInterface_inherits(StateContainerMixin, _BaseClass);\n\n        var _super = StateContainerInterface_createSuper(StateContainerMixin);\n\n        function StateContainerMixin() {\n          var _this;\n\n          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n          StateContainerInterface_classCallCheck(this, StateContainerMixin);\n\n          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n          }\n\n          _this = _super.call.apply(_super, [this, options].concat(args));\n          _this._states = _this._states !== undefined ? _this._states : new Map();\n          return _this;\n        }\n\n        StateContainerInterface_createClass(StateContainerMixin, [{\n          key: "getState",\n          value: function getState(name) {\n            return this._states.get(name);\n          }\n        }, {\n          key: "getStateNames",\n          value: function getStateNames() {\n            return StateContainerInterface_toConsumableArray(this._states.keys());\n          }\n        }, {\n          key: "addState",\n          value: function addState(state) {\n            // Make sure the state is not already in this container\n            if (StateContainerInterface_toConsumableArray(this._states.values()).includes(state)) {\n              console.warn("Cannot add animation to state ".concat(this.name, ". Animation was already added."));\n              return state.name;\n            } // Make sure the state name is unique\n\n\n            var uniqueName = core_Utils.getUniqueName(state.name, StateContainerInterface_toConsumableArray(this._states.keys()));\n\n            if (state.name !== uniqueName) {\n              console.warn("Animation name ".concat(state.name, " is not unique for state ").concat(this.name, ". New animation will be added with name ").concat(uniqueName, "."));\n              state.name = uniqueName;\n            }\n\n            this._states.set(state.name, state);\n\n            return state.name;\n          }\n        }, {\n          key: "removeState",\n          value: function removeState(name) {\n            // Check if the state is in this container\n            if (!this._states || !this._states.has(name)) {\n              console.warn("Did not remove animation ".concat(name, " from state ").concat(this.name, ". No animation exists with this name."));\n              return false;\n            }\n\n            this._states.get(name).discard();\n\n            this._states["delete"](name);\n\n            return true;\n          }\n        }, {\n          key: "renameState",\n          value: function renameState(currentName, newName) {\n            // Make sure the state is in this container\n            if (!this._states || !this._states.has(currentName)) {\n              throw new Error("Cannot rename animation ".concat(currentName, " in ").concat(this.name, ". No animation exists with this name."));\n            }\n\n            var state = this._states.get(currentName); // Exit if the names are the same\n\n\n            if (currentName === newName) {\n              return currentName;\n            } // Make sure the name is unique\n\n\n            var uniqueName = core_Utils.getUniqueName(newName, StateContainerInterface_toConsumableArray(this._states.keys()).filter(function (s) {\n              return s.name !== currentName;\n            }));\n\n            if (newName !== uniqueName) {\n              console.warn("Animation name ".concat(newName, " is not unique in state ").concat(this.name, ". Animation will be renamed to ").concat(uniqueName, "."));\n              newName = uniqueName;\n            }\n\n            state.name = newName;\n\n            this._states["delete"](currentName);\n\n            this._states.set(state.name, state);\n\n            return state.name;\n          }\n        }, {\n          key: "discardStates",\n          value: function discardStates() {\n            this._states.forEach(function (state) {\n              state.discard();\n            });\n\n            delete this._states;\n          }\n        }]);\n\n        return StateContainerMixin;\n      }(BaseClass);\n\n      return StateContainerMixin;\n    }\n  }]);\n\n  return StateContainerInterface;\n}();\n\n/* harmony default export */ const state_StateContainerInterface = (StateContainerInterface);\n;// CONCATENATED MODULE: ./src/core/animpack/state/QueueState.js\nfunction QueueState_typeof(obj) { "@babel/helpers - typeof"; return QueueState_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, QueueState_typeof(obj); }\n\nfunction QueueState_toConsumableArray(arr) { return QueueState_arrayWithoutHoles(arr) || QueueState_iterableToArray(arr) || QueueState_unsupportedIterableToArray(arr) || QueueState_nonIterableSpread(); }\n\nfunction QueueState_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction QueueState_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return QueueState_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return QueueState_arrayLikeToArray(o, minLen); }\n\nfunction QueueState_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction QueueState_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return QueueState_arrayLikeToArray(arr); }\n\nfunction QueueState_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction QueueState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction QueueState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction QueueState_createClass(Constructor, protoProps, staticProps) { if (protoProps) QueueState_defineProperties(Constructor.prototype, protoProps); if (staticProps) QueueState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction QueueState_get() { if (typeof Reflect !== "undefined" && Reflect.get) { QueueState_get = Reflect.get; } else { QueueState_get = function _get(target, property, receiver) { var base = QueueState_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return QueueState_get.apply(this, arguments); }\n\nfunction QueueState_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = QueueState_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction QueueState_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) QueueState_setPrototypeOf(subClass, superClass); }\n\nfunction QueueState_setPrototypeOf(o, p) { QueueState_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return QueueState_setPrototypeOf(o, p); }\n\nfunction QueueState_createSuper(Derived) { var hasNativeReflectConstruct = QueueState_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = QueueState_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = QueueState_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return QueueState_possibleConstructorReturn(this, result); }; }\n\nfunction QueueState_possibleConstructorReturn(self, call) { if (call && (QueueState_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return QueueState_assertThisInitialized(self); }\n\nfunction QueueState_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction QueueState_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction QueueState_getPrototypeOf(o) { QueueState_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return QueueState_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n/**\r\n * Class for playing an ordered array of animation states in sequence.\r\n *\r\n * @extends AbstractState\r\n * @implements @AnimationPlayerInterface\r\n */\n\nvar QueueState = /*#__PURE__*/function (_AnimationPlayerInter) {\n  QueueState_inherits(QueueState, _AnimationPlayerInter);\n\n  var _super = QueueState_createSuper(QueueState);\n\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {Object} [options={}] - Options for the state.\r\n   * @param {boolean} [options.autoAdvance=true] - Whether to autmatically advance\r\n   * to the next state in the queue as each state completes.\r\n   * @param {Array.<AbstractState>} [queueStates=[]] - Array of states to be played\r\n   * in order.\r\n   */\n  function QueueState() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var queueStates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    QueueState_classCallCheck(this, QueueState);\n\n    _this = _super.call(this, options);\n    queueStates.forEach(function (state) {\n      _this.addState(state);\n    });\n    _this._queue = _this._states.keys();\n    _this._done = true;\n    return _this;\n  }\n  /**\r\n   * Gets whether the animation queue has reached the end.\r\n   */\n\n\n  QueueState_createClass(QueueState, [{\n    key: "done",\n    get: function get() {\n      return this._done;\n    }\n    /**\r\n     * Gets the internal weight.\r\n     *\r\n     * @readonly\r\n     * @type {number}\r\n     */\n\n  }, {\n    key: "internalWeight",\n    get: function get() {\n      return this._currentState ? this._currentState.internalWeight * this._internalWeight : 0;\n    }\n    /**\r\n     * Restart the queue iterator.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_reset",\n    value: function _reset() {\n      this._queue = this._states.keys();\n\n      var _this$_queue$next = this._queue.next(),\n          value = _this$_queue$next.value,\n          done = _this$_queue$next.done;\n\n      this._done = done;\n      return value || null;\n    }\n    /**\r\n     * Multiplies the user weight by a factor to determine the internal weight.\r\n     *\r\n     * @param {number} factor - 0-1 multiplier to apply to the user weight.\r\n     */\n\n  }, {\n    key: "updateInternalWeight",\n    value: function updateInternalWeight(factor) {\n      QueueState_get(QueueState_getPrototypeOf(QueueState.prototype), "updateInternalWeight", this).call(this, factor);\n\n      if (this._currentState) {\n        this._currentState.updateInternalWeight(this._internalWeight);\n      }\n    }\n    /**\r\n     * Start the next animation in the queue.\r\n     *\r\n     * @param {Function=} onNext - Function to execute each time an animation completes\r\n     * and the queue moves to the next animation.\r\n     * @param {boolean} [wrap=false] - Whether or not to start the queue from the\r\n     * beginning again if the end has been reached.\r\n     *\r\n     * @returns {Deferred}\r\n     */\n\n  }, {\n    key: "next",\n    value: function next(onNext) {\n      var _this2 = this;\n\n      var wrap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      // Move the queue forward\n      var _this$_queue$next2 = this._queue.next(),\n          name = _this$_queue$next2.value,\n          done = _this$_queue$next2.done;\n\n      this._done = done;\n      this._paused = false; // The queue has reached the end\n\n      if (done) {\n        // Start the queue over\n        if (wrap) {\n          return this.play(this._playCallbacks.onFinish, this._playCallbacks.onError, this._playCallbacks.onCancel, onNext);\n        } // Stop the queue\n        else {\n          this._promises.finish.resolve();\n\n          return this._promises.finish;\n        }\n      } // Signal the next animation is starting\n\n\n      if (typeof onNext === \'function\') {\n        var lastName = QueueState_toConsumableArray(this._states.keys())[this._states.size - 1];\n\n        var isQueueEnd = name === lastName;\n        onNext({\n          name: name,\n          canAdvance: this.getState(name).loopCount !== Infinity && !isQueueEnd,\n          isQueueEnd: isQueueEnd\n        });\n      } // Start the next animation\n\n\n      this.playAnimation(name, this._transitionTime, this._easingFn, function () {\n        if (!_this2._paused && !_this2.isTransitioning) {\n          _this2.next(onNext);\n        }\n      }, this._playCallbacks.onError);\n      return this._promises.finish;\n    }\n  }, {\n    key: "play",\n    value: function play(onFinish, onError, onCancel, onNext) {\n      var _this3 = this;\n\n      var name = this._reset();\n\n      QueueState_get(QueueState_getPrototypeOf(QueueState.prototype), "play", this).call(this, onFinish, onError, onCancel);\n\n      if (this._done) {\n        this._promises.finish.resolve();\n      } else {\n        // Signal the next animation is starting\n        if (name !== this.currentAnimation && typeof onNext === \'function\') {\n          var lastName = QueueState_toConsumableArray(this._states.keys())[this._states.size - 1];\n\n          var isQueueEnd = name === lastName;\n          onNext({\n            name: name,\n            canAdvance: name ? this.getState(name).loopCount !== Infinity && !isQueueEnd : true,\n            isQueueEnd: !name || isQueueEnd\n          });\n        } // Start the next animation\n\n\n        this.playAnimation(name, this._currentState ? this._transitionTime : 0, this._easingFn, function () {\n          if (!_this3._paused && !_this3.isTransitioning) {\n            _this3.next(onNext);\n          }\n        }, onError);\n      }\n\n      return this._promises.finish;\n    }\n  }, {\n    key: "pause",\n    value: function pause() {\n      var paused = QueueState_get(QueueState_getPrototypeOf(QueueState.prototype), "pause", this).call(this);\n\n      this.pauseAnimation();\n      return paused;\n    }\n  }, {\n    key: "resume",\n    value: function resume(onFinish, onError, onCancel, onNext) {\n      var _this4 = this;\n\n      if (this._done) {\n        return this.play(onFinish, onError, onCancel, onNext);\n      } else {\n        QueueState_get(QueueState_getPrototypeOf(QueueState.prototype), "resume", this).call(this, onFinish, onError, onCancel);\n\n        this.resumeAnimation(this._currentState.name, this._transitionTime, this._easingFn, function () {\n          if (!_this4._paused && !_this4.isTransitioning) {\n            _this4.next(onNext);\n          }\n        }, onError);\n        return this._promises.finish;\n      }\n    }\n  }, {\n    key: "cancel",\n    value: function cancel() {\n      var canceled = QueueState_get(QueueState_getPrototypeOf(QueueState.prototype), "cancel", this).call(this);\n\n      if (this._currentState) {\n        this._currentState.cancel();\n      }\n\n      return canceled;\n    }\n  }, {\n    key: "stop",\n    value: function stop() {\n      var stopped = QueueState_get(QueueState_getPrototypeOf(QueueState.prototype), "stop", this).call(this);\n\n      this.stopAnimation();\n      this._done = true;\n      return stopped;\n    }\n  }, {\n    key: "discard",\n    value: function discard() {\n      QueueState_get(QueueState_getPrototypeOf(QueueState.prototype), "discard", this).call(this);\n\n      this.discardStates();\n    }\n  }]);\n\n  return QueueState;\n}(animpack_AnimationPlayerInterface.Mixin(state_StateContainerInterface.Mixin(state_AbstractState)));\n\n/* harmony default export */ const state_QueueState = (QueueState);\n;// CONCATENATED MODULE: ./src/core/animpack/state/AbstractBlendState.js\nfunction AbstractBlendState_typeof(obj) { "@babel/helpers - typeof"; return AbstractBlendState_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, AbstractBlendState_typeof(obj); }\n\nfunction AbstractBlendState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AbstractBlendState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AbstractBlendState_createClass(Constructor, protoProps, staticProps) { if (protoProps) AbstractBlendState_defineProperties(Constructor.prototype, protoProps); if (staticProps) AbstractBlendState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction AbstractBlendState_get() { if (typeof Reflect !== "undefined" && Reflect.get) { AbstractBlendState_get = Reflect.get; } else { AbstractBlendState_get = function _get(target, property, receiver) { var base = AbstractBlendState_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return AbstractBlendState_get.apply(this, arguments); }\n\nfunction AbstractBlendState_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = AbstractBlendState_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction AbstractBlendState_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) AbstractBlendState_setPrototypeOf(subClass, superClass); }\n\nfunction AbstractBlendState_setPrototypeOf(o, p) { AbstractBlendState_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return AbstractBlendState_setPrototypeOf(o, p); }\n\nfunction AbstractBlendState_createSuper(Derived) { var hasNativeReflectConstruct = AbstractBlendState_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = AbstractBlendState_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = AbstractBlendState_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return AbstractBlendState_possibleConstructorReturn(this, result); }; }\n\nfunction AbstractBlendState_possibleConstructorReturn(self, call) { if (call && (AbstractBlendState_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return AbstractBlendState_assertThisInitialized(self); }\n\nfunction AbstractBlendState_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction AbstractBlendState_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction AbstractBlendState_getPrototypeOf(o) { AbstractBlendState_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return AbstractBlendState_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n/**\r\n * Base class for a state that blends a collection of {@link AbstractState}.\r\n *\r\n * @abstract\r\n * @implements StateContainerInterface\r\n */\n\nvar AbstractBlendState = /*#__PURE__*/function (_StateContainerInterf) {\n  AbstractBlendState_inherits(AbstractBlendState, _StateContainerInterf);\n\n  var _super = AbstractBlendState_createSuper(AbstractBlendState);\n\n  function AbstractBlendState() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var blendStates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    AbstractBlendState_classCallCheck(this, AbstractBlendState);\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this, options].concat(args));\n    blendStates.forEach(function (state) {\n      _this.addState(state);\n    });\n    return _this;\n  }\n  /**\r\n   * Gets the sum of internal weights of the sub-states.\r\n   *\r\n   * @readonly\r\n   * @type {number}\r\n   */\n\n\n  AbstractBlendState_createClass(AbstractBlendState, [{\n    key: "internalWeight",\n    get: function get() {\n      var blendWeights = 0;\n\n      this._states.forEach(function (state) {\n        blendWeights += state.internalWeight;\n      });\n\n      return blendWeights;\n    }\n    /**\r\n     * Returns the weight of a state controlled by the container.\r\n     *\r\n     * @param {string} name - Name of the state to return the weight from.\r\n     *\r\n     * @returns {number} - Weight of the state.\r\n     */\n\n  }, {\n    key: "getBlendWeight",\n    value: function getBlendWeight(name) {\n      // Make sure the name is valid\n      var state = this.getState(name);\n\n      if (state === undefined) {\n        throw new Error("Cannot get weight of state ".concat(name, " from BlendState ").concat(this.name, ". No state exists with this name."));\n      }\n\n      return state.weight;\n    }\n    /**\r\n     * Sets the weight of a state controlled by the container.\r\n     *\r\n     * @param {string} name - Name of the state to set the weight of.\r\n     * @param {number} weight - Weight value to set on the state.\r\n     *\r\n     * @returns {Deferred}\r\n     */\n\n  }, {\n    key: "setBlendWeight",\n    value: function setBlendWeight(name, weight) {\n      var seconds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var easingFn = arguments.length > 3 ? arguments[3] : undefined;\n      // Make sure the name is valid\n      var state = this.getState(name);\n\n      if (state === undefined) {\n        throw new Error("Cannot set weight of state ".concat(name, " from BlendState ").concat(this.name, ". No state exists with this name."));\n      }\n\n      weight = core_MathUtils.clamp(weight);\n      return state.setWeight(weight, seconds, easingFn);\n    }\n    /**\r\n     * Multiplies the weight of each sub-state by a factor to determine the internal weight.\r\n     *\r\n     * @param {number} factor - 0-1 multiplier to apply to the user weight.\r\n     */\n\n  }, {\n    key: "updateInternalWeight",\n    value: function updateInternalWeight(factor) {\n      var _this2 = this;\n\n      AbstractBlendState_get(AbstractBlendState_getPrototypeOf(AbstractBlendState.prototype), "updateInternalWeight", this).call(this, factor);\n\n      this._states.forEach(function (state) {\n        state.updateInternalWeight(_this2._internalWeight);\n      });\n    }\n    /**\r\n     * Update any values of the sub-states that need to be evaluated every frame.\r\n     *\r\n     * @param {number} deltaTime - Time in milliseconds since the last update.\r\n     */\n\n  }, {\n    key: "update",\n    value: function update(deltaTime) {\n      AbstractBlendState_get(AbstractBlendState_getPrototypeOf(AbstractBlendState.prototype), "update", this).call(this, deltaTime);\n\n      this._states.forEach(function (state) {\n        state.update(deltaTime);\n      });\n    }\n    /**\r\n     * Start playback of the sub-states from the beginning.\r\n     *\r\n     * @param {Function=} onFinish - Function to execute when the state finishes.\r\n     * @param {Function=} onError - Function to execute if the state encounters\r\n     * an error during playback.\r\n     * @param {Function=} onCancel - Function to execute if playback is canceled.\r\n     *\r\n     * @returns {Deferred}\r\n     */\n\n  }, {\n    key: "play",\n    value: function play(onFinish, onError, onCancel) {\n      var promises = [AbstractBlendState_get(AbstractBlendState_getPrototypeOf(AbstractBlendState.prototype), "play", this).call(this)];\n\n      this._states.forEach(function (state) {\n        promises.push(state.play());\n      });\n\n      return core_Deferred.all(promises, onFinish, onError, onCancel);\n    }\n    /**\r\n     * Pause playback of the sub-states. This prevents pending promises from being executed.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "pause",\n    value: function pause() {\n      this._states.forEach(function (state) {\n        state.pause();\n      });\n\n      return AbstractBlendState_get(AbstractBlendState_getPrototypeOf(AbstractBlendState.prototype), "pause", this).call(this);\n    }\n    /**\r\n     * Resume playback of the sub-states.\r\n     *\r\n     * @param {Function=} onFinish - Function to execute when the state finishes.\r\n     * @param {Function=} onError - Function to execute if the state encounters\r\n     * an error during playback.\r\n     * @param {Function=} onCancel - Function to execute if playback is canceled.\r\n     *\r\n     * @returns {Deferred}\r\n     */\n\n  }, {\n    key: "resume",\n    value: function resume(onFinish, onError, onCancel) {\n      var promises = [AbstractBlendState_get(AbstractBlendState_getPrototypeOf(AbstractBlendState.prototype), "resume", this).call(this)];\n\n      this._states.forEach(function (state) {\n        promises.push(state.resume());\n      });\n\n      return core_Deferred.all(promises, onFinish, onError, onCancel);\n    }\n    /**\r\n     * Cancel playback of the sub-states and cancel any pending promises.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "cancel",\n    value: function cancel() {\n      this._states.forEach(function (state) {\n        state.cancel();\n      });\n\n      return AbstractBlendState_get(AbstractBlendState_getPrototypeOf(AbstractBlendState.prototype), "cancel", this).call(this);\n    }\n    /**\r\n     * Stop playback of the sub-states and resolve any pending promises.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "stop",\n    value: function stop() {\n      this._states.forEach(function (state) {\n        state.stop();\n      });\n\n      return AbstractBlendState_get(AbstractBlendState_getPrototypeOf(AbstractBlendState.prototype), "stop", this).call(this);\n    }\n    /**\r\n     * Discards all sub-state resources.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "discard",\n    value: function discard() {\n      AbstractBlendState_get(AbstractBlendState_getPrototypeOf(AbstractBlendState.prototype), "discard", this).call(this);\n\n      this.discardStates();\n    }\n  }]);\n\n  return AbstractBlendState;\n}(state_StateContainerInterface.Mixin(state_AbstractState));\n\n/* harmony default export */ const state_AbstractBlendState = (AbstractBlendState);\n;// CONCATENATED MODULE: ./src/core/animpack/state/FreeBlendState.js\nfunction FreeBlendState_typeof(obj) { "@babel/helpers - typeof"; return FreeBlendState_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, FreeBlendState_typeof(obj); }\n\nfunction FreeBlendState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction FreeBlendState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction FreeBlendState_createClass(Constructor, protoProps, staticProps) { if (protoProps) FreeBlendState_defineProperties(Constructor.prototype, protoProps); if (staticProps) FreeBlendState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction FreeBlendState_get() { if (typeof Reflect !== "undefined" && Reflect.get) { FreeBlendState_get = Reflect.get; } else { FreeBlendState_get = function _get(target, property, receiver) { var base = FreeBlendState_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return FreeBlendState_get.apply(this, arguments); }\n\nfunction FreeBlendState_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = FreeBlendState_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction FreeBlendState_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) FreeBlendState_setPrototypeOf(subClass, superClass); }\n\nfunction FreeBlendState_setPrototypeOf(o, p) { FreeBlendState_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return FreeBlendState_setPrototypeOf(o, p); }\n\nfunction FreeBlendState_createSuper(Derived) { var hasNativeReflectConstruct = FreeBlendState_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = FreeBlendState_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = FreeBlendState_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return FreeBlendState_possibleConstructorReturn(this, result); }; }\n\nfunction FreeBlendState_possibleConstructorReturn(self, call) { if (call && (FreeBlendState_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return FreeBlendState_assertThisInitialized(self); }\n\nfunction FreeBlendState_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction FreeBlendState_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction FreeBlendState_getPrototypeOf(o) { FreeBlendState_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return FreeBlendState_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\r\n * Class for blending N number of blend states.\r\n *\r\n * @extends AbstractBlendState\r\n */\n\nvar FreeBlendState = /*#__PURE__*/function (_AbstractBlendState) {\n  FreeBlendState_inherits(FreeBlendState, _AbstractBlendState);\n\n  var _super = FreeBlendState_createSuper(FreeBlendState);\n\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {Object} [options={}] - Options for the container state.\r\n   * @param {Array.<AbstractState>} [blendStates=[]] - Blend states to be controlled by\r\n   * this container.\r\n   */\n  function FreeBlendState() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var blendStates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    FreeBlendState_classCallCheck(this, FreeBlendState);\n\n    return _super.call(this, options, blendStates);\n  }\n\n  FreeBlendState_createClass(FreeBlendState, [{\n    key: "updateInternalWeight",\n    value: function updateInternalWeight(factor) {\n      var _this = this;\n\n      FreeBlendState_get(FreeBlendState_getPrototypeOf(FreeBlendState.prototype), "updateInternalWeight", this).call(this, factor); // Determine the total active weight of blend states\n\n\n      var sumWeights = 0;\n\n      this._states.forEach(function (state) {\n        sumWeights += state.weight;\n      }); // Ensure the sum of blend state internal weights does not exceed container internal weight\n\n\n      factor /= Math.max(sumWeights, 1); // Sum of blend state internal weights should not exceed container internal weight\n\n      this._states.forEach(function (state) {\n        state.updateInternalWeight(factor * _this._weight);\n      });\n    }\n  }]);\n\n  return FreeBlendState;\n}(state_AbstractBlendState);\n\n/* harmony default export */ const state_FreeBlendState = (FreeBlendState);\n;// CONCATENATED MODULE: ./src/core/animpack/state/Blend1dState.js\nfunction Blend1dState_typeof(obj) { "@babel/helpers - typeof"; return Blend1dState_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, Blend1dState_typeof(obj); }\n\nfunction Blend1dState_toConsumableArray(arr) { return Blend1dState_arrayWithoutHoles(arr) || Blend1dState_iterableToArray(arr) || Blend1dState_unsupportedIterableToArray(arr) || Blend1dState_nonIterableSpread(); }\n\nfunction Blend1dState_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Blend1dState_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Blend1dState_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Blend1dState_arrayLikeToArray(o, minLen); }\n\nfunction Blend1dState_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction Blend1dState_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return Blend1dState_arrayLikeToArray(arr); }\n\nfunction Blend1dState_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Blend1dState_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction Blend1dState_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? Blend1dState_ownKeys(Object(source), !0).forEach(function (key) { Blend1dState_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : Blend1dState_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction Blend1dState_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Blend1dState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Blend1dState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Blend1dState_createClass(Constructor, protoProps, staticProps) { if (protoProps) Blend1dState_defineProperties(Constructor.prototype, protoProps); if (staticProps) Blend1dState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction Blend1dState_get() { if (typeof Reflect !== "undefined" && Reflect.get) { Blend1dState_get = Reflect.get; } else { Blend1dState_get = function _get(target, property, receiver) { var base = Blend1dState_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return Blend1dState_get.apply(this, arguments); }\n\nfunction Blend1dState_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Blend1dState_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Blend1dState_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) Blend1dState_setPrototypeOf(subClass, superClass); }\n\nfunction Blend1dState_setPrototypeOf(o, p) { Blend1dState_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Blend1dState_setPrototypeOf(o, p); }\n\nfunction Blend1dState_createSuper(Derived) { var hasNativeReflectConstruct = Blend1dState_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Blend1dState_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Blend1dState_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Blend1dState_possibleConstructorReturn(this, result); }; }\n\nfunction Blend1dState_possibleConstructorReturn(self, call) { if (call && (Blend1dState_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return Blend1dState_assertThisInitialized(self); }\n\nfunction Blend1dState_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Blend1dState_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction Blend1dState_getPrototypeOf(o) { Blend1dState_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Blend1dState_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n/**\r\n * Class for blending N number of blend states based on a single\r\n * parameter.\r\n *\r\n * @extends AbstractBlendState\r\n */\n\nvar Blend1dState = /*#__PURE__*/function (_AbstractBlendState) {\n  Blend1dState_inherits(Blend1dState, _AbstractBlendState);\n\n  var _super = Blend1dState_createSuper(Blend1dState);\n\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {Object} [options] - Options for the container state\r\n   * @param {Array.<AbstractBlendState>} [blendStates=[]] - Blend states to be\r\n   * controlled by this container.\r\n   * @param {Array.<number>} [blendThresholds=[]] - Threshold values for activating\r\n   * each blend state.\r\n   * @param {Array.<boolean>} [phaseMatches=[]] - Booleans indicating whether or not\r\n   * each blend state should be phase matched.\r\n   */\n  function Blend1dState() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var blendStates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var blendThresholds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var phaseMatches = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n    Blend1dState_classCallCheck(this, Blend1dState);\n\n    _this = _super.call(this, options, blendStates);\n    _this._blendValue = 0;\n    _this._promises = Blend1dState_objectSpread(Blend1dState_objectSpread({}, _this._promises), {}, {\n      blendValue: core_Deferred.resolve()\n    }); // Validate there are no duplicate thresholds\n\n    var nonZeroDifferentSize = blendStates.length !== 0 && blendStates.length !== blendThresholds.length;\n\n    if (nonZeroDifferentSize) {\n      throw new Error("Cannot create Blend1dState with blendThresholds ".concat(blendThresholds, ". BlendThresholds count does not match blendStates count."));\n    }\n\n    var containsDuplicates = new Set(blendThresholds).size !== blendThresholds.length;\n\n    if (containsDuplicates) {\n      throw new Error("Cannot create Blend1dState with blendThresholds ".concat(blendThresholds, ". BlendThresholds contains duplicate values"));\n    } // Initialize the thresholds map\n\n\n    _this._thresholds = [];\n\n    Blend1dState_toConsumableArray(_this._states.values()).forEach(function (state, index) {\n      _this._thresholds.push({\n        value: blendThresholds[index],\n        name: state.name,\n        phaseMatch: phaseMatches[index] || false\n      });\n    });\n\n    _this._sortThresholds();\n\n    _this._forceNoThresholdDupes = true;\n    _this._phaseLeadState = null;\n\n    _this._updateBlendWeights();\n\n    return _this;\n  }\n  /**\r\n   * Gets and sets the blend parameter value.\r\n   */\n\n\n  Blend1dState_createClass(Blend1dState, [{\n    key: "blendValue",\n    get: function get() {\n      return this._blendValue;\n    },\n    set: function set(value) {\n      this._blendValue = value;\n    }\n    /**\r\n     * Gets whether or not the blend value is currently being animated.\r\n     */\n\n  }, {\n    key: "blendValuePending",\n    get: function get() {\n      return this._promises.blendValue && this._promises.blendValue.pending;\n    }\n    /**\r\n     * Updates the user defined weight over time.\r\n     *\r\n     * @param {null} name - Unused parameter.\r\n     * @param {number} weight - The target weight value.\r\n     * @param {number} [seconds=0] - The amount of time it will take to reach the\r\n     * target weight.\r\n     * @param {Function=} easingFn - The easing function to use for interpolation.\r\n     *\r\n     * @returns {Deferred}\r\n     */\n\n  }, {\n    key: "setBlendWeight",\n    value: function setBlendWeight(name, value) {\n      var _this2 = this;\n\n      var seconds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var easingFn = arguments.length > 3 ? arguments[3] : undefined;\n\n      this._promises.blendValue.cancel();\n\n      this._promises.blendValue = animpack_AnimationUtils.interpolateProperty(this, \'blendValue\', value, {\n        seconds: seconds,\n        easingFn: easingFn,\n        onProgress: function onProgress() {\n          _this2._updateBlendWeights();\n        },\n        onFinish: function onFinish() {\n          _this2._updateBlendWeights();\n        }\n      });\n      return this._promises.blendValue;\n    }\n    /**\r\n     * Gets the user defined weight.\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: "getBlendWeight",\n    value: function getBlendWeight() {\n      return this.blendValue;\n    }\n  }, {\n    key: "addState",\n    value: function addState(state) {\n      var thresholdValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var phaseMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      this._thresholds = this._thresholds || []; // Make sure there is not already a state with this threshold\n\n      var sameValue = this._thresholds.find(function (threshold) {\n        return threshold.value === thresholdValue;\n      });\n\n      if (this._forceNoThresholdDupes && sameValue !== undefined) {\n        throw new Error("Cannot set blend threshold of ".concat(thresholdValue, " for state ").concat(state.name, " on ").concat(this.name, ". A state already exists with that threshold."));\n      }\n\n      Blend1dState_get(Blend1dState_getPrototypeOf(Blend1dState.prototype), "addState", this).call(this, state);\n\n      this._thresholds.push({\n        value: thresholdValue,\n        name: state.name,\n        phaseMatch: phaseMatch || false\n      });\n\n      this._sortThresholds();\n\n      return state.name;\n    }\n  }, {\n    key: "removeState",\n    value: function removeState(name) {\n      var removed = Blend1dState_get(Blend1dState_getPrototypeOf(Blend1dState.prototype), "removeState", this).call(this, name);\n\n      if (removed) {\n        var index = this._thresholds.findIndex(function (threshold) {\n          return threshold.name === name;\n        });\n\n        this._thresholds.splice(index, 1);\n      }\n\n      return removed;\n    }\n  }, {\n    key: "renameState",\n    value: function renameState(currentName, newName) {\n      newName = Blend1dState_get(Blend1dState_getPrototypeOf(Blend1dState.prototype), "renameState", this).call(this, currentName, newName);\n\n      var threshold = this._thresholds.find(function (threshold) {\n        return threshold.name === currentName;\n      });\n\n      threshold.name = newName;\n      return newName;\n    }\n    /**\r\n     * Gets the threshold value of a blend with the corresponding name.\r\n     *\r\n     * @param {string} name - Name of the blend to get the threshold of.\r\n     *\r\n     * @returns {number} Threhold value.\r\n     */\n\n  }, {\n    key: "getBlendThreshold",\n    value: function getBlendThreshold(name) {\n      var threshold = this._thresholds.find(function (threshold) {\n        return threshold.name === name;\n      });\n\n      if (threshold === undefined) {\n        throw new Error("Cannot get blend threshold of state ".concat(name, " on ").concat(this.name, ". No state exists with that name."));\n      }\n\n      return threshold.value;\n    }\n    /**\r\n     * Sets the threshold value of a blend with the corresponding name.\r\n     *\r\n     * @param {string} name - Name of the blend to set the threshold.\r\n     * @param {number} value - Value of the threshold to set.\r\n     *\r\n     * @returns {number} Set threshold value.\r\n     */\n\n  }, {\n    key: "setBlendThreshold",\n    value: function setBlendThreshold(name, value) {\n      // Make sure there is not already a state with this threshold\n      var sameValue = this._thresholds.find(function (threshold) {\n        return threshold.value === value;\n      });\n\n      if (sameValue !== undefined) {\n        throw new Error("Cannot set blend threshold of ".concat(value, " for state ").concat(name, " on ").concat(this.name, ". A state already exists with that threshold."));\n      }\n\n      var threshold = this._thresholds.find(function (threshold) {\n        return threshold.name === name;\n      });\n\n      if (threshold === undefined) {\n        throw new Error("Cannot set blend threshold of state ".concat(name, " on ").concat(this.name, ". No state exists with that name."));\n      }\n\n      threshold.value = value;\n\n      this._sortThresholds();\n\n      return threshold.value;\n    }\n  }, {\n    key: "updateInternalWeight",\n    value: function updateInternalWeight(factor) {\n      var _this3 = this;\n\n      Blend1dState_get(Blend1dState_getPrototypeOf(Blend1dState.prototype), "updateInternalWeight", this).call(this, factor);\n\n      if (this._phaseLeadState) {\n        this._states.forEach(function (state) {\n          if (state.weight !== 0) {\n            state.normalizedTime = _this3._phaseLeadState.normalizedTime;\n          }\n        });\n      }\n    }\n    /**\r\n     * Updates the blend weights based on their corresponding threshold values\r\n     * and the current blendValue. Additionally, sets a lead phase state if the\r\n     * conditions for phase-matching have been satisfied.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_updateBlendWeights",\n    value: function _updateBlendWeights() {\n      var _this4 = this;\n\n      if (this._thresholds.length === 0) return;\n\n      if (this._thresholds.length === 1) {\n        var state = this._states.get(this._thresholds[0].name);\n\n        state.setWeight(1);\n        return;\n      } // Initially set all sub-state weights to zero\n\n\n      this._states.forEach(function (state) {\n        state.setWeight(0);\n      });\n\n      this._phaseLeadState = null; // Find the first threshold that is greater than or equal to the parameter value\n\n      var targetIndex = this._thresholds.findIndex(function (threshold) {\n        return threshold.value >= _this4._blendValue;\n      });\n\n      if (targetIndex === 0 || targetIndex === -1) {\n        // Give one state full influence\n        targetIndex = targetIndex === -1 ? this._thresholds.length - 1 : 0;\n\n        var _state = this._states.get(this._thresholds[targetIndex].name);\n\n        _state.setWeight(1);\n      } else {\n        // Linear interpolate influence between two states\n        var thresholdA = this._thresholds[targetIndex - 1];\n        var thresholdB = this._thresholds[targetIndex];\n        var factorB = (this.blendValue - thresholdA.value) / (thresholdB.value - thresholdA.value);\n        var factorA = 1 - factorB;\n\n        var stateA = this._states.get(thresholdA.name);\n\n        var stateB = this._states.get(thresholdB.name);\n\n        stateA.setWeight(factorA);\n        stateB.setWeight(factorB); // Set phase-matching if needed\n\n        if (thresholdA.phaseMatch && thresholdB.phaseMatch) {\n          this._phaseLeadState = factorA > factorB ? stateA : stateB;\n        }\n      }\n    }\n    /**\r\n     * Sorts the thresholds from low to high based on value.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_sortThresholds",\n    value: function _sortThresholds() {\n      this._thresholds.sort(function (a, b) {\n        return a.value - b.value;\n      });\n    }\n  }]);\n\n  return Blend1dState;\n}(state_AbstractBlendState);\n\n/* harmony default export */ const state_Blend1dState = (Blend1dState);\n;// CONCATENATED MODULE: ./src/core/animpack/state/Blend2dState.js\nfunction Blend2dState_typeof(obj) { "@babel/helpers - typeof"; return Blend2dState_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, Blend2dState_typeof(obj); }\n\nfunction Blend2dState_toConsumableArray(arr) { return Blend2dState_arrayWithoutHoles(arr) || Blend2dState_iterableToArray(arr) || Blend2dState_unsupportedIterableToArray(arr) || Blend2dState_nonIterableSpread(); }\n\nfunction Blend2dState_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Blend2dState_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Blend2dState_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Blend2dState_arrayLikeToArray(o, minLen); }\n\nfunction Blend2dState_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction Blend2dState_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return Blend2dState_arrayLikeToArray(arr); }\n\nfunction Blend2dState_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Blend2dState_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction Blend2dState_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? Blend2dState_ownKeys(Object(source), !0).forEach(function (key) { Blend2dState_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : Blend2dState_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction Blend2dState_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Blend2dState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Blend2dState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Blend2dState_createClass(Constructor, protoProps, staticProps) { if (protoProps) Blend2dState_defineProperties(Constructor.prototype, protoProps); if (staticProps) Blend2dState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction Blend2dState_get() { if (typeof Reflect !== "undefined" && Reflect.get) { Blend2dState_get = Reflect.get; } else { Blend2dState_get = function _get(target, property, receiver) { var base = Blend2dState_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return Blend2dState_get.apply(this, arguments); }\n\nfunction Blend2dState_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Blend2dState_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Blend2dState_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) Blend2dState_setPrototypeOf(subClass, superClass); }\n\nfunction Blend2dState_setPrototypeOf(o, p) { Blend2dState_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Blend2dState_setPrototypeOf(o, p); }\n\nfunction Blend2dState_createSuper(Derived) { var hasNativeReflectConstruct = Blend2dState_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Blend2dState_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Blend2dState_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Blend2dState_possibleConstructorReturn(this, result); }; }\n\nfunction Blend2dState_possibleConstructorReturn(self, call) { if (call && (Blend2dState_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return Blend2dState_assertThisInitialized(self); }\n\nfunction Blend2dState_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Blend2dState_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction Blend2dState_getPrototypeOf(o) { Blend2dState_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Blend2dState_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable no-underscore-dangle */\n\n\n\n\n/**\r\n * Class for blending N number of blend states based on two\r\n * paramters.\r\n *\r\n * @extends AbstractBlendState\r\n */\n\nvar Blend2dState = /*#__PURE__*/function (_AbstractBlendState) {\n  Blend2dState_inherits(Blend2dState, _AbstractBlendState);\n\n  var _super = Blend2dState_createSuper(Blend2dState);\n\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {Object} [options] - Options for the container state\r\n   * @param {Array.<AbstractBlendState>} [blendStates=[]] - Blend states to be\r\n   * controlled by this container.\r\n   * @param {Array.<Array.<number>>} [blendThresholds=[]] - Threshold values for activating\r\n   * each blend state.\r\n   * @param {Array.<boolean>} [phaseMatches=[]] - Booleans indicating whether or not\r\n   * each blend state should be phase matched.\r\n   */\n  function Blend2dState() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var blendStates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var blendThresholds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var phaseMatches = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n    Blend2dState_classCallCheck(this, Blend2dState);\n\n    _this = _super.call(this, options, blendStates);\n\n    if (blendStates.length !== blendThresholds.length) {\n      throw new Error("Cannot create Blend2dState with blendStates ".concat(blendStates, " and blendThresholds ").concat(blendThresholds, ". Count of blendStates must match count of blendThresholds."));\n    }\n\n    blendThresholds.slice(0, blendThresholds.length - 1).forEach(function (threshold, index) {\n      blendThresholds.slice(index + 1).forEach(function (otherThreshold) {\n        if (threshold[0] === otherThreshold[0] && threshold[1] === otherThreshold[1]) {\n          throw new Error("Cannot create Blend2dState with blendThresholds ".concat(blendThresholds, ". No duplicate values allowed in blendThresholds."));\n        }\n      });\n    });\n    _this._blendValueX = 0;\n    _this._blendValueY = 0;\n    _this._promises = Blend2dState_objectSpread(Blend2dState_objectSpread({}, _this._promises), {}, {\n      blendValueX: core_Deferred.resolve(),\n      blendValueY: core_Deferred.resolve()\n    });\n    _this._thresholds = [];\n\n    Blend2dState_toConsumableArray(_this._states.values()).forEach(function (state, index) {\n      _this._thresholds.push({\n        name: state.name,\n        phaseMatch: phaseMatches[index] || false\n      });\n    });\n\n    _this._vertices = blendThresholds;\n\n    if (_this._vertices.length >= 3) {\n      _this._triangles = core_MathUtils.getDelaunayTriangulation(_this._vertices);\n    }\n\n    _this._phaseLeadState = null;\n\n    _this._updateBlendWeights();\n\n    return _this;\n  }\n  /**\r\n   * Updates the user defined weight over time.\r\n   *\r\n   * @param {string} name - Name of blend weight to update.\r\n   * @param {number} weight - Target weight value.\r\n   * @param {number} [seconds=0] - The amount of time it will take to reach the\r\n   * target value.\r\n   * @param {Function=} easingFn - The easing function to use for interpolation.\r\n   *\r\n   * @returns {Deferred}\r\n   */\n\n\n  Blend2dState_createClass(Blend2dState, [{\n    key: "setBlendWeight",\n    value: function setBlendWeight(name, value) {\n      var _this2 = this;\n\n      var seconds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var easingFn = arguments.length > 3 ? arguments[3] : undefined;\n      var property = "blendValue".concat(name.toUpperCase());\n\n      if (property !== \'blendValueX\' && property !== \'blendValueY\') {\n        throw new Error("Cannot set blend weight for ".concat(name, " on ").concat(this.name, ". Blend2dState only accepts \'X\' or \'Y\' for setBlendWeight"));\n      }\n\n      this._promises[property].cancel();\n\n      this._promises[property] = animpack_AnimationUtils.interpolateProperty(this, property, value, {\n        seconds: seconds,\n        easingFn: easingFn,\n        onProgress: function onProgress() {\n          _this2._updateBlendWeights();\n        },\n        onFinish: function onFinish() {\n          _this2._updateBlendWeights();\n        }\n      });\n      return this._promises[property];\n    }\n    /**\r\n     * Gets the user defined weight.\r\n     *\r\n     * @param {string} name - Name of blend weight.\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: "getBlendWeight",\n    value: function getBlendWeight(name) {\n      var property = name.toUpperCase();\n\n      if (property !== \'X\' && property !== \'Y\') {\n        throw new Error("Cannot get blend weight for ".concat(name, " on ").concat(this.name, ". Blend2dState only accepts \'X\' or \'Y\' for getBlendWeight"));\n      }\n\n      return property === \'X\' ? this._blendValueX : this._blendValueY;\n    }\n    /**\r\n     * Gets and sets the x blend weight.\r\n     */\n\n  }, {\n    key: "blendValueX",\n    get: function get() {\n      return this._blendValueX;\n    },\n    set: function set(value) {\n      this._blendValueX = value;\n    }\n    /**\r\n     * Gets and sets the y blend weight.\r\n     */\n\n  }, {\n    key: "blendValueY",\n    get: function get() {\n      return this._blendValueY;\n    },\n    set: function set(value) {\n      this._blendValueY = value;\n    }\n    /**\r\n     * Gets whether or not the x blend value is currently being animated.\r\n     */\n\n  }, {\n    key: "blendValueXPending",\n    get: function get() {\n      return this._promises.blendValueX && this._promises.blendValueX.pending;\n    }\n    /**\r\n     * Gets whether or not the y blend value is currently being animated.\r\n     */\n\n  }, {\n    key: "blendValueYPending",\n    get: function get() {\n      return this._promises.blendValueY && this._promises.blendValueY.pending;\n    }\n  }, {\n    key: "updateInternalWeight",\n    value: function updateInternalWeight(factor) {\n      var _this3 = this;\n\n      Blend2dState_get(Blend2dState_getPrototypeOf(Blend2dState.prototype), "updateInternalWeight", this).call(this, factor);\n\n      if (this._phaseLeadState) {\n        Blend2dState_toConsumableArray(this._states.values()).forEach(function (state, index) {\n          if (state.weight !== 0 && _this3._thresholds[index].phaseMatch) {\n            state.normalizedTime = _this3._phaseLeadState.normalizedTime;\n          }\n        });\n      }\n    }\n    /**\r\n     * Updates the blend weights based on their corresponding threshold values\r\n     * and the current [x,y] blendValue. Additionally, sets a lead phase state if the\r\n     * conditions for phase-matching have been satisfied.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_updateBlendWeights",\n    value: function _updateBlendWeights() {\n      var _this4 = this;\n\n      if (!this._vertices || this._vertices.length === 0) return;\n\n      if (this._vertices.length === 1) {\n        Blend2dState_toConsumableArray(this._states.values())[0].weight = 1;\n        return;\n      } // Initially set all sub-state weights to zero\n\n\n      this._states.forEach(function (state) {\n        state.setWeight(0);\n      });\n\n      this._phaseLeadState = null;\n      var p = [this._blendValueX, this._blendValueY];\n\n      if (this._vertices.length === 2) {\n        this._setInfluenceClosestPointOnLine(p);\n      } else {\n        var triangle = this._triangles.find(function (triangle) {\n          return core_MathUtils.isPointInTriangle(_this4._vertices[triangle[0]], _this4._vertices[triangle[1]], _this4._vertices[triangle[2]], p);\n        });\n\n        if (triangle) {\n          this._setInfluenceTriangle(triangle, p);\n        } else {\n          this._setInfluenceClosestPointInTriangles(p);\n        }\n      }\n    }\n    /**\r\n     * Sets blend weights for states corresponding to a\r\n     * triangle of thresholds and a given [x,y] blendValues.\r\n     *\r\n     * @param {Array.<Array.<number>>} triangle - Set of triangluated indices\r\n     * that correspond to blend thresholds.\r\n     * @param {Array.<number>} p - Given [x,y] blendValue.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_setInfluenceTriangle",\n    value: function _setInfluenceTriangle(triangle, p) {\n      var areaA = core_MathUtils.triangleArea(this._vertices[triangle[1]], this._vertices[triangle[2]], p);\n      var areaB = core_MathUtils.triangleArea(this._vertices[triangle[0]], this._vertices[triangle[2]], p);\n      var areaC = core_MathUtils.triangleArea(this._vertices[triangle[0]], this._vertices[triangle[1]], p);\n      var totalArea = areaA + areaB + areaC;\n      var weightA = areaA / totalArea;\n      var weightB = areaB / totalArea;\n      var weightC = areaC / totalArea;\n      var thresholdA = this._thresholds[triangle[0]];\n      var thresholdB = this._thresholds[triangle[1]];\n      var thresholdC = this._thresholds[triangle[2]];\n\n      var stateA = this._states.get(thresholdA.name);\n\n      var stateB = this._states.get(thresholdB.name);\n\n      var stateC = this._states.get(thresholdC.name);\n\n      stateA.setWeight(weightA);\n      stateB.setWeight(weightB);\n      stateC.setWeight(weightC);\n\n      this._setPhaseLeadState([stateA, stateB, stateC], [thresholdA.phaseMatch, thresholdB.phaseMatch, thresholdC.phaseMatch]);\n    }\n    /**\r\n     * Determines the closest point within a triangle of\r\n     * thresholds based on the current [x,y] blendValues and\r\n     * then sets blend weights for the corresponding states.\r\n     *\r\n     * @param {Array.<number>} p - Given [x,y] blendValue.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_setInfluenceClosestPointInTriangles",\n    value: function _setInfluenceClosestPointInTriangles(p) {\n      var _this5 = this;\n\n      var globalClosestPoint = null;\n      var globalMinDist = Number.POSITIVE_INFINITY;\n      var closestTriangle = -1;\n\n      this._triangles.forEach(function (triangle, index) {\n        var pointA = core_MathUtils.closestPointOnLine(_this5._vertices[triangle[0]], _this5._vertices[triangle[1]], p);\n        var pointB = core_MathUtils.closestPointOnLine(_this5._vertices[triangle[1]], _this5._vertices[triangle[2]], p);\n        var pointC = core_MathUtils.closestPointOnLine(_this5._vertices[triangle[2]], _this5._vertices[triangle[0]], p);\n        var distA = core_MathUtils.distanceSquared(pointA, p);\n        var distB = core_MathUtils.distanceSquared(pointB, p);\n        var distC = core_MathUtils.distanceSquared(pointC, p);\n        var localClosestPoint = pointC;\n        var localMinDist = distC;\n\n        if (distA < localMinDist) {\n          localClosestPoint = pointA;\n          localMinDist = distA;\n        }\n\n        if (distB < localMinDist) {\n          localClosestPoint = pointB;\n          localMinDist = distB;\n        }\n\n        if (localMinDist < globalMinDist) {\n          globalMinDist = localMinDist;\n          globalClosestPoint = Blend2dState_toConsumableArray(localClosestPoint);\n          closestTriangle = index;\n        }\n      });\n\n      this._setInfluenceTriangle(this._triangles[closestTriangle], globalClosestPoint);\n    }\n    /**\r\n     * Determines the closest point on the line formed between the\r\n     * two blend thresholds based on the current [x,y] blendValues and\r\n     * then sets blend weights for the corresponding states.\r\n     *\r\n     * @param {Array.<number>} p - Given [x,y] blendValue.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_setInfluenceClosestPointOnLine",\n    value: function _setInfluenceClosestPointOnLine(p) {\n      var closestPoint = core_MathUtils.closestPointOnLine(this._vertices[[0]], this._vertices[[1]], p);\n      var distA = core_MathUtils.distanceSquared(this._vertices[0], closestPoint);\n      var distB = core_MathUtils.distanceSquared(this._vertices[1], closestPoint);\n      var weightA = distB / (distA + distB);\n      var weightB = distA / (distA + distB);\n      var thresholdA = this._thresholds[0];\n      var thresholdB = this._thresholds[1];\n\n      var stateA = this._states.get(thresholdA.name);\n\n      var stateB = this._states.get(thresholdB.name);\n\n      stateA.setWeight(weightA);\n      stateB.setWeight(weightB);\n\n      this._setPhaseLeadState([stateA, stateB], [thresholdA.phaseMatch, thresholdB.phaseMatch]);\n    }\n    /**\r\n     * Sets a lead phase state if the conditions\r\n     * for phase-matching are satisfied.\r\n     *\r\n     * @param {Array.<AbstractBlendState>} states - States to\r\n     * check phase-matching criteria.\r\n     * @param {Array.<boolean>} phaseMatched - List of phase-match booleans.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_setPhaseLeadState",\n    value: function _setPhaseLeadState(states, phaseMatched) {\n      var _this6 = this;\n\n      var max = 0;\n      states.forEach(function (state, index) {\n        if (phaseMatched[index] && state.weight > max) {\n          _this6._phaseLeadState = state;\n          max = state.weight;\n        }\n      });\n    }\n  }]);\n\n  return Blend2dState;\n}(state_AbstractBlendState);\n\n/* harmony default export */ const state_Blend2dState = (Blend2dState);\n;// CONCATENATED MODULE: ./src/core/animpack/AnimationLayer.js\nfunction AnimationLayer_typeof(obj) { "@babel/helpers - typeof"; return AnimationLayer_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, AnimationLayer_typeof(obj); }\n\nfunction AnimationLayer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AnimationLayer_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AnimationLayer_createClass(Constructor, protoProps, staticProps) { if (protoProps) AnimationLayer_defineProperties(Constructor.prototype, protoProps); if (staticProps) AnimationLayer_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction AnimationLayer_get() { if (typeof Reflect !== "undefined" && Reflect.get) { AnimationLayer_get = Reflect.get; } else { AnimationLayer_get = function _get(target, property, receiver) { var base = AnimationLayer_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return AnimationLayer_get.apply(this, arguments); }\n\nfunction AnimationLayer_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = AnimationLayer_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction AnimationLayer_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) AnimationLayer_setPrototypeOf(subClass, superClass); }\n\nfunction AnimationLayer_setPrototypeOf(o, p) { AnimationLayer_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return AnimationLayer_setPrototypeOf(o, p); }\n\nfunction AnimationLayer_createSuper(Derived) { var hasNativeReflectConstruct = AnimationLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = AnimationLayer_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = AnimationLayer_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return AnimationLayer_possibleConstructorReturn(this, result); }; }\n\nfunction AnimationLayer_possibleConstructorReturn(self, call) { if (call && (AnimationLayer_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return AnimationLayer_assertThisInitialized(self); }\n\nfunction AnimationLayer_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction AnimationLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction AnimationLayer_getPrototypeOf(o) { AnimationLayer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return AnimationLayer_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n\n\n/**\r\n * Enum for types of {@link AnimationLayer} blending.\r\n *\r\n * @readonly\r\n * @enum {string}\r\n */\n\nvar LayerBlendModes = {\n  Override: \'Override\',\n  Additive: \'Additive\'\n};\n/**\r\n * The default blending mode {@link AnimationLayer}.\r\n *\r\n * @readonly\r\n * @type {string}\r\n */\n\nvar DefaultLayerBlendMode = \'Override\';\n/**\r\n * Checks if a given blendMode is present in the values of {@link LayerBlendModes}.\r\n * If it is, return the original value, otherwise return {@link DefaultLayerBlendMode}.\r\n *\r\n * @param {string} blendMode - The name of the type of blending.\r\n *\r\n * @returns {(string|DefaultLayerBlendMode)}\r\n */\n\nfunction validateBlendMode(blendMode) {\n  if (Array.from(Object.values(LayerBlendModes)).includes(blendMode)) {\n    return blendMode;\n  } else {\n    return DefaultLayerBlendMode;\n  }\n}\n/**\r\n * Class for managing a set of animations where only one state can be active at\r\n * any given time.\r\n *\r\n * @implements AnimationPlayerInterface\r\n * @implements StateContainerInterface\r\n */\n\nvar AnimationLayer = /*#__PURE__*/function (_AnimationPlayerInter) {\n  AnimationLayer_inherits(AnimationLayer, _AnimationPlayerInter);\n\n  var _super = AnimationLayer_createSuper(AnimationLayer);\n\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {Object=} options -  Options for the animation layer.\r\n   * @param {string} options.name - Name of the layer. Names must be unique to the\r\n   * animation feature that contains the layer.\r\n   * @param {LayerBlendModes} [options.blendMode=DefaultLayerBlendMode] -\r\n   * Type of blending to use for all states controlled by the layer.\r\n   * @param {number} [options.weight=1] - The amount of influence the layer\'s current\r\n   * animation has over the result for the host.\r\n   * @param {number} [options.transitionTime=0] - The default amount of time to use when\r\n   * playing and resuming animations.\r\n   * @param {Function=} options.easingFn - The default easing function to use when\r\n   * transitioning between animations and setting layer weight.\r\n   */\n  function AnimationLayer() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    AnimationLayer_classCallCheck(this, AnimationLayer);\n\n    _this = _super.call(this, options);\n    _this.name = options.name === undefined ? \'AnimationLayer\' : options.name;\n    _this._blendMode = Array.from(Object.values(LayerBlendModes)).includes(options.blendMode) ? options.blendMode : DefaultLayerBlendMode;\n    _this._promises = {\n      weight: core_Deferred.resolve()\n    };\n    _this._weightPaused = false;\n    _this.weight = typeof options.weight === \'number\' ? options.weight : 1;\n    _this._internalWeight = _this._weight;\n    return _this;\n  }\n  /**\r\n   * Gets the type of blending used for states controlled by the layer.\r\n   *\r\n   * @readonly\r\n   * @type {string}\r\n   */\n\n\n  AnimationLayer_createClass(AnimationLayer, [{\n    key: "blendMode",\n    get: function get() {\n      return this._blendMode;\n    }\n    /**\r\n     * Gets and sets the amount of influence the layer\'s current animation has over\r\n     * the result for the host.\r\n     *\r\n     * @type {number}\r\n     */\n\n  }, {\n    key: "weight",\n    get: function get() {\n      return this._weight;\n    }\n    /**\r\n     * Gets whether or not the layer\'s weight value is currently being animated.\r\n     *\r\n     * @readonly\r\n     * @type {boolean}\r\n     */\n    ,\n    set: function set(weight) {\n      this._weight = core_MathUtils.clamp(weight, 0, 1);\n    }\n  }, {\n    key: "weightPending",\n    get: function get() {\n      return this._promises.weight && this._promises.weight.pending;\n    }\n    /**\r\n     * Pause the current animation state and any interpolation happening on the layer\'s\r\n     * weight property.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "pause",\n    value: function pause() {\n      this._paused = true;\n      this._weightPaused = true;\n      return this.pauseAnimation() || this.weightPending;\n    }\n    /**\r\n     * Resume the current animation state and any interpolation happening on the layer\'s\r\n     * weight property.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "resume",\n    value: function resume() {\n      this._paused = false;\n      this._weightPaused = false;\n      var isWeightActive = this.weightPending;\n\n      if (this._currentState) {\n        return this.resumeAnimation() || isWeightActive;\n      } else {\n        return isWeightActive;\n      }\n    }\n    /**\r\n     * Updates the user defined weight over time.\r\n     *\r\n     * @param {number} weight - The target weight value.\r\n     * @param {number} [seconds=0] - The amount of time it will take to reach the\r\n     * target weight.\r\n     * @param {Function=} easingFn - The easing function to use for interpolation.\r\n     *\r\n     * @returns {Deferred}\r\n     */\n\n  }, {\n    key: "setWeight",\n    value: function setWeight(weight) {\n      var seconds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var easingFn = arguments.length > 2 ? arguments[2] : undefined;\n\n      if (this.weightPending) {\n        this._promises.weight.cancel();\n      }\n\n      weight = core_MathUtils.clamp(weight);\n      this._promises.weight = animpack_AnimationUtils.interpolateProperty(this, \'weight\', weight, {\n        seconds: seconds,\n        easingFn: easingFn !== undefined ? easingFn : this._easingFn\n      });\n      return this._promises.weight;\n    }\n    /**\r\n     * Pause any interpolation happening on the layer\'s weight property.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "pauseWeight",\n    value: function pauseWeight() {\n      this._weightPaused = true;\n      return this.weightPending;\n    }\n    /**\r\n     * Resume any interpolation happening on the layer\'s weight property.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "resumeWeight",\n    value: function resumeWeight() {\n      this._weightPaused = false;\n      return this.weightPending;\n    }\n    /**\r\n     * Multiplies the user weight by a factor to determine the internal weight.\r\n     *\r\n     * @param {number} factor - 0-1 multiplier to apply to the user weight.\r\n     */\n\n  }, {\n    key: "updateInternalWeight",\n    value: function updateInternalWeight(factor) {\n      this._internalWeight = this._weight * factor;\n\n      if (this._currentState) {\n        this._currentState.updateInternalWeight(this._internalWeight);\n      }\n    }\n    /**\r\n     * Returns the names of blend states in an animation.\r\n     *\r\n     * @param {string} animationName - Name of the animation.\r\n     *\r\n     * @returns {Array.<string>} - Names of blend states.\r\n     */\n\n  }, {\n    key: "getAnimationBlendNames",\n    value: function getAnimationBlendNames(animationName) {\n      var state = this.getState(animationName);\n\n      if (state === undefined) {\n        throw new Error("Cannot get blend names of animation ".concat(animationName, " on layer ").concat(this.name, ". No animation exists with this name."));\n      }\n\n      if (state instanceof state_AbstractBlendState) {\n        return state.getStateNames();\n      }\n\n      throw new Error("Cannot get blend names of animation ".concat(animationName, " on layer ").concat(this.name, ". Animation is not an instance of AbstractBlendState."));\n    }\n    /**\r\n     * Update the weight for a blend state of an animation.\r\n     *\r\n     * @param {string} animationName - Name of the animation containing the blend state\r\n     * to update.\r\n     * @param {string} blendName - Name of the blend state to update.\r\n     * @param {number} weight - Weight value to set on the animation. This number shoudld be\r\n     * in the 0-1 range.\r\n     * @param {number=} seconds - Number of seconds it should take to reach the new weight.\r\n     * Default is zero and will set immediately.\r\n     * @param {Function=} easingFn - Easing function to use while interpolating the new\r\n     * weight. Default is Easing.Linear.InOut.\r\n     *\r\n     * @returns {Deferred} - Promise that will resolve once the animation\'s weight reaches\r\n     * the target value.\r\n     */\n\n  }, {\n    key: "setAnimationBlendWeight",\n    value: function setAnimationBlendWeight(animationName, blendName, weight) {\n      var seconds = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var easingFn = arguments.length > 4 ? arguments[4] : undefined;\n      var state = this.getState(animationName);\n\n      if (state === undefined) {\n        throw new Error("Cannot set blend weight of animation ".concat(animationName, " on layer ").concat(this.name, ". No animation exists with this name."));\n      }\n\n      if (state instanceof state_AbstractBlendState) {\n        return state.setBlendWeight(blendName, weight, seconds, easingFn);\n      }\n\n      throw new Error("Cannot set blend weight of animation ".concat(animationName, " on layer ").concat(this.name, ". Animation is not an instance of AbstractBlendState."));\n    }\n    /**\r\n     * Returns the weight for a blend state of an animation.\r\n     *\r\n     * @param {string} animationName - Name of the animation containing the blend state\r\n     * to update.\r\n     * @param {string} blendName - Name of the blend state to retrieve the weight of.\r\n     *\r\n     * @returns {number} - Weight of the blend state.\r\n     */\n\n  }, {\n    key: "getAnimationBlendWeight",\n    value: function getAnimationBlendWeight(animationName, blendName) {\n      var state = this.getState(animationName);\n\n      if (state === undefined) {\n        throw new Error("Cannot get blend weight of animation ".concat(animationName, " on layer ").concat(this.name, ". No animation exists with this name."));\n      }\n\n      if (state instanceof state_AbstractBlendState) {\n        return state.getBlendWeight(blendName);\n      }\n\n      throw new Error("Cannot get blend weight of animation ".concat(animationName, " on layer ").concat(this.name, ". Animation is not an instance of AbstractBlendState."));\n    }\n    /**\r\n     * Update any weight interpolators and the current animation.\r\n     *\r\n     * @param {number} deltaTime - Time in milliseconds since the last update.\r\n     */\n\n  }, {\n    key: "update",\n    value: function update(deltaTime) {\n      AnimationLayer_get(AnimationLayer_getPrototypeOf(AnimationLayer.prototype), "update", this).call(this, deltaTime);\n\n      if (!this._paused && !this._weightPaused) {\n        this._promises.weight.execute(deltaTime);\n      }\n    }\n    /**\r\n     * Cancel any pending promises and discard states controlled by the layer.\r\n     */\n\n  }, {\n    key: "discard",\n    value: function discard() {\n      AnimationLayer_get(AnimationLayer_getPrototypeOf(AnimationLayer.prototype), "discard", this).call(this);\n\n      this.discardStates();\n\n      this._promises.weight.cancel();\n\n      delete this._promises;\n    }\n  }]);\n\n  return AnimationLayer;\n}(animpack_AnimationPlayerInterface.Mixin(state_StateContainerInterface.Mixin()));\n\n/* harmony default export */ const animpack_AnimationLayer = (AnimationLayer);\n;// CONCATENATED MODULE: ./src/core/animpack/state/SingleState.js\nfunction SingleState_typeof(obj) { "@babel/helpers - typeof"; return SingleState_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, SingleState_typeof(obj); }\n\nfunction SingleState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction SingleState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction SingleState_createClass(Constructor, protoProps, staticProps) { if (protoProps) SingleState_defineProperties(Constructor.prototype, protoProps); if (staticProps) SingleState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction SingleState_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) SingleState_setPrototypeOf(subClass, superClass); }\n\nfunction SingleState_setPrototypeOf(o, p) { SingleState_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return SingleState_setPrototypeOf(o, p); }\n\nfunction SingleState_createSuper(Derived) { var hasNativeReflectConstruct = SingleState_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = SingleState_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = SingleState_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return SingleState_possibleConstructorReturn(this, result); }; }\n\nfunction SingleState_possibleConstructorReturn(self, call) { if (call && (SingleState_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return SingleState_assertThisInitialized(self); }\n\nfunction SingleState_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction SingleState_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction SingleState_getPrototypeOf(o) { SingleState_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return SingleState_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n/**\r\n * Class for playing a single animation clip.\r\n *\r\n * @extends AbstractState\r\n * @alias core/SingleState\r\n */\n\nvar SingleState = /*#__PURE__*/function (_AbstractState) {\n  SingleState_inherits(SingleState, _AbstractState);\n\n  var _super = SingleState_createSuper(SingleState);\n\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {Object=} options - Options for the animation state.\r\n   * @param {string=} options.name - Name for the animation state. Names must be\r\n   * unique for the layer the state is applied to.\r\n   * @param {weight} [options.weight=0] - The 0-1 amount of influence the state will have.\r\n   * @param {timeScale} [options.timeScale=1] - Factor to scale the playback speed of the\r\n   * animation.\r\n   * @param {number} [options.loopCount=Infinity] - Number of times the animation should\r\n   * repeat before finishing.\r\n   * @param {string} [options.blendMode=DefaultLayerBlendMode] - Type of\r\n   * blending the animation should use.\r\n   */\n  function SingleState() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    SingleState_classCallCheck(this, SingleState);\n\n    _this = _super.call(this, options);\n    _this._timeScale = options.timeScale !== undefined ? options.timeScale : 1;\n    _this._promises.timeScale = core_Deferred.resolve();\n    _this._loopCount = options.loopCount !== undefined ? options.loopCount : Infinity;\n    _this._blendMode = validateBlendMode(options.blendMode);\n    return _this;\n  }\n  /**\r\n   * Gets and sets the normalized playing time of the current animation\r\n   *\r\n   * @type {number}\r\n   */\n\n\n  SingleState_createClass(SingleState, [{\n    key: "normalizedTime",\n    get: function get() {\n      return 0;\n    },\n    set: function set(time) {}\n    /**\r\n     * Gets and sets the a factor to scale animation playback speed with.\r\n     *\r\n     * @type {number}\r\n     */\n\n  }, {\n    key: "timeScale",\n    get: function get() {\n      return this._timeScale;\n    },\n    set: function set(timeScale) {\n      this._timeScale = timeScale;\n    }\n    /**\r\n     * Gets whether or not the timeScale is currently being animated.\r\n     *\r\n     * @readonly\r\n     * @type {boolean}\r\n     */\n\n  }, {\n    key: "timeScalePending",\n    get: function get() {\n      return this._promises.timeScale.pending;\n    }\n    /**\r\n     * Updates the timeScale value over time.\r\n     *\r\n     * @param {number} weight - The target timeScale value.\r\n     * @param {number} [seconds=0] - The amount of time it will take to reach the\r\n     * target timeScale.\r\n     * @param {Function=} easingFn - The easing function to use for interpolation.\r\n     *\r\n     * @returns {Deferred}\r\n     */\n\n  }, {\n    key: "setTimeScale",\n    value: function setTimeScale(timeScale) {\n      var seconds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var easingFn = arguments.length > 2 ? arguments[2] : undefined;\n\n      this._promises.timeScale.cancel();\n\n      this._promises.timeScale = animpack_AnimationUtils.interpolateProperty(this, \'timeScale\', timeScale, {\n        seconds: seconds,\n        easingFn: easingFn\n      });\n      return this._promises.timeScale;\n    }\n    /**\r\n     * Gets and sets the number of times the animation will repeat before finishing.\r\n     *\r\n     * @type {number}\r\n     */\n\n  }, {\n    key: "loopCount",\n    get: function get() {\n      return this._loopCount;\n    },\n    set: function set(loopCount) {\n      this._loopCount = loopCount;\n    }\n    /**\r\n     * Gets the type of blending used for the animation.\r\n     *\r\n     * @readonly\r\n     * @type {string}\r\n     */\n\n  }, {\n    key: "blendMode",\n    get: function get() {\n      return this._blendMode;\n    }\n  }]);\n\n  return SingleState;\n}(state_AbstractState);\n\n/* harmony default export */ const state_SingleState = (SingleState);\n;// CONCATENATED MODULE: ./src/core/animpack/state/RandomAnimationState.js\nfunction RandomAnimationState_typeof(obj) { "@babel/helpers - typeof"; return RandomAnimationState_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, RandomAnimationState_typeof(obj); }\n\nfunction RandomAnimationState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction RandomAnimationState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction RandomAnimationState_createClass(Constructor, protoProps, staticProps) { if (protoProps) RandomAnimationState_defineProperties(Constructor.prototype, protoProps); if (staticProps) RandomAnimationState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction RandomAnimationState_get() { if (typeof Reflect !== "undefined" && Reflect.get) { RandomAnimationState_get = Reflect.get; } else { RandomAnimationState_get = function _get(target, property, receiver) { var base = RandomAnimationState_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return RandomAnimationState_get.apply(this, arguments); }\n\nfunction RandomAnimationState_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = RandomAnimationState_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction RandomAnimationState_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) RandomAnimationState_setPrototypeOf(subClass, superClass); }\n\nfunction RandomAnimationState_setPrototypeOf(o, p) { RandomAnimationState_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return RandomAnimationState_setPrototypeOf(o, p); }\n\nfunction RandomAnimationState_createSuper(Derived) { var hasNativeReflectConstruct = RandomAnimationState_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = RandomAnimationState_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = RandomAnimationState_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return RandomAnimationState_possibleConstructorReturn(this, result); }; }\n\nfunction RandomAnimationState_possibleConstructorReturn(self, call) { if (call && (RandomAnimationState_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return RandomAnimationState_assertThisInitialized(self); }\n\nfunction RandomAnimationState_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction RandomAnimationState_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction RandomAnimationState_getPrototypeOf(o) { RandomAnimationState_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return RandomAnimationState_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n/**\r\n * Class for playing random animations at random intervals within this state.\r\n *\r\n * @extends AbstractState\r\n * @implements AnimationPlayerInterface\r\n * @implements StateContainerInterface\r\n */\n\nvar RandomAnimationState = /*#__PURE__*/function (_AnimationPlayerInter) {\n  RandomAnimationState_inherits(RandomAnimationState, _AnimationPlayerInter);\n\n  var _super = RandomAnimationState_createSuper(RandomAnimationState);\n\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {Object} [options={}] - Options for the container state.\r\n   * @param {number} [options.playInterval=3] - The base animation playback interval.\r\n   * @param {Array.<AbstractState>} [subStates=[]] - states to be randomly picked to play\r\n   */\n  function RandomAnimationState() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var subStates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    RandomAnimationState_classCallCheck(this, RandomAnimationState);\n\n    _this = _super.call(this, options);\n    _this._playInterval = options.playInterval ? options.playInterval : 3;\n    subStates.forEach(function (state) {\n      _this.addState(state);\n    });\n    return _this;\n  }\n  /**\r\n   * Gets and sets the base animation play interval\r\n   *\r\n   * @type {float}\r\n   */\n\n\n  RandomAnimationState_createClass(RandomAnimationState, [{\n    key: "playInterval",\n    get: function get() {\n      return this._playInterval;\n    },\n    set: function set(playInterval) {\n      this._playInterval = playInterval;\n    }\n    /**\r\n     * Reset the internal timer for animation play interval\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_resetTimer",\n    value: function _resetTimer() {\n      var _this2 = this;\n\n      var playTimer = core_Utils.getRandomFloat(this._playInterval / 4, this._playInterval * 2);\n\n      var onFinish = function onFinish() {\n        _this2.playRandomAnimation(_this2._playCallbacks.onError);\n      };\n\n      this._promises.timer = core_Utils.wait(playTimer, {\n        onFinish: onFinish\n      });\n    }\n  }, {\n    key: "updateInternalWeight",\n    value: function updateInternalWeight(factor) {\n      RandomAnimationState_get(RandomAnimationState_getPrototypeOf(RandomAnimationState.prototype), "updateInternalWeight", this).call(this, factor);\n\n      if (this._currentState) {\n        this._currentState.updateInternalWeight(this._internalWeight);\n      }\n    }\n    /**\r\n     * Pick a random animation and utilize AnimationPlayerInterface to play that animation\r\n     *\r\n     * @param {Function=} onError - Function to execute if the state encounters\r\n     * an error during playback.\r\n     */\n\n  }, {\n    key: "playRandomAnimation",\n    value: function playRandomAnimation(onError) {\n      this._resetTimer();\n\n      var states = this.getStateNames();\n\n      if (this._currentState) {\n        states.splice(states.indexOf(this._currentState.name), 1);\n      }\n\n      var randomState = states[core_Utils.getRandomInt(0, states.length)];\n      this.playAnimation(randomState, this._transitionTime, this._easingFn, undefined, onError, undefined);\n    }\n  }, {\n    key: "play",\n    value: function play(onFinish, onError, onCancel) {\n      this.playRandomAnimation(onError);\n      return RandomAnimationState_get(RandomAnimationState_getPrototypeOf(RandomAnimationState.prototype), "play", this).call(this, onFinish, onError, onCancel);\n    }\n  }, {\n    key: "pause",\n    value: function pause() {\n      return RandomAnimationState_get(RandomAnimationState_getPrototypeOf(RandomAnimationState.prototype), "pause", this).call(this) && this.pauseAnimation();\n    }\n  }, {\n    key: "resume",\n    value: function resume(onFinish, onError, onCancel) {\n      if (this._currentState) {\n        this.resumeAnimation(this._currentState.name, this._transitionTime, this._easingFn, undefined, onError, undefined);\n      }\n\n      return RandomAnimationState_get(RandomAnimationState_getPrototypeOf(RandomAnimationState.prototype), "resume", this).call(this, onFinish, onError, onCancel);\n    }\n  }, {\n    key: "cancel",\n    value: function cancel() {\n      return RandomAnimationState_get(RandomAnimationState_getPrototypeOf(RandomAnimationState.prototype), "cancel", this).call(this) && this.cancelAnimation();\n    }\n  }, {\n    key: "stop",\n    value: function stop() {\n      return RandomAnimationState_get(RandomAnimationState_getPrototypeOf(RandomAnimationState.prototype), "stop", this).call(this) && this.stopAnimation();\n    }\n  }, {\n    key: "discard",\n    value: function discard() {\n      RandomAnimationState_get(RandomAnimationState_getPrototypeOf(RandomAnimationState.prototype), "discard", this).call(this);\n\n      this.discardStates();\n    }\n  }]);\n\n  return RandomAnimationState;\n}(animpack_AnimationPlayerInterface.Mixin(state_StateContainerInterface.Mixin(state_AbstractState)));\n\n/* harmony default export */ const state_RandomAnimationState = (RandomAnimationState);\n;// CONCATENATED MODULE: ./src/core/animpack/AnimationFeature.js\nfunction AnimationFeature_typeof(obj) { "@babel/helpers - typeof"; return AnimationFeature_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, AnimationFeature_typeof(obj); }\n\nfunction AnimationFeature_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction AnimationFeature_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? AnimationFeature_ownKeys(Object(source), !0).forEach(function (key) { AnimationFeature_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : AnimationFeature_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction AnimationFeature_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction AnimationFeature_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AnimationFeature_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AnimationFeature_createClass(Constructor, protoProps, staticProps) { if (protoProps) AnimationFeature_defineProperties(Constructor.prototype, protoProps); if (staticProps) AnimationFeature_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction AnimationFeature_get() { if (typeof Reflect !== "undefined" && Reflect.get) { AnimationFeature_get = Reflect.get; } else { AnimationFeature_get = function _get(target, property, receiver) { var base = AnimationFeature_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return AnimationFeature_get.apply(this, arguments); }\n\nfunction AnimationFeature_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = AnimationFeature_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction AnimationFeature_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) AnimationFeature_setPrototypeOf(subClass, superClass); }\n\nfunction AnimationFeature_setPrototypeOf(o, p) { AnimationFeature_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return AnimationFeature_setPrototypeOf(o, p); }\n\nfunction AnimationFeature_createSuper(Derived) { var hasNativeReflectConstruct = AnimationFeature_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = AnimationFeature_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = AnimationFeature_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return AnimationFeature_possibleConstructorReturn(this, result); }; }\n\nfunction AnimationFeature_possibleConstructorReturn(self, call) { if (call && (AnimationFeature_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return AnimationFeature_assertThisInitialized(self); }\n\nfunction AnimationFeature_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction AnimationFeature_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction AnimationFeature_getPrototypeOf(o) { AnimationFeature_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return AnimationFeature_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n\n\n\n\n\n\n/**\r\n * Enum for animation state classes.\r\n *\r\n * @readonly\r\n * @enum {Class}\r\n */\n\nvar AnimationTypes = {\n  single: state_SingleState,\n  freeBlend: state_FreeBlendState,\n  queue: state_QueueState,\n  randomAnimation: state_RandomAnimationState,\n  blend1d: state_Blend1dState,\n  blend2d: state_Blend2dState\n};\n/**\r\n * Feature for managing animations on an object.\r\n *\r\n * @extends AbstractHostFeature\r\n * @alias core/AnimationFeature\r\n *\r\n * @property {Object} EVENTS - Built-in messages that the feature emits. When the\r\n * feature is added to a {@link core/HostObject}, event names will be prefixed by the\r\n * name of the feature class + \'.\'.\r\n * @property {string} [EVENTS.addLayer=onAddLayerEvent] - Message that is emitted after\r\n * [addLayer]{@link core/AnimationFeature#addLayer} has been successfully executed.\r\n * An object representing the name of the layer that was added and its index in\r\n * the layer stack with the signature {name: string, index: number} is supplied\r\n * as an argument to listener functions.\r\n * @property {string} [EVENTS.removeLayer=onRemoveLayerEvent] - Message that is\r\n * emitted after [removeLayer]{@link core/AnimationFeature#removeLayer} has been\r\n * successfully executed. An object representing the name of the layer that was\r\n * removed and its index in the layer stack with the signature {name: string, index: number}\r\n * is supplied as an argument to listener functions.\r\n * @property {string} [EVENTS.renameLayer=onRenameLayerEvent] - Message that is\r\n * emitted after [renameLayer]{@link core/AnimationFeature#renameLayer} has been\r\n * successfully executed. An object representing the original name of the layer\r\n * that was renamed and its updated name with the signature {oldName: string, newName: string}\r\n * is supplied as an argument to listener functions.\r\n * @property {string} [EVENTS.addAnimation=onAddAnimationEvent] - Message that is\r\n * emitted after [addAnimation]{@link core/AnimationFeature#addAnimation} has been\r\n * successfully executed. An object representing the name of the layer that the\r\n * animation was added to and the name of the animation that was added with the\r\n * signature {layerName: string, animationName: string} is supplied as an argument\r\n * to listener functions.\r\n * @property {string} [EVENTS.removeAnimation=onRemovedAnimationEvent] - Message\r\n * that is emitted after [removeAnimation]{@link core/AnimationFeature#removeAnimation}\r\n * has been successfully executed. An object representing the name of the layer\r\n * that the animation was removed from and the name of the animation that was removed\r\n * with the signature {layerName: string, animationName: string} is supplied as\r\n * an argument to listener functions.\r\n * @property {string} [EVENTS.renameAnimation=onRenameAnimationEvent] - Message\r\n * that is emitted after [renameAnimation]{@link core/AnimationFeature#renameAnimation}\r\n * has been successfully executed. An object representing the name of the layer\r\n * that contains the animation that was renamed, the original name of the animation\r\n * that was renamed and its updated name with the signature {layerName: string, oldName: string, newName: string}\r\n * is supplied as an argument to listener functions.\r\n * @property {string} [EVENTS.play=onPlayEvent] - Message that is emitted after\r\n * each call to [play]{@link core/AnimationFeature#playAnimation}. An object representing\r\n * the name of the layer contains the animation that was played and the name of\r\n * the animation that was played with the signature {layerName: string, animationName: string}\r\n * is supplied as an argument to listener functions.\r\n * @property {string} [EVENTS.pause=onPauseEvent] - Message that is emitted after\r\n * each call to [pause]{@link core/AnimationFeature#pauseAnimation}. An object representing\r\n * the name of the layer contains the animation that was paused and the name of\r\n * the animation that was paused with the signature {layerName: string, animationName: string}\r\n * is supplied as an argument to listener functions.\r\n * @property {string} [EVENTS.resume=onResumeEvent] - Message that is emitted after\r\n * each call to [resume]{@link core/AnimationFeature#resumeAnimation}. An object representing\r\n * the name of the layer contains the animation that was resumed and the name of\r\n * the animation that was resumed with the signature {layerName: string, animationName: string}\r\n * is supplied as an argument to listener functions.\r\n * @property {string} [EVENTS.interrupt=onInterruptEvent] - Message that is emitted\r\n * if there is a current speech in progress and [play]{@link core/AnimationFeature#playAnimation}\r\n * or [resume]{@link core/AnimationFeature#resumeAnimation} are executed for a new speech.\r\n * An object representing the name of the layer contains the animation that was\r\n * interrupted and the name of the animation that was interrupted with the signature\r\n * {layerName: string, animationName: string} is supplied as an argument to listener\r\n * functions.\r\n * @property {string} [EVENTS.stop=onStopEvent] - Message that is emitted after\r\n * each call to [stop]{@link core/AnimationFeature#stopAnimation} and when a speech reaches\r\n * the end of playback. An object representing\r\n * the name of the layer contains the animation that was stopped and the name of\r\n * the animation that was stopped with the signature {layerName: string, animationName: string}\r\n * is supplied as an argument to listener functions.\r\n */\n\nvar AnimationFeature = /*#__PURE__*/function (_AbstractHostFeature) {\n  AnimationFeature_inherits(AnimationFeature, _AbstractHostFeature);\n\n  var _super = AnimationFeature_createSuper(AnimationFeature);\n\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {core/HostObject} host - Host object that owns the feature.\r\n   */\n  function AnimationFeature(host) {\n    var _this;\n\n    AnimationFeature_classCallCheck(this, AnimationFeature);\n\n    _this = _super.call(this, host);\n    _this._layers = [];\n    _this._layerMap = {};\n    _this._paused = false;\n    return _this;\n  }\n  /**\r\n   * Make sure a supplied layer index is within the range of layers.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {number} index\r\n   * @param {boolean} [existing=true] - Whether the index represents and existing\r\n   * layer or a new layer to be added.\r\n   *\r\n   * @returns {number=}\r\n   */\n\n\n  AnimationFeature_createClass(AnimationFeature, [{\n    key: "_validateIndex",\n    value: function _validateIndex(index) {\n      var existing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      // Index is invalid if there are no layers and we\'re checking for an existing layer index\n      if (this._layers.length === 0 && existing) {\n        return undefined;\n      }\n\n      var lastIndex = existing ? this._layers.length - 1 : this._layers.length; // Count from the end of the array for negative indices\n\n      if (index < 0) {\n        index = lastIndex + index + 1;\n      }\n\n      if (index < 0 || index > lastIndex) {\n        return undefined;\n      } else {\n        return index;\n      }\n    }\n    /**\r\n     * Re-evaluate internal weight values of layers starting from the top of the\r\n     * stack. Override layers\' weights affect the values of all layers lower in the\r\n     * stack.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_updateInternalWeights",\n    value: function _updateInternalWeights() {\n      var numLayers = this._layers.length;\n      var weightMultiplier = 1; // Update internal weight values on layers in reverse order\n\n      for (var i = numLayers - 1; i >= 0; i--) {\n        var layer = this._layers[i];\n        layer.updateInternalWeight(weightMultiplier); // If the layer is override, update the multiplier with the remainder of the full weight\n\n        if (layer.blendMode === LayerBlendModes.Override && layer.currentState) {\n          weightMultiplier *= 1 - layer.currentState.internalWeight;\n        }\n      }\n    }\n    /**\r\n     * Return a new instance of a SingleState.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {Object} options - Options to pass to the SingleState constructor.\r\n     * @param {string=} options.name - Name for the animation state. Names must be\r\n     * unique for the layer the state is applied to.\r\n     * @param {weight} [options.weight=0] - The 0-1 amount of influence the state will have.\r\n     * @param {timeScale} [options.timeScale=1] - Factor to scale the playback speed of the\r\n     * animation.\r\n     * @param {number} [options.loopCount=Infinity] - Number of times the animation should\r\n     * repeat before finishing.\r\n     * @param {string} [options.blendMode=LayerBlendModes[DefaultLayerBlendMode]] - Type of\r\n     * blending the animation should use.\r\n     *\r\n     * @returns {core/SingleState}\r\n     */\n\n  }, {\n    key: "_createSingleState",\n    value: function _createSingleState(options) {\n      return new state_SingleState(options);\n    }\n    /**\r\n     * Return a new instance of a FreeBlendState.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {Object} options - Options to pass to the FreeBlendState constructor.\r\n     * @param {string=} options.name - Name for the animation state. Names must be\r\n     * unique for the layer the state is applied to.\r\n     * @param {weight} [options.weight=0] - The 0-1 amount of influence the state will have.\r\n     * @param {timeScale} [options.timeScale=1] - Factor to scale the playback speed of the\r\n     * animation.\r\n     * @param {number} [options.loopCount=Infinity] - Number of times the animation should\r\n     * repeat before finishing.\r\n     * @param {string} [options.blendMode=LayerBlendModes[DefaultLayerBlendMode]] - Type of\r\n     * blending the animation should use.\r\n     * @param {Array.<Object>} [options.blendStateOptions] - Array of options used to create the\r\n     * blend states for this container.\r\n     *\r\n     * @returns {FreeBlendState}\r\n     */\n\n  }, {\n    key: "_createFreeBlendState",\n    value: function _createFreeBlendState(options) {\n      var _this2 = this;\n\n      var _options$blendStateOp = options.blendStateOptions,\n          blendStateOptions = _options$blendStateOp === void 0 ? [] : _options$blendStateOp;\n      var blendStates = [];\n      blendStateOptions.forEach(function (blendOptions) {\n        blendStates.push(_this2._createSingleState(AnimationFeature_objectSpread(AnimationFeature_objectSpread({}, blendOptions), {}, {\n          blendMode: options.blendMode\n        })));\n      });\n      return new state_FreeBlendState(options, blendStates);\n    }\n    /**\r\n     * Return a new instance of a QueueState.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {Object} options - Options to pass to the QueueState constructor.\r\n     * @param {string=} options.name - Name for the animation state. Names must be\r\n     * unique for the layer the state is applied to.\r\n     * @param {number} [options.weight=0] - The 0-1 amount of influence the state will have.\r\n     * @param {number=} options.transitionTime - The amount of time it takes to transition\r\n     * between queued states.\r\n     * @param {string} [options.blendMode=LayerBlendModes[DefaultLayerBlendMode]] - Type of\r\n     * blending the animation should use.\r\n     * @param {Array.<Object>} [options.queueOptions] - Array of options used to create the\r\n     * queue states for this container.\r\n     *\r\n     * @returns {QueueState}\r\n     */\n\n  }, {\n    key: "_createQueueState",\n    value: function _createQueueState(options) {\n      var _this3 = this;\n\n      var _options$queueOptions = options.queueOptions,\n          queueOptions = _options$queueOptions === void 0 ? [] : _options$queueOptions;\n      var queueStates = queueOptions.map(function (queueOption) {\n        return _this3._createSingleState(AnimationFeature_objectSpread(AnimationFeature_objectSpread({\n          transitionTime: options.transitionTime\n        }, queueOption), {}, {\n          blendMode: options.blendMode\n        }));\n      });\n      return new state_QueueState(options, queueStates);\n    }\n    /**\r\n     * Return a new instance of a Blend1dState.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {Object} options - Options to pass to the Blend1dState constructor.\r\n     * @param {string=} options.name - Name for the animation state. Names must be\r\n     * unique for the layer the state is applied to.\r\n     * @param {weight} [options.weight=0] - The 0-1 amount of influence the state will have.\r\n     * @param {timeScale} [options.timeScale=1] - Factor to scale the playback speed of the\r\n     * animation.\r\n     * @param {number} [options.loopCount=Infinity] - Number of times the animation should\r\n     * repeat before finishing.\r\n     * @param {string} [options.blendMode=LayerBlendModes[DefaultLayerBlendMode]] - Type of\r\n     * blending the animation should use.\r\n     * @param {Array.<Object>} [options.blendStateOptions] - Array of options used to create the\r\n     * blend states for this container.\r\n     * @param {Array.<number>} [options.blendThresholds] - Array of numbers used to set the\r\n     * thresholds for each blend state in this container.\r\n     * @param {Array.<boolean>} [options.blendMatchPhases=[]] - Optional array of booleans used to\r\n     * set whether or not each blend state in this container will match phases.\r\n     *\r\n     * @returns {Blend1dState}\r\n     */\n\n  }, {\n    key: "_createBlend1dState",\n    value: function _createBlend1dState(options) {\n      var _this4 = this;\n\n      var _options$blendStateOp2 = options.blendStateOptions,\n          blendStateOptions = _options$blendStateOp2 === void 0 ? [] : _options$blendStateOp2;\n      var _options$blendThresho = options.blendThresholds,\n          blendThresholds = _options$blendThresho === void 0 ? [] : _options$blendThresho;\n      var _options$blendMatchPh = options.blendMatchPhases,\n          blendMatchPhases = _options$blendMatchPh === void 0 ? [] : _options$blendMatchPh;\n      var blendStates = [];\n      blendStateOptions.forEach(function (blendOptions) {\n        blendStates.push(_this4._createSingleState(AnimationFeature_objectSpread(AnimationFeature_objectSpread({}, blendOptions), {}, {\n          blendMode: options.blendMode\n        })));\n      });\n      return new state_Blend1dState(options, blendStates, blendThresholds, blendMatchPhases);\n    }\n    /**\r\n     * Return a new instance of a Blend2dState.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {Object} options - Options to pass to the Blend1dState constructor.\r\n     * @param {string=} options.name - Name for the animation state. Names must be\r\n     * unique for the layer the state is applied to.\r\n     * @param {weight} [options.weight=0] - The 0-1 amount of influence the state will have.\r\n     * @param {timeScale} [options.timeScale=1] - Factor to scale the playback speed of the\r\n     * animation.\r\n     * @param {number} [options.loopCount=Infinity] - Number of times the animation should\r\n     * repeat before finishing.\r\n     * @param {string} [options.blendMode=LayerBlendModes[DefaultLayerBlendMode]] - Type of\r\n     * blending the animation should use.\r\n     * @param {Array.<Object>} [options.blendStateOptions] - Array of options used to create the\r\n     * blend states for this container.\r\n     * @param {Array.<Array.<number>>} [options.blendThresholds] - Array of Array of numbers used to set the\r\n     * thresholds for each blend state in this container.\r\n     * @param {Array.<boolean>} [options.blendMatchPhases=[]] - Optional array of booleans used to\r\n     * set whether or not each blend state in this container will match phases.\r\n     *\r\n     * @returns {Blend1dState}\r\n     */\n\n  }, {\n    key: "_createBlend2dState",\n    value: function _createBlend2dState(options) {\n      var _this5 = this;\n\n      var _options$blendStateOp3 = options.blendStateOptions,\n          blendStateOptions = _options$blendStateOp3 === void 0 ? [] : _options$blendStateOp3;\n      var _options$blendThresho2 = options.blendThresholds,\n          blendThresholds = _options$blendThresho2 === void 0 ? [] : _options$blendThresho2;\n      var _options$blendMatchPh2 = options.blendMatchPhases,\n          blendMatchPhases = _options$blendMatchPh2 === void 0 ? [] : _options$blendMatchPh2;\n      var blendStates = [];\n      blendStateOptions.forEach(function (blendOptions) {\n        blendStates.push(_this5._createSingleState(AnimationFeature_objectSpread(AnimationFeature_objectSpread({}, blendOptions), {}, {\n          blendMode: options.blendMode\n        })));\n      });\n      return new state_Blend2dState(options, blendStates, blendThresholds, blendMatchPhases);\n    }\n    /**\r\n     * Return a new instance of a RandomAnimationState.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {Object} options - Options to pass to the RandomAnimationState constructor.\r\n     * @param {string=} options.name - Name for the animation state. Names must be\r\n     * unique for the layer the state is applied to.\r\n     * @param {number} [options.playInterval=3] - The base animation playback interval.\r\n     * @param {Array.<Object>} [options.subStateOptions] - Array of options used to create the\r\n     * sub states for this container.\r\n     *\r\n     * @returns {RandomAnimationState}\r\n     */\n\n  }, {\n    key: "_createRandomAnimationState",\n    value: function _createRandomAnimationState(options) {\n      var _this6 = this;\n\n      var _options$subStateOpti = options.subStateOptions,\n          subStateOptions = _options$subStateOpti === void 0 ? [] : _options$subStateOpti;\n      var subStates = [];\n      subStateOptions.forEach(function (subStateOptions) {\n        subStates.push(_this6._createSingleState(AnimationFeature_objectSpread(AnimationFeature_objectSpread({}, subStateOptions), {}, {\n          blendMode: options.blendMode\n        })));\n      });\n      return new state_RandomAnimationState(options, subStates);\n    }\n    /**\r\n     * Make sure the layer with the given name exists and return a unique version\r\n     * of the animation name supplied for that layer.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} layerName - Name of the layer to check against.\r\n     * @param {string} animationName - Name of the animation to validate.\r\n     *\r\n     * @returns {string} Validated animation name.\r\n     */\n\n  }, {\n    key: "_validateNewAnimation",\n    value: function _validateNewAnimation(layerName, animationName) {\n      // Make sure the layerName is valid\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Cannot add animation to layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      } // Make sure the animationName is unique\n\n\n      var name = core_Utils.getUniqueName(animationName, layer.getStateNames());\n\n      if (name !== animationName) {\n        console.warn("Animation name ".concat(animationName, " is not unique for layer ").concat(layer.name, ". Animation will be renamed to ").concat(name, "."));\n      }\n\n      return name;\n    }\n    /**\r\n     * Gets whether or not all animations are paused.\r\n     *\r\n     * @readonly\r\n     * @type {boolean}\r\n     */\n\n  }, {\n    key: "paused",\n    get: function get() {\n      return this._paused;\n    }\n    /**\r\n     * Gets an array of names of animation layers.\r\n     *\r\n     * @readonly\r\n     * @type {Array.<string>}\r\n     */\n\n  }, {\n    key: "layers",\n    get: function get() {\n      return this._layers.map(function (layer) {\n        return layer.name;\n      });\n    }\n    /**\r\n     * Create and store a new animation layer.\r\n     *\r\n     * @param {string} [name=\'NewLayer\'] - Name for the layer.\r\n     * @param {Object} [options={}] - Options to pass to {@link AnimationLayer#constructor}\r\n     * @param {index=} index - Index to insert the new layer at. If none is provided\r\n     * it will be added to the end of the stack.\r\n     *\r\n     * @returns {number} Index of the new layer.\r\n     */\n\n  }, {\n    key: "addLayer",\n    value: function addLayer() {\n      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \'NewLayer\';\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var index = arguments.length > 2 ? arguments[2] : undefined;\n      var numLayers = this._layers.length;\n      var layerIndex = index; // Make sure the given index is within the range of layers\n\n      if (index === undefined || index === -1) {\n        layerIndex = this._layers.length;\n      } else {\n        layerIndex = this._validateIndex(index, false);\n\n        if (layerIndex === undefined) {\n          // Insert at the beginning if the user passed in a negative index\n          if (index < 0) {\n            layerIndex = 0;\n          } // Otherwise append to the end\n          else {\n            layerIndex = this._layers.length;\n          }\n\n          console.warn("Index ".concat(index, " is invalid for host ").concat(this._host.id, ". New layer will be added at the closest valid index: ").concat(layerIndex, "."));\n        }\n      } // Make sure the layer name is unique\n\n\n      var layerName = core_Utils.getUniqueName(name, Object.keys(this._layerMap));\n\n      if (name !== layerName) {\n        console.warn("Layer name ".concat(name, " is not unique. New layer will be added with the name ").concat(layerName, "."));\n      }\n\n      var layer = new animpack_AnimationLayer(AnimationFeature_objectSpread(AnimationFeature_objectSpread({}, options), {}, {\n        name: layerName\n      }));\n      this._layerMap[layerName] = layer;\n\n      if (layerIndex === numLayers) {\n        this._layers.push(layer);\n      } else {\n        this._layers.splice(layerIndex, 0, layer);\n      } // Notify that a layer has been added to the feature\n\n\n      var eventData = {\n        name: layerName,\n        index: layerIndex\n      };\n      this.emit(this.constructor.EVENTS.addLayer, eventData);\n      return eventData;\n    }\n    /**\r\n     * Remove an animation layer from the stack. Animations on this layer will no\r\n     * longer be evaluated.\r\n     *\r\n     * @param {string} name - Name for the layer to remove.\r\n     *\r\n     * @returns {boolean} Whether or not removal was successful.\r\n     */\n\n  }, {\n    key: "removeLayer",\n    value: function removeLayer(name) {\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        console.warn("Did not remove layer ".concat(name, " from host ").concat(this._host.id, ". No layer exists with this name."));\n        return false;\n      }\n\n      layer.discard();\n\n      var index = this._layers.indexOf(layer);\n\n      this._layers.splice(index, 1);\n\n      delete this._layerMap[name]; // Notify that a layer has been removed from the feature\n\n      this.emit(this.constructor.EVENTS.removeLayer, {\n        name: name,\n        index: index\n      });\n      return true;\n    }\n    /**\r\n     * Re-order the layer stack so that the layer with the given name is positioned\r\n     * at the given index.\r\n     *\r\n     * @param {string} name - Name of the layer to move.\r\n     * @param {number} index - New index to position the layer at.\r\n     *\r\n     * @returns {number} The new index of the layer\r\n     */\n\n  }, {\n    key: "moveLayer",\n    value: function moveLayer(name, index) {\n      // Make sure the name is valid\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        throw new Error("Cannot move layer ".concat(name, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      } // Make sure the index falls in the range of existing layers\n\n\n      var layerIndex = this._validateIndex(index, true);\n\n      var lastIndex = this._layers.length - 1;\n\n      if (layerIndex === undefined) {\n        throw new Error("Cannot move layer ".concat(name, " from host ").concat(this._host.id, " to index ").concat(index, ". Index must be in the 0 - ").concat(lastIndex, " range."));\n      }\n\n      var currentIndex = this._layers.indexOf(layer);\n\n      if (currentIndex === layerIndex) {\n        return;\n      } // Remove from the current position\n\n\n      this._layers.splice(currentIndex, 1); // Insert at the new position\n\n\n      if (layerIndex === lastIndex) {\n        this._layers.push(layer);\n      } else {\n        this._layers.splice(layerIndex, 0, layer);\n      }\n\n      return layerIndex;\n    }\n    /**\r\n     * Update the name of a layer. Names must be unique, if the new name is not\r\n     * unique it will have trailing numbers appended until it is unique.\r\n     *\r\n     * @param {string} currentName - Current name of the layer.\r\n     * @param {string} newName - New name to set on the layer.\r\n     *\r\n     * @returns {string} The new name of the layer\r\n     */\n\n  }, {\n    key: "renameLayer",\n    value: function renameLayer(currentName, newName) {\n      // Make sure the name is valid\n      var layer = this._layerMap[currentName];\n\n      if (layer === undefined) {\n        throw new Error("Cannot rename layer ".concat(currentName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      } // Make sure the layer name is unique\n\n\n      var name = core_Utils.getUniqueName(newName, Object.keys(this._layerMap));\n\n      if (name !== newName) {\n        console.warn("Layer name ".concat(newName, " is not unique. Layer will be renamed to ").concat(name, "."));\n      }\n\n      delete this._layerMap[currentName];\n      this._layerMap[name] = layer;\n      layer.name = name; // Notify that a layer has been renamed on the feature\n\n      this.emit(this.constructor.EVENTS.renameLayer, {\n        oldName: currentName,\n        newName: name\n      });\n      return name;\n    }\n    /**\r\n     * Return the weight of an animation layer.\r\n     *\r\n     * @param {string} name - Name of the layer to return weight from.\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: "getLayerWeight",\n    value: function getLayerWeight(name) {\n      // Make sure the name is valid\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        throw new Error("Cannot get weight on layer ".concat(name, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      return layer.weight;\n    }\n    /**\r\n     * Update the weight of an animation layer.\r\n     *\r\n     * @param {string} name - The name of the layer to update.\r\n     * @param {number} weight - The weight value to set on the layer. This number\r\n     * should be in the 0-1 range.\r\n     * @param {number=} seconds - The number of seconds it should take to reach the\r\n     * new weight. Default is zero and will set immediately.\r\n     * @param {Function=} easingFn - The easing function to use while interpolating\r\n     * the weight. Default is Easing.Linear.InOut.\r\n     *\r\n     * @returns {Deferred} A promise that will resolve once the layer\'s weight reaches\r\n     * the target value.\r\n     */\n\n  }, {\n    key: "setLayerWeight",\n    value: function setLayerWeight(name, weight, seconds, easingFn) {\n      // Make sure the name is valid\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        var e = "Cannot set weight on layer ".concat(name, " from host ").concat(this._host.id, ". No layer exists with this name.");\n        return core_Deferred.reject(e);\n      }\n\n      return layer.setWeight(weight, seconds, easingFn);\n    }\n    /**\r\n     * Returns the names of blend states in an animation in a layer.\r\n     *\r\n     * @param {string} layerName - Name of the layer containing the animation containing\r\n     * the blend state to update.\r\n     * @param {string} animationName - Name of the animation containing the blend state\r\n     * to update.\r\n     *\r\n     * @returns {Array.<string>} - Names of blend states.\r\n     */\n\n  }, {\n    key: "getAnimationBlendNames",\n    value: function getAnimationBlendNames(layerName, animationName) {\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Cannot get blend names on layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      return layer.getAnimationBlendNames(animationName);\n    }\n    /**\r\n     * Update the weight for a blend state in an animation in a layer.\r\n     *\r\n     * @param {string} layerName - Name of the layer containing the animation containing\r\n     * the blend state to update.\r\n     * @param {string} animationName - Name of the animation containing the blend state\r\n     * to update.\r\n     * @param {string} blendName - Name of the blend state to update.\r\n     * @param {number} weight - Weight value to set on the animation. This number shoudld be\r\n     * in the 0-1 range.\r\n     * @param {number=} seconds - Number of seconds it should take to reach the new weight.\r\n     * Default is zero and will set immediately.\r\n     * @param {Function=} easingFn - Easing function to use while interpolating the new\r\n     * weight. Default is Easing.Linear.InOut.\r\n     *\r\n     * @returns {Deferred} - Promise that will resolve once the animation\'s weight reaches\r\n     * the target value.\r\n     */\n\n  }, {\n    key: "setAnimationBlendWeight",\n    value: function setAnimationBlendWeight(layerName, animationName, blendName, weight, seconds, easingFn) {\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        var e = "Cannot set blend weight on layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name.");\n        return core_Deferred.reject(e);\n      }\n\n      return layer.setAnimationBlendWeight(animationName, blendName, weight, seconds, easingFn);\n    }\n    /**\r\n     * Returns the weight for a blend state in an animation in a layer.\r\n     *\r\n     * @param {string} layerName - Name of the layer containing the animation containing\r\n     * the blend state to update.\r\n     * @param {string} animationName - Name of the animation containing the blend state\r\n     * to update.\r\n     * @param {string} blendName - Name of the blend state to update.\r\n     *\r\n     * @returns {number} - Weight of the blend state.\r\n     */\n\n  }, {\n    key: "getAnimationBlendWeight",\n    value: function getAnimationBlendWeight(layerName, animationName, blendName) {\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Cannot get blend weight on layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      return layer.getAnimationBlendWeight(animationName, blendName);\n    }\n    /**\r\n     * Pause weight interpolation animation on a layer with the given name.\r\n     *\r\n     * @param {string} name - Name of the layer to pause.\r\n     *\r\n     * @returns {boolean} - Whether or not there was an existing interpolation to pause.\r\n     */\n\n  }, {\n    key: "pauseLayerWeight",\n    value: function pauseLayerWeight(name) {\n      // Make sure the name is valid\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        throw new Error("Cannot pause weight interpolation on layer ".concat(name, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      return layer.pauseWeight();\n    }\n    /**\r\n     * Resume weight interpolation animation on a layer with the given name.\r\n     *\r\n     * @param {string} name - Name of the layer to resume.\r\n     *\r\n     * @returns {Deferred} - Resolves once the layer\'s weight reaches its target value.\r\n     */\n\n  }, {\n    key: "resumeLayerWeight",\n    value: function resumeLayerWeight(name) {\n      // Make sure the name is valid\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        var e = "Cannot resume weight interpolation on layer ".concat(name, " from host ").concat(this._host.id, ". No layer exists with this name.");\n        return core_Deferred.reject(e);\n      }\n\n      return layer.resumeWeight();\n    }\n    /**\r\n     * Pause current animation and weight interpolation animation on a layer with\r\n     * the given name.\r\n     *\r\n     * @param {string} name - Name of the layer to pause.\r\n     *\r\n     * @returns {boolean} - Whether or not there was an existing interpolation or\r\n     * current animation to pause.\r\n     */\n\n  }, {\n    key: "pauseLayer",\n    value: function pauseLayer(name) {\n      // Make sure the name is valid\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        throw new Error("Cannot pause layer ".concat(name, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      return layer.pause();\n    }\n    /**\r\n     * Resume current animation and weight interpolation animation on a layer with\r\n     * the given name.\r\n     *\r\n     * @param {string} name - Name of the layer to resume.\r\n     *\r\n     * @returns {Deferred} - Resolves once the layer\'s weight reaches its target value\r\n     * and it\'s current animation finishes playing.\r\n     */\n\n  }, {\n    key: "resumeLayer",\n    value: function resumeLayer(name) {\n      // Make sure the name is valid\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        var e = "Cannot resume layer ".concat(name, " from host ").concat(this._host.id, ". No layer exists with this name.");\n        return core_Deferred.reject(e);\n      }\n\n      return layer.resume();\n    }\n    /**\r\n     * Return whether or not the animation layer with the given name is currently\r\n     * transitioning between animations.\r\n     *\r\n     * @param {string} layerName - Name of the layer to check.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "getTransitioning",\n    value: function getTransitioning(layerName) {\n      // Make sure the layerName is valid\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Get transitioning on layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      return layer.isTransitioning;\n    }\n    /**\r\n     * Return an array of the names of all states the layer with the given name controls.\r\n     *\r\n     * @param {string} layerName - Name of the layer to search.\r\n     *\r\n     * @returns {Array.<string>}\r\n     */\n\n  }, {\n    key: "getAnimations",\n    value: function getAnimations(layerName) {\n      // Make sure the layerName is valid\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Get animations on layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      return layer.getStateNames();\n    }\n    /**\r\n     * Return the name of the state currently active on the layer with the given name.\r\n     * Return null if there is no current animation for the layer.\r\n     *\r\n     * @param {string} layerName - Name of the layer.\r\n     *\r\n     * @returns {(string|null)}\r\n     */\n\n  }, {\n    key: "getCurrentAnimation",\n    value: function getCurrentAnimation(layerName) {\n      // Make sure the layerName is valid\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Get current animation on layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      return layer.currentAnimation;\n    }\n    /**\r\n     * Return whether or not a layer with the given name is currently playing an\r\n     * animation and that animation is paused.\r\n     *\r\n     * @param {string} layerName - Name of the layer.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "getPaused",\n    value: function getPaused(layerName) {\n      // Make sure the layerName is valid\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Get paused on layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      return layer.currentState && layer.currentState.paused;\n    }\n    /**\r\n     * Return the type name of the given animation. @see AnimationTypes.\r\n     *\r\n     * @param {string} layerName - Name of the layer that contains the animation.\r\n     * @param {string} animationName - Name of the animation to check.\r\n     *\r\n     * @returns {string}\r\n     */\n\n  }, {\n    key: "getAnimationType",\n    value: function getAnimationType(layerName, animationName) {\n      // Make sure the layerName is valid\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Get animation type on layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      var state = layer.getState(animationName);\n\n      if (state === undefined) {\n        throw new Error("Get animation type for animation ".concat(animationName, " on layer ").concat(layerName, " from host ").concat(this._host.id, ". No animation exists with this name."));\n      }\n\n      var constructor = state.constructor;\n      return Object.keys(AnimationTypes).find(function (typeName) {\n        return AnimationTypes[typeName] === constructor;\n      });\n    }\n    /**\r\n     * Add a new animation to an animation layer.\r\n     *\r\n     * @param {string} layerName - Name of the layer to add the animation to.\r\n     * @param {string} animationName - Name to use when calling the animation.\r\n     * @param {Object=} options - Options to pass to the constructor for the new\r\n     * SingleState animation.\r\n     *\r\n     * @returns {string} - The name of the animation that was added\r\n     */\n\n  }, {\n    key: "addAnimation",\n    value: function addAnimation(layerName, animationName) {\n      var animationType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : AnimationTypes.single;\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      options.name = this._validateNewAnimation(layerName, animationName); // Make sure the animation type is valid\n\n      if (!Object.values(AnimationTypes).includes(animationType)) {\n        throw new Error("Cannot add animation ".concat(animationName, " to layer ").concat(layerName, " on host ").concat(this._host.id, ". Invalid animation type."));\n      }\n\n      var layer = this._layerMap[layerName];\n      options.blendMode = layer.blendMode;\n      options.transitionTime = layer.transitionTime;\n      var state = this["_create".concat(animationType.name)](options);\n      var name = layer.addState(state); // Notify that an animation has been added to the feature\n\n      this.emit(this.constructor.EVENTS.addAnimation, {\n        layerName: layerName,\n        animationName: name\n      });\n      return name;\n    }\n    /**\r\n     * Remove an animation from an animation layer.\r\n     *\r\n     * @param {string} layerName - Name of the layer to remove the animation from.\r\n     * @param {string} name - Name of the animation to remove.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "removeAnimation",\n    value: function removeAnimation(layerName, animationName) {\n      // Make sure the name is valid\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Cannot remove animation from layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      var removed = layer.removeState(animationName); // Notify that an animation has been removed from the feature\n\n      if (removed === true) {\n        this.emit(this.constructor.EVENTS.removeAnimation, {\n          layerName: layerName,\n          animationName: animationName\n        });\n      }\n\n      return removed;\n    }\n    /**\r\n     * Update the name of an animation. Names must be unique on each layer, if the new\r\n     * name is not unique it will have trailing numbers appended until it is unique.\r\n     *\r\n     * @param {string} layerName - Name of the layer that contains the animation that\r\n     * will be renamed,\r\n     * @param {string} currentAnimationName - Current name of the animation.\r\n     * @param {string} newAnimationName - New name to set on the animation.\r\n     *\r\n     * @returns {string} - The new name of the animation\r\n     */\n\n  }, {\n    key: "renameAnimation",\n    value: function renameAnimation(layerName, currentAnimationName, newAnimationName) {\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Cannot rename animation ".concat(currentAnimationName, " on layer ").concat(layerName, " for host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      var name = layer.renameState(currentAnimationName, newAnimationName); // Notify that an animation has been renamed on the feature\n\n      this.emit(this.constructor.EVENTS.renameAnimation, {\n        layerName: layerName,\n        oldName: currentAnimationName,\n        newName: name\n      });\n      return name;\n    }\n    /**\r\n     * Pause the currently playing animation and play a new animation from the beginning.\r\n     *\r\n     * @param {string} layerName - Name of the layer that contains the animation.\r\n     * @param {string} animationName - Name of the animation state to play.\r\n     * @param {number=} seconds - The number of seconds it should take to transition\r\n     * to the new animation. Default is zero and will set immediately.\r\n     * @param {Function=} easingFn - The easing function to use while transitioning\r\n     * between animations. Default is Easing.Linear.InOut.\r\n     *\r\n     * @returns {Deferred} - Resolves once the animation reaches the end of its\r\n     * timeline. Looping animations can only resolve if they are interrupted or\r\n     * manually stopped.\r\n     */\n\n  }, {\n    key: "playAnimation",\n    value: function playAnimation(layerName, animationName, seconds, easingFn) {\n      var _this7 = this;\n\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        var e = "Cannot play animation ".concat(animationName, " on layer ").concat(layerName, " for host ").concat(this._host.id, ". No layer exists with this name.");\n        return core_Deferred.reject(e);\n      } // Notify that a new animation has begun\n\n\n      this.emit(this.constructor.EVENTS.playAnimation, {\n        layerName: layerName,\n        animationName: animationName\n      });\n      return layer.playAnimation(animationName, seconds, easingFn, function () {\n        // Notify that an animation has stopped\n        _this7.emit(_this7.constructor.EVENTS.stopAnimation, {\n          layerName: layerName,\n          animationName: animationName\n        });\n      }, undefined, function () {\n        // Notify that an animation has been interrupted\n        _this7.emit(_this7.constructor.EVENTS.interruptAnimation, {\n          layerName: layerName,\n          animationName: animationName\n        });\n      }, function (_ref) {\n        var name = _ref.name,\n            canAdvance = _ref.canAdvance,\n            isQueueEnd = _ref.isQueueEnd;\n\n        if (layer.currentAnimation === animationName) {\n          // Notify that a new animation has begun\n          _this7.emit(_this7.constructor.EVENTS.playNextAnimation, {\n            layerName: layerName,\n            animationName: animationName,\n            nextQueuedAnimation: name,\n            canAdvance: canAdvance,\n            isQueueEnd: isQueueEnd\n          });\n        }\n      });\n    }\n    /**\r\n     * Play the next animation in the queue of a QueueState animation.\r\n     *\r\n     * @param {string} layerName - Name of the layer that contains the queue animation.\r\n     * @param {string=} animationName - Name of the animation queue animation. Defaults\r\n     * to the name of the current animation for the layer.\r\n     * @param {number=} seconds - The number of seconds it should take to transition\r\n     * to the queue animation if it\'s not already currently playing. Default is zero\r\n     * and will set immediately.\r\n     * @param {Function=} easingFn - The easing function to use while transitioning\r\n     * to the queue animation if it isn\'t already playing. Default is Easing.Linear.InOut.\r\n     *\r\n     * @returns {Deferred} - Resolves once the last animation in the queue finishes\r\n     * playing.\r\n     */\n\n  }, {\n    key: "playNextAnimation",\n    value: function playNextAnimation(layerName, animationName, transitionTime, easingFn) {\n      var _this8 = this;\n\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        var e = "Cannot play next animation on layer ".concat(layerName, " for host ").concat(this._host.id, ". No layer exists with this name.");\n        return core_Deferred.reject(e);\n      }\n\n      if (animationName === undefined) {\n        animationName = layer.currentAnimation;\n      }\n\n      var animation = layer.getState(layer.currentAnimation);\n\n      if (animation === null) {\n        var _e = "Cannot play next animation on layer ".concat(layerName, " for host ").concat(this._host.id, ". No animation exists with name ").concat(animationName, ".");\n\n        return core_Deferred.reject(_e);\n      } else if (this.getAnimationType(layerName, animationName) !== \'queue\') {\n        var _e2 = "Cannot play next animation on layer ".concat(layerName, " for host ").concat(this._host.id, ". ").concat(animationName, " is not a queue state.");\n\n        return core_Deferred.reject(_e2);\n      }\n\n      var onNext = function onNext(_ref2) {\n        var name = _ref2.name,\n            canAdvance = _ref2.canAdvance,\n            isQueueEnd = _ref2.isQueueEnd;\n\n        if (layer.currentAnimation === animationName) {\n          // Notify that a new animation has begun\n          _this8.emit(_this8.constructor.EVENTS.playNextAnimation, {\n            layerName: layerName,\n            animationName: animationName,\n            nextQueuedAnimation: name,\n            canAdvance: canAdvance,\n            isQueueEnd: isQueueEnd\n          });\n        }\n      }; // Make the queue animation current if it wasn\'t already\n\n\n      if (layer.currentAnimation === null) {\n        layer.resumeAnimation(animation.name, transitionTime, easingFn, undefined, undefined, undefined, onNext);\n      }\n\n      return animation.next(onNext, true);\n    }\n    /**\r\n     * Pause the current animation on a layer.\r\n     *\r\n     * @param {string} name - Name of the layer to pause.\r\n     *\r\n     * @returns {boolean} Whether or not an animation was successfully paused.\r\n     */\n\n  }, {\n    key: "pauseAnimation",\n    value: function pauseAnimation(name) {\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        console.warn("Did not pause animation on layer ".concat(name, " for host ").concat(this._host.id, ". No layer exists with this name."));\n        return false;\n      }\n\n      var paused = layer.pauseAnimation(); // Notify that an animation was paused\n\n      if (paused) {\n        var animationName = layer.currentAnimation;\n        this.emit(this.constructor.EVENTS.pauseAnimation, {\n          layerName: name,\n          animationName: animationName\n        });\n      }\n\n      return paused;\n    }\n    /**\r\n     * Pause the currently playing animation and play a new animation from where it\r\n     * last left off.\r\n     *\r\n     * @param {string} layerName - Name of the layer that contains the animation.\r\n     * @param {string=} animationName - Name of the animation state to resume. Defaults\r\n     * to the name of the current animation for the layer.\r\n     * @param {number=} seconds - The number of seconds it should take to transition\r\n     * to the new animation. Default is zero and will set immediately.\r\n     * @param {Function=} easingFn - The easing function to use while transitioning\r\n     * between animations. Default is Easing.Linear.InOut.\r\n     *\r\n     * @returns {Deferred} - Resolves once the animation reaches the end of its\r\n     * timeline. Looping animations can only resolve if they are interrupted or\r\n     * manually stopped.\r\n     */\n\n  }, {\n    key: "resumeAnimation",\n    value: function resumeAnimation(layerName, animationName, seconds, easingFn) {\n      var _this9 = this;\n\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        var e = "Cannot resume animation ".concat(animationName, " on layer ").concat(layerName, " for host ").concat(this._host.id, ". No layer exists with this name.");\n        return core_Deferred.reject(e);\n      } // Notify that an animation was resumed\n\n\n      this.emit(this.constructor.EVENTS.resumeAnimation, {\n        layerName: layerName,\n        animationName: animationName\n      });\n      return layer.resumeAnimation(animationName, seconds, easingFn, function () {\n        // Notify that an animation has stopped\n        _this9.emit(_this9.constructor.EVENTS.stopAnimation, {\n          layerName: layerName,\n          animationName: animationName\n        });\n      }, undefined, function () {\n        // Notify that an animation has been interrupted\n        _this9.emit(_this9.constructor.EVENTS.interruptAnimation, {\n          layerName: layerName,\n          animationName: animationName\n        });\n      }, function (_ref3) {\n        var name = _ref3.name,\n            canAdvance = _ref3.canAdvance,\n            isQueueEnd = _ref3.isQueueEnd;\n\n        if (layer.currentAnimation === animationName) {\n          // Notify that a new animation has begun\n          _this9.emit(_this9.constructor.EVENTS.playNextAnimation, {\n            layerName: layerName,\n            animationName: animationName,\n            nextQueuedAnimation: name,\n            canAdvance: canAdvance,\n            isQueueEnd: isQueueEnd\n          });\n        }\n      });\n    }\n    /**\r\n     * Stop the current animation on a layer. Stop rewinds the animation to the\r\n     * beginning and prevents it from progressing forward.\r\n     *\r\n     * @param {string} name - Name of the layer that contains the animation.\r\n     *\r\n     * @returns {boolean} Whether or not an animation was successfully stopped.\r\n     */\n\n  }, {\n    key: "stopAnimation",\n    value: function stopAnimation(name) {\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        console.warn("Did not stop animation on layer ".concat(name, " for host ").concat(this._host.id, ". No layer exists with this name."));\n        return false;\n      }\n\n      return layer.stopAnimation();\n    }\n    /**\r\n     * Pause current animation and weight interpolation animation on all layers.\r\n       * @returns {boolean} - Whether or not there was an existing interpolation or\r\n     * current animations to pause.\r\n     */\n\n  }, {\n    key: "pause",\n    value: function pause() {\n      this._paused = true;\n      var paused = false;\n\n      this._layers.forEach(function (l) {\n        if (l.pause()) {\n          paused = true;\n        }\n      });\n\n      return paused;\n    }\n    /**\r\n     * Resume current animation and weight interpolation animation on all layers.\r\n       * @returns {boolean} - Whether or not there was an existing interpolation or\r\n     * current animations to resume.\r\n     */\n\n  }, {\n    key: "resume",\n    value: function resume() {\n      this._paused = false;\n      var resumed = false;\n\n      this._layers.forEach(function (l) {\n        if (l.resume()) {\n          resumed = true;\n        }\n      });\n\n      return resumed;\n    }\n    /**\r\n     * Adds a namespace to the host with the name of the feature to contain properties\r\n     * and methods from the feature that users of the host need access to.\r\n     *\r\n     * @see AnimationFeature\r\n     */\n\n  }, {\n    key: "installApi",\n    value: function installApi() {\n      var _this10 = this;\n\n      /**\r\n       * @inner\r\n       * @namespace AnimationFeature\r\n       */\n      var api = AnimationFeature_get(AnimationFeature_getPrototypeOf(AnimationFeature.prototype), "installApi", this).call(this);\n\n      Object.defineProperties(api, {\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @see core/AnimationFeature#paused\r\n         */\n        paused: {\n          get: function get() {\n            return _this10.paused;\n          }\n        },\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @see core/AnimationFeature#layers\r\n         */\n        layers: {\n          get: function get() {\n            return _this10.layers;\n          }\n        }\n      });\n      Object.assign(api, {\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#addLayer\r\n         */\n        addLayer: this.addLayer.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#removeLayer\r\n         */\n        removeLayer: this.removeLayer.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#moveLayer\r\n         */\n        moveLayer: this.moveLayer.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#renameLayer\r\n         */\n        renameLayer: this.renameLayer.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#getLayerWeight\r\n         */\n        getLayerWeight: this.getLayerWeight.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#setLayerWeight\r\n         */\n        setLayerWeight: this.setLayerWeight.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#pauseLayerWeight\r\n         */\n        pauseLayerWeight: this.pauseLayerWeight.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#resumeLayerWeight\r\n         */\n        resumeLayerWeight: this.resumeLayerWeight.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#pauseLayer\r\n         */\n        pauseLayer: this.pauseLayer.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#resumeLayer\r\n         */\n        resumeLayer: this.resumeLayer.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#getTransitioning\r\n         */\n        getTransitioning: this.getTransitioning.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#getAnimations\r\n         */\n        getAnimations: this.getAnimations.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#getCurrentAnimation\r\n         */\n        getCurrentAnimation: this.getCurrentAnimation.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#getPaused\r\n         */\n        getPaused: this.getPaused.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#getAnimationType\r\n         */\n        getAnimationType: this.getAnimationType.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#addAnimation\r\n         */\n        addAnimation: this.addAnimation.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#removeAnimation\r\n         */\n        removeAnimation: this.removeAnimation.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#renameAnimation\r\n         */\n        renameAnimation: this.renameAnimation.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#getAnimationBlendNames\r\n         */\n        getAnimationBlendNames: this.getAnimationBlendNames.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#getAnimationBlendWeight\r\n         */\n        getAnimationBlendWeight: this.getAnimationBlendWeight.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#setAnimationBlendWeight\r\n         */\n        setAnimationBlendWeight: this.setAnimationBlendWeight.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#playAnimation\r\n         */\n        playAnimation: this.playAnimation.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#playNextAnimation\r\n         */\n        playNextAnimation: this.playNextAnimation.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#pauseAnimation\r\n         */\n        pauseAnimation: this.pauseAnimation.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#resumeAnimation\r\n         */\n        resumeAnimation: this.resumeAnimation.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#stopAnimation\r\n         */\n        stopAnimation: this.stopAnimation.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#pause\r\n         */\n        pause: this.pause.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#resume\r\n         */\n        resume: this.resume.bind(this)\n      });\n    }\n    /**\r\n     * Update each animation layer.\r\n     *\r\n     * @param {number} deltaTime - Time since the last update.\r\n     */\n\n  }, {\n    key: "update",\n    value: function update(deltaTime) {\n      if (!this._layers.length) {\n        return;\n      }\n\n      if (this._paused) {\n        deltaTime = 0;\n      } // Re-evaluate internal weights for layers\n\n\n      this._updateInternalWeights(); // Update layers\n\n\n      this._layers.forEach(function (layer) {\n        layer.update(deltaTime);\n      });\n\n      AnimationFeature_get(AnimationFeature_getPrototypeOf(AnimationFeature.prototype), "update", this).call(this, deltaTime);\n    }\n  }, {\n    key: "discard",\n    value: function discard() {\n      this._layers.forEach(function (layer) {\n        layer.discard();\n      });\n\n      delete this._layers;\n      delete this._layerMap;\n\n      AnimationFeature_get(AnimationFeature_getPrototypeOf(AnimationFeature.prototype), "discard", this).call(this);\n    }\n  }]);\n\n  return AnimationFeature;\n}(core_AbstractHostFeature);\n\nObject.defineProperty(AnimationFeature, \'EVENTS\', {\n  value: AnimationFeature_objectSpread(AnimationFeature_objectSpread({}, Object.getPrototypeOf(core_AbstractHostFeature).EVENTS), {}, {\n    addLayer: \'onAddLayerEvent\',\n    removeLayer: \'onRemoveLayerEvent\',\n    renameLayer: \'onRenameLayerEvent\',\n    addAnimation: \'onAddAnimationEvent\',\n    removeAnimation: \'onRemovedAnimationEvent\',\n    renameAnimation: \'onRenameAnimationEvent\',\n    playAnimation: \'onPlayEvent\',\n    playNextAnimation: \'onNextEvent\',\n    pauseAnimation: \'onPauseEvent\',\n    resumeAnimation: \'onResumeEvent\',\n    interruptAnimation: \'onInterruptEvent\',\n    stopAnimation: \'onStopEvent\'\n  })\n});\n/* harmony default export */ const animpack_AnimationFeature = (AnimationFeature);\n;// CONCATENATED MODULE: ./src/core/PointOfInterestFeature.js\nfunction PointOfInterestFeature_typeof(obj) { "@babel/helpers - typeof"; return PointOfInterestFeature_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, PointOfInterestFeature_typeof(obj); }\n\nfunction PointOfInterestFeature_slicedToArray(arr, i) { return PointOfInterestFeature_arrayWithHoles(arr) || PointOfInterestFeature_iterableToArrayLimit(arr, i) || PointOfInterestFeature_unsupportedIterableToArray(arr, i) || PointOfInterestFeature_nonIterableRest(); }\n\nfunction PointOfInterestFeature_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction PointOfInterestFeature_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction PointOfInterestFeature_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction PointOfInterestFeature_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction PointOfInterestFeature_toConsumableArray(arr) { return PointOfInterestFeature_arrayWithoutHoles(arr) || PointOfInterestFeature_iterableToArray(arr) || PointOfInterestFeature_unsupportedIterableToArray(arr) || PointOfInterestFeature_nonIterableSpread(); }\n\nfunction PointOfInterestFeature_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction PointOfInterestFeature_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return PointOfInterestFeature_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return PointOfInterestFeature_arrayLikeToArray(o, minLen); }\n\nfunction PointOfInterestFeature_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction PointOfInterestFeature_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return PointOfInterestFeature_arrayLikeToArray(arr); }\n\nfunction PointOfInterestFeature_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction PointOfInterestFeature_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction PointOfInterestFeature_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction PointOfInterestFeature_createClass(Constructor, protoProps, staticProps) { if (protoProps) PointOfInterestFeature_defineProperties(Constructor.prototype, protoProps); if (staticProps) PointOfInterestFeature_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction PointOfInterestFeature_get() { if (typeof Reflect !== "undefined" && Reflect.get) { PointOfInterestFeature_get = Reflect.get; } else { PointOfInterestFeature_get = function _get(target, property, receiver) { var base = PointOfInterestFeature_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return PointOfInterestFeature_get.apply(this, arguments); }\n\nfunction PointOfInterestFeature_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = PointOfInterestFeature_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction PointOfInterestFeature_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) PointOfInterestFeature_setPrototypeOf(subClass, superClass); }\n\nfunction PointOfInterestFeature_setPrototypeOf(o, p) { PointOfInterestFeature_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return PointOfInterestFeature_setPrototypeOf(o, p); }\n\nfunction PointOfInterestFeature_createSuper(Derived) { var hasNativeReflectConstruct = PointOfInterestFeature_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = PointOfInterestFeature_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = PointOfInterestFeature_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return PointOfInterestFeature_possibleConstructorReturn(this, result); }; }\n\nfunction PointOfInterestFeature_possibleConstructorReturn(self, call) { if (call && (PointOfInterestFeature_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return PointOfInterestFeature_assertThisInitialized(self); }\n\nfunction PointOfInterestFeature_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction PointOfInterestFeature_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction PointOfInterestFeature_getPrototypeOf(o) { PointOfInterestFeature_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return PointOfInterestFeature_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable no-underscore-dangle */\n\n/* eslint-disable no-unused-vars */\n\n\n\n\n\n\n\n/**\r\n * Enum for axis directions.\r\n *\r\n * @readonly\r\n * @enum {Class}\r\n */\n\nvar AxisMap = {\n  PositiveX: [1, 0, 0],\n  NegativeX: [-1, 0, 0],\n  PositiveY: [0, 1, 0],\n  NegativeY: [0, -1, 0],\n  PositiveZ: [0, 0, 1],\n  NegativeZ: [0, 0, -1]\n};\nvar FaceTargetTypes = {\n  EyeCenter: 0,\n  EyeLeft: 1,\n  EyeRight: 2,\n  Mouth: 3\n}; // Average distance between pupils is .064m, golden ratio says that the distance\n// from center of the pupils to the center of the mouth should be about the same.\n\nvar FaceVectors = [[0, 0, 0], [-.032, 0, 0], [.032, 0, 0], [0, -.064, 0]]; // Time ranges to use when choosing a new random wait time between saccades\n\nvar MicroSaccadeWaitRanges = {\n  "default": [0.8, 1.75],\n  postMacro: [0.6, 1.3125]\n};\nvar MacroSaccadeWaitRanges = {\n  "default": [5.0, 8.0],\n  mouthTarget: [0.2, 0.75],\n  // Look away from a mouth target the fastest\n  eyeTarget: [1.5, 4.0]\n}; // Minimum angle in degrees the eye direction must change to trigger a blink animation\n\nvar BlinkThreshold = 35; // Maximum number of milliseconds to use for calculating look speed\n\nvar MaxDelta = 100 / 3;\n/**\r\n * PointOfInterest controls the gaze direction of the host. Given one or more\r\n * animations of type Blend2dState, it calculates the angles between the lookTracker\r\n * object (generally a joint in the host\'s skeleton) and the lookTarget (the object\r\n * the host should look at) and drives the managed Blend2dStates\' X and Y blend\r\n * values using the result. You can optionally add saccadic movement to any managed\r\n * animation to help make the host\'s eyes appear alive when focused on the same\r\n * point for exteded periods of time. If blink animations are specified, a blink\r\n * will be played during large changes in gaze direction.\r\n *\r\n * @extends AbstractHostFeature\r\n * @alias core/PointOfInterestFeature\r\n * @implements SSMLSpeechmarkInterface\r\n * @implements ManagedAnimationLayerInterface\r\n */\n\nvar PointOfInterestFeature = /*#__PURE__*/function (_AbstractHostFeature$) {\n  PointOfInterestFeature_inherits(PointOfInterestFeature, _AbstractHostFeature$);\n\n  var _super = PointOfInterestFeature_createSuper(PointOfInterestFeature);\n\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {core/HostObject} host - Host that owns the feature.\r\n   * @param {Object=} options - Options for the feature.\r\n   * @param {Object=} target - 3D transformation node that the host should try to\r\n   * look at.\r\n   * @param {Object} options.lookTracker - 3D transformation node that represents\r\n   * the direction the host is currently looking during animation.\r\n   * @param {Object=} options.scene - Engine-specific scene object that contains\r\n   * the host. This object must be defined if using \'setTargetByName\' or \'SetTargetById\'\r\n   * methods.\r\n   * @param {Object=} lookOptions - Options for the look animation layers.\r\n   * @param {number} [lookOptions.blendTime=0.1] - Default amount of time it will\r\n   * take to manipulate the weights of the look layers.\r\n   * @param {number} [lookOptions.easingFn=Quadratic.InOut] - Default easing function\r\n   * to use when manipulating look layer weights.\r\n   * @param {Array.<Object>} [lookOptions.layers=[]] - An array of layer options\r\n   * objects to register as look layers.\r\n   * @param {Object=} blinkOptions - Options for the blink animation layers.\r\n   * @param {number} [blinkOptions.blendTime=0.075] - Default amount of time it\r\n   * will take to manipulate the weights of the blink layers.\r\n   * @param {number} [blinkOptions.easingFn=Quadratic.InOut] - Default easing function\r\n   * to use when manipulating blink layer weights.\r\n   * @param {Array.<Object>} [blinkOptions.layers=[]] - An array of layer options\r\n   * objects to register as blink layers.\r\n   */\n  function PointOfInterestFeature(host) {\n    var _this;\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        target = _ref.target,\n        lookTracker = _ref.lookTracker,\n        scene = _ref.scene;\n\n    var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref2$blendTime = _ref2.blendTime,\n        lookBlendTime = _ref2$blendTime === void 0 ? 0.1 : _ref2$blendTime,\n        _ref2$easingFn = _ref2.easingFn,\n        lookEasingFn = _ref2$easingFn === void 0 ? Quadratic.InOut : _ref2$easingFn,\n        _ref2$layers = _ref2.layers,\n        lookLayers = _ref2$layers === void 0 ? [] : _ref2$layers;\n\n    var _ref3 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n        _ref3$blendTime = _ref3.blendTime,\n        blinkBlendTime = _ref3$blendTime === void 0 ? 0.075 : _ref3$blendTime,\n        _ref3$easingFn = _ref3.easingFn,\n        blinkEasingFn = _ref3$easingFn === void 0 ? Quadratic.InOut : _ref3$easingFn,\n        _ref3$layers = _ref3.layers,\n        blinkLayers = _ref3$layers === void 0 ? [] : _ref3$layers;\n\n    PointOfInterestFeature_classCallCheck(this, PointOfInterestFeature);\n\n    _this = _super.call(this, host);\n\n    if (!_this.constructor._validateTransformObject(lookTracker)) {\n      throw new Error("Cannot initialize PointOfInterestFeature on host ".concat(_this._host.id, ". LookTracker must be defined as a valid transformation object."));\n    }\n\n    _this._lookTracker = lookTracker;\n    _this._scene = scene;\n    _this._target = target || null;\n    _this._prevTargetPos = [0, 0, 0];\n    _this._isTargetMoving = false;\n    _this._lookLayers = _this._lookLayers || {};\n    _this._trackingConfigs = _this._trackingConfigs || [];\n    _this._blinkLayers = _this._blinkLayers || {}; // Register the look layers\n\n    lookLayers.forEach(function (_ref4) {\n      var name = _ref4.name,\n          animation = _ref4.animation,\n          maxSpeed = _ref4.maxSpeed,\n          reference = _ref4.reference,\n          forwardAxis = _ref4.forwardAxis,\n          hasSaccade = _ref4.hasSaccade,\n          blendTime = _ref4.blendTime,\n          easingFn = _ref4.easingFn;\n\n      _this.registerLookLayer(name, {\n        animation: animation,\n        maxSpeed: maxSpeed,\n        reference: reference,\n        forwardAxis: forwardAxis,\n        hasSaccade: hasSaccade,\n        blendTime: blendTime !== undefined ? blendTime : lookBlendTime,\n        easingFn: easingFn !== undefined ? easingFn : lookEasingFn\n      });\n    }); // Register the blink layers\n\n    blinkLayers.forEach(function (_ref5) {\n      var name = _ref5.name,\n          animation = _ref5.animation,\n          blendTime = _ref5.blendTime,\n          easingFn = _ref5.easingFn;\n\n      _this.registerBlinkLayer(name, {\n        animation: animation,\n        blendTime: blendTime !== undefined ? blendTime : blinkBlendTime,\n        easingFn: easingFn !== undefined ? easingFn : blinkEasingFn\n      });\n    });\n    return _this;\n  }\n  /**\r\n   * Gets and sets the target object the host should look at.\r\n   *\r\n   * @type {Object|null}\r\n   */\n\n\n  PointOfInterestFeature_createClass(PointOfInterestFeature, [{\n    key: "target",\n    get: function get() {\n      return this._target;\n    },\n    set: function set(target) {\n      this._target = target || null;\n    }\n    /**\r\n     * Return a vector representing the global position of an object. Should be\r\n     * overloaded for each rendering engine implementation.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {any} _obj - Engine-specific 3D transform object.\r\n     *\r\n     * @returns {Array.<number>} - An array consisting of three numbers representing\r\n     * x, y and z coordinates.\r\n     */\n\n  }, {\n    key: "_onLayerAdded",\n    value: function _onLayerAdded(_ref6) {\n      var name = _ref6.name;\n      this._lookLayers = this._lookLayers || {};\n      this._blinkLayers = this._blinkLayers || {};\n\n      PointOfInterestFeature_get(PointOfInterestFeature_getPrototypeOf(PointOfInterestFeature.prototype), "_onLayerAdded", this).call(this, {\n        name: name\n      }); // Validate the look animation\n\n\n      if (this._lookLayers[name] !== undefined) {\n        this._registerLookAnimation(name, this._lookLayers[name]);\n      }\n    }\n  }, {\n    key: "_onAnimationAdded",\n    value: function _onAnimationAdded(_ref7) {\n      var layerName = _ref7.layerName,\n          animationName = _ref7.animationName;\n      this._lookLayers = this._lookLayers || {};\n      this._blinkLayers = this._blinkLayers || {};\n\n      PointOfInterestFeature_get(PointOfInterestFeature_getPrototypeOf(PointOfInterestFeature.prototype), "_onAnimationAdded", this).call(this, {\n        layerName: layerName\n      }); // Validate the look animation\n\n\n      if (this._lookLayers[layerName] === animationName) {\n        this._registerLookAnimation(layerName, animationName);\n      }\n    }\n    /**\r\n     * Ensure that registered look animations are Blend2dStates.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} layerName - Name of the layer that contains the look animation.\r\n     * @param {string} animationName - Name of the animation.\r\n     */\n\n  }, {\n    key: "_registerLookAnimation",\n    value: function _registerLookAnimation(layerName, animationName) {\n      if (this._managedLayers[layerName].animations[animationName].isActive) {\n        if (AnimationTypes[this._host.AnimationFeature.getAnimationType(layerName, animationName)] !== AnimationTypes.blend2d) {\n          // Warn and deactivate if the registered state is not blend2d\n          console.warn("Cannot register Point of Interest look animation ".concat(animationName, " on layer ").concat(layerName, " for host ").concat(this._host.id, ". Look animations must be of type \'blend2d\'."));\n          this._managedLayers[layerName].animations[animationName].isActive = false;\n        }\n      }\n    }\n    /**\r\n     * Check if the given object is not of an engine-specific type. Should\r\n     * be overloaded for each rendering engine implementation.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {any} obj - Object to validate.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "_addTrackingConfig",\n    value:\n    /**\r\n     * Check if the given configuration object has already been stored as a tracking\r\n     * config. If it has, return the stored configuration. Otherwise, store and\r\n     * return it.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {Object} config - Object containing tracker, reference and forwardAxis\r\n     * properties.\r\n     *\r\n     * @returns {Object}\r\n     */\n    function _addTrackingConfig(config) {\n      var trackingConfig = this._trackingConfigs.find(function (c) {\n        return c.reference === config.reference && c.forwardAxis === config.forwardAxis;\n      });\n\n      if (trackingConfig) {\n        return trackingConfig;\n      } else {\n        config.angles = {\n          h: 0,\n          v: 0\n        };\n        config.prevAngles = {\n          h: 0,\n          v: 0\n        };\n\n        this._trackingConfigs.push(config);\n\n        return config;\n      }\n    }\n    /**\r\n     * Return the distance between the look tracker and the look target.\r\n     *\r\n     * @private\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: "_getTargetDistance",\n    value: function _getTargetDistance() {\n      // Find the vector between the global positions of tracker and target\n      var sourcePosition = this.constructor._getWorldPosition(this._lookTracker);\n\n      var targetPosition = this.constructor._getWorldPosition(this._target);\n\n      var lookVector = [targetPosition[0] - sourcePosition[0], targetPosition[1] - sourcePosition[1], targetPosition[2] - sourcePosition[2]];\n      return core_MathUtils.getVectorMagnitude(lookVector);\n    }\n    /**\r\n     * Reset all stored tracking angles to 0.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_resetLookAngles",\n    value: function _resetLookAngles() {\n      this._trackingConfigs.forEach(function (_ref8) {\n        var angles = _ref8.angles;\n        angles.h = 0;\n        angles.v = 0;\n      });\n    }\n    /**\r\n     * Store the difference in horizontal and vertical rotation for the tracker\'s\r\n     * reference rotation and the direction of the target from the tracker.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_setLookAngles",\n    value: function _setLookAngles() {\n      var _this2 = this;\n\n      // Get the current positions of the tracker and target objects\n      var targetPos = this.constructor._getWorldPosition(this._target);\n\n      var trackerPos = this.constructor._getWorldPosition(this._lookTracker); // Check if the target has moved\n\n\n      this._isTargetMoving = core_MathUtils.getVectorMagnitude([targetPos[0] - this._prevTargetPos[0], targetPos[1] - this._prevTargetPos[1], targetPos[2] - this._prevTargetPos[2]]) > 0;\n      Object.assign(this._prevTargetPos, targetPos); // Calculate the horizontal and vertical angles to rotate to the target\n\n      var targetSpherical = core_MathUtils.cartesianToSpherical(targetPos[0] - trackerPos[0], targetPos[1] - trackerPos[1], targetPos[2] - trackerPos[2]);\n\n      var targetAngles = this.constructor._sphericalToBlendValue(targetSpherical[1], targetSpherical[2]); // Calculate angles relative to the reference objects\n\n\n      this._trackingConfigs.forEach(function (_ref9) {\n        var reference = _ref9.reference,\n            forwardAxis = _ref9.forwardAxis,\n            angles = _ref9.angles;\n\n        // Calculate the horizontal and vertical angles to rotate to the direction of the tracker\n        var refDirection = _this2.constructor._getObjectDirection(reference, forwardAxis);\n\n        var refSpherical = core_MathUtils.cartesianToSpherical.apply(core_MathUtils, PointOfInterestFeature_toConsumableArray(refDirection));\n\n        var refAngles = _this2.constructor._sphericalToBlendValue(refSpherical[1], refSpherical[2]); // Store the difference\n\n\n        angles.h = targetAngles.h - refAngles.h;\n        angles.v = targetAngles.v - refAngles.v;\n      });\n    }\n    /**\r\n     * Return the horizontal and vertical angles it would require to simulate looking\r\n     * at the given type of face target\r\n     *\r\n     * @private\r\n     *\r\n     * @param {number} targetType - Integer representing the FaceTargetType.\r\n     *\r\n     * @returns {Object}- An object with signature {r: number, h: number, v: number}\r\n     * where \'r\' represents radius, h represents the horizontal/azimuthal angle and\r\n     * v represents the vertical/polar angle.\r\n     */\n\n  }, {\n    key: "_getFaceTargetAngles",\n    value: function _getFaceTargetAngles(targetType) {\n      // No offset when the target is the center of the eyes\n      if (targetType === 0) {\n        return {\n          h: 0,\n          v: 0\n        };\n      } // Build a vector to the face target type using the current distance to the target\n\n\n      var distance = this._getTargetDistance(this._lookTracker);\n\n      var faceVector = PointOfInterestFeature_toConsumableArray(FaceVectors[targetType]);\n\n      faceVector[2] = distance;\n      var spherical = core_MathUtils.cartesianToSpherical.apply(core_MathUtils, PointOfInterestFeature_toConsumableArray(faceVector)); // Make sure values are clamped within the range of motion of the human eye, in case the target is very close\n\n      var blendValues = this.constructor._sphericalToBlendValue(spherical[1], spherical[2]);\n\n      blendValues.h = core_MathUtils.clamp(blendValues.h, -35, 35);\n      blendValues.v = core_MathUtils.clamp(blendValues.v, -25, 30);\n      return blendValues;\n    }\n    /**\r\n     * Updated the stored speed and duration variables for a layer based on the\r\n     * change in horizontal and vertical angles of the tracker.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} layerName - Name of the layer to store values on.\r\n     * @param {number} h - Change in horizontal angle, in degrees.\r\n     * @param {number} v - Change in vertical angle, in degrees.\r\n     */\n\n  }, {\n    key: "_updateLayerSpeed",\n    value: function _updateLayerSpeed(layerName, h, v) {\n      var layer = this._managedLayers[layerName]; // From "Realistic Avatar and head Animation Using a Neurobiological Model of Visual Attention", Itti, Dhavale, Pighin\n\n      layer.maxHSpeed = 473 * (1 - Math.exp(-h / 7.8));\n      layer.maxVSpeed = 473 * (1 - Math.exp(-v / 7.8)); // From "Eyes Alive", Lee, Badler\n\n      var D0 = 0.025;\n      var d = 0.00235;\n      layer.hDuration = D0 + d * h;\n      layer.vDuration = D0 + d * v;\n    }\n    /**\r\n     * Set the microSaccade object with new randomized values.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} layerName - Name of the layer that owns the saccade motion.\r\n     */\n\n  }, {\n    key: "_setMicroSaccade",\n    value: function _setMicroSaccade(layerName) {\n      var layer = this._managedLayers[layerName];\n      var microSaccade = layer.microSaccade;\n\n      if (this._target) {\n        // Micro movements should be smaller when focused on a target\n        microSaccade.h = core_Utils.getRandomFloat(.01, .15);\n        microSaccade.v = core_Utils.getRandomFloat(.01, .15);\n      } else {\n        // Microsaccades. Encyclopedia of Neuroscience. (2009) Springer, Berlin, Heidelberg. https://doi.org/10.1007/978-3-540-29678-2_3492\n        microSaccade.h = core_Utils.getRandomFloat(.01, .3);\n        microSaccade.v = core_Utils.getRandomFloat(.01, .3);\n      }\n\n      this._updateLayerSpeed(layerName, microSaccade.h, microSaccade.v); // Restart the timer\n\n\n      this._initializeMicroTimer.apply(this, [layerName].concat(PointOfInterestFeature_toConsumableArray(MicroSaccadeWaitRanges["default"])));\n    }\n    /**\r\n     * Set the macroSaccade object with new randomized values.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} layerName - Name of the layer that owns the saccade motion.\r\n     */\n\n  }, {\n    key: "_setMacroSaccade",\n    value: function _setMacroSaccade(layerName) {\n      var layer = this._managedLayers[layerName];\n      var macroSaccade = layer.macroSaccade;\n      var macroSaccadeWaitRange; // Increase random value range when not focused on a target\n\n      if (!this._target) {\n        macroSaccadeWaitRange = MacroSaccadeWaitRanges["default"]; // Normal human horizontal eye rotation limit is about 35 degrees\n\n        var hLimit = core_Utils.getRandomFloat(.143, .286);\n        var hFactor = core_Utils.getRandomFloat(-hLimit, hLimit);\n        macroSaccade.h = hFactor * 35; // Normal human vertical eye rotation limit is about 25 degrees upward and 30 degrees downward\n\n        var vLimit = core_Utils.getRandomFloat(.093, .186);\n        var vFactor = core_Utils.getRandomFloat(-vLimit, vLimit);\n        macroSaccade.v = vFactor > 0 ? vFactor * 25 : vFactor * 30;\n      } // Pick a new face target\n      else {\n        // Social triangle - saccade between eyes and mouth, weighted to look at eyes more often\n        switch (layer.saccadeTarget) {\n          case 1:\n            macroSaccadeWaitRange = MacroSaccadeWaitRanges.eyeTarget;\n            layer.saccadeTarget = Math.random() < 0.75 ? FaceTargetTypes.EyeRight : FaceTargetTypes.Mouth;\n            break;\n\n          case 2:\n            macroSaccadeWaitRange = MacroSaccadeWaitRanges.eyeTarget;\n            layer.saccadeTarget = Math.random() < 0.75 ? FaceTargetTypes.EyeLeft : FaceTargetTypes.Mouth;\n            break;\n\n          case 3:\n            macroSaccadeWaitRange = MacroSaccadeWaitRanges.mouthTarget;\n            layer.saccadeTarget = Math.random() < 0.5 ? FaceTargetTypes.EyeLeft : FaceTargetTypes.EyeRight;\n            break;\n\n          case 0:\n          default:\n            macroSaccadeWaitRange = MacroSaccadeWaitRanges.eyeTarget;\n            layer.saccadeTarget = Math.random() < 0.5 ? FaceTargetTypes.EyeLeft : FaceTargetTypes.EyeRight;\n            break;\n        }\n\n        var _this$_getFaceTargetA = this._getFaceTargetAngles(layer.saccadeTarget),\n            h = _this$_getFaceTargetA.h,\n            v = _this$_getFaceTargetA.v;\n\n        macroSaccade.h = h;\n        macroSaccade.v = v;\n      }\n\n      this._updateLayerSpeed(layerName, macroSaccade.h, macroSaccade.v); // Restart the timers\n\n\n      this._initializeMicroTimer.apply(this, [layerName].concat(PointOfInterestFeature_toConsumableArray(MicroSaccadeWaitRanges.postMacro)));\n\n      this._initializeMacroTimer.apply(this, [layerName].concat(PointOfInterestFeature_toConsumableArray(macroSaccadeWaitRange)));\n    }\n    /**\r\n     * Start a new wait timer that will set a new micro saccade movement when it\r\n     * resolves.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} layerName - Name of the layer that owns the saccade motion.\r\n     * @param {number} minWaitTime - Minimum number of seconds before a new saccade\r\n     * will be triggered.\r\n     * @param {number} maxWaitTime - Maximum number of seconds before a new saccade\r\n     * will be triggered.\r\n     */\n\n  }, {\n    key: "_initializeMicroTimer",\n    value: function _initializeMicroTimer(layerName, minWaitTime, maxWaitTime) {\n      var _this3 = this;\n\n      var layer = this._managedLayers[layerName];\n      var waitTime = core_Utils.getRandomFloat(minWaitTime, maxWaitTime);\n\n      if (layer.microSaccadeTimer) {\n        layer.microSaccadeTimer.cancel();\n      }\n\n      layer.microSaccadeTimer = core_Utils.wait(waitTime, {\n        onFinish: function onFinish() {\n          _this3._setMicroSaccade(layerName);\n        }\n      });\n    }\n    /**\r\n     * Start a new wait timer that will set a new macro saccade movement when it\r\n     * resolves.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} layerName - Name of the layer that owns the saccade motion.\r\n     * @param {number} minWaitTime - Minimum number of seconds before a new saccade\r\n     * will be triggered.\r\n     * @param {number} maxWaitTime - Maximum number of seconds before a new saccade\r\n     * will be triggered.\r\n     */\n\n  }, {\n    key: "_initializeMacroTimer",\n    value: function _initializeMacroTimer(layerName, minWaitTime, maxWaitTime) {\n      var _this4 = this;\n\n      var layer = this._managedLayers[layerName];\n      var waitTime = core_Utils.getRandomFloat(minWaitTime, maxWaitTime);\n\n      if (layer.macroSaccadeTimer) {\n        layer.macroSaccadeTimer.cancel();\n      }\n\n      layer.macroSaccadeTimer = core_Utils.wait(waitTime, {\n        onFinish: function onFinish() {\n          _this4._setMacroSaccade(layerName);\n        }\n      });\n    }\n    /**\r\n     * Sets a new target to look at.\r\n     *\r\n     * @param {Object|null} target - The new target to look at.\r\n     */\n\n  }, {\n    key: "setTarget",\n    value: function setTarget(target) {\n      this.target = target;\n    }\n    /**\r\n     * Finds an object given its name and sets it as the new target to look at.\r\n     * Should be overloaded for each rendering engine implementation.\r\n     *\r\n     * @param {string} target - Name to search for.\r\n     */\n\n  }, {\n    key: "setTargetByName",\n    value: function setTargetByName(name) {\n      if (!name) {\n        this._target = null;\n      }\n\n      if (!this._scene) {\n        throw new Error("Cannot set PointOfInterestFeature target using name ".concat(name, " on host ").concat(this._host.id, ". Scene must be defined."));\n      }\n    }\n    /**\r\n     * Finds an object given its id and sets it as the new target to look at.\r\n     * Should be overloaded for each rendering engine implementation.\r\n     *\r\n     * @param {string|number} target - Id to search for.\r\n     */\n\n  }, {\n    key: "setTargetById",\n    value: function setTargetById(id) {\n      if (!id) {\n        this._target = null;\n      }\n\n      if (!this._scene) {\n        throw new Error("Cannot set PointOfInterestFeature target using id ".concat(id, " on host ").concat(this._host.id, ". Scene must be defined."));\n      }\n    }\n    /**\r\n     * Start keeping track of an animation layer that owns a blend2d animation with\r\n     * blendWeights corresponding to horizontal and vertical look angles.\r\n     *\r\n     * @param {string} layerName - Name of the layer to keep track of.\r\n     * @param {Object=} options - Options for the layer.\r\n     * @param {string} [options.animation = \'look\'] - Name of the animation on the\r\n     * layer whose blendWeights will be driven based on the angle between the lookTracker\r\n     * and the lookTarget. This animation must be of type blend2d.\r\n     * @param {number} [options.maxSpeed = 25] - The maximum speed at which the blend2d\r\n     * blendWeights can be manipulated.\r\n     * @param {string} [options.forwardAxis = \'PositiveZ\'] - Axis pointing from the\r\n     * front of the lookReference object. Valid options are \'PositiveX\', \'NegativeX\',\r\n     * \'PositiveY\', \'NegativeY\', \'PositiveZ\', \'NegativeZ\'.\r\n     * @param {Object=} options.lookReference - 3D transformation node that the lookTracker\r\n     * rotation limits should be calculated relative to. Defaults to the host owner.\r\n     * @param {number} [options.hasSaccade = false] - Whether or not to include\r\n     * saccadic motion onto the blendWeight animation. This should only be set to\r\n     * true for blend2d animations representing eye animation.\r\n     * @param {number=} [options.blendTime=[PointOfInterestFeature.DEFAULT_LAYER_OPTIONS.blendTime]{@link PointOfInterestFeature#DEFAULT_LAYER_OPTIONS#blendTime}] -\r\n     * Default amount of time to use when manipulating layer weight.\r\n     * @param {Function=} options.easingFn - Default easing function to use when\r\n     * manipulating layer weight.\r\n     */\n\n  }, {\n    key: "registerLookLayer",\n    value: function registerLookLayer(layerName) {\n      var _ref10 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref10$animation = _ref10.animation,\n          animation = _ref10$animation === void 0 ? \'look\' : _ref10$animation,\n          _ref10$maxSpeed = _ref10.maxSpeed,\n          maxSpeed = _ref10$maxSpeed === void 0 ? 25 : _ref10$maxSpeed,\n          reference = _ref10.reference,\n          _ref10$forwardAxis = _ref10.forwardAxis,\n          forwardAxis = _ref10$forwardAxis === void 0 ? \'PositiveZ\' : _ref10$forwardAxis,\n          _ref10$hasSaccade = _ref10.hasSaccade,\n          hasSaccade = _ref10$hasSaccade === void 0 ? false : _ref10$hasSaccade,\n          _ref10$blendTime = _ref10.blendTime,\n          blendTime = _ref10$blendTime === void 0 ? PointOfInterestFeature.DEFAULT_LAYER_OPTIONS.blendTime : _ref10$blendTime,\n          easingFn = _ref10.easingFn;\n\n      // Validate reference object\n      reference = reference || this._host.owner;\n\n      if (!this.constructor._validateTransformObject(reference)) {\n        throw new Error("Cannot initialize register look layer ".concat(layerName, " for PointOfInterestFeature on host ").concat(this._host.id, ". Reference must be defined as a valid transformation object."));\n      } // Find vector associated with axis string\n\n\n      forwardAxis = AxisMap[forwardAxis] !== undefined ? AxisMap[forwardAxis] : AxisMap.PositiveZ; // Store tracking configuration\n\n      var trackingConfig = this._addTrackingConfig({\n        reference: reference,\n        forwardAxis: forwardAxis\n      }); // Register the layer and animation\n\n\n      this.registerLayer(layerName, {\n        trackingConfig: trackingConfig,\n        maxSpeed: maxSpeed,\n        maxHSpeed: undefined,\n        maxVSpeed: undefined,\n        hDuration: undefined,\n        vDuration: undefined,\n        hVelocity: [0, 0],\n        vVelocity: [0, 0],\n        hasSaccade: hasSaccade,\n        blendTime: blendTime,\n        easingFn: easingFn,\n        microSaccade: {\n          h: 0,\n          v: 0\n        },\n        macroSaccade: {\n          h: 0,\n          v: 0\n        },\n        saccadeTarget: FaceTargetTypes.EyeCenter,\n        animations: PointOfInterestFeature_defineProperty({}, animation, {})\n      });\n      this._lookLayers[layerName] = animation; // Validate the look animation\n\n      this._registerLookAnimation(layerName, animation); // Initialize saccade timers\n\n\n      if (hasSaccade) {\n        var macroSaccadeWaitRange = this._target ? MacroSaccadeWaitRanges.eyeTarget : MacroSaccadeWaitRanges["default"];\n\n        this._initializeMicroTimer.apply(this, [layerName].concat(PointOfInterestFeature_toConsumableArray(MicroSaccadeWaitRanges["default"])));\n\n        this._initializeMacroTimer.apply(this, [layerName].concat(PointOfInterestFeature_toConsumableArray(macroSaccadeWaitRange)));\n      }\n    }\n    /**\r\n     * Start keeping track of an animation layer that owns a blink animation. Blink\r\n     * animations can be of any type, but if it is of type randomAnimation then a\r\n     * it will be randomized each time a blink is called.\r\n     *\r\n     * @param {string} layerName - Name of the layer to keep track of.\r\n     * @param {Object=} options - Options for the layer.\r\n     * @param {string} [options.animation = \'blink\'] - Name of the blink animation\r\n     * on the layer.\r\n     * @param {number} [options.blendTime=[PointOfInterestFeature.DEFAULT_LAYER_OPTIONS.blendTime]{@link PointOfInterestFeature#DEFAULT_LAYER_OPTIONS#blendTime}] -\r\n     * Default amount of time to use when manipulating the layer\'s weight.\r\n     * @param {Function=} options.easingFn - Default easing function to use when\r\n     * manipulating the layer\'s weight.\r\n     */\n\n  }, {\n    key: "registerBlinkLayer",\n    value: function registerBlinkLayer(layerName) {\n      var _ref11 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref11$animation = _ref11.animation,\n          animation = _ref11$animation === void 0 ? \'blink\' : _ref11$animation,\n          _ref11$blendTime = _ref11.blendTime,\n          blendTime = _ref11$blendTime === void 0 ? PointOfInterestFeature.DEFAULT_LAYER_OPTIONS.blendTime : _ref11$blendTime,\n          easingFn = _ref11.easingFn;\n\n      // Register the layer and animation\n      this.registerLayer(layerName, {\n        blendTime: blendTime,\n        easingFn: easingFn,\n        animations: PointOfInterestFeature_defineProperty({}, animation, {})\n      });\n      this._blinkLayers[layerName] = animation;\n    }\n  }, {\n    key: "update",\n    value: function update(deltaTime) {\n      var _this5 = this;\n\n      PointOfInterestFeature_get(PointOfInterestFeature_getPrototypeOf(PointOfInterestFeature.prototype), "update", this).call(this, deltaTime); // Update the look angles\n\n\n      if (this._target) {\n        this._setLookAngles();\n      } else {\n        this._resetLookAngles();\n      }\n\n      var deltaSeconds = Math.min(deltaTime, MaxDelta) / 1000;\n      var triggerBlink = false; // Set look blend values\n\n      Object.entries(this._lookLayers).forEach(function (_ref12) {\n        var _ref13 = PointOfInterestFeature_slicedToArray(_ref12, 2),\n            layerName = _ref13[0],\n            animName = _ref13[1];\n\n        var options = _this5._managedLayers[layerName]; // Increment the saccade timers\n\n        if (options.isActive && options.hasSaccade) {\n          options.microSaccadeTimer.execute(deltaTime);\n          options.macroSaccadeTimer.execute(deltaTime);\n        } // Set the blend values\n\n\n        if (options.animations[animName].isActive) {\n          var currentH = _this5._host.AnimationFeature.getAnimationBlendWeight(layerName, animName, \'X\');\n\n          var currentV = _this5._host.AnimationFeature.getAnimationBlendWeight(layerName, animName, \'Y\');\n\n          var targetH = options.trackingConfig.angles.h;\n          var targetV = options.trackingConfig.angles.v; // Check if the look angle has changed enough to trigger a blink\n\n          if (_this5._isTargetMoving && !triggerBlink) {\n            var prevTargetH = options.trackingConfig.prevAngles.h;\n            var prevTargetV = options.trackingConfig.prevAngles.v;\n            var changeAmount = core_MathUtils.toDegrees(core_MathUtils.getAngleBetween([prevTargetH, prevTargetV], [targetH, targetV]));\n\n            if (changeAmount >= BlinkThreshold) {\n              triggerBlink = true;\n            }\n          }\n\n          options.trackingConfig.prevAngles.h = targetH;\n          options.trackingConfig.prevAngles.v = targetV; // Add in the saccade movement\n\n          if (options.hasSaccade) {\n            core_MathUtils.dampValue(0, options.macroSaccade.h + options.macroSaccade.h, options.hVelocity, options.hDuration, options.maxHSpeed);\n            targetH += options.hVelocity[0];\n            core_MathUtils.dampValue(0, options.macroSaccade.v + options.macroSaccade.v, options.vVelocity, options.vDuration, options.maxVSpeed);\n            targetV += options.vVelocity[0];\n          } // Clamp to max speed\n\n\n          var factor = core_MathUtils.clamp(deltaSeconds * options.maxSpeed, 0, 1);\n          targetH = core_MathUtils.lerp(currentH, targetH, factor);\n          targetV = core_MathUtils.lerp(currentV, targetV, factor); // Update the blend values\n\n          _this5._host.AnimationFeature.setAnimationBlendWeight(layerName, animName, \'X\', targetH);\n\n          _this5._host.AnimationFeature.setAnimationBlendWeight(layerName, animName, \'Y\', targetV);\n        }\n      });\n\n      if (!triggerBlink || !this._isTargetMoving) {\n        return;\n      } // Execute blink\n\n\n      Object.entries(this._blinkLayers).forEach(function (_ref14) {\n        var _ref15 = PointOfInterestFeature_slicedToArray(_ref14, 2),\n            layerName = _ref15[0],\n            animName = _ref15[1];\n\n        var animation = _this5._managedLayers[layerName].animations[animName];\n\n        if (animation.isActive) {\n          _this5._host.AnimationFeature.playAnimation(layerName, animName);\n        }\n      });\n    }\n  }, {\n    key: "installApi",\n    value: function installApi() {\n      var _this6 = this;\n\n      /**\r\n       * @inner\r\n       * @namespace PointOfInterestFeature\r\n       */\n      var api = PointOfInterestFeature_get(PointOfInterestFeature_getPrototypeOf(PointOfInterestFeature.prototype), "installApi", this).call(this);\n\n      Object.defineProperties(api, {\n        /**\r\n         * @memberof PointOfInterestFeature\r\n         * @instance\r\n         * @see core/PointOfInterestFeature#target\r\n         */\n        target: {\n          get: function get() {\n            return _this6.target;\n          },\n          set: function set(target) {\n            _this6.target = target;\n          }\n        }\n      });\n      Object.assign(api, {\n        /**\r\n         * @memberof PointOfInterestFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/PointOfInterestFeature#registerLookLayer\r\n         */\n        registerLookLayer: this.registerLookLayer.bind(this),\n\n        /**\r\n         * @memberof PointOfInterestFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/PointOfInterestFeature#registerBlinkLayer\r\n         */\n        registerBlinkLayer: this.registerBlinkLayer.bind(this),\n\n        /**\r\n         * @memberof PointOfInterestFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/PointOfInterestFeature#setTarget\r\n         */\n        setTarget: this.setTarget.bind(this),\n\n        /**\r\n         * @memberof PointOfInterestFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/PointOfInterestFeature#setTargetByName\r\n         */\n        setTargetByName: this.setTargetByName.bind(this),\n\n        /**\r\n         * @memberof PointOfInterestFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/PointOfInterestFeature#setTargetById\r\n         */\n        setTargetById: this.setTargetById.bind(this)\n      });\n      return api;\n    }\n  }], [{\n    key: "_getWorldPosition",\n    value: function _getWorldPosition(obj) {\n      return [0, 0, 0];\n    }\n    /**\r\n     * Return a matrix representing the global transformation matrix of an object.\r\n     * Should be overloaded for each rendering engine implementation.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {any} obj - Engine-specific 3D transform object.\r\n     *\r\n     * @returns {Array.<number>} - An array consisting of 16 numbers representing\r\n     * the 3d transformation.\r\n     */\n\n  }, {\n    key: "_getWorldMatrix",\n    value: function _getWorldMatrix(obj) {\n      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n    }\n    /**\r\n     * Rotate the given local direction vector by the object\'s world rotation matrix.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {any} obj - Engine-specific 3D transform object.\r\n     * @param {Array.<number>} forwardVector - Unit vector representing the local\r\n     * forward direction of the object.\r\n     *\r\n     * @returns {Array.<number>}\r\n     */\n\n  }, {\n    key: "_getObjectDirection",\n    value: function _getObjectDirection(obj) {\n      var forwardVector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AxisMap.PositiveZ;\n      var rotation = core_MathUtils.getRotationMatrix(this._getWorldMatrix(obj));\n      return core_MathUtils.rotateVector(forwardVector, rotation);\n    }\n    /**\r\n     * Calculate horizontal and vertical look angles in degrees given spherical theta\r\n     * and phi angles in radians.\r\n     *\r\n     * @param {number} theta - Vertical/polar angle in radians where 0 points directly\r\n     * along positive Y axis.\r\n     * @param {number} phi - Horizontal/azimuthal angle in radians.\r\n     *\r\n     * @returns {Object} - An object with the signature {h: number, v: number} where\r\n     * h represents horizontal rotation in degrees and v represents vertical rotation\r\n     * in degrees.\r\n     */\n\n  }, {\n    key: "_sphericalToBlendValue",\n    value: function _sphericalToBlendValue(theta, phi) {\n      var h = core_MathUtils.toDegrees(phi); // Offset the vertical angle so 0 is pointing forward instead of up\n\n      var v = core_MathUtils.toDegrees(theta) - 90; // Convert vertical angle to -180, 180 range\n\n      return {\n        h: h,\n        v: v\n      };\n    }\n  }, {\n    key: "_validateTransformObject",\n    value: function _validateTransformObject(obj) {\n      return obj instanceof Object;\n    }\n  }]);\n\n  return PointOfInterestFeature;\n}(core_AbstractHostFeature.mix(awspack_SSMLSpeechmarkInterface.Mixin, animpack_ManagedAnimationLayerInterface.Mixin));\n\n/* harmony default export */ const core_PointOfInterestFeature = (PointOfInterestFeature);\n\n;// CONCATENATED MODULE: ./src/core/animpack/index.js\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\r\n * @module core/animpack\r\n */\n\n\n\n\n\n\n\n\n\n\n\n/**\r\n * @namespace\r\n */\n\nvar Easing = {\n  /**\r\n   * @see Linear\r\n   */\n  Linear: Linear,\n\n  /**\r\n   * @see Quadratic\r\n   */\n  Quadratic: Quadratic,\n\n  /**\r\n   * @see Cubic\r\n   */\n  Cubic: Cubic,\n\n  /**\r\n   * @see Quartic\r\n   */\n  Quartic: Quartic,\n\n  /**\r\n   * @see Quintic\r\n   */\n  Quintic: Quintic,\n\n  /**\r\n   * @see Sinusoidal\r\n   */\n  Sinusoidal: Sinusoidal,\n\n  /**\r\n   * @see Exponential\r\n   */\n  Exponential: Exponential,\n\n  /**\r\n   * @see Circular\r\n   */\n  Circular: Circular,\n\n  /**\r\n   * @see Elastic\r\n   */\n  Elastic: Elastic,\n\n  /**\r\n   * @see Back\r\n   */\n  Back: Back,\n\n  /**\r\n   * @see Bounce\r\n   */\n  Bounce: Bounce\n};\n/* harmony default export */ const animpack = ({\n  /**\r\n   * @see core/AnimationFeature\r\n   */\n  AnimationFeature: animpack_AnimationFeature,\n\n  /**\r\n   * @see AnimationLayer\r\n   */\n  AnimationLayer: animpack_AnimationLayer,\n\n  /**\r\n   * @see core/SingleState\r\n   */\n  SingleState: state_SingleState,\n\n  /**\r\n   * @see TransitionState\r\n   */\n  TransitionState: state_TransitionState,\n\n  /**\r\n   * @see FreeBlendState\r\n   */\n  FreeBlendState: state_FreeBlendState,\n\n  /**\r\n   * @see QueueState\r\n   */\n  QueueState: state_QueueState,\n\n  /**\r\n   * @see RandomAnimationState\r\n   */\n  RandomAnimationState: state_RandomAnimationState,\n\n  /**\r\n   * @see Blend1dState\r\n   */\n  Blend1dState: state_Blend1dState,\n\n  /**\r\n   * @see Blend2dState\r\n   */\n  Blend2dState: state_Blend2dState,\n\n  /**\r\n   * @see AnimationUtils\r\n   */\n  AnimationUtils: animpack_AnimationUtils,\n  Easing: Easing,\n\n  /**\r\n   * @see LayerBlendModes\r\n   */\n  LayerBlendModes: LayerBlendModes,\n\n  /**\r\n   * @see DefaultLayerBlendMode\r\n   */\n  DefaultLayerBlendMode: DefaultLayerBlendMode,\n\n  /**\r\n   * @see AnimationTypes\r\n   */\n  AnimationTypes: AnimationTypes\n});\n;// CONCATENATED MODULE: ./src/core/awspack/TextToSpeechUtils.js\nfunction TextToSpeechUtils_toConsumableArray(arr) { return TextToSpeechUtils_arrayWithoutHoles(arr) || TextToSpeechUtils_iterableToArray(arr) || TextToSpeechUtils_unsupportedIterableToArray(arr) || TextToSpeechUtils_nonIterableSpread(); }\n\nfunction TextToSpeechUtils_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction TextToSpeechUtils_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction TextToSpeechUtils_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return TextToSpeechUtils_arrayLikeToArray(arr); }\n\nfunction TextToSpeechUtils_slicedToArray(arr, i) { return TextToSpeechUtils_arrayWithHoles(arr) || TextToSpeechUtils_iterableToArrayLimit(arr, i) || TextToSpeechUtils_unsupportedIterableToArray(arr, i) || TextToSpeechUtils_nonIterableRest(); }\n\nfunction TextToSpeechUtils_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction TextToSpeechUtils_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return TextToSpeechUtils_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return TextToSpeechUtils_arrayLikeToArray(o, minLen); }\n\nfunction TextToSpeechUtils_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction TextToSpeechUtils_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction TextToSpeechUtils_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction TextToSpeechUtils_typeof(obj) { "@babel/helpers - typeof"; return TextToSpeechUtils_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, TextToSpeechUtils_typeof(obj); }\n\nfunction TextToSpeechUtils_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction TextToSpeechUtils_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction TextToSpeechUtils_createClass(Constructor, protoProps, staticProps) { if (protoProps) TextToSpeechUtils_defineProperties(Constructor.prototype, protoProps); if (staticProps) TextToSpeechUtils_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\r\n * A collection of useful text-to-speech functions.\r\n *\r\n * @hideconstructor\r\n */\n\nvar TextToSpeechUtils = /*#__PURE__*/function () {\n  function TextToSpeechUtils() {\n    TextToSpeechUtils_classCallCheck(this, TextToSpeechUtils);\n  }\n\n  TextToSpeechUtils_createClass(TextToSpeechUtils, null, [{\n    key: "autoGenerateSSMLMarks",\n    value:\n    /**\r\n     * Returns a new string with SSML marks inserted based on\r\n     * matches between the input string and the input map. The\r\n     * word matches are case-insensitive. Words within existing\r\n     * SSML tags will not be affected. Input text will be surrounded\r\n     * by <speak></speak> tags if needed.\r\n     *\r\n     * @param {string} text - Input string.\r\n     * @param {object} map - Input object that maps mark keys\r\n     * to arrays of words. Example:\r\n     *\r\n     *  {\r\n     *    \'mark:sad\' : [\'sad\', \'blue\', \'down\'],\r\n     *    \'mark:happy\' : [\'joy\', \'glad\', \'great\'],\r\n     *    \'mark:no\' : [\'no\', \'nah\', \'nay\', \'sure\']\r\n     *  }\r\n     * @param {Array.<string>} [randomMarks = []] - If there are sentences that don\'t\r\n     * match any words from the map object, marks from this array will be randomly\r\n     * chosen and inserted.\r\n     *\r\n     * @returns {string} - Updated input string.\r\n     */\n    function autoGenerateSSMLMarks(text, map) {\n      var _this = this;\n\n      var randomMarks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n      if (TextToSpeechUtils_typeof(map) !== \'object\' || map === null) {\n        throw new Error("Cannot generate SSML marks for text \\"".concat(text, "\\" because map is not an object."));\n      } // process the input map into an internal format\n\n\n      var internalMap = this._processInputMap(map);\n\n      var speakTags = [\'<speak>\', \'</speak>\'];\n      var ssmlMarkRegex = /<mark name=(?:"|\')(.*?)(?:"|\')\\/>/;\n      var ssmlTagRegex = /<[^>]*>/g; // Identify any existing SSML tags\n\n      var existingTags = [];\n      var result = ssmlTagRegex.exec(text);\n\n      while (result !== null) {\n        existingTags.push({\n          start: result.index,\n          end: result.index + result[0].length,\n          text: result[0]\n        });\n        result = ssmlTagRegex.exec(text);\n      }\n\n      var chunks = [];\n      var index = 0;\n      var ssmlMarkResult;\n      var duplicateMarkToCheck = [];\n      existingTags.forEach(function (existingTag) {\n        var substr = text.slice(index, existingTag.start);\n\n        if (substr !== \'\') {\n          // auto-mark non-tag text\n          chunks.push(_this._insertMarks(substr, internalMap, duplicateMarkToCheck));\n          duplicateMarkToCheck = [];\n        }\n\n        ssmlMarkResult = ssmlMarkRegex.exec(existingTag.text);\n\n        if (ssmlMarkResult !== null) {\n          var markText = ssmlMarkResult[1];\n          duplicateMarkToCheck.push(markText);\n        } else if (!speakTags.includes(existingTag.text)) {\n          chunks.push(existingTag.text);\n        } // advance the index\n\n\n        index = existingTag.end;\n      });\n      chunks.push(this._insertMarks(text.slice(index), internalMap, duplicateMarkToCheck));\n      var markedText = chunks.join(\'\');\n\n      if (randomMarks && randomMarks.length > 0) {\n        // add random marks to any unmarked sentences\n        markedText = this.addMarksToUnmarkedSentences(markedText, randomMarks);\n      }\n\n      return TextToSpeechUtils.validateText(markedText);\n    }\n    /**\r\n     * Returns a new string with a random SSML mark inserted at each sentence that\r\n     * does not already contain an SSML mark.\r\n     *\r\n     * @param {string} text - Input string.\r\n     * @param {Array.<string>} marks - Any array of random SSML marks to choose from\r\n     * when modifying the text.\r\n     *\r\n     * @returns {string}\r\n     */\n\n  }, {\n    key: "addMarksToUnmarkedSentences",\n    value: function addMarksToUnmarkedSentences(text, marks) {\n      if (!marks || marks.length === 0) return text;\n      var ssmlMarkRegex = /<mark name=(?:"|\')(.*?)(?:"|\')\\/>/g;\n      var ssmlTagRegex = /<[^>]*>/g; // Find the indices of any marks in the text\n\n      var markIndices = [];\n      var markResult = ssmlMarkRegex.exec(text);\n\n      while (markResult !== null) {\n        markIndices.push(markResult.index);\n        markResult = ssmlMarkRegex.exec(text);\n      } // Find all SSML tags in the text\n\n\n      var existingTags = [];\n      var ssmlResult = ssmlTagRegex.exec(text);\n\n      while (ssmlResult !== null) {\n        existingTags.push({\n          start: ssmlResult.index,\n          end: ssmlResult.index + ssmlResult[0].length,\n          text: ssmlResult[0]\n        });\n        ssmlResult = ssmlTagRegex.exec(text);\n      } // Create a copy of the text with all SSML marks replaces with whitespace\n\n\n      var cleanedText = text.slice();\n      existingTags.forEach(function (existingSsml) {\n        var whitespace = new Array(existingSsml.text.length + 1).join(\' \');\n        cleanedText = [cleanedText.slice(0, existingSsml.start), whitespace, cleanedText.slice(existingSsml.end)].join(\'\');\n      });\n\n      var sentenceEndIndices = this._getSentenceEnds(cleanedText); // Only insert random marks into sentences that don\'t already have any\n\n\n      var prevIndex = 0;\n      var targetIndices = sentenceEndIndices.filter(function (index) {\n        var containsMark = markIndices.findIndex(function (markIndex) {\n          return prevIndex <= markIndex && index > markIndex;\n        }) !== -1;\n        prevIndex = index;\n        return !containsMark;\n      });\n\n      var randomMarkedText = this._insertRandomMarksAt(text, targetIndices, marks);\n\n      return randomMarkedText;\n    }\n    /**\r\n     * Generate a version of given text that is enclosed by Polly ssml speak tags.\r\n     *\r\n     * @param {string} text - The text to validate.\r\n     *\r\n     * @returns {string} - Updated input string.\r\n     */\n\n  }, {\n    key: "validateText",\n    value: function validateText(text) {\n      if (!text) {\n        text = \'<speak></speak>\';\n      } else {\n        text = text.replace(/(^\\s*<\\s*speak\\s*)>\\s*|(^\\s*)/, \'<speak>\').replace(/(\\s*<\\s*\\/\\s*speak\\s*>\\s*$|\\s*$)/, \'</speak>\');\n      }\n\n      return text;\n    }\n    /**\r\n     * Parse an input string and insert SSML marks based on\r\n     * word matches in a map.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} text - Input string.\r\n     * @param {Array.<number>} [indices = []] - An array of indices in the text input\r\n     * where random marks should be inserted.\r\n     * @param {Array.<string>} [marks = []] - An array of mark strings to choose\r\n     * from when inserting random marks.\r\n     *\r\n     * @returns {string} - Updated input string.\r\n     */\n\n  }, {\n    key: "_insertRandomMarksAt",\n    value: function _insertRandomMarksAt(text) {\n      var indices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var marks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n      if (!marks || marks.length === 0 || !indices || indices.length === 0) {\n        return text;\n      }\n\n      var offset = 0;\n      indices.forEach(function (index) {\n        var randomMark = "<mark name=\'".concat(marks[core_Utils.getRandomInt(0, marks.length)], "\'/>");\n        text = [text.slice(0, index + offset), randomMark, text.slice(index + offset)].join(\'\');\n        offset += randomMark.length;\n      });\n      return text;\n    }\n    /**\r\n     * Parses a string of text and returns an array containing the indices\r\n     * of the last character in a sentence that is not in the following list:\r\n     *  (\'.\', \'?\', \'!\')\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} text - Text to process for end of sentence\r\n     * indices.\r\n     *\r\n     * @returns {Array.<number>} - Array of end of sentence indices.\r\n     */\n\n  }, {\n    key: "_getSentenceEnds",\n    value: function _getSentenceEnds(text) {\n      var sentenceRegex = /[^.!?]+[.!?]+/g;\n      var endSentenceRegex = /[.!?]+/;\n      var result = sentenceRegex.exec(text);\n      var sentenceEnds = [];\n\n      while (result !== null) {\n        // find the last non-punctuation character\n        var punctResult = endSentenceRegex.exec(result[0]);\n        sentenceEnds.push(result.index + result[0].length - punctResult[0].length);\n        result = sentenceRegex.exec(text);\n      }\n\n      return sentenceEnds;\n    }\n    /**\r\n     * Parse an input string and insert SSML marks based on\r\n     * word matches in a map.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} text - Input string.\r\n     * @param {Map} map - Mapping of words to mark values that\r\n     * will be inserted as the value for a mark\'s \'name\' attribute.\r\n     * @param {Array} duplicatesToCheck - A list of mark values to check for duplicate against the first word\r\n     *\r\n     * @returns {string} - Updated input string.\r\n     */\n\n  }, {\n    key: "_insertMarks",\n    value: function _insertMarks(text, map, duplicatesToCheck) {\n      if (text === \'\') return text;\n      var wordRegex = /\\w+|\\s+|[^\\s\\w]+/g;\n      var lowerCaseWord;\n      var checkDuplicate = true;\n      var markedWords = text.match(wordRegex).map(function (word) {\n        lowerCaseWord = word.toLowerCase();\n\n        if (map.has(lowerCaseWord)) {\n          var marks = map.get(lowerCaseWord).map(function (mark) {\n            if (checkDuplicate) {\n              checkDuplicate = false;\n              return duplicatesToCheck.includes(mark) ? \'\' : "<mark name=\'".concat(mark, "\'/>");\n            } else {\n              return "<mark name=\'".concat(mark, "\'/>");\n            }\n          });\n          return "".concat(marks.join(\'\')).concat(word);\n        } else {\n          checkDuplicate = false;\n          return word;\n        }\n      });\n      var existingMarks = duplicatesToCheck.map(function (mark) {\n        return "<mark name=\'".concat(mark, "\'/>");\n      });\n      return "".concat(existingMarks.join(\'\')).concat(markedWords.join(\'\'));\n    }\n    /**\r\n     * Processes an input object for mapping an array\r\n     * of words to specific mark keys. Converts the input\r\n     * map into a Map with a more efficient format for\r\n     * performing mark injection.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {object} map - Input object that maps mark keys\r\n     * to arrays of words.\r\n     *\r\n     * @returns {Map} - Map for internal use.\r\n     */\n\n  }, {\n    key: "_processInputMap",\n    value: function _processInputMap(map) {\n      var internalMap = new Map();\n      var list = [];\n      Object.entries(map).forEach(function (_ref) {\n        var _ref2 = TextToSpeechUtils_slicedToArray(_ref, 2),\n            key = _ref2[0],\n            value = _ref2[1];\n\n        if (!Array.isArray(value)) {\n          throw new Error("Cannot generate SSML marks from map \\"".concat(map, "\\" because value for key \'").concat(key, "\' is not an array."));\n        }\n\n        value.forEach(function (word) {\n          var lowerCaseWord = word.toLowerCase();\n          list = internalMap.get(lowerCaseWord);\n\n          if (list !== undefined && !list.includes(key)) {\n            internalMap.set(lowerCaseWord, [].concat(TextToSpeechUtils_toConsumableArray(list), [key]));\n          } else {\n            internalMap.set(lowerCaseWord, [key]);\n          }\n        });\n      });\n      return internalMap;\n    }\n  }]);\n\n  return TextToSpeechUtils;\n}();\n\n/* harmony default export */ const awspack_TextToSpeechUtils = (TextToSpeechUtils);\n;// CONCATENATED MODULE: ./src/core/awspack/AbstractSpeech.js\nfunction AbstractSpeech_toConsumableArray(arr) { return AbstractSpeech_arrayWithoutHoles(arr) || AbstractSpeech_iterableToArray(arr) || AbstractSpeech_unsupportedIterableToArray(arr) || AbstractSpeech_nonIterableSpread(); }\n\nfunction AbstractSpeech_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction AbstractSpeech_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return AbstractSpeech_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return AbstractSpeech_arrayLikeToArray(o, minLen); }\n\nfunction AbstractSpeech_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction AbstractSpeech_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return AbstractSpeech_arrayLikeToArray(arr); }\n\nfunction AbstractSpeech_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction AbstractSpeech_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AbstractSpeech_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AbstractSpeech_createClass(Constructor, protoProps, staticProps) { if (protoProps) AbstractSpeech_defineProperties(Constructor.prototype, protoProps); if (staticProps) AbstractSpeech_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\r\n * Class that can play back audio generated by AWS Polly and synchronized emit\r\n * speechmark messages.\r\n *\r\n * @abstract\r\n */\n\nvar AbstractSpeech = /*#__PURE__*/function () {\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {core/TextToSpeechFeature} speaker - The feature that owns the Speech and\r\n   * will emit speechmark messages.\r\n   * @param {string} text - The text of the speech.\r\n   * @param {Array.<Object>} [speechmarks=[]] - An array of speechmark objects representing\r\n   * the text and timing of the speech.\r\n   */\n  function AbstractSpeech(speaker, text) {\n    var speechmarks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n    AbstractSpeech_classCallCheck(this, AbstractSpeech);\n\n    this._speaker = speaker;\n    this._text = text;\n    this._speechmarks = speechmarks;\n    this._speechmarkOffset = 0;\n\n    this._reset();\n  }\n  /**\r\n   * Reset tracking properties.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {number} [currentTime=0] - Time to use for _startTime.\r\n   */\n\n\n  AbstractSpeech_createClass(AbstractSpeech, [{\n    key: "_reset",\n    value: function _reset() {\n      var currentTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      this._startTime = currentTime;\n      this._localTime = 0;\n      this._pauseTime = 0;\n      this._playing = false;\n      this._markIter = this._speechmarks.values();\n\n      var _this$_markIter$next = this._markIter.next(),\n          value = _this$_markIter$next.value,\n          done = _this$_markIter$next.done;\n\n      this._currentMark = value;\n      this._endTime = this._speechmarks.length ? this._speechmarks[this._speechmarks.length - 1].time : 0;\n      this._done = done;\n      this._promise = null;\n    }\n    /**\r\n     * Create a new promise that will stop playback and emit messages for this speech.\r\n     *\r\n     * @param {Function=} onFinish - Funciton to execute once the speech stops.\r\n     * @param {onError=} onError - Function to execute if the speech encounters an\r\n     * error.\r\n     * @param {Function=} onInterrupt - Function to execute if the speech is canceled.\r\n     *\r\n     * @returns {Deferred}\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_createPromise",\n    value: function _createPromise(onFinish, onError, onInterrupt) {\n      var _this = this;\n\n      var onResolve = function onResolve(value) {\n        _this._playing = false;\n\n        _this._speaker.emit(_this._speaker.constructor.EVENTS.stop, _this);\n\n        _this._speaker.constructor.emit(_this._speaker.constructor.EVENTS.stop, _this);\n\n        if (typeof onFinish === \'function\') {\n          onFinish(value);\n        }\n      };\n\n      var onReject = function onReject(e) {\n        _this._playing = false;\n\n        _this._speaker.emit(_this._speaker.constructor.EVENTS.stop, _this);\n\n        _this._speaker.constructor.emit(_this._speaker.constructor.EVENTS.stop, _this);\n\n        console.error("".concat(_this.constructor.name, " encountered an unexpected error: ").concat(e));\n\n        if (typeof onError === \'function\') {\n          onError(e);\n        }\n      };\n\n      var onCancel = function onCancel(value) {\n        _this._playing = false;\n\n        _this._speaker.emit(_this._speaker.constructor.EVENTS.interrupt, _this);\n\n        _this._speaker.constructor.emit(_this._speaker.constructor.EVENTS.interrupt, _this);\n\n        if (typeof onInterrupt === \'function\') {\n          onInterrupt(value);\n        }\n      };\n\n      this._promise = new core_Deferred(undefined, onResolve, onReject, onCancel);\n      return this._promise;\n    }\n    /**\r\n     * Return whether or not the speech has reached it\'s end.\r\n     *\r\n     * @private\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "_checkFinished",\n    value: function _checkFinished() {\n      return this._done && this._localTime >= this._endTime;\n    }\n    /**\r\n     * Gets the playback state of the audio.\r\n     *\r\n     * @readonly\r\n     * @type {boolean}\r\n     */\n\n  }, {\n    key: "playing",\n    get: function get() {\n      return this._playing;\n    }\n    /**\r\n     * Gets the text of the speech.\r\n     *\r\n     * @readonly\r\n     * @type {string}\r\n     */\n\n  }, {\n    key: "text",\n    get: function get() {\n      return this._text;\n    }\n    /**\r\n     * Gets a shallow copy of the speechmarks array for the speech.\r\n     *\r\n     * @readonly\r\n     * @type {Array.<Object>}\r\n     */\n\n  }, {\n    key: "speechmarks",\n    get: function get() {\n      return AbstractSpeech_toConsumableArray(this._speechmarks);\n    }\n    /**\r\n     * Gets and sets the number of seconds to offset speechmark emission.\r\n     * @type {number}\r\n     */\n\n  }, {\n    key: "speechmarkOffset",\n    get: function get() {\n      return this._speechmarkOffset / 1000;\n    },\n    set: function set(offset) {\n      this._speechmarkOffset = offset * 1000; // Store as milliseconds\n    }\n    /**\r\n     * Emit speechmark messages as they are encountered in sync with audio.\r\n     *\r\n     * @param {number} currentTime - Current global time when update was called.\r\n     */\n\n  }, {\n    key: "update",\n    value: function update(currentTime) {\n      if (!this._playing) {\n        return;\n      } // Update local audio time\n\n\n      this._localTime = currentTime - this._startTime;\n\n      if (!this._done) {\n        // Emit speechmark messages for marks up to the current time\n        while (!this._done && this._currentMark.time + this._speechmarkOffset <= this._localTime) {\n          this._speaker.emit(this._speaker.constructor.EVENTS[this._currentMark.type], {\n            speech: this,\n            mark: this._currentMark\n          });\n\n          var _this$_markIter$next2 = this._markIter.next(),\n              value = _this$_markIter$next2.value,\n              done = _this$_markIter$next2.done;\n\n          this._currentMark = value;\n          this._done = done;\n        }\n      } // End playback\n\n\n      if (this._checkFinished()) {\n        this.stop();\n\n        this._reset();\n      }\n    }\n    /**\r\n     * Play the speech from the beginning.\r\n     *\r\n     * @param {number} currentTime - Current global time when play was called.\r\n     * @param {Function=} onFinish - Optional function to execute once the speech\r\n     * promise resolves.\r\n     * @param {Function=} onError - Optional function to execute if the speech\r\n     * encounters and error during playback.\r\n     * @param {Function=} onInterrupt - Optional function to execute if the speech\r\n     * is canceled.\r\n     *\r\n     * @returns {Deferred} Resolves once the speech reaches the end of playback.\r\n     */\n\n  }, {\n    key: "play",\n    value: function play(currentTime, onFinish, onError, onInterrupt) {\n      this._reset(currentTime);\n\n      this._playing = true;\n\n      this._speaker.emit(this._speaker.constructor.EVENTS.play, this);\n\n      this._speaker.constructor.emit(this._speaker.constructor.EVENTS.play, this);\n\n      return this._createPromise(onFinish, onError, onInterrupt);\n    }\n    /**\r\n     * Pause the speech at the current time.\r\n     *\r\n     * @param {number} currentTime - Current global time when pause was called.\r\n     */\n\n  }, {\n    key: "pause",\n    value: function pause(currentTime) {\n      this._playing = false;\n      this._pauseTime = currentTime;\n\n      this._speaker.emit(this._speaker.constructor.EVENTS.pause, this);\n\n      this._speaker.constructor.emit(this._speaker.constructor.EVENTS.pause, this);\n    }\n    /**\r\n     * Resume the speech at the current time.\r\n     *\r\n     * @param {number} currentTime - Current global time when resume was called.\r\n     * @param {Function=} onFinish - Optional function to execute once the speech\r\n     * promise resolves.\r\n     * @param {Function=} onError - Optional function to execute if the speech\r\n     * encounters and error during playback.\r\n     * @param {Function=} onInterrupt - Optional function to execute if the speech\r\n     * is canceled.\r\n     *\r\n     * @returns {Deferred} Resolves once the speech reaches the end of playback.\r\n     */\n\n  }, {\n    key: "resume",\n    value: function resume(currentTime, onFinish, onError, onInterrupt) {\n      // Play from the beginning if the speech hasn\'t played yet\n      if (!this._promise) {\n        this._reset(currentTime);\n\n        this._createPromise(onFinish, onError, onInterrupt);\n      }\n\n      this._playing = true;\n      this._startTime += currentTime - this._pauseTime;\n\n      this._speaker.emit(this._speaker.constructor.EVENTS.resume, this);\n\n      this._speaker.constructor.emit(this._speaker.constructor.EVENTS.resume, this);\n\n      return this._promise;\n    }\n    /**\r\n     * Cancels playback of the speech at the current time. Cancel the speech promise.\r\n     */\n\n  }, {\n    key: "cancel",\n    value: function cancel() {\n      if (this._promise) {\n        this._promise.cancel();\n\n        this._promise = null;\n      }\n\n      this._playing = false;\n    }\n    /**\r\n     * Stop the speech and reset time to the beginning. Resolve the speech promise.\r\n     */\n\n  }, {\n    key: "stop",\n    value: function stop() {\n      if (this._promise) {\n        this._promise.resolve();\n\n        this._promise = null;\n      }\n\n      this._playing = false;\n    }\n  }]);\n\n  return AbstractSpeech;\n}();\n\n/* harmony default export */ const awspack_AbstractSpeech = (AbstractSpeech);\n;// CONCATENATED MODULE: ./src/core/awspack/Speech.js\nfunction Speech_typeof(obj) { "@babel/helpers - typeof"; return Speech_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, Speech_typeof(obj); }\n\nfunction Speech_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Speech_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Speech_createClass(Constructor, protoProps, staticProps) { if (protoProps) Speech_defineProperties(Constructor.prototype, protoProps); if (staticProps) Speech_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction Speech_get() { if (typeof Reflect !== "undefined" && Reflect.get) { Speech_get = Reflect.get; } else { Speech_get = function _get(target, property, receiver) { var base = Speech_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return Speech_get.apply(this, arguments); }\n\nfunction Speech_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Speech_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Speech_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) Speech_setPrototypeOf(subClass, superClass); }\n\nfunction Speech_setPrototypeOf(o, p) { Speech_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Speech_setPrototypeOf(o, p); }\n\nfunction Speech_createSuper(Derived) { var hasNativeReflectConstruct = Speech_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Speech_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Speech_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Speech_possibleConstructorReturn(this, result); }; }\n\nfunction Speech_possibleConstructorReturn(self, call) { if (call && (Speech_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return Speech_assertThisInitialized(self); }\n\nfunction Speech_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Speech_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction Speech_getPrototypeOf(o) { Speech_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Speech_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\r\n * The built-in class for asynchronous Promises.\r\n * @external Audio\r\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLAudioElement/Audio\r\n */\n\n/**\r\n * @extends AbstractSpeech\r\n * @alias core/Speech\r\n */\n\nvar Speech = /*#__PURE__*/function (_AbstractSpeech) {\n  Speech_inherits(Speech, _AbstractSpeech);\n\n  var _super = Speech_createSuper(Speech);\n\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {TextToSpeech} speaker - The owner of the Speech that will emit speechmark\r\n   * messages.\r\n   * @param {string} text - The text of the speech.\r\n   * @param {Array.<Object>} [speechmarks=[]] - An array of speechmark objects representing\r\n   * the text and timing of the speech.\r\n   * @param {Object} audioConfig - Object containing audio and url.\r\n   * @param {external:Audio} audioConfig.audio - Playable audio object.\r\n   */\n  function Speech(speaker, text) {\n    var _this;\n\n    var speechmarks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var audioConfig = arguments.length > 3 ? arguments[3] : undefined;\n\n    Speech_classCallCheck(this, Speech);\n\n    _this = _super.call(this, speaker, text, speechmarks);\n    _this._audio = audioConfig.audio; // Keep track of whether the audio has finished playing through\n\n    _this._audio.onended = function () {\n      _this._audioFinished = true;\n    };\n\n    _this._audioFinished = true;\n    return _this;\n  }\n\n  Speech_createClass(Speech, [{\n    key: "_checkFinished",\n    value: function _checkFinished() {\n      return this._audioFinished && Speech_get(Speech_getPrototypeOf(Speech.prototype), "_checkFinished", this).call(this);\n    }\n    /**\r\n     * Gets the playable audio for the speech.\r\n     *\r\n     * @readonly\r\n     * @type {external:Audio}\r\n     */\n\n  }, {\n    key: "audio",\n    get: function get() {\n      return this._audio;\n    }\n    /**\r\n     * Gets the audio volume for the speech.\r\n     *\r\n     * @type {number}\r\n     */\n\n  }, {\n    key: "volume",\n    get: function get() {\n      return this._audio.volume;\n    }\n    /**\r\n     * Sets the audio volume for the speech.\r\n     */\n    ,\n    set: function set(volume) {\n      this._audio.volume = volume;\n    }\n    /**\r\n     * Set the audio\'s current local time and play it.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_playAudio",\n    value: function _playAudio() {\n      var _this2 = this;\n\n      if (this._speechmarkOffset < 0) {\n        this._audio.currentTime = this._speechmarkOffset;\n        setTimeout(function () {\n          if (_this2._playing) {\n            _this2._audio.currentTime = (_this2._localTime + _this2._speechmarkOffset) / 1000;\n\n            _this2._audio.play();\n          }\n        }, -this._speechmarkOffset);\n      } else {\n        this._audio.currentTime = 0;\n\n        this._audio.play();\n      }\n    }\n    /**\r\n     * Pause the audio once it is playable.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_pauseAudio",\n    value: function _pauseAudio() {\n      var _this3 = this;\n\n      this._audio.play().then(function () {\n        if (!_this3._playing) {\n          _this3._audio.pause();\n        }\n      });\n    }\n  }, {\n    key: "play",\n    value: function play(currentTime, onFinish, onError, onInterrupt) {\n      this._audioFinished = false;\n\n      this._playAudio();\n\n      return Speech_get(Speech_getPrototypeOf(Speech.prototype), "play", this).call(this, currentTime, onFinish, onError, onInterrupt);\n    }\n  }, {\n    key: "pause",\n    value: function pause(currentTime) {\n      this._pauseAudio();\n\n      Speech_get(Speech_getPrototypeOf(Speech.prototype), "pause", this).call(this, currentTime);\n    }\n  }, {\n    key: "resume",\n    value: function resume(currentTime, onFinish, onError, onInterrupt) {\n      this._audioFinished = false;\n\n      this._audio.play();\n\n      return Speech_get(Speech_getPrototypeOf(Speech.prototype), "resume", this).call(this, currentTime, onFinish, onError, onInterrupt);\n    }\n  }, {\n    key: "cancel",\n    value: function cancel() {\n      this._pauseAudio();\n\n      Speech_get(Speech_getPrototypeOf(Speech.prototype), "cancel", this).call(this);\n    }\n  }, {\n    key: "stop",\n    value: function stop() {\n      this._pauseAudio();\n\n      this._audio.currentTime = 0;\n\n      Speech_get(Speech_getPrototypeOf(Speech.prototype), "stop", this).call(this);\n    }\n  }]);\n\n  return Speech;\n}(awspack_AbstractSpeech);\n\n/* harmony default export */ const awspack_Speech = (Speech);\n;// CONCATENATED MODULE: ./src/core/awspack/AbstractTextToSpeechFeature.js\nfunction AbstractTextToSpeechFeature_typeof(obj) { "@babel/helpers - typeof"; return AbstractTextToSpeechFeature_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, AbstractTextToSpeechFeature_typeof(obj); }\n\nfunction AbstractTextToSpeechFeature_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction AbstractTextToSpeechFeature_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? AbstractTextToSpeechFeature_ownKeys(Object(source), !0).forEach(function (key) { AbstractTextToSpeechFeature_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : AbstractTextToSpeechFeature_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction AbstractTextToSpeechFeature_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction AbstractTextToSpeechFeature_slicedToArray(arr, i) { return AbstractTextToSpeechFeature_arrayWithHoles(arr) || AbstractTextToSpeechFeature_iterableToArrayLimit(arr, i) || AbstractTextToSpeechFeature_unsupportedIterableToArray(arr, i) || AbstractTextToSpeechFeature_nonIterableRest(); }\n\nfunction AbstractTextToSpeechFeature_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction AbstractTextToSpeechFeature_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction AbstractTextToSpeechFeature_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction AbstractTextToSpeechFeature_toConsumableArray(arr) { return AbstractTextToSpeechFeature_arrayWithoutHoles(arr) || AbstractTextToSpeechFeature_iterableToArray(arr) || AbstractTextToSpeechFeature_unsupportedIterableToArray(arr) || AbstractTextToSpeechFeature_nonIterableSpread(); }\n\nfunction AbstractTextToSpeechFeature_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction AbstractTextToSpeechFeature_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return AbstractTextToSpeechFeature_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return AbstractTextToSpeechFeature_arrayLikeToArray(o, minLen); }\n\nfunction AbstractTextToSpeechFeature_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction AbstractTextToSpeechFeature_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return AbstractTextToSpeechFeature_arrayLikeToArray(arr); }\n\nfunction AbstractTextToSpeechFeature_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction AbstractTextToSpeechFeature_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AbstractTextToSpeechFeature_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AbstractTextToSpeechFeature_createClass(Constructor, protoProps, staticProps) { if (protoProps) AbstractTextToSpeechFeature_defineProperties(Constructor.prototype, protoProps); if (staticProps) AbstractTextToSpeechFeature_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction AbstractTextToSpeechFeature_get() { if (typeof Reflect !== "undefined" && Reflect.get) { AbstractTextToSpeechFeature_get = Reflect.get; } else { AbstractTextToSpeechFeature_get = function _get(target, property, receiver) { var base = AbstractTextToSpeechFeature_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return AbstractTextToSpeechFeature_get.apply(this, arguments); }\n\nfunction AbstractTextToSpeechFeature_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = AbstractTextToSpeechFeature_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction AbstractTextToSpeechFeature_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) AbstractTextToSpeechFeature_setPrototypeOf(subClass, superClass); }\n\nfunction AbstractTextToSpeechFeature_setPrototypeOf(o, p) { AbstractTextToSpeechFeature_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return AbstractTextToSpeechFeature_setPrototypeOf(o, p); }\n\nfunction AbstractTextToSpeechFeature_createSuper(Derived) { var hasNativeReflectConstruct = AbstractTextToSpeechFeature_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = AbstractTextToSpeechFeature_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = AbstractTextToSpeechFeature_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return AbstractTextToSpeechFeature_possibleConstructorReturn(this, result); }; }\n\nfunction AbstractTextToSpeechFeature_possibleConstructorReturn(self, call) { if (call && (AbstractTextToSpeechFeature_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return AbstractTextToSpeechFeature_assertThisInitialized(self); }\n\nfunction AbstractTextToSpeechFeature_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction AbstractTextToSpeechFeature_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction AbstractTextToSpeechFeature_getPrototypeOf(o) { AbstractTextToSpeechFeature_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return AbstractTextToSpeechFeature_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n\n\n/**\r\n * The Amazon Polly service object.\r\n * @external Polly\r\n * @see https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/Polly.html\r\n */\n\n/**\r\n * The presigner object that can be used to generate presigned urls for the Polly service.\r\n * @external Presigner\r\n * @see https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/Polly/Presigner.html\r\n */\n// Available options for Polly\n\nvar engines = [\'standard\', \'neural\'];\nvar audioFormats = [\'mp3\', \'ogg_vorbis\', \'pcm\'];\nvar speechmarkTypes = [\'sentence\', \'ssml\', \'viseme\', \'word\'];\nvar sampleRates = {\n  mp3: {\n    rates: [\'8000\', \'16000\', \'22050\', \'24000\'],\n    defaults: {\n      standard: \'2050\',\n      neural: \'2400\'\n    }\n  },\n  pcm: {\n    rates: [\'8000\', \'16000\'],\n    defaults: {\n      standard: \'1600\',\n      neural: \'1600\'\n    }\n  }\n};\nsampleRates.ogg_vorbis = sampleRates.mp3;\nvar awsVersion;\n/**\r\n * Base class for turning text input into playable audio. There should be one instance\r\n * per speaker, each instance can play only one piece of text at a time.\r\n *\r\n * @extends AbstractHostFeature\r\n * @abstract\r\n *\r\n * @property {(number|undefined)} AWS_VERSION - Gets the version of AWS SDK being\r\n * used. Will be undefined until [initializeService]{@link AbstractTextToSpeechFeature.initializeService}\r\n * has been successfully executed.\r\n * @property {string} [POLLY_MIN_NEURAL_VERSION=\'2.503\'] - Gets the minimum version\r\n * of the AWS SDK that is necessary to use neural voices with AWS Polly.\r\n * @property {Object} POLLY_DEFAULTS - Default values to use with calls to {@link external:Polly}.\r\n * @property {string} [POLLY_DEFAULTS.Engine=\'standard\']\r\n * @property {Array.<string>} [POLLY_DEFAULTS.LexiconNames=[]]\r\n * @property {string} [POLLY_DEFAULTS.OutputFormat=\'mp3\']\r\n * @property {string} [POLLY_DEFAULTS.SampleRate=\'22050\']\r\n * @property {string} [POLLY_DEFAULTS.Text=\'\']\r\n * @property {string} [POLLY_DEFAULTS.TextType=\'ssml\']\r\n * @property {string} [POLLY_DEFAULTS.VoiceId=\'Amy\']\r\n * @property {string} [POLLY_DEFAULTS.LanguageCode=\'en-GB\']\r\n * @property {string} [POLLY_DEFAULTS.LanguageName=\'British English\']\r\n * @property {Array.<string>} [POLLY_VOICES=[]] - An array of voices available in\r\n * Polly. Will be empty until [initializeService]{@link AbstractTextToSpeechFeature.initializeService}\r\n * has been successfully executed. See [Polly Documentation]{@link https://docs.aws.amazon.com/polly/latest/dg/voicelist.html}\r\n * for a full list of available voices.\r\n * @property {Object} [POLLY_LANGUAGES={}] - An object that maps language names\r\n * to language codes that are available in Polly. Will be empty until\r\n * [initializeService]{@link AbstractTextToSpeechFeature.initializeService}\r\n * has been successfully executed. See [Polly Documentation]{@link https://docs.aws.amazon.com/polly/latest/dg/SupportedLanguage.html}\r\n * for a full list of available languages and corresponding codes.\r\n * @property {Object} [POLLY_LANGUAGE_CODES={}] - An object that maps language codes\r\n * to language names that are available in Polly. Will be empty until\r\n * [initializeService]{@link AbstractTextToSpeechFeature.initializeService}\r\n * has been successfully executed. See [Polly Documentation]{@link https://docs.aws.amazon.com/polly/latest/dg/SupportedLanguage.html}\r\n * for a full list of available languages and corresponding codes.\r\n * @property {Object} EVENTS - Built-in messages that the feature emits. When the\r\n * feature is added to a {@link core/HostObject}, event names will be prefixed by the\r\n * name of the feature class + \'.\'.\r\n * @property {string} [EVENTS.ready=onReadyEvent] - Message that is emitted after\r\n * [initializeService]{@link AbstractTextToSpeechFeature.initializeService} has been\r\n * successfully executed.\r\n * @property {string} [EVENTS.play=onPlayEvent] - Message that is emitted after\r\n * each call to [play]{@link AbstractTextToSpeechFeature#play}. The speech that was played\r\n * is supplied as an argument to listener functions.\r\n * @property {string} [EVENTS.pause=onPauseEvent] - Message that is emitted after\r\n * each call to [pause]{@link AbstractTextToSpeechFeature#pause}. The speech that was paused\r\n * is supplied as an argument to listener functions.\r\n * @property {string} [EVENTS.resume=onResumeEvent] - Message that is emitted after\r\n * each call to [resume]{@link AbstractTextToSpeechFeature#resume}. The speech that was\r\n * resumed is supplied as an argument to listener functions.\r\n * @property {string} [EVENTS.interrupt=onInterruptEvent] - Message that is emitted\r\n * if there is a current speech in progress and [play]{@link AbstractTextToSpeechFeature#play}\r\n * or [resume]{@link AbstractTextToSpeechFeature#resume} are executed for a new speech.\r\n * The speech that was interrupted is supplied as an argument to listener functions.\r\n * @property {string} [EVENTS.stop=onStopEvent] - Message that is emitted after\r\n * each call to [stop]{@link AbstractTextToSpeechFeature#stop} and when a speech reaches\r\n * the end of playback. The speech that was stopped is supplied as an argument\r\n * to listener functions.\r\n * @property {string} [EVENTS.sentence=onSentenceEvent] - Message that is emitted\r\n * each time a sentence speechmark is encountered whose timestamp matches up with\r\n * the speech audio\'s current time. The sentence speechmark object is supplied as\r\n * an argument to listener functions.\r\n * @property {string} [EVENTS.word=onWordEvent] - Message that is emitted\r\n * each time a word speechmark is encountered whose timestamp matches up with\r\n * the speech audio\'s current time. The word speechmark object is supplied as\r\n * an argument to listener functions.\r\n * @property {string} [EVENTS.viseme=onVisemeEvent] - Message that is emitted\r\n * each time a viseme speechmark is encountered whose timestamp matches up with\r\n * the speech audio\'s current time. The viseme speechmark object is supplied as\r\n * an argument to listener functions.\r\n * @property {string} [EVENTS.ssml=onSsmlEvent] - Message that is emitted\r\n * each time a ssml speechmark is encountered whose timestamp matches up with\r\n * the speech audio\'s current time. The ssml speechmark object is supplied as\r\n * an argument to listener functions.\r\n * @property {Object} SERVICES - AWS services that are necessary for the feature\r\n * to function.\r\n * @property {external:Polly} SERVICES.polly - The Polly service that is used\r\n * to synthesize speechmarks. Will be undefined until [initializeService]{@link AbstractTextToSpeechFeature.initializeService}\r\n * has been successfully executed\r\n * @property {external:Presigner} SERVICES.presigner - The Polly Presigner\r\n * object that is used to synthesize speech audio. Will be undefined until\r\n * [initializeService]{@link AbstractTextToSpeechFeature.initializeService}\r\n * has been successfully executed.\r\n */\n\nvar AbstractTextToSpeechFeature = /*#__PURE__*/function (_AbstractHostFeature) {\n  AbstractTextToSpeechFeature_inherits(AbstractTextToSpeechFeature, _AbstractHostFeature);\n\n  var _super = AbstractTextToSpeechFeature_createSuper(AbstractTextToSpeechFeature);\n\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {core/HostObject} host - Host object managing the feature.\r\n   * @param {Object=} options - Options that will be sent to Polly for each speech.\r\n   * @param {string=} options.voice - The name of the Polly voice to use for all speech.\r\n   * @param {string=} options.engine - The name of the Polly engine to use for all speech.\r\n   * @param {string=} options.language - The name of the language to use for all speech.\r\n   * @param {audioFormat} [options.audioFormat=\'mp3\'] - The format to use for generated\r\n   * audio for all speeches.\r\n   * @param {string=} options.sampleRate - The sample rate for audio files for all\r\n   * speeches.\r\n   * @param {number} [options.speechmarkOffset=0] - Amount of time in seconds to\r\n   * offset speechmark event emission from the audio.\r\n   * @param {number} [options.minEndMarkDuration=.05] - The minimum amount of time\r\n   * in seconds that the last speechmark of each type in a speech can have its\r\n   * duration property set to.\r\n   * @param {number} [options.volume=1] - The default volume to play speech audio\r\n   * with.\r\n   * @param {boolean} [options.isGlobal=false] - Whether the audio source should default\r\n   * to global regardless of whether or not it is attached to an object.\r\n   */\n  function AbstractTextToSpeechFeature(host) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      voice: undefined,\n      engine: undefined,\n      language: undefined,\n      audioFormat: \'mp3\',\n      sampleRate: undefined,\n      speechmarkOffset: 0,\n      minEndMarkDuration: 0.05,\n      volume: 1,\n      isGlobal: false\n    };\n\n    AbstractTextToSpeechFeature_classCallCheck(this, AbstractTextToSpeechFeature);\n\n    _this = _super.call(this, host);\n    _this._speechCache = {};\n    _this._currentSpeech = null;\n    _this._currentPromise = null;\n    _this._isValidated = false;\n    _this.speechmarkOffset = Number.isNaN(Number(options.speechmarkOffset)) ? 0 : Number(options.speechmarkOffset);\n    _this.minEndMarkDuration = Number.isNaN(Number(options.minEndMarkDuration)) ? 0 : Number(options.minEndMarkDuration);\n    _this.volume = Number.isNaN(Number(options.volume)) ? 1 : Number(options.volume);\n    _this._isGlobal = options.isGlobal || false;\n    _this._promises = {\n      volume: core_Deferred.resolve()\n    };\n    _this._volumePaused = false; // Set default options for each speech\n\n    _this._voice = options.voice || _this.constructor.POLLY_DEFAULTS.VoiceId;\n    _this._language = options.language || _this.constructor.POLLY_DEFAULTS.LanguageName;\n    _this._engine = engines.includes(options.engine) ? options.engine : _this.constructor.POLLY_DEFAULTS.Engine;\n    _this._audioFormat = audioFormats.includes(options.audioFormat) ? options.audioFormat : _this.constructor.POLLY_DEFAULTS.OutputFormat;\n    _this._sampleRate = sampleRates[_this._audioFormat].rates.includes(options.sampleRate) ? options.sampleRate : _this.constructor.POLLY_DEFAULTS.SampleRate;\n    return _this;\n  }\n  /**\r\n   * Store Polly, Presigner and AWS SDK Version for use across all instances.\r\n   *\r\n   * @param {external:Polly} polly - Polly instance to use to generate speechmarks.\r\n   * @param {external:Presigner} presigner - Presigner instance to use to generate\r\n   * audio URLs.\r\n   * @param {string} version - Version of the AWS SDK to use to validate voice options.\r\n   */\n\n\n  AbstractTextToSpeechFeature_createClass(AbstractTextToSpeechFeature, [{\n    key: "currentSpeech",\n    get:\n    /**\r\n     * Gets the text of the currently playing speech.\r\n     *\r\n     * @readonly\r\n     * @type {string}\r\n     */\n    function get() {\n      if (this._currentSpeech) {\n        return this._currentSpeech.text;\n      } else {\n        return null;\n      }\n    }\n    /**\r\n     * Gets and sets the number of seconds to offset speechmark emission.\r\n     *\r\n     * @type {number}\r\n     */\n\n  }, {\n    key: "speechmarkOffset",\n    get: function get() {\n      return this._speechmarkOffset;\n    },\n    set: function set(offset) {\n      this._speechmarkOffset = offset;\n\n      if (this._currentSpeech) {\n        this._currentSpeech.speechmarkOffset = offset;\n      }\n    }\n    /**\r\n     * Gets and sets the The minimum amount of time in seconds that the last\r\n     * speechmark of each type in a speech can have its duration property set to.\r\n     *\r\n     * @type number\r\n     */\n\n  }, {\n    key: "minEndMarkDuration",\n    get: function get() {\n      return this._minEndMarkDuration / 1000;\n    },\n    set: function set(duration) {\n      this._minEndMarkDuration = duration * 1000;\n    }\n    /**\r\n     * Appends the Sumerian Hosts custom user-agent to a string if it is not\r\n     * already present.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} currentUserAgent - String to append to if needed.\r\n     *\r\n     * @returns {string}\r\n     */\n\n  }, {\n    key: "_validateEngine",\n    value:\n    /**\r\n     * Checks if a given engine type is compatible with the AWS SDK version. If it\r\n     * is, return the original value. Otherwise return a default.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} engine - The type of Polly voice engine to validate.\r\n     *\r\n     * @returns {string}\r\n     */\n    function _validateEngine(engine) {\n      // Default to the standard engine if neural is not available for this version\n      if (engine === undefined || this.constructor.AWS_VERSION < this.constructor.POLLY_MIN_NEURAL_VERSION) {\n        engine = this.constructor.POLLY_DEFAULTS.Engine;\n      }\n\n      return engine;\n    }\n    /**\r\n     * Checks if a given audio format type is compatible with Polly. If it is, return\r\n     * the original value. Otherwise return a default.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} engine - The type of Polly voice engine to validate.\r\n     *\r\n     * @returns {string}\r\n     */\n\n  }, {\n    key: "_validateFormat",\n    value: function _validateFormat(format) {\n      if (format === undefined || !audioFormats.includes(format)) {\n        format = this.constructor.POLLY_DEFAULTS.OutputFormat;\n      }\n\n      return format;\n    }\n    /**\r\n     * Checks if a given audio sampling rate is compatible with the current audio\r\n     * format. If it is, return the original value. Otherwise return a default.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} engine - The type of Polly voice engine to validate.\r\n     *\r\n     * @returns {string}\r\n     */\n\n  }, {\n    key: "_validateRate",\n    value: function _validateRate(rate) {\n      // Use default if specified sample rate is not valid for the audio format\n      if (rate === undefined || !sampleRates[this._audioFormat].rates.includes(rate)) {\n        rate = sampleRates[this._audioFormat].defaults[this._engine];\n      }\n\n      return rate;\n    }\n    /**\r\n     * Checks if a given Polly voice id is compatible with the current Polly engine.\r\n     * If it is, return the original value. Otherwise return a default.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} engine - The type of Polly voice engine to validate.\r\n     *\r\n     * @returns {string}\r\n     */\n\n  }, {\n    key: "_validateVoice",\n    value: function _validateVoice(voiceId) {\n      var voice = this.constructor.POLLY_VOICES.find(function (v) {\n        return v.Id === voiceId;\n      }); // Use the default voice if the voice isn\'t supported by the engine\n\n      if (voice === undefined || !voice.SupportedEngines.includes(this._engine)) {\n        voiceId = this.constructor.POLLY_DEFAULTS.VoiceId;\n      }\n\n      return voiceId;\n    }\n    /**\r\n     * Checks if a given Polly language is compatible with the current Polly voice.\r\n     * If it is, return the original value. Otherwise return a default.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} engine - The type of Polly voice engine to validate.\r\n     *\r\n     * @returns {string}\r\n     */\n\n  }, {\n    key: "_validateLanguage",\n    value: function _validateLanguage(language) {\n      var _this2 = this;\n\n      var voice = this.constructor.POLLY_VOICES.find(function (v) {\n        return v.Id === _this2._voice;\n      });\n      var languageCode = this.constructor.POLLY_LANGUAGES[language]; // Find the languages available for the current voice\n\n      var availableCodes = [voice.LanguageCode];\n\n      if (voice.AdditionalLanguageCodes) {\n        availableCodes.push.apply(availableCodes, AbstractTextToSpeechFeature_toConsumableArray(voice.AdditionalLanguageCodes));\n      } // If the current voice doesn\'t support the language, use its default\n\n\n      if (!availableCodes.includes(languageCode)) {\n        language = this.constructor.POLLY_LANGUAGE_CODES[voice.LanguageCode];\n      }\n\n      return language;\n    }\n    /**\r\n     * Validate the current Polly options to make sure they are compatible with each\r\n     * other.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_validate",\n    value: function _validate() {\n      // Validate speech parameters\n      this._engine = this._validateEngine(this._engine);\n      this._audioFormat = this._validateFormat(this._audioFormat);\n      this._sampleRate = this._validateRate(this._sampleRate);\n      this._voice = this._validateVoice(this._voice);\n      this._language = this._validateLanguage(this._language);\n      this._isValidated = true;\n    }\n    /**\r\n     * Return an object containing parameters compatible with Polly.synthesizeSpeech.\r\n     *\r\n     * @private\r\n     *\r\n     * @returns {Object}\r\n     */\n\n  }, {\n    key: "_getConfig",\n    value: function _getConfig() {\n      // Make sure parameters have been validated\n      if (this.constructor.isReady && !this._isValidated) {\n        this._validate();\n      } // Create a config object compatible with Polly\n\n\n      return {\n        Engine: this._engine,\n        OutputFormat: this._audioFormat,\n        SampleRate: this._sampleRate,\n        VoiceId: this._voice,\n        LanguageCode: this.constructor.POLLY_LANGUAGES[this._language]\n      };\n    }\n    /**\r\n     * Update Polly parameters with options from a given config. All stored speeches\r\n     * will be updated to use the new parameters, unless the speech text is contained\r\n     * in the \'skipSpeeches\' parameter.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {Object} config - Polly parameter options to overwrite.\r\n     * @param {Array.<string>} skipSpeeches - Text of any speeches that should not\r\n     * have parameters updated.\r\n     *\r\n     * @returns {Object}\r\n     */\n\n  }, {\n    key: "_updateConfig",\n    value: function _updateConfig(config) {\n      var _this3 = this;\n\n      var skipSpeeches = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n      var currentConfig = this._getConfig();\n\n      if (!config) {\n        return currentConfig;\n      }\n\n      this._isValidated = false;\n      var currentConfigStr = JSON.stringify(currentConfig); // Update options\n\n      if (config.Engine) {\n        this._engine = config.Engine;\n      }\n\n      if (config.audioFormat) {\n        this._audioFormat = config.audioFormat;\n      }\n\n      if (config.SampleRate) {\n        this._sampleRate = config.SampleRate;\n      }\n\n      if (config.VoiceId) {\n        this._voice = config.VoiceId;\n      }\n\n      if (config.Language) {\n        this._language = config.Language;\n      } // Validate the config\n\n\n      var validConfig = this._getConfig(); // Exit if nothing has changed\n\n\n      var configStr = JSON.stringify(validConfig);\n\n      if (currentConfigStr === configStr) {\n        this._isValidated = true;\n        return validConfig;\n      } // Update all cached configs\n\n\n      Object.entries(this._speechCache).forEach(function (_ref) {\n        var _ref2 = AbstractTextToSpeechFeature_slicedToArray(_ref, 2),\n            text = _ref2[0],\n            speech = _ref2[1];\n\n        // Check if this is a skipped speech\n        if (skipSpeeches.includes(text)) {\n          return;\n        }\n\n        var speechConfigStr = JSON.stringify(speech.config); // Update the speech with new parameters\n\n        if (speechConfigStr !== configStr) {\n          _this3._updateSpeech(text, validConfig);\n        }\n      });\n      return validConfig;\n    }\n    /**\r\n     * Update an existing speech, or add a new speech with new Polly parameters with\r\n     * options from a given config.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} text - The text of the speech to update.\r\n     * @param {Object} config - Polly parameter options to update.\r\n     * @param {boolean} [force=false] - Whether to force the speech to be updated\r\n     * if no parameters have changes.\r\n     *\r\n     * @returns {AbstractSpeech}\r\n     */\n\n  }, {\n    key: "_updateSpeech",\n    value: function _updateSpeech(text, config) {\n      var _this4 = this;\n\n      var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var speech = this._speechCache[text] || {}; // Exit if nothing has changed and force is false\n\n      if (!force && config !== undefined && speech.config && JSON.stringify(config) === JSON.stringify(speech.config)) {\n        return speech;\n      } // Create separate parameters for audio and speechmark generation\n\n\n      var audioParams = AbstractTextToSpeechFeature_objectSpread(AbstractTextToSpeechFeature_objectSpread({}, config), {}, {\n        Text: text,\n        TextType: \'ssml\'\n      });\n\n      var speechmarkParams = AbstractTextToSpeechFeature_objectSpread(AbstractTextToSpeechFeature_objectSpread({}, audioParams), {}, {\n        OutputFormat: \'json\',\n        SpeechMarkTypes: speechmarkTypes\n      }); // Generate audio and speechmarks\n\n\n      speech.config = config;\n      speech.promise = Promise.all([this._synthesizeSpeechmarks(speechmarkParams), this._synthesizeAudio(audioParams)]).then(function (results) {\n        return _this4._createSpeech.apply(_this4, [text].concat(AbstractTextToSpeechFeature_toConsumableArray(results)));\n      });\n      this._speechCache[text] = speech;\n      return speech;\n    }\n    /**\r\n     * Create a new Speech object for the speaker.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {TextToSpeech} speaker - The TextToSpeech instance that will own the speech.\r\n     * @param {string} text - Text of the speech.\r\n     * @param {Object} speechmarks - Speechmarks for the speech.\r\n     * @param {Object} audioConfig - Audio for the speech.\r\n     *\r\n     * @returns {AbstractSpeech}\r\n     */\n\n  }, {\n    key: "_createSpeech",\n    value: function _createSpeech(text, speechmarks, audioConfig) {\n      return new awspack_AbstractSpeech(this, text, speechmarks, audioConfig);\n    }\n    /**\r\n     * Create presigned URL of speech audio for the given speech text.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {Object} params - Parameters object compatible with Polly.synthesizeSpeech.\r\n     *\r\n     * @returns {Deferred} Resolves with an object containing the audio URL.\r\n     */\n\n  }, {\n    key: "_synthesizeAudio",\n    value: function _synthesizeAudio(params) {\n      var _this5 = this;\n\n      return new core_Deferred(function (resolve, reject) {\n        _this5.constructor.SERVICES.presigner.getSynthesizeSpeechUrl(params, function (error, url) {\n          if (!error) {\n            resolve({\n              url: url\n            });\n          } else {\n            reject(error);\n          }\n        });\n      });\n    }\n    /**\r\n     * Retrieves and parses speechmarks for the given speech text.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {Object} params - Parameters object compatible with Polly.synthesizeSpeech.\r\n     *\r\n     * @returns {Deferred} Resolves with an array of speechmark objects\r\n     */\n\n  }, {\n    key: "_synthesizeSpeechmarks",\n    value: function _synthesizeSpeechmarks(params) {\n      var _this6 = this;\n\n      return this.constructor.SERVICES.polly.synthesizeSpeech(params).promise().then(function (result) {\n        // Convert charcodes to string\n        var jsonString = JSON.stringify(result.AudioStream);\n        var json = JSON.parse(jsonString);\n        var dataStr = json.data.map(function (c) {\n          return String.fromCharCode(c);\n        }).join(\'\');\n        var markTypes = {\n          sentence: [],\n          word: [],\n          viseme: [],\n          ssml: []\n        };\n        var endMarkTypes = {\n          sentence: null,\n          word: null,\n          viseme: null,\n          ssml: null\n        }; // Split by enclosing {} to create speechmark objects\n\n        var speechMarks = AbstractTextToSpeechFeature_toConsumableArray(dataStr.matchAll(/\\{.*?\\}(?=\\n|$)/gm)).map(function (match) {\n          var mark = JSON.parse(match[0]); // Set the duration of the last speechmark stored matching this one\'s type\n\n          var numMarks = markTypes[mark.type].length;\n\n          if (numMarks > 0) {\n            var lastMark = markTypes[mark.type][numMarks - 1];\n            lastMark.duration = mark.time - lastMark.time;\n          }\n\n          markTypes[mark.type].push(mark);\n          endMarkTypes[mark.type] = mark;\n          return mark;\n        }); // Find the time of the latest speechmark\n\n\n        var endTimes = [];\n\n        if (endMarkTypes.sentence) {\n          endTimes.push(endMarkTypes.sentence.time);\n        }\n\n        if (endMarkTypes.word) {\n          endTimes.push(endMarkTypes.word.time);\n        }\n\n        if (endMarkTypes.viseme) {\n          endTimes.push(endMarkTypes.viseme.time);\n        }\n\n        if (endMarkTypes.ssml) {\n          endTimes.push(endMarkTypes.ssml.time);\n        }\n\n        var endTime = Math.max.apply(Math, endTimes); // Calculate duration for the ending speechMarks of each type\n\n        if (endMarkTypes.sentence) {\n          endMarkTypes.sentence.duration = Math.max(_this6._minEndMarkDuration, endTime - endMarkTypes.sentence.time);\n        }\n\n        if (endMarkTypes.word) {\n          endMarkTypes.word.duration = Math.max(_this6._minEndMarkDuration, endTime - endMarkTypes.word.time);\n        }\n\n        if (endMarkTypes.viseme) {\n          endMarkTypes.viseme.duration = Math.max(_this6._minEndMarkDuration, endTime - endMarkTypes.viseme.time);\n        }\n\n        if (endMarkTypes.ssml) {\n          endMarkTypes.ssml.duration = Math.max(_this6._minEndMarkDuration, endTime - endMarkTypes.ssml.time);\n        }\n\n        return speechMarks;\n      });\n    }\n    /**\r\n     * Returns a Speech object that has the given text.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} text - The text content of the Speech.\r\n     * @param {Object=} config - Options to update the Speech with.\r\n     *\r\n     * @returns {Deferred} Resolves with Speech or null;\r\n     */\n\n  }, {\n    key: "_getSpeech",\n    value: function _getSpeech(text, config) {\n      // Make sure AWS services exist\n      if (!this.constructor.isReady) {\n        var e = \'AWS services have not been initialized.\';\n        return core_Deferred.reject(e);\n      } // Make sure its possible to generate speeches\n\n\n      if (!text) {\n        var _e2 = \'Cannot play a speech with no text.\';\n        return core_Deferred.reject(_e2);\n      } // Update the speech with options\n\n\n      text = awspack_TextToSpeechUtils.validateText(text);\n      config = this._updateConfig(config, text);\n      return this._updateSpeech(text, config).promise;\n    }\n    /**\r\n     * Adds a namespace to the host with the name of the feature to contain properties\r\n     * and methods from the feature that users of the host need access to.\r\n     *\r\n     * @see TextToSpeechFeature\r\n     */\n\n  }, {\n    key: "installApi",\n    value: function installApi() {\n      var _this7 = this;\n\n      /**\r\n       * @inner\r\n       * @namespace TextToSpeechFeature\r\n       */\n      var api = AbstractTextToSpeechFeature_get(AbstractTextToSpeechFeature_getPrototypeOf(AbstractTextToSpeechFeature.prototype), "installApi", this).call(this);\n\n      Object.assign(api, {\n        /**\r\n         * @memberof TextToSpeechFeature\r\n         * @instance\r\n         * @method\r\n         * @see AbstractTextToSpeechFeature#play\r\n         */\n        play: this.play.bind(this),\n\n        /**\r\n         * @memberof TextToSpeechFeature\r\n         * @instance\r\n         * @method\r\n         * @see AbstractTextToSpeechFeature#pause\r\n         */\n        pause: this.pause.bind(this),\n\n        /**\r\n         * @memberof TextToSpeechFeature\r\n         * @instance\r\n         * @method\r\n         * @see AbstractTextToSpeechFeature#resume\r\n         */\n        resume: this.resume.bind(this),\n\n        /**\r\n         * @memberof TextToSpeechFeature\r\n         * @instance\r\n         * @method\r\n         * @see AbstractTextToSpeechFeature#stop\r\n         */\n        stop: this.stop.bind(this),\n\n        /**\r\n         * @memberof TextToSpeechFeature\r\n         * @instance\r\n         * @method\r\n         * @see AbstractTextToSpeechFeature#getVolume\r\n         */\n        getVolume: this.getVolume.bind(this),\n\n        /**\r\n         * @memberof TextToSpeechFeature\r\n         * @instance\r\n         * @method\r\n         * @see AbstractTextToSpeechFeature#setVolume\r\n         */\n        setVolume: this.setVolume.bind(this),\n\n        /**\r\n         * @memberof TextToSpeechFeature\r\n         * @instance\r\n         * @method\r\n         * @see AbstractTextToSpeechFeature#pauseVolume\r\n         */\n        pauseVolume: this.pauseVolume.bind(this),\n\n        /**\r\n         * @memberof TextToSpeechFeature\r\n         * @instance\r\n         * @method\r\n         * @see AbstractTextToSpeechFeature#resumeVolume\r\n         */\n        resumeVolume: this.resumeVolume.bind(this)\n      });\n      Object.defineProperties(api, {\n        /**\r\n         * @memberof TextToSpeechFeature\r\n         * @instance\r\n         * @see AbstractTextToSpeechFeature#speechmarkOffset\r\n         */\n        speechmarkOffset: {\n          get: function get() {\n            return _this7.speechmarkOffset;\n          },\n          set: function set(offset) {\n            _this7.speechmarkOffset = offset;\n          }\n        }\n      });\n      return api;\n    }\n    /**\r\n     * Gets and sets the volume used for all audio clips played by the speaker.\r\n     *\r\n     * @type {number}\r\n     */\n\n  }, {\n    key: "volume",\n    get: function get() {\n      return this._volume;\n    }\n    /**\r\n     * Gets whether or not the speaker\'s volume value is currently being tweened.\r\n     *\r\n     * @readonly\r\n     * @type {boolean}\r\n     */\n    ,\n    set: function set(volume) {\n      this._volume = core_MathUtils.clamp(volume);\n    }\n  }, {\n    key: "volumePending",\n    get: function get() {\n      return this._promises.volume && this._promises.volume.pending;\n    }\n    /**\r\n     * Gets the volume used for all audio clips played by the speaker.\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: "getVolume",\n    value: function getVolume() {\n      return this.volume;\n    }\n    /**\r\n     * Updates the volume used for all audio clips played by the speaker over time.\r\n     *\r\n     * @param {number} volume - Target volume value.\r\n     * @param {number} [seconds=0] - Amount of time it will take to reach the target\r\n     * volume.\r\n     * @param {Function=} easingFn - Easing function used for interpolation.\r\n     *\r\n     * @returns {Deferred}\r\n     */\n\n  }, {\n    key: "setVolume",\n    value: function setVolume(volume) {\n      var seconds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var easingFn = arguments.length > 2 ? arguments[2] : undefined;\n\n      if (this.volumePending) {\n        this._promises.volume.cancel();\n      }\n\n      volume = core_MathUtils.clamp(volume);\n      this._promises.volume = animpack_AnimationUtils.interpolateProperty(this, \'volume\', volume, {\n        seconds: seconds,\n        easingFn: easingFn\n      });\n      return this._promises.volume;\n    }\n    /**\r\n     * Pause interpolation happening on the speaker\'s volume property.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "pauseVolume",\n    value: function pauseVolume() {\n      this._volumePaused = true;\n      return this.volumePending;\n    }\n    /**\r\n     * Resume any interpolation happening on the speaker\'s volume property.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "resumeVolume",\n    value: function resumeVolume() {\n      this._volumePaused = false;\n      return this.volumePending;\n    }\n    /**\r\n     * Update the currently playing speech.\r\n     *\r\n     * @param {number} deltaTime - Time since the last update.\r\n     */\n\n  }, {\n    key: "update",\n    value: function update(deltaTime) {\n      if (!this._volumePaused) {\n        this._promises.volume.execute(deltaTime);\n      }\n\n      if (this._currentSpeech && this._currentSpeech.playing) {\n        this._currentSpeech.volume = this._volume;\n\n        this._currentSpeech.update(this._host.now);\n\n        AbstractTextToSpeechFeature_get(AbstractTextToSpeechFeature_getPrototypeOf(AbstractTextToSpeechFeature.prototype), "update", this).call(this, deltaTime);\n      }\n    }\n    /**\r\n     * Set the current speech to a new asset and update the speech\'s speechmark\r\n     * offset value to match that of the feature.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {AbstractSpeech} speech - Speech to set as current.\r\n     */\n\n  }, {\n    key: "_setCurrentSpeech",\n    value: function _setCurrentSpeech(speech) {\n      speech.speechmarkOffset = this._speechmarkOffset;\n      this._currentSpeech = speech;\n    }\n    /**\r\n     * Create a promise that will play/resume a speech with the given text after\r\n     * the audio context attempts to resume and speech audio is retrieved from Polly.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} text - The text of the new speech to play.\r\n     * @param {Object=} config - Optional parameters for the speech.\r\n     * @param {string} [playMethod = \'play\'] - Method to execute on the resulting\r\n     * Speech object. Valid options are \'play\' and \'resume\'.\r\n     */\n\n  }, {\n    key: "_startSpeech",\n    value: function _startSpeech(text, config) {\n      var _this8 = this;\n\n      var playMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \'play\';\n\n      // If no text is provided, try to use the current speech\n      if (text === undefined && playMethod === \'resume\' && this._currentSpeech) {\n        text = this._currentSpeech.text;\n      }\n\n      var currentPromise = this._currentPromise || {\n        play: new core_Deferred(undefined, function () {\n          currentPromise.speech.cancel();\n        }, function () {\n          currentPromise.speech.cancel();\n        }, function () {\n          currentPromise.speech.cancel();\n        }),\n        speech: new core_Deferred()\n      };\n      this._currentPromise = currentPromise;\n\n      this._getSpeech(text, config).then(function (speech) {\n        // Exit if the promise is no longer pending because of user interaction\n        if (!currentPromise.play.pending) {\n          return;\n        } else if (_this8._currentPromise !== currentPromise) {\n          // Cancel if another call to play has already been made\n          currentPromise.play.cancel();\n          return;\n        } // Reset current speech when the speech ends\n\n\n        var onFinish = function onFinish() {\n          _this8._currentSpeech = null;\n          _this8._currentPromise = null;\n        }; // Cancel the currently playing speech\n\n\n        if (_this8._currentSpeech && _this8._currentSpeech.playing) {\n          if (playMethod === \'play\') {\n            _this8._currentSpeech.cancel();\n          } else if (playMethod === \'resume\' && _this8._currentSpeech.audio !== speech.audio) {\n            _this8._currentSpeech.cancel();\n          }\n        }\n\n        _this8._setCurrentSpeech(speech); // Play the speech\n\n\n        currentPromise.speech = speech[playMethod](_this8._host.now, onFinish, onFinish, onFinish);\n        currentPromise.speech.then(function () {\n          if (currentPromise.speech.resolved) {\n            currentPromise.play.resolve();\n          } else {\n            currentPromise.play.cancel();\n          }\n        })["catch"](function (error) {\n          currentPromise.play.reject(error);\n        });\n      })["catch"](function (e) {\n        e = "Cannot ".concat(playMethod, " speech ").concat(text, " on host ").concat(_this8.host.id, ". ").concat(e);\n        currentPromise.play.reject(e);\n      });\n\n      return currentPromise.play;\n    }\n    /**\r\n     * Stop any speeches currently playing and play a new speech from the beginning.\r\n     *\r\n     * @param {string} text - The text of the new speech to play.\r\n     * @param {Object=} config - Optional parameters for the speech.\r\n     *\r\n     * @returns {Deferred}\r\n     */\n\n  }, {\n    key: "play",\n    value: function play(text, config) {\n      return this._startSpeech(text, config, \'play\');\n    }\n    /**\r\n     * If a speech is currently playing, pause it at the current time.\r\n     */\n\n  }, {\n    key: "pause",\n    value: function pause() {\n      if (this._currentSpeech && this._currentSpeech.playing) {\n        this._currentSpeech.pause(this._host.now);\n      } else {\n        console.warn("Cannot pause speech on host ".concat(this.host.id, ". No speech is currently playing"));\n      }\n    }\n    /**\r\n     * Stop any speeches currently playing and resume a new speech from the current\r\n     * time.\r\n     *\r\n     * @param {string=} text - The text of the new speech to play. If undefined and\r\n     * there is a current speech that is paused, the current speech will be resumed.\r\n     * @param {Object=} config - Optional parameters for the speech.\r\n     *\r\n     * @returns {Deferred}\r\n     */\n\n  }, {\n    key: "resume",\n    value: function resume(text, config) {\n      return this._startSpeech(text, config, \'resume\');\n    }\n    /**\r\n     * If a speech is currently playing, stop playback and reset time.\r\n     */\n\n  }, {\n    key: "stop",\n    value: function stop() {\n      if (this._currentSpeech && this._currentSpeech.playing) {\n        this._currentSpeech.stop();\n\n        this._currentSpeech = null;\n      } else {\n        console.warn("Cannot stop speech on host ".concat(this.host.id, ". No speech is currently playing."));\n      }\n    }\n  }, {\n    key: "discard",\n    value: function discard() {\n      if (this._currentSpeech && this._currentSpeech.playing) {\n        this._currentSpeech.stop();\n      }\n\n      delete this._speechCache;\n\n      AbstractTextToSpeechFeature_get(AbstractTextToSpeechFeature_getPrototypeOf(AbstractTextToSpeechFeature.prototype), "discard", this).call(this);\n    }\n  }], [{\n    key: "initializeService",\n    value: function initializeService(polly, presigner, version) {\n      var _this9 = this;\n\n      // Make sure all were defined\n      if (polly === undefined || presigner === undefined || version === undefined) {\n        throw new Error(\'Cannot initialize TextToSpeech feature. All arguments must be defined.\');\n      } // Add sumerian hosts user-agent\n\n\n      if (polly.config) {\n        polly.config.customUserAgent = this._withCustomUserAgent(polly.config.customUserAgent);\n      }\n\n      if (presigner.service && presigner.service.config) {\n        presigner.service.config.customUserAgent = this._withCustomUserAgent(presigner.service.config.customUserAgent);\n      }\n\n      this._isReady = false; // Store parameters\n\n      this.SERVICES.polly = polly;\n      this.SERVICES.presigner = presigner;\n      awsVersion = version; // Clear the current polly objects\n\n      var availableVoices = this.POLLY_VOICES;\n      availableVoices.length = 0;\n      var availableLanguages = this.POLLY_LANGUAGES;\n      Object.keys(availableLanguages).forEach(function (name) {\n        delete availableLanguages[name];\n      });\n      var availableLanguageCodes = this.POLLY_LANGUAGE_CODES;\n      Object.keys(availableLanguageCodes).forEach(function (name) {\n        delete availableLanguageCodes[name];\n      }); // Re-populate according to version\n\n      var minNeuralSdk = this.POLLY_MIN_NEURAL_VERSION;\n      return this.SERVICES.polly.describeVoices().promise().then(function (response) {\n        var allCodes = {};\n        response.Voices.forEach(function (voice) {\n          if (voice.SupportedEngines.includes(\'standard\') || version >= minNeuralSdk) {\n            availableVoices.push(voice);\n          }\n\n          availableVoices.forEach(function (voice) {\n            availableLanguages[voice.LanguageName] = voice.LanguageCode;\n            allCodes[voice.LanguageCode] = voice.LanguageName;\n          });\n        });\n        Object.entries(availableLanguages).forEach(function (_ref3) {\n          var _ref4 = AbstractTextToSpeechFeature_slicedToArray(_ref3, 2),\n              name = _ref4[0],\n              code = _ref4[1];\n\n          availableLanguageCodes[code] = name;\n        }); // Notify that we\'re ready to generate speeches\n\n        _this9._isReady = true;\n\n        _this9.emit(_this9.EVENTS.ready);\n      });\n    }\n    /**\r\n     * Indicates whether or not the class is capable of generating speech audio. Polly,\r\n     * Presigner and AWS SDK version number must have been defined using\r\n     * [initializeService]{@link AbstractTextToSpeechFeature.initializeService}.\r\n     *\r\n     * @readonly\r\n     * @type {boolean}\r\n     */\n\n  }, {\n    key: "isReady",\n    get: function get() {\n      return this._isReady;\n    }\n  }, {\n    key: "_withCustomUserAgent",\n    value: function _withCustomUserAgent(currentUserAgent) {\n      var sumerianHostsUserAgent = \'request-source/SumerianHosts\';\n\n      if (currentUserAgent == null) {\n        return sumerianHostsUserAgent;\n      }\n\n      if (currentUserAgent.indexOf(sumerianHostsUserAgent) !== -1) {\n        return currentUserAgent;\n      }\n\n      return currentUserAgent.concat(\' \', sumerianHostsUserAgent);\n    }\n  }]);\n\n  return AbstractTextToSpeechFeature;\n}(core_AbstractHostFeature);\n\nObject.defineProperties(AbstractTextToSpeechFeature, {\n  AWS_VERSION: {\n    get: function get() {\n      return awsVersion;\n    }\n  },\n  POLLY_MIN_NEURAL_VERSION: {\n    value: \'2.503\',\n    writable: false\n  },\n  POLLY_DEFAULTS: {\n    value: {\n      Engine: \'standard\',\n      LexiconNames: [],\n      OutputFormat: \'mp3\',\n      SampleRate: \'22050\',\n      Text: \'\',\n      TextType: \'ssml\',\n      VoiceId: \'Amy\',\n      LanguageCode: \'en-GB\',\n      LanguageName: \'British English\'\n    },\n    writable: false\n  },\n  POLLY_VOICES: {\n    value: [],\n    writable: false\n  },\n  POLLY_LANGUAGES: {\n    value: {},\n    writable: false\n  },\n  POLLY_LANGUAGE_CODES: {\n    value: {},\n    writable: false\n  },\n  _isReady: {\n    value: false,\n    writable: true\n  },\n  EVENTS: {\n    value: AbstractTextToSpeechFeature_objectSpread(AbstractTextToSpeechFeature_objectSpread({}, Object.getPrototypeOf(AbstractTextToSpeechFeature).EVENTS), {}, {\n      ready: \'onReadyEvent\',\n      play: \'onPlayEvent\',\n      pause: \'onPauseEvent\',\n      resume: \'onResumeEvent\',\n      interrupt: \'onInterruptEvent\',\n      stop: \'onStopEvent\',\n      sentence: \'onSentenceEvent\',\n      word: \'onWordEvent\',\n      viseme: \'onVisemeEvent\',\n      ssml: \'onSsmlEvent\'\n    })\n  },\n  SERVICES: {\n    value: AbstractTextToSpeechFeature_objectSpread(AbstractTextToSpeechFeature_objectSpread({}, Object.getPrototypeOf(AbstractTextToSpeechFeature).SERVICES), {}, {\n      polly: undefined,\n      presigner: undefined\n    })\n  }\n});\n/* harmony default export */ const awspack_AbstractTextToSpeechFeature = (AbstractTextToSpeechFeature);\n;// CONCATENATED MODULE: ./src/core/awspack/TextToSpeechFeature.js\nfunction TextToSpeechFeature_typeof(obj) { "@babel/helpers - typeof"; return TextToSpeechFeature_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, TextToSpeechFeature_typeof(obj); }\n\nfunction TextToSpeechFeature_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction TextToSpeechFeature_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction TextToSpeechFeature_createClass(Constructor, protoProps, staticProps) { if (protoProps) TextToSpeechFeature_defineProperties(Constructor.prototype, protoProps); if (staticProps) TextToSpeechFeature_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction TextToSpeechFeature_get() { if (typeof Reflect !== "undefined" && Reflect.get) { TextToSpeechFeature_get = Reflect.get; } else { TextToSpeechFeature_get = function _get(target, property, receiver) { var base = TextToSpeechFeature_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return TextToSpeechFeature_get.apply(this, arguments); }\n\nfunction TextToSpeechFeature_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = TextToSpeechFeature_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction TextToSpeechFeature_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) TextToSpeechFeature_setPrototypeOf(subClass, superClass); }\n\nfunction TextToSpeechFeature_setPrototypeOf(o, p) { TextToSpeechFeature_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return TextToSpeechFeature_setPrototypeOf(o, p); }\n\nfunction TextToSpeechFeature_createSuper(Derived) { var hasNativeReflectConstruct = TextToSpeechFeature_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = TextToSpeechFeature_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = TextToSpeechFeature_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return TextToSpeechFeature_possibleConstructorReturn(this, result); }; }\n\nfunction TextToSpeechFeature_possibleConstructorReturn(self, call) { if (call && (TextToSpeechFeature_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return TextToSpeechFeature_assertThisInitialized(self); }\n\nfunction TextToSpeechFeature_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction TextToSpeechFeature_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction TextToSpeechFeature_getPrototypeOf(o) { TextToSpeechFeature_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return TextToSpeechFeature_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n/**\r\n * @extends AbstractTextToSpeechFeature\r\n * @alias core/TextToSpeechFeature\r\n */\n\nvar TextToSpeechFeature = /*#__PURE__*/function (_AbstractTextToSpeech) {\n  TextToSpeechFeature_inherits(TextToSpeechFeature, _AbstractTextToSpeech);\n\n  var _super = TextToSpeechFeature_createSuper(TextToSpeechFeature);\n\n  function TextToSpeechFeature() {\n    var _this;\n\n    TextToSpeechFeature_classCallCheck(this, TextToSpeechFeature);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this._enabled = false;\n\n    _this._setAudioContext();\n\n    _this._observeAudioContext();\n\n    return _this;\n  }\n  /**\r\n   * Store the audio context that will be used to ensure audio can be played.\r\n   *\r\n   * @private\r\n   */\n\n\n  TextToSpeechFeature_createClass(TextToSpeechFeature, [{\n    key: "_setAudioContext",\n    value: function _setAudioContext() {\n      this._audioContext = new AudioContext();\n    }\n    /**\r\n     * Listen for state changes on the audio context to determine whether the feature\r\n     * is enabled.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_observeAudioContext",\n    value: function _observeAudioContext() {\n      var _this2 = this;\n\n      if (this._audioContext) {\n        this._audioContext.onstatechange = function () {\n          if (_this2._audioContext.state === \'running\') {\n            _this2._enabled = true;\n          } else {\n            _this2._enabled = false;\n            console.warn(\'The audio context is not running. Speech will not be able to be played until it is resumed. Use the "TextToSpeechFeature.resumeAudio" method to try to resume it after a user gesture.\');\n          }\n        };\n\n        this._audioContext.onstatechange();\n      }\n    }\n    /**\r\n     * Create an Audio object of speech audio for the given speech text.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {Object} params - Parameters object compatible with Polly.synthesizeSpeech.\r\n     *\r\n     * @returns {Promise} Resolves with an object containing the audio URL and Audio\r\n     * object.\r\n     */\n\n  }, {\n    key: "_synthesizeAudio",\n    value: function _synthesizeAudio(params) {\n      var _this3 = this;\n\n      return TextToSpeechFeature_get(TextToSpeechFeature_getPrototypeOf(TextToSpeechFeature.prototype), "_synthesizeAudio", this).call(this, params).then(function (result) {\n        var url = result.url; // Create an Audio object that points to the presigned url\n\n        var audio = new Audio(url);\n        audio.loop = _this3.loop;\n        audio.crossOrigin = \'anonymous\';\n        audio.preload = \'auto\';\n        result.audio = audio;\n        return new Promise(function (resolve) {\n          // Resolve once the minimum amount is loaded\n          audio.addEventListener(\'canplaythrough\', function () {\n            resolve(result);\n          }); // Start loading the audio\n\n          document.body.appendChild(audio);\n          audio.load();\n        });\n      });\n    }\n    /**\r\n     * Create a new Speech object for the speaker.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {TextToSpeech} speaker - The TextToSpeech instance that will own the speech.\r\n     * @param {string} text - Text of the speech.\r\n     * @param {Object} speechmarks - Speechmarks for the speech.\r\n     * @param {Object} audioConfig - Audio for the speech.\r\n     *\r\n     * @returns {AbstractSpeech}\r\n     */\n\n  }, {\n    key: "_createSpeech",\n    value: function _createSpeech(text, speechmarks, audioConfig) {\n      return new awspack_Speech(this, text, speechmarks, audioConfig);\n    }\n    /**\r\n     * Gets whether or not the audio context is running and speech can be played.\r\n     *\r\n     * @readonly\r\n     * @type {boolean}\r\n     */\n\n  }, {\n    key: "enabled",\n    get: function get() {\n      return this._enabled;\n    }\n    /**\r\n     * Try to resume the audio context. This will be automatically executed each time\r\n     * speech is played or resumed. If using manually, it should be called after a\r\n     * user interaction occurs.\r\n     *\r\n     * @returns {Deferred} - Resolves once the audio context has resumed.\r\n     */\n\n  }, {\n    key: "resumeAudio",\n    value: function resumeAudio() {\n      var _this4 = this;\n\n      var promise = new core_Deferred(function (resolve, reject) {\n        _this4._audioContext.resume().then(function () {\n          _this4._enabled = true;\n          resolve();\n        })["catch"](function (e) {\n          _this4._enabled = false;\n          reject(e);\n        });\n      });\n      return promise;\n    }\n  }, {\n    key: "_startSpeech",\n    value: function _startSpeech(text, config) {\n      var _this5 = this;\n\n      var playMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \'play\';\n      var currentPromise = {\n        play: new core_Deferred(undefined, function () {\n          currentPromise.speech.cancel();\n        }, function () {\n          currentPromise.speech.cancel();\n        }, function () {\n          currentPromise.speech.cancel();\n        }),\n        speech: new core_Deferred()\n      };\n      this._currentPromise = currentPromise; // Try to start the audio context\n\n      this.resumeAudio().then(function () {\n        // Exit if the promise is no longer pending because of user interaction\n        if (!currentPromise.play.pending) {\n          return;\n        } // Cancel if another call to play has already been made\n        else if (_this5._currentPromise !== currentPromise) {\n          currentPromise.play.cancel();\n          return;\n        } // The audio context is running so the speech can be played\n\n\n        if (_this5._enabled) {\n          TextToSpeechFeature_get(TextToSpeechFeature_getPrototypeOf(TextToSpeechFeature.prototype), "_startSpeech", _this5).call(_this5, text, config, playMethod);\n        } // Reject if the audio context is not running\n        else {\n          currentPromise.reject(new Error("Cannot ".concat(playMethod, " speech on host ").concat(_this5._host.id, ". The audio context is not running. Use the \\"TextToSpeechFeature.resumeAudio\\" method to try to resume it after a user gesture.")));\n        }\n      });\n      return currentPromise.play;\n    }\n  }, {\n    key: "play",\n    value: function play(text, config) {\n      return this._startSpeech(text, config, \'play\');\n    }\n  }, {\n    key: "resume",\n    value: function resume(text, config) {\n      return this._startSpeech(text, config, \'resume\');\n    }\n  }, {\n    key: "installApi",\n    value: function installApi() {\n      var _this6 = this;\n\n      var api = TextToSpeechFeature_get(TextToSpeechFeature_getPrototypeOf(TextToSpeechFeature.prototype), "installApi", this).call(this);\n\n      Object.defineProperties(api, {\n        /**\r\n         * @memberof TextToSpeechFeature\r\n         * @instance\r\n         * @see core/TextToSpeechFeature#enabled\r\n         */\n        enabled: {\n          get: function get() {\n            return _this6._enabled;\n          }\n        }\n      });\n      return api;\n    }\n  }]);\n\n  return TextToSpeechFeature;\n}(awspack_AbstractTextToSpeechFeature);\n\n/* harmony default export */ const awspack_TextToSpeechFeature = (TextToSpeechFeature);\n;// CONCATENATED MODULE: ./src/core/awspack/index.js\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n\n/**\r\n * @module core/awspack\r\n */\n\n/* harmony default export */ const awspack = ({\n  /**\r\n   * @see core/AbstractTextToSpeechFeature\r\n   */\n  AbstractTextToSpeechFeature: awspack_AbstractTextToSpeechFeature,\n\n  /**\r\n   * @see core/TextToSpeechFeature\r\n   */\n  TextToSpeechFeature: awspack_TextToSpeechFeature,\n\n  /**\r\n   * @see core/TextToSpeechUtils\r\n   */\n  TextToSpeechUtils: awspack_TextToSpeechUtils,\n\n  /** \r\n   * @see core/AbstractSpeech\r\n   */\n  AbstractSpeech: awspack_AbstractSpeech,\n\n  /**\r\n   * @see core/Speech\r\n   */\n  Speech: awspack_Speech\n});\n;// CONCATENATED MODULE: ./src/core/index.js\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\r\n * @module core/HOST\r\n */\n\n\n\n\n\n\n\n\n\n\nvar core_Easing = animpack.Easing,\n    core_AnimationFeature = animpack.AnimationFeature,\n    core_AnimationTypes = animpack.AnimationTypes,\n    core_AnimationLayer = animpack.AnimationLayer,\n    core_LayerBlendModes = animpack.LayerBlendModes,\n    core_DefaultLayerBlendMode = animpack.DefaultLayerBlendMode,\n    core_SingleState = animpack.SingleState,\n    core_TransitionState = animpack.TransitionState,\n    core_FreeBlendState = animpack.FreeBlendState,\n    core_QueueState = animpack.QueueState,\n    core_RandomAnimationState = animpack.RandomAnimationState,\n    core_Blend1dState = animpack.Blend1dState,\n    core_Blend2dState = animpack.Blend2dState,\n    core_AnimationUtils = animpack.AnimationUtils;\n\nvar core_AbstractTextToSpeechFeature = awspack.AbstractTextToSpeechFeature,\n    core_TextToSpeechFeature = awspack.TextToSpeechFeature,\n    core_TextToSpeechUtils = awspack.TextToSpeechUtils,\n    core_AbstractSpeech = awspack.AbstractSpeech,\n    core_Speech = awspack.Speech;\n/* harmony default export */ const core = ({\n  /**\r\n   * @see env\r\n   */\n  env: env,\n\n  /**\r\n   * @see Utils\r\n   */\n  Utils: core_Utils,\n\n  /**\r\n   * @see MathUtils\r\n   */\n  MathUtils: core_MathUtils,\n\n  /**\r\n   * @see Deferred\r\n   */\n  Deferred: core_Deferred,\n\n  /**\r\n   * @see core/Messenger\r\n   */\n  Messenger: core_Messenger,\n\n  /**\r\n   * @see core/HostObject\r\n   */\n  HostObject: core_HostObject,\n\n  /**\r\n   * @see core/LipsyncFeature\r\n   */\n  LipsyncFeature: core_LipsyncFeature,\n\n  /**\r\n   * @see GestureFeature\r\n   */\n  GestureFeature: core_GestureFeature,\n\n  /**\r\n   * @see core/PointOfInterestFeature\r\n   */\n  PointOfInterestFeature: core_PointOfInterestFeature,\n\n  /**\r\n   * @see DefaultVisemeMap\r\n   */\n  DefaultVisemeMap: DefaultVisemeMap,\n\n  /**\r\n   * @see DefaultGestureWords\r\n   */\n  DefaultGestureWords: DefaultGestureWords,\n\n  /**\r\n   * @see AxisMap\r\n   */\n  AxisMap: AxisMap,\n\n  /**\r\n   * @see core/AnimationFeature\r\n   */\n  AnimationFeature: core_AnimationFeature,\n\n  /**\r\n   * @see AnimationLayer\r\n   */\n  AnimationLayer: core_AnimationLayer,\n\n  /**\r\n   * @see core/SingleState\r\n   */\n  SingleState: core_SingleState,\n\n  /**\r\n   * @see TransitionState\r\n   */\n  TransitionState: core_TransitionState,\n\n  /**\r\n   * @see FreeBlendState\r\n   */\n  FreeBlendState: core_FreeBlendState,\n\n  /**\r\n   * @see QueueState\r\n   */\n  QueueState: core_QueueState,\n\n  /**\r\n   * @see RandomAnimationState\r\n   */\n  RandomAnimationState: core_RandomAnimationState,\n\n  /**\r\n   * @see Blend1dState\r\n   */\n  Blend1dState: core_Blend1dState,\n\n  /**\r\n   * @see Blend2dState\r\n   */\n  Blend2dState: core_Blend2dState,\n\n  /**\r\n   * @see AnimationUtils\r\n   */\n  AnimationUtils: core_AnimationUtils,\n  Easing: core_Easing,\n\n  /**\r\n   * @see LayerBlendModes\r\n   */\n  LayerBlendModes: core_LayerBlendModes,\n\n  /**\r\n   * @see DefaultLayerBlendMode\r\n   */\n  DefaultLayerBlendMode: core_DefaultLayerBlendMode,\n\n  /**\r\n   * @see AnimationTypes\r\n   */\n  AnimationTypes: core_AnimationTypes,\n  // AWS Pack\n\n  /**\r\n  * @see core/AbstractTextToSpeechFeature\r\n  */\n  AbstractTextToSpeechFeature: core_AbstractTextToSpeechFeature,\n\n  /**\r\n   * @see core/TextToSpeechFeature\r\n   */\n  TextToSpeechFeature: core_TextToSpeechFeature,\n\n  /**\r\n   * @see core/TextToSpeechUtils\r\n   */\n  TextToSpeechUtils: core_TextToSpeechUtils,\n\n  /**\r\n   * @see core/AbstractSpeech\r\n   */\n  AbstractSpeech: core_AbstractSpeech,\n\n  /**\r\n   * @see core/Speech\r\n   */\n  Speech: core_Speech\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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VixFQUFBQSxNQUFNLEVBQU5BLFdBMUZhOztBQTJGWjtBQUNIO0FBQ0E7QUFDRXhNLEVBQUFBLGVBQWUsRUFBZkEsb0JBOUZhOztBQStGWjtBQUNIO0FBQ0E7QUFDRUcsRUFBQUEscUJBQXFCLEVBQXJCQSwwQkFsR2E7O0FBbUdaO0FBQ0g7QUFDQTtBQUNFMkIsRUFBQUEsY0FBYyxFQUFkQSxtQkF0R2E7QUF3R1o7O0FBQ0E7QUFDSDtBQUNBO0FBQ0UyUSxFQUFBQSwyQkFBMkIsRUFBM0JBLGdDQTVHYTs7QUE2R2I7QUFDRjtBQUNBO0FBQ0UzaUIsRUFBQUEsbUJBQW1CLEVBQW5CQSx3QkFoSGE7O0FBaUhiO0FBQ0Y7QUFDQTtBQUNFMmMsRUFBQUEsaUJBQWlCLEVBQWpCQSxzQkFwSGE7O0FBcUhiO0FBQ0Y7QUFDQTtBQUNFcUQsRUFBQUEsY0FBYyxFQUFkQSxtQkF4SGE7O0FBMEhiO0FBQ0Y7QUFDQTtBQUNHcUIsRUFBQUEsTUFBTSxFQUFOQSxXQUFNQTtBQTdITSxDQUFmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vSE9TVF9DT1JFLy4vc3JjL2NvcmUvRGVmZXJyZWQuanM/Njg4ZSIsIndlYnBhY2s6Ly9IT1NUX0NPUkUvLi9zcmMvY29yZS9VdGlscy5qcz9iZjI0Iiwid2VicGFjazovL0hPU1RfQ09SRS8uL3NyYy9jb3JlL01hdGhVdGlscy5qcz84MWU3Iiwid2VicGFjazovL0hPU1RfQ09SRS8uL3NyYy9jb3JlL0hvc3RFbnZpcm9ubWVudC5qcz8xNTFkIiwid2VicGFjazovL0hPU1RfQ09SRS8uL3NyYy9jb3JlL01lc3Nlbmdlci5qcz9kMDA2Iiwid2VicGFjazovL0hPU1RfQ09SRS8uL3NyYy9jb3JlL0Fic3RyYWN0SG9zdEZlYXR1cmUuanM/MjM2ZSIsIndlYnBhY2s6Ly9IT1NUX0NPUkUvLi9zcmMvY29yZS9Ib3N0T2JqZWN0LmpzPzc1ZTciLCJ3ZWJwYWNrOi8vSE9TVF9DT1JFLy4vc3JjL2NvcmUvYW5pbXBhY2svRWFzaW5nLmpzPzU4NmMiLCJ3ZWJwYWNrOi8vSE9TVF9DT1JFLy4vc3JjL2NvcmUvRmVhdHVyZURlcGVuZGVudEludGVyZmFjZS5qcz8wNmJiIiwid2VicGFjazovL0hPU1RfQ09SRS8uL3NyYy9jb3JlL2FuaW1wYWNrL0FuaW1hdGlvbkZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UuanM/NmU2MyIsIndlYnBhY2s6Ly9IT1NUX0NPUkUvLi9zcmMvY29yZS9hbmltcGFjay9NYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2UuanM/NDdkNSIsIndlYnBhY2s6Ly9IT1NUX0NPUkUvLi9zcmMvY29yZS9hd3NwYWNrL1RleHRUb1NwZWVjaEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UuanM/YmNhZCIsIndlYnBhY2s6Ly9IT1NUX0NPUkUvLi9zcmMvY29yZS9MaXBzeW5jRmVhdHVyZS5qcz84ZDNhIiwid2VicGFjazovL0hPU1RfQ09SRS8uL3NyYy9jb3JlL2F3c3BhY2svU1NNTFNwZWVjaG1hcmtJbnRlcmZhY2UuanM/Y2E3NCIsIndlYnBhY2s6Ly9IT1NUX0NPUkUvLi9zcmMvY29yZS9HZXN0dXJlRmVhdHVyZS5qcz9kYjM5Iiwid2VicGFjazovL0hPU1RfQ09SRS8uL3NyYy9jb3JlL2FuaW1wYWNrL0FuaW1hdGlvblV0aWxzLmpzPzExNDgiLCJ3ZWJwYWNrOi8vSE9TVF9DT1JFLy4vc3JjL2NvcmUvYW5pbXBhY2svc3RhdGUvQWJzdHJhY3RTdGF0ZS5qcz8yZjg3Iiwid2VicGFjazovL0hPU1RfQ09SRS8uL3NyYy9jb3JlL2FuaW1wYWNrL3N0YXRlL1RyYW5zaXRpb25TdGF0ZS5qcz85ZTc3Iiwid2VicGFjazovL0hPU1RfQ09SRS8uL3NyYy9jb3JlL2FuaW1wYWNrL0FuaW1hdGlvblBsYXllckludGVyZmFjZS5qcz83MzNlIiwid2VicGFjazovL0hPU1RfQ09SRS8uL3NyYy9jb3JlL2FuaW1wYWNrL3N0YXRlL1N0YXRlQ29udGFpbmVySW50ZXJmYWNlLmpzPzI2NTkiLCJ3ZWJwYWNrOi8vSE9TVF9DT1JFLy4vc3JjL2NvcmUvYW5pbXBhY2svc3RhdGUvUXVldWVTdGF0ZS5qcz8wYzRhIiwid2VicGFjazovL0hPU1RfQ09SRS8uL3NyYy9jb3JlL2FuaW1wYWNrL3N0YXRlL0Fic3RyYWN0QmxlbmRTdGF0ZS5qcz82Njk3Iiwid2VicGFjazovL0hPU1RfQ09SRS8uL3NyYy9jb3JlL2FuaW1wYWNrL3N0YXRlL0ZyZWVCbGVuZFN0YXRlLmpzP2Q2NzUiLCJ3ZWJwYWNrOi8vSE9TVF9DT1JFLy4vc3JjL2NvcmUvYW5pbXBhY2svc3RhdGUvQmxlbmQxZFN0YXRlLmpzP2E3NDIiLCJ3ZWJwYWNrOi8vSE9TVF9DT1JFLy4vc3JjL2NvcmUvYW5pbXBhY2svc3RhdGUvQmxlbmQyZFN0YXRlLmpzPzgxNjMiLCJ3ZWJwYWNrOi8vSE9TVF9DT1JFLy4vc3JjL2NvcmUvYW5pbXBhY2svQW5pbWF0aW9uTGF5ZXIuanM/YmVlYyIsIndlYnBhY2s6Ly9IT1NUX0NPUkUvLi9zcmMvY29yZS9hbmltcGFjay9zdGF0ZS9TaW5nbGVTdGF0ZS5qcz80ZjE0Iiwid2VicGFjazovL0hPU1RfQ09SRS8uL3NyYy9jb3JlL2FuaW1wYWNrL3N0YXRlL1JhbmRvbUFuaW1hdGlvblN0YXRlLmpzPzQ0OTMiLCJ3ZWJwYWNrOi8vSE9TVF9DT1JFLy4vc3JjL2NvcmUvYW5pbXBhY2svQW5pbWF0aW9uRmVhdHVyZS5qcz9lYmRlIiwid2VicGFjazovL0hPU1RfQ09SRS8uL3NyYy9jb3JlL1BvaW50T2ZJbnRlcmVzdEZlYXR1cmUuanM/ZGVlNSIsIndlYnBhY2s6Ly9IT1NUX0NPUkUvLi9zcmMvY29yZS9hbmltcGFjay9pbmRleC5qcz85YTEyIiwid2VicGFjazovL0hPU1RfQ09SRS8uL3NyYy9jb3JlL2F3c3BhY2svVGV4dFRvU3BlZWNoVXRpbHMuanM/NzU1ZCIsIndlYnBhY2s6Ly9IT1NUX0NPUkUvLi9zcmMvY29yZS9hd3NwYWNrL0Fic3RyYWN0U3BlZWNoLmpzPzdmMWMiLCJ3ZWJwYWNrOi8vSE9TVF9DT1JFLy4vc3JjL2NvcmUvYXdzcGFjay9TcGVlY2guanM/MmE0MSIsIndlYnBhY2s6Ly9IT1NUX0NPUkUvLi9zcmMvY29yZS9hd3NwYWNrL0Fic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZS5qcz8zNDFmIiwid2VicGFjazovL0hPU1RfQ09SRS8uL3NyYy9jb3JlL2F3c3BhY2svVGV4dFRvU3BlZWNoRmVhdHVyZS5qcz81YTg1Iiwid2VicGFjazovL0hPU1RfQ09SRS8uL3NyYy9jb3JlL2F3c3BhY2svaW5kZXguanM/M2FlMCIsIndlYnBhY2s6Ly9IT1NUX0NPUkUvLi9zcmMvY29yZS9pbmRleC5qcz9jN2IyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcclxuXHJcbi8qKlxyXG4gKiBUaGUgYnVpbHQtaW4gY2xhc3MgZm9yIGFzeW5jaHJvbm91cyBQcm9taXNlcy5cclxuICogQGV4dGVybmFsIFByb21pc2VcclxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm9taXNlXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEEgUHJvbWlzZSBvYmplY3QgdGhhdCBjYW4gYmUgcmVzb2x2ZWQsIHJlamVjdGVkIG9yIGNhbmNlbGVkIGF0IGFueSB0aW1lIGJ5IHRoZVxyXG4gKiB1c2VyLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBleHRlcm5hbDpQcm9taXNlXHJcbiAqL1xyXG5jbGFzcyBEZWZlcnJlZCBleHRlbmRzIFByb21pc2Uge1xyXG4gIC8qKlxyXG4gICAqIEBjb25zdHJ1Y3RvclxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2V4ZWN1dGFibGU9KCkgPT4ge31dIC0gVGhlIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGJ5IHRoZVxyXG4gICAqIGNvbnN0cnVjdG9yLCBkdXJpbmcgdGhlIHByb2Nlc3Mgb2YgY29uc3RydWN0aW5nIHRoZSBwcm9taXNlLiBUaGUgc2lnbmF0dXJlXHJcbiAgICogb2YgdGhpcyBpcyBleHBlY3RlZCB0byBiZTogZXhlY3V0YWJsZSggIHJlc29sdXRpb25GdW5jLCByZWplY3Rpb25GdW5jLCBjYW5jZWxsYXRpb25GdW5jICkuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uUmVzb2x2ZSAtIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb25jZSB0aGUgcHJvbWlzZVxyXG4gICAqIGlzIHJlc29sdmVkLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvblJlamVjdCAtIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb25jZSB0aGUgcHJvbWlzZVxyXG4gICAqIGlzIHJlamVjdGVkLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkNhbmNlbCAtIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgaWYgdGhlIHVzZXIgY2FuY2Vsc1xyXG4gICAqIHRoZSBwcm9taXNlLiBDYW5jZWxpbmcgcmVzdWx0cyBpbiB0aGUgcHJvbWlzZSBoYXZpbmcgYSBzdGF0dXMgb2YgJ3Jlc29sdmVkJy5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihleGVjdXRhYmxlID0gKCkgPT4ge30sIG9uUmVzb2x2ZSwgb25SZWplY3QsIG9uQ2FuY2VsKSB7XHJcbiAgICBpZiAodHlwZW9mIGV4ZWN1dGFibGUgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBDYW5ub3QgY3JlYXRlIG5ldyBEZWZlcnJlZC4gRXhlY3V0YWJsZSBtdXN0IGJlIGEgZnVuY3Rpb24uYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2Ygb25SZXNvbHZlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygb25SZXNvbHZlICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgQ2Fubm90IGNyZWF0ZSBuZXcgRGVmZXJyZWQuIE9uUmVzb2x2ZSBtdXN0IGJlIGEgZnVuY3Rpb24uYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2Ygb25SZWplY3QgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBvblJlamVjdCAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYENhbm5vdCBjcmVhdGUgbmV3IERlZmVycmVkLiBPblJlamVjdCBtdXN0IGJlIGEgZnVuY3Rpb24uYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2Ygb25DYW5jZWwgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBvbkNhbmNlbCAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYENhbm5vdCBjcmVhdGUgbmV3IERlZmVycmVkLiBPbkNhbmNlbCBtdXN0IGJlIGEgZnVuY3Rpb24uYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCByZXM7XHJcbiAgICBsZXQgcmVqO1xyXG4gICAgbGV0IGNhbmNlbDtcclxuICAgIGNvbnN0IHN0YXR1cyA9IHtcclxuICAgICAgcmVzb2x2ZWQ6IGZhbHNlLFxyXG4gICAgICByZWplY3RlZDogZmFsc2UsXHJcbiAgICAgIGNhbmNlbGVkOiBmYWxzZSxcclxuICAgICAgcGVuZGluZzogdHJ1ZSxcclxuICAgIH07XHJcblxyXG4gICAgc3VwZXIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAvLyBTdG9yZSB0aGUgcmVzb2x2ZXJcclxuICAgICAgcmVzID0gdmFsdWUgPT4ge1xyXG4gICAgICAgIGlmIChzdGF0dXMucGVuZGluZykge1xyXG4gICAgICAgICAgc3RhdHVzLnJlc29sdmVkID0gdHJ1ZTtcclxuICAgICAgICAgIHN0YXR1cy5wZW5kaW5nID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgaWYgKHR5cGVvZiBvblJlc29sdmUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBvblJlc29sdmUodmFsdWUpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiByZXNvbHZlKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBTdG9yZSB0aGUgcmVqZWN0ZXJcclxuICAgICAgcmVqID0gdmFsdWUgPT4ge1xyXG4gICAgICAgIGlmIChzdGF0dXMucGVuZGluZykge1xyXG4gICAgICAgICAgc3RhdHVzLnJlamVjdGVkID0gdHJ1ZTtcclxuICAgICAgICAgIHN0YXR1cy5wZW5kaW5nID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgaWYgKHR5cGVvZiBvblJlamVjdCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IG9uUmVqZWN0KHZhbHVlKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBTdG9yZSB0aGUgY2FuY2VsZXJcclxuICAgICAgY2FuY2VsID0gdmFsdWUgPT4ge1xyXG4gICAgICAgIGlmIChzdGF0dXMucGVuZGluZykge1xyXG4gICAgICAgICAgc3RhdHVzLmNhbmNlbGVkID0gdHJ1ZTtcclxuICAgICAgICAgIHN0YXR1cy5wZW5kaW5nID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgaWYgKHR5cGVvZiBvbkNhbmNlbCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IG9uQ2FuY2VsKHZhbHVlKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gUnVuIHRoZSBleGVjdXRhYmxlIHdpdGggY3VzdG9tIHJlc29sdmVyIGFuZCByZWplY3RlclxyXG4gICAgICBleGVjdXRhYmxlKHJlcywgcmVqLCBjYW5jZWwpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5fc3RhdHVzID0gc3RhdHVzO1xyXG4gICAgdGhpcy5fcmVzb2x2ZSA9IHJlcztcclxuICAgIHRoaXMuX3JlamVjdCA9IHJlajtcclxuICAgIHRoaXMuX2NhbmNlbCA9IGNhbmNlbDtcclxuICAgIHRoaXMuX2V4ZWN1dGFibGUgPSBleGVjdXRhYmxlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgcmVzb2x2ZWQgc3RhdGUgb2YgdGhlIHByb21pc2UuXHJcbiAgICpcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgcmVzb2x2ZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc3RhdHVzLnJlc29sdmVkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgcmVqZWN0ZWQgc3RhdGUgb2YgdGhlIHByb21pc2UuXHJcbiAgICpcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgcmVqZWN0ZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc3RhdHVzLnJlamVjdGVkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgY2FuY2VsZWQgc3RhdGUgb2YgdGhlIHByb21pc2UuXHJcbiAgICpcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgY2FuY2VsZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc3RhdHVzLmNhbmNlbGVkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgcGVuZGluZyBzdGF0ZSBvZiB0aGUgcHJvbWlzZS5cclxuICAgKlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBwZW5kaW5nKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0YXR1cy5wZW5kaW5nO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRm9yY2UgdGhlIHByb21pc2UgdG8gcmVzb2x2ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7YW55PX0gdmFsdWUgLSBWYWx1ZSB0byBwYXNzIHRvIHRoZSByZXNvbHZlci5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHthbnl9IC0gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcmVzb2x2ZXIgZnVuY3Rpb24uXHJcbiAgICovXHJcbiAgcmVzb2x2ZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmUodmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRm9yY2UgdGhlIHByb21pc2UgdG8gcmVqZWN0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHthbnk9fSB2YWx1ZSAtIFZhbHVlIHRvIHBhc3MgdG8gdGhlIHJlamVjdGVyLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge2FueX0gLSBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSByZWplY3RlciBmdW5jdGlvbi5cclxuICAgKi9cclxuICByZWplY3QodmFsdWUpIHtcclxuICAgIHJldHVybiB0aGlzLl9yZWplY3QodmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRm9yY2UgdGhlIHByb21pc2UgdG8gcmVzb2x2ZSBhbmQgc2V0IHRoZSBjYW5jZWxlZCBzdGF0ZSB0byB0cnVlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHthbnk9fSB2YWx1ZSAtIFZhbHVlIHRvIHBhc3MgdG8gdGhlIGNhbmNlbGxlci5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHthbnl9IC0gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgY2FuY2VsbGVyIGZ1bmN0aW9uLlxyXG4gICAqL1xyXG4gIGNhbmNlbCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2NhbmNlbCh2YWx1ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSdW4gdGhlIHByb21pc2UgZnVuY3Rpb24gdG8gdHJ5IHRvIHJlc29sdmUgdGhlIHByb21pc2UuIFByb21pc2UgbXVzdCBiZVxyXG4gICAqIHBlbmRpbmcuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gey4uLmFueX0gYXJncyAtIE9wdGlvbmFsIGFyZ3VtZW50cyB0byBwYXNzIGFmdGVyIHJlc29sdmUgYW5kIHJlamVjdC5cclxuICAgKi9cclxuICBleGVjdXRlKC4uLmFyZ3MpIHtcclxuICAgIGlmICh0aGlzLnBlbmRpbmcpIHtcclxuICAgICAgdGhpcy5fZXhlY3V0YWJsZSh0aGlzLl9yZXNvbHZlLCB0aGlzLl9yZWplY3QsIHRoaXMuX2NhbmNlbCwgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gYSBjYW5jZWxlZCBkZWZlcnJlZCBwcm9taXNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHthbnk9fSB2YWx1ZSAtIFZhbHVlIHRvIGNhbmNlbCB0aGUgcHJvbWlzZSB3aXRoLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0RlZmVycmVkfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBjYW5jZWwodmFsdWUpIHtcclxuICAgIHJldHVybiBuZXcgRGVmZXJyZWQoKF9yZXNvbHZlLCBfcmVqZWN0LCBjYW5jZWwpID0+IHtcclxuICAgICAgY2FuY2VsKHZhbHVlKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgbmV3IERlZmVycmVkIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgb3IgcmVqZWN0IG9uY2UgYWxsIHByb21pc2VzXHJcbiAgICogaW4gdGhlIGlucHV0IGFycmF5IGhhdmUgYmVlbiByZXNvbHZlZCBvciBvbmUgcHJvbWlzZSBpcyBjYW5jZWxlZCBvciByZWplY3RlZC5cclxuICAgKiBQcm9taXNlcyBpbiB0aGUgYXJyYXkgdGhhdCBhcmUgRGVmZXJyZWQgcHJvbWlzZXMgd2lsbCBiZSBtYW51YWxseSByZXNvbHZlZCxcclxuICAgKiByZWplY3RlZCBvciBjYW5jZWxlZCB3aGVuIGNhbGxpbmcgcmVzb2x2ZSwgcmVqZWN0IG9yIGNhbmNlbCBvbiB0aGUgcmV0dXJuIHByb21pc2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0FycmF5Ljxhbnk+fSBpdGVyYWJsZSAtIEFuIGl0ZXJhYmxlIHN1Y2ggYXMgYW4gYXJyYXkuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uUmVzb2x2ZSAtIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb25jZSB0aGUgcHJvbWlzZVxyXG4gICAqIGlzIHJlc29sdmVkLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvblJlamVjdCAtIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb25jZSB0aGUgcHJvbWlzZVxyXG4gICAqIGlzIHJlamVjdGVkLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkNhbmNlbCAtIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgaWYgdGhlIHVzZXIgY2FuY2Vsc1xyXG4gICAqIHRoZSBwcm9taXNlLiBDYW5jZWxpbmcgcmVzdWx0cyBpbiB0aGUgcHJvbWlzZSBoYXZpbmcgYSBzdGF0dXMgb2YgJ2NhbmNlbGVkJy5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIERlZmVycmVkXHJcbiAgICovXHJcbiAgc3RhdGljIGFsbChpdGVyYWJsZSwgb25SZXNvbHZlLCBvblJlamVjdCwgb25DYW5jZWwpIHtcclxuICAgIGlmIChpdGVyYWJsZSA9PSBudWxsIHx8IHR5cGVvZiBpdGVyYWJsZVtTeW1ib2wuaXRlcmF0b3JdICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIGxldCBlID0gYENhbm5vdCBleGVjdXRlIERlZmVycmVkLmFsbC4gRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBpdGVyYWJsZS5gO1xyXG5cclxuICAgICAgaWYgKHR5cGVvZiBvblJlamVjdCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGUgPSBvblJlamVjdChlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIERlZmVycmVkLnJlamVjdChlKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhcnJheSA9IFsuLi5pdGVyYWJsZV07XHJcbiAgICBjb25zdCBkZWZlcnJlZCA9IGFycmF5LmZpbHRlcihpdGVtID0+IGl0ZW0gaW5zdGFuY2VvZiBEZWZlcnJlZCk7XHJcblxyXG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IERlZmVycmVkKFxyXG4gICAgICB1bmRlZmluZWQsXHJcbiAgICAgIHJlc29sdmVWYWx1ZSA9PiB7XHJcbiAgICAgICAgZGVmZXJyZWQuZm9yRWFjaChpdGVtID0+IHtcclxuICAgICAgICAgIGl0ZW0ucmVzb2x2ZShyZXNvbHZlVmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGRlZmVycmVkLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb25SZXNvbHZlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICByZXR1cm4gb25SZXNvbHZlKHJlc29sdmVWYWx1ZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiByZXNvbHZlVmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBlcnJvciA9PiB7XHJcbiAgICAgICAgZGVmZXJyZWQuZm9yRWFjaChpdGVtID0+IHtcclxuICAgICAgICAgIGl0ZW0ucmVqZWN0KGVycm9yKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBkZWZlcnJlZC5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9uUmVqZWN0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICByZXR1cm4gb25SZWplY3QoZXJyb3IpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBjYW5jZWxWYWx1ZSA9PiB7XHJcbiAgICAgICAgZGVmZXJyZWQuZm9yRWFjaChpdGVtID0+IHtcclxuICAgICAgICAgIGl0ZW0uY2FuY2VsKGNhbmNlbFZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBkZWZlcnJlZC5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9uQ2FuY2VsID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICByZXR1cm4gb25DYW5jZWwoY2FuY2VsVmFsdWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gY2FuY2VsVmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IG51bUl0ZW1zID0gYXJyYXkubGVuZ3RoO1xyXG4gICAgY29uc3QgaXRlbVRyYWNrZXIgPSB7XHJcbiAgICAgIGZhaWxlZDogZmFsc2UsXHJcbiAgICAgIG51bVJlc29sdmVkOiAwLFxyXG4gICAgICByZXNvbHV0aW9uczogW11cclxuICAgIH1cclxuXHJcbiAgICBhcnJheS5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xyXG4gICAgICBpZiAoaXRlbVRyYWNrZXIuZmFpbGVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9IGVsc2UgaWYgKCEoaXRlbSBpbnN0YW5jZW9mIFByb21pc2UpKSB7XHJcbiAgICAgICAgaXRlbVRyYWNrZXIucmVzb2x1dGlvbnNbaW5kZXhdID0gaXRlbTtcclxuICAgICAgICBpdGVtVHJhY2tlci5udW1SZXNvbHZlZCArPSAxO1xyXG5cclxuICAgICAgICBpZiAoaXRlbVRyYWNrZXIubnVtUmVzb2x2ZWQgPT09IG51bUl0ZW1zKSB7XHJcbiAgICAgICAgICByZXN1bHQucmVzb2x2ZShpdGVtVHJhY2tlci5yZXNvbHV0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaXRlbS50aGVuKFxyXG4gICAgICAgIHZhbHVlID0+IHtcclxuICAgICAgICAgIGlmICghaXRlbVRyYWNrZXIuZmFpbGVkICYmICFpdGVtLmNhbmNlbGVkKSB7XHJcbiAgICAgICAgICAgIGl0ZW1UcmFja2VyLnJlc29sdXRpb25zW2luZGV4XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICBpdGVtVHJhY2tlci5udW1SZXNvbHZlZCArPSAxO1xyXG5cclxuICAgICAgICAgICAgaWYgKGl0ZW1UcmFja2VyLm51bVJlc29sdmVkID09PSBudW1JdGVtcykge1xyXG4gICAgICAgICAgICAgIHJlc3VsdC5yZXNvbHZlKGl0ZW1UcmFja2VyLnJlc29sdXRpb25zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIGlmICghaXRlbVRyYWNrZXIuZmFpbGVkKSB7XHJcbiAgICAgICAgICAgIGl0ZW1UcmFja2VyLmZhaWxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHJlc3VsdC5jYW5jZWwodmFsdWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXJyb3IgPT4ge1xyXG4gICAgICAgICAgaWYgKCFpdGVtVHJhY2tlci5mYWlsZWQpIHtcclxuICAgICAgICAgICAgaXRlbVRyYWNrZXIuZmFpbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmVzdWx0LnJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IERlZmVycmVkO1xyXG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXHJcbmltcG9ydCBEZWZlcnJlZCBmcm9tICdjb3JlL0RlZmVycmVkJztcclxuXHJcbi8qKlxyXG4gKiBBIGNvbGxlY3Rpb24gb2YgdXNlZnVsIGdlbmVyaWMgZnVuY3Rpb25zLlxyXG4gKlxyXG4gKiBAaGlkZWNvbnN0cnVjdG9yXHJcbiAqL1xyXG5jbGFzcyBVdGlscyB7XHJcbiAgLyoqXHJcbiAgICogQHN0YXRpY1xyXG4gICAqXHJcbiAgICogR2VuZXJhdGUgYSB1bmlxdWUgaWRcclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAgICovXHJcbiAgc3RhdGljIGNyZWF0ZUlkKCkge1xyXG4gICAgcmV0dXJuICd4eHh4eHh4eHh4eHg0eHh4eXh4eHh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBjID0+IHtcclxuICAgICAgY29uc3QgcmFuZG9tTnVtYmVyID0gTWF0aC5mbG9vcigoRGF0ZS5ub3coKSArIE1hdGgucmFuZG9tKCkgKiAxNikgJSAxNik7XHJcbiAgICAgIGlmIChjID09PSAneCcpIHtcclxuICAgICAgICByZXR1cm4gcmFuZG9tTnVtYmVyLnRvU3RyaW5nKDE2KTtcclxuICAgICAgfVxyXG4gICAgICAvLyBTZXQgYml0IDYgYW5kIDcgdG8gMCBhbmQgMVxyXG4gICAgICByZXR1cm4gKChyYW5kb21OdW1iZXIgJiAweDMpIHwgMHg4KS50b1N0cmluZygxNik7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBzdGF0aWNcclxuICAgKlxyXG4gICAqIENoZWNrIGEgbmFtZSBzdHJpbmcgYWdhaW5zdCBhbiBhcnJheSBvZiBzdHJpbmdzIHRvIGRldGVybWluZSBpZiBpdCBpcyB1bmlxdWUuXHJcbiAgICogSWYgaXQgaXNuJ3QsIGFwcGVuZCBpbmNyZW1lbnRlZCB0cmFpbGluZyBpbnRlZ2VycyB0byB0aGUgZW5kIG9mIHRoZSBuYW1lXHJcbiAgICogdW50aWwgaXQgaXMgdW5pcXVlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBTdHJpbmcgbmFtZSB0byBtYWtlIHVuaXF1ZS5cclxuICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+PX0gbmFtZUFycmF5IC0gQXJyYXkgb2Ygc3RyaW5nIG5hbWVzIHRvIGNoZWNrIGFnYWlucy5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICovXHJcbiAgc3RhdGljIGdldFVuaXF1ZU5hbWUobmFtZSwgbmFtZUFycmF5ID0gW10pIHtcclxuICAgIC8vIElmIHRoZSBuYW1lIGlzbid0IGluIHRoZSBhcnJheSByZXR1cm4gaXQgcmlnaHQgYXdheVxyXG4gICAgaWYgKCFuYW1lQXJyYXkuaW5jbHVkZXMobmFtZSkpIHtcclxuICAgICAgcmV0dXJuIG5hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbmFtZVNldCA9IG5ldyBTZXQobmFtZUFycmF5KTtcclxuXHJcbiAgICAvLyBTZXBhcmF0ZSB0aGUgbmFtZSBpbnRvIHN0cmluZyBhbmQgdHJhaWxpbmcgbnVtYmVyc1xyXG4gICAgY29uc3QgbWF0Y2hHcm91cCA9IG5hbWUubWF0Y2goL1xcZCokLyk7XHJcbiAgICBjb25zdCB7aW5kZXh9ID0gbWF0Y2hHcm91cDtcclxuICAgIGNvbnN0IGJhc2VOYW1lID0gbmFtZS5zbGljZSgwLCBpbmRleCk7XHJcbiAgICBsZXQgaW5jcmVtZW50ID0gTnVtYmVyKG1hdGNoR3JvdXBbMF0pO1xyXG5cclxuICAgIC8vIEZpbmQgdGhlIGhpZ2hlc3QgdHJhaWxpbmcgbnVtYmVyIHZhbHVlIGZvciB0aGUgYmFzZSBvZiB0aGUgbmFtZVxyXG4gICAgbmFtZVNldC5mb3JFYWNoKHNldE5hbWUgPT4ge1xyXG4gICAgICBjb25zdCBzZXRNYXRjaEdyb3VwID0gc2V0TmFtZS5tYXRjaCgvXFxkKiQvKTtcclxuXHJcbiAgICAgIGlmIChzZXROYW1lLnNsaWNlKDAsIHNldE1hdGNoR3JvdXAuaW5kZXgpID09PSBiYXNlTmFtZSkge1xyXG4gICAgICAgIGNvbnN0IHNldEluY3JlbWVudCA9IE51bWJlcihzZXRNYXRjaEdyb3VwWzBdKTtcclxuXHJcbiAgICAgICAgaWYgKHNldEluY3JlbWVudCA+IGluY3JlbWVudCkge1xyXG4gICAgICAgICAgaW5jcmVtZW50ID0gc2V0SW5jcmVtZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gSW5jcmVtZW50IHRoZSBoaWdoZXN0IHRyYWlsaW5nIG51bWJlciBhbmQgYXBwZW5kIHRvIHRoZSBuYW1lXHJcbiAgICByZXR1cm4gYCR7YmFzZU5hbWV9JHtpbmNyZW1lbnQgKyAxfWA7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gYSBkZWZlcnJlZCBwcm9taXNlIHRoYXQgd2lsbCB3YWl0IGEgZ2l2ZW4gbnVtYmVyIG9mIHNlY29uZHMgYmVmb3JlXHJcbiAgICogcmVzb2x2aW5nLiBQYXNzIGRlbHRhIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHRvIHRoZSBkZWZlcnJlZCBwcm9taXNlJ3MgZXhlY3V0ZVxyXG4gICAqIG1ldGhvZCBpbiBhbiB1cGRhdGUgbG9vcCB0byBwcm9ncmVzcyB0aW1lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzZWNvbmRzPTBdIC0gTnVtYmVyIG9mIHNlY29uZHMgdG8gd2FpdCBiZWZvcmUgcmVzb2x2aW5nLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyAtIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0XHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMub25GaW5pc2hdIC0gQ2FsbGJhY2sgdG8gZXhlY3V0ZSBvbmNlIHRoZSB3YWl0IHRpbWVcclxuICAgKiBpcyBtZXQuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9wdGlvbnMub25Qcm9ncmVzcyAtIENhbGxiYWNrIHRvIGV4ZWN1dGUgZWFjaCB0aW1lIHRoZSB3YWl0XHJcbiAgICogdGltZSBwcm9ncmVzc2VzIHRvd2FyZHMgdGhlIHRhcmdldCBudW1iZXIgb2Ygc2Vjb25kcy4gVGhlIGFtb3VudCBvZiBwcm9ncmVzc1xyXG4gICAqIGFzIGEgMC0xIHBlcmNlbnRhZ2UgaXMgcGFzc2VkIGFzIGFuIGFyZ3VtZW50LlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvcHRpb25zLm9uQ2FuY2VsIC0gQ2FsbGJhY2sgdG8gZXhlY3V0ZSBpZiB0aGUgdXNlciBjYW5jZWxzXHJcbiAgICogdGhlIHdhaXQgYmVmb3JlIGNvbXBsZXRpb24uXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9wdGlvbnMub25FcnJvciAtIENhbGxiYWNrIHRvIGV4ZWN1dGUgaWYgdGhlIHdhaXQgc3RvcHNcclxuICAgKiBiZWNhdXNlIGFuIGVycm9yIGlzIGVuY291bnRlcmVkLiBUaGUgZXJyb3IgbWVzc2FnZSBpcyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9XHJcbiAgICovXHJcbiAgc3RhdGljIHdhaXQoc2Vjb25kcyA9IDAsIHtvbkZpbmlzaCwgb25Qcm9ncmVzcywgb25DYW5jZWwsIG9uRXJyb3J9ID0ge30pIHtcclxuICAgIC8vIE1ha2Ugc3VyZSBzZWNvbmRzIGlzIG51bWVyaWNcclxuICAgIGlmICh0eXBlb2Ygc2Vjb25kcyAhPT0gJ251bWJlcicpIHtcclxuICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgIGBJbnZhbGlkIHNlY29uZHMgdmFsdWUgJHtzZWNvbmRzfSBmb3Igd2FpdC4gRGVmYXVsdGluZyB0byAwLmBcclxuICAgICAgKTtcclxuXHJcbiAgICAgIHNlY29uZHMgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlc29sdmUgaW1tZWRpYXRlbHkgaWYgdGhlIHdhaXQgdGltZSBpcyBub3QgZ3JlYXRlciB0aGFuIDBcclxuICAgIGlmIChzZWNvbmRzIDw9IDApIHtcclxuICAgICAgaWYgKHR5cGVvZiBvbkZpbmlzaCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIG9uRmluaXNoKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBEZWZlcnJlZC5yZXNvbHZlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGN1cnJlbnRUaW1lID0gMDtcclxuICAgIGNvbnN0IHRvdGFsVGltZSA9IHNlY29uZHMgKiAxMDAwOyAvLyBjb252ZXJ0IHRvIG1pbGxpc2Vjb25kc1xyXG5cclxuICAgIC8vIEV4ZWN1dGFibGUgdG8gcGFzcyB0byBEZWZlcnJlZCwgbWVhbnQgdG8gYmUgcnVuIGluIGFuIHVwZGF0ZSBsb29wXHJcbiAgICBjb25zdCBvblVwZGF0ZSA9IChyZXNvbHZlLCByZWplY3QsIF9jYW5jZWwsIGRlbHRhVGltZSA9IDApID0+IHtcclxuICAgICAgaWYgKHR5cGVvZiBkZWx0YVRpbWUgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgY29uc3QgZSA9IG5ldyBFcnJvcihcclxuICAgICAgICAgIGBJbnZhbGlkIHByb3BlcnR5IHdhaXQgZGVsdGFUaW1lLiBEZWx0YVRpbWUgbXVzdCBiZSBhIG51bWJlci5gXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBNYWtlIHN1cmUgdGltZSBoYXMgcGFzc2VkXHJcbiAgICAgIGlmIChkZWx0YVRpbWUgPT09IDApIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFNpZ25hbCBwcm9ncmVzc1xyXG4gICAgICBjdXJyZW50VGltZSArPSBkZWx0YVRpbWU7XHJcbiAgICAgIGlmIChjdXJyZW50VGltZSA8IDApIHtcclxuICAgICAgICBjdXJyZW50VGltZSA9IDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0eXBlb2Ygb25Qcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIG9uUHJvZ3Jlc3MoTWF0aC5taW4oY3VycmVudFRpbWUgLyB0b3RhbFRpbWUsIDEpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU2lnbmFsIGNvbXBsZXRpb24gb25jZSB0aW1lIGlzIHVwXHJcbiAgICAgIGlmIChjdXJyZW50VGltZSA+PSB0b3RhbFRpbWUpIHtcclxuICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIG5ldyBEZWZlcnJlZChvblVwZGF0ZSwgb25GaW5pc2gsIG9uRXJyb3IsIG9uQ2FuY2VsKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAgKiBHZXQgYSByYW5kb20gZmxvYXQgbnVtYmVyIGJldHdlZW4gYSBtaW4gKGluY2x1c2l2ZSkgYW5kIG1heCAoZXhjbHVzaXZlKSB2YWx1ZVxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbWluIG1pbmltdW0gdmFsdWVcclxuICAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBtYXhpbXVtIHZhbHVlXHJcbiAgICAqIEByZXR1cm5zIHtmbG9hdH1cclxuICAgICovXHJcbiAgc3RhdGljIGdldFJhbmRvbUZsb2F0KG1pbiwgbWF4KSB7XHJcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICAqIEdldCBhIHJhbmRvbSBpbnRlZ2VyIG51bWJlciBiZXR3ZWVuIGEgbWluIChpbmNsdXNpdmUpIGFuZCBtYXggKGV4Y2x1c2l2ZSkgdmFsdWVcclxuICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBtaW5pbXVtIHZhbHVlXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggbWF4aW11bSB2YWx1ZVxyXG4gICAgKiBAcmV0dXJucyB7aW50ZWdlcn1cclxuICAgICovXHJcbiAgc3RhdGljIGdldFJhbmRvbUludChtaW4sIG1heCkge1xyXG4gICAgbWluID0gTWF0aC5jZWlsKG1pbik7XHJcbiAgICBtYXggPSBNYXRoLmZsb29yKG1heCk7XHJcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikpICsgbWluO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgVXRpbHM7XHJcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcclxuY29uc3QgUmFkaWFuVG9EZWdyZWUgPSAxODAgLyBNYXRoLlBJO1xyXG5jb25zdCBEZWdyZWVUb1JhZGlhbiA9IE1hdGguUEkgLyAxODA7XHJcblxyXG4vKipcclxuICogQSBjb2xsZWN0aW9uIG9mIHVzZWZ1bCBtYXRoIGZ1bmN0aW9ucy5cclxuICpcclxuICogQGhpZGVjb25zdHJ1Y3RvclxyXG4gKi9cclxuY2xhc3MgTWF0aFV0aWxzIHtcclxuICAvKipcclxuICAgKiBDb252ZXJ0IHRoZSBnaXZlbiBhbmdsZSBmcm9tIHJhZGlhbnMgdG8gZGVncmVlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpYW5zIC0gQW5nbGUgaW4gcmFkaWFucy5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gQW5nbGUgaW4gZGVncmVlcy5cclxuICAgKi9cclxuICBzdGF0aWMgdG9EZWdyZWVzKHJhZGlhbnMpIHtcclxuICAgIHJldHVybiByYWRpYW5zICogUmFkaWFuVG9EZWdyZWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb252ZXJ0IHRoZSBnaXZlbiBhbmdsZSBmcm9tIGRlZ3JlZXMgdG8gcmFkaWFucy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWdyZWVzIC0gQW5nbGUgaW4gZGVncmVlcy5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gQW5nbGUgaW4gcmFkaWFucy5cclxuICAgKi9cclxuICBzdGF0aWMgdG9SYWRpYW5zKGRlZ3JlZXMpIHtcclxuICAgIHJldHVybiBkZWdyZWVzICogRGVncmVlVG9SYWRpYW47XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMaW5lYXJseSBpbnRlcnBvbGF0ZSBiZXR3ZWVuIHR3byB2YWx1ZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbSAtIFN0YXJ0IHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0byAtIFRhcmdldCB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZmFjdG9yIC0gMC0xIGFtb3VudCB0byBpbnRlcnBvbGF0ZSBiZXR3ZWVuIGZyb20gYW5kIHRvLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBzdGF0aWMgbGVycChmcm9tLCB0bywgZmFjdG9yKSB7XHJcbiAgICByZXR1cm4gZnJvbSArICh0byAtIGZyb20pICogZmFjdG9yO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2xhbXAgYSBudW1iZXIgYmV0d2VlbiAyIHZhbHVlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFZhbHVlIHRvIGNsYW1wLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWluPTBdIC0gTWludW11bSB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW21heD0xXSAtIE1heGltdW0gdmFsdWUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBjbGFtcCh2YWx1ZSwgbWluID0gMCwgbWF4ID0gMSkge1xyXG4gICAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4odmFsdWUsIG1heCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlcyB0aGUgY2xvc2VzdCBwb2ludCBvbiBhIGdpdmVuIDJEIGxpbmUgc2VnZW1lbnRcclxuICAgKiBmcm9tIGEgZ2l2ZW4gMkQgcG9pbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBhIC0gRmlyc3QgcG9pbnQgb24gbGluZSBzZWdtZW50LlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGIgLSBTZWNvbmQgcG9pbnQgb24gbGluZSBzZWdtZW50LlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHAgLSAyRCBwb2ludC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtBcnJheS48bnVtYmVyPn1cclxuICAgKi9cclxuICBzdGF0aWMgY2xvc2VzdFBvaW50T25MaW5lKGEsIGIsIHApIHtcclxuICAgIGNvbnN0IGRpc3RTcXIgPSBNYXRoVXRpbHMuZGlzdGFuY2VTcXVhcmVkKGEsIGIpO1xyXG5cclxuICAgIC8vIExpbmUgc2VnbWVudCBpcyBhIHNpbmdsZSBwb2ludFxyXG4gICAgaWYgKGRpc3RTcXIgPT09IDApIHtcclxuICAgICAgcmV0dXJuIGE7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdCA9XHJcbiAgICAgICgocFswXSAtIGFbMF0pICogKGJbMF0gLSBhWzBdKSArIChwWzFdIC0gYVsxXSkgKiAoYlsxXSAtIGFbMV0pKSAvIGRpc3RTcXI7XHJcblxyXG4gICAgbGV0IHBvaW50ID0gWy4uLmFdO1xyXG4gICAgaWYgKHQgPiAxKSB7XHJcbiAgICAgIHBvaW50ID0gWy4uLmJdO1xyXG4gICAgfSBlbHNlIGlmICh0ID4gMCkge1xyXG4gICAgICBwb2ludCA9IFthWzBdICsgdCAqIChiWzBdIC0gYVswXSksIGFbMV0gKyB0ICogKGJbMV0gLSBhWzFdKV07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBvaW50O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgZGlzdGFuY2Ugc3F1YXJlZCBmb3IgdHdvIDJEIHBvaW50cy5cclxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBhIC0gMkQgcG9pbnQuXHJcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYiAtIDJEIHBvaW50LlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBzdGF0aWMgZGlzdGFuY2VTcXVhcmVkKGEsIGIpIHtcclxuICAgIHJldHVybiAoYVswXSAtIGJbMF0pICogKGFbMF0gLSBiWzBdKSArIChhWzFdIC0gYlsxXSkgKiAoYVsxXSAtIGJbMV0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJpYW5ndWxhdGVzIGEgc2V0IG9mIDJEIHBvaW50cyB1c2luZyBhbiBpbXBsZW1lbnRhdGlvblxyXG4gICAqIG9mIHRoZSBCb3d5ZXItV2F0c29uIGluY3JlbWVudGFsIERlbGF1bmF5IHRyaWFuZ3VsYXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IHZlcnRpY2VzIC0gQXJyYXkgb2YgMkQgcG9pbnRzLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0FycmF5LjxBcnJheTxudW1iZXI+Pn0gLSBBcnJheSBvZiB0cmlhbmdsZSBpbmRpY2VzLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBnZXREZWxhdW5heVRyaWFuZ3VsYXRpb24odmVydGljZXMpIHtcclxuICAgIGlmICghdmVydGljZXMgfHwgdmVydGljZXMubGVuZ3RoIDwgMykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYENhbm5vdCBnZXQgZGVsYXVuYXkgdHJpYW5ndWxhdGlvbiBmb3IgcG9pbnRzICR7dmVydGljZXN9LiBJbnB1dCBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgdGhyZWUgcG9pbnRzLmBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgbWluWCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuICAgIGxldCBtaW5ZID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG4gICAgbGV0IG1heFggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XHJcbiAgICBsZXQgbWF4WSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcclxuXHJcbiAgICB2ZXJ0aWNlcy5mb3JFYWNoKHYgPT4ge1xyXG4gICAgICBtaW5YID0gdlswXSA8IG1pblggPyB2WzBdIDogbWluWDtcclxuICAgICAgbWluWSA9IHZbMV0gPCBtaW5ZID8gdlsxXSA6IG1pblk7XHJcbiAgICAgIG1heFggPSB2WzBdID4gbWF4WCA/IHZbMF0gOiBtYXhYO1xyXG4gICAgICBtYXhZID0gdlsxXSA+IG1heFkgPyB2WzFdIDogbWF4WTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGRYID0gbWF4WCAtIG1pblg7XHJcbiAgICBjb25zdCBkWSA9IG1heFkgLSBtaW5ZO1xyXG4gICAgY29uc3QgbWlkWCA9IChtaW5YICsgbWF4WCkgLyAyO1xyXG4gICAgY29uc3QgbWlkWSA9IChtaW5ZICsgbWF4WSkgLyAyO1xyXG4gICAgY29uc3QgZE1heCA9IGRYID4gZFkgPyBkWCA6IGRZO1xyXG5cclxuICAgIGNvbnN0IHN1cGVySW5kaWNlcyA9IFtcclxuICAgICAgdmVydGljZXMubGVuZ3RoLFxyXG4gICAgICB2ZXJ0aWNlcy5sZW5ndGggKyAxLFxyXG4gICAgICB2ZXJ0aWNlcy5sZW5ndGggKyAyLFxyXG4gICAgXTtcclxuXHJcbiAgICBjb25zdCB2ZXJ0c1dpdGhTdXBlciA9IFtcclxuICAgICAgLi4udmVydGljZXMsXHJcbiAgICAgIFttaWRYIC0gMjAgKiBkTWF4LCBtaWRZIC0gZE1heF0sXHJcbiAgICAgIFttaWRYLCBtaWRZICsgMjAgKiBkTWF4XSxcclxuICAgICAgW21pZFggKyAyMCAqIGRNYXgsIG1pZFkgLSBkTWF4XSxcclxuICAgIF07XHJcblxyXG4gICAgY29uc3Qgc3VwZXJTb3J0ZWRJbmRpY2VzID0gTWF0aFV0aWxzLnNvcnRQb2ludHNDQ1coXHJcbiAgICAgIHN1cGVySW5kaWNlcyxcclxuICAgICAgdmVydHNXaXRoU3VwZXJcclxuICAgICk7XHJcblxyXG4gICAgY29uc3Qgc3VwZXJUcmlhbmdsZSA9IHtcclxuICAgICAgaW5kaWNlczogc3VwZXJTb3J0ZWRJbmRpY2VzLFxyXG4gICAgICBlZGdlczogW1xyXG4gICAgICAgIFtzdXBlclNvcnRlZEluZGljZXNbMF0sIHN1cGVyU29ydGVkSW5kaWNlc1sxXV0sXHJcbiAgICAgICAgW3N1cGVyU29ydGVkSW5kaWNlc1sxXSwgc3VwZXJTb3J0ZWRJbmRpY2VzWzJdXSxcclxuICAgICAgICBbc3VwZXJTb3J0ZWRJbmRpY2VzWzJdLCBzdXBlclNvcnRlZEluZGljZXNbMF1dLFxyXG4gICAgICBdLFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCB0cmlhbmdsZXMgPSBbc3VwZXJUcmlhbmdsZV07XHJcblxyXG4gICAgdmVydHNXaXRoU3VwZXIuZm9yRWFjaCgobmV3VmVydCwgbmV3SW5kZXgpID0+IHtcclxuICAgICAgY29uc3QgaW52YWxpZFRyaWFuZ2xlcyA9IFtdO1xyXG4gICAgICB0cmlhbmdsZXMuZm9yRWFjaCh0cmlhbmdsZSA9PiB7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgTWF0aFV0aWxzLmlzUG9pbnRJbkNpcmN1bUNpcmNsZShcclxuICAgICAgICAgICAgdmVydHNXaXRoU3VwZXJbdHJpYW5nbGUuaW5kaWNlc1swXV0sXHJcbiAgICAgICAgICAgIHZlcnRzV2l0aFN1cGVyW3RyaWFuZ2xlLmluZGljZXNbMV1dLFxyXG4gICAgICAgICAgICB2ZXJ0c1dpdGhTdXBlclt0cmlhbmdsZS5pbmRpY2VzWzJdXSxcclxuICAgICAgICAgICAgbmV3VmVydFxyXG4gICAgICAgICAgKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgaW52YWxpZFRyaWFuZ2xlcy5wdXNoKHRyaWFuZ2xlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgY29uc3QgYm91bmRpbmdQb2x5ID0gW107XHJcbiAgICAgIGludmFsaWRUcmlhbmdsZXMuZm9yRWFjaCh0cmlhbmdsZSA9PiB7XHJcbiAgICAgICAgdHJpYW5nbGUuZWRnZXMuZm9yRWFjaChlZGdlID0+IHtcclxuICAgICAgICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICAgICAgICBpbnZhbGlkVHJpYW5nbGVzLmZvckVhY2gob3RoZXJUcmlhbmdsZSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0cmlhbmdsZSAhPT0gb3RoZXJUcmlhbmdsZSkge1xyXG4gICAgICAgICAgICAgIG90aGVyVHJpYW5nbGUuZWRnZXMuZm9yRWFjaChvdGhlckVkZ2UgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAoZWRnZVswXSA9PT0gb3RoZXJFZGdlWzBdICYmIGVkZ2VbMV0gPT09IG90aGVyRWRnZVsxXSkgfHxcclxuICAgICAgICAgICAgICAgICAgKGVkZ2VbMV0gPT09IG90aGVyRWRnZVswXSAmJiBlZGdlWzBdID09PSBvdGhlckVkZ2VbMV0pXHJcbiAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgY291bnQgKz0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBpZiAoY291bnQgPT09IDApIGJvdW5kaW5nUG9seS5wdXNoKGVkZ2UpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGludmFsaWRUcmlhbmdsZXMuZm9yRWFjaCh0cmlhbmdsZSA9PiB7XHJcbiAgICAgICAgdHJpYW5nbGVzLnNwbGljZSh0cmlhbmdsZXMuaW5kZXhPZih0cmlhbmdsZSksIDEpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGJvdW5kaW5nUG9seS5mb3JFYWNoKGVkZ2UgPT4ge1xyXG4gICAgICAgIGNvbnN0IHNvcnRlZEluZGljZXMgPSBNYXRoVXRpbHMuc29ydFBvaW50c0NDVyhcclxuICAgICAgICAgIFtlZGdlWzBdLCBlZGdlWzFdLCBuZXdJbmRleF0sXHJcbiAgICAgICAgICB2ZXJ0c1dpdGhTdXBlclxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHRyaWFuZ2xlcy5wdXNoKHtcclxuICAgICAgICAgIGluZGljZXM6IHNvcnRlZEluZGljZXMsXHJcbiAgICAgICAgICBlZGdlczogW1xyXG4gICAgICAgICAgICBbc29ydGVkSW5kaWNlc1swXSwgc29ydGVkSW5kaWNlc1sxXV0sXHJcbiAgICAgICAgICAgIFtzb3J0ZWRJbmRpY2VzWzFdLCBzb3J0ZWRJbmRpY2VzWzJdXSxcclxuICAgICAgICAgICAgW3NvcnRlZEluZGljZXNbMl0sIHNvcnRlZEluZGljZXNbMF1dLFxyXG4gICAgICAgICAgXSxcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB0cmlhbmdsZXNUb1JlbW92ZSA9IFtdO1xyXG4gICAgdHJpYW5nbGVzLmZvckVhY2godHJpYW5nbGUgPT4ge1xyXG4gICAgICB0cmlhbmdsZS5pbmRpY2VzLmZvckVhY2goaW5kZXggPT4ge1xyXG4gICAgICAgIGlmIChzdXBlckluZGljZXMuaW5jbHVkZXMoaW5kZXgpKSB7XHJcbiAgICAgICAgICB0cmlhbmdsZXNUb1JlbW92ZS5wdXNoKHRyaWFuZ2xlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdHJpYW5nbGVzVG9SZW1vdmUuZm9yRWFjaCh0cmlhbmdsZSA9PiB7XHJcbiAgICAgIGNvbnN0IGluZGV4ID0gdHJpYW5nbGVzLmluZGV4T2YodHJpYW5nbGUpO1xyXG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgdHJpYW5nbGVzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0cmlhbmdsZXMubWFwKHRyaWFuZ2xlID0+IHRyaWFuZ2xlLmluZGljZXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIDJEIHBvaW50IGlzIHdpdGhpbiB0aGUgY2ljcnVtY2lyY2xlXHJcbiAgICogZGVmaW5lZCBieSB0aHJlZSAyRCBwb2ludHMuIFRoZSB0cmlhbmdsZSBwb2ludHMgbXVzdCBiZSBpblxyXG4gICAqIGNvdW50ZXItY2xvY2t3aXNlIG9yZGVyIGEgLT4gYiAtPiBjLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYSAtIEZpcnN0IHRyaWFuZ2xlIHBvaW50LlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGIgLSBTZWNvbmQgdHJpYW5nbGUgcG9pbnQuXHJcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYyAtIFRoaXJkIHRyaWFuZ2xlIHBvaW50LlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHAgLSAyRCBwb2ludC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xyXG4gIHN0YXRpYyBpc1BvaW50SW5DaXJjdW1DaXJjbGUoYSwgYiwgYywgcCkge1xyXG4gICAgY29uc3QgYXggPSBhWzBdIC0gcFswXTtcclxuICAgIGNvbnN0IGF5ID0gYVsxXSAtIHBbMV07XHJcbiAgICBjb25zdCBieCA9IGJbMF0gLSBwWzBdO1xyXG4gICAgY29uc3QgYnkgPSBiWzFdIC0gcFsxXTtcclxuICAgIGNvbnN0IGN4ID0gY1swXSAtIHBbMF07XHJcbiAgICBjb25zdCBjeSA9IGNbMV0gLSBwWzFdO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgIChheCAqIGF4ICsgYXkgKiBheSkgKiAoYnggKiBjeSAtIGN4ICogYnkpIC1cclxuICAgICAgICAoYnggKiBieCArIGJ5ICogYnkpICogKGF4ICogY3kgLSBjeCAqIGF5KSArXHJcbiAgICAgICAgKGN4ICogY3ggKyBjeSAqIGN5KSAqIChheCAqIGJ5IC0gYnggKiBheSkgPlxyXG4gICAgICAwXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIDJEIHBvaW50IGlzIHdpdGhpbiBhIGdpdmVuIHRyaWFuZ2xlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYSAtIEZpcnN0IHRyaWFuZ2xlIHBvaW50LlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGIgLSBTZWNvbmQgdHJpYW5nbGUgcG9pbnQuXHJcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYyAtIFRoaXJkIHRyaWFuZ2xlIHBvaW50LlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHAgLSAyRCBwb2ludC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xyXG4gIHN0YXRpYyBpc1BvaW50SW5UcmlhbmdsZShhLCBiLCBjLCBwKSB7XHJcbiAgICBjb25zdCBkZW5vbSA9IChiWzFdIC0gY1sxXSkgKiAoYVswXSAtIGNbMF0pICsgKGNbMF0gLSBiWzBdKSAqIChhWzFdIC0gY1sxXSk7XHJcbiAgICBjb25zdCBhVmFsID1cclxuICAgICAgKChiWzFdIC0gY1sxXSkgKiAocFswXSAtIGNbMF0pICsgKGNbMF0gLSBiWzBdKSAqIChwWzFdIC0gY1sxXSkpIC8gZGVub207XHJcbiAgICBjb25zdCBiVmFsID1cclxuICAgICAgKChjWzFdIC0gYVsxXSkgKiAocFswXSAtIGNbMF0pICsgKGFbMF0gLSBjWzBdKSAqIChwWzFdIC0gY1sxXSkpIC8gZGVub207XHJcbiAgICBjb25zdCBjVmFsID0gMSAtIGFWYWwgLSBiVmFsO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgIGFWYWwgPj0gMCAmJiBhVmFsIDw9IDEgJiYgYlZhbCA+PSAwICYmIGJWYWwgPD0gMSAmJiBjVmFsID49IDAgJiYgY1ZhbCA8PSAxXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgc29ydGVkIGluZGljZXMgb2YgYSBnaXZlbiBzZXQgb2YgMkQgcG9pbnRzIGluXHJcbiAgICogY291bnRlci1jbG9ja3dpc2Ugb3JkZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBpbmRpY2VzIC0gTGlzdCBvZiBpbmRpY2VzLlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gdmVydGljZXMgLSBMaXN0IG9mIDJEIHBvaW50cy5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSAtIExpc3Qgb2Ygc29ydGVkIGluZGljZXMuXHJcbiAgICovXHJcbiAgc3RhdGljIHNvcnRQb2ludHNDQ1coaW5kaWNlcywgdmVydGljZXMpIHtcclxuICAgIGNvbnN0IGNlbnRyb2lkID0gWzAsIDBdO1xyXG4gICAgaW5kaWNlcy5mb3JFYWNoKGluZGV4ID0+IHtcclxuICAgICAgY2VudHJvaWRbMF0gKz0gdmVydGljZXNbaW5kZXhdWzBdO1xyXG4gICAgICBjZW50cm9pZFsxXSArPSB2ZXJ0aWNlc1tpbmRleF1bMV07XHJcbiAgICB9KTtcclxuICAgIGNlbnRyb2lkWzBdIC89IGluZGljZXMubGVuZ3RoO1xyXG4gICAgY2VudHJvaWRbMV0gLz0gaW5kaWNlcy5sZW5ndGg7XHJcblxyXG4gICAgaW5kaWNlcy5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgIGNvbnN0IGJWYWwgPSBNYXRoLmF0YW4yKFxyXG4gICAgICAgIHZlcnRpY2VzW2JdWzFdIC0gY2VudHJvaWRbMV0sXHJcbiAgICAgICAgdmVydGljZXNbYl1bMF0gLSBjZW50cm9pZFswXVxyXG4gICAgICApO1xyXG4gICAgICBjb25zdCBhVmFsID0gTWF0aC5hdGFuMihcclxuICAgICAgICB2ZXJ0aWNlc1thXVsxXSAtIGNlbnRyb2lkWzFdLFxyXG4gICAgICAgIHZlcnRpY2VzW2FdWzBdIC0gY2VudHJvaWRbMF1cclxuICAgICAgKTtcclxuXHJcbiAgICAgIHJldHVybiBhVmFsIC0gYlZhbDtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBpbmRpY2VzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FjbHVhdGVzIHRoZSBhcmVhIG9mIGEgdHJpYW5nbGVcclxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBhIC0gRmlyc3QgdHJpYW5nbGUgcG9pbnQuXHJcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYiAtIFNlY29uZCB0cmlhbmdsZSBwb2ludC5cclxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBjIC0gVGhpcmQgdHJpYW5nbGUgcG9pbnQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIHN0YXRpYyB0cmlhbmdsZUFyZWEoYSwgYiwgYykge1xyXG4gICAgcmV0dXJuIE1hdGguYWJzKFxyXG4gICAgICAoYVswXSAqIChiWzFdIC0gY1sxXSkgKyBiWzBdICogKGNbMV0gLSBhWzFdKSArIGNbMF0gKiAoYVsxXSAtIGJbMV0pKSAqIDAuNVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiB0aGUgbWFnbml0dWRlIG9mIGEgZ2l2ZW4gdmVjdG9yIGFycmF5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdmVjdG9yIC0gQXJyYXkgY29uc2lzdGluZyBvZiBudW1iZXJzLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBzdGF0aWMgZ2V0VmVjdG9yTWFnbml0dWRlKHZlY3Rvcikge1xyXG4gICAgaWYgKCEodmVjdG9yIGluc3RhbmNlb2YgQXJyYXkpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgQ2Fubm90IGdldCBtYWduaXR1ZGUgZm9yIHZlY3RvciAke3ZlY3Rvcn0uIElucHV0IG11c3QgYmUgYW4gQXJyYXkgbnVtYmVycy5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmVkdWNlciA9IChhY2N1bXVsYXRvciwgY3VycmVudFZhbHVlKSA9PiB7XHJcbiAgICAgIGlmICh0eXBlb2YgY3VycmVudFZhbHVlICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgIGBDYW5ub3QgZ2V0IG1hZ25pdHVkZSBmb3IgdmVjdG9yICR7dmVjdG9yfS4gQWxsIGl0ZW1zIGluIHRoZSBpbnB1dCBBcnJheSBtdXN0IGJlIG51bWJlcnMuYFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvciArIChjdXJyZW50VmFsdWUgKiogMik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIE1hdGguc3FydCh2ZWN0b3IucmVkdWNlKHJlZHVjZXIsIDApKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiB0aGUgZG90IHByb2R1Y3QgYmV0d2VlbiB0d28gdmVjdG9ycy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHZlY3RvckEgLSBBcnJheSBjb25zaXN0aW5nIG9mIG51bWJlcnMuXHJcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdmVjdG9yQiAtIEFycmF5IGNvbnNpc3Rpbmcgb2YgbnVtYmVycy5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgc3RhdGljIGdldERvdFByb2R1Y3QodmVjdG9yQSwgdmVjdG9yQikge1xyXG4gICAgaWYgKCEodmVjdG9yQSBpbnN0YW5jZW9mIEFycmF5KSB8fCAhKHZlY3RvckIgaW5zdGFuY2VvZiBBcnJheSkgfHwgdmVjdG9yQS5sZW5ndGggIT09IHZlY3RvckIubGVuZ3RoKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGdldCBkb3QgcHJvZHVjdCBiZXR3ZWVuICR7dmVjdG9yQX0gYW5kICR7dmVjdG9yQn0uIElucHV0cyBtdXN0IGJlIHZlY3RvcnMgb2YgdGhlIHNhbWUgbGVuZ3RoLmApO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCByZXN1bHQgPSAwO1xyXG4gICAgdmVjdG9yQS5mb3JFYWNoKCh2YWx1ZUEsIGluZGV4KSA9PiB7XHJcbiAgICAgIGNvbnN0IHZhbHVlQiA9IHZlY3RvckJbaW5kZXhdO1xyXG5cclxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZUEgIT09ICdudW1iZXInIHx8IHR5cGVvZiB2YWx1ZUIgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZ2V0IGRvdCBwcm9kdWN0IGJldHdlZW4gJHt2ZWN0b3JBfSBhbmQgJHt2ZWN0b3JCfS4gVmVjdG9ycyBtdXN0IG9ubHkgY29uc2lzdCBvZiBudW1lcmljIHZhbHVlcy5gKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmVzdWx0ICs9IHZhbHVlQSAqIHZhbHVlQjtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gdGhlIGFuZ2xlIGluIHJhZGlhbnMgYmV0d2VlbiB2ZWN0b3JBIGFuZCB2ZWN0b3JCLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdmVjdG9yQSAtIEFycmF5IGNvbnNpc3Rpbmcgb2YgbnVtYmVycy5cclxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2ZWN0b3JCIC0gQXJyYXkgY29uc2lzdGluZyBvZiBudW1iZXJzLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBzdGF0aWMgZ2V0QW5nbGVCZXR3ZWVuKHZlY3RvckEsIHZlY3RvckIpIHtcclxuICAgIGNvbnN0IG5vcm1hbEEgPSB0aGlzLm5vcm1hbGl6ZVZlY3RvcihbLi4udmVjdG9yQV0pO1xyXG4gICAgY29uc3Qgbm9ybWFsQiA9IHRoaXMubm9ybWFsaXplVmVjdG9yKFsuLi52ZWN0b3JCXSk7XHJcbiAgICBjb25zdCBkb3QgPSB0aGlzLmdldERvdFByb2R1Y3Qobm9ybWFsQSwgbm9ybWFsQik7XHJcblxyXG4gICAgcmV0dXJuIE1hdGguYWNvcyh0aGlzLmNsYW1wKGRvdCwgLTEsIDEpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE11bHRpcGx5IGEgM3gzIHJvdGF0aW9uIG1hdHJpeCB3aXRoIGEgdmVjdG9yMy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHZlY3RvcjMgLSBBcnJheSBjb25zaXN0aW5nIG9mIDMgbnVtYmVycyByZXByZXNlbnRpbmdcclxuICAgKiBhIGRpcmVjdGlvbiB2ZWN0b3IuXHJcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF0cml4MyAtIEFuIGFycmF5IG9mIDkgbnVtYmVycyByZXByZXNlbnRpbmcgYSByb3dcclxuICAgKiBtYWpvciByb3RhdGlvbiBtYXRyaXguXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59IC0gQW4gYXJyYXkgb2YgMyBudW1iZXJzIHJlcHJlc2VudGluZyB0aGUgbmV3IGRpcmVjdGlvblxyXG4gICAqIG9mIHRoZSB2ZWN0b3IuXHJcbiAgICovXHJcbiAgc3RhdGljIHJvdGF0ZVZlY3Rvcih2ZWN0b3IzLCBtYXRyaXgzKSB7XHJcbiAgICBpZiAoISh2ZWN0b3IzIGluc3RhbmNlb2YgQXJyYXkpXHJcbiAgICAgIHx8IHZlY3RvcjMubGVuZ3RoICE9PSAzXHJcbiAgICAgIHx8ICF2ZWN0b3IzLmV2ZXJ5KHYgPT4gdHlwZW9mIHYgPT09ICdudW1iZXInKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYENhbm5vdCByb3RhdGUgdmVjdG9yICR7dmVjdG9yM30gYnkgcm90YXRpb24gbWF0cml4ICR7bWF0cml4M30uIElucHV0IHZlY3RvciBtdXN0IGJlIGFuIGFycmF5IG9mIDMgbnVtYmVycy5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCEobWF0cml4MyBpbnN0YW5jZW9mIEFycmF5KVxyXG4gICAgICB8fCBtYXRyaXgzLmxlbmd0aCAhPT0gOVxyXG4gICAgICB8fCAhbWF0cml4My5ldmVyeSh2ID0+IHR5cGVvZiB2ID09PSAnbnVtYmVyJykpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBDYW5ub3Qgcm90YXRlIHZlY3RvciAke3ZlY3RvcjN9IGJ5IHJvdGF0aW9uIG1hdHJpeCAke21hdHJpeDN9LiBJbnB1dCBtYXRyaXgzIG11c3QgYmUgYW4gYXJyYXkgb2YgOSBudW1iZXJzLmBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB4ID0gbWF0cml4M1swXSAqIHZlY3RvcjNbMF1cclxuICAgICAgKyBtYXRyaXgzWzNdICogdmVjdG9yM1sxXVxyXG4gICAgICArIG1hdHJpeDNbNl0gKiB2ZWN0b3IzWzJdO1xyXG4gICAgY29uc3QgeSA9IG1hdHJpeDNbMV0gKiB2ZWN0b3IzWzBdXHJcbiAgICAgICsgbWF0cml4M1s0XSAqIHZlY3RvcjNbMV1cclxuICAgICAgKyBtYXRyaXgzWzddICogdmVjdG9yM1syXTtcclxuICAgIGNvbnN0IHogPSBtYXRyaXgzWzJdICogdmVjdG9yM1swXVxyXG4gICAgICArIG1hdHJpeDNbNV0gKiB2ZWN0b3IzWzFdXHJcbiAgICAgICsgbWF0cml4M1s4XSAqIHZlY3RvcjNbMl07XHJcblxyXG4gICAgcmV0dXJuIFt4LCB5LCB6XTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE5vcm1hbGl6ZSBhIGdpdmVuIHZlY3RvciBhcnJheS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHZlY3RvciAtIEFycmF5IGNvbnNpc3Rpbmcgb2YgbnVtYmVycy5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtBcnJheS48bnVtYmVyPn0gVGhlIG9yaWdpbmFsIHZlY3RvciB3aXRoIG5vcm1hbGl6ZWQgdmFsdWVzLCBmb3IgY2hhaW5pbmcuXHJcbiAgICovXHJcbiAgc3RhdGljIG5vcm1hbGl6ZVZlY3Rvcih2ZWN0b3IpIHtcclxuICAgIGNvbnN0IG1hZ25pdHVkZSA9IHRoaXMuZ2V0VmVjdG9yTWFnbml0dWRlKHZlY3Rvcik7XHJcblxyXG4gICAgaWYgKG1hZ25pdHVkZSA9PT0gMCkge1xyXG4gICAgICB2ZWN0b3IuZmlsbCgwKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmVjdG9yLmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xyXG4gICAgICAgIHZlY3RvcltpbmRleF0gPSB2YWx1ZSAvIG1hZ25pdHVkZTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHZlY3RvcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEV4dHJhY3QgdGhlIDN4MyByb3RhdGlvbiBtYXRyaXggZnJvbSBhIGdpdmVuIDR4NCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtYXRyaXg0IC0gQW4gYXJyYXkgb2YgMTYgbnVtYmVycyByZXByZXNlbnRpbmcgYSByb3dcclxuICAgKiBtYWpvciB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59IC0gQW4gYXJyYXkgb2YgOSBudW1iZXJzIHJlcHJlc2VudGluZyBhIHJvdyBtYWpvclxyXG4gICAqIHJvdGF0aW9uIG1hdHJpeC5cclxuICAgKi9cclxuICBzdGF0aWMgZ2V0Um90YXRpb25NYXRyaXgobWF0cml4NCkge1xyXG4gICAgaWYgKCEobWF0cml4NCBpbnN0YW5jZW9mIEFycmF5KVxyXG4gICAgICB8fCBtYXRyaXg0Lmxlbmd0aCAhPT0gMTZcclxuICAgICAgfHwgIW1hdHJpeDQuZXZlcnkodiA9PiB0eXBlb2YgdiA9PT0gJ251bWJlcicpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgQ2Fubm90IGNvbnZlcnQgbWF0cml4ICR7bWF0cml4NH0gdG8gYSByb3RhdGlvbiBtYXRyaXguIElucHV0IG1hdHJpeCBtdXN0IGJlIGFuIGFycmF5IG9mIDE2IG51bWJlcnMuYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEV4dHJhY3Qgc2NhbGVcclxuICAgIGNvbnN0IHNjYWxlWCA9IDEgLyAodGhpcy5nZXRWZWN0b3JNYWduaXR1ZGUobWF0cml4NC5zbGljZSgwLCA0KSkgfHwgMSk7XHJcbiAgICBjb25zdCBzY2FsZVkgPSAxIC8gKHRoaXMuZ2V0VmVjdG9yTWFnbml0dWRlKG1hdHJpeDQuc2xpY2UoNCwgOCkpIHx8IDEpO1xyXG4gICAgY29uc3Qgc2NhbGVaID0gMSAvICh0aGlzLmdldFZlY3Rvck1hZ25pdHVkZShtYXRyaXg0LnNsaWNlKDgsIDEyKSkgfHwgMSk7XHJcblxyXG4gICAgcmV0dXJuIFtcclxuICAgICAgbWF0cml4NFswXSAqIHNjYWxlWCwgbWF0cml4NFsxXSAqIHNjYWxlWCwgbWF0cml4NFsyXSAqIHNjYWxlWCxcclxuICAgICAgbWF0cml4NFs0XSAqIHNjYWxlWSwgbWF0cml4NFs1XSAqIHNjYWxlWSwgbWF0cml4NFs2XSAqIHNjYWxlWSxcclxuICAgICAgbWF0cml4NFs4XSAqIHNjYWxlWiwgbWF0cml4NFs5XSAqIHNjYWxlWiwgbWF0cml4NFsxMF0gKiBzY2FsZVpcclxuICAgIF07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyB0aGUgc3BoZXJpY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSBnaXZlbiBjYXJ0ZXNpYW5cclxuICAgKiB4eXogY29vcmRpbmF0ZXMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBQb3NpdGlvbiBhbG9uZyB0aGUgeCBheGlzLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gUG9zaXRpb24gYWxvbmcgdGhlIHkgYXhpcy5cclxuICAgKiBAcGFyYW0ge251bWJlcn0geiAtIFBvc2l0aW9uIGFsb25nIHRoZSB6IGF4aXMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59IC0gQW4gYXJyYXkgY29uc2lzdGluZyBvZiB0aHJlZSBudW1iZXJlcyB3aGVyZSBpbmRleFxyXG4gICAqIDAgcmVwcmVzZW50cyB0aGUgcmFkaXVzLCBpbmRleCAxIHJlcHJlc2VudHMgdGhlIHZlcnRpY2FsL3BvbGFyIGFuZ2xlIGluIHJhZGlhbnNcclxuICAgKiBhbmQgaW5kZXggMiByZXByZXNlbnRzIHRoZSBob3Jpem9udGFsL2F6aW11dGhhbCBhbmdsZSBpbiByYWRpYW5zLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBjYXJ0ZXNpYW5Ub1NwaGVyaWNhbCh4LCB5LCB6KSB7XHJcbiAgICBjb25zdCByID0gdGhpcy5nZXRWZWN0b3JNYWduaXR1ZGUoW3gsIHksIHpdKTtcclxuXHJcbiAgICAvLyBSZXR1cm4gaWRlbnRpdHkgaWYgdGhlIHZlY3RvciBoYXMgbm8gbGVuZ3RoXHJcbiAgICBpZiAociA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gWzAsIDAsIDBdO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBbXHJcbiAgICAgIHIsXHJcbiAgICAgIE1hdGguYWNvcyh0aGlzLmNsYW1wKHkgLyByLCAtIDEsIDEpKSxcclxuICAgICAgTWF0aC5hdGFuMih4LCB6KSxcclxuICAgIF07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHcmFkdWFsbHkgY2hhbmdlIGEgdmFsdWUgb2YgYSBudW1lcmljIHByb3BlcnR5IHRvd2FyZHMgYSBnb2FsIG92ZXIgdGltZSB1c2luZ1xyXG4gICAqIGEgY3JpdGljYWxseSBkYW1wZWQgc3ByaW5nIGZ1bmN0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnRWYWx1ZSAtIFRoZSBzdGFydGluZyB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0VmFsdWUtIFRoZSBnb2FsIHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFt2YWx1ZVN0b3JlID0gWzAsIDBdXSAtIEFuIEFycmF5IGNvbnNpc3Rpbmcgb2YgdHdvXHJcbiAgICogbnVtYmVycyB3aGVyZSB0aGUgZmlyc3QgbnVtYmVyIGhvbGRzIHRoZSByZXN1bHQgdmFsdWUgYW5kIHRoZSBzZWNvbmQgaG9sZHNcclxuICAgKiB0aGUgdmVsb2NpdHkgdGhhdCByZXN1bHRlZCBpbiB0aGF0IHZhbHVlLiBUaGUgc2FtZSBhcnJheSBzaG91bGQgYmUgcHJvdmlkZWRcclxuICAgKiB3aXRoIGVhY2ggY2FsbCB0byB0aGlzIGZ1bmN0aW9uLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsdGFUaW1lID0gMWUtN10gLSBUaGUgdGltZSBzaW5jZSB0aGUgbGFzdCBjYWxsIHRvIHRoaXMgZnVuY3Rpb25cclxuICAgKiBpbiBzZWNvbmRzLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc21vb3RoVGltZSA9IDAuM10gLSBUaGUgYXBwcm94aW1hdGUgYW1vdW50IG9mIHRpbWUgaW4gc2Vjb25kc1xyXG4gICAqIGl0IHNob3VsZCB0YWtlIHRvIHJlYWNoIHRoZSB0YXJnZXQgdmFsdWUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttYXhTcGVlZCA9IDFlN10gLSBBIGNsYW1waW5nIHZhbHVlIGZvciB0aGUgbWF4aW11bSBzcGVlZCB0aGVcclxuICAgKiB2YWx1ZSBjYW4gY2hhbmdlLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0FycmF5LjxudW1iZXI+fSAtIFRoZSB2YWx1ZVN0b3JlIGFycmF5LlxyXG4gICAqL1xyXG4gIHN0YXRpYyBkYW1wVmFsdWUoXHJcbiAgICBjdXJyZW50VmFsdWUsXHJcbiAgICB0YXJnZXRWYWx1ZSxcclxuICAgIHZhbHVlU3RvcmUgPSBbMCwgMF0sXHJcbiAgICBkZWx0YVRpbWUgPSAxZS03LFxyXG4gICAgc21vb3RoVGltZSA9IDAuMyxcclxuICAgIG1heFNwZWVkID0gMWU3XHJcbiAgKSB7XHJcbiAgICBzbW9vdGhUaW1lID0gTWF0aC5tYXgoMC4wMDAxLCBzbW9vdGhUaW1lKTtcclxuICAgIGRlbHRhVGltZSA9IE1hdGgubWF4KDFlLTcsIGRlbHRhVGltZSk7XHJcblxyXG4gICAgLy8gRmluZCB0aGUgZGVsdGEgYmV0d2VlbiB2YWx1ZXMgYW5kIHVzZSBpdCB0byBlc3RpbWF0ZSB0aGUgcHJldmlvdXMgdmFsdWVcclxuICAgIGNvbnN0IGNsYW1wVGltZSA9IG1heFNwZWVkICogc21vb3RoVGltZTtcclxuICAgIGNvbnN0IGRlbHRhVmFsdWUgPSBjdXJyZW50VmFsdWUgLSB0YXJnZXRWYWx1ZTtcclxuICAgIGNvbnN0IGNsYW1wRGVsdGFWYWx1ZSA9IHRoaXMuY2xhbXAoZGVsdGFWYWx1ZSwgLWNsYW1wVGltZSwgY2xhbXBUaW1lKTtcclxuICAgIGNvbnN0IGxhc3RWYWx1ZSA9IGN1cnJlbnRWYWx1ZSAtIGNsYW1wRGVsdGFWYWx1ZTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgZGFtcGluZyBmYWN0b3JzXHJcbiAgICBjb25zdCBkMSA9IDIgLyBzbW9vdGhUaW1lO1xyXG4gICAgY29uc3QgZDIgPSBkMSAqIGRlbHRhVGltZTtcclxuICAgIGNvbnN0IGQzID0gMSAvICgxICsgZDIgKyAwLjUgKiBkMiAqKiAyICsgMC4yNSAqIGQyICoqIDMpO1xyXG4gICAgY29uc3QgZDQgPSAodmFsdWVTdG9yZVsxXSArIGQxICogY2xhbXBEZWx0YVZhbHVlKSAqIGRlbHRhVGltZTtcclxuXHJcbiAgICAvLyBEYW1wIHRoZSB0YXJnZXQgdmFsdWUgYW5kIHVwZGF0ZSB0aGUgdmVsb2NpdHlcclxuICAgIHZhbHVlU3RvcmVbMF0gPSBsYXN0VmFsdWUgKyAoY2xhbXBEZWx0YVZhbHVlICsgZDQpICogZDM7XHJcbiAgICB2YWx1ZVN0b3JlWzFdID0gKHZhbHVlU3RvcmVbMV0gLSBkMSAqIGQ0KSAqIGQzO1xyXG5cclxuICAgIC8vIFByZXZlbnQgb3ZlcnNob290aW5nXHJcbiAgICBpZiAodGFyZ2V0VmFsdWUgLSBjdXJyZW50VmFsdWUgPiAwID09PSB2YWx1ZVN0b3JlWzBdID4gdGFyZ2V0VmFsdWUpIHtcclxuICAgICAgdmFsdWVTdG9yZVswXSA9IHRhcmdldFZhbHVlO1xyXG4gICAgICB2YWx1ZVN0b3JlWzFdID0gKHZhbHVlU3RvcmVbMF0gLSB0YXJnZXRWYWx1ZSkgLyBkZWx0YVRpbWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHZhbHVlU3RvcmU7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBNYXRoVXRpbHM7XHJcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcclxuLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L3ByZWZlci1kZWZhdWx0LWV4cG9ydCAqL1xyXG5cclxuLyoqXHJcbiAqIEluZGljYXRlcyB0aGUgdHlwZSBvZiBob3N0IGJ1aWxkLlxyXG4gKlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cclxuY29uc3QgZW52ID0gJ2NvcmUnO1xyXG5cclxuZXhwb3J0IHtlbnZ9O1xyXG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVyc2NvcmUtZGFuZ2xlICovXHJcbmltcG9ydCBVdGlscyBmcm9tICcuL1V0aWxzJztcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyB0aGF0IGNhbiBleGVjdXRlIGZ1bmN0aW9ucyB3aGVuIGxvY2FsIG1lc3NhZ2VzIGFyZSByZWNlaXZlZC4gTG9jYWwgbWVzc2FnZXNcclxuICogYXJlIHByZWZpeGVkIHdpdGggdGhlIGluc3RhbmNlJ3MgaWQuXHJcbiAqXHJcbiAqIEBhbGlhcyBjb3JlL01lc3NlbmdlclxyXG4gKlxyXG4gKiBAcHJvcGVydHkge2NvcmUvTWVzc2VuZ2VyfSBHbG9iYWxNZXNzZW5nZXIgLSBBIG1lc3NlbmdlciB0aGF0IGNhbiBiZSB1c2VkIGZvclxyXG4gKiBnbG9iYWwgbWVzc2FnaW5nLiBXaGVuIHVzaW5nIHN0YXRpYyBsaXN0ZW4gYW5kIGVtaXQgbWV0aG9kcyB0aGV5IGFyZSBleGVjdXRlZFxyXG4gKiBvbiB0aGlzIG1lc3Nlbmdlci5cclxuICogQHByb3BlcnR5IHtPYmplY3R9IEVWRU5UUyAtIEJ1aWx0LWluIGV2ZW50cyB0aGF0IHRoZSBNZXNzZW5nZXIgZW1pdHMuXHJcbiAqL1xyXG5jbGFzcyBNZXNzZW5nZXIge1xyXG4gIC8qKlxyXG4gICAqIEBjb25zdHJ1Y3RvclxyXG4gICAqXHJcbiAgICogQHBhcmFtIHthbnk9fSBpZCAtIElkIGZvciB0aGUgb2JqZWN0LiBJZiBub25lIGlzIHByb3ZpZGVkIGEgbmV3IGlkIHdpbGxcclxuICAgKiBiZSBjcmVhdGVkLiBJZCBzaG91bGQgYmUgYWJsZSB0byBiZSByZXByZXNlbnRlZCBhcyBhIHN0cmluZy5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihpZCkge1xyXG4gICAgdGhpcy5faWQgPSBpZCAhPT0gdW5kZWZpbmVkID8gaWQgOiBVdGlscy5jcmVhdGVJZCgpO1xyXG4gICAgdGhpcy5fZGlzcGF0Y2hlciA9IHdpbmRvdztcclxuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xyXG4gICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnMgPSB7fTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIHN0cmluZyBpZCBvZiB0aGUgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHR5cGUge3N0cmluZ31cclxuICAgKi9cclxuICBnZXQgaWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQcmVmaXggYSBtZXNzYWdlIHdpdGggdGhlIGluc3RhbmNlIGlkLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAqL1xyXG4gIF9jcmVhdGVMb2NhbE1lc3NhZ2UobWVzc2FnZSkge1xyXG4gICAgcmV0dXJuIGAke3RoaXMuaWR9LiR7bWVzc2FnZX1gO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGNhbGwgYSBjYWxsYmFjayBmdW5jdGlvbiBhbmQgc3VwcGx5IHRoZSBldmVudCdzXHJcbiAgICogZGV0YWlsIHByb3BlcnR5IGFzIGFuIGFyZ3VtZW50LlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XHJcbiAgICovXHJcbiAgX2NyZWF0ZUxpc3RlbmVyKGNhbGxiYWNrKSB7XHJcbiAgICByZXR1cm4gZSA9PiB7XHJcbiAgICAgIGxldCB2YWx1ZTtcclxuXHJcbiAgICAgIGlmIChlLmRldGFpbCAhPT0gbnVsbCkge1xyXG4gICAgICAgIHZhbHVlID0gZS5kZXRhaWw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNhbGxiYWNrKHZhbHVlKTtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgYW4gZXZlbnQgb2JqZWN0IGFuZCBzZW5kIGl0IHRvIGxpc3RlbmVycy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIEV2ZW50IHR5cGUgbmFtZS5cclxuICAgKiBAcGFyYW0ge2FueT19IHZhbHVlIC0gVmFsdWUgdG8gc2VuZCB0byBsaXN0ZW5lcnMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7Q3VzdG9tRXZlbnR9XHJcbiAgICovXHJcbiAgX2NyZWF0ZUV2ZW50KG1lc3NhZ2UsIHZhbHVlKSB7XHJcbiAgICByZXR1cm4gbmV3IEN1c3RvbUV2ZW50KG1lc3NhZ2UsIHtkZXRhaWw6IHZhbHVlfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWdpc3RlciBhbiBldmVudC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIEV2ZW50IHR5cGUgbmFtZS5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciAtIEEgbGlzdGVuZXIgZnVuY3Rpb24gZ2VuZXJhdGVkIHVzaW5nIF9jcmVhdGVMaXN0ZW5lci5cclxuICAgKi9cclxuICBfYWRkTGlzdGVuZXIobWVzc2FnZSwgbGlzdGVuZXIpIHtcclxuICAgIHRoaXMuX2Rpc3BhdGNoZXIuYWRkRXZlbnRMaXN0ZW5lcihcclxuICAgICAgdGhpcy5fY3JlYXRlTG9jYWxNZXNzYWdlKG1lc3NhZ2UpLFxyXG4gICAgICBsaXN0ZW5lclxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVucmVnaXN0ZXIgYW4gZXZlbnQuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBFdmVudCB0eXBlIG5hbWUuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgLSBBIGxpc3RlbmVyIGZ1bmN0aW9uIGdlbmVyYXRlZCB1c2luZyBfY3JlYXRlTGlzdGVuZXIuXHJcbiAgICovXHJcbiAgX3JlbW92ZUxpc3RlbmVyKG1lc3NhZ2UsIGxpc3RlbmVyKSB7XHJcbiAgICB0aGlzLl9kaXNwYXRjaGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXHJcbiAgICAgIHRoaXMuX2NyZWF0ZUxvY2FsTWVzc2FnZShtZXNzYWdlKSxcclxuICAgICAgbGlzdGVuZXJcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFeGVjdXRlIGEgZnVuY3Rpb24gd2hlbiBhIG1lc3NhZ2UgaXMgcmVjZWl2ZWQgZm9yIHRoaXMgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0byBsaXN0ZW4gZm9yLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBvbmNlIHRoZSBtZXNzYWdlIGlzIHJlY2VpdmVkLlxyXG4gICAqL1xyXG4gIGxpc3RlblRvKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XHJcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgQ2Fubm90IGFkZCBsaXN0ZW5lciBmb3IgJHttZXNzYWdlfSBvbiAke3RoaXMuaWR9LiBDYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24uYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9jYWxsYmFja3NbbWVzc2FnZV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aGlzLl9jYWxsYmFja3NbbWVzc2FnZV0gPSBbXTtcclxuICAgICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnNbbWVzc2FnZV0gPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBsaXN0ZW5lciA9IHRoaXMuX2NyZWF0ZUxpc3RlbmVyKGNhbGxiYWNrKTtcclxuICAgIHRoaXMuX2NhbGxiYWNrc1ttZXNzYWdlXS5wdXNoKGNhbGxiYWNrKTtcclxuICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJzW21lc3NhZ2VdLnB1c2gobGlzdGVuZXIpO1xyXG5cclxuICAgIHRoaXMuX2FkZExpc3RlbmVyKG1lc3NhZ2UsIGxpc3RlbmVyKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFByZXZlbnQgYSBmdW5jdGlvbiBmcm9tIGJlaW5nIGV4ZWN1dGVkIHdoZW4gYSBtZXNzYWdlIGlzIHJlY2VpdmVkIGZvciB0aGlzXHJcbiAgICogb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0byBzdG9wIGxpc3RlbmluZyBmb3IuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGNhbGxiYWNrIC0gT3B0aW9uYWwgY2FsbGJhY2sgdG8gcmVtb3ZlLiBJZiBub25lIGlzIGRlZmluZWQsXHJcbiAgICogcmVtb3ZlIGFsbCBjYWxsYmFja3MgZm9yIHRoZSBtZXNzYWdlLlxyXG4gICAqL1xyXG4gIHN0b3BMaXN0ZW5pbmcobWVzc2FnZSwgY2FsbGJhY2spIHtcclxuICAgIGlmICh0aGlzLl9jYWxsYmFja3NbbWVzc2FnZV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9IGVsc2UgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgd2FzIGRlZmluZWQsIGNhbGwgc3RvcExpc3RlbmluZyBvbiBhbGwgY2FsbGJhY2tzIGZvciB0aGUgbWVzc2FnZVxyXG4gICAgICBmb3IgKGxldCBpID0gdGhpcy5fY2FsbGJhY2tzW21lc3NhZ2VdLmxlbmd0aCAtIDE7IGkgPiAtMTsgaS0tKSB7XHJcbiAgICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nKG1lc3NhZ2UsIHRoaXMuX2NhbGxiYWNrc1ttZXNzYWdlXVtpXSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiBhIGNhbGxiYWNrIHdhcyBkZWZpbmVkLCBtYWtlIHN1cmUgaXQncyBhIGxpc3RlbmVyXHJcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX2NhbGxiYWNrc1ttZXNzYWdlXS5pbmRleE9mKGNhbGxiYWNrKTtcclxuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGxpc3RlbmVyID0gdGhpcy5fZXZlbnRMaXN0ZW5lcnNbbWVzc2FnZV1baW5kZXhdO1xyXG4gICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXIobWVzc2FnZSwgbGlzdGVuZXIpO1xyXG5cclxuICAgIHRoaXMuX2NhbGxiYWNrc1ttZXNzYWdlXS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnNbbWVzc2FnZV0uc3BsaWNlKGluZGV4LCAxKTtcclxuXHJcbiAgICBpZiAodGhpcy5fY2FsbGJhY2tzW21lc3NhZ2VdLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzW21lc3NhZ2VdO1xyXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRMaXN0ZW5lcnNbbWVzc2FnZV07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZS1yZWdpc3RlciBjYWxsYmFjayhzKSBmcm9tIGJlaW5nIGV4ZWN1dGVkIHdoZW4gbWVzc2FnZXMgbWF0Y2hpbmcgdGhlIGdpdmVuXHJcbiAgICogcmVndWxhciBleHByZXNzaW9uIGFyZSByZWNlaXZlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UmVnZXhwfSByZWdleHAgLSByZWdleHAgLSBUaGUgcmVndWxhciBleHByZXNzaW9uIHRvIGZpbHRlciBtZXNzYWdlcyB3aXRoLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBjYWxsYmFjayAtIE9wdGlvbmFsIGNhbGxiYWNrIHRvIHJlbW92ZS4gSWYgbm9uZSBpcyBkZWZpbmVkLFxyXG4gICAqIHJlbW92ZSBhbGwgY2FsbGJhY2tzIGZvciBtZXNzYWdlcyBtYXRjaGluZyB0aGUgcmVndWxhciBleHByZXNzaW9uLlxyXG4gICAqL1xyXG4gIHN0b3BMaXN0ZW5pbmdCeVJlZ2V4cChyZWdleHAsIGNhbGxiYWNrKSB7XHJcbiAgICBjb25zdCBtZXNzYWdlcyA9IE9iamVjdC5rZXlzKHRoaXMuX2NhbGxiYWNrcykuZmlsdGVyKG1lc3NhZ2UgPT4gcmVnZXhwLnRlc3QobWVzc2FnZSkpO1xyXG5cclxuICAgIG1lc3NhZ2VzLmZvckVhY2gobWVzc2FnZSA9PiB7XHJcbiAgICAgIHRoaXMuc3RvcExpc3RlbmluZyhtZXNzYWdlLCBjYWxsYmFjayk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFByZXZlbnQgYW55IGZ1bmN0aW9ucyBmcm9tIGJlaW5nIGV4ZWN1dGVkIHdoZW4gYW55IG1lc3NhZ2UgaXMgcmVjZWl2ZWQgZm9yXHJcbiAgICogdGhpcyBvYmplY3QuXHJcbiAgICovXHJcbiAgc3RvcExpc3RlbmluZ1RvQWxsKCkge1xyXG4gICAgY29uc3QgbWVzc2FnZXMgPSBPYmplY3Qua2V5cyh0aGlzLl9jYWxsYmFja3MpO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSBtZXNzYWdlcy5sZW5ndGggLSAxOyBpID4gLTE7IGktLSkge1xyXG4gICAgICB0aGlzLnN0b3BMaXN0ZW5pbmcobWVzc2FnZXNbaV0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2VuZCBhIG1lc3NhZ2UsIGNhdXNpbmcgbGlzdGVuZXIgZnVuY3Rpb25zIGZvciB0aGUgbWVzc2FnZSBvbiB0aGlzIG9iamVjdFxyXG4gICAqIHRvIGJlIGV4ZWN1dGVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0byBlbWl0LlxyXG4gICAqIEBwYXJhbSB7YW55PX0gdmFsdWUgLSBPcHRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGxpc3RlbmVyIGNhbGxiYWNrcy5cclxuICAgKi9cclxuICBlbWl0KG1lc3NhZ2UsIHZhbHVlKSB7XHJcbiAgICBpZiAodGhpcy5fY2FsbGJhY2tzW21lc3NhZ2VdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIG1lc3NhZ2UgPSB0aGlzLl9jcmVhdGVMb2NhbE1lc3NhZ2UobWVzc2FnZSk7XHJcbiAgICBjb25zdCBldmVudCA9IHRoaXMuX2NyZWF0ZUV2ZW50KG1lc3NhZ2UsIHZhbHVlKTtcclxuICAgIHRoaXMuX2Rpc3BhdGNoZXIuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFeGVjdXRlIGEgZnVuY3Rpb24gd2hlbiBhIG1lc3NhZ2UgaXMgcmVjZWl2ZWQgZm9yIHRoZSBnbG9iYWwgTWVzc2VuZ2VyIGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHN0YXRpY1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0byBsaXN0ZW4gZm9yLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBvbmNlIHRoZSBtZXNzYWdlIGlzIHJlY2VpdmVkLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBsaXN0ZW5UbyhtZXNzYWdlLCBjYWxsYmFjaywgbWVzc2VuZ2VyKSB7XHJcbiAgICB0aGlzLkdsb2JhbE1lc3Nlbmdlci5saXN0ZW5UbyhtZXNzYWdlLCBjYWxsYmFjaywgbWVzc2VuZ2VyKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFByZXZlbnQgYSBmdW5jdGlvbiBmcm9tIGJlaW5nIGV4ZWN1dGVkIHdoZW4gYSBtZXNzYWdlIGlzIHJlY2VpdmVkIGZvciB0aGVcclxuICAgKiBnbG9iYWwgTWVzc2VuZ2VyIGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHN0YXRpY1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0byBzdG9wIGxpc3RlbmluZyBmb3IuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGNhbGxiYWNrIC0gT3B0aW9uYWwgY2FsbGJhY2sgdG8gcmVtb3ZlLiBJZiBub25lIGlzIGRlZmluZWQsXHJcbiAgICogcmVtb3ZlIGFsbCBjYWxsYmFja3MgZm9yIHRoZSBtZXNzYWdlLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBzdG9wTGlzdGVuaW5nKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XHJcbiAgICB0aGlzLkdsb2JhbE1lc3Nlbmdlci5zdG9wTGlzdGVuaW5nKG1lc3NhZ2UsIGNhbGxiYWNrKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlLXJlZ2lzdGVyIGNhbGxiYWNrKHMpIGZyb20gYmVpbmcgZXhlY3V0ZWQgb24gdGhlIGdsb2JhbCBtZXNzZW5nZXJyIGluc3RhbmNlXHJcbiAgICogd2hlbiBtZXNzYWdlcyBtYXRjaGluZyB0aGUgZ2l2ZW4gcmVndWxhciBleHByZXNzaW9uIGFyZSByZWNlaXZlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UmVnZXhwfSByZWdleHAgLSByZWdleHAgLSBUaGUgcmVndWxhciBleHByZXNzaW9uIHRvIGZpbHRlciBtZXNzYWdlcyB3aXRoLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBjYWxsYmFjayAtIE9wdGlvbmFsIGNhbGxiYWNrIHRvIHJlbW92ZS4gSWYgbm9uZSBpcyBkZWZpbmVkLFxyXG4gICAqIHJlbW92ZSBhbGwgY2FsbGJhY2tzIGZvciBtZXNzYWdlcyBtYXRjaGluZyB0aGUgcmVndWxhciBleHByZXNzaW9uLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBzdG9wTGlzdGVuaW5nQnlSZWdleHAocmVnZXhwLCBjYWxsYmFjaykge1xyXG4gICAgY29uc3QgbWVzc2FnZXMgPSBPYmplY3Qua2V5cyh0aGlzLkdsb2JhbE1lc3Nlbmdlci5fY2FsbGJhY2tzKS5maWx0ZXIoXHJcbiAgICAgIG1lc3NhZ2UgPT4gcmVnZXhwLnRlc3QobWVzc2FnZSlcclxuICAgICk7XHJcblxyXG4gICAgbWVzc2FnZXMuZm9yRWFjaChtZXNzYWdlID0+IHtcclxuICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nKG1lc3NhZ2UsIGNhbGxiYWNrKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUHJldmVudCBhbnkgZnVuY3Rpb25zIGZyb20gYmVpbmcgZXhlY3V0ZWQgd2hlbiBhbnkgbWVzc2FnZSBpcyByZWNlaXZlZCBmb3JcclxuICAgKiB0aGUgZ2xvYmFsIE1lc3NlbmdlciBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBzdGF0aWNcclxuICAgKi9cclxuICBzdGF0aWMgc3RvcExpc3RlbmluZ1RvQWxsKCkge1xyXG4gICAgdGhpcy5HbG9iYWxNZXNzZW5nZXIuc3RvcExpc3RlbmluZ1RvQWxsKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZW5kIGEgbWVzc2FnZSwgY2F1c2luZyBsaXN0ZW5lciBmdW5jdGlvbnMgZm9yIHRoZSBtZXNzYWdlIG9uIHRoZSBnbG9iYWwgTWVzc2VuZ2VyXHJcbiAgICogaW5zdGFuY2UgdG8gYmUgZXhlY3V0ZWQuXHJcbiAgICpcclxuICAgKiBAc3RhdGljXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIFRoZSBtZXNzYWdlIHRvIGVtaXQuXHJcbiAgICogQHBhcmFtIHthbnk9fSB2YWx1ZSAtIE9wdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gbGlzdGVuZXIgY2FsbGJhY2tzLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBlbWl0KG1lc3NhZ2UsIHZhbHVlKSB7XHJcbiAgICB0aGlzLkdsb2JhbE1lc3Nlbmdlci5lbWl0KG1lc3NhZ2UsIHZhbHVlKTtcclxuICB9XHJcbn1cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE1lc3Nlbmdlciwge1xyXG4gIEdsb2JhbE1lc3Nlbmdlcjoge1xyXG4gICAgdmFsdWU6IG5ldyBNZXNzZW5nZXIoKSxcclxuICAgIHdyaXRhYmxlOiBmYWxzZSxcclxuICB9LFxyXG4gIEVWRU5UUzoge1xyXG4gICAgdmFsdWU6IHt9LFxyXG4gICAgd3JpdGFibGU6IGZhbHNlLFxyXG4gIH0sXHJcbn0pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTWVzc2VuZ2VyO1xyXG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXHJcbmltcG9ydCBNZXNzZW5nZXIgZnJvbSAnY29yZS9NZXNzZW5nZXInO1xyXG5cclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIGFsbCBob3N0IGZlYXR1cmVzLiBLZWVwcyBhIHJlZmVyZW5jZSB0byB0aGUgaG9zdCBvYmplY3QgbWFuYWdpbmdcclxuICogdGhlIGZlYXR1cmUuXHJcbiAqXHJcbiAqIEBhYnN0cmFjdFxyXG4gKlxyXG4gKiBAcHJvcGVydHkge09iamVjdH0gRVZFTlRTIC0gQnVpbHQtaW4gbWVzc2FnZXMgdGhhdCB0aGUgZmVhdHVyZSBlbWl0cy4gV2hlbiB0aGVcclxuICogZmVhdHVyZSBpcyBhZGRlZCB0byBhIHtAbGluayBjb3JlL0hvc3RPYmplY3R9LCBldmVudCBuYW1lcyB3aWxsIGJlIHByZWZpeGVkIGJ5IHRoZVxyXG4gKiBuYW1lIG9mIHRoZSBmZWF0dXJlIGNsYXNzICsgJy4nLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UUy51cGRhdGU9b25VcGRhdGVdIC0gTWVzc2FnZSB0aGF0IGlzIGVtaXR0ZWQgYWZ0ZXJcclxuICogZWFjaCBjYWxsIHRvIFt1cGRhdGVde0BsaW5rIEFic3RyYWN0SG9zdEZlYXR1cmUjdXBkYXRlfS5cclxuICogQHByb3BlcnR5IHtPYmplY3R9IFNFUlZJQ0VTIC0gQW55IEFXUyBzZXJ2aWNlcyB0aGF0IGFyZSBuZWNlc3NhcnkgZm9yIHRoZVxyXG4gKiBmZWF0dXJlIHRvIGZ1bmN0aW9uLlxyXG4gKi9cclxuY2xhc3MgQWJzdHJhY3RIb3N0RmVhdHVyZSB7XHJcbiAgLyoqXHJcbiAgICogQGNvbnN0cnVjdG9yXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2NvcmUvSG9zdE9iamVjdH0gaG9zdCAtIFRoZSBIb3N0T2JqZWN0IG1hbmFnaW5nIHRoZSBmZWF0dXJlLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGhvc3QpIHtcclxuICAgIHRoaXMuX2hvc3QgPSBob3N0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBhIG5hbWVzcGFjZSB0byB0aGUgaG9zdCB3aXRoIHRoZSBuYW1lIG9mIHRoZSBmZWF0dXJlIHRvIGNvbnRhaW4gcHJvcGVydGllc1xyXG4gICAqIGFuZCBtZXRob2RzIGZyb20gdGhlIGZlYXR1cmUgdGhhdCB1c2VycyBvZiB0aGUgaG9zdCBuZWVkIGFjY2VzcyB0by5cclxuICAgKi9cclxuICBpbnN0YWxsQXBpKCkge1xyXG4gICAgY29uc3QgZXZlbnRzID0ge307XHJcbiAgICBjb25zdCBhcGkgPSB7RVZFTlRTOiBldmVudHN9O1xyXG5cclxuICAgIC8vIEFkZCB0aGUgY2xhc3MgbmFtZSB0byBldmVudCBuYW1lc1xyXG4gICAgT2JqZWN0LmVudHJpZXModGhpcy5jb25zdHJ1Y3Rvci5FVkVOVFMpLmZvckVhY2goKFtuYW1lLCB2YWx1ZV0pID0+IHtcclxuICAgICAgZXZlbnRzW25hbWVdID0gYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfS4ke3ZhbHVlfWA7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLl9ob3N0W3RoaXMuY29uc3RydWN0b3IubmFtZV0gPSBhcGk7XHJcblxyXG4gICAgcmV0dXJuIGFwaTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIGhvc3QgdGhhdCBtYW5hZ2VzIHRoZSBmZWF0dXJlLlxyXG4gICAqXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGhvc3QoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faG9zdDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIGVuZ2luZSBvd25lciBvYmplY3Qgb2YgdGhlIGhvc3QuXHJcbiAgICpcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgb3duZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faG9zdC5vd25lcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExpc3RlbiB0byBhIGZlYXR1cmUgbWVzc2FnZSBmcm9tIHRoZSBob3N0IG9iamVjdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gTWVzc2FnZSB0byBsaXN0ZW4gZm9yLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiB0aGUgbWVzc2FnZSBpcyByZWNlaXZlZC5cclxuICAgKi9cclxuICBsaXN0ZW5UbyhtZXNzYWdlLCBjYWxsYmFjaykge1xyXG4gICAgdGhpcy5faG9zdC5saXN0ZW5UbyhtZXNzYWdlLCBjYWxsYmFjayk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMaXN0ZW4gdG8gYSBmZWF0dXJlIG1lc3NhZ2UgZnJvbSB0aGUgZ2xvYmFsIG1lc3Nlbmdlci4gRmVhdHVyZSBtZXNzYWdlcyB3aWxsXHJcbiAgICogYmUgcHJlZml4ZWQgd2l0aCB0aGUgY2xhc3MgbmFtZSBvZiB0aGUgZmVhdHVyZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gTWVzc2FnZSB0byBsaXN0ZW4gZm9yLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiB0aGUgbWVzc2FnZSBpcyByZWNlaXZlZC5cclxuICAgKi9cclxuICBzdGF0aWMgbGlzdGVuVG8obWVzc2FnZSwgY2FsbGJhY2spIHtcclxuICAgIG1lc3NhZ2UgPSBgJHt0aGlzLm5hbWV9LiR7bWVzc2FnZX1gO1xyXG4gICAgTWVzc2VuZ2VyLmxpc3RlblRvKG1lc3NhZ2UsIGNhbGxiYWNrKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0b3AgbGlzdGVuaW5nIHRvIGEgbWVzc2FnZSBmcm9tIHRoZSBob3N0IG9iamVjdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gTWVzc2FnZSB0byBzdG9wIGxpc3RlbmluZyBmb3IuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGNhbGxiYWNrIC0gT3B0aW9uYWwgY2FsbGJhY2sgdG8gcmVtb3ZlLiBJZiBub25lIGlzIGRlZmluZWQsXHJcbiAgICogcmVtb3ZlIGFsbCBjYWxsYmFja3MgZm9yIHRoZSBtZXNzYWdlLlxyXG4gICAqL1xyXG4gIHN0b3BMaXN0ZW5pbmcobWVzc2FnZSwgY2FsbGJhY2spIHtcclxuICAgIHRoaXMuX2hvc3Quc3RvcExpc3RlbmluZyhtZXNzYWdlLCBjYWxsYmFjayk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdG9wIGxpc3RlbmluZyB0byBhIG1lc3NhZ2UgZnJvbSB0aGUgZ2xvYmFsIG1lc3Nlbmdlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gTWVzc2FnZSB0byBzdG9wIGxpc3RlbmluZyBmb3IuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGNhbGxiYWNrIC0gT3B0aW9uYWwgY2FsbGJhY2sgdG8gcmVtb3ZlLiBJZiBub25lIGlzIGRlZmluZWQsXHJcbiAgICogcmVtb3ZlIGFsbCBjYWxsYmFja3MgZm9yIHRoZSBtZXNzYWdlLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBzdG9wTGlzdGVuaW5nKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XHJcbiAgICBtZXNzYWdlID0gYCR7dGhpcy5uYW1lfS4ke21lc3NhZ2V9YDtcclxuICAgIE1lc3Nlbmdlci5zdG9wTGlzdGVuaW5nKG1lc3NhZ2UsIGNhbGxiYWNrKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0b3AgbGlzdGVuaW5nIHRvIGEgbWVzc2FnZSBtYXRjaGluZyB0aGUgZ2l2ZW4gcmVndWxhciBleHByZXNzaW9uIGZyb20gdGhlXHJcbiAgICogaG9zdCBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1JlZ2V4cH0gcmVnZXhwIC0gVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBzdG9wIGxpc3RlbmluZyBmb3IuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGNhbGxiYWNrIC0gT3B0aW9uYWwgY2FsbGJhY2sgdG8gcmVtb3ZlLiBJZiBub25lIGlzIGRlZmluZWQsXHJcbiAgICogcmVtb3ZlIGFsbCBjYWxsYmFja3MgZm9yIHRoZSBtZXNzYWdlLlxyXG4gICAqL1xyXG4gIHN0b3BMaXN0ZW5pbmdCeVJlZ2V4cChyZWdleHAsIGNhbGxiYWNrKSB7XHJcbiAgICB0aGlzLl9ob3N0LnN0b3BMaXN0ZW5pbmdCeVJlZ2V4cChyZWdleHAsIGNhbGxiYWNrKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0b3AgbGlzdGVuaW5nIHRvIGEgbWVzc2FnZSBtYXRjaGluZyB0aGUgZ2l2ZW4gcmVndWxhciBleHByZXNzaW9uIGZyb20gdGhlXHJcbiAgICogZ2xvYmFsIG1lc3Nlbmdlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UmVnZXhwfSByZWdleHAgLSBUaGUgcmVndWxhciBleHByZXNzaW9uIHRvIHN0b3AgbGlzdGVuaW5nIGZvci5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gY2FsbGJhY2sgLSBPcHRpb25hbCBjYWxsYmFjayB0byByZW1vdmUuIElmIG5vbmUgaXMgZGVmaW5lZCxcclxuICAgKiByZW1vdmUgYWxsIGNhbGxiYWNrcyBmb3IgdGhlIG1lc3NhZ2UuXHJcbiAgICovXHJcbiAgc3RhdGljIHN0b3BMaXN0ZW5pbmdCeVJlZ2V4cChyZWdleHAsIGNhbGxiYWNrKSB7XHJcbiAgICByZWdleHAgPSBuZXcgUmVnRXhwKGBeJHt0aGlzLm5hbWV9LiR7cmVnZXhwLnNvdXJjZS5yZXBsYWNlKC9cXF4vLCAnJyl9YCk7XHJcbiAgICBNZXNzZW5nZXIuc3RvcExpc3RlbmluZ0J5UmVnZXhwKHJlZ2V4cCwgY2FsbGJhY2spO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RvcCBsaXN0ZW5pbmcgdG8gYWxsIG1lc3NhZ2VzLlxyXG4gICAqL1xyXG4gIHN0b3BMaXN0ZW5pbmdUb0FsbCgpIHtcclxuICAgIHRoaXMuX2hvc3Quc3RvcExpc3RlbmluZ1RvQWxsKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdG9wIGxpc3RlbmluZyB0byBhbGwgZmVhdHVyZSBtZXNzYWdlcy5cclxuICAgKi9cclxuICBzdGF0aWMgc3RvcExpc3RlbmluZ1RvQWxsKCkge1xyXG4gICAgTWVzc2VuZ2VyLnN0b3BMaXN0ZW5pbmdCeVJlZ2V4cChuZXcgUmVnRXhwKGBeJHt0aGlzLm5hbWV9LmApKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEVtaXQgZmVhdHVyZSBtZXNzYWdlcyBmcm9tIHRoZSBob3N0LiBGZWF0dXJlIG1lc3NhZ2VzIHdpbGwgYmUgcHJlZml4ZWQgd2l0aFxyXG4gICAqIHRoZSBjbGFzcyBuYW1lIG9mIHRoZSBmZWF0dXJlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0byBlbWl0LlxyXG4gICAqIEBwYXJhbSB7YW55PX0gdmFsdWUgLSBPcHRpb25hbCBwYXJhbWV0ZXIgdG8gcGFzcyB0byBsaXN0ZW5lciBjYWxsYmFja3MuXHJcbiAgICovXHJcbiAgZW1pdChtZXNzYWdlLCB2YWx1ZSkge1xyXG4gICAgbWVzc2FnZSA9IGAke3RoaXMuY29uc3RydWN0b3IubmFtZX0uJHttZXNzYWdlfWA7XHJcbiAgICB0aGlzLl9ob3N0LmVtaXQobWVzc2FnZSwgdmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRW1pdCBmZWF0dXJlIG1lc3NhZ2VzIGZyb20gdGhlIGdsb2JhbCBtZXNzZW5nZXIuIEZlYXR1cmUgbWVzc2FnZXMgd2lsbCBiZSBwcmVmaXhlZFxyXG4gICAqIHdpdGggdGhlIGNsYXNzIG5hbWUgb2YgdGhlIGZlYXR1cmUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIFRoZSBtZXNzYWdlIHRvIGVtaXQuXHJcbiAgICogQHBhcmFtIHthbnk9fSB2YWx1ZSAtIE9wdGlvbmFsIHBhcmFtZXRlciB0byBwYXNzIHRvIGxpc3RlbmVyIGNhbGxiYWNrcy5cclxuICAgKi9cclxuICBzdGF0aWMgZW1pdChtZXNzYWdlLCB2YWx1ZSkge1xyXG4gICAgbWVzc2FnZSA9IGAke3RoaXMubmFtZX0uJHttZXNzYWdlfWA7XHJcbiAgICBNZXNzZW5nZXIuZW1pdChtZXNzYWdlLCB2YWx1ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFeGVjdXRlcyBlYWNoIHRpbWUgdGhlIGhvc3QgaXMgdXBkYXRlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVRpbWUgLSBBbW91bnQgb2YgdGltZSBzaW5jZSB0aGUgbGFzdCBob3N0IHVwZGF0ZSB3YXNcclxuICAgKiBjYWxsZWQuXHJcbiAgICovXHJcbiAgdXBkYXRlKGRlbHRhVGltZSkge1xyXG4gICAgdGhpcy5lbWl0KHRoaXMuY29uc3RydWN0b3IuRVZFTlRTLnVwZGF0ZSwgZGVsdGFUaW1lKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENsZWFuIHVwIG9uY2UgdGhlIGZlYXR1cmUgaXMgbm8gbG9uZ2VyIGluIHVzZS4gUmVtb3ZlIHRoZSBmZWF0dXJlIG5hbWVzcGFjZVxyXG4gICAqIGZyb20gdGhlIGhvc3QgYW5kIHJlbW92ZSByZWZlcmVuY2UgdG8gdGhlIGhvc3QuXHJcbiAgICovXHJcbiAgZGlzY2FyZCgpIHtcclxuICAgIE9iamVjdC5rZXlzKHRoaXMuX2hvc3RbdGhpcy5jb25zdHJ1Y3Rvci5uYW1lXSkuZm9yRWFjaChuYW1lID0+IHtcclxuICAgICAgZGVsZXRlIHRoaXMuX2hvc3RbdGhpcy5jb25zdHJ1Y3Rvci5uYW1lXVtuYW1lXTtcclxuICAgIH0pO1xyXG5cclxuICAgIGRlbGV0ZSB0aGlzLl9ob3N0W3RoaXMuY29uc3RydWN0b3IubmFtZV07XHJcbiAgICBkZWxldGUgdGhpcy5faG9zdDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFwcGxpZXMgYSBzZXF1ZW5jZSBvZiBtaXhpbiBjbGFzcyBmYWN0b3J5IGZ1bmN0aW9ucyB0byB0aGlzIGNsYXNzIGFuZFxyXG4gICAqIHJldHVybnMgdGhlIHJlc3VsdC4gRWFjaCBmdW5jdGlvbiBpcyBleHBlY3RlZCB0byByZXR1cm4gYSBjbGFzcyB0aGF0XHJcbiAgICogZXh0ZW5kcyB0aGUgY2xhc3MgaXQgd2FzIGdpdmVuLiBUaGUgZnVuY3Rpb25zIGFyZSBhcHBsaWVkIGluIHRoZSBvcmRlclxyXG4gICAqIHRoYXQgcGFyYW1ldGVycyBhcmUgZ2l2ZW4sIG1lYW5pbmcgdGhhdCB0aGUgZmlyc3QgZmFjdG9yeSB3aWxsXHJcbiAgICogZXh0ZW5kIHRoaXMgYmFzZSBjbGFzcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IG1peGluQ2xhc3NGYWN0b3JpZXMgQ2xhc3MgZmFjdG9yeSBmdW5jdGlvbnMgdGhhdCB3aWxsXHJcbiAgICogYmUgYXBwbGllZC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtDbGFzc30gQSBjbGFzcyB0aGF0IGlzIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIGZhY3RvcnkgZnVuY3Rpb25zLlxyXG4gICAqIFRoZSByZXN1bHRpbmcgY2xhc3Mgd2lsbCBhbHdheXMgaW5oZXJpdCBmcm9tIEFic3RyYWN0SG9zdEZlYXR1cmUuXHJcbiAgICovXHJcbiAgc3RhdGljIG1peCguLi5taXhpbkNsYXNzRmFjdG9yaWVzKSB7XHJcbiAgICBsZXQgUmVzdWx0Q2xhc3MgPSB0aGlzO1xyXG5cclxuICAgIG1peGluQ2xhc3NGYWN0b3JpZXMuZm9yRWFjaChtaXhpbkNsYXNzRmFjdG9yeSA9PiB7XHJcbiAgICAgIFJlc3VsdENsYXNzID0gbWl4aW5DbGFzc0ZhY3RvcnkoUmVzdWx0Q2xhc3MpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIFJlc3VsdENsYXNzO1xyXG4gIH1cclxufVxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQWJzdHJhY3RIb3N0RmVhdHVyZSwge1xyXG4gIEVWRU5UUzoge1xyXG4gICAgdmFsdWU6IHtcclxuICAgICAgdXBkYXRlOiAnb25VcGRhdGUnLFxyXG4gICAgfSxcclxuICAgIHdyaXRhYmxlOiBmYWxzZSxcclxuICB9LFxyXG4gIFNFUlZJQ0VTOiB7XHJcbiAgICB2YWx1ZToge30sXHJcbiAgICB3cml0YWJsZTogZmFsc2UsXHJcbiAgfSxcclxufSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBBYnN0cmFjdEhvc3RGZWF0dXJlO1xyXG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXHJcbmltcG9ydCBNZXNzZW5nZXIgZnJvbSAnYXBwL01lc3Nlbmdlcic7XHJcbmltcG9ydCBBYnN0cmFjdEhvc3RGZWF0dXJlIGZyb20gJy4vQWJzdHJhY3RIb3N0RmVhdHVyZSc7XHJcbmltcG9ydCBVdGlscyBmcm9tICcuL1V0aWxzJztcclxuXHJcbi8qKlxyXG4gKiBPYmplY3QgdGhhdCBtYW5hZ2VzIGFjY2VzcyB0byBhbGwgSG9zdCBmZWF0dXJlcy4gQ29udGFpbnMgYSByZWZlcmVuY2UgdG9cclxuICogZW5naW5lLXNwZWNpZmljIHZpc3VhbHMgaWYgYXBwbGljYWJsZS5cclxuICpcclxuICogQGV4dGVuZHMgY29yZS9NZXNzZW5nZXJcclxuICogQGFsaWFzIGNvcmUvSG9zdE9iamVjdFxyXG4gKlxyXG4gKiBAcHJvcGVydHkge09iamVjdH0gRVZFTlRTIC0gQnVpbHQtaW4gbWVzc2FnZXMgdGhhdCB0aGUgTWVzc2VuZ2VyIGVtaXRzLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UUy51cGRhdGU9J29uVXBkYXRlJ10gLSBNZXNzYWdlIHRoYXQgaXMgZW1pdHRlZCBhZnRlclxyXG4gKiBlYWNoIGNhbGwgdG8gW3VwZGF0ZV17QGxpbmsgY29yZS9Ib3N0T2JqZWN0I3VwZGF0ZX0uXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLmFkZEZlYXR1cmU9J29uQWRkRmVhdHVyZSddIC0gTWVzc2FnZSB0aGF0IGlzIGVtaXR0ZWRcclxuICogYWZ0ZXIgZWFjaCBjYWxsIHRvIFthZGRGZWF0dXJlXXtAbGluayBjb3JlL0hvc3RPYmplY3QjYWRkRmVhdHVyZX0uXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLnJlbW92ZUZlYXR1cmU9J29uUmVtb3ZlRmVhdHVyZSddIC0gTWVzc2FnZSB0aGF0IGlzIGVtaXR0ZWRcclxuICogYWZ0ZXIgZWFjaCBjYWxsIHRvIFtyZW1vdmVGZWF0dXJlXXtAbGluayBjb3JlL0hvc3RPYmplY3QjcmVtb3ZlRmVhdHVyZX0uXHJcbiAqL1xyXG5jbGFzcyBIb3N0T2JqZWN0IGV4dGVuZHMgTWVzc2VuZ2VyIHtcclxuICAvKipcclxuICAgKiBAY29uc3RydWN0b3JcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBob3N0LlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucy5vd25lciAtIE9wdGlvbmFsIGVuZ2luZS1zcGVjaWZpYyBvd25lciBvZiB0aGUgaG9zdC5cclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcih7b3duZXIgPSB7fX0gPSB7fSkge1xyXG4gICAgLy8gSWYgYW4gb3duZXIgaXMgc3BlY2lmaWVkLCB1c2UgaXRzIGlkIGZvciBtZXNzYWdpbmdcclxuICAgIHN1cGVyKG93bmVyLmlkKTtcclxuXHJcbiAgICB0aGlzLl9vd25lciA9IG93bmVyO1xyXG4gICAgdGhpcy5fZmVhdHVyZXMgPSB7fTtcclxuICAgIHRoaXMuX3dhaXRzID0gW107XHJcbiAgICB0aGlzLl9sYXN0VXBkYXRlID0gdGhpcy5ub3c7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBlbmdpbmUgb3duZXIgb2JqZWN0IG9mIHRoZSBob3N0LlxyXG4gICAqXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cclxuICBnZXQgb3duZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fb3duZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHRpbWUgaW4gbWlsbGlzZWNvbmRzLlxyXG4gICAqXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgbm93KCkge1xyXG4gICAgcmV0dXJuIERhdGUubm93KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBhbW91bnQgb2YgdGltZSBpbiBtaWxsaXNlY29uZHMgc2luY2UgdXBkYXRlIHdhcyBsYXN0IGNhbGxlZC5cclxuICAgKlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IGRlbHRhVGltZSgpIHtcclxuICAgIHJldHVybiB0aGlzLm5vdyAtIHRoaXMuX2xhc3RVcGRhdGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgaW4gdGhlIGVuZ2luZSdzIHJlbmRlciBsb29wLiBFeGVjdXRlcyB1cGRhdGVcclxuICAgKiBsb29wcyBmb3IgYWxsIGZlYXR1cmVzLlxyXG4gICAqL1xyXG4gIHVwZGF0ZSgpIHtcclxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gdGhpcy5ub3c7XHJcbiAgICBjb25zdCBkdCA9IHRoaXMuZGVsdGFUaW1lO1xyXG5cclxuICAgIC8vIFByb2dyZXNzIHN0b3JlZCB3YWl0c1xyXG4gICAgdGhpcy5fd2FpdHMuZm9yRWFjaCh3YWl0ID0+IHtcclxuICAgICAgd2FpdC5leGVjdXRlKGR0KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFVwZGF0ZSBhbGwgZmVhdHVyZXNcclxuICAgIE9iamVjdC52YWx1ZXModGhpcy5fZmVhdHVyZXMpLmZvckVhY2goZmVhdHVyZSA9PiB7XHJcbiAgICAgIGZlYXR1cmUudXBkYXRlKGR0KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIE5vdGlmeSBsaXN0ZW5lcnMgYW4gdXBkYXRlIG9jY3VyZWRcclxuICAgIHRoaXMuZW1pdCh0aGlzLmNvbnN0cnVjdG9yLkVWRU5UUy51cGRhdGUsIGR0KTtcclxuXHJcbiAgICB0aGlzLl9sYXN0VXBkYXRlID0gY3VycmVudFRpbWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gYSBkZWZlcnJlZCBwcm9taXNlIHRoYXQgd2lsbCB3YWl0IGEgZ2l2ZW4gbnVtYmVyIG9mIHNlY29uZHMgYmVmb3JlXHJcbiAgICogcmVzb2x2aW5nLiBUaGUgaG9zdCB3aWxsIGNvbnRpbnVvdXNseSB1cGRhdGUgdGhlIHdhaXQgcHJvbWlzZSBkdXJpbmcgdGhlXHJcbiAgICogdXBkYXRlIGxvb3AgdW50aWwgaXQgcmVzb2x2ZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NlY29uZHM9MF0gLSBOdW1iZXIgb2Ygc2Vjb25kcyB0byB3YWl0IGJlZm9yZSByZXNvbHZpbmcuXHJcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIC0gT3B0aW9uYWwgb3B0aW9ucyBvYmplY3RcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbkZpbmlzaF0gLSBDYWxsYmFjayB0byBleGVjdXRlIG9uY2UgdGhlIHdhaXQgdGltZVxyXG4gICAqIGlzIG1ldC5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb3B0aW9ucy5vblByb2dyZXNzIC0gQ2FsbGJhY2sgdG8gZXhlY3V0ZSBlYWNoIHRpbWUgdGhlIHdhaXRcclxuICAgKiB0aW1lIHByb2dyZXNzZXMgdG93YXJkcyB0aGUgdGFyZ2V0IG51bWJlciBvZiBzZWNvbmRzLiBUaGUgYW1vdW50IG9mIHByb2dyZXNzXHJcbiAgICogYXMgYSAwLTEgcGVyY2VudGFnZSBpcyBwYXNzZWQgYXMgYW4gYXJndW1lbnQuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9wdGlvbnMub25DYW5jZWwgLSBDYWxsYmFjayB0byBleGVjdXRlIGlmIHRoZSB1c2VyIGNhbmNlbHNcclxuICAgKiB0aGUgd2FpdCBiZWZvcmUgY29tcGxldGlvbi5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb3B0aW9ucy5vbkVycm9yIC0gQ2FsbGJhY2sgdG8gZXhlY3V0ZSBpZiB0aGUgd2FpdCBzdG9wc1xyXG4gICAqIGJlY2F1c2UgYW4gZXJyb3IgaXMgZW5jb3VudGVyZWQuIFRoZSBlcnJvciBtZXNzYWdlIGlzIHBhc3NlZCBhcyBhIHBhcmFtZXRlci5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH1cclxuICAgKi9cclxuICB3YWl0KHNlY29uZHMsIHtvbkZpbmlzaCwgb25Qcm9ncmVzcywgb25DYW5jZWwsIG9uRXJyb3J9ID0ge30pIHtcclxuICAgIGNvbnN0IHdhaXQgPSBVdGlscy53YWl0KHNlY29uZHMsIHtvbkZpbmlzaCwgb25Qcm9ncmVzcywgb25DYW5jZWwsIG9uRXJyb3J9KTtcclxuICAgIHRoaXMuX3dhaXRzLnB1c2god2FpdCk7XHJcblxyXG4gICAgLy8gT25jZSB0aGUgd2FpdCBwcm9taXNlIGlzIG5vIGxvbmdlciBwZW5kaW5nIHJlbW92ZSBpdCBmcm9tIHRoZSB3YWl0cyBhcnJheVxyXG4gICAgY29uc3Qgb25Db21wbGV0ZSA9ICgpID0+IHtcclxuICAgICAgdGhpcy5fd2FpdHMuc3BsaWNlKHRoaXMuX3dhaXRzLmluZGV4T2Yod2FpdCksIDEpO1xyXG4gICAgfTtcclxuICAgIHdhaXQudGhlbihvbkNvbXBsZXRlLCBvbkNvbXBsZXRlKTtcclxuXHJcbiAgICByZXR1cm4gd2FpdDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluc3RhbnRpYXRlIGEgbmV3IEhvc3QgZmVhdHVyZSBhbmQgc3RvcmUgaXQuIEZlYXR1cmVzIG11c3QgaW5oZXJpdCBmcm9tXHJcbiAgICogQWJzdHJhY3RIb3N0RmVhdHVyZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Q2xhc3N9IEZlYXR1cmVDbGFzcyAtIENsYXNzIHRoYXQgd2lsbCBpbnN0YW50aWF0ZSB0aGUgZmVhdHVyZS4gTXVzdFxyXG4gICAqIGV4dGVuZCB7QGxpbmsgQWJzdHJhY3RIb3N0RmVhdHVyZX0uXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBbZm9yY2U9ZmFsc2VdIC0gV2hldGhlciBvciBub3QgdG8gb3ZlcndyaXRlIGFuIGV4aXN0aW5nXHJcbiAgICogZmVhdHVyZSBpZiBvbmUgb2YgdGhpcyB0eXBlIGFscmVhZHkgZXhpc3RzIG9uIHRoZSBvYmplY3QuXHJcbiAgICogQHBhcmFtICB7Li4uYW55fSBhcmdzIC0gQWRkaXRpb25hbCBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgRmVhdHVyZUNsYXNzXHJcbiAgICogY29uc3RydWN0b3IuIFRoZSBIb3N0T2JqZWN0IHdpbGwgYWx3YXlzIGJlIHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBXaGV0aGVyIG9yIG5vdCBhIGZlYXR1cmUgd2FzIHN1Y2Nlc3NmdWxseSBhZGRlZC5cclxuICAgKi9cclxuICBhZGRGZWF0dXJlKEZlYXR1cmVDbGFzcywgZm9yY2UgPSBmYWxzZSwgLi4uYXJncykge1xyXG4gICAgY29uc3QgaW5wdXRUeXBlID0gdHlwZW9mIEZlYXR1cmVDbGFzcztcclxuXHJcbiAgICAvLyBNYWtlIHN1cmUgdGhlIEZlYXR1cmVDbGFzcyBjYW4gYmUgZXhlY3V0ZWRcclxuICAgIGlmIChpbnB1dFR5cGUgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBDYW5ub3QgYWRkIGZlYXR1cmUgdG8gaG9zdCAke3RoaXMuaWR9LiBGZWF0dXJlQ2xhc3MgbXVzdCBiZSBhIGNsYXNzLmBcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgZmVhdHVyZSBpcyBhIGhvc3QgZmVhdHVyZVxyXG4gICAgZWxzZSBpZiAoIShGZWF0dXJlQ2xhc3MucHJvdG90eXBlIGluc3RhbmNlb2YgQWJzdHJhY3RIb3N0RmVhdHVyZSkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBDYW5ub3QgYWRkIGZlYXR1cmUgJHtGZWF0dXJlQ2xhc3MubmFtZX0gdG8gaG9zdCAke3RoaXMuaWR9LiBGZWF0dXJlQ2xhc3MgbXVzdCBleHRlbmQgQWJzdHJhY3RIb3N0RmVhdHVyZS5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgdGhlIEZlYXR1cmVDbGFzcyBhbHJlYWR5IGV4aXN0cyBvbiB0aGlzIG9iamVjdFxyXG4gICAgaWYgKHRoaXMuX2ZlYXR1cmVzW0ZlYXR1cmVDbGFzcy5uYW1lXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGlmIChmb3JjZSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICAgIGBGZWF0dXJlICR7RmVhdHVyZUNsYXNzLm5hbWV9IGFscmVhZHkgZXhpc3RzIG9uIGhvc3QgJHt0aGlzLmlkfS4gRXhpc3RpbmcgZmVhdHVyZSB3aWxsIGJlIG92ZXJ3cml0dGVuLmBcclxuICAgICAgICApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgIGBGZWF0dXJlICR7RmVhdHVyZUNsYXNzLm5hbWV9IGFscmVhZHkgZXhpc3RzIG9uIGhvc3QgJHt0aGlzLmlkfS4gVXNlICdmb3JjZScgYXJndW1lbnQgdG8gb3ZlcndyaXRlIHRoZSBmZWF0dXJlLmBcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgZmVhdHVyZVxyXG4gICAgY29uc3QgZmVhdHVyZSA9IG5ldyBGZWF0dXJlQ2xhc3ModGhpcywgLi4uYXJncyk7XHJcbiAgICBmZWF0dXJlLmluc3RhbGxBcGkoKTtcclxuXHJcbiAgICB0aGlzLl9mZWF0dXJlc1tGZWF0dXJlQ2xhc3MubmFtZV0gPSBmZWF0dXJlO1xyXG4gICAgdGhpcy5lbWl0KHRoaXMuY29uc3RydWN0b3IuRVZFTlRTLmFkZEZlYXR1cmUsIEZlYXR1cmVDbGFzcy5uYW1lKTtcclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSBhIGZlYXR1cmUgZnJvbSB0aGUgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVOYW1lIC0gTmFtZSBvZiB0aGUgdHlwZSBvZiBmZWF0dXJlIHRvIHJlbW92ZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAtIFdoZXRoZXIgb3Igbm90IGEgZmVhdHVyZSB3YXMgc3VjY2Vzc2Z1bGx5IHJlbW92ZWQuXHJcbiAgICovXHJcbiAgcmVtb3ZlRmVhdHVyZSh0eXBlTmFtZSkge1xyXG4gICAgaWYgKHRoaXMuX2ZlYXR1cmVzW3R5cGVOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICBgRmVhdHVyZSBvZiB0eXBlICR7dHlwZU5hbWV9IGRvZXMgbm90IGV4aXN0IG9uIGhvc3QgJHt0aGlzLmlkfS4gTm8gZmVhdHVyZSB3aWxsIGJlIHJlbW92ZWQuYFxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBSZW1vdmUgdGhlIGZlYXR1cmVcclxuICAgICAgdGhpcy5lbWl0KHRoaXMuY29uc3RydWN0b3IuRVZFTlRTLnJlbW92ZUZlYXR1cmUsIHR5cGVOYW1lKTtcclxuICAgICAgdGhpcy5fZmVhdHVyZXNbdHlwZU5hbWVdLmRpc2NhcmQoKTtcclxuICAgICAgZGVsZXRlIHRoaXMuX2ZlYXR1cmVzW3R5cGVOYW1lXTtcclxuXHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5kaWNhdGUgd2hldGhlciBhIHNwZWNpZmllZCBmZWF0dXJlIGlzIGluc3RhbGxlZCBvbiB0aGUgaG9zdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlTmFtZSAtIE5hbWUgb2YgdGhlIHR5cGUgb2YgZmVhdHVyZSB0byBsb29rIGZvci5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGhhc0ZlYXR1cmUodHlwZU5hbWUpIHtcclxuICAgIHJldHVybiAhIXRoaXMuX2ZlYXR1cmVzW3R5cGVOYW1lXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExpc3QgdGhlIG5hbWVzIG9mIHRoZSBmZWF0dXJlcyBpbnN0YWxsZWQgb24gdGhlIGhvc3QuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZz59XHJcbiAgICovXHJcbiAgbGlzdEZlYXR1cmVzKCkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2ZlYXR1cmVzKTtcclxuICB9XHJcbn1cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShIb3N0T2JqZWN0LCAnRVZFTlRTJywge1xyXG4gIHZhbHVlOiB7XHJcbiAgICAuLi5PYmplY3QuZ2V0UHJvdG90eXBlT2YoSG9zdE9iamVjdCkuRVZFTlRTLFxyXG4gICAgdXBkYXRlOiAnb25VcGRhdGUnLFxyXG4gICAgYWRkRmVhdHVyZTogJ29uQWRkRmVhdHVyZScsXHJcbiAgICByZW1vdmVGZWF0dXJlOiAnb25SZW1vdmVGZWF0dXJlJyxcclxuICB9LFxyXG4gIHdyaXRhYmxlOiBmYWxzZSxcclxufSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBIb3N0T2JqZWN0O1xyXG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBFYXNpbmdPYmplY3QgT2JqZWN0IGNvbnRhaW5pbmcgZWFzaW5nIGZ1bmN0aW9uc1xyXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBJbiAtIEVhc2luZyAnSW4nIGZ1bmN0aW9uLiBTaG91bGQgdXNlIHRoZSBzaWduYXR1cmUgKGs6bnVtYmVyKTpudW1iZXIuXHJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IE91dCAtIEVhc2luZyAnT3V0JyBmdW5jdGlvbi4gU2hvdWxkIHVzZSB0aGUgc2lnbmF0dXJlIChrOm51bWJlcik6bnVtYmVyLlxyXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBJbk91dCAtIEVhc2luZyAnSW5PdXQnIGZ1bmN0aW9uLiBTaG91bGQgdXNlIHRoZSBzaWduYXR1cmUgKGs6bnVtYmVyKTpudW1iZXIuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIExpbmVhciBFYXNpbmdcclxuICogQHR5cGUge0Vhc2luZ09iamVjdH1cclxuICovXHJcbmV4cG9ydCBjb25zdCBMaW5lYXIgPSB7XHJcbiAgTm9uZShrKSB7XHJcbiAgICByZXR1cm4gaztcclxuICB9LFxyXG4gIEluKGspIHtcclxuICAgIHJldHVybiBrO1xyXG4gIH0sXHJcbiAgT3V0KGspIHtcclxuICAgIHJldHVybiBrO1xyXG4gIH0sXHJcbiAgSW5PdXQoaykge1xyXG4gICAgcmV0dXJuIGs7XHJcbiAgfSxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBRdWFkcmF0aWMgRWFzaW5nXHJcbiAqIEB0eXBlIHtFYXNpbmdPYmplY3R9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgUXVhZHJhdGljID0ge1xyXG4gIEluKGspIHtcclxuICAgIHJldHVybiBrICogaztcclxuICB9LFxyXG4gIE91dChrKSB7XHJcbiAgICByZXR1cm4gayAqICgyIC0gayk7XHJcbiAgfSxcclxuICBJbk91dChrKSB7XHJcbiAgICBrICo9IDI7XHJcbiAgICBpZiAoayA8IDEpIHtcclxuICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIC0wLjUgKiAoLS1rICogKGsgLSAyKSAtIDEpO1xyXG4gIH0sXHJcbn07XHJcblxyXG4vKipcclxuICogQ3ViaWMgRWFzaW5nXHJcbiAqIEB0eXBlIHtFYXNpbmdPYmplY3R9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgQ3ViaWMgPSB7XHJcbiAgSW4oaykge1xyXG4gICAgcmV0dXJuIGsgKiBrICogaztcclxuICB9LFxyXG4gIE91dChrKSB7XHJcbiAgICByZXR1cm4gLS1rICogayAqIGsgKyAxO1xyXG4gIH0sXHJcbiAgSW5PdXQoaykge1xyXG4gICAgayAqPSAyO1xyXG4gICAgaWYgKGsgPCAxKSB7XHJcbiAgICAgIHJldHVybiAwLjUgKiBrICogayAqIGs7XHJcbiAgICB9XHJcblxyXG4gICAgayAtPSAyO1xyXG4gICAgcmV0dXJuIDAuNSAqIChrICogayAqIGsgKyAyKTtcclxuICB9LFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFF1YXJ0aWMgRWFzaW5nXHJcbiAqIEB0eXBlIHtFYXNpbmdPYmplY3R9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgUXVhcnRpYyA9IHtcclxuICBJbihrKSB7XHJcbiAgICByZXR1cm4gayAqIGsgKiBrICogaztcclxuICB9LFxyXG4gIE91dChrKSB7XHJcbiAgICByZXR1cm4gMSAtIC0tayAqIGsgKiBrICogaztcclxuICB9LFxyXG4gIEluT3V0KGspIHtcclxuICAgIGsgKj0gMjtcclxuICAgIGlmIChrIDwgMSkge1xyXG4gICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrICogaztcclxuICAgIH1cclxuXHJcbiAgICBrIC09IDI7XHJcbiAgICByZXR1cm4gLTAuNSAqIChrICogayAqIGsgKiBrIC0gMik7XHJcbiAgfSxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBRdWludGljIEVhc2luZ1xyXG4gKiBAdHlwZSB7RWFzaW5nT2JqZWN0fVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFF1aW50aWMgPSB7XHJcbiAgSW4oaykge1xyXG4gICAgcmV0dXJuIGsgKiBrICogayAqIGsgKiBrO1xyXG4gIH0sXHJcbiAgT3V0KGspIHtcclxuICAgIHJldHVybiAtLWsgKiBrICogayAqIGsgKiBrICsgMTtcclxuICB9LFxyXG4gIEluT3V0KGspIHtcclxuICAgIGsgKj0gMjtcclxuICAgIGlmIChrIDwgMSkge1xyXG4gICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrICogayAqIGs7XHJcbiAgICB9XHJcblxyXG4gICAgayAtPSAyO1xyXG4gICAgcmV0dXJuIDAuNSAqIChrICogayAqIGsgKiBrICogayArIDIpO1xyXG4gIH0sXHJcbn07XHJcblxyXG4vKipcclxuICogU2ludXNvaWRhbCBFYXNpbmdcclxuICogQHR5cGUge0Vhc2luZ09iamVjdH1cclxuICovXHJcbmV4cG9ydCBjb25zdCBTaW51c29pZGFsID0ge1xyXG4gIEluKGspIHtcclxuICAgIHJldHVybiAxIC0gTWF0aC5jb3MoKGsgKiBNYXRoLlBJKSAvIDIpO1xyXG4gIH0sXHJcbiAgT3V0KGspIHtcclxuICAgIHJldHVybiBNYXRoLnNpbigoayAqIE1hdGguUEkpIC8gMik7XHJcbiAgfSxcclxuICBJbk91dChrKSB7XHJcbiAgICByZXR1cm4gMC41ICogKDEgLSBNYXRoLmNvcyhNYXRoLlBJICogaykpO1xyXG4gIH0sXHJcbn07XHJcblxyXG4vKipcclxuICogRXhwb25lbnRpYWwgRWFzaW5nXHJcbiAqIEB0eXBlIHtFYXNpbmdPYmplY3R9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgRXhwb25lbnRpYWwgPSB7XHJcbiAgSW4oaykge1xyXG4gICAgcmV0dXJuIGsgPT09IDAgPyAwIDogMTAyNCAqKiAoayAtIDEpO1xyXG4gIH0sXHJcbiAgT3V0KGspIHtcclxuICAgIHJldHVybiBrID09PSAxID8gMSA6IDEgLSAyICoqICgtMTAgKiBrKTtcclxuICB9LFxyXG4gIEluT3V0KGspIHtcclxuICAgIGlmIChrID09PSAwKSB7XHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgaWYgKGsgPT09IDEpIHtcclxuICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcblxyXG4gICAgayAqPSAyO1xyXG4gICAgaWYgKGsgPCAxKSB7XHJcbiAgICAgIHJldHVybiAwLjUgKiAxMDI0ICoqIChrIC0gMSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMC41ICogKC0oMiAqKiAoLTEwICogKGsgLSAxKSkpICsgMik7XHJcbiAgfSxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaXJjdWxhciBFYXNpbmdcclxuICogQHR5cGUge0Vhc2luZ09iamVjdH1cclxuICovXHJcbmV4cG9ydCBjb25zdCBDaXJjdWxhciA9IHtcclxuICBJbihrKSB7XHJcbiAgICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gayAqIGspO1xyXG4gIH0sXHJcbiAgT3V0KGspIHtcclxuICAgIHJldHVybiBNYXRoLnNxcnQoMSAtIC0tayAqIGspO1xyXG4gIH0sXHJcbiAgSW5PdXQoaykge1xyXG4gICAgayAqPSAyO1xyXG4gICAgaWYgKGsgPCAxKSB7XHJcbiAgICAgIHJldHVybiAtMC41ICogKE1hdGguc3FydCgxIC0gayAqIGspIC0gMSk7XHJcbiAgICB9XHJcblxyXG4gICAgayAtPSAyO1xyXG4gICAgcmV0dXJuIDAuNSAqIChNYXRoLnNxcnQoMSAtIGsgKiBrKSArIDEpO1xyXG4gIH0sXHJcbn07XHJcblxyXG4vKipcclxuICogRWxhc3RpYyBFYXNpbmdcclxuICogQHR5cGUge0Vhc2luZ09iamVjdH1cclxuICovXHJcbmV4cG9ydCBjb25zdCBFbGFzdGljID0ge1xyXG4gIEluKGspIHtcclxuICAgIGxldCBzO1xyXG4gICAgbGV0IGEgPSAwLjE7XHJcbiAgICBjb25zdCBwID0gMC40O1xyXG5cclxuICAgIGlmIChrID09PSAwKSB7XHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChrID09PSAxKSB7XHJcbiAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghYSB8fCBhIDwgMSkge1xyXG4gICAgICBhID0gMTtcclxuICAgICAgcyA9IHAgLyA0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcyA9IChwICogTWF0aC5hc2luKDEgLyBhKSkgLyAoMiAqIE1hdGguUEkpO1xyXG4gICAgfVxyXG5cclxuICAgIGsgLT0gMTtcclxuICAgIHJldHVybiAtKGEgKiAyICoqICgxMCAqIGspICogTWF0aC5zaW4oKChrIC0gcykgKiAoMiAqIE1hdGguUEkpKSAvIHApKTtcclxuICB9LFxyXG4gIE91dChrKSB7XHJcbiAgICBsZXQgcztcclxuICAgIGxldCBhID0gMC4xO1xyXG4gICAgY29uc3QgcCA9IDAuNDtcclxuXHJcbiAgICBpZiAoayA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoayA9PT0gMSkge1xyXG4gICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWEgfHwgYSA8IDEpIHtcclxuICAgICAgYSA9IDE7XHJcbiAgICAgIHMgPSBwIC8gNDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHMgPSAocCAqIE1hdGguYXNpbigxIC8gYSkpIC8gKDIgKiBNYXRoLlBJKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYSAqIDIgKiogKC0xMCAqIGspICogTWF0aC5zaW4oKChrIC0gcykgKiAoMiAqIE1hdGguUEkpKSAvIHApICsgMTtcclxuICB9LFxyXG4gIEluT3V0KGspIHtcclxuICAgIGxldCBzO1xyXG4gICAgbGV0IGEgPSAwLjE7XHJcbiAgICBjb25zdCBwID0gMC40O1xyXG5cclxuICAgIGlmIChrID09PSAwKSB7XHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChrID09PSAxKSB7XHJcbiAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghYSB8fCBhIDwgMSkge1xyXG4gICAgICBhID0gMTtcclxuICAgICAgcyA9IHAgLyA0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcyA9IChwICogTWF0aC5hc2luKDEgLyBhKSkgLyAoMiAqIE1hdGguUEkpO1xyXG4gICAgfVxyXG5cclxuICAgIGsgKj0gMjtcclxuICAgIGlmIChrIDwgMSkge1xyXG4gICAgICBrIC09IDE7XHJcbiAgICAgIHJldHVybiAoXHJcbiAgICAgICAgLTAuNSAqIChhICogMiAqKiAoMTAgKiBrKSAqIE1hdGguc2luKCgoayAtIHMpICogKDIgKiBNYXRoLlBJKSkgLyBwKSlcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBrIC09IDE7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICBhICogMiAqKiAoLTEwICogaykgKiBNYXRoLnNpbigoKGsgLSBzKSAqICgyICogTWF0aC5QSSkpIC8gcCkgKiAwLjUgKyAxXHJcbiAgICApO1xyXG4gIH0sXHJcbn07XHJcblxyXG4vKipcclxuICogQmFjayBFYXNpbmdcclxuICogQHR5cGUge0Vhc2luZ09iamVjdH1cclxuICovXHJcbmV4cG9ydCBjb25zdCBCYWNrID0ge1xyXG4gIEluKGspIHtcclxuICAgIGNvbnN0IHMgPSAxLjcwMTU4O1xyXG4gICAgcmV0dXJuIGsgKiBrICogKChzICsgMSkgKiBrIC0gcyk7XHJcbiAgfSxcclxuICBPdXQoaykge1xyXG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XHJcbiAgICByZXR1cm4gLS1rICogayAqICgocyArIDEpICogayArIHMpICsgMTtcclxuICB9LFxyXG4gIEluT3V0KGspIHtcclxuICAgIGNvbnN0IHMgPSAxLjcwMTU4ICogMS41MjU7XHJcbiAgICBrICo9IDI7XHJcbiAgICBpZiAoayA8IDEpIHtcclxuICAgICAgcmV0dXJuIDAuNSAqIChrICogayAqICgocyArIDEpICogayAtIHMpKTtcclxuICAgIH1cclxuXHJcbiAgICBrIC09IDI7XHJcbiAgICByZXR1cm4gMC41ICogKGsgKiBrICogKChzICsgMSkgKiBrICsgcykgKyAyKTtcclxuICB9LFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEJvdW5jZSBFYXNpbmdcclxuICogQHR5cGUge0Vhc2luZ09iamVjdH1cclxuICovXHJcbmV4cG9ydCBjb25zdCBCb3VuY2UgPSB7XHJcbiAgSW4oaykge1xyXG4gICAgcmV0dXJuIDEgLSBCb3VuY2UuT3V0KDEgLSBrKTtcclxuICB9LFxyXG4gIE91dChrKSB7XHJcbiAgICBpZiAoayA8IDEgLyAyLjc1KSB7XHJcbiAgICAgIHJldHVybiA3LjU2MjUgKiBrICogaztcclxuICAgIH0gZWxzZSBpZiAoayA8IDIgLyAyLjc1KSB7XHJcbiAgICAgIGsgLT0gMS41O1xyXG4gICAgICByZXR1cm4gNy41NjI1ICogKGsgLyAyLjc1KSAqIGsgKyAwLjc1O1xyXG4gICAgfSBlbHNlIGlmIChrIDwgMi41IC8gMi43NSkge1xyXG4gICAgICBrIC09IDIuMjU7XHJcbiAgICAgIHJldHVybiA3LjU2MjUgKiAoayAvIDIuNzUpICogayArIDAuOTM3NTtcclxuICAgIH1cclxuICAgIGsgLT0gMi42MjU7XHJcbiAgICByZXR1cm4gNy41NjI1ICogKGsgLyAyLjc1KSAqIGsgKyAwLjk4NDM3NTtcclxuICB9LFxyXG4gIEluT3V0KGspIHtcclxuICAgIGlmIChrIDwgMC41KSB7XHJcbiAgICAgIHJldHVybiBCb3VuY2UuSW4oayAqIDIpICogMC41O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEJvdW5jZS5PdXQoayAqIDIgLSAxKSAqIDAuNSArIDAuNTtcclxuICB9LFxyXG59O1xyXG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXHJcblxyXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtY2xhc3Nlcy1wZXItZmlsZSAqL1xyXG5pbXBvcnQgSG9zdE9iamVjdCBmcm9tICdjb3JlL0hvc3RPYmplY3QnO1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIGZhY3RvcnkgaW50ZXJmYWNlIGZvciBmZWF0dXJlcyB0aGF0IGFyZSBkZXBlbmRlbnQgb24gb3RoZXIgZmVhdHVyZXMgYmVpbmdcclxuICogcHJlc2VudCBvbiB0aGUgaG9zdC4gRXZlbnQgZGVwZW5kZW5jaWVzIHdpbGwgYmUgbGlzdGVuZWQgZm9yIHdoZW4gYSBmZWF0dXJlIG9mXHJcbiAqIG1hdGNoaW5nIHR5cGUgaXMgYWRkZWQgdG8gdGhlIGhvc3QgYW5kIHdpbGwgc3RvcCBiZWluZyBsaXN0ZW5lZCBmb3Igd2hlbiBvbmVcclxuICogaXMgcmVtb3ZlZC4gSWYgdGhlIGZlYXR1cmUgaXMgYWxyZWFkeSBwcmVzZW50IHdoZW4gY29uc3RydWN0ZWQsIGV2ZW50cyB3aWxsXHJcbiAqIGJlIGxpc3RlbmVkIGZvciByaWdodCBhd2F5LlxyXG4gKlxyXG4gKiBAaW50ZXJmYWNlXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBFVkVOVF9ERVBFTkRFTkNJRVMgLSBFdmVudHMgdGhhdCB0aGUgZmVhdHVyZSBzaG91bGQgc3RhcnQvc3RvcFxyXG4gKiBsaXN0ZW5pbmcgZm9yIHdoZW4gYSBmZWF0dXJlIG9mIHR5cGUgRmVhdHVyZU5hbWUgaXMgYWRkZWQvcmVtb3ZlZCBmcm9tIHRoZSBob3N0LlxyXG4gKiBFdmVudCBkZXBlbmRlbmNpZXMgc2hvdWxkIGZvbGxvdyB0aGUgc2lnbmF0dXJlOlxyXG4gKiAgeyBGZWF0dXJlTmFtZTogeyBldmVudE5hbWU6IGNhbGxiYWNrTmFtZSwgLi4uIH0sIC4uLiB9XHJcbiAqL1xyXG5jbGFzcyBGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlIHtcclxuICAvKipcclxuICAgKiBTdGFydCBsaXN0ZW5pbmcgZm9yIGV2ZW50IGRlcGVuZGVuY2llcyB0aGF0IG1hdGNoIHRoZSBnaXZlbiBmZWF0dXJlIHR5cGUuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVOYW1lIC0gdHlwZSBvZiBmZWF0dXJlIHRvIGxpc3RlbiBmb3IuXHJcbiAgICovXHJcbiAgX29uRmVhdHVyZUFkZGVkKHR5cGVOYW1lKSB7fVxyXG5cclxuICAvKipcclxuICAgKiBTdG9wIGxpc3RlbmluZyBmb3IgZXZlbnQgZGVwZW5kZW5jaWVzIHRoYXQgbWF0Y2ggdGhlIGdpdmVuIGZlYXR1cmUgdHlwZS5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZU5hbWUgLSB0eXBlIG9mIGZlYXR1cmUgdG8gc3RvcCBsaXN0ZW5pbmcgZm9yLlxyXG4gICAqL1xyXG4gIF9vbkZlYXR1cmVSZW1vdmVkKHR5cGVOYW1lKSB7fVxyXG5cclxuICAvKipcclxuICAgKiBAYXVnbWVudHMge0BsaW5rIEFic3RyYWN0SG9zdEZlYXR1cmUjZGlzY2FyZH1cclxuICAgKi9cclxuICBkaXNjYXJkKCkge31cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIGNsYXNzIHRoYXQgaW1wbGVtZW50cyB7QGxpbmsgRmVhdHVyZURlcGVuZGVudEludGVyZmFjZX0gYW5kIGV4dGVuZHNcclxuICAgKiBhIHNwZWNpZmllZCBiYXNlIGNsYXNzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtDbGFzc30gQmFzZUNsYXNzIC0gVGhlIGNsYXNzIHRvIGV4dGVuZC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0NsYXNzfSBBIGNsYXNzIHRoYXQgZXh0ZW5kcyBgQmFzZUNsYXNzYCBhbmQgaW1wbGVtZW50cyB7QGxpbmsgRmVhdHVyZURlcGVuZGVudEludGVyZmFjZX0uXHJcbiAgICovXHJcbiAgc3RhdGljIE1peGluKEJhc2VDbGFzcykge1xyXG4gICAgY29uc3QgRmVhdHVyZURlcGVuZGVudE1peGluID0gY2xhc3MgZXh0ZW5kcyBCYXNlQ2xhc3Mge1xyXG4gICAgICBjb25zdHJ1Y3Rvcihob3N0KSB7XHJcbiAgICAgICAgc3VwZXIoaG9zdCk7XHJcbiAgICAgICAgdGhpcy5faG9zdCA9IGhvc3Q7XHJcblxyXG4gICAgICAgIC8vIE5vIG5lZWQgdG8gbGlzdGVuIGZvciBldmVudHMgaWYgdGhlIG1peGluIGlzIGluIHRoZSBwcm90b3R5cGUgY2hhaW4gbXVsdGlwbGUgdGltZXNcclxuICAgICAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgLy8gU3RhcnQgbGlzdGVuaW5nIGZvciBmZWF0dXJlIGV2ZW50c1xyXG4gICAgICAgICAgdGhpcy5fb25GZWF0dXJlQWRkZWQgPSB0aGlzLl9vbkZlYXR1cmVBZGRlZC5iaW5kKHRoaXMpO1xyXG4gICAgICAgICAgdGhpcy5fb25GZWF0dXJlUmVtb3ZlZCA9IHRoaXMuX29uRmVhdHVyZVJlbW92ZWQuYmluZCh0aGlzKTtcclxuXHJcbiAgICAgICAgICB0aGlzLl9ob3N0Lmxpc3RlblRvKFxyXG4gICAgICAgICAgICBIb3N0T2JqZWN0LkVWRU5UUy5hZGRGZWF0dXJlLFxyXG4gICAgICAgICAgICB0aGlzLl9vbkZlYXR1cmVBZGRlZFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIHRoaXMuX2hvc3QubGlzdGVuVG8oXHJcbiAgICAgICAgICAgIEhvc3RPYmplY3QuRVZFTlRTLnJlbW92ZUZlYXR1cmUsXHJcbiAgICAgICAgICAgIHRoaXMuX29uRmVhdHVyZVJlbW92ZWRcclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgLy8gUmVnaXN0ZXIgZmVhdHVyZXMgdGhhdCBhbHJlYWR5IGV4aXN0XHJcbiAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmNvbnN0cnVjdG9yLkVWRU5UX0RFUEVOREVOQ0lFUykuZm9yRWFjaCh0eXBlTmFtZSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9ob3N0W3R5cGVOYW1lXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5fb25GZWF0dXJlQWRkZWQodHlwZU5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIF9vbkZlYXR1cmVBZGRlZCh0eXBlTmFtZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLkVWRU5UX0RFUEVOREVOQ0lFU1t0eXBlTmFtZV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgY29uc3QgZXZlbnRzID0gdGhpcy5jb25zdHJ1Y3Rvci5FVkVOVF9ERVBFTkRFTkNJRVNbdHlwZU5hbWVdO1xyXG5cclxuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGV2ZW50cykuZm9yRWFjaCgoW2V2ZW50TmFtZSwgY2FsbGJhY2tdKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXNbY2FsbGJhY2tdID0gdGhpc1tjYWxsYmFja10uYmluZCh0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5faG9zdC5saXN0ZW5UbyhcclxuICAgICAgICAgICAgICB0aGlzLl9ob3N0W3R5cGVOYW1lXS5FVkVOVFNbZXZlbnROYW1lXSxcclxuICAgICAgICAgICAgICB0aGlzW2NhbGxiYWNrXVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBfb25GZWF0dXJlUmVtb3ZlZCh0eXBlTmFtZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLkVWRU5UX0RFUEVOREVOQ0lFU1t0eXBlTmFtZV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgY29uc3QgZXZlbnRzID0gdGhpcy5jb25zdHJ1Y3Rvci5FVkVOVF9ERVBFTkRFTkNJRVNbdHlwZU5hbWVdO1xyXG5cclxuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGV2ZW50cykuZm9yRWFjaCgoW2V2ZW50TmFtZSwgY2FsbGJhY2tdKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hvc3Quc3RvcExpc3RlbmluZyhcclxuICAgICAgICAgICAgICB0aGlzLl9ob3N0W3R5cGVOYW1lXS5FVkVOVFNbZXZlbnROYW1lXSxcclxuICAgICAgICAgICAgICB0aGlzW2NhbGxiYWNrXVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBkaXNjYXJkKCkge1xyXG4gICAgICAgIC8vIFN0b3AgbGlzdGVuaW5nIGZvciBmZWF0dXJlIGV2ZW50c1xyXG4gICAgICAgIHRoaXMuX2hvc3Quc3RvcExpc3RlbmluZyhcclxuICAgICAgICAgIEhvc3RPYmplY3QuRVZFTlRTLmFkZEZlYXR1cmUsXHJcbiAgICAgICAgICB0aGlzLl9vbkZlYXR1cmVBZGRlZFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdGhpcy5faG9zdC5zdG9wTGlzdGVuaW5nKFxyXG4gICAgICAgICAgSG9zdE9iamVjdC5FVkVOVFMucmVtb3ZlRmVhdHVyZSxcclxuICAgICAgICAgIHRoaXMuX29uRmVhdHVyZVJlbW92ZWRcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBTdG9wIGxpc3RlbmluZyB0byBmZWF0dXJlLXNwZWNpZmljIGV2ZW50c1xyXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuY29uc3RydWN0b3IuRVZFTlRfREVQRU5ERU5DSUVTKS5mb3JFYWNoKHR5cGVOYW1lID0+IHtcclxuICAgICAgICAgIGlmICh0aGlzLl9ob3N0W3R5cGVOYW1lXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX29uRmVhdHVyZVJlbW92ZWQodHlwZU5hbWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBzdXBlci5kaXNjYXJkKCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgRVZFTlRfREVQRU5ERU5DSUVTID0gQmFzZUNsYXNzLkVWRU5UX0RFUEVOREVOQ0lFUyB8fCB7fTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhGZWF0dXJlRGVwZW5kZW50TWl4aW4sIHtcclxuICAgICAgRVZFTlRfREVQRU5ERU5DSUVTOiB7XHJcbiAgICAgICAgdmFsdWU6IHtcclxuICAgICAgICAgIC4uLkVWRU5UX0RFUEVOREVOQ0lFUyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBGZWF0dXJlRGVwZW5kZW50TWl4aW47XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogRXZlbnQgZGVwZW5kZW5jaWVzIHNob3VsZCBmb2xsb3cgdGhlIHNpZ25hdHVyZTpcclxuICoge1xyXG4gKiAgRmVhdHVyZU5hbWU6IHtcclxuICogICAgLy8gRXZlbnRzIHRoYXQgdGhlIGZlYXR1cmUgc2hvdWxkIHN0YXJ0L3N0b3AgbGlzdGVuaW5nIGZvciB3aGVuIGEgZmVhdHVyZVxyXG4gKiAgICAvLyBvZiB0eXBlIEZlYXR1cmVOYW1lIGlzIGFkZGVkL3JlbW92ZWQgZnJvbSB0aGUgaG9zdFxyXG4gKiAgICB7XHJcbiAqICAgICAgZXZlbnROYW1lOiBjYWxsYmFja05hbWUsXHJcbiAqICAgICAgLi4uXHJcbiAqICAgIH0sXHJcbiAqICB9XHJcbiAqIH1cclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UsIHtcclxuICBFVkVOVF9ERVBFTkRFTkNJRVM6IHtcclxuICAgIHZhbHVlOiB7fSxcclxuICAgIHdyaXRhYmxlOiBmYWxzZSxcclxuICB9LFxyXG59KTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2U7XHJcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcclxuXHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXHJcbi8qIGVzbGludC1kaXNhYmxlIG1heC1jbGFzc2VzLXBlci1maWxlICovXHJcbmltcG9ydCBGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlIGZyb20gJ2NvcmUvRmVhdHVyZURlcGVuZGVudEludGVyZmFjZSc7XHJcblxyXG4vKipcclxuICogQ2xhc3MgZmFjdG9yeSBpbnRlcmZhY2UgZm9yIGZlYXR1cmVzIHRoYXQgYXJlIGRlcGVuZGVudCBvbiB0aGUgQW5pbWF0aW9uRmVhdHVyZVxyXG4gKiBiZWluZyBwcmVzZW50IG9uIHRoZSBob3N0LiBMYXllciBhbmQgYW5pbWF0aW9uIGV2ZW50cyB3aWxsIGF1dG9tYXRpY2FsbHkgYmVcclxuICogbGlzdGVuZWQgZm9yIG9uY2UgYSBBbmltYXRpb25GZWF0dXJlIGlzIGFkZGVkIHRvIHRoZSBob3N0IGFuZCBzdG9wcGVkIG9uY2UgaXRcclxuICogaXMgcmVtb3ZlZC5cclxuICpcclxuICogQGludGVyZmFjZVxyXG4gKiBAZXh0ZW5kcyBGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBFVkVOVF9ERVBFTkRFTkNJRVMgLSBFdmVudHMgdGhhdCB0aGUgZmVhdHVyZSBzaG91bGQgc3RhcnQvc3RvcFxyXG4gKiBsaXN0ZW5pbmcgZm9yIHdoZW4gYSBmZWF0dXJlIG9mIHR5cGUgRmVhdHVyZU5hbWUgaXMgYWRkZWQvcmVtb3ZlZCBmcm9tIHRoZSBob3N0LlxyXG4gKiBAcHJvcGVydHkge09iamVjdH0gRVZFTlRfREVQRU5ERU5DSUVTLkFuaW1hdGlvbkZlYXR1cmUgLSBFdmVudHMgdGhhdCBhcmVcclxuICogc3BlY2lmaWMgdG8gdGhlIEFuaW1hdGlvbkZlYXR1cmUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRfREVQRU5ERU5DSUVTLkFuaW1hdGlvbkZlYXR1cmUuYWRkTGF5ZXI9J19vbkxheWVyQWRkZWQnXSAtXHJcbiAqIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gQW5pbWF0aW9uRmVhdHVyZSBhZGRMYXllclxyXG4gKiBldmVudHMgYXJlIGVtaXR0ZWQuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRfREVQRU5ERU5DSUVTLkFuaW1hdGlvbkZlYXR1cmUucmVtb3ZlTGF5ZXI9J19vbkxheWVyUmVtb3ZlZCddIC1cclxuICogVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBBbmltYXRpb25GZWF0dXJlIHJlbW92ZUxheWVyXHJcbiAqIGV2ZW50cyBhcmUgZW1pdHRlZC5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVF9ERVBFTkRFTkNJRVMuQW5pbWF0aW9uRmVhdHVyZS5yZW5hbWVMYXllcj0nX29uTGF5ZXJSZW5hbWVkJ10gLVxyXG4gKiBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIEFuaW1hdGlvbkZlYXR1cmUgcmVuYW1lTGF5ZXJcclxuICogZXZlbnRzIGFyZSBlbWl0dGVkLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UX0RFUEVOREVOQ0lFUy5BbmltYXRpb25GZWF0dXJlLmFkZEFuaW1hdGlvbj0nX29uQW5pbWF0aW9uQWRkZWQnXSAtXHJcbiAqIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gQW5pbWF0aW9uRmVhdHVyZSBhZGRBbmltYXRpb25cclxuICogZXZlbnRzIGFyZSBlbWl0dGVkLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UX0RFUEVOREVOQ0lFUy5BbmltYXRpb25GZWF0dXJlLnJlbW92ZUFuaW1hdGlvbj0nX29uQW5pbWF0aW9uUmVtb3ZlZCddIC1cclxuICogVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBBbmltYXRpb25GZWF0dXJlIHJlbW92ZUFuaW1hdGlvblxyXG4gKiBldmVudHMgYXJlIGVtaXR0ZWQuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRfREVQRU5ERU5DSUVTLkFuaW1hdGlvbkZlYXR1cmUucmVuYW1lQW5pbWF0aW9uPSdfb25BbmltYXRpb25SZW5hbWVkJ10gLVxyXG4gKiBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIEFuaW1hdGlvbkZlYXR1cmUgcmVuYW1lQW5pbWF0aW9uXHJcbiAqIGV2ZW50cyBhcmUgZW1pdHRlZC5cclxuICovXHJcbmNsYXNzIEFuaW1hdGlvbkZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UgZXh0ZW5kcyBGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlIHtcclxuICAvKipcclxuICAgKiBFeGVjdXRlZCB3aGVuIGFuaW1hdGlvbiBsYXllciBhZGRlZCBldmVudHMgYXJlIGNhdWdodC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRoYXQgd2FzIGFkZGVkLlxyXG4gICAqL1xyXG4gIF9vbkxheWVyQWRkZWQoe25hbWV9KSB7fVxyXG5cclxuICAvKipcclxuICAgKiBFeGVjdXRlZCB3aGVuIGFuaW1hdGlvbiBsYXllciByZW1vdmVkIGV2ZW50cyBhcmUgY2F1Z2h0LlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCB3YXMgcmVtb3ZlZC5cclxuICAgKi9cclxuICBfb25MYXllclJlbW92ZWQoe25hbWV9KSB7fVxyXG5cclxuICAvKipcclxuICAgKiBFeGVjdXRlZCB3aGVuIGFuaW1hdGlvbiBsYXllciByZW5hbWVkIGV2ZW50cyBhcmUgY2F1Z2h0LlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvbGROYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCB3YXMgcmVuYW1lZC5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3TmFtZSAtIE5ldyBuYW1lIG9mIHRoZSBsYXllci5cclxuICAgKi9cclxuICBfb25MYXllclJlbmFtZWQoe29sZE5hbWUsIG5ld05hbWV9KSB7fVxyXG5cclxuICAvKipcclxuICAgKiBFeGVjdXRlZCB3aGVuIGFuaW1hdGlvbiBhZGRlZCBldmVudHMgYXJlIGNhdWdodC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCBhbiBhbmltYXRpb24gd2FzIGFkZGVkIHRvLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbmltYXRpb25OYW1lIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRoYXQgd2FzIGFkZGVkLlxyXG4gICAqL1xyXG4gIF9vbkFuaW1hdGlvbkFkZGVkKHtsYXllck5hbWUsIGFuaW1hdGlvbk5hbWV9KSB7fVxyXG5cclxuICAvKipcclxuICAgKiBFeGVjdXRlZCB3aGVuIGFuaW1hdGlvbiByZW1vdmVkIGV2ZW50cyBhcmUgY2F1Z2h0LlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0aGF0IGFuIGFuaW1hdGlvbiB3YXMgcmVtb3ZlZCBmcm9tLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbmltYXRpb25OYW1lIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRoYXQgd2FzIHJlbW92ZWQuXHJcbiAgICovXHJcbiAgX29uQW5pbWF0aW9uUmVtb3ZlZCh7bGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lfSkge31cclxuXHJcbiAgLyoqXHJcbiAgICogRXhlY3V0ZWQgd2hlbiBhbmltYXRpb24gcmVuYW1lZCBldmVudHMgYXJlIGNhdWdodC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCBhbiBhbmltYXRpb24gYmVsb25ncyB0by5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gb2xkTmFtZSAtIE5hbWUgb2YgdGhlIGFuaW1hdGlvbiB0aGF0IHdhcyByZW5hbWVkLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdOYW1lIC0gTmV3IG5hbWUgb2YgdGhlIGFuaW1hdGlvbi5cclxuICAgKi9cclxuICBfb25BbmltYXRpb25SZW5hbWVkKHtsYXllck5hbWUsIG9sZE5hbWUsIG5ld05hbWV9KSB7fVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgY2xhc3MgdGhhdCBpbXBsZW1lbnRzIHtAbGluayBBbmltYXRpb25GZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlfVxyXG4gICAqIGFuZCBleHRlbmRzIGEgc3BlY2lmaWVkIGJhc2UgY2xhc3MuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0NsYXNzfSBCYXNlQ2xhc3MgLSBUaGUgY2xhc3MgdG8gZXh0ZW5kLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Q2xhc3N9IEEgY2xhc3MgdGhhdCBleHRlbmRzIGBCYXNlQ2xhc3NgIGFuZCBpbXBsZW1lbnRzIHtAbGluayBBbmltYXRpb25GZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlfS5cclxuICAgKi9cclxuICBzdGF0aWMgTWl4aW4oQmFzZUNsYXNzKSB7XHJcbiAgICBjb25zdCBQYXJlbnRDbGFzcyA9IEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UuTWl4aW4oQmFzZUNsYXNzKTtcclxuICAgIGNvbnN0IEFuaW1hdGlvbkZlYXR1cmVEZXBlbmRlbnRNaXhpbiA9IGNsYXNzIGV4dGVuZHMgUGFyZW50Q2xhc3Mge1xyXG4gICAgICBfb25MYXllckFkZGVkKHtuYW1lfSkge31cclxuXHJcbiAgICAgIF9vbkxheWVyUmVtb3ZlZCh7bmFtZX0pIHt9XHJcblxyXG4gICAgICBfb25MYXllclJlbmFtZWQoe29sZE5hbWUsIG5ld05hbWV9KSB7fVxyXG5cclxuICAgICAgX29uQW5pbWF0aW9uQWRkZWQoe2xheWVyTmFtZSwgYW5pbWF0aW9uTmFtZX0pIHt9XHJcblxyXG4gICAgICBfb25BbmltYXRpb25SZW1vdmVkKHtsYXllck5hbWUsIGFuaW1hdGlvbk5hbWV9KSB7fVxyXG5cclxuICAgICAgX29uQW5pbWF0aW9uUmVuYW1lZCh7bGF5ZXJOYW1lLCBvbGROYW1lLCBuZXdOYW1lfSkge31cclxuICAgIH07XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQW5pbWF0aW9uRmVhdHVyZURlcGVuZGVudE1peGluLCB7XHJcbiAgICAgIEVWRU5UX0RFUEVOREVOQ0lFUzoge1xyXG4gICAgICAgIHZhbHVlOiB7XHJcbiAgICAgICAgICAuLi5QYXJlbnRDbGFzcy5FVkVOVF9ERVBFTkRFTkNJRVMsXHJcbiAgICAgICAgICAuLi5BbmltYXRpb25GZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlLkVWRU5UX0RFUEVOREVOQ0lFUyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBBbmltYXRpb25GZWF0dXJlRGVwZW5kZW50TWl4aW47XHJcbiAgfVxyXG59XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhBbmltYXRpb25GZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlLCB7XHJcbiAgRVZFTlRfREVQRU5ERU5DSUVTOiB7XHJcbiAgICB2YWx1ZToge1xyXG4gICAgICBBbmltYXRpb25GZWF0dXJlOiB7XHJcbiAgICAgICAgYWRkTGF5ZXI6ICdfb25MYXllckFkZGVkJyxcclxuICAgICAgICByZW1vdmVMYXllcjogJ19vbkxheWVyUmVtb3ZlZCcsXHJcbiAgICAgICAgcmVuYW1lTGF5ZXI6ICdfb25MYXllclJlbmFtZWQnLFxyXG4gICAgICAgIGFkZEFuaW1hdGlvbjogJ19vbkFuaW1hdGlvbkFkZGVkJyxcclxuICAgICAgICByZW1vdmVBbmltYXRpb246ICdfb25BbmltYXRpb25SZW1vdmVkJyxcclxuICAgICAgICByZW5hbWVBbmltYXRpb246ICdfb25BbmltYXRpb25SZW5hbWVkJyxcclxuICAgICAgfSxcclxuICAgIH0sXHJcbiAgICB3cml0YWJsZTogZmFsc2UsXHJcbiAgfSxcclxufSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBBbmltYXRpb25GZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlO1xyXG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXHJcblxyXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtY2xhc3Nlcy1wZXItZmlsZSAqL1xyXG5pbXBvcnQgQW5pbWF0aW9uRmVhdHVyZURlcGVuZGVudEludGVyZmFjZSBmcm9tICdjb3JlL2FuaW1wYWNrL0FuaW1hdGlvbkZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UnO1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIGZhY3RvcnkgaW50ZXJmYWNlIGZvciB0aGF0IGtlZXBzIHRyYWNrIG9mIGxheWVycyBhbmQgYW5pbWF0aW9ucyBvbiBhIGhvc3QuXHJcbiAqIFRyYWNrZWQgYXNzZXRzIGFyZSBtYXJrZWQgYXMgaW5hY3RpdmUgdW50aWwgbGF5ZXJzIGFuZCBhbmltYXRpb25zIHdpdGggbWF0Y2hpbmdcclxuICogbmFtZXMgYXJlIGRldGVjdGVkIGFzIHByZXNlbnQgb24gdGhlIGhvc3QuXHJcbiAqXHJcbiAqIEBpbnRlcmZhY2VcclxuICogQGV4dGVuZHMgQW5pbWF0aW9uRmVhdHVyZURlcGVuZGVudEludGVyZmFjZVxyXG4gKlxyXG4gKiBAcHJvcGVydHkge09iamVjdH0gREVGQVVMVF9MQVlFUl9PUFRJT05TIC0gRGVmYXVsdCBvcHRpb25zIHRvIHVzZSB3aGVuIGV4ZWN1dGluZ1xyXG4gKiB7QGxpbmsgQW5pbWF0aW9uTGF5ZXJ9IG1ldGhvZHMuXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbREVGQVVMVF9MQVlFUl9PUFRJT05TLmJsZW5kVGltZT0wLjVdIC0gRGVmYXVsdCB0aW1lIGluIHNlY29uZHNcclxuICogdG8gdXNlIHdoZW4gZXhlY3V0aW5nIHtAbGluayBBbmltYXRpb25MYXllci5zZXRCbGVuZFdlaWdodH0uXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbREVGQVVMVF9MQVlFUl9PUFRJT05TLmFuaW1hdGlvbnM9e31dIC0gTWFwcyBhbmltYXRpb24gbmFtZXNcclxuICogdG8gZGVmYXVsdCBvcHRpb25zIG9iamVjdHMgdG8gdXNlIGZvciBtYW5hZ2VkIGFuaW1hdGlvbnMuXHJcbiAqL1xyXG5jbGFzcyBNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2UgZXh0ZW5kcyBBbmltYXRpb25GZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlIHtcclxuICAvKipcclxuICAgKiBTdGFydCB0cmFja2luZyBrZWVwaW5nIHRyYWNrIG9mIHdoZXRoZXIgYSBsYXllciB3aXRoIHRoZSBnaXZlbiBuYW1lIGlzIHByZXNlbnRcclxuICAgKiBvbiB0aGUgaG9zdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdG8ga2VlcCB0cmFjayBvZi5cclxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgbGF5ZXIuXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSBvcHRpb25zLmJsZW5kVGltZSAtIERlZmF1bHQgYW1vdW50IG9mIHRpbWUgdG8gdXNlIHdoZW5cclxuICAgKiBtYW5pcHVsYXRpbmcgbGF5ZXIgd2VpZ2h0cyBvbiB0aGlzIGxheWVyLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvcHRpb25zLmVhc2luZ0ZuIC0gRGVmYXVsdCBlYXNpbmcgZnVuY3Rpb24gdG8gdXNlIHdoZW5cclxuICAgKiBtYW5pcHVsYXRpbmcgbGF5ZXIgd2VpZ2h0cyBvbiB0aGlzIGxheWVyLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucy5hbmltYXRpb25zIC0gQW5pbWF0aW9ucyB0byBrZWVwIHRyYWNrIG9mIG9uIHRoZSBsYXllci5cclxuICAgKiBBbmltYXRpb25zIGFyZSByZXByZXNlbnRlZCBhcyBrZXkvdmFsdWUgcGFpcnMgb2YgYW5pbWF0aW9uIG5hbWVzIGFuZCB0aGVpclxyXG4gICAqIG9wdGlvbnMuXHJcbiAgICovXHJcbiAgcmVnaXN0ZXJMYXllcihuYW1lLCBvcHRpb25zID0ge30pIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0IHRyYWNraW5nIGtlZXBpbmcgdHJhY2sgb2Ygd2hldGhlciBhbiBhbmltYXRpb24gd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpc1xyXG4gICAqIHByZXNlbnQgb24gdGhlIGhvc3QuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCB3aWxsIG93biB0aGUgYW5pbWF0aW9uLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbmltYXRpb25OYW1lIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRvIGtlZXAgdHJhY2sgb2YuXHJcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGFuaW1hdGlvbi5cclxuICAgKi9cclxuICByZWdpc3RlckFuaW1hdGlvbihsYXllck5hbWUsIGFuaW1hdGlvbk5hbWUsIG9wdGlvbnMgPSB7fSkge31cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IGxheWVyIHdlaWdodHMgb24gdHJhY2tlZCBsYXllcnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gbmFtZUZpbHRlciAtIFByZWRpY2F0ZSBmdW5jdGlvbiB0byB0ZXN0IGVhY2ggdHJhY2tlZCBsYXllclxyXG4gICAqIHdpdGguIEJ5IGRlZmF1bHQgYWxsIGxheWVycyB3aWxsIHBhc3MuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHdlaWdodCAtIFdlaWdodCB2YWx1ZSB0byBzZXQgb24gbGF5ZXJzLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gc2Vjb25kcyAtIE51bWJlciBvZiBzZWNvbmRzIGl0IHdpbGwgdGFrZSB0byByZWFjaCB0aGUgd2VpZ2h0XHJcbiAgICogb24gZWFjaCBsYXllci4gSWYgdW5kZWZpbmVkLCBlYWNoIGxheWVycycgYmxlbmRUaW1lIG9wdGlvbiBpcyB1c2VkLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBlYXNpbmdGbiAtIEVhc2luZyBmdW5jdGlvbiB0byB1c2Ugd2hlbiBzZXR0aW5nIHdlaWdodFxyXG4gICAqIG9uIGVhY2ggbGF5ZXIuIElmIHVuZGVmaW5lZCwgZWFjaCBsYXllcnMnIGVhc2luZ0ZuIG9wdGlvbiBpcyB1c2VkLlxyXG4gICAqL1xyXG4gIHNldExheWVyV2VpZ2h0cyhuYW1lRmlsdGVyID0gKCkgPT4gdHJ1ZSwgd2VpZ2h0LCBzZWNvbmRzLCBlYXNpbmdGbikge31cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IGFsbCB0cmFja2VkIGxheWVycycgd2VpZ2h0cyB0byAxLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSBzZWNvbmRzIC0gTnVtYmVyIG9mIHNlY29uZHMgaXQgd2lsbCB0YWtlIHRvIHJlYWNoIHRoZSB3ZWlnaHRcclxuICAgKiBvbiBlYWNoIGxheWVyLiBJZiB1bmRlZmluZWQsIGVhY2ggbGF5ZXJzJyBibGVuZFRpbWUgb3B0aW9uIGlzIHVzZWQuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGVhc2luZ0ZuIC0gRWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSB3aGVuIHNldHRpbmcgd2VpZ2h0XHJcbiAgICogb24gZWFjaCBsYXllci4gSWYgdW5kZWZpbmVkLCBlYWNoIGxheWVycycgZWFzaW5nRm4gb3B0aW9uIGlzIHVzZWQuXHJcbiAgICovXHJcbiAgZW5hYmxlKHNlY29uZHMsIGVhc2luZ0ZuKSB7fVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgYWxsIHRyYWNrZWQgbGF5ZXJzJyB3ZWlnaHRzIHRvIDAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcj19IHNlY29uZHMgLSBOdW1iZXIgb2Ygc2Vjb25kcyBpdCB3aWxsIHRha2UgdG8gcmVhY2ggdGhlIHdlaWdodFxyXG4gICAqIG9uIGVhY2ggbGF5ZXIuIElmIHVuZGVmaW5lZCwgZWFjaCBsYXllcnMnIGJsZW5kVGltZSBvcHRpb24gaXMgdXNlZC5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gZWFzaW5nRm4gLSBFYXNpbmcgZnVuY3Rpb24gdG8gdXNlIHdoZW4gc2V0dGluZyB3ZWlnaHRcclxuICAgKiBvbiBlYWNoIGxheWVyLiBJZiB1bmRlZmluZWQsIGVhY2ggbGF5ZXJzJyBlYXNpbmdGbiBvcHRpb24gaXMgdXNlZC5cclxuICAgKi9cclxuICBkaXNhYmxlKHNlY29uZHMsIGVhc2luZ0ZuKSB7fVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgY2xhc3MgdGhhdCBpbXBsZW1lbnRzIHtAbGluayBNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2V9XHJcbiAgICogYW5kIGV4dGVuZHMgYSBzcGVjaWZpZWQgYmFzZSBjbGFzcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Q2xhc3N9IEJhc2VDbGFzcyAtIFRoZSBjbGFzcyB0byBleHRlbmQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtDbGFzc30gQSBjbGFzcyB0aGF0IGV4dGVuZHMgYEJhc2VDbGFzc2AgYW5kIGltcGxlbWVudHMge0BsaW5rIE1hbmFnZWRBbmltYXRpb25MYXllckludGVyZmFjZX0uXHJcbiAgICovXHJcbiAgc3RhdGljIE1peGluKEJhc2VDbGFzcykge1xyXG4gICAgY29uc3QgUGFyZW50Q2xhc3MgPSBBbmltYXRpb25GZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlLk1peGluKEJhc2VDbGFzcyk7XHJcbiAgICBjb25zdCBNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJNaXhpbiA9IGNsYXNzIGV4dGVuZHMgUGFyZW50Q2xhc3Mge1xyXG4gICAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XHJcblxyXG4gICAgICAgIHRoaXMuX21hbmFnZWRMYXllcnMgPSB7fTtcclxuICAgICAgfVxyXG5cclxuICAgICAgX29uRmVhdHVyZUFkZGVkKHR5cGVOYW1lKSB7XHJcbiAgICAgICAgc3VwZXIuX29uRmVhdHVyZUFkZGVkKHR5cGVOYW1lKTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVOYW1lICE9PSAnQW5pbWF0aW9uRmVhdHVyZScpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX21hbmFnZWRMYXllcnMgPSB0aGlzLl9tYW5hZ2VkTGF5ZXJzIHx8IHt9O1xyXG5cclxuICAgICAgICAvLyBEZXRlY3QgbmV3IGxheWVyc1xyXG4gICAgICAgIHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5sYXllcnMuZm9yRWFjaChuYW1lID0+IHtcclxuICAgICAgICAgIHRoaXMuX29uTGF5ZXJBZGRlZCh7bmFtZX0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBfb25GZWF0dXJlUmVtb3ZlZCh0eXBlTmFtZSkge1xyXG4gICAgICAgIHN1cGVyLl9vbkZlYXR1cmVSZW1vdmVkKHR5cGVOYW1lKTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVOYW1lICE9PSAnQW5pbWF0aW9uRmVhdHVyZScpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX21hbmFnZWRMYXllcnMgPSB0aGlzLl9tYW5hZ2VkTGF5ZXJzIHx8IHt9O1xyXG5cclxuICAgICAgICAvLyBEZWFjdGl2YXRlIHRoZSBsYXllcnNcclxuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9tYW5hZ2VkTGF5ZXJzKS5mb3JFYWNoKG5hbWUgPT4ge1xyXG4gICAgICAgICAgdGhpcy5fb25MYXllclJlbW92ZWQoe25hbWV9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgX29uTGF5ZXJBZGRlZCh7bmFtZX0pIHtcclxuICAgICAgICAvLyBNYXJrIHRoZSBsYXllciBhcyBhY3RpdmUgaWYgaXQgaXMgbWFuYWdlZFxyXG4gICAgICAgIGlmICh0aGlzLl9tYW5hZ2VkTGF5ZXJzW25hbWVdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIHRoaXMuX21hbmFnZWRMYXllcnNbbmFtZV0uaXNBY3RpdmUgPSB0cnVlO1xyXG5cclxuICAgICAgICAgIC8vIERldGVjdCBuZXcgYW5pbWF0aW9uc1xyXG4gICAgICAgICAgdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlLmdldEFuaW1hdGlvbnMobmFtZSkuZm9yRWFjaChhbmltTmFtZSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX29uQW5pbWF0aW9uQWRkZWQoe2xheWVyTmFtZTogbmFtZSwgYW5pbWF0aW9uTmFtZTogYW5pbU5hbWV9KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgX29uTGF5ZXJSZW1vdmVkKHtuYW1lfSkge1xyXG4gICAgICAgIC8vIERlYWN0aXZhdGUgdGhlIGxheWVyIGlmIGl0IGlzIG1hbmFnZWRcclxuICAgICAgICBpZiAodGhpcy5fbWFuYWdlZExheWVyc1tuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzW25hbWVdLmlzQWN0aXZlID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgLy8gRGVhY3RpdmF0ZSB0aGUgYW5pbWF0aW9uc1xyXG4gICAgICAgICAgT2JqZWN0LmtleXModGhpcy5fbWFuYWdlZExheWVyc1tuYW1lXS5hbmltYXRpb25zKS5mb3JFYWNoKFxyXG4gICAgICAgICAgICBhbmltTmFtZSA9PiB7XHJcbiAgICAgICAgICAgICAgdGhpcy5fb25BbmltYXRpb25SZW1vdmVkKHtcclxuICAgICAgICAgICAgICAgIGxheWVyTmFtZTogbmFtZSxcclxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbk5hbWU6IGFuaW1OYW1lLFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgX29uTGF5ZXJSZW5hbWVkKHtvbGROYW1lLCBuZXdOYW1lfSkge1xyXG4gICAgICAgIGNvbnN0IGxheWVyT3B0aW9ucyA9IHRoaXMuX21hbmFnZWRMYXllcnNbb2xkTmFtZV07XHJcblxyXG4gICAgICAgIC8vIFJlcGxhY2UgdGhlIGxheWVyIGtleSB3aXRoIHRoZSBuZXcgbmFtZVxyXG4gICAgICAgIGlmIChsYXllck9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgZGVsZXRlIHRoaXMuX21hbmFnZWRMYXllcnNbb2xkTmFtZV07XHJcbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzW25ld05hbWVdID0gbGF5ZXJPcHRpb25zO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgX29uQW5pbWF0aW9uQWRkZWQoe2xheWVyTmFtZSwgYW5pbWF0aW9uTmFtZX0pIHtcclxuICAgICAgICAvLyBNYXJrIHRoZSBhbmltYXRpb24gYXMgYWN0aXZlIGlmIGl0IGlzIG1hbmFnZWRcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0gIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICAgdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdLmFuaW1hdGlvbnNbYW5pbWF0aW9uTmFtZV0gIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdLmFuaW1hdGlvbnNbXHJcbiAgICAgICAgICAgIGFuaW1hdGlvbk5hbWVcclxuICAgICAgICAgIF0uaXNBY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgX29uQW5pbWF0aW9uUmVtb3ZlZCh7bGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lfSkge1xyXG4gICAgICAgIC8vIERlYWN0aXZhdGUgdGhlIGFuaW1hdGlvbiBpZiBpdCBpcyBtYW5hZ2VkXHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgIHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXS5hbmltYXRpb25zW2FuaW1hdGlvbk5hbWVdICE9PSB1bmRlZmluZWRcclxuICAgICAgICApIHtcclxuICAgICAgICAgIHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXS5hbmltYXRpb25zW1xyXG4gICAgICAgICAgICBhbmltYXRpb25OYW1lXHJcbiAgICAgICAgICBdLmlzQWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBfb25BbmltYXRpb25SZW5hbWVkKHtsYXllck5hbWUsIG9sZE5hbWUsIG5ld05hbWV9KSB7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgIHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXS5hbmltYXRpb25zW29sZE5hbWVdICE9PSB1bmRlZmluZWRcclxuICAgICAgICApIHtcclxuICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIGFuaW1hdGlvbiBrZXkgd2l0aCB0aGUgbmV3IG5hbWVcclxuICAgICAgICAgIGNvbnN0IGFuaW1PcHRpb25zID0gdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdLmFuaW1hdGlvbnNbXHJcbiAgICAgICAgICAgIG9sZE5hbWVcclxuICAgICAgICAgIF07XHJcbiAgICAgICAgICBkZWxldGUgdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdLmFuaW1hdGlvbnNbb2xkTmFtZV07XHJcbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0uYW5pbWF0aW9uc1tuZXdOYW1lXSA9IGFuaW1PcHRpb25zO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmVnaXN0ZXJMYXllcihuYW1lLCBvcHRpb25zID0ge30pIHtcclxuICAgICAgICAvLyBTdGFydCB3aXRoIGRlZmF1bHQgb3B0aW9ucyBmb3IgZWFjaCBuZXcgbGF5ZXJcclxuICAgICAgICBpZiAodGhpcy5fbWFuYWdlZExheWVyc1tuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzW25hbWVdID0ge1xyXG4gICAgICAgICAgICAuLi50aGlzLmNvbnN0cnVjdG9yLkRFRkFVTFRfTEFZRVJfT1BUSU9OUyxcclxuICAgICAgICAgICAgYW5pbWF0aW9uczoge30sXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIGFsbCBvcHRpb25zIGV4Y2VwdCBhbmltYXRpb25zXHJcbiAgICAgICAgY29uc3QgbGF5ZXJPcHRpb25zID0gdGhpcy5fbWFuYWdlZExheWVyc1tuYW1lXTtcclxuICAgICAgICBvcHRpb25zID0gey4uLm9wdGlvbnN9O1xyXG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBvcHRpb25zLmFuaW1hdGlvbnMgfHwge307XHJcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMuYW5pbWF0aW9ucztcclxuICAgICAgICBPYmplY3QuYXNzaWduKGxheWVyT3B0aW9ucywgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGxheWVyIGNhbiBiZSBtYW5pcHVsYXRlZCBub3dcclxuICAgICAgICBsYXllck9wdGlvbnMuaXNBY3RpdmUgPVxyXG4gICAgICAgICAgdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgIHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5sYXllcnMuaW5jbHVkZXMobmFtZSk7XHJcblxyXG4gICAgICAgIC8vIFJlZ2lzdGVyIHRoZSBhbmltYXRpb25zXHJcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoYW5pbWF0aW9uT3B0aW9ucykuZm9yRWFjaCgoW2FuaW1OYW1lLCBhbmltT3B0aW9uc10pID0+IHtcclxuICAgICAgICAgIHRoaXMucmVnaXN0ZXJBbmltYXRpb24obmFtZSwgYW5pbU5hbWUsIGFuaW1PcHRpb25zKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmVnaXN0ZXJBbmltYXRpb24obGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lLCBvcHRpb25zID0ge30pIHtcclxuICAgICAgICAvLyBSZWdpc3RlciB0aGUgbGF5ZXIgaWYgaXQgaGFzbid0IGJlZW4gcmVnaXN0ZXJlZCB5ZXRcclxuICAgICAgICBpZiAodGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIHRoaXMucmVnaXN0ZXJMYXllcihsYXllck5hbWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIGFuaW1hdGlvbiBvcHRpb25zXHJcbiAgICAgICAgY29uc3QgYW5pbU9wdGlvbnMgPVxyXG4gICAgICAgICAgdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdLmFuaW1hdGlvbnNbYW5pbWF0aW9uTmFtZV0gfHwge307XHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhbmltT3B0aW9ucywgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdLmFuaW1hdGlvbnNbYW5pbWF0aW9uTmFtZV0gPSBhbmltT3B0aW9ucztcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgYW5pbWF0aW9uIGNhbiBiZSBtYW5pcHVsYXRlZCBub3dcclxuICAgICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0uYW5pbWF0aW9uc1thbmltYXRpb25OYW1lXS5pc0FjdGl2ZSA9XHJcbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0uaXNBY3RpdmUgJiZcclxuICAgICAgICAgIHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5nZXRBbmltYXRpb25zKGxheWVyTmFtZSkuaW5jbHVkZXMoXHJcbiAgICAgICAgICAgIGFuaW1hdGlvbk5hbWVcclxuICAgICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNldExheWVyV2VpZ2h0cyhuYW1lRmlsdGVyID0gKCkgPT4gdHJ1ZSwgd2VpZ2h0LCBzZWNvbmRzLCBlYXNpbmdGbikge1xyXG4gICAgICAgIGNvbnN0IGxheWVyTmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLl9tYW5hZ2VkTGF5ZXJzKS5maWx0ZXIobmFtZUZpbHRlcik7XHJcblxyXG4gICAgICAgIGxheWVyTmFtZXMuZm9yRWFjaChuYW1lID0+IHtcclxuICAgICAgICAgIGNvbnN0IGxheWVyT3B0aW9ucyA9IHRoaXMuX21hbmFnZWRMYXllcnNbbmFtZV07XHJcblxyXG4gICAgICAgICAgaWYgKGxheWVyT3B0aW9ucy5pc0FjdGl2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9ob3N0LkFuaW1hdGlvbkZlYXR1cmUuc2V0TGF5ZXJXZWlnaHQoXHJcbiAgICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICAgICAgICB3ZWlnaHQsXHJcbiAgICAgICAgICAgICAgc2Vjb25kcyAhPT0gdW5kZWZpbmVkID8gc2Vjb25kcyA6IGxheWVyT3B0aW9ucy5ibGVuZFRpbWUsXHJcbiAgICAgICAgICAgICAgZWFzaW5nRm4gfHwgbGF5ZXJPcHRpb25zLmVhc2luZ0ZuXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGVuYWJsZShzZWNvbmRzLCBlYXNpbmdGbikge1xyXG4gICAgICAgIHRoaXMuc2V0TGF5ZXJXZWlnaHRzKHVuZGVmaW5lZCwgMSwgc2Vjb25kcywgZWFzaW5nRm4pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBkaXNhYmxlKHNlY29uZHMsIGVhc2luZ0ZuKSB7XHJcbiAgICAgICAgdGhpcy5zZXRMYXllcldlaWdodHModW5kZWZpbmVkLCAwLCBzZWNvbmRzLCBlYXNpbmdGbik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGluc3RhbGxBcGkoKSB7XHJcbiAgICAgICAgY29uc3QgYXBpID0gc3VwZXIuaW5zdGFsbEFwaSgpO1xyXG5cclxuICAgICAgICBPYmplY3QuYXNzaWduKGFwaSwge1xyXG4gICAgICAgICAgcmVnaXN0ZXJMYXllcjogdGhpcy5yZWdpc3RlckxheWVyLmJpbmQodGhpcyksXHJcbiAgICAgICAgICByZWdpc3RlckFuaW1hdGlvbjogdGhpcy5yZWdpc3RlckFuaW1hdGlvbi5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgc2V0TGF5ZXJXZWlnaHRzOiB0aGlzLnNldExheWVyV2VpZ2h0cy5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgZW5hYmxlOiB0aGlzLmVuYWJsZS5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgZGlzYWJsZTogdGhpcy5kaXNhYmxlLmJpbmQodGhpcyksXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBhcGk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTWFuYWdlZEFuaW1hdGlvbkxheWVyTWl4aW4sIHtcclxuICAgICAgREVGQVVMVF9MQVlFUl9PUFRJT05TOiB7XHJcbiAgICAgICAgdmFsdWU6IE1hbmFnZWRBbmltYXRpb25MYXllckludGVyZmFjZS5ERUZBVUxUX0xBWUVSX09QVElPTlMsXHJcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIE1hbmFnZWRBbmltYXRpb25MYXllck1peGluO1xyXG4gIH1cclxufVxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTWFuYWdlZEFuaW1hdGlvbkxheWVySW50ZXJmYWNlLCB7XHJcbiAgREVGQVVMVF9MQVlFUl9PUFRJT05TOiB7XHJcbiAgICB2YWx1ZToge2JsZW5kVGltZTogMC41LCBhbmltYXRpb25zOiB7fX0sXHJcbiAgICB3cml0YWJsZTogZmFsc2UsXHJcbiAgfSxcclxufSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2U7XHJcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcclxuXHJcbi8qIGVzbGludC1kaXNhYmxlIG1heC1jbGFzc2VzLXBlci1maWxlICovXHJcbmltcG9ydCBGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlIGZyb20gJ2NvcmUvRmVhdHVyZURlcGVuZGVudEludGVyZmFjZSc7XHJcblxyXG4vKipcclxuICogQ2xhc3MgZmFjdG9yeSBpbnRlcmZhY2UgZm9yIGZlYXR1cmVzIHRoYXQgYXJlIGRlcGVuZGVudCBvbiB0aGUgVGV4dFRvU3BlZWNoRmVhdHVyZVxyXG4gKiBiZWluZyBwcmVzZW50IG9uIHRoZSBob3N0LiBTcGVlY2ggZXZlbnRzIHdpbGwgYXV0b21hdGljYWxseSBiZSBsaXN0ZW5lZCBmb3Igb25jZSBhXHJcbiAqIFRleHRUb1NwZWVjaEZlYXR1cmUgaXMgYWRkZWQgdG8gdGhlIGhvc3QgYW5kIHN0b3BwZWQgb25jZSBpdCBpcyByZW1vdmVkLlxyXG4gKlxyXG4gKiBAaW50ZXJmYWNlXHJcbiAqIEBleHRlbmRzIEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2VcclxuICpcclxuICogQHByb3BlcnR5IHtPYmplY3R9IEVWRU5UX0RFUEVOREVOQ0lFUyAtIEV2ZW50cyB0aGF0IHRoZSBmZWF0dXJlIHNob3VsZCBzdGFydC9zdG9wXHJcbiAqIGxpc3RlbmluZyBmb3Igd2hlbiBhIGZlYXR1cmUgb2YgdHlwZSBGZWF0dXJlTmFtZSBpcyBhZGRlZC9yZW1vdmVkIGZyb20gdGhlIGhvc3QuXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBFVkVOVF9ERVBFTkRFTkNJRVMuVGV4dFRvU3BlZWNoRmVhdHVyZSAtIEV2ZW50cyB0aGF0IGFyZVxyXG4gKiBzcGVjaWZpYyB0byB0aGUgVGV4dFRvU3BlZWNoRmVhdHVyZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVF9ERVBFTkRFTkNJRVMuVGV4dFRvU3BlZWNoRmVhdHVyZS5wbGF5PSdfb25QbGF5J10gLVxyXG4gKiBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIFRleHRUb1NwZWVjaEZlYXR1cmUgcGxheVxyXG4gKiBldmVudHMgYXJlIGVtaXR0ZWQuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRfREVQRU5ERU5DSUVTLlRleHRUb1NwZWVjaEZlYXR1cmUucGF1c2U9J19vblBhdXNlJ10gLVxyXG4gKiBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIFRleHRUb1NwZWVjaEZlYXR1cmUgcGF1c2VcclxuICogZXZlbnRzIGFyZSBlbWl0dGVkLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UX0RFUEVOREVOQ0lFUy5UZXh0VG9TcGVlY2hGZWF0dXJlLnJlc3VtZT0nX29uUmVzdW1lJ10gLVxyXG4gKiBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIFRleHRUb1NwZWVjaEZlYXR1cmUgcmVzdW1lXHJcbiAqIGV2ZW50cyBhcmUgZW1pdHRlZC5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVF9ERVBFTkRFTkNJRVMuVGV4dFRvU3BlZWNoRmVhdHVyZS5zdG9wPSdfb25TdG9wJ10gLVxyXG4gKiBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIFRleHRUb1NwZWVjaEZlYXR1cmUgc3RvcFxyXG4gKiBldmVudHMgYXJlIGVtaXR0ZWQuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRfREVQRU5ERU5DSUVTLlRleHRUb1NwZWVjaEZlYXR1cmUuc2VudGVuY2U9J19vblNlbnRlbmNlJ10gLVxyXG4gKiBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIFRleHRUb1NwZWVjaEZlYXR1cmUgc2VudGVuY2VcclxuICogZXZlbnRzIGFyZSBlbWl0dGVkLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UX0RFUEVOREVOQ0lFUy5UZXh0VG9TcGVlY2hGZWF0dXJlLndvcmQ9J19vbldvcmQnXSAtXHJcbiAqIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gVGV4dFRvU3BlZWNoRmVhdHVyZSB3b3JkXHJcbiAqIGV2ZW50cyBhcmUgZW1pdHRlZC5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVF9ERVBFTkRFTkNJRVMuVGV4dFRvU3BlZWNoRmVhdHVyZS52aXNlbWU9J19vblZpc2VtZSddIC1cclxuICogVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBUZXh0VG9TcGVlY2hGZWF0dXJlIHZpc2VtZVxyXG4gKiBldmVudHMgYXJlIGVtaXR0ZWQuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRfREVQRU5ERU5DSUVTLlRleHRUb1NwZWVjaEZlYXR1cmUuc3NtbD0nX29uU3NtbCddIC1cclxuICogVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBUZXh0VG9TcGVlY2hGZWF0dXJlIHNzbWxcclxuICogZXZlbnRzIGFyZSBlbWl0dGVkLlxyXG4gKi9cclxuY2xhc3MgVGV4dFRvU3BlZWNoRmVhdHVyZURlcGVuZGVudEludGVyZmFjZSBleHRlbmRzIEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2Uge1xyXG4gIC8qKlxyXG4gICAqIEV4ZWN1dGVkIHdoZW4gc3BlZWNoIHBsYXkgZXZlbnRzIGFyZSBjYXVnaHQuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9vblBsYXkoKSB7fVxyXG5cclxuICAvKipcclxuICAgKiBFeGVjdXRlZCB3aGVuIHNwZWVjaCBwYXVzZSBldmVudHMgYXJlIGNhdWdodC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX29uUGF1c2UoKSB7fVxyXG5cclxuICAvKipcclxuICAgKiBFeGVjdXRlZCB3aGVuIHNwZWVjaCByZXN1bWUgZXZlbnRzIGFyZSBjYXVnaHQuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9vblJlc3VtZSgpIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIEV4ZWN1dGVkIHdoZW4gc3BlZWNoIHN0b3AgZXZlbnRzIGFyZSBjYXVnaHQuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9vblN0b3AoKSB7fVxyXG5cclxuICAvKipcclxuICAgKiBFeGVjdXRlZCB3aGVuIHNwZWVjaCBzZW50ZW5jZSBldmVudHMgYXJlIGNhdWdodC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX29uU2VudGVuY2UoKSB7fVxyXG5cclxuICAvKipcclxuICAgKiBFeGVjdXRlZCB3aGVuIHNwZWVjaCB3b3JkIGV2ZW50cyBhcmUgY2F1Z2h0LlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfb25Xb3JkKCkge31cclxuXHJcbiAgLyoqXHJcbiAgICogRXhlY3V0ZWQgd2hlbiBzcGVlY2ggdmlzZW1lIGV2ZW50cyBhcmUgY2F1Z2h0LlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfb25WaXNlbWUoKSB7fVxyXG5cclxuICAvKipcclxuICAgKiBFeGVjdXRlZCB3aGVuIHNwZWVjaCBzc21sIGV2ZW50cyBhcmUgY2F1Z2h0LlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfb25Tc21sKCkge31cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIGNsYXNzIHRoYXQgaW1wbGVtZW50cyB7QGxpbmsgVGV4dFRvU3BlZWNoRmVhdHVyZURlcGVuZGVudEludGVyZmFjZX1cclxuICAgKiBhbmQgZXh0ZW5kcyBhIHNwZWNpZmllZCBiYXNlIGNsYXNzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtDbGFzc30gQmFzZUNsYXNzIC0gVGhlIGNsYXNzIHRvIGV4dGVuZC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0NsYXNzfSBBIGNsYXNzIHRoYXQgZXh0ZW5kcyBgQmFzZUNsYXNzYCBhbmQgaW1wbGVtZW50cyB7QGxpbmsgVGV4dFRvU3BlZWNoRmVhdHVyZURlcGVuZGVudEludGVyZmFjZX0uXHJcbiAgICovXHJcbiAgc3RhdGljIE1peGluKEJhc2VDbGFzcykge1xyXG4gICAgY29uc3QgUGFyZW50Q2xhc3MgPSBGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlLk1peGluKEJhc2VDbGFzcyk7XHJcbiAgICBjb25zdCBUZXh0VG9TcGVlY2hGZWF0dXJlRGVwZW5kZW50TWl4aW4gPSBjbGFzcyBleHRlbmRzIFBhcmVudENsYXNzIHtcclxuICAgICAgX29uUGxheSgpIHt9XHJcblxyXG4gICAgICBfb25QYXVzZSgpIHt9XHJcblxyXG4gICAgICBfb25SZXN1bWUoKSB7fVxyXG5cclxuICAgICAgX29uU3RvcCgpIHt9XHJcblxyXG4gICAgICBfb25TZW50ZW5jZSgpIHt9XHJcblxyXG4gICAgICBfb25Xb3JkKCkge31cclxuXHJcbiAgICAgIF9vblZpc2VtZSgpIHt9XHJcblxyXG4gICAgICBfb25Tc21sKCkge31cclxuICAgIH07XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVGV4dFRvU3BlZWNoRmVhdHVyZURlcGVuZGVudE1peGluLCB7XHJcbiAgICAgIEVWRU5UX0RFUEVOREVOQ0lFUzoge1xyXG4gICAgICAgIHZhbHVlOiB7XHJcbiAgICAgICAgICAuLi5QYXJlbnRDbGFzcy5FVkVOVF9ERVBFTkRFTkNJRVMsXHJcbiAgICAgICAgICAuLi5UZXh0VG9TcGVlY2hGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlLkVWRU5UX0RFUEVOREVOQ0lFUyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBUZXh0VG9TcGVlY2hGZWF0dXJlRGVwZW5kZW50TWl4aW47XHJcbiAgfVxyXG59XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhUZXh0VG9TcGVlY2hGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlLCB7XHJcbiAgRVZFTlRfREVQRU5ERU5DSUVTOiB7XHJcbiAgICB2YWx1ZToge1xyXG4gICAgICBUZXh0VG9TcGVlY2hGZWF0dXJlOiB7XHJcbiAgICAgICAgcGxheTogJ19vblBsYXknLFxyXG4gICAgICAgIHBhdXNlOiAnX29uUGF1c2UnLFxyXG4gICAgICAgIHJlc3VtZTogJ19vblJlc3VtZScsXHJcbiAgICAgICAgc3RvcDogJ19vblN0b3AnLFxyXG4gICAgICAgIHNlbnRlbmNlOiAnX29uU2VudGVuY2UnLFxyXG4gICAgICAgIHdvcmQ6ICdfb25Xb3JkJyxcclxuICAgICAgICB2aXNlbWU6ICdfb25WaXNlbWUnLFxyXG4gICAgICAgIHNzbWw6ICdfb25Tc21sJyxcclxuICAgICAgfSxcclxuICAgIH0sXHJcbiAgICB3cml0YWJsZTogZmFsc2UsXHJcbiAgfSxcclxufSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUZXh0VG9TcGVlY2hGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlO1xyXG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXHJcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSAnLi9NYXRoVXRpbHMnO1xyXG5pbXBvcnQge1F1YWRyYXRpY30gZnJvbSAnLi9hbmltcGFjay9FYXNpbmcnO1xyXG5pbXBvcnQgTWFuYWdlZEFuaW1hdGlvbkxheWVySW50ZXJmYWNlIGZyb20gJy4vYW5pbXBhY2svTWFuYWdlZEFuaW1hdGlvbkxheWVySW50ZXJmYWNlJztcclxuaW1wb3J0IFRleHRUb1NwZWVjaEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UgZnJvbSAnLi9hd3NwYWNrL1RleHRUb1NwZWVjaEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UnO1xyXG5pbXBvcnQgQWJzdHJhY3RIb3N0RmVhdHVyZSBmcm9tICcuL0Fic3RyYWN0SG9zdEZlYXR1cmUnO1xyXG5cclxuLyoqXHJcbiAqIERlZmF1bHQgbWFwcGluZyBvZiBQb2xseSB2aXNlbWUgbmFtZXMgdG8gYW5pbWF0aW9uIG9wdGlvbnMgb2JqZWN0cy5cclxuICpcclxuICogQHByb3BlcnR5IHtPYmplY3R9IFtzaWw9e25hbWU6ICdzaWwnfV1cclxuICogQHByb3BlcnR5IHtPYmplY3R9IFtwPXtuYW1lOiAncCcsIG92ZXJyaWRlV2VpZ2h0OiAwLjl9XVxyXG4gKiBAcHJvcGVydHkge09iamVjdH0gW3Q9e25hbWU6ICd0JywgYmxlbmRUaW1lOiAwLjJ9XVxyXG4gKiBAcHJvcGVydHkge09iamVjdH0gW1M9e25hbWU6ICdTJ31dXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbVD17bmFtZTogJ1QnfV1cclxuICogQHByb3BlcnR5IHtPYmplY3R9IFtmPXtuYW1lOiAnZicsIG92ZXJyaWRlV2VpZ2h0OiAwLjc1fV1cclxuICogQHByb3BlcnR5IHtPYmplY3R9IFtrPXtuYW1lOiAnayd9XVxyXG4gKiBAcHJvcGVydHkge09iamVjdH0gW2k9e25hbWU6ICdpJ31dXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbcj17bmFtZTogJ3InfV1cclxuICogQHByb3BlcnR5IHtPYmplY3R9IFtzPXtuYW1lOiAncycsIGJsZW5kVGltZTogMC4yNX1dXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbdT17bmFtZTogJ3UnfV1cclxuICogQHByb3BlcnR5IHtPYmplY3R9IFtAPXtuYW1lOiAnQCd9XVxyXG4gKiBAcHJvcGVydHkge09iamVjdH0gW2E9e25hbWU6ICdhJ31dXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbZT17bmFtZTogJ2UnLCBibGVuZFRpbWU6IDAuMn1dXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbRT17bmFtZTogJ0UnfV1cclxuICogQHByb3BlcnR5IHtPYmplY3R9IFtvPXtuYW1lOiAnbyd9XVxyXG4gKiBAcHJvcGVydHkge09iamVjdH0gW089e25hbWU6ICdPJ31dXHJcbiAqL1xyXG5jb25zdCBEZWZhdWx0VmlzZW1lTWFwID0ge1xyXG4gIHNpbDoge25hbWU6ICdzaWwnfSxcclxuICBwOiB7bmFtZTogJ3AnLCBvdmVycmlkZVdlaWdodDogMC45fSxcclxuICB0OiB7bmFtZTogJ3QnLCBibGVuZFRpbWU6IDAuMn0sXHJcbiAgUzoge25hbWU6ICdTJ30sXHJcbiAgVDoge25hbWU6ICdUJ30sXHJcbiAgZjoge25hbWU6ICdmJywgb3ZlcnJpZGVXZWlnaHQ6IDAuNzV9LFxyXG4gIGs6IHtuYW1lOiAnayd9LFxyXG4gIGk6IHtuYW1lOiAnaSd9LFxyXG4gIHI6IHtuYW1lOiAncid9LFxyXG4gIHM6IHtuYW1lOiAncycsIGJsZW5kVGltZTogMC4yNX0sXHJcbiAgdToge25hbWU6ICd1J30sXHJcbiAgJ0AnOiB7bmFtZTogJ0AnfSxcclxuICBhOiB7bmFtZTogJ2EnfSxcclxuICBlOiB7bmFtZTogJ2UnLCBibGVuZFRpbWU6IDAuMn0sXHJcbiAgRToge25hbWU6ICdFJ30sXHJcbiAgbzoge25hbWU6ICdvJ30sXHJcbiAgTzoge25hbWU6ICdPJ30sXHJcbn07XHJcblxyXG4vKipcclxuICogTGlwc3luYyBjb250cm9scyB0d28gdHlwZXMgb2YgbW92ZW1lbnQ6IGlkbGUgYW5pbWF0aW9uIHRoYXQgc2hvdWxkIHBsYXkgd2hpbGVcclxuICogc3BlZWNoIGlzIHBsYXlpbmcgYW5kIHZpc2VtZSBhbmltYXRpb25zIGNvcnJlc3BvbmRpbmcgdG8gUG9sbHkgdmlzZW1lcyB3aG9zZVxyXG4gKiB3ZWlnaHRzIHNob3VsZCBiZSB0dXJuZWQgb24gYW5kIG9mZiBhcyB0aGV5IGFyZSBlbmNvdW50ZXJlZCBpbiB0aGUgUG9sbHkgU1NNTFxyXG4gKiB0cmFuc2NyaXB0LiBMYXllcnMgb3duZWQgYnkgdGhpcyBmZWF0dXJlIHdpbGwgYmUgZW5hYmxlZCB3aGlsZSBzcGVlY2ggaXMgcGxheWluZ1xyXG4gKiBhbmQgZGlzYWJsZWQgb25jZSBpdCBzdG9wcy5cclxuICpcclxuICogQGV4dGVuZHMgQWJzdHJhY3RIb3N0RmVhdHVyZVxyXG4gKiBAYWxpYXMgY29yZS9MaXBzeW5jRmVhdHVyZVxyXG4gKiBAaW1wbGVtZW50cyBUZXh0VG9TcGVlY2hGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlXHJcbiAqIEBpbXBsZW1lbnRzIE1hbmFnZWRBbmltYXRpb25MYXllckludGVyZmFjZVxyXG4gKi9cclxuY2xhc3MgTGlwc3luY0ZlYXR1cmUgZXh0ZW5kcyBBYnN0cmFjdEhvc3RGZWF0dXJlLm1peChcclxuICBUZXh0VG9TcGVlY2hGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlLk1peGluLFxyXG4gIE1hbmFnZWRBbmltYXRpb25MYXllckludGVyZmFjZS5NaXhpblxyXG4pIHtcclxuICAvKipcclxuICAgKiBAY29uc3RydWN0b3JcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Y29yZS9Ib3N0T2JqZWN0fSBob3N0IC0gSG9zdCB0aGF0IG93bnMgdGhlIGZlYXR1cmUuXHJcbiAgICogQHBhcmFtIHtPYmplY3Q9fSB2aXNlbWVPcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIHZpc2VtZSBsYXllcnMuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt2aXNlbWVPcHRpb25zLmJsZW5kVGltZT0wLjE1XSAtIERlZmF1bHQgYW1vdW50IG9mIHRpbWUgaXRcclxuICAgKiB3aWxsIHRha2UgdG8gbWFuaXB1bGF0ZSBlYWNoIGZyZWVCbGVuZCB3ZWlnaHQgb24gdGhlIHZpc2VtZSBzdGF0ZXMuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFt2aXNlbWVPcHRpb25zLmRlY2F5UmF0ZT17YW1vdW50OiAuNSwgc2Vjb25kczogLjV9XSAtIEFuIG9iamVjdFxyXG4gICAqIGRlc2NyaWJpbmcgdGhlIDAtMSBmYWN0b3IgdmlzZW1lIHdlaWdodCB3aWxsIGRlY2F5IGlmIHRoZSB2aXNlbWUgZHVyYXRpb24gaXNcclxuICAgKiBsb25nZXIgdGhhbiB0aGUgYmxlbmRUaW1lIGFuZCB0aGUgbnVtYmVyIG9mIHNlY29uZHMgaXQgd291bGQgdGFrZSB0byBkZWNheVxyXG4gICAqIGJ5IHRoYXQgZmFjdG9yLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdmlzZW1lT3B0aW9ucy5lYXNpbmdGbj1RdWFkcmF0aWMuSW5PdXRdIC0gRGVmYXVsdCBlYXNpbmcgZnVuY3Rpb25cclxuICAgKiB0byB1c2Ugd2hlbiBtYW5pcHVsYXRpbmcgdmlzZW1lIGZyZWVCbGVuZCB3ZWlnaHRzLlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IFt2aXNlbWVPcHRpb25zLi5sYXllcnM9W11dIC0gQW4gYXJyYXkgb2YgbGF5ZXIgb3B0aW9uc1xyXG4gICAqIG9iamVjdHMgdG8gcmVnaXN0ZXIgYXMgdmlzZW1lIGxheWVycy5cclxuICAgKiBAcGFyYW0ge09iamVjdD19IHRhbGtpbmdPcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIHRhbGtpbmcgbGF5ZXJzLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdGFsa2luZ09wdGlvbnMuYmxlbmRUaW1lPTAuNzVdIC0gRGVmYXVsdCBhbW91bnQgb2YgdGltZSB0b1xyXG4gICAqIGVuYWJsZSBhbmQgZGlzYWJsZSB0aGUgdGFsa2luZyBpZGxlIGxheWVyc1xyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdGFsa2luZ09wdGlvbnMuZWFzaW5nRm49UXVhZHJhdGljLkluT3V0XSAtIERlZmF1bHQgZWFzaW5nXHJcbiAgICogZnVuY3Rpb24gdG8gdXNlIHdoZW4gbWFuaXB1bGF0aW5nIHdlaWdodHMgb24gdGhlIHRhbGtpbmcgaWRsZSBsYXllcnMuXHJcbiAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gW3RhbGtpbmdPcHRpb25zLmxheWVycz1bXV0gLSBBbiBhcnJheSBvZiBsYXllciBvcHRpb25zXHJcbiAgICogb2JqZWN0cyB0byByZWdpc3RlciBhcyB0YWxraW5nIGxheWVycy5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW3Zpc2VtZUxlYWRUaW1lPS4wNjddIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRvIGluc3RydWN0IHRoZVxyXG4gICAqIFRleHRUb1NwZWVjaEZlYXR1cmUgdG8gZW1pdCBzcGVlY2htYXJrcyBiZWZvcmUgZWFjaCBvbmUncyBhY3R1YWwgdGltZXN0YW1wXHJcbiAgICogaXMgcmVhY2hlZC4gVGhpcyB3aWxsIHNldCB0aGUgJ3NwZWVjaE1hcmtPZmZzZXQnIHZhcmlhYmxlIG9uIHRoZSBUZXh0VG9TcGVlY2hGZWF0dXJlLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgaG9zdCxcclxuICAgIHtcclxuICAgICAgYmxlbmRUaW1lOiB2aXNlbWVCbGVuZFRpbWUgPSAwLjE1LFxyXG4gICAgICBkZWNheVJhdGU6IHthbW91bnQgPSAwLjUsIHNlY29uZHMgPSAwLjV9ID0ge30sXHJcbiAgICAgIGVhc2luZ0ZuOiB2aXNlbWVFYXNpbmdGbiA9IFF1YWRyYXRpYy5Jbk91dCxcclxuICAgICAgbGF5ZXJzOiB2aXNlbWVMYXllcnMgPSBbXSxcclxuICAgIH0gPSB7fSxcclxuICAgIHtcclxuICAgICAgYmxlbmRUaW1lOiB0YWxraW5nQmxlbmRUaW1lID0gMC43NSxcclxuICAgICAgZWFzaW5nRm46IHRhbGtpbmdFYXNpbmdGbiA9IFF1YWRyYXRpYy5Jbk91dCxcclxuICAgICAgbGF5ZXJzOiB0YWxraW5nTGF5ZXJzID0gW10sXHJcbiAgICB9ID0ge30sXHJcbiAgICB2aXNlbWVMZWFkVGltZSA9IDAuMDY3XHJcbiAgKSB7XHJcbiAgICBzdXBlcihob3N0KTtcclxuXHJcbiAgICB0aGlzLl92aXNlbWVMYXllcnMgPSB7fTtcclxuICAgIHRoaXMuX3RhbGtpbmdMYXllcnMgPSB7fTtcclxuICAgIHRoaXMudmlzZW1lTGVhZFRpbWUgPSB2aXNlbWVMZWFkVGltZTtcclxuXHJcbiAgICAvLyBSZWdpc3RlciB0aGUgdmlzZW1lIGxheWVyc1xyXG4gICAgdmlzZW1lTGF5ZXJzLmZvckVhY2goKHtuYW1lLCBhbmltYXRpb24sIHZpc2VtZU1hcCA9IERlZmF1bHRWaXNlbWVNYXB9KSA9PiB7XHJcbiAgICAgIHRoaXMucmVnaXN0ZXJWaXNlbWVMYXllcihuYW1lLCB7XHJcbiAgICAgICAgYW5pbWF0aW9uLFxyXG4gICAgICAgIHZpc2VtZU1hcCxcclxuICAgICAgICBkZWNheVJhdGU6IHthbW91bnQsIHNlY29uZHN9LFxyXG4gICAgICAgIGJsZW5kVGltZTogdmlzZW1lQmxlbmRUaW1lLFxyXG4gICAgICAgIGVhc2luZ0ZuOiB2aXNlbWVFYXNpbmdGbixcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBSZWdpc3RlciB0aGUgdGFsa2luZyBsYXllcnNcclxuICAgIHRhbGtpbmdMYXllcnMuZm9yRWFjaCgoe25hbWUsIGFuaW1hdGlvbn0pID0+IHtcclxuICAgICAgdGhpcy5yZWdpc3RlclRhbGtpbmdMYXllcihuYW1lLCB7XHJcbiAgICAgICAgYW5pbWF0aW9uLFxyXG4gICAgICAgIGJsZW5kVGltZTogdGFsa2luZ0JsZW5kVGltZSxcclxuICAgICAgICBlYXNpbmdGbjogdGFsa2luZ0Vhc2luZ0ZuLFxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRW5zdXJlIHRoYXQgcmVnaXN0ZXJlZCB2aXNlbWUgYW5pbWF0aW9ucyBhcmUgRnJlZUJsZW5kU3RhdGVzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0aGF0IGNvbnRhaW5zIHRoZSB2aXNlbWUgYW5pbWF0aW9uLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbmltYXRpb25OYW1lIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uLlxyXG4gICAqL1xyXG4gIF9yZWdpc3RlclZpc2VtZUFuaW1hdGlvbihsYXllck5hbWUsIGFuaW1hdGlvbk5hbWUpIHtcclxuICAgIGlmICh0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0uYW5pbWF0aW9uc1thbmltYXRpb25OYW1lXS5pc0FjdGl2ZSkge1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlLmdldEFuaW1hdGlvblR5cGUoXHJcbiAgICAgICAgICBsYXllck5hbWUsXHJcbiAgICAgICAgICBhbmltYXRpb25OYW1lXHJcbiAgICAgICAgKSAhPT0gJ2ZyZWVCbGVuZCdcclxuICAgICAgKSB7XHJcbiAgICAgICAgLy8gV2FybiBhbmQgZGVhY3RpdmF0ZSBpZiB0aGUgcmVnaXN0ZXJlZCBzdGF0ZSBpcyBub3QgZnJlZUJsZW5kXHJcbiAgICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgICAgYENhbm5vdCByZWdpc3RlciBMaXBzeW5jIHZpc2VtZSBhbmltYXRpb24gJHthbmltYXRpb25OYW1lfSBvbiBsYXllciAke2xheWVyTmFtZX0gZm9yIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gVmlzZW1lIGFuaW1hdGlvbnMgbXVzdCBiZSBvZiB0eXBlICdmcmVlQmxlbmQnLmBcclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXS5hbmltYXRpb25zW1xyXG4gICAgICAgICAgYW5pbWF0aW9uTmFtZVxyXG4gICAgICAgIF0uaXNBY3RpdmUgPSBmYWxzZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgYmxlbmRXZWlnaHRzIGNhbiBiZSBtYW5pcHVsYXRlZCBub3dcclxuICAgICAgICBjb25zdCB3ZWlnaHROYW1lcyA9IHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5nZXRBbmltYXRpb25CbGVuZE5hbWVzKFxyXG4gICAgICAgICAgbGF5ZXJOYW1lLFxyXG4gICAgICAgICAgYW5pbWF0aW9uTmFtZVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgY29uc3Qge3Zpc2VtZU1hcH0gPSB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0uYW5pbWF0aW9uc1tcclxuICAgICAgICAgIGFuaW1hdGlvbk5hbWVcclxuICAgICAgICBdO1xyXG5cclxuICAgICAgICBPYmplY3QudmFsdWVzKHZpc2VtZU1hcCkuZm9yRWFjaCh2aXNlbWVPcHRpb25zID0+IHtcclxuICAgICAgICAgIHZpc2VtZU9wdGlvbnMuaXNBY3RpdmUgPSB3ZWlnaHROYW1lcy5pbmNsdWRlcyh2aXNlbWVPcHRpb25zLm5hbWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJZiB0aGUgYWRkZWQgZmVhdHVyZSBpcyBUZXh0VG9TcGVlY2gsIHVwZGF0ZSBpdHMgc3BlZWNoTWFya09mZnNldCB2YXJpYWJsZS5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZU5hbWUgLSBOYW1lIG9mIHRoZSB0eXBlIG9mIGZlYXR1cmUgdGhhdCB3YXMgYWRkZWQuXHJcbiAgICovXHJcbiAgX29uRmVhdHVyZUFkZGVkKHR5cGVOYW1lKSB7XHJcbiAgICB0aGlzLl92aXNlbWVMYXllcnMgPSB0aGlzLl92aXNlbWVMYXllcnMgfHwge307XHJcbiAgICB0aGlzLl90YWxraW5nTGF5ZXJzID0gdGhpcy5fdGFsa2luZ0xheWVycyB8fCB7fTtcclxuXHJcbiAgICBzdXBlci5fb25GZWF0dXJlQWRkZWQodHlwZU5hbWUpO1xyXG5cclxuICAgIGlmICh0eXBlTmFtZSA9PT0gJ1RleHRUb1NwZWVjaEZlYXR1cmUnKSB7XHJcbiAgICAgIHRoaXMuX2hvc3QuVGV4dFRvU3BlZWNoRmVhdHVyZS5zcGVlY2htYXJrT2Zmc2V0ID1cclxuICAgICAgICAtdGhpcy5fdmlzZW1lTGVhZFRpbWUgfHwgMDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9vbkxheWVyQWRkZWQoe25hbWV9KSB7XHJcbiAgICBzdXBlci5fb25MYXllckFkZGVkKHtuYW1lfSk7XHJcblxyXG4gICAgLy8gVmFsaWRhdGUgdGhlIHZpc2VtZSBhbmltYXRpb25cclxuICAgIGlmICh0aGlzLl92aXNlbWVMYXllcnNbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aGlzLl9yZWdpc3RlclZpc2VtZUFuaW1hdGlvbihuYW1lLCB0aGlzLl92aXNlbWVMYXllcnNbbmFtZV0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX29uQW5pbWF0aW9uQWRkZWQoe2xheWVyTmFtZSwgYW5pbWF0aW9uTmFtZX0pIHtcclxuICAgIHN1cGVyLl9vbkFuaW1hdGlvbkFkZGVkKHtsYXllck5hbWV9KTtcclxuXHJcbiAgICAvLyBWYWxpZGF0ZSB0aGUgdmlzZW1lIGFuaW1hdGlvblxyXG4gICAgaWYgKHRoaXMuX3Zpc2VtZUxheWVyc1tsYXllck5hbWVdID09PSBhbmltYXRpb25OYW1lKSB7XHJcbiAgICAgIHRoaXMuX3JlZ2lzdGVyVmlzZW1lQW5pbWF0aW9uKGxheWVyTmFtZSwgdGhpcy5fdmlzZW1lTGF5ZXJzW2xheWVyTmFtZV0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX29uUGxheSgpIHtcclxuICAgIC8vIFR1cm4gb24gdGhlIGxheWVyIHdlaWdodHNcclxuICAgIHRoaXMuZW5hYmxlKCk7XHJcblxyXG4gICAgLy8gU2V0IHRoZSBjdXJyZW50IGFuaW1hdGlvbnNcclxuICAgIFt0aGlzLl92aXNlbWVMYXllcnMsIHRoaXMuX3RhbGtpbmdMYXllcnNdLmZvckVhY2gobGF5ZXJzID0+IHtcclxuICAgICAgT2JqZWN0LmVudHJpZXMobGF5ZXJzKS5mb3JFYWNoKChbbGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lXSkgPT4ge1xyXG4gICAgICAgIGlmICh0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0uYW5pbWF0aW9uc1thbmltYXRpb25OYW1lXS5pc0FjdGl2ZSkge1xyXG4gICAgICAgICAgdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlLnJlc3VtZUFuaW1hdGlvbihsYXllck5hbWUsIGFuaW1hdGlvbk5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIF9vblBhdXNlKCkge1xyXG4gICAgdGhpcy5fb25TdG9wKCk7XHJcbiAgfVxyXG5cclxuICBfb25SZXN1bWUoKSB7XHJcbiAgICB0aGlzLl9vblBsYXkoKTtcclxuICB9XHJcblxyXG4gIF9vblN0b3AoKSB7XHJcbiAgICAvLyBUdXJuIG9mZiB0aGUgbGF5ZXIgd2VpZ2h0c1xyXG4gICAgdGhpcy5kaXNhYmxlKCk7XHJcblxyXG4gICAgLy8gUGF1c2UgdGhlIGN1cnJlbnQgYW5pbWF0aW9uc1xyXG4gICAgW3RoaXMuX3Zpc2VtZUxheWVycywgdGhpcy5fdGFsa2luZ0xheWVyc10uZm9yRWFjaChsYXllcnMgPT4ge1xyXG4gICAgICBPYmplY3QuZW50cmllcyhsYXllcnMpLmZvckVhY2goKFtsYXllck5hbWUsIGFuaW1hdGlvbk5hbWVdKSA9PiB7XHJcbiAgICAgICAgaWYgKHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXS5hbmltYXRpb25zW2FuaW1hdGlvbk5hbWVdLmlzQWN0aXZlKSB7XHJcbiAgICAgICAgICB0aGlzLl9ob3N0LkFuaW1hdGlvbkZlYXR1cmUucGF1c2VBbmltYXRpb24obGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBXaGVuIHZpc2VtZSBldmVudHMgYXJlIGNhdWdodCwgdHVybiBvbiB3ZWlnaHQgb2YgdGhlIG5ldyB2aXNlbWUgZm9yIHRoZSBkdXJhdGlvblxyXG4gICAqIG9mIHRoZSBzcGVlY2ggbWFyaywgdGhlbiB0dXJuIHdlaWdodCBiYWNrIG9mZi5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBFdmVudCBkYXRhIHBhc3NlZCBmcm9tIHRoZSBzcGVlY2guXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm1hcmsgLSBTcGVlY2htYXJrIG9iamVjdC5cclxuICAgKi9cclxuICBhc3luYyBfb25WaXNlbWUoe21hcmt9KSB7XHJcbiAgICBPYmplY3QuZW50cmllcyh0aGlzLl92aXNlbWVMYXllcnMpLmZvckVhY2goKFtsYXllck5hbWUsIGFuaW1OYW1lXSkgPT4ge1xyXG4gICAgICAvLyBNYWtlIHN1cmUgdGhlIGxheWVyIGNhbiBiZSBtYW5pcHVsYXRlZFxyXG4gICAgICBjb25zdCB7aXNBY3RpdmUsIHZpc2VtZU1hcH0gPSB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0uYW5pbWF0aW9uc1tcclxuICAgICAgICBhbmltTmFtZVxyXG4gICAgICBdO1xyXG5cclxuICAgICAgaWYgKCFpc0FjdGl2ZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVGFrZSB2YXJpYWJsZXMgZnJvbSB0aGUgdmlzZW1lIGlmIHRoZXkgZXhpc3QgYW5kIGRlZmF1bHQgdG8gdGhlIGxheWVyXHJcbiAgICAgIGNvbnN0IHtcclxuICAgICAgICBuYW1lOiB2aXNlbWUsXHJcbiAgICAgICAgaXNBY3RpdmU6IGlzVmlzZW1lQWN0aXZlLFxyXG4gICAgICAgIGRlY2F5UmF0ZSxcclxuICAgICAgICBibGVuZFRpbWUsXHJcbiAgICAgICAgZWFzaW5nRm4sXHJcbiAgICAgICAgb3ZlcnJpZGVXZWlnaHQsXHJcbiAgICAgIH0gPSB7XHJcbiAgICAgICAgLi4udGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdLFxyXG4gICAgICAgIC4uLnZpc2VtZU1hcFttYXJrLnZhbHVlXSxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGNvbnN0IHZpc2VtZU5hbWVzID0gdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlLmdldEFuaW1hdGlvbkJsZW5kTmFtZXMoXHJcbiAgICAgICAgbGF5ZXJOYW1lLFxyXG4gICAgICAgIGFuaW1OYW1lXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBNYWtlIHN1cmUgdGhlIG5ldyB2aXNlbWUgaGFzIGFuIGFjdGl2ZSBmcmVlQmxlbmQgd2VpZ2h0XHJcbiAgICAgIGlmICghaXNWaXNlbWVBY3RpdmUgfHwgIXZpc2VtZU5hbWVzLmluY2x1ZGVzKHZpc2VtZSkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEZpbmQgdGhlIHBlYWsgd2VpZ2h0IGZvciB0aGUgdmlzZW1lIGFuZCB0aGUgYW1vdW50IG9mIHRpbWUgaXQgc2hvdWxkXHJcbiAgICAgIC8vIHRha2UgdG8gcmVhY2ggaXRcclxuICAgICAgbGV0IHdlaWdodCA9IDE7XHJcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gbWFyay5kdXJhdGlvbiAvIDEwMDA7XHJcbiAgICAgIGlmIChkdXJhdGlvbiA8IGJsZW5kVGltZSkge1xyXG4gICAgICAgIGNvbnN0IGxlcnBGYWN0b3IgPSBibGVuZFRpbWUgPiAwID8gZHVyYXRpb24gLyBibGVuZFRpbWUgOiAxO1xyXG4gICAgICAgIHdlaWdodCA9XHJcbiAgICAgICAgICBvdmVycmlkZVdlaWdodCAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgID8gb3ZlcnJpZGVXZWlnaHRcclxuICAgICAgICAgICAgOiBNYXRoVXRpbHMubGVycCgwLCAxLCBsZXJwRmFjdG9yKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBibGVuZEluVGltZSA9IE1hdGgubWluKGR1cmF0aW9uLCBibGVuZFRpbWUpO1xyXG5cclxuICAgICAgLy8gRmluZCB0aGUgYW1vdW50IGFuZCB0aW1lIHZpc2VtZSB3aWxsIGJlIGhlbGQgZm9yXHJcbiAgICAgIGNvbnN0IGhvbGRUaW1lID0gZHVyYXRpb24gLSBibGVuZFRpbWU7XHJcblxyXG4gICAgICBpZiAoaG9sZFRpbWUgPCAwKSB7XHJcbiAgICAgICAgLy8gUGVyZm9ybSBpbiAtPiBvdXQgYW5pbWF0aW9uXHJcbiAgICAgICAgdGhpcy5fYW5pbWF0ZVNpbXBsZVZpc2VtZShcclxuICAgICAgICAgIGxheWVyTmFtZSxcclxuICAgICAgICAgIGFuaW1OYW1lLFxyXG4gICAgICAgICAgdmlzZW1lLFxyXG4gICAgICAgICAgd2VpZ2h0LFxyXG4gICAgICAgICAgYmxlbmRJblRpbWUsXHJcbiAgICAgICAgICBibGVuZFRpbWUsXHJcbiAgICAgICAgICBlYXNpbmdGblxyXG4gICAgICAgICk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgbGVycEZhY3RvciA9XHJcbiAgICAgICAgICBkZWNheVJhdGUuc2Vjb25kcyA+IDAgPyBob2xkVGltZSAvIGRlY2F5UmF0ZS5zZWNvbmRzIDogMTtcclxuICAgICAgICAvLyBQZXJmb3JtIGluIC0+IGhvbGQgLT4gb3V0IGFuaW1hdGlvblxyXG4gICAgICAgIGNvbnN0IGRlY2F5V2VpZ2h0ID0gTWF0aFV0aWxzLmxlcnAoXHJcbiAgICAgICAgICB3ZWlnaHQsXHJcbiAgICAgICAgICB3ZWlnaHQgKiBkZWNheVJhdGUuYW1vdW50LFxyXG4gICAgICAgICAgTWF0aC5taW4oMSwgbGVycEZhY3RvcilcclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMuX2FuaW1hdGVIZWxkVmlzZW1lKFxyXG4gICAgICAgICAgbGF5ZXJOYW1lLFxyXG4gICAgICAgICAgYW5pbU5hbWUsXHJcbiAgICAgICAgICB2aXNlbWUsXHJcbiAgICAgICAgICB3ZWlnaHQsXHJcbiAgICAgICAgICBkZWNheVdlaWdodCxcclxuICAgICAgICAgIGJsZW5kSW5UaW1lLFxyXG4gICAgICAgICAgaG9sZFRpbWUsXHJcbiAgICAgICAgICBibGVuZFRpbWUsXHJcbiAgICAgICAgICBlYXNpbmdGblxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQW5pbWF0ZSBhIHZpc2VtZSBibGVuZCB3ZWlnaHQgdG93YXJkcyBhIHZhbHVlIGFuZCB0aGVuIGJhY2sgdG8gemVyby5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCBjb250YWlucyB0aGUgdmlzZW1lLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbmltTmFtZSAtIE5hbWUgb2YgdGhlIGZyZWVibGVuZCBhbmltYXRpb24gdGhhdCBjb250YWluc1xyXG4gICAqIHRoZSB2aXNlbWUuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpc2VtZU5hbWUgLSBOYW1lIG9mIHRoZSBibGVuZCB3ZWlnaHQgdG8gbWFuaXB1bGF0ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gd2VpZ2h0IC0gUGVhayB3ZWlnaHQgdG8gYW5pbWF0ZSB0b3dhcmRzLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBibGVuZEluVGltZSAtIEFtb3VudCBvZiB0aW1lIGl0IHNob3VsZCB0YWtlIHRvIHJlYWNoIHRoZVxyXG4gICAqIHBlYWsgd2VpZ2h0LlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBibGVuZE91dFRpbWUgLSBBbW91bnQgb2YgdGltZSBpdCBzaG91bGQgdGFrZSB0byBhbmltYXRlIGJhY2tcclxuICAgKiB0byB6ZXJvIGFmdGVyIHJlYWNoaW5nIHRoZSBwZWFrIHdlaWdodC5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYXNpbmdGbiAtIEVhc2luZyBmdW5jdGlvbiB0byB1c2UgZHVyaW5nIGFuaW1hdGlvbi5cclxuICAgKi9cclxuICBfYW5pbWF0ZVNpbXBsZVZpc2VtZShcclxuICAgIGxheWVyTmFtZSxcclxuICAgIGFuaW1OYW1lLFxyXG4gICAgdmlzZW1lTmFtZSxcclxuICAgIHBlYWtXZWlnaHQsXHJcbiAgICBibGVuZEluVGltZSxcclxuICAgIGJsZW5kT3V0VGltZSxcclxuICAgIGVhc2luZ0ZuXHJcbiAgKSB7XHJcbiAgICAvLyBBbmltYXRlIHRvd2FyZHMgdGhlIHBlYWsgdmFsdWVcclxuICAgIGNvbnN0IHdlaWdodFByb21pc2UgPSB0aGlzLl9ob3N0LkFuaW1hdGlvbkZlYXR1cmUuc2V0QW5pbWF0aW9uQmxlbmRXZWlnaHQoXHJcbiAgICAgIGxheWVyTmFtZSxcclxuICAgICAgYW5pbU5hbWUsXHJcbiAgICAgIHZpc2VtZU5hbWUsXHJcbiAgICAgIHBlYWtXZWlnaHQsXHJcbiAgICAgIGJsZW5kSW5UaW1lLFxyXG4gICAgICBlYXNpbmdGblxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBBbmltYXRlIGJhY2sgdG8gemVybyBpZiB0aGVyZSB3YXMgbm8gd2VpZ2h0IGludGVycnVwdGlvblxyXG4gICAgd2VpZ2h0UHJvbWlzZS50aGVuKCgpID0+IHtcclxuICAgICAgaWYgKCF3ZWlnaHRQcm9taXNlLmNhbmNlbGVkKSB7XHJcbiAgICAgICAgdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlLnNldEFuaW1hdGlvbkJsZW5kV2VpZ2h0KFxyXG4gICAgICAgICAgbGF5ZXJOYW1lLFxyXG4gICAgICAgICAgYW5pbU5hbWUsXHJcbiAgICAgICAgICB2aXNlbWVOYW1lLFxyXG4gICAgICAgICAgMCxcclxuICAgICAgICAgIGJsZW5kT3V0VGltZSxcclxuICAgICAgICAgIGVhc2luZ0ZuXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBbmltYXRlIGEgdmlzZW1lIGJsZW5kIHdlaWdodCB0b3dhcmRzIGEgdmFsdWUgYW5kIHRoZW4gYmFjayB0byB6ZXJvLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0aGF0IGNvbnRhaW5zIHRoZSB2aXNlbWUuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFuaW1OYW1lIC0gTmFtZSBvZiB0aGUgZnJlZWJsZW5kIGFuaW1hdGlvbiB0aGF0IGNvbnRhaW5zXHJcbiAgICogdGhlIHZpc2VtZS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlzZW1lTmFtZSAtIE5hbWUgb2YgdGhlIGJsZW5kIHdlaWdodCB0byBtYW5pcHVsYXRlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwZWFrV2VpZ2h0IC0gUGVhayB3ZWlnaHQgdG8gYW5pbWF0ZSB0b3dhcmRzLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWNheVdlaWdodCAtIFdlaWdodCB0byBhbmltYXRlIHRvd2FyZHMgYWZ0ZXIgcmVhY2hpbmcgdGhlXHJcbiAgICogcGVhayB3ZWlnaHQuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGJsZW5kSW5UaW1lIC0gQW1vdW50IG9mIHRpbWUgaXQgc2hvdWxkIHRha2UgdG8gcmVhY2ggdGhlXHJcbiAgICogcGVhayB3ZWlnaHQuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhvbGRUaW1lIC0gQW1vdW50IG9mIHRpbWUgaXQgc2hvdWxkIHRha2UgdG8gcmVhY2ggdGhlIGRlY2F5XHJcbiAgICogd2VpZ2h0IGFmdGVyIHRoZSBwZWFrIHdlaWdodCBoYXMgYmVlbiByZWFjaGVkLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBibGVuZE91dFRpbWUgLSBBbW91bnQgb2YgdGltZSBpdCBzaG91bGQgdGFrZSB0byBhbmltYXRlIGJhY2tcclxuICAgKiB0byB6ZXJvIGFmdGVyIHJlYWNoaW5nIHRoZSBkZWNheSB3ZWlnaHQuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFzaW5nRm4gLSBFYXNpbmcgZnVuY3Rpb24gdG8gdXNlIGR1cmluZyBhbmltYXRpb24uXHJcbiAgICovXHJcbiAgYXN5bmMgX2FuaW1hdGVIZWxkVmlzZW1lKFxyXG4gICAgbGF5ZXJOYW1lLFxyXG4gICAgYW5pbU5hbWUsXHJcbiAgICB2aXNlbWVOYW1lLFxyXG4gICAgcGVha1dlaWdodCxcclxuICAgIGRlY2F5V2VpZ2h0LFxyXG4gICAgYmxlbmRJblRpbWUsXHJcbiAgICBob2xkVGltZSxcclxuICAgIGJsZW5kT3V0VGltZSxcclxuICAgIGVhc2luZ0ZuXHJcbiAgKSB7XHJcbiAgICAvLyBBbmltYXRlIHRvd2FyZHMgdGhlIHBlYWsgdmFsdWVcclxuICAgIGNvbnN0IHN0YXJ0UHJvbWlzZSA9IHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5zZXRBbmltYXRpb25CbGVuZFdlaWdodChcclxuICAgICAgbGF5ZXJOYW1lLFxyXG4gICAgICBhbmltTmFtZSxcclxuICAgICAgdmlzZW1lTmFtZSxcclxuICAgICAgcGVha1dlaWdodCxcclxuICAgICAgYmxlbmRJblRpbWUsXHJcbiAgICAgIGVhc2luZ0ZuXHJcbiAgICApO1xyXG5cclxuICAgIGF3YWl0IHN0YXJ0UHJvbWlzZTtcclxuXHJcbiAgICBpZiAoIXN0YXJ0UHJvbWlzZS5jYW5jZWxlZCkge1xyXG4gICAgICAvLyBBbmltYXRlIHRvd2FyZHMgdGhlIGRlY2F5IHZhbHVlIGlmIHRoZXJlIHdhcyBubyB3ZWlnaHQgaW50ZXJydXB0aW9uXHJcbiAgICAgIGNvbnN0IGhvbGRQcm9taXNlID0gdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlLnNldEFuaW1hdGlvbkJsZW5kV2VpZ2h0KFxyXG4gICAgICAgIGxheWVyTmFtZSxcclxuICAgICAgICBhbmltTmFtZSxcclxuICAgICAgICB2aXNlbWVOYW1lLFxyXG4gICAgICAgIGRlY2F5V2VpZ2h0LFxyXG4gICAgICAgIGhvbGRUaW1lLFxyXG4gICAgICAgIGVhc2luZ0ZuXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBhd2FpdCBob2xkUHJvbWlzZTtcclxuXHJcbiAgICAgIGlmICghaG9sZFByb21pc2UuY2FuY2VsZWQpIHtcclxuICAgICAgICAvLyBBbmltYXRlIGJhY2sgdG8gemVybyBpZiB0aGVyZSB3YXMgbm8gd2VpZ2h0IGludGVycnVwdGlvblxyXG4gICAgICAgIHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5zZXRBbmltYXRpb25CbGVuZFdlaWdodChcclxuICAgICAgICAgIGxheWVyTmFtZSxcclxuICAgICAgICAgIGFuaW1OYW1lLFxyXG4gICAgICAgICAgdmlzZW1lTmFtZSxcclxuICAgICAgICAgIDAsXHJcbiAgICAgICAgICBibGVuZE91dFRpbWUsXHJcbiAgICAgICAgICBlYXNpbmdGblxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgYW5kIHNldHMgdGhlIGFtb3VudCBvZiB0aW1lIGluIHNlY29uZHMgdG8gbmVnYXRpdmVseSBvZmZzZXQgc3BlZWNobWFya1xyXG4gICAqIGVtaXNzaW9uIGJ5LlxyXG4gICAqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgdmlzZW1lTGVhZFRpbWUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fdmlzZW1lTGVhZFRpbWU7XHJcbiAgfVxyXG5cclxuICBzZXQgdmlzZW1lTGVhZFRpbWUoc2Vjb25kcykge1xyXG4gICAgdGhpcy5fdmlzZW1lTGVhZFRpbWUgPSBzZWNvbmRzO1xyXG5cclxuICAgIGlmICh0aGlzLl9ob3N0LlRleHRUb1NwZWVjaEZlYXR1cmUpIHtcclxuICAgICAgdGhpcy5faG9zdC5UZXh0VG9TcGVlY2hGZWF0dXJlLnNwZWVjaG1hcmtPZmZzZXQgPSAtc2Vjb25kcztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0IGtlZXBpbmcgdHJhY2sgb2YgYW4gYW5pbWF0aW9uIGxheWVyIHRoYXQgb3ducyBhIGZyZWVCbGVuZCBhbmltYXRpb25cclxuICAgKiB3aXRoIGJsZW5kV2VpZ2h0cyBjb3JyZXNwb25kaW5nIHRvIHZpc2VtZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdG8ga2VlcCB0cmFjayBvZi5cclxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgbGF5ZXIuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbj0ndmlzZW1lcyddIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uIG9uIHRoZVxyXG4gICAqIGxheWVyIHRoYXQgd2lsbCBiZSBwbGF5ZWQgZHVyaW5nIHNwZWVjaC4gVGhpcyBhbmltYXRpb24gbXVzdCBiZSBvZiB0eXBlXHJcbiAgICogZnJlZUJsZW5kLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gZGVjYXlSYXRlXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWNheVJhdGUuYW1vdW50PTAuNV0gLSBUaGUgcGVyY2VudGFnZSB0byBkZWNyZWFzZSB0aGUgdmlzZW1lJ3NcclxuICAgKiBwZWFrIHZhbHVlIGJ5IG92ZXIgdGltZSBvbmNlIHRoZSBwZWFrIHZhbHVlIGhhcyBiZWVuIHJlYWNoZWQuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWNheVJhdGUuc2Vjb25kcz0wLjVdIC0gVGhlIGFtb3VudCBvZiB0aW1lIGluIHNlY29uZHMgdG9cclxuICAgKiBkZWNyZWFzZSB0aGUgdmlzZW1lJ3Mgd2VpZ2h0IG9uY2UgaXQgaGFzIHJlYWNoZWQgaXRzIHBlYWsgdmFsdWUuXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSBbb3B0aW9ucy5ibGVuZFRpbWU9W0xpcHN5bmNGZWF0dXJlLkRFRkFVTFRfTEFZRVJfT1BUSU9OUy5ibGVuZFRpbWVde0BsaW5rIExpcHN5bmNGZWF0dXJlI0RFRkFVTFRfTEFZRVJfT1BUSU9OUyNibGVuZFRpbWV9XSAtXHJcbiAgICogRGVmYXVsdCBhbW91bnQgb2YgdGltZSB0byB1c2Ugd2hlbiBtYW5pcHVsYXRpbmcgYW5pbWF0aW9uIGJsZW5kV2VpZ2h0cy5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb3B0aW9ucy5lYXNpbmdGbiAtIERlZmF1bHQgZWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSB3aGVuXHJcbiAgICogbWFuaXB1bGF0aW5nIGFuaW1hdGlvbiBibGVuZFdlaWdodHMuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnZpc2VtZU1hcD1EZWZhdWx0VmlzZW1lTWFwXSAtIE9iamVjdCBjb250YWluaW5nIGtleS92YWx1ZSBwYWlycyBvZlxyXG4gICAqIFBvbGx5IHZpc2VtZSBuYW1lcyBtYXBwZWQgdG8gb2JqZWN0cyBjb250YWluaW5nIHRoZSBuYW1lIG9mIHRoZSBjb3JyZXNwb25kaW5nXHJcbiAgICogYW5pbWF0aW9uIGJsZW5kV2VpZ2h0IGFuZCBhbnkgb3RoZXIgYW5pbWF0aW9uIG9wdGlvbnMgdG8gdXNlIHN1Y2ggYXMgdmlzZW1lXHJcbiAgICogc3BlY2lmaWMgYmxlbmQgdGltZXMgYW5kIGVhc2luZyBmdW5jdGlvbnMuXHJcbiAgICovXHJcbiAgcmVnaXN0ZXJWaXNlbWVMYXllcihcclxuICAgIGxheWVyTmFtZSxcclxuICAgIHtcclxuICAgICAgYW5pbWF0aW9uID0gJ3Zpc2VtZXMnLFxyXG4gICAgICBkZWNheVJhdGUgPSB7YW1vdW50OiAwLjUsIHNlY29uZHM6IDAuNX0sXHJcbiAgICAgIGJsZW5kVGltZSA9IExpcHN5bmNGZWF0dXJlLkRFRkFVTFRfTEFZRVJfT1BUSU9OUy5ibGVuZFRpbWUsXHJcbiAgICAgIGVhc2luZ0ZuLFxyXG4gICAgICB2aXNlbWVNYXAgPSBEZWZhdWx0VmlzZW1lTWFwLFxyXG4gICAgfSA9IHt9XHJcbiAgKSB7XHJcbiAgICAvLyBSZWdpc3RlciB0aGUgbGF5ZXIgYW5kIGFuaW1hdGlvblxyXG4gICAgdGhpcy5yZWdpc3RlckxheWVyKGxheWVyTmFtZSwge1xyXG4gICAgICBkZWNheVJhdGUsXHJcbiAgICAgIGJsZW5kVGltZSxcclxuICAgICAgZWFzaW5nRm4sXHJcbiAgICAgIGFuaW1hdGlvbnM6IHtbYW5pbWF0aW9uXToge3Zpc2VtZU1hcH19LFxyXG4gICAgfSk7XHJcbiAgICB0aGlzLl92aXNlbWVMYXllcnNbbGF5ZXJOYW1lXSA9IGFuaW1hdGlvbjtcclxuXHJcbiAgICAvLyBWYWxpZGF0ZSB0aGUgdmlzZW1lIGFuaW1hdGlvblxyXG4gICAgdGhpcy5fcmVnaXN0ZXJWaXNlbWVBbmltYXRpb24obGF5ZXJOYW1lLCBhbmltYXRpb24pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnQga2VlcGluZyB0cmFjayBvZiBhbiBhbmltYXRpb24gbGF5ZXIgdGhhdCBjb250YWlucyBhIGxvb3BpbmcgYW5pbWF0aW9uXHJcbiAgICogdG8gYmUgcGxheWVkIGR1cmluZyBzcGVlY2guXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdG8ga2VlcCB0cmFjayBvZi5cclxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgbGF5ZXIuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbj0nc3RhbmRfdGFsayddIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uIG9uIHRoZVxyXG4gICAqIGxheWVyIHRoYXQgd2lsbCBiZSBwbGF5ZWQgZHVyaW5nIHNwZWVjaC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuYmxlbmRUaW1lPVtMaXBzeW5jRmVhdHVyZS5ERUZBVUxUX0xBWUVSX09QVElPTlMuYmxlbmRUaW1lXXtAbGluayBMaXBzeW5jRmVhdHVyZSNERUZBVUxUX0xBWUVSX09QVElPTlMjYmxlbmRUaW1lfV0gLVxyXG4gICAqIERlZmF1bHQgYW1vdW50IG9mIHRpbWUgdG8gdXNlIHdoZW4gbWFuaXB1bGF0aW5nIHRoZSBsYXllcidzIHdlaWdodHMuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9wdGlvbnMuZWFzaW5nRm4gLSBEZWZhdWx0IGVhc2luZyBmdW5jdGlvbiB0byB1c2Ugd2hlblxyXG4gICAqIG1hbmlwdWxhdGluZyB0aGUgbGF5ZXIncyB3ZWlnaHRzLlxyXG4gICAqL1xyXG4gIHJlZ2lzdGVyVGFsa2luZ0xheWVyKFxyXG4gICAgbGF5ZXJOYW1lLFxyXG4gICAge1xyXG4gICAgICBhbmltYXRpb24gPSAnc3RhbmRfdGFsaycsXHJcbiAgICAgIGJsZW5kVGltZSA9IExpcHN5bmNGZWF0dXJlLkRFRkFVTFRfTEFZRVJfT1BUSU9OUy5ibGVuZFRpbWUsXHJcbiAgICAgIGVhc2luZ0ZuLFxyXG4gICAgfSA9IHt9XHJcbiAgKSB7XHJcbiAgICAvLyBSZWdpc3RlciB0aGUgbGF5ZXIgYW5kIGFuaW1hdGlvblxyXG4gICAgdGhpcy5yZWdpc3RlckxheWVyKGxheWVyTmFtZSwge1xyXG4gICAgICBibGVuZFRpbWUsXHJcbiAgICAgIGVhc2luZ0ZuLFxyXG4gICAgICBhbmltYXRpb25zOiB7W2FuaW1hdGlvbl06IHt9fSxcclxuICAgIH0pO1xyXG4gICAgdGhpcy5fdGFsa2luZ0xheWVyc1tsYXllck5hbWVdID0gYW5pbWF0aW9uO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBhIG5hbWVzcGFjZSB0byB0aGUgaG9zdCB3aXRoIHRoZSBuYW1lIG9mIHRoZSBmZWF0dXJlIHRvIGNvbnRhaW4gcHJvcGVydGllc1xyXG4gICAqIGFuZCBtZXRob2RzIGZyb20gdGhlIGZlYXR1cmUgdGhhdCB1c2VycyBvZiB0aGUgaG9zdCBuZWVkIGFjY2VzcyB0by5cclxuICAgKlxyXG4gICAqIEBzZWUgTGlwc3luY0ZlYXR1cmVcclxuICAgKi9cclxuICBpbnN0YWxsQXBpKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqIEBuYW1lc3BhY2UgTGlwc3luY0ZlYXR1cmVcclxuICAgICAqL1xyXG4gICAgY29uc3QgYXBpID0gc3VwZXIuaW5zdGFsbEFwaSgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlcm9mIExpcHN5bmNGZWF0dXJlXHJcbiAgICAgKiBAbmFtZSByZWdpc3RlckxheWVyXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBzZWUgTWFuYWdlZEFuaW1hdGlvbkxheWVySW50ZXJmYWNlI3JlZ2lzdGVyTGF5ZXJcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlcm9mIExpcHN5bmNGZWF0dXJlXHJcbiAgICAgKiBAbmFtZSByZWdpc3RlckFuaW1hdGlvblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAc2VlIE1hbmFnZWRBbmltYXRpb25MYXllckludGVyZmFjZSNyZWdpc3RlckFuaW1hdGlvblxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyb2YgTGlwc3luY0ZlYXR1cmVcclxuICAgICAqIEBuYW1lIHNldExheWVyV2VpZ2h0c1xyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAc2VlIE1hbmFnZWRBbmltYXRpb25MYXllckludGVyZmFjZSNzZXRMYXllcldlaWdodHNcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlcm9mIExpcHN5bmNGZWF0dXJlXHJcbiAgICAgKiBAbmFtZSBlbmFibGVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQHNlZSBNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2UjZW5hYmxlXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXJvZiBMaXBzeW5jRmVhdHVyZVxyXG4gICAgICogQG5hbWUgZGlzYWJsZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAc2VlIE1hbmFnZWRBbmltYXRpb25MYXllckludGVyZmFjZSNkaXNhYmxlXHJcbiAgICAgKi9cclxuXHJcbiAgICBPYmplY3QuYXNzaWduKGFwaSwge1xyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIExpcHN5bmNGZWF0dXJlXHJcbiAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAqIEBzZWUgY29yZS9MaXBzeW5jRmVhdHVyZSNyZWdpc3RlclZpc2VtZUxheWVyXHJcbiAgICAgICAqL1xyXG4gICAgICByZWdpc3RlclZpc2VtZUxheWVyOiB0aGlzLnJlZ2lzdGVyVmlzZW1lTGF5ZXIuYmluZCh0aGlzKSxcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBtZW1iZXJvZiBMaXBzeW5jRmVhdHVyZVxyXG4gICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgKiBAc2VlIGNvcmUvTGlwc3luY0ZlYXR1cmUjcmVnaXN0ZXJUYWxraW5nTGF5ZXJcclxuICAgICAgICovXHJcbiAgICAgIHJlZ2lzdGVyVGFsa2luZ0xheWVyOiB0aGlzLnJlZ2lzdGVyVGFsa2luZ0xheWVyLmJpbmQodGhpcyksXHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXJvZiBMaXBzeW5jRmVhdHVyZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAbmFtZSB2aXNlbWVMZWFkVGltZVxyXG4gICAgICogQHNlZSBjb3JlL0xpcHN5bmNGZWF0dXJlI3Zpc2VtZUxlYWRUaW1lXHJcbiAgICAgKi9cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcGksICd2aXNlbWVMZWFkVGltZScsIHtcclxuICAgICAgZ2V0OiAoKSA9PiB0aGlzLnZpc2VtZUxlYWRUaW1lLFxyXG4gICAgICBzZXQ6IHNlY29uZHMgPT4ge1xyXG4gICAgICAgIHRoaXMudmlzZW1lTGVhZFRpbWUgPSBzZWNvbmRzO1xyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGFwaTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IExpcHN5bmNGZWF0dXJlO1xyXG5leHBvcnQge0RlZmF1bHRWaXNlbWVNYXB9O1xyXG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xyXG4vLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXHJcblxyXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtY2xhc3Nlcy1wZXItZmlsZSAqL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1lbXB0eSAqL1xyXG5pbXBvcnQgVGV4dFRvU3BlZWNoRmVhdHVyZURlcGVuZGVudEludGVyZmFjZSBmcm9tICdjb3JlL2F3c3BhY2svVGV4dFRvU3BlZWNoRmVhdHVyZURlcGVuZGVudEludGVyZmFjZSc7XHJcblxyXG4vKipcclxuICogQ2xhc3MgZmFjdG9yeSBpbnRlcmZhY2UgZm9yIHRoYXQgcmVnaXN0ZXJzIGNhbGxiYWNrIG1ldGhvZCB3aGVuIGEgc3NtbCBzcGVlY2htYXJrIGV2ZW50IGlzIGVtaXR0ZWQuXHJcbiAqXHJcbiAqIEBpbnRlcmZhY2VcclxuICogQGV4dGVuZHMgVGV4dFRvU3BlZWNoRmVhdHVyZURlcGVuZGVudEludGVyZmFjZVxyXG4gKi9cclxuY2xhc3MgU1NNTFNwZWVjaG1hcmtJbnRlcmZhY2UgZXh0ZW5kcyBUZXh0VG9TcGVlY2hGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlIHtcclxuICAvKipcclxuICAgKiBXaGVuIHNzbWwgZXZlbnRzIGFyZSBjYXVnaHQsIHRoaXMgd2lsbCB0cnkgdG8gcGFyc2UgdGhlIHNwZWVjaCBtYXJrIHZhbHVlIGFuZCBleGVjdXRlIGFueSBmdW5jdGlvbiB3aGljaCBtZWV0cyBjcml0ZXJpYSBkZWZpbmVkIGluIHRoZSB2YWx1ZS5cclxuICAgKiBTcGVlY2ggbWFyayB2YWx1ZSB3aWxsIGJlIHRyZWF0ZWQgYXMgc3RyaW5naWZpZWQganNvbiBmb3JtYXQgY29udGFpbmluZyByZXF1aXJlZCBmZWF0dXJlIG5hbWUsIGZ1bmN0aW9uIG5hbWUgYW5kIGFyZ3VtZW50IGFycmF5IHRvIHBhc3MgaW4uXHJcbiAgICogRXhhbXBsZSBzcGVlY2ggbWFyayB2YWx1ZSBtaWdodCBsb29rIGxpa2U6ICd7XCJmZWF0dXJlXCI6XCJHZXN0dXJlRmVhdHVyZVwiLCBcIm1ldGhvZFwiOlwic3dpdGNoVG9HZXN0dXJlXCIsIFwiYXJnc1wiOltcImdlbnJpY0FcIiwgMC41XX0nXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gRXZlbnQgZGF0YSBwYXNzZWQgZnJvbSB0aGUgc3BlZWNoLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5tYXJrIC0gU3BlZWNobWFyayBvYmplY3QuXHJcbiAgICovXHJcbiAgX29uU3NtbCh7bWFya30pIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBjbGFzcyB0aGF0IGltcGxlbWVudHMge0BsaW5rIFNTTUxTcGVlY2htYXJrSW50ZXJmYWNlfVxyXG4gICAqIGFuZCBleHRlbmRzIGEgc3BlY2lmaWVkIGJhc2UgY2xhc3MuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0NsYXNzfSBCYXNlQ2xhc3MgLSBUaGUgY2xhc3MgdG8gZXh0ZW5kLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Q2xhc3N9IEEgY2xhc3MgdGhhdCBleHRlbmRzIGBCYXNlQ2xhc3NgIGFuZCBpbXBsZW1lbnRzIHtAbGluayBTU01MU3BlZWNobWFya0ludGVyZmFjZX0uXHJcbiAgICovXHJcbiAgc3RhdGljIE1peGluKEJhc2VDbGFzcykge1xyXG4gICAgY29uc3QgUGFyZW50Q2xhc3MgPSBUZXh0VG9TcGVlY2hGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlLk1peGluKEJhc2VDbGFzcyk7XHJcbiAgICBjb25zdCBTU01MU3BlZWNoTWFya01peGluID0gY2xhc3MgZXh0ZW5kcyBQYXJlbnRDbGFzcyB7XHJcbiAgICAgIF9vblNzbWwoe21hcmt9KSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IHtmZWF0dXJlLCBtZXRob2QsIGFyZ3N9ID0gSlNPTi5wYXJzZShtYXJrLnZhbHVlKTtcclxuICAgICAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLm5hbWUgPT09IGZlYXR1cmUpIHtcclxuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzW21ldGhvZF07XHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayAmJiB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzKVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRnVuY3Rpb24gJHttZXRob2R9IGRvZXMgbm90IGV4aXN0IHdpdGhpbiBmZWF0dXJlICR7ZmVhdHVyZX1gKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaChlKSB7fVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBTU01MU3BlZWNoTWFya01peGluO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgU1NNTFNwZWVjaG1hcmtJbnRlcmZhY2U7XHJcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcclxuaW1wb3J0IE1hbmFnZWRBbmltYXRpb25MYXllckludGVyZmFjZSBmcm9tICcuL2FuaW1wYWNrL01hbmFnZWRBbmltYXRpb25MYXllckludGVyZmFjZSc7XHJcbmltcG9ydCBTU01MU3BlZWNobWFya0ludGVyZmFjZSBmcm9tICcuL2F3c3BhY2svU1NNTFNwZWVjaG1hcmtJbnRlcmZhY2UnO1xyXG5pbXBvcnQgQWJzdHJhY3RIb3N0RmVhdHVyZSBmcm9tICcuL0Fic3RyYWN0SG9zdEZlYXR1cmUnO1xyXG5pbXBvcnQgRGVmZXJyZWQgZnJvbSAnLi9EZWZlcnJlZCc7XHJcbmltcG9ydCBVdGlscyBmcm9tICcuL1V0aWxzJztcclxuXHJcbmNvbnN0IERlZmF1bHRHZXN0dXJlV29yZHMgPSB7XHJcbiAgYmlnOiBbXHJcbiAgICAnYWRkJyxcclxuICAgICdhYm92ZScsXHJcbiAgICAnYXV0aG9yaXR5JyxcclxuICAgICdiaWcnLFxyXG4gICAgJ2NvdmVyJyxcclxuICAgICdmdWxsJyxcclxuICAgICdmbHknLFxyXG4gICAgJ2dyb3cnLFxyXG4gICAgJ2dyb3d0aCcsXHJcbiAgICAnaGlnaCcsXHJcbiAgICAnaHVnZScsXHJcbiAgICAnaW5jcmVhc2UnLFxyXG4gICAgJ21ham9yJyxcclxuICAgICdtYWpvcml0eScsXHJcbiAgICAnbGFyZ2UnLFxyXG4gICAgJ2xlYWRlcicsXHJcbiAgICAnbG90JyxcclxuICAgICdyYWlzZScsXHJcbiAgICAncmlzZScsXHJcbiAgICAndGFsbCcsXHJcbiAgXSxcclxuICBoZWFydDogW1xyXG4gICAgJ2FjY2VwdCcsXHJcbiAgICAnYWRtaXQnLFxyXG4gICAgJ2JlbGlldmUnLFxyXG4gICAgJ2NhcmUnLFxyXG4gICAgJ2ZlZWxpbmcnLFxyXG4gICAgJ2ZlZWwnLFxyXG4gICAgJ2ZyaWVuZCcsXHJcbiAgICAnZ3JhdGVmdWwnLFxyXG4gICAgJ2hhcHB5JyxcclxuICAgICdoZWFydCcsXHJcbiAgICAnaHVtYW4nLFxyXG4gICAgJ3BhaW4nLFxyXG4gICAgJ3NhdmUnLFxyXG4gICAgJ3NhZmUnLFxyXG4gICAgJ2tpbmQnLFxyXG4gICAgJ2xvdmUnLFxyXG4gIF0sXHJcbiAgaW46IFtcclxuICAgICdpbmNsdWRlJyxcclxuICAgICdpbmNsdWRpbmcnLFxyXG4gICAgJ2luc2lkZScsXHJcbiAgICAnaW50bycsXHJcbiAgICAnbm93JyxcclxuICAgICduZWFyJyxcclxuICAgICduZWFyZXN0JyxcclxuICAgICdjbG9zZXN0JyxcclxuICAgICd0aGVyZWluJyxcclxuICAgICd3aXRoaW4nLFxyXG4gIF0sXHJcbiAgbWFueTogW1xyXG4gICAgJ2FsbCcsXHJcbiAgICAnYWx3YXlzJyxcclxuICAgICdhbnknLFxyXG4gICAgJ2FueW9uZScsXHJcbiAgICAnYW1vbmcnLFxyXG4gICAgJ2FyZWEnLFxyXG4gICAgJ2Fyb3VuZCcsXHJcbiAgICAnYmVhdXRpZnVsJyxcclxuICAgICdlbnRpcmUnLFxyXG4gICAgJ2Vudmlyb25tZW50JyxcclxuICAgICdlbnZpcm9ubWVudHMnLFxyXG4gICAgJ2Vudmlyb25tZW50YWwnLFxyXG4gICAgJ2V2ZXJ5Ym9keScsXHJcbiAgICAnZXZlcnlvbmUnLFxyXG4gICAgJ2V2ZXJ5dGhpbmcnLFxyXG4gICAgJ2F1ZGllbmNlJyxcclxuICAgICd0b3RhbCcsXHJcbiAgICAnZ3JvdXAnLFxyXG4gICAgJ2dyb3VwcycsXHJcbiAgICAnbWlsbGlvbicsXHJcbiAgICAnbWlsbGlvbnMnLFxyXG4gICAgJ290aGVycycsXHJcbiAgICAnYmlsbGlvbicsXHJcbiAgICAnYmlsbGlvbnMnLFxyXG4gICAgJ2h1bmRyZWQnLFxyXG4gICAgJ2h1bmRyZWRzJyxcclxuICAgICdtYW55JyxcclxuICAgICd0aG91c2FuZCcsXHJcbiAgICAndGhvdXNhbmRzJyxcclxuICAgICd3b3JsZCcsXHJcbiAgICAnd29ybGRzJyxcclxuICAgICdvdXRzaWRlJyxcclxuICAgICdyZXZlYWwnLFxyXG4gIF0sXHJcbiAgbW92ZW1lbnQ6IFtcclxuICAgICdhd2F5JyxcclxuICAgICdhY3Jvc3MnLFxyXG4gICAgJ2FoZWFkJyxcclxuICAgICdhbG9uZycsXHJcbiAgICAnZmFyJyxcclxuICAgICdmYXN0JyxcclxuICAgICdmb2xsb3cnLFxyXG4gICAgJ2dvJyxcclxuICAgICdsZWF2ZScsXHJcbiAgICAnbW92ZScsXHJcbiAgICAnbW92ZW1lbnQnLFxyXG4gICAgJ3Rocm91Z2gnLFxyXG4gICAgJ3Rocm91Z2hvdXQnLFxyXG4gICAgJ3Rvd2FyZCcsXHJcbiAgICAndHJhdmVsJyxcclxuICAgICd0dXJuZWQnLFxyXG4gICAgJ3Bhc3NlZCcsXHJcbiAgXSxcclxuICBvbmU6IFtcclxuICAgICdzaW5nbGUnLFxyXG4gICAgJ29uZScsXHJcbiAgICAnb25jZScsXHJcbiAgICAnZmlyc3QnLFxyXG4gICAgJ2ZpcnN0bHknLFxyXG4gICAgJ29ubHknLFxyXG4gICAgJ3NvbG8nLFxyXG4gICAgJ3dhcm5lZCcsXHJcbiAgICAndHJ1bHknLFxyXG4gICAgJ3VwJyxcclxuICAgICdhbG9uZScsXHJcbiAgXSxcclxuICBhZ2dyZXNzaXZlOiBbXHJcbiAgICAncG93ZXInLFxyXG4gICAgJ3Bvd2VycycsXHJcbiAgICAncG93ZXJmdWwnLFxyXG4gICAgJ2Fzc2VydCcsXHJcbiAgICAnYXNzZXJ0aXZlJyxcclxuICAgICdzdHJvbmcnLFxyXG4gICAgJ3N0cm9uZ2VyJyxcclxuICAgICdzdHJvbmdlc3QnLFxyXG4gICAgJ3N0cmVuZ3RoJyxcclxuICAgICdmbGV4JyxcclxuICAgICdkYW5nJyxcclxuICAgICdkYW1uJyxcclxuICAgICdkYW1uaXQnLFxyXG4gICAgJ2Rhcm4nLFxyXG4gICAgJ3NodWNrcycsXHJcbiAgICAnZG9oJyxcclxuICAgICdkcmF0JyxcclxuICAgICdhbmdyeScsXHJcbiAgICAnYW5ncmllcicsXHJcbiAgICAnYW5ncmllc3QnLFxyXG4gICAgJ2FnZ3Jlc3NpdmUnLFxyXG4gICAgJ2Fubm95ZWQnLFxyXG4gICAgJ2Fubm95aW5nJyxcclxuICAgICdhdHRhY2snLFxyXG4gICAgJ2F0dGFja2luZycsXHJcbiAgICAnb2ZmZW5zZScsXHJcbiAgICAnb2ZmZW5zaXZlJyxcclxuICAgICdiYXR0bGUnLFxyXG4gIF0sXHJcbiAgeW91OiBbJ3lvdScsICd5YWxsJywgXCJ5J2FsbFwiLCAneW91cicsICd5b3VycycsICd0aG91JywgJ3RoeSddLFxyXG4gIGRlZmVuc2U6IFtcclxuICAgICdkZWZlbnNlJyxcclxuICAgICdmZWFyJyxcclxuICAgICdyZXB1bHNlZCcsXHJcbiAgICAnc2NhcmVkJyxcclxuICAgICdzY2FyeScsXHJcbiAgICAnc2NhcmllcicsXHJcbiAgICAnc2Nhcmllc3QnLFxyXG4gICAgJ2ZlYXJmdWwnLFxyXG4gICAgJ2FmcmFpZCcsXHJcbiAgICAnY293ZXInLFxyXG4gICAgJ2Nvd2VycycsXHJcbiAgICAnY293ZXJpbmcnLFxyXG4gICAgJ2hpZGVvdXMnLFxyXG4gICAgJ2Rvb21lZCcsXHJcbiAgICAndGVycmlmaWVkJyxcclxuICAgICd0ZXJyaWZ5JyxcclxuICAgICd0ZXJyaWZ5aW5nJyxcclxuICAgICd0ZXJyaWZpZXMnLFxyXG4gICAgJ3Nwb29reScsXHJcbiAgICAnc3Bvb2tpZXInLFxyXG4gICAgJ3Nwb29raWVzdCcsXHJcbiAgXSxcclxuICB3YXZlOiBbXHJcbiAgICAnaGVsbG8nLFxyXG4gICAgJ2hpJyxcclxuICAgICdoaXlhJyxcclxuICAgICdob3dkeScsXHJcbiAgICAnd2VsY29tZScsXHJcbiAgICAnYWxvaGEnLFxyXG4gICAgJ2hleWEnLFxyXG4gICAgJ2hleScsXHJcbiAgICAnYnllJyxcclxuICAgICdnb29kYnllJyxcclxuICAgICdob2xhJyxcclxuICAgICdhZGlvcycsXHJcbiAgICAnY2hhbycsXHJcbiAgXSxcclxuICBzZWxmOiBbJ215JywgJ0knLCAnbXlzZWxmJywgJ3NlbGYnLCBcIkkndmVcIiwgJ0l2ZScsICdtZScsICdtaW5lJywgJ293biddLFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdlc3R1cmUgYWxsb3dzIHlvdSB0byBwbGF5IGFuaW1hdGlvbnMgb24gZGVtYW5kIG9uIG9uZSBvciBtb3JlIGxheWVycyBmcm9tIHNjcmlwdFxyXG4gKiBvciBzc21sLiBJZiBnZXN0dXJlIGlzIHBsYXllZCB0aGF0IGlzIGEgUXVldWVTdGF0ZSwgdGhlIHF1ZXVlIHdpbGwgYXV0b21hdGljYWxseVxyXG4gKiBiZSBwcm9ncmVzc2VkIGFmdGVyIGEgZ2l2ZW4gaG9sZCB0aW1lIGlmIGEgbG9vcGluZyBxdWV1ZWQgc3RhdGUgaXMgcmVhY2hlZC4gR2VzdHVyZVxyXG4gKiBsYXllcnMgY2FuIG9wdGlvbmFsbHkgYmUgYXV0b21hdGljYWxseSBkaXNhYmxlZCB3aGVuIG5vIGdlc3R1cmUgYW5pbWF0aW9uIGlzXHJcbiAqIGluIHByb2dyZXNzLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEhvc3RGZWF0dXJlXHJcbiAqIEBpbXBsZW1lbnRzIFNTTUxTcGVlY2htYXJrSW50ZXJmYWNlXHJcbiAqIEBpbXBsZW1lbnRzIE1hbmFnZWRBbmltYXRpb25MYXllckludGVyZmFjZVxyXG4gKi9cclxuY2xhc3MgR2VzdHVyZUZlYXR1cmUgZXh0ZW5kcyBBYnN0cmFjdEhvc3RGZWF0dXJlLm1peChcclxuICBTU01MU3BlZWNobWFya0ludGVyZmFjZS5NaXhpbixcclxuICBNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2UuTWl4aW5cclxuKSB7XHJcbiAgLyoqXHJcbiAgICogQGNvbnN0cnVjdG9yXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2NvcmUvSG9zdE9iamVjdH0gaG9zdCAtIEhvc3Qgb2JqZWN0IHRoYXQgb3ducyB0aGUgZmVhdHVyZS5cclxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgLSBPcHRpb25hbCBvcHRpb25zIGZvciB0aGUgZmVhdHVyZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaG9sZFRpbWUgPSAzXSAtIEFtb3VudCBvZiB0aW1lIGluIHNlY29uZHMgdGhhdCBtdXN0XHJcbiAgICogZWxhcHNlIGJlZm9yZSBhZHZhbmNpbmcgYSBnZXN0dXJlIHRoYXQncyBhIHtAbGluayBRdWV1ZVN0YXRlfSB3aGVuIHRoZSBjdXJyZW50XHJcbiAgICogc3RhdGUgaW4gdGhlIHF1ZXVlIGlzIHNldCB0byBsb29wIGluZmluaXRlbHkuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1pbmltdW1JbnRlcnZhbCA9IDAuMjVdIC0gVGhlIG1pbmltdW0gYW1vdW50IG9mIHRpbWVcclxuICAgKiBpbiBzZWNvbmRzIHRoYXQgbXVzdCBlbGFwc2UgYmVmb3JlIGFub3RoZXIgZ2VzdHVyZSBjYW4gYmUgcGxheWVkLlxyXG4gICAqIEBwYXJhbSAge09iamVjdH0gbGF5ZXJzIC0gQW4gb2JqZWN0IHRoYXQgbWFwcyBsYXllciBuYW1lcyB0byBsYXllciBvcHRpb25zLlxyXG4gICAqIFRoZXNlIGFyZSB0aGUgbGF5ZXJzIHRoYXQgd2lsbCBiZSByZWdpc3RlcmVkIGFzIHRyYWNrZWQgZ2VzdHVyZSBsYXllcnMuIFNlZVxyXG4gICAqIHtAbGluayBNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2UjcmVnaXN0ZXJMYXllcn0gZm9yIG1vcmUgaW5mb3JtYXRpb25cclxuICAgKiBvbiBleHBlY3RlZCBmb3JtYXQgZm9yIGVhY2ggbGF5ZXIgb3B0aW9ucyBvYmplY3QuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoaG9zdCwge2hvbGRUaW1lID0gMywgbWluaW11bUludGVydmFsID0gMSwgbGF5ZXJzID0ge319ID0ge30pIHtcclxuICAgIHN1cGVyKGhvc3QpO1xyXG5cclxuICAgIHRoaXMuaG9sZFRpbWUgPSBob2xkVGltZTtcclxuICAgIHRoaXMubWluaW11bUludGVydmFsID0gbWluaW11bUludGVydmFsO1xyXG5cclxuICAgIC8vIFJlZ2lzdGVyIHRoZSBnZXN0dXJlIGxheWVyc1xyXG4gICAgT2JqZWN0LmVudHJpZXMobGF5ZXJzKS5mb3JFYWNoKChbbmFtZSwgb3B0aW9ucyA9IHt9XSkgPT4ge1xyXG4gICAgICB0aGlzLnJlZ2lzdGVyTGF5ZXIobmFtZSwgb3B0aW9ucyk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiBhIHZhbGlkIGhvbGQgdGltZSB2YWx1ZS4gSWYgaG9sZCB0aW1lIGlzbid0IGRlZmluZWQgZm9yIHRoZSBhbmltYXRpb24sXHJcbiAgICogdHJ5IHRvIHVzZSB0aGUgaG9sZCB0aW1lIGZvciB0aGUgbGF5ZXIuIElmIHRoYXQncyBub3QgZGVmaW5lZCwgZmFsbCBiYWNrIHRvXHJcbiAgICogdGhlIGhvbGQgdGltZSBmb3IgdGhlIGZlYXR1cmUuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGxheWVyIC0gTWFuYWdlZCBsYXllciBvcHRpb25zIG9iamVjdC5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gYW5pbWF0aW9uIC0gTWFuYWdlZCBhbmltYXRpb24gb3B0aW9ucyBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIF9nZXRIb2xkVGltZShsYXllciwgYW5pbWF0aW9uKSB7XHJcbiAgICBjb25zdCBsYXllckhvbGRUaW1lID1cclxuICAgICAgbGF5ZXIuaG9sZFRpbWUgIT09IHVuZGVmaW5lZCA/IGxheWVyLmhvbGRUaW1lIDogdGhpcy5ob2xkVGltZTtcclxuXHJcbiAgICByZXR1cm4gYW5pbWF0aW9uLmhvbGRUaW1lICE9PSB1bmRlZmluZWRcclxuICAgICAgPyBhbmltYXRpb24uaG9sZFRpbWVcclxuICAgICAgOiBsYXllckhvbGRUaW1lO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgdmFsaWQgbWluaW11bSBpbnRlcnZhbCB2YWx1ZS4gSWYgbWluaW11bSBpbnRlcnZhbCBpc24ndCBkZWZpbmVkIGZvclxyXG4gICAqIHRoZSBhbmltYXRpb24sIHRyeSB0byB1c2UgdGhlIG1pbmltdW0gaW50ZXJ2YWwgZm9yIHRoZSBsYXllci4gSWYgdGhhdCdzIG5vdFxyXG4gICAqIGRlZmluZWQsIGZhbGwgYmFjayB0byB0aGUgbWluaW11bSBpbnRlcnZhbCBmb3IgdGhlIGZlYXR1cmUuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGxheWVyIC0gTWFuYWdlZCBsYXllciBvcHRpb25zIG9iamVjdC5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gYW5pbWF0aW9uIC0gTWFuYWdlZCBhbmltYXRpb24gb3B0aW9ucyBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIF9nZXRNaW5pbXVtSW50ZXJ2YWwobGF5ZXIsIGFuaW1hdGlvbikge1xyXG4gICAgY29uc3QgbGF5ZXJNaW5pbXVtSW50ZXJ2YWwgPVxyXG4gICAgICBsYXllci5taW5pbXVtSW50ZXJ2YWwgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgID8gbGF5ZXIubWluaW11bUludGVydmFsXHJcbiAgICAgICAgOiB0aGlzLm1pbmltdW1JbnRlcnZhbDtcclxuXHJcbiAgICByZXR1cm4gYW5pbWF0aW9uLm1pbmltdW1JbnRlcnZhbCAhPT0gdW5kZWZpbmVkXHJcbiAgICAgID8gYW5pbWF0aW9uLm1pbmltdW1JbnRlcnZhbFxyXG4gICAgICA6IGxheWVyTWluaW11bUludGVydmFsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsbGJhY2sgZm9yIHtAbGluayBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjcGxheU5leHRBbmltYXRpb259IGV2ZW50LiBJZiB0aGVcclxuICAgKiBldmVudCBpcyBlbWl0dGVkIGZvciBhIG1hbmFnZWQgYW5pbWF0aW9uIGFuZCB0aGUgbmV3IHF1ZXVlZCBzdGF0ZSBjYW5ub3RcclxuICAgKiBhZHZhbmNlIG9uIGl0cyBvd24sIHN0YXJ0IGEgbmV3IHRpbWVyIHByb21pc2UgdGhhdCB3aWxsIGFkdmFuY2UgdGhlIHF1ZXVlXHJcbiAgICogb25jZSBpdCByZXNvbHZlcy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgb2JqZWN0IHBhc3NlZCBmcm9tIHBsYXlOZXh0QW5pbWF0aW9uIGV2ZW50LlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0aGF0IG93bnMgdGhlIHF1ZXVlIHN0YXRlLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbmltYXRpb25OYW1lIC0gTmFtZSBvZiB0aGUgcXVldWUgc3RhdGUgYW5pbWF0aW9uLlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2FuQWR2YW5jZSAtIFdoZXRoZXIgb3Igbm90IHRoZSBjdXJyZW50IHN0YXRlIGluIHRoZSBxdWV1ZVxyXG4gICAqIGNhbiBhZHZhbmNlIG9uIGl0cyBvd24uXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBpc1F1ZXVlRW5kIC0gV2hldGhlciB0aGUgY3VycmVudCBzdGF0ZSBpbiB0aGUgcXVldWUgaXMgdGhlIGxhc3RcclxuICAgKiBzdGF0ZSBpbiB0aGUgcXVldWUuXHJcbiAgICovXHJcbiAgX29uTmV4dCh7bGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lLCBjYW5BZHZhbmNlLCBpc1F1ZXVlRW5kfSkge1xyXG4gICAgLy8gRXhpdCBpZiB0aGlzIGlzbid0IGEgbWFuYWdlZCBsYXllclxyXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV07XHJcbiAgICBpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRXhpdCBpZiBpdCBpc24ndCBhIG1hbmFnZWQgYW5pbWF0aW9uXHJcbiAgICBjb25zdCBhbmltYXRpb24gPSBsYXllci5hbmltYXRpb25zW2FuaW1hdGlvbk5hbWVdO1xyXG4gICAgaWYgKGFuaW1hdGlvbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdGFydCBhIG5ldyB0aW1lciBmb3IgbG9vcGluZyBzdGF0ZXMgdGhhdCBhcmVuJ3QgdGhlIGVuZCBvZiB0aGUgcXVldWVcclxuICAgIGlmICghY2FuQWR2YW5jZSAmJiAhaXNRdWV1ZUVuZCAmJiBsYXllci5jdXJyZW50R2VzdHVyZSA9PT0gYW5pbWF0aW9uTmFtZSkge1xyXG4gICAgICBjb25zdCBob2xkVGltZSA9IHRoaXMuX2dldEhvbGRUaW1lKGxheWVyLCBhbmltYXRpb24pO1xyXG4gICAgICBsYXllci5ob2xkVGltZXIuY2FuY2VsKCk7XHJcblxyXG4gICAgICAvLyBTa2lwIHRvIHRoZSBuZXh0IGFuaW1hdGlvbiByaWdodCBhd2F5IGlmIGhvbGQgdGltZSBpcyB6ZXJvXHJcbiAgICAgIGlmIChob2xkVGltZSA8PSAwKSB7XHJcbiAgICAgICAgdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlLnBsYXlOZXh0QW5pbWF0aW9uKGxheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFdhaXQgZm9yIHRoZSBnaXZlbiBob2xkIHRpbWUgYmVmb3JlIHByb2dyZXNzaW5nXHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGxheWVyLmhvbGRUaW1lciA9IFV0aWxzLndhaXQoaG9sZFRpbWUsIHtcclxuICAgICAgICAgIG9uRmluaXNoOiAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIEFkdmFuY2UgdGhlIHF1ZXVlIHRvIHRoZSBuZXh0IHN0YXRlXHJcbiAgICAgICAgICAgIGlmIChsYXllci5jdXJyZW50R2VzdHVyZSA9PT0gYW5pbWF0aW9uTmFtZSkge1xyXG4gICAgICAgICAgICAgIHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5wbGF5TmV4dEFuaW1hdGlvbihcclxuICAgICAgICAgICAgICAgIGxheWVyTmFtZSxcclxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbk5hbWVcclxuICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxsYmFjayBmb3Ige0BsaW5rIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNzdG9wQW5pbWF0aW9ufSBldmVudC4gSWYgdGhlXHJcbiAgICogZXZlbnQgaXMgZW1pdHRlZCBmb3IgYSBtYW5hZ2VkIGFuaW1hdGlvbiBjYW5jZWwgdGhlIGxheWVyJ3Mgc3RvcmVkIHRpbWVycy5cclxuICAgKiBJZiB0aGUgbGF5ZXIgaXMgc2V0IHRvIGF1dG8tZGlzYWJsZSBzZXQgaXRzIHdlaWdodCB0byAwLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyBvYmplY3QgcGFzc2VkIGZyb20gcGxheU5leHRBbmltYXRpb24gZXZlbnQuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRoYXQgb3ducyB0aGUgc3RvcHBlZCBhbmltYXRpb24uXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFuaW1hdGlvbk5hbWUgLSBOYW1lIG9mIHRoZSBhbmltYXRpb24gdGhhdCB3YXMgc3RvcHBlZC5cclxuICAgKi9cclxuICBfb25TdG9wKHtsYXllck5hbWUsIGFuaW1hdGlvbk5hbWV9KSB7XHJcbiAgICAvLyBNYWtlIHN1cmUgdGhlIGxheWVyIGlzIG1hbmFnZWRcclxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdO1xyXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgYW5pbWF0aW9uIGlzIG1hbmFnZWRcclxuICAgIGNvbnN0IGFuaW1hdGlvbiA9IGxheWVyLmFuaW1hdGlvbnNbYW5pbWF0aW9uTmFtZV07XHJcbiAgICBpZiAoYW5pbWF0aW9uICE9PSB1bmRlZmluZWQgJiYgYW5pbWF0aW9uTmFtZSA9PT0gbGF5ZXIuY3VycmVudEdlc3R1cmUpIHtcclxuICAgICAgbGF5ZXIuY3VycmVudEdlc3R1cmUgPSBudWxsO1xyXG4gICAgICBsYXllci5wbGF5VGltZXIgPSBudWxsO1xyXG4gICAgICBsYXllci5ob2xkVGltZXIuY2FuY2VsKCk7XHJcblxyXG4gICAgICAvLyBUdXJuIG9mZiBsYXllciB3ZWlnaHRcclxuICAgICAgaWYgKGxheWVyLmF1dG9EaXNhYmxlKSB7XHJcbiAgICAgICAgdGhpcy5zZXRMYXllcldlaWdodHMobmFtZSA9PiBuYW1lID09PSBsYXllck5hbWUsIDApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfb25BbmltYXRpb25BZGRlZCh7bGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lfSkge1xyXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV07XHJcblxyXG4gICAgaWYgKGxheWVyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgY29uc3QgYW5pbWF0aW9uID0gbGF5ZXIuYW5pbWF0aW9uc1thbmltYXRpb25OYW1lXTtcclxuXHJcbiAgICAgIC8vIFJlZ2lzdGVyIHRoZSBhbmltYXRpb24gYXMgYWN0aXZlIGlmIGl0IGlzIHVubWFuYWdlZFxyXG4gICAgICBpZiAoYW5pbWF0aW9uID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0aGlzLnJlZ2lzdGVyQW5pbWF0aW9uKGxheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gTWFyayB0aGUgYW5pbWF0aW9uIGFzIGFjdGl2ZSBpZiBpdCBpcyBtYW5hZ2VkXHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGFuaW1hdGlvbi5pc0FjdGl2ZSA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJlZ2lzdGVyTGF5ZXIobmFtZSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBzdXBlci5yZWdpc3RlckxheWVyKG5hbWUsIHtcclxuICAgICAgLi4ub3B0aW9ucyxcclxuICAgICAgaG9sZFRpbWVyOiBEZWZlcnJlZC5yZXNvbHZlKCksXHJcbiAgICAgIHBsYXlUaW1lcjogbnVsbCxcclxuICAgICAgY3VycmVudEdlc3R1cmU6IG51bGwsXHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAodGhpcy5fbWFuYWdlZExheWVyc1tuYW1lXS5pc0FjdGl2ZSkge1xyXG4gICAgICB0aGlzLl9ob3N0LkFuaW1hdGlvbkZlYXR1cmUuZ2V0QW5pbWF0aW9ucyhuYW1lKS5mb3JFYWNoKGFuaW0gPT4ge1xyXG4gICAgICAgIC8vIEF1dG9tYXRpY2FsbHkgcmVnaXN0ZXIgYWxsIGFuaW1hdGlvbnMgb24gdGhlIGxheWVyXHJcbiAgICAgICAgaWYgKHRoaXMuX21hbmFnZWRMYXllcnNbbmFtZV0uYW5pbWF0aW9uc1thbmltXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICB0aGlzLnJlZ2lzdGVyQW5pbWF0aW9uKFxyXG4gICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICBhbmltLFxyXG4gICAgICAgICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzW25hbWVdLmFuaW1hdGlvbnNbYW5pbV1cclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJlZ2lzdGVyQW5pbWF0aW9uKGxheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICAvLyBUcnkgdG8gZmFsbCBiYWNrIHRvIGEgZGVmYXVsdCB3b3JkIGFycmF5XHJcbiAgICBpZiAoIShvcHRpb25zLndvcmRzIGluc3RhbmNlb2YgQXJyYXkpICYmICEob3B0aW9ucy53b3JkcyBpbnN0YW5jZW9mIFNldCkpIHtcclxuICAgICAgb3B0aW9ucy53b3JkcyA9IERlZmF1bHRHZXN0dXJlV29yZHNbYW5pbWF0aW9uTmFtZV0gfHwgW107XHJcbiAgICB9XHJcblxyXG4gICAgc3VwZXIucmVnaXN0ZXJBbmltYXRpb24obGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lLCBvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhbiBvYmplY3QgdGhhdCBtYXBzIHNzbWwgbWFyayBzeW50YXggcmVxdWlyZWQgdG8gcGxheSBlYWNoIGdlc3R1cmUgdG9cclxuICAgKiB0aGUgd29yZHMgYXJyYXkgYXNzb2NpYXRlZCB3aXRoIGVhY2ggZ2VzdHVyZS4gV29yZHMgYXJyYXlzIGFyZSBkZWZpbmVkIGF0IHdoZW5cclxuICAgKiB0aGUgZ2VzdHVyZSBhbmltYXRpb24gaXMgcmVnaXN0ZXJlZC4gR2VzdHVyZXMgd2l0aG91dCBhc3NvY2lhdGVkIHdvcmRzIHdpbGxcclxuICAgKiBiZSBleGNsdWRlZCBmcm9tIHRoZSByZXN1bHQuIFRoZSByZXN1bHRpbmcgb2JqZWN0IGNhbiBiZSB1c2VkIGFzIGFuIGlucHV0XHJcbiAgICogZm9yIHtAbGluayBUZXh0VG9TcGVlY2hVdGlscy5hdXRvR2VuZXJhdGVTU01MTWFya3N9IHRvIHVwZGF0ZSBhIHNwZWVjaCBzdHJpbmdcclxuICAgKiB3aXRoIHRoZSBtYXJrdXAgcmVxdWlyZWQgdG8gcGxheSBnZXN0dXJlcyB0aW1lZCB3aXRoIHRoZWlyIGFzc29jaWF0ZWQgd29yZHMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gICAqL1xyXG4gIGNyZWF0ZUdlc3R1cmVNYXAoKSB7XHJcbiAgICBjb25zdCBnZXN0dXJlTWFwID0ge307XHJcblxyXG4gICAgT2JqZWN0LmVudHJpZXModGhpcy5fbWFuYWdlZExheWVycykuZm9yRWFjaCgoW2xheWVyTmFtZSwge2FuaW1hdGlvbnN9XSkgPT4ge1xyXG4gICAgICBPYmplY3QuZW50cmllcyhhbmltYXRpb25zKS5mb3JFYWNoKFxyXG4gICAgICAgIChbXHJcbiAgICAgICAgICBhbmltYXRpb25OYW1lLFxyXG4gICAgICAgICAge2hvbGRUaW1lLCBtaW5pbXVtSW50ZXJ2YWwsIHdvcmRzLCB0cmFuc2l0aW9uVGltZX0sXHJcbiAgICAgICAgXSkgPT4ge1xyXG4gICAgICAgICAgLy8gT25seSBzdG9yZSBnZXN0dXJlcyB0aGF0IGhhdmUgYW55IGFzc29jaWF0ZWQgd29yZHNcclxuICAgICAgICAgIGlmICh3b3Jkcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAuLi4oaG9sZFRpbWUgJiYgeyBob2xkVGltZSB9KSxcclxuICAgICAgICAgICAgICAuLi4obWluaW11bUludGVydmFsICYmIHsgbWluaW11bUludGVydmFsIH0pLFxyXG4gICAgICAgICAgICAgIC4uLih0cmFuc2l0aW9uVGltZSAmJiB7IHRyYW5zaXRpb25UaW1lIH0pLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSB7XHJcbiAgICAgICAgICAgICAgZmVhdHVyZTogdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLFxyXG4gICAgICAgICAgICAgIG1ldGhvZDogJ3BsYXlHZXN0dXJlJyxcclxuICAgICAgICAgICAgICBhcmdzOiBbbGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lLCBvcHRpb25zXSxcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGdlc3R1cmVNYXBbSlNPTi5zdHJpbmdpZnkoa2V5KV0gPSB3b3JkcztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gZ2VzdHVyZU1hcDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHNzbWwgbWFyayBzeW50YXggcmVxdWlyZWQgdG8gcGxheSBlYWNoIGdlc3R1cmVcclxuICAgKiB0aGF0IGRvZXMgbm90IGhhdmUgYW55IGFzc29jaWF0ZWQgd29yZHMuIFRoZSByZXN1bHRpbmcgYXJyYXkgY2FuIGJlIHVzZWQgYXNcclxuICAgKiBhbiBpbnB1dCBmb3Ige0BsaW5rIFRleHRUb1NwZWVjaFV0aWxzLmF1dG9HZW5lcmF0ZVNTTUxNYXJrc30gb3JcclxuICAgKiB7QGxpbmsgVGV4dFRvU3BlZWNoVXRpbHMuYWRkTWFya3NUb1VubWFya2VkU2VudGVuY2VzfSB0byB1cGRhdGUgYSBzcGVlY2hcclxuICAgKiBzdHJpbmcgd2l0aCB0aGUgbWFya3VwIHJlcXVpcmVkIHRvIHBsYXkgcmFuZG9tIGdlc3R1cmVzIGF0IGVhY2ggdW5tYXJrZWRcclxuICAgKiBzZW50ZW5jZSBpbiB0aGUgc3RyaW5nLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPj19IGxheWVycyAtIEFuIGFycmF5IG9mIG5hbWVzIG9mIG1hbmFnZWQgbGF5ZXJzIHRvIGdlbmVyYXRlXHJcbiAgICogbWFya3MgZm9yLiBJZiB1bmRlZmluZWQsIHVzZSBhbGwgbWFuYWdlZCBsYXllcnMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZz59XHJcbiAgICovXHJcbiAgY3JlYXRlR2VuZXJpY0dlc3R1cmVBcnJheShsYXllcnMpIHtcclxuICAgIGNvbnN0IGdlbmVyaWNHZXN0dXJlcyA9IFtdO1xyXG4gICAgbGF5ZXJzID0gbGF5ZXJzIHx8IE9iamVjdC5rZXlzKHRoaXMuX21hbmFnZWRMYXllcnMpO1xyXG5cclxuICAgIGxheWVycy5mb3JFYWNoKGxheWVyTmFtZSA9PiB7XHJcbiAgICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdO1xyXG5cclxuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBsYXllciBpcyBtYW5hZ2VkXHJcbiAgICAgIGlmICghbGF5ZXIpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIE9iamVjdC5lbnRyaWVzKGxheWVyLmFuaW1hdGlvbnMpLmZvckVhY2goXHJcbiAgICAgICAgKFtcclxuICAgICAgICAgIGFuaW1hdGlvbk5hbWUsXHJcbiAgICAgICAgICB7IGhvbGRUaW1lLCBtaW5pbXVtSW50ZXJ2YWwsIHdvcmRzLCB0cmFuc2l0aW9uVGltZSB9LFxyXG4gICAgICAgIF0pID0+IHtcclxuICAgICAgICAgIC8vIE9ubHkgc3RvcmUgZ2VzdHVyZXMgdGhhdCBkb24ndCBoYXZlIGFueSBhc3NvY2lhdGVkIHdvcmRzXHJcbiAgICAgICAgICBpZiAoIXdvcmRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgIC4uLihob2xkVGltZSAmJiB7IGhvbGRUaW1lIH0pLFxyXG4gICAgICAgICAgICAgIC4uLihtaW5pbXVtSW50ZXJ2YWwgJiYgeyBtaW5pbXVtSW50ZXJ2YWwgfSksXHJcbiAgICAgICAgICAgICAgLi4uKHRyYW5zaXRpb25UaW1lICYmIHsgdHJhbnNpdGlvblRpbWUgfSksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgICAgICBmZWF0dXJlOiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUsXHJcbiAgICAgICAgICAgICAgbWV0aG9kOiAncGxheUdlc3R1cmUnLFxyXG4gICAgICAgICAgICAgIGFyZ3M6IFtsYXllck5hbWUsIGFuaW1hdGlvbk5hbWUsIG9wdGlvbnNdLFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGlmICghZ2VuZXJpY0dlc3R1cmVzLmluY2x1ZGVzKGtleSkpIHtcclxuICAgICAgICAgICAgICBnZW5lcmljR2VzdHVyZXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGdlbmVyaWNHZXN0dXJlcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBsYXkgYSBtYW5hZ2VkIGdlc3R1cmUgYW5pbWF0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBsYXllciB0aGF0IGNvbnRhaW5zIHRoZSBnZXN0dXJlXHJcbiAgICogYW5pbWF0aW9uLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbmltYXRpb25OYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGdlc3R1cmUgYW5pbWF0aW9uLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyAtIE9wdGlvbmFsIGdlc3R1cmUgb3B0aW9ucy5cclxuICAgKiBAcGFyYW0ge251bWJlcj19IG9wdGlvbnMuaG9sZFRpbWUgLSBUaGlzIG9wdGlvbiBvbmx5IGFwcGxpZXMgdG8ge0BsaW5rIFF1ZXVlU3RhdGV9XHJcbiAgICogZ2VzdHVyZXMuIFdoZW4gYSBRdWV1ZVN0YXRlIGdlc3R1cmUgcHJvZ3Jlc3NlcyB0byBhIGxvb3Bpbmcgc3RhdGUsIHRoaXMgb3B0aW9uXHJcbiAgICogZGVmaW5lcyBob3cgbWFueSBzZWNvbmRzIHNob3VsZCBlbGFwc2UgYmVmb3JlIG1vdmluZyB0aGUgcXVldWUgZm9yd2FyZC4gSWZcclxuICAgKiB1bmRlZmluZWQsIGl0IHdpbGwgZmFsbCBiYWNrIGZpcnN0IHRvIHRoZSBob2xkVGltZSBkZWZpbmVkIGluIHRoZSBvcHRpb25zIHdoZW5cclxuICAgKiB0aGUgZ2VzdHVyZSBhbmltYXRpb24gd2FzIHJlZ2lzdGVyZWQgYW5kIHRoZW4gdG8gdGhlIGhvbGRUaW1lIGRlZmluZWQgb24gdGhlXHJcbiAgICogZmVhdHVyZS5cclxuICAgKiBAcGFyYW0ge251bWJlcj19IG9wdGlvbnMubWluaW11bUludGVydmFsIC0gVGhlIG1pbmltdW0gYW1vdW50IG9mIHRpbWUgdGhhdFxyXG4gICAqIG11c3QgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgYSBnZXN0dXJlIHdhcyBwbGF5ZWQuXHJcbiAgICovXHJcbiAgcGxheUdlc3R1cmUoXHJcbiAgICBsYXllck5hbWUsXHJcbiAgICBhbmltYXRpb25OYW1lLFxyXG4gICAge2hvbGRUaW1lLCBtaW5pbXVtSW50ZXJ2YWwsIHRyYW5zaXRpb25UaW1lLCBmb3JjZSA9IGZhbHNlfSA9IHt9XHJcbiAgKSB7XHJcbiAgICAvLyBNYWtlIHN1cmUgdGhlIGFuaW1hdGlvbiBpcyByZWdpc3RlcmVkXHJcbiAgICBpZiAoXHJcbiAgICAgIHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXSA9PT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgIHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXS5hbmltYXRpb25zW2FuaW1hdGlvbk5hbWVdID09PSB1bmRlZmluZWRcclxuICAgICkge1xyXG4gICAgICB0aGlzLnJlZ2lzdGVyQW5pbWF0aW9uKGxheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSwge1xyXG4gICAgICAgIGhvbGRUaW1lLFxyXG4gICAgICAgIG1pbmltdW1JbnRlcnZhbCxcclxuICAgICAgICB0cmFuc2l0aW9uVGltZSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV07XHJcbiAgICBjb25zdCBhbmltYXRpb24gPSBsYXllci5hbmltYXRpb25zW2FuaW1hdGlvbk5hbWVdO1xyXG5cclxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgYW5pbWF0aW9uIGlzIGFjdGl2ZVxyXG4gICAgaWYgKCFhbmltYXRpb24uaXNBY3RpdmUpIHtcclxuICAgICAgLy8gQ3JlYXRlIHdhcm5pbmcgbWVzc2FnZSBiYXNlZCBvbiB3aGljaCBvYmplY3QgZG9lc24ndCBleGlzdCB5ZXRcclxuICAgICAgY29uc3QgdHlwZU5hbWUgPSBsYXllci5pc0FjdGl2ZSA/ICdhbmltYXRpb24nIDogJ2xheWVyJztcclxuICAgICAgY29uc3QgbWVzc2FnZSA9IGBTa2lwcGluZyBnZXN0dXJlICR7YW5pbWF0aW9uTmFtZX0gb24gbGF5ZXIgJHtsYXllck5hbWV9IGZvciBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5vICR7dHlwZU5hbWV9IGV4aXN0cyB3aXRoIHRoaXMgbmFtZSB5ZXQuYDtcclxuXHJcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcclxuICAgICAgcmV0dXJuIERlZmVycmVkLmNhbmNlbCh7cmVhc29uOiAnaW5hY3RpdmUnLCB2YWx1ZTogdHlwZU5hbWV9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVjayBpZiB0aGUgZ2VzdHVyZSBpcyBhbHJlYWR5IHBsYXlpbmdcclxuICAgIGNvbnN0IHtjdXJyZW50R2VzdHVyZX0gPSBsYXllcjtcclxuICAgIGlmIChjdXJyZW50R2VzdHVyZSA9PT0gYW5pbWF0aW9uTmFtZSAmJiAhZm9yY2UpIHtcclxuICAgICAgY29uc3QgbWVzc2FnZSA9IGBTa2lwcGluZyBnZXN0dXJlICR7YW5pbWF0aW9uTmFtZX0gb24gbGF5ZXIgJHtsYXllck5hbWV9IGZvciBob3N0ICR7dGhpcy5faG9zdC5pZH0uIFRoZSBnZXN0dXJlIGlzIGFscmVhZHkgcGxheWluZy4gVXNlIG9wdGlvbnMuZm9yY2UgdG8gZm9yY2UgdGhlIGdlc3R1cmUgcmVwbGF5LCB3aGljaCBtYXkgcmVzdWx0IGluIGEgaGFyZCB0cmFuc2l0aW9uLmA7XHJcblxyXG4gICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XHJcbiAgICAgIHJldHVybiBEZWZlcnJlZC5jYW5jZWwoe3JlYXNvbjogJ3BsYXlpbmcnLCB2YWx1ZTogYW5pbWF0aW9uTmFtZX0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFVwZGF0ZSBhbmltYXRpb24gb3B0aW9uc1xyXG4gICAgaWYgKGhvbGRUaW1lICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgYW5pbWF0aW9uLmhvbGRUaW1lID0gaG9sZFRpbWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG1pbmltdW1JbnRlcnZhbCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGFuaW1hdGlvbi5taW5pbXVtSW50ZXJ2YWwgPSBtaW5pbXVtSW50ZXJ2YWw7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBtaW5pbXVtSW50ZXJ2YWwgPSB0aGlzLl9nZXRNaW5pbXVtSW50ZXJ2YWwobGF5ZXIsIGFuaW1hdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgdGhlIGludGVydmFsXHJcbiAgICBpZiAoIWZvcmNlICYmIGxheWVyLnBsYXlUaW1lciAhPT0gbnVsbCAmJiBsYXllci5wbGF5VGltZXIgPCBtaW5pbXVtSW50ZXJ2YWwpIHtcclxuICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgIGBTa2lwcGluZyBnZXN0dXJlICR7YW5pbWF0aW9uTmFtZX0gb24gbGF5ZXIgJHtsYXllck5hbWV9IGZvciBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE1pbmltdW0gaW50ZXJ2YWwgJHttaW5pbXVtSW50ZXJ2YWx9IGhhcyBub3QgYmVlbiBtZXQuYFxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gRGVmZXJyZWQuY2FuY2VsKHtcclxuICAgICAgICByZWFzb246ICdtaW5pbXVtSW50ZXJ2YWwnLFxyXG4gICAgICAgIHZhbHVlOiBtaW5pbXVtSW50ZXJ2YWwgLSBsYXllci5wbGF5VGltZXIsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFBsYXkgdGhlIGFuaW1hdGlvblxyXG4gICAgbGF5ZXIuY3VycmVudEdlc3R1cmUgPSBhbmltYXRpb25OYW1lO1xyXG4gICAgbGF5ZXIucGxheVRpbWVyID0gMDtcclxuICAgIGxheWVyLmhvbGRUaW1lci5jYW5jZWwoKTtcclxuICAgIGlmIChsYXllci5hdXRvRGlzYWJsZSkge1xyXG4gICAgICB0aGlzLnNldExheWVyV2VpZ2h0cyhuYW1lID0+IG5hbWUgPT09IGxheWVyTmFtZSwgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5wbGF5QW5pbWF0aW9uKFxyXG4gICAgICBsYXllck5hbWUsXHJcbiAgICAgIGFuaW1hdGlvbk5hbWUsXHJcbiAgICAgIHRyYW5zaXRpb25UaW1lXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlKGRlbHRhVGltZSkge1xyXG4gICAgc3VwZXIudXBkYXRlKGRlbHRhVGltZSk7XHJcblxyXG4gICAgLy8gSW5jcmVtZW50IHRoZSB0aW1lcnNcclxuICAgIE9iamVjdC5lbnRyaWVzKHRoaXMuX21hbmFnZWRMYXllcnMpLmZvckVhY2goKFtuYW1lLCBvcHRpb25zXSkgPT4ge1xyXG4gICAgICBpZiAob3B0aW9ucy5pc0FjdGl2ZSAmJiAhdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlLmdldFBhdXNlZChuYW1lKSkge1xyXG4gICAgICAgIG9wdGlvbnMuaG9sZFRpbWVyLmV4ZWN1dGUoZGVsdGFUaW1lKTtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMucGxheVRpbWVyICE9PSBudWxsKSB7XHJcbiAgICAgICAgICBvcHRpb25zLnBsYXlUaW1lciArPSBkZWx0YVRpbWUgLyAxMDAwO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBpbnN0YWxsQXBpKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqIEBuYW1lc3BhY2UgR2VzdHVyZUZlYXR1cmVcclxuICAgICAqL1xyXG4gICAgY29uc3QgYXBpID0gc3VwZXIuaW5zdGFsbEFwaSgpO1xyXG5cclxuICAgIE9iamVjdC5hc3NpZ24oYXBpLCB7XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbWVtYmVyb2YgR2VzdHVyZUZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBtZXRob2RcclxuICAgICAgICogQHNlZSBHZXN0dXJlRmVhdHVyZSNjcmVhdGVHZXN0dXJlTWFwXHJcbiAgICAgICAqL1xyXG4gICAgICBjcmVhdGVHZXN0dXJlTWFwOiB0aGlzLmNyZWF0ZUdlc3R1cmVNYXAuYmluZCh0aGlzKSxcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBtZW1iZXJvZiBHZXN0dXJlRmVhdHVyZVxyXG4gICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgKiBAc2VlIEdlc3R1cmVGZWF0dXJlI2NyZWF0ZUdlbmVyaWNHZXN0dXJlQXJyYXlcclxuICAgICAgICovXHJcbiAgICAgIGNyZWF0ZUdlbmVyaWNHZXN0dXJlQXJyYXk6IHRoaXMuY3JlYXRlR2VuZXJpY0dlc3R1cmVBcnJheS5iaW5kKHRoaXMpLFxyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIEdlc3R1cmVGZWF0dXJlXHJcbiAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAqIEBzZWUgR2VzdHVyZUZlYXR1cmUjcGxheUdlc3R1cmVcclxuICAgICAgICovXHJcbiAgICAgIHBsYXlHZXN0dXJlOiB0aGlzLnBsYXlHZXN0dXJlLmJpbmQodGhpcyksXHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEdlc3R1cmVGZWF0dXJlLCB7XHJcbiAgREVGQVVMVF9MQVlFUl9PUFRJT05TOiB7XHJcbiAgICB2YWx1ZToge1xyXG4gICAgICAuLi5HZXN0dXJlRmVhdHVyZS5ERUZBVUxUX0xBWUVSX09QVElPTlMsXHJcbiAgICAgIGF1dG9EaXNhYmxlOiB0cnVlLFxyXG4gICAgfSxcclxuICAgIHdyaXRhYmxlOiBmYWxzZSxcclxuICB9LFxyXG4gIEVWRU5UX0RFUEVOREVOQ0lFUzoge1xyXG4gICAgdmFsdWU6IHtcclxuICAgICAgLi4uR2VzdHVyZUZlYXR1cmUuRVZFTlRfREVQRU5ERU5DSUVTLFxyXG4gICAgICBBbmltYXRpb25GZWF0dXJlOiB7XHJcbiAgICAgICAgLi4uR2VzdHVyZUZlYXR1cmUuRVZFTlRfREVQRU5ERU5DSUVTLkFuaW1hdGlvbkZlYXR1cmUsXHJcbiAgICAgICAgcGxheU5leHRBbmltYXRpb246ICdfb25OZXh0JyxcclxuICAgICAgICBzdG9wQW5pbWF0aW9uOiAnX29uU3RvcCcsXHJcbiAgICAgICAgaW50ZXJydXB0QW5pbWF0aW9uOiAnX29uU3RvcCdcclxuICAgICAgfSxcclxuICAgIH0sXHJcbiAgfSxcclxufSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBHZXN0dXJlRmVhdHVyZTtcclxuZXhwb3J0IHtEZWZhdWx0R2VzdHVyZVdvcmRzfTtcclxuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxyXG5pbXBvcnQgRGVmZXJyZWQgZnJvbSAnY29yZS9EZWZlcnJlZCc7XHJcbmltcG9ydCBVdGlscyBmcm9tICdjb3JlL1V0aWxzJztcclxuaW1wb3J0IE1hdGhVdGlscyBmcm9tICdjb3JlL01hdGhVdGlscyc7XHJcbmltcG9ydCB7TGluZWFyfSBmcm9tICcuL0Vhc2luZyc7XHJcblxyXG4vKipcclxuICogQSBjb2xsZWN0aW9uIG9mIHVzZWZ1bCBhbmltYXRpb24gZnVuY3Rpb25zLlxyXG4gKlxyXG4gKiBAaGlkZWNvbnN0cnVjdG9yXHJcbiAqL1xyXG5jbGFzcyBBbmltYXRpb25VdGlscyB7XHJcbiAgc3RhdGljIGxlcnAoZnJvbSwgdG8sIGZhY3Rvcikge1xyXG4gICAgY29uc29sZS53YXJuKGBBbmltYXRpb25VdGlscy5sZXJwIGlzIGJlaW5nIGRlcHJlY2F0ZWQuIFVzZSBNYXRoVXRpbHMubGVycCBpbnN0ZWFkLmApO1xyXG5cclxuICAgIHJldHVybiBNYXRoVXRpbHMubGVycChmcm9tLCB0bywgZmFjdG9yKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENsYW1wIGEgbnVtYmVyIGJldHdlZW4gMiB2YWx1ZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBWYWx1ZSB0byBjbGFtcC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW21pbj0wXSAtIE1pbnVtdW0gdmFsdWUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttYXg9MV0gLSBNYXhpbXVtIHZhbHVlLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBzdGF0aWMgY2xhbXAodmFsdWUsIG1pbiA9IDAsIG1heCA9IDEpIHtcclxuICAgIGNvbnNvbGUud2FybihgQW5pbWF0aW9uVXRpbHMuY2xhbXAgaXMgYmVpbmcgZGVwcmVjYXRlZC4gVXNlIE1hdGhVdGlscy5jbGFtcCBpbnN0ZWFkLmApO1xyXG5cclxuICAgIHJldHVybiBNYXRoVXRpbHMuY2xhbXAodmFsdWUsIG1pbiwgbWF4KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiBhIGRlZmVycmVkIHByb21pc2UgdGhhdCBjYW4gYmUgdXNlZCB0byB1cGRhdGUgdGhlIHZhbHVlIG9mIGEgbnVtZXJpY1xyXG4gICAqIHByb3BlcnR5IG9mIHRoaXMgb2JqZWN0IG92ZXIgdGltZS4gUGFzcyBkZWx0YSB0aW1lIGluIG1pbGxpc2Vjb25kcyB0byB0aGVcclxuICAgKiBkZWZlcnJlZCBwcm9taXNlJ3MgZXhlY3V0ZSBtZXRob2QgaW4gYW4gdXBkYXRlIGxvb3AgdG8gYW5pbWF0ZSB0aGUgcHJvcGVydHlcclxuICAgKiB0b3dhcmRzIHRoZSB0YXJnZXQgdmFsdWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydHlPd25lciAtIE9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBwcm9wZXJ0eSB0byBhbmltYXRpb24uXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5TmFtZSAtIE5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGFuaW1hdGUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldFZhbHVlIC0gVGFyZ2V0IHZhbHVlIHRvIHJlYWNoLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyAtIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnNlY29uZHM9MF0gLSBOdW1iZXIgb2Ygc2Vjb25kcyBpdCB3aWxsIHRha2UgdG8gcmVhY2hcclxuICAgKiB0aGUgdGFyZ2V0IHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmVhc2luZ0ZuPUxpbmVhci5Jbk91dF0gLSBFYXNpbmcgZnVuY3Rpb24gdG8gdXNlIGZvciBhbmltYXRpb24uXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMub25GaW5pc2hdIC0gQ2FsbGJhY2sgdG8gZXhlY3V0ZSBvbmNlIHRoZSBhbmltYXRpb24gY29tcGxldGVzLlxyXG4gICAqIFRoZSB0YXJnZXQgdmFsdWUgaXMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvcHRpb25zLm9uUHJvZ3Jlc3MgLSBDYWxsYmFjayB0byBleGVjdXRlIGVhY2ggdGltZSB0aGUgYW5pbWF0aW9uXHJcbiAgICogcHJvcGVydHkgaXMgdXBkYXRlZCBkdXJpbmcgdGhlIGFuaW1hdGlvbi4gVGhlIHByb3BlcnR5J3MgdmFsdWUgYXQgdGhlIHRpbWUgb2ZcclxuICAgKiB0aGUgdXBkYXRlIGlzIHBhc3NlZCBhcyBhIHBhcmFtZXRlci5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb3B0aW9ucy5vbkNhbmNlbCAtIENhbGxiYWNrIHRvIGV4ZWN1dGUgaWYgdGhlIHVzZXIgY2FuY2VscyB0aGVcclxuICAgKiBhbmltYXRpb24gYmVmb3JlIGNvbXBsZXRpb24uIFRoZSBhbmltYXRpb24gcHJvcGVydHkncyB2YWx1ZSBhdCB0aGUgdGltZSBvZlxyXG4gICAqIGNhbmNlbCBpcyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9wdGlvbnMub25FcnJvciAtIENhbGxiYWNrIHRvIGV4ZWN1dGUgaWYgdGhlIGFuaW1hdGlvbiBzdG9wc1xyXG4gICAqIGJlY2F1c2UgYW4gZXJyb3IgaXMgZW5jb3VudGVyZWQuIFRoZSBlcnJvciBtZXNzYWdlIGlzIHBhc3NlZCBhcyBhIHBhcmFtZXRlci5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH0gUmVzb2x2ZXMgd2l0aCB0aGUgcHJvcGVydHkncyB2YWx1ZSBvbmNlIGl0IHJlYWNoZXMgdGhlXHJcbiAgICogdGFyZ2V0IHZhbHVlLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBpbnRlcnBvbGF0ZVByb3BlcnR5KFxyXG4gICAgcHJvcGVydHlPd25lcixcclxuICAgIHByb3BlcnR5TmFtZSxcclxuICAgIHRhcmdldFZhbHVlLFxyXG4gICAge3NlY29uZHMgPSAwLCBlYXNpbmdGbiwgb25GaW5pc2gsIG9uUHJvZ3Jlc3MsIG9uQ2FuY2VsLCBvbkVycm9yfSA9IHt9XHJcbiAgKSB7XHJcbiAgICAvLyBNYWtlIHN1cmUgcHJvcGVydHkgaXMgYW4gb2JqZWN0XHJcbiAgICBpZiAoIShwcm9wZXJ0eU93bmVyIGluc3RhbmNlb2YgT2JqZWN0KSkge1xyXG4gICAgICBjb25zdCBlID0gbmV3IEVycm9yKFxyXG4gICAgICAgIGBDYW5ub3QgaW50ZXJwb2xhdGUgcHJvcGVydHkgJHtwcm9wZXJ0eU5hbWV9LiBQcm9wZXJ0eSBvd25lciBtdXN0IGJlIGFuIG9iamVjdC5gXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBpZiAodHlwZW9mIG9uRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBvbkVycm9yKGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gRGVmZXJyZWQucmVqZWN0KGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE1ha2Ugc3VyZSBwcm9wZXJ0eSBpcyBudW1lcmljXHJcbiAgICBpZiAoTnVtYmVyLmlzTmFOKE51bWJlcihwcm9wZXJ0eU93bmVyW3Byb3BlcnR5TmFtZV0pKSkge1xyXG4gICAgICBjb25zdCBlID0gbmV3IEVycm9yKFxyXG4gICAgICAgIGBDYW5ub3QgaW50ZXJwb2xhdGUgcHJvcGVydHkgJHtwcm9wZXJ0eU5hbWV9LiBQcm9wZXJ0eSBtdXN0IGJlIG51bWVyaWMuYFxyXG4gICAgICApO1xyXG5cclxuICAgICAgaWYgKHR5cGVvZiBvbkVycm9yID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgb25FcnJvcihlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIERlZmVycmVkLnJlamVjdChlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBNYWtlIHN1cmUgdGhlIHRhcmdldCB2YWx1ZSBpcyBudW1lcmljXHJcbiAgICBpZiAoTnVtYmVyLmlzTmFOKE51bWJlcih0YXJnZXRWYWx1ZSkpKSB7XHJcbiAgICAgIGNvbnN0IGUgPSBuZXcgRXJyb3IoXHJcbiAgICAgICAgYENhbm5vdCBpbnRlcnBvbGF0ZSBwcm9wZXJ0eSAke3Byb3BlcnR5TmFtZX0gdG8gdmFsdWUgJHt0YXJnZXRWYWx1ZX0uIFRhcmdldCB2YWx1ZSBtdXN0IGJlIG51bWVyaWMuYFxyXG4gICAgICApO1xyXG5cclxuICAgICAgaWYgKHR5cGVvZiBvbkVycm9yID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgb25FcnJvcihlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIERlZmVycmVkLnJlamVjdChlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXNvbHZlIGltbWVkaWF0ZWx5IGlmIHRoZSB0YXJnZXQgaGFzIGFscmVhZHkgYmVlbiByZWFjaGVkXHJcbiAgICBjb25zdCBzdGFydFZhbHVlID0gcHJvcGVydHlPd25lcltwcm9wZXJ0eU5hbWVdO1xyXG5cclxuICAgIGlmIChzdGFydFZhbHVlID09PSB0YXJnZXRWYWx1ZSkge1xyXG4gICAgICBpZiAodHlwZW9mIG9uRmluaXNoID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgb25GaW5pc2godGFyZ2V0VmFsdWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gRGVmZXJyZWQucmVzb2x2ZSh0YXJnZXRWYWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGVmYXVsdCB0byBsaW5lYXIgaW50ZXJwb2xhdGlvblxyXG4gICAgaWYgKHR5cGVvZiBlYXNpbmdGbiAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBpZiAoZWFzaW5nRm4gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICAgIGBJbnZhbGlkIHByb3BlcnR5IGludGVycG9sYXRpb24gZWFzaW5nRm4uIERlZmF1bHRpbmcgdG8gbGluZWFyIGludGVycG9sYXRpb24uYFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGVhc2luZ0ZuID0gTGluZWFyLkluT3V0O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGludGVycG9sYXRvciA9IFV0aWxzLndhaXQoc2Vjb25kcywge1xyXG4gICAgICBvbkZpbmlzaDogKCkgPT4ge1xyXG4gICAgICAgIHByb3BlcnR5T3duZXJbcHJvcGVydHlOYW1lXSA9IHRhcmdldFZhbHVlO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9uRmluaXNoID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICBvbkZpbmlzaCh0YXJnZXRWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBvbkNhbmNlbDogKCkgPT4ge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb25DYW5jZWwgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgIG9uQ2FuY2VsKHByb3BlcnR5T3duZXJbcHJvcGVydHlOYW1lXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBvblByb2dyZXNzOiBwcm9ncmVzcyA9PiB7XHJcbiAgICAgICAgaWYgKHByb3BlcnR5T3duZXJbcHJvcGVydHlOYW1lXSAhPT0gdGFyZ2V0VmFsdWUpIHtcclxuICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbGVycCBmYWN0b3JcclxuICAgICAgICAgIGNvbnN0IGVhc2VGYWN0b3IgPSBlYXNpbmdGbihwcm9ncmVzcyk7XHJcblxyXG4gICAgICAgICAgaWYgKHR5cGVvZiBlYXNlRmFjdG9yICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICBjb25zdCBlID0gbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAgIGBJbnZhbGlkIHByb3BlcnR5IGludGVycG9sYXRpb24gZWFzaW5nRm4uIEVhc2luZ0ZuIG11c3QgcmV0dXJuIGEgbnVtYmVyLmBcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgaW50ZXJwb2xhdG9yLnJlamVjdChlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgdmFsdWVcclxuICAgICAgICAgIHByb3BlcnR5T3duZXJbcHJvcGVydHlOYW1lXSA9IE1hdGhVdGlscy5sZXJwKFxyXG4gICAgICAgICAgICBzdGFydFZhbHVlLFxyXG4gICAgICAgICAgICB0YXJnZXRWYWx1ZSxcclxuICAgICAgICAgICAgZWFzZUZhY3RvclxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNpZ25hbCBwcm9ncmVzc1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb25Qcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgb25Qcm9ncmVzcyhwcm9wZXJ0eU93bmVyW3Byb3BlcnR5TmFtZV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2lnbmFsIGNvbXBsZXRpb24gb25jZSB0aW1lIGlzIHVwXHJcbiAgICAgICAgaWYgKHByb2dyZXNzID09PSAxKSB7XHJcbiAgICAgICAgICBwcm9wZXJ0eU93bmVyW3Byb3BlcnR5TmFtZV0gPSB0YXJnZXRWYWx1ZTtcclxuICAgICAgICAgIGludGVycG9sYXRvci5yZXNvbHZlKHRhcmdldFZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIG9uRXJyb3IsXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gaW50ZXJwb2xhdG9yO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQW5pbWF0aW9uVXRpbHM7XHJcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcclxuaW1wb3J0IERlZmVycmVkIGZyb20gJ2NvcmUvRGVmZXJyZWQnO1xyXG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gJ2NvcmUvTWF0aFV0aWxzJztcclxuaW1wb3J0IEFuaW1hdGlvblV0aWxzIGZyb20gJy4uL0FuaW1hdGlvblV0aWxzJztcclxuXHJcbi8qKlxyXG4gKiBCYXNlIGNsYXNzIGZvciBhIHN0YXRlIGluIG91ciBhbmltYXRpb24gc3lzdGVtLlxyXG4gKlxyXG4gKiBAYWJzdHJhY3RcclxuICovXHJcbmNsYXNzIEFic3RyYWN0U3RhdGUge1xyXG4gIC8qKlxyXG4gICAqIEBjb25zdHJ1Y3RvclxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGFuaW1hdGlvbiBzdGF0ZS5cclxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdGlvbnMubmFtZSAtIE5hbWUgZm9yIHRoZSBhbmltYXRpb24gc3RhdGUuIE5hbWVzIG11c3QgYmVcclxuICAgKiB1bmlxdWUgZm9yIHRoZSBjb250YWluZXIgdGhlIHN0YXRlIGlzIGFwcGxpZWQgdG8gYW5kIHNob3VsZCBiZSB2YWxpZGF0ZWQgYXRcclxuICAgKiB0aGUgY29udGFpbmVyIGxldmVsLiBJZiBubyBuYW1lIGlzIGdpdmVuIGl0IHdpbGwgZGVmYXVsdCB0byB0aGUgY29uc3RydWN0b3JcclxuICAgKiBuYW1lLlxyXG4gICAqIEBwYXJhbSB7d2VpZ2h0fSBbb3B0aW9ucy53ZWlnaHQ9MF0gLSBUaGUgMC0xIGFtb3VudCBvZiBpbmZsdWVuY2UgdGhlIHN0YXRlIHdpbGwgaGF2ZS5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcclxuICAgIHRoaXMubmFtZSA9XHJcbiAgICAgIG9wdGlvbnMubmFtZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uYW1lIDogdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgdGhpcy5fd2VpZ2h0ID1cclxuICAgICAgb3B0aW9ucy53ZWlnaHQgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgID8gTWF0aFV0aWxzLmNsYW1wKG9wdGlvbnMud2VpZ2h0LCAwLCAxKVxyXG4gICAgICAgIDogMDtcclxuICAgIHRoaXMuX2ludGVybmFsV2VpZ2h0ID0gdGhpcy5fd2VpZ2h0O1xyXG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5fcHJvbWlzZXMgPSB7XHJcbiAgICAgIGZpbmlzaDogRGVmZXJyZWQucmVzb2x2ZSgpLFxyXG4gICAgICB3ZWlnaHQ6IERlZmVycmVkLnJlc29sdmUoKSxcclxuICAgICAgcGxheTogRGVmZXJyZWQucmVzb2x2ZSgpLFxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLl9wbGF5Q2FsbGJhY2tzID0ge1xyXG4gICAgICBvbkZpbmlzaDogdW5kZWZpbmVkLFxyXG4gICAgICBvbkVycm9yOiB1bmRlZmluZWQsXHJcbiAgICAgIG9uQ2FuY2VsOiB1bmRlZmluZWQsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgc3RhdGUgaXMgY3VycmVudGx5IHBhdXNlZC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IHBhdXNlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9wYXVzZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIGFuZCBzZXRzIHRoZSB1c2VyIGRlZmluZWQgd2VpZ2h0LlxyXG4gICAqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgd2VpZ2h0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3dlaWdodDtcclxuICB9XHJcblxyXG4gIHNldCB3ZWlnaHQod2VpZ2h0KSB7XHJcbiAgICB0aGlzLl93ZWlnaHQgPSBNYXRoVXRpbHMuY2xhbXAod2VpZ2h0LCAwLCAxKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgd2hldGhlciBvciBub3QgdGhlIHdlaWdodCBpcyBjdXJyZW50bHkgYmVpbmcgYW5pbWF0ZWQuXHJcbiAgICpcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBnZXQgd2VpZ2h0UGVuZGluZygpIHtcclxuICAgIHJldHVybiB0aGlzLl9wcm9taXNlcy53ZWlnaHQgJiYgdGhpcy5fcHJvbWlzZXMud2VpZ2h0LnBlbmRpbmc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGVzIHRoZSB1c2VyIGRlZmluZWQgd2VpZ2h0IG92ZXIgdGltZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3ZWlnaHQgLSBUaGUgdGFyZ2V0IHdlaWdodCB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NlY29uZHM9MF0gLSBUaGUgYW1vdW50IG9mIHRpbWUgaXQgd2lsbCB0YWtlIHRvIHJlYWNoIHRoZVxyXG4gICAqIHRhcmdldCB3ZWlnaHQuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGVhc2luZ0ZuIC0gVGhlIGVhc2luZyBmdW5jdGlvbiB0byB1c2UgZm9yIGludGVycG9sYXRpb24uXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9XHJcbiAgICovXHJcbiAgc2V0V2VpZ2h0KHdlaWdodCwgc2Vjb25kcyA9IDAsIGVhc2luZ0ZuKSB7XHJcbiAgICB0aGlzLl9wcm9taXNlcy53ZWlnaHQuY2FuY2VsKCk7XHJcbiAgICB3ZWlnaHQgPSBNYXRoVXRpbHMuY2xhbXAod2VpZ2h0KTtcclxuXHJcbiAgICB0aGlzLl9wcm9taXNlcy53ZWlnaHQgPSBBbmltYXRpb25VdGlscy5pbnRlcnBvbGF0ZVByb3BlcnR5KFxyXG4gICAgICB0aGlzLFxyXG4gICAgICAnd2VpZ2h0JyxcclxuICAgICAgd2VpZ2h0LFxyXG4gICAgICB7c2Vjb25kcywgZWFzaW5nRm59XHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiB0aGlzLl9wcm9taXNlcy53ZWlnaHQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBpbnRlcm5hbCB3ZWlnaHQuXHJcbiAgICpcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBpbnRlcm5hbFdlaWdodCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbFdlaWdodDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE11bHRpcGxpZXMgdGhlIHVzZXIgd2VpZ2h0IGJ5IGEgZmFjdG9yIHRvIGRldGVybWluZSB0aGUgaW50ZXJuYWwgd2VpZ2h0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZhY3RvciAtIDAtMSBtdWx0aXBsaWVyIHRvIGFwcGx5IHRvIHRoZSB1c2VyIHdlaWdodC5cclxuICAgKi9cclxuICB1cGRhdGVJbnRlcm5hbFdlaWdodChmYWN0b3IpIHtcclxuICAgIHRoaXMuX2ludGVybmFsV2VpZ2h0ID0gdGhpcy5fd2VpZ2h0ICogZmFjdG9yO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIGFueSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIGV2YWx1YXRlZCBldmVyeSBmcmFtZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVRpbWUgLSBUaW1lIGluIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgbGFzdCB1cGRhdGUuXHJcbiAgICovXHJcbiAgdXBkYXRlKGRlbHRhVGltZSkge1xyXG4gICAgaWYgKCF0aGlzLl9wYXVzZWQpIHtcclxuICAgICAgT2JqZWN0LnZhbHVlcyh0aGlzLl9wcm9taXNlcykuZm9yRWFjaChwcm9taXNlID0+IHtcclxuICAgICAgICBwcm9taXNlLmV4ZWN1dGUoZGVsdGFUaW1lKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFydCBwbGF5YmFjayBvZiB0aGUgc3RhdGUgZnJvbSB0aGUgYmVnaW5uaW5nLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uRmluaXNoIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHRoZSBzdGF0ZSBmaW5pc2hlcy5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25FcnJvciAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgaWYgdGhlIHN0YXRlIGVuY291bnRlcnNcclxuICAgKiBhbiBlcnJvciBkdXJpbmcgcGxheWJhY2suXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uQ2FuY2VsIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBpZiBwbGF5YmFjayBpcyBjYW5jZWxlZC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH1cclxuICAgKi9cclxuICBwbGF5KG9uRmluaXNoLCBvbkVycm9yLCBvbkNhbmNlbCkge1xyXG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XHJcbiAgICB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uRmluaXNoID0gb25GaW5pc2g7XHJcbiAgICB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uRXJyb3IgPSBvbkVycm9yO1xyXG4gICAgdGhpcy5fcGxheUNhbGxiYWNrcy5vbkNhbmNlbCA9IG9uQ2FuY2VsO1xyXG5cclxuICAgIHRoaXMuX3Byb21pc2VzLnBsYXkgPSBuZXcgRGVmZXJyZWQodW5kZWZpbmVkLCBvbkZpbmlzaCwgb25FcnJvciwgb25DYW5jZWwpO1xyXG4gICAgdGhpcy5fcHJvbWlzZXMuZmluaXNoID0gRGVmZXJyZWQuYWxsKFtcclxuICAgICAgdGhpcy5fcHJvbWlzZXMucGxheSxcclxuICAgICAgdGhpcy5fcHJvbWlzZXMud2VpZ2h0LFxyXG4gICAgXSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VzLmZpbmlzaDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhdXNlIHBsYXliYWNrIG9mIHRoZSBzdGF0ZS4gVGhpcyBwcmV2ZW50cyBwZW5kaW5nIHByb21pc2VzIGZyb20gYmVpbmcgZXhlY3V0ZWQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBwYXVzZSgpIHtcclxuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc3VtZSBwbGF5YmFjayBvZiB0aGUgc3RhdGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25GaW5pc2ggLSBGdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIHN0YXRlIGZpbmlzaGVzLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkVycm9yIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBpZiB0aGUgc3RhdGUgZW5jb3VudGVyc1xyXG4gICAqIGFuIGVycm9yIGR1cmluZyBwbGF5YmFjay5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25DYW5jZWwgLSBGdW5jdGlvbiB0byBleGVjdXRlIGlmIHBsYXliYWNrIGlzIGNhbmNlbGVkLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0RlZmVycmVkfVxyXG4gICAqL1xyXG4gIHJlc3VtZShvbkZpbmlzaCwgb25FcnJvciwgb25DYW5jZWwpIHtcclxuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xyXG5cclxuICAgIGlmICghdGhpcy5fcHJvbWlzZXMucGxheS5wZW5kaW5nKSB7XHJcbiAgICAgIHRoaXMuX3BsYXlDYWxsYmFja3Mub25GaW5pc2ggPSBvbkZpbmlzaCB8fCB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uRmluaXNoO1xyXG4gICAgICB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uRXJyb3IgPSBvbkVycm9yIHx8IHRoaXMuX3BsYXlDYWxsYmFja3Mub25FcnJvcjtcclxuICAgICAgdGhpcy5fcGxheUNhbGxiYWNrcy5vbkNhbmNlbCA9IG9uQ2FuY2VsIHx8IHRoaXMuX3BsYXlDYWxsYmFja3Mub25DYW5jZWw7XHJcblxyXG4gICAgICB0aGlzLl9wcm9taXNlcy5wbGF5ID0gbmV3IERlZmVycmVkKFxyXG4gICAgICAgIHVuZGVmaW5lZCxcclxuICAgICAgICB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uRmluaXNoLFxyXG4gICAgICAgIHRoaXMuX3BsYXlDYWxsYmFja3Mub25FcnJvcixcclxuICAgICAgICB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uQ2FuY2VsXHJcbiAgICAgICk7XHJcbiAgICAgIHRoaXMuX3Byb21pc2VzLmZpbmlzaCA9IERlZmVycmVkLmFsbChbXHJcbiAgICAgICAgdGhpcy5fcHJvbWlzZXMucGxheSxcclxuICAgICAgICB0aGlzLl9wcm9taXNlcy53ZWlnaHQsXHJcbiAgICAgIF0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLl9wcm9taXNlcy5maW5pc2g7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYW5jZWwgcGxheWJhY2sgb2YgdGhlIHN0YXRlIGFuZCBjYW5jZWwgYW55IHBlbmRpbmcgcHJvbWlzZXMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBjYW5jZWwoKSB7XHJcbiAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xyXG5cclxuICAgIE9iamVjdC52YWx1ZXModGhpcy5fcHJvbWlzZXMpLmZvckVhY2gocHJvbWlzZSA9PiB7XHJcbiAgICAgIHByb21pc2UuY2FuY2VsKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0b3AgcGxheWJhY2sgb2YgdGhlIHN0YXRlIGFuZCByZXNvbHZlIGFueSBwZW5kaW5nIHByb21pc2VzLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgc3RvcCgpIHtcclxuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XHJcblxyXG4gICAgT2JqZWN0LnZhbHVlcyh0aGlzLl9wcm9taXNlcykuZm9yRWFjaChwcm9taXNlID0+IHtcclxuICAgICAgcHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbmNlbCBhbnkgcGVuZGluZyBwcm9taXNlcyBhbmQgcmVtb3ZlIHJlZmVyZW5jZSB0byB0aGVtLlxyXG4gICAqL1xyXG4gIGRpc2NhcmQoKSB7XHJcbiAgICB0aGlzLmNhbmNlbCgpO1xyXG5cclxuICAgIGRlbGV0ZSB0aGlzLl9wcm9taXNlcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZvcmNlIHRoZSBpbnRlcm5hbCB3ZWlnaHQgdG8gMC4gU2hvdWxkIGJlIGNhbGxlZCBiZWZvcmUgc3dpdGNoaW5nIG9yIHRyYW5zaXRpb25pbmdcclxuICAgKiB0byBhIG5ldyBzdGF0ZS5cclxuICAgKi9cclxuICBkZWFjdGl2YXRlKCkge1xyXG4gICAgdGhpcy51cGRhdGVJbnRlcm5hbFdlaWdodCgwKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEFic3RyYWN0U3RhdGU7XHJcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcclxuaW1wb3J0IERlZmVycmVkIGZyb20gJ2NvcmUvRGVmZXJyZWQnO1xyXG5pbXBvcnQgQWJzdHJhY3RTdGF0ZSBmcm9tICcuL0Fic3RyYWN0U3RhdGUnO1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIGZvciBzbW9vdGggdHJhbnNpdGlvbmluZyBiZXR3ZWVuIHN0YXRlcyBvbiBhbiBhbmltYXRpb24gbGF5ZXIuXHJcbiAqXHJcbiAqIEBleHRlbmRzIEFic3RyYWN0U3RhdGVcclxuICovXHJcbmNsYXNzIFRyYW5zaXRpb25TdGF0ZSBleHRlbmRzIEFic3RyYWN0U3RhdGUge1xyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIob3B0aW9ucyk7XHJcblxyXG4gICAgdGhpcy5fdG8gPSBudWxsO1xyXG4gICAgdGhpcy5fZnJvbSA9IFtdO1xyXG4gICAgdGhpcy5fd2VpZ2h0UHJvbWlzZSA9IERlZmVycmVkLnJlc29sdmUoKTtcclxuICB9XHJcblxyXG4gIGdldCBpbnRlcm5hbFdlaWdodCgpIHtcclxuICAgIC8vIEZpbmQgdGhlIGNvbWJpbmVkIHdlaWdodCBvZiBhbGwgc3ViLXN0YXRlc1xyXG4gICAgbGV0IHRvdGFsV2VpZ2h0ID0gMDtcclxuXHJcbiAgICBpZiAodGhpcy5fdG8pIHtcclxuICAgICAgdG90YWxXZWlnaHQgKz0gdGhpcy5fdG8ud2VpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2Zyb20uZm9yRWFjaChzdGF0ZSA9PiB7XHJcbiAgICAgIHRvdGFsV2VpZ2h0ICs9IHN0YXRlLndlaWdodDtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0b3RhbFdlaWdodCAqIHRoaXMuX2ludGVybmFsV2VpZ2h0O1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlSW50ZXJuYWxXZWlnaHQoZmFjdG9yKSB7XHJcbiAgICBzdXBlci51cGRhdGVJbnRlcm5hbFdlaWdodChmYWN0b3IpO1xyXG5cclxuICAgIHRoaXMuX2Zyb20uZm9yRWFjaChzdGF0ZSA9PiB7XHJcbiAgICAgIHN0YXRlLnVwZGF0ZUludGVybmFsV2VpZ2h0KHRoaXMuX2ludGVybmFsV2VpZ2h0KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICh0aGlzLl90bykge1xyXG4gICAgICB0aGlzLl90by51cGRhdGVJbnRlcm5hbFdlaWdodCh0aGlzLl9pbnRlcm5hbFdlaWdodCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgc3ViLXN0YXRlcyB0aGUgdHJhbnNpdGlvbiBpcyBjb250cm9sbGluZyBhbmQgc3RhcnQgbmV3IHdlaWdodFxyXG4gICAqIGFuaW1hdGlvbnMgb24gZWFjaCBvbmUuIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBlYWNoIHRpbWUgdGhlIGN1cnJlbnQgc3RhdGUgb2ZcclxuICAgKiBhbiBhbmltYXRpb24gbGF5ZXIgZ2V0cyB1cGRhdGVkIHRvIGEgbmV3IHZhbHVlIGFuZCBhIHRyYW5zaXRpb24gdGltZSBncmVhdGVyXHJcbiAgICogdGhhdCB6ZXJvIGlzIHNwZWNpZmllZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPEFic3RyYWN0U3RhdGU+fSBbY3VycmVudFN0YXRlcz1bXV0gLSBTdGF0ZXMgd2hvc2Ugd2VpZ2h0IHZhbHVlc1xyXG4gICAqIHdpbGwgYmUgYW5pbWF0ZWQgdG8gMC5cclxuICAgKiBAcGFyYW0ge0Fic3RyYWN0U3RhdGU9fSB0YXJnZXRTdGF0ZSAtIFN0YXRlIHdob3NlIHdlaWdodCB3aWxsIGJlIGFuaW1hdGVkXHJcbiAgICogdG8gMS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gdHJhbnNpdGlvblRpbWUgLSBBbW91bnQgb2YgdGltZSBpdCB3aWxsIGluIHNlY29uZHMgdGFrZSBmb3JcclxuICAgKiB3ZWlnaHQgYW5pbWF0aW9ucyB0byBjb21wbGV0ZS5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gZWFzaW5nRm4gLSBFYXNpbmcgZnVuY3Rpb24gdG8gdXNlIGZvciB3ZWlnaHQgYW5pbWF0aW9ucy5cclxuICAgKiBEZWZhdWx0IGlzIEVhc2luZy5MaW5lYXIuSW5PdXQuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uQ29tcGxldGUgLSBGdW5jdGlvbiB0byBleGVjdXRlIG9uY2UgYWxsIHdlaWdodCBhbmltYXRpb25zXHJcbiAgICogY29tcGxldGUuXHJcbiAgICovXHJcbiAgY29uZmlndXJlKFxyXG4gICAgY3VycmVudFN0YXRlcyA9IFtdLFxyXG4gICAgdGFyZ2V0U3RhdGUsXHJcbiAgICB0cmFuc2l0aW9uVGltZSxcclxuICAgIGVhc2luZ0ZuLFxyXG4gICAgb25Db21wbGV0ZVxyXG4gICkge1xyXG4gICAgLy8gRGVhY3RpdmF0ZSBhbnkgc3RhdGVzIHRoYXQgYXJlbid0IGluIHRoZSBuZXcgY29uZmlndXJhdGlvblxyXG4gICAgaWYgKHRoaXMuX3RvID09PSB0YXJnZXRTdGF0ZSB8fCBjdXJyZW50U3RhdGVzLmluY2x1ZGVzKHRoaXMuX3RvKSkge1xyXG4gICAgICB0aGlzLl90byA9IG51bGw7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9mcm9tID0gdGhpcy5fZnJvbS5maWx0ZXIoXHJcbiAgICAgIHN0YXRlID0+IHN0YXRlICE9PSB0YXJnZXRTdGF0ZSAmJiAhY3VycmVudFN0YXRlcy5pbmNsdWRlcyhzdGF0ZSlcclxuICAgICk7XHJcbiAgICB0aGlzLmRlYWN0aXZhdGUoKTtcclxuXHJcbiAgICB0aGlzLl9mcm9tID0gY3VycmVudFN0YXRlcztcclxuICAgIHRoaXMuX3RvID0gdGFyZ2V0U3RhdGU7XHJcbiAgICB0aGlzLnJlc2V0KHRyYW5zaXRpb25UaW1lLCBlYXNpbmdGbiwgb25Db21wbGV0ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFydCBuZXcgd2VpZ2h0IGFuaW1hdGlvbnMgc3RhdGUgdGhlIHRyYW5zaXRpb24gY29udHJvbHMuIFRoaXMgc2hvdWxkIGJlIGNhbGxlZFxyXG4gICAqIGlmIGFuIGFuaW1hdGlvbiBpcyBwbGF5ZWQgd2l0aCBhIHRyYW5zaXRpb24gdGltZSBncmVhdGVyIHRoYW4gemVybyBhbmQgYSB0cmFuc3Rpb25cclxuICAgKiB0byB0aGF0IGFuaW1hdGlvbiB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0cmFuc2l0aW9uVGltZSAtIEFtb3VudCBvZiB0aW1lIGl0IHdpbGwgaW4gc2Vjb25kcyB0YWtlIGZvclxyXG4gICAqIHdlaWdodCBhbmltYXRpb25zIHRvIGNvbXBsZXRlLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBlYXNpbmdGbiAtIEVhc2luZyBmdW5jdGlvbiB0byB1c2UgZm9yIHdlaWdodCBhbmltYXRpb25zLlxyXG4gICAqIERlZmF1bHQgaXMgRWFzaW5nLkxpbmVhci5Jbk91dC5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25Db21wbGV0ZSAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgb25jZSBhbGwgd2VpZ2h0IGFuaW1hdGlvbnNcclxuICAgKiBjb21wbGV0ZS5cclxuICAgKi9cclxuICByZXNldCh0cmFuc2l0aW9uVGltZSwgZWFzaW5nRm4sIG9uQ29tcGxldGUpIHtcclxuICAgIC8vIFN0b3AgYW55IHBlbmRpbmcgcHJvbWlzZXNcclxuICAgIHRoaXMuX3dlaWdodFByb21pc2UuY2FuY2VsKCk7XHJcblxyXG4gICAgLy8gU3RhcnQgdHdlZW5pbmcgd2VpZ2h0IHRvIDAgZm9yIHRoZSBjdXJyZW50IHN0YXRlc1xyXG4gICAgY29uc3Qgd2VpZ2h0UHJvbWlzZXMgPSB0aGlzLl9mcm9tLm1hcChzdGF0ZSA9PlxyXG4gICAgICBzdGF0ZS5zZXRXZWlnaHQoMCwgdHJhbnNpdGlvblRpbWUsIGVhc2luZ0ZuKVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBTdGFydCB0d2VlbmluZyB3ZWlnaHQgdG8gMSBmb3IgdGhlIHRhcmdldCBzdGF0ZVxyXG4gICAgaWYgKHRoaXMuX3RvKSB7XHJcbiAgICAgIHdlaWdodFByb21pc2VzLnB1c2godGhpcy5fdG8uc2V0V2VpZ2h0KDEsIHRyYW5zaXRpb25UaW1lLCBlYXNpbmdGbikpO1xyXG4gICAgICB0aGlzLm5hbWUgPSB0aGlzLl90by5uYW1lO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5uYW1lID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl93ZWlnaHRQcm9taXNlID0gRGVmZXJyZWQuYWxsKHdlaWdodFByb21pc2VzLCAoKSA9PiB7XHJcbiAgICAgIHRoaXMuX2Zyb20uZm9yRWFjaChzdGF0ZSA9PiB7XHJcbiAgICAgICAgc3RhdGUuY2FuY2VsKCk7XHJcbiAgICAgICAgc3RhdGUuZGVhY3RpdmF0ZSgpO1xyXG4gICAgICB9KTtcclxuICAgICAgaWYgKHR5cGVvZiBvbkNvbXBsZXRlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgb25Db21wbGV0ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHBsYXkob25GaW5pc2gsIG9uRXJyb3IsIG9uQ2FuY2VsLCBvbk5leHQpIHtcclxuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5fcGxheUNhbGxiYWNrcy5vbkZpbmlzaCA9IG9uRmluaXNoO1xyXG4gICAgdGhpcy5fcGxheUNhbGxiYWNrcy5vbkVycm9yID0gb25FcnJvcjtcclxuICAgIHRoaXMuX3BsYXlDYWxsYmFja3Mub25DYW5jZWwgPSBvbkNhbmNlbDtcclxuXHJcbiAgICBjb25zdCBwcm9taXNlcyA9IFt0aGlzLl93ZWlnaHRQcm9taXNlXTtcclxuXHJcbiAgICB0aGlzLl9mcm9tLmZvckVhY2goc3RhdGUgPT4ge1xyXG4gICAgICBzdGF0ZS5yZXN1bWUoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICh0aGlzLl90bykge1xyXG4gICAgICB0aGlzLl9wcm9taXNlcy5wbGF5ID0gdGhpcy5fdG8ucGxheShcclxuICAgICAgICB1bmRlZmluZWQsXHJcbiAgICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICAgIHVuZGVmaW5lZCxcclxuICAgICAgICBvbk5leHRcclxuICAgICAgKTtcclxuICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLl9wcm9taXNlcy5wbGF5KTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9wcm9taXNlcy5maW5pc2ggPSBEZWZlcnJlZC5hbGwocHJvbWlzZXMsIG9uRmluaXNoLCBvbkVycm9yLCBvbkNhbmNlbCk7XHJcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZXMuZmluaXNoO1xyXG4gIH1cclxuXHJcbiAgcGF1c2UoKSB7XHJcbiAgICB0aGlzLl9mcm9tLmZvckVhY2goc3RhdGUgPT4ge1xyXG4gICAgICBzdGF0ZS5wYXVzZSgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKHRoaXMuX3RvKSB7XHJcbiAgICAgIHRoaXMuX3RvLnBhdXNlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN1cGVyLnBhdXNlKCk7XHJcbiAgfVxyXG5cclxuICByZXN1bWUob25GaW5pc2gsIG9uRXJyb3IsIG9uQ2FuY2VsLCBvbk5leHQpIHtcclxuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xyXG5cclxuICAgIGlmICghdGhpcy5fcHJvbWlzZXMucGxheS5wZW5kaW5nKSB7XHJcbiAgICAgIHRoaXMuX3BsYXlDYWxsYmFja3Mub25GaW5pc2ggPSBvbkZpbmlzaCB8fCB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uRmluaXNoO1xyXG4gICAgICB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uRXJyb3IgPSBvbkVycm9yIHx8IHRoaXMuX3BsYXlDYWxsYmFja3Mub25FcnJvcjtcclxuICAgICAgdGhpcy5fcGxheUNhbGxiYWNrcy5vbkNhbmNlbCA9IG9uQ2FuY2VsIHx8IHRoaXMuX3BsYXlDYWxsYmFja3Mub25DYW5jZWw7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcHJvbWlzZXMgPSBbdGhpcy5fd2VpZ2h0UHJvbWlzZV07XHJcblxyXG4gICAgdGhpcy5fZnJvbS5mb3JFYWNoKHN0YXRlID0+IHtcclxuICAgICAgc3RhdGUucmVzdW1lKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAodGhpcy5fdG8pIHtcclxuICAgICAgdGhpcy5fcHJvbWlzZXMucGxheSA9IHRoaXMuX3RvLnJlc3VtZShcclxuICAgICAgICB1bmRlZmluZWQsXHJcbiAgICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICAgIHVuZGVmaW5lZCxcclxuICAgICAgICBvbk5leHRcclxuICAgICAgKTtcclxuICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLl9wcm9taXNlcy5wbGF5KTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9wcm9taXNlcy5maW5pc2ggPSBEZWZlcnJlZC5hbGwoXHJcbiAgICAgIHByb21pc2VzLFxyXG4gICAgICB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uRmluaXNoLFxyXG4gICAgICB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uRXJyb3IsXHJcbiAgICAgIHRoaXMuX3BsYXlDYWxsYmFja3Mub25DYW5jZWxcclxuICAgICk7XHJcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZXMuZmluaXNoO1xyXG4gIH1cclxuXHJcbiAgY2FuY2VsKCkge1xyXG4gICAgdGhpcy5fZnJvbS5mb3JFYWNoKHN0YXRlID0+IHtcclxuICAgICAgc3RhdGUucGF1c2UoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICh0aGlzLl90bykge1xyXG4gICAgICB0aGlzLl90by5jYW5jZWwoKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl93ZWlnaHRQcm9taXNlLmNhbmNlbCgpO1xyXG5cclxuICAgIHJldHVybiBzdXBlci5jYW5jZWwoKTtcclxuICB9XHJcblxyXG4gIHN0b3AoKSB7XHJcbiAgICB0aGlzLl9mcm9tLmZvckVhY2goc3RhdGUgPT4ge1xyXG4gICAgICBzdGF0ZS5wYXVzZSgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKHRoaXMuX3RvKSB7XHJcbiAgICAgIHRoaXMuX3RvLnN0b3AoKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc3VwZXIuc3RvcCgpO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlKGRlbHRhVGltZSkge1xyXG4gICAgc3VwZXIudXBkYXRlKGRlbHRhVGltZSk7XHJcblxyXG4gICAgdGhpcy5fZnJvbS5mb3JFYWNoKHN0YXRlID0+IHtcclxuICAgICAgc3RhdGUudXBkYXRlKGRlbHRhVGltZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAodGhpcy5fdG8pIHtcclxuICAgICAgdGhpcy5fdG8udXBkYXRlKGRlbHRhVGltZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkaXNjYXJkKCkge1xyXG4gICAgc3VwZXIuZGlzY2FyZCgpO1xyXG5cclxuICAgIHRoaXMuX3dlaWdodFByb21pc2UuY2FuY2VsKCk7XHJcbiAgICBkZWxldGUgdGhpcy5fd2VpZ2h0UHJvbWlzZTtcclxuICAgIHRoaXMuX3RvID0gbnVsbDtcclxuICAgIHRoaXMuX2Zyb20ubGVuZ3RoID0gMDtcclxuICB9XHJcblxyXG4gIGRlYWN0aXZhdGUoKSB7XHJcbiAgICBpZiAodGhpcy5fdG8pIHtcclxuICAgICAgdGhpcy5fdG8uZGVhY3RpdmF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2Zyb20uZm9yRWFjaChzdGF0ZSA9PiB7XHJcbiAgICAgIHN0YXRlLmRlYWN0aXZhdGUoKTtcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgVHJhbnNpdGlvblN0YXRlO1xyXG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXHJcbi8qIGVzbGludC1kaXNhYmxlIG1heC1jbGFzc2VzLXBlci1maWxlICovXHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLWVtcHR5LWZ1bmN0aW9uICovXHJcbi8qIGVzbGludC1kaXNhYmxlIGdldHRlci1yZXR1cm4gKi9cclxuLyogZXNsaW50LWRpc2FibGUgbm8tdXNlbGVzcy1jb25zdHJ1Y3RvciAqL1xyXG5pbXBvcnQgVHJhbnNpdGlvblN0YXRlIGZyb20gJy4vc3RhdGUvVHJhbnNpdGlvblN0YXRlJztcclxuaW1wb3J0IERlZmVycmVkIGZyb20gJy4uL0RlZmVycmVkJztcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyBmYWN0b3J5IGludGVyZmFjZSBmb3IgY29udHJvbGxpbmcgcGxheWJhY2sgb2YgYSBjb2xsZWN0aW9uIG9mIGFuaW1hdGlvbnMuXHJcbiAqIE9uZSBhbmltYXRpb24gY2FuIGJlIHBsYXllZCBhdCBhbnkgZ2l2ZW4gdGltZSwgY3Jvc3NmYWRpbmcgYmV0d2VlbiBhbmltYXRpb25zXHJcbiAqIHdpbGwgcmVzdWx0IGluIHBsYXlpbmcgYSB7QGxpbmsgVHJhbnNpdGlvblN0YXRlfS5cclxuICpcclxuICogQGludGVyZmFjZVxyXG4gKi9cclxuY2xhc3MgQW5pbWF0aW9uUGxheWVySW50ZXJmYWNlIHtcclxuICAvKipcclxuICAgKiBHZXRzIHdoZXRoZXIgb3Igbm90IHRoZSBwbGF5ZXIgaXMgdXBkYXRpbmcgc3RhdGVzLlxyXG4gICAqXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgZ2V0IHBhdXNlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9wYXVzZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIGFuZCBzZXRzIHRoZSBkZWZhdWx0IG51bWJlciBvZiBzZWNvbmRzIGl0IHRha2VzIHRvIHRyYW5zaXRpb24gdG8gYSBuZXdcclxuICAgKiBhbmltYXRpb24uXHJcbiAgICpcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCB0cmFuc2l0aW9uVGltZSgpIHt9XHJcblxyXG4gIHNldCB0cmFuc2l0aW9uVGltZShzZWNvbmRzKSB7fVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIGFuZCBzZXRzIHRoZSBkZWZhdWx0IGVhc2luZyBmdW5jdGlvbiB0byB1c2Ugd2hlbiB0cmFuc2l0aW9uaW5nIGFuZFxyXG4gICAqIHNldHRpbmcgd2VpZ2h0cy5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKi9cclxuICBnZXQgZWFzaW5nRm4oKSB7fVxyXG5cclxuICBzZXQgZWFzaW5nRm4oZm4pIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIHN0YXRlIHRoZSBsYXllciBpcyBjdXJyZW50bHkgaW4gY29udHJvbCBvZi5cclxuICAgKlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEB0eXBlIHtBYnN0cmFjdFN0YXRlfVxyXG4gICAqL1xyXG4gIGdldCBjdXJyZW50U3RhdGUoKSB7fVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBuYW1lIG9mIHRoZSBzdGF0ZSB0aGUgbGF5ZXIgaXMgY3VycmVudGx5IGluIGNvbnRyb2wgb2YuXHJcbiAgICpcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAqL1xyXG4gIGdldCBjdXJyZW50QW5pbWF0aW9uKCkge31cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgbGF5ZXIgaXMgY3VycmVudGx5IHRyYW5zaXRpb25pbmcgdG8gYSBuZXcgYW5pbWF0aW9uLlxyXG4gICAqXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgZ2V0IGlzVHJhbnNpdGlvbmluZygpIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB0aGUgbGF5ZXIncyBjdXJyZW50IHN0YXRlIHRvIGEgbmV3IHZhbHVlLiBJZiB0cmFuc2l0aW9uVGltZSBpcyBkZWZpbmVkXHJcbiAgICogYW5kIGdyZWF0ZXIgdGhhbiB6ZXJvLCBwZXJmb3JtIGEgc21vb3RoIGJsZW5kIGJldHdlZW4gYW55IHN0YXRlcyB0aGF0IGN1cnJlbnRseVxyXG4gICAqIGhhdmUgbm9uLXplcm8gd2VpZ2h0IHZhbHVlcyBhbmQgdGhlIG5ldyBzdGF0ZS5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyhzdHJpbmd8bnVsbCl9IG5hbWUgLSBOYW1lIG9mIHRoZSBzdGF0ZSB0byB0cmFuc2l0aW9uIHRvLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwbGF5TWV0aG9kIC0gTmFtZSBvZiB0aGUgb3BlcmF0aW9uIGJlaW5nIHByZXBhcmVkIGZvciwgdG8gYmVcclxuICAgKiB1c2VkIGluIGVycm9yIG1lc3NhZ2luZy5cclxuICAgKiBAcGFyYW0ge251bWJlcj19IHRyYW5zaXRpb25UaW1lIC0gQW1vdW50IG9mIHRpbWUgaW4gc2Vjb25kcyBpdCB3aWxsIHRha2UgdG9cclxuICAgKiBzd2l0Y2ggdG8gdGhlIG5ldyBzdGF0ZS5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gZWFzaW5nRm4gLSBFYXNpbmcgZnVuY3Rpb24gdG8gdXNlIHdoZW4gdHJhbnNpdGlvbmluZyB0byBhXHJcbiAgICogbmV3IHN0YXRlIG92ZXIgdGltZS5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25FcnJvciAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgaWYgYW4gZXJyb3IgaXMgZW5jb3VudGVyZWQuXHJcbiAgICovXHJcbiAgX3ByZXBhcmVDdXJyZW50U3RhdGUobmFtZSwgcGxheU1ldGhvZCwgdHJhbnNpdGlvblRpbWUsIGVhc2luZ0ZuLCBvbkVycm9yKSB7fVxyXG5cclxuICAvKipcclxuICAgKiBTdGFydCBwbGF5YmFjayBhbiBhbmltYXRpb24gZnJvbSB0aGUgYmVnaW5uaW5nLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBhbmltYXRpb24gdG8gcGxheS5cclxuICAgKiBAcGFyYW0ge251bWJlcj19IHRyYW5zaXRpb25UaW1lIC0gQW1vdW50IG9mIHRpbWUgaXQgd2lsbCB0YWtlIGJlZm9yZSB0aGVcclxuICAgKiBuZXcgc3RhdGUgaGFzIGZ1bGwgaW5mbHVlbmNlIGZvciB0aGUgbGF5ZXIuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGVhc2luZ0ZuIC0gRWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSBmb3IgYmxlbmRpbmcgaWYgdHJhbnNpdGlvblRpbWVcclxuICAgKiBpcyBncmVhdGVyIHRoYW4gemVyby5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25GaW5pc2ggLSBGdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIGFuaW1hdGlvbiBmaW5pc2hlcy5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25FcnJvciAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgaWYgdGhlIGFuaW1hdGlvbiBlbmNvdW50ZXJzXHJcbiAgICogYW4gZXJyb3IgZHVyaW5nIHBsYXliYWNrLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkNhbmNlbCAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgaWYgcGxheWJhY2sgaXMgY2FuY2VsZWQuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uTmV4dCAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgaWYgYW4gYW5pbWF0aW9uIHF1ZXVlIGlzXHJcbiAgICogcGxheWVkIGFuZCBpdCBhZHZhbmNlcyB0byB0aGUgbmV4dCBhbmltYXRpb24uXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9XHJcbiAgICovXHJcbiAgcGxheUFuaW1hdGlvbihcclxuICAgIG5hbWUsXHJcbiAgICB0cmFuc2l0aW9uVGltZSxcclxuICAgIGVhc2luZ0ZuLFxyXG4gICAgb25GaW5pc2gsXHJcbiAgICBvbkVycm9yLFxyXG4gICAgb25DYW5jZWwsXHJcbiAgICBvbk5leHRcclxuICApIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbmNlbCBwbGF5YmFjayBvZiB0aGUgY3VycmVudCBhbmltYXRpb24uXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBjYW5jZWxBbmltYXRpb24oKSB7fVxyXG5cclxuICAvKipcclxuICAgKiBQYXVzZSBwbGF5YmFjayBvZiB0aGUgY3VycmVudCBhbmltYXRpb24uXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBwYXVzZUFuaW1hdGlvbigpIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc3VtZSBwbGF5YmFjayBvZiBhbiBhbmltYXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZz19IG5hbWUgLSBOYW1lIG9mIHRoZSBhbmltYXRpb24gdG8gcmVzdW1lIHBsYXliYWNrIGZvci4gRGVmYXVsdFxyXG4gICAqIGlzIHRoZSBsYXllcidzIGN1cnJlbnQgYW5pbWF0aW9uIG5hbWUuXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSB0cmFuc2l0aW9uVGltZSAtIEFtb3VudCBvZiB0aW1lIGl0IHdpbGwgdGFrZSBiZWZvcmUgdGhlXHJcbiAgICogbmV3IHN0YXRlIGhhcyBmdWxsIGluZmx1ZW5jZSBmb3IgdGhlIGxheWVyLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkZpbmlzaCAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgc3RhdGUgZmluaXNoZXMuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uRXJyb3IgLSBGdW5jdGlvbiB0byBleGVjdXRlIGlmIHRoZSBzdGF0ZSBlbmNvdW50ZXJzXHJcbiAgICogYW4gZXJyb3IgZHVyaW5nIHBsYXliYWNrLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkNhbmNlbCAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgaWYgcGxheWJhY2sgaXMgY2FuY2VsZWQuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uTmV4dCAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgaWYgYW4gYW5pbWF0aW9uIHF1ZXVlIGlzXHJcbiAgICogcGxheWVkIGFuZCBpdCBhZHZhbmNlcyB0byB0aGUgbmV4dCBhbmltYXRpb24uXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9XHJcbiAgICovXHJcbiAgcmVzdW1lQW5pbWF0aW9uKFxyXG4gICAgbmFtZSxcclxuICAgIHRyYW5zaXRpb25UaW1lLFxyXG4gICAgZWFzaW5nRm4sXHJcbiAgICBvbkZpbmlzaCxcclxuICAgIG9uRXJyb3IsXHJcbiAgICBvbkNhbmNlbCxcclxuICAgIG9uTmV4dFxyXG4gICkge31cclxuXHJcbiAgLyoqXHJcbiAgICogU3RvcCBwbGF5YmFjayBvZiB0aGUgY3VycmVudCBhbmltYXRpb24uXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBzdG9wQW5pbWF0aW9uKCkge31cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHRoZSBjdXJyZW50IGFuaW1hdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVRpbWUgLSBUaW1lIGluIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgbGFzdCB1cGRhdGUuXHJcbiAgICovXHJcbiAgdXBkYXRlKGRlbHRhVGltZSkge31cclxuXHJcbiAgLyoqXHJcbiAgICogRGlzY2FyZCB0aGUgdHJhbnNpdGlvbiBzdGF0ZS5cclxuICAgKi9cclxuICBkaXNjYXJkKCkge31cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIGNsYXNzIHRoYXQgaW1wbGVtZW50cyB7QGxpbmsgQW5pbWF0aW9uUGxheWVySW50ZXJmYWNlfSBhbmQgZXh0ZW5kc1xyXG4gICAqIGEgc3BlY2lmaWVkIGJhc2UgY2xhc3MuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0NsYXNzfSBbQmFzZUNsYXNzID0gY2xhc3N7fV0gLSBUaGUgY2xhc3MgdG8gZXh0ZW5kLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Q2xhc3N9IEEgY2xhc3MgdGhhdCBleHRlbmRzIGBCYXNlQ2xhc3NgIGFuZCBpbXBsZW1lbnRzIHtAbGluayBBbmltYXRpb25QbGF5ZXJJbnRlcmZhY2V9LlxyXG4gICAqL1xyXG4gIHN0YXRpYyBNaXhpbihCYXNlQ2xhc3MgPSBjbGFzcyB7fSkge1xyXG4gICAgY29uc3QgQW5pbWF0aW9uUGxheWVyTWl4aW4gPSBjbGFzcyBleHRlbmRzIEJhc2VDbGFzcyB7XHJcbiAgICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSwgLi4uYXJncykge1xyXG4gICAgICAgIHN1cGVyKG9wdGlvbnMsIC4uLmFyZ3MpO1xyXG5cclxuICAgICAgICB0aGlzLl90cmFuc2l0aW9uU3RhdGUgPSBuZXcgVHJhbnNpdGlvblN0YXRlKCk7XHJcbiAgICAgICAgdGhpcy5fc3RhdGVzID0gdGhpcy5fc3RhdGVzICE9PSB1bmRlZmluZWQgPyB0aGlzLl9zdGF0ZXMgOiBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudFN0YXRlID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvblRpbWUgPVxyXG4gICAgICAgICAgTnVtYmVyKG9wdGlvbnMudHJhbnNpdGlvblRpbWUpID49IDBcclxuICAgICAgICAgICAgPyBOdW1iZXIob3B0aW9ucy50cmFuc2l0aW9uVGltZSlcclxuICAgICAgICAgICAgOiAwO1xyXG5cclxuICAgICAgICB0aGlzLl9lYXNpbmdGbiA9XHJcbiAgICAgICAgICB0eXBlb2Ygb3B0aW9ucy5lYXNpbmdGbiA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMuZWFzaW5nRm4gOiB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGdldCBwYXVzZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhdXNlZDtcclxuICAgICAgfVxyXG5cclxuICAgICAgZ2V0IHRyYW5zaXRpb25UaW1lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2l0aW9uVGltZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc2V0IHRyYW5zaXRpb25UaW1lKHNlY29uZHMpIHtcclxuICAgICAgICBzZWNvbmRzID0gTnVtYmVyKHNlY29uZHMpO1xyXG5cclxuICAgICAgICBpZiAoIShzZWNvbmRzID49IDApKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgIGBDYW5ub3Qgc2V0IHRyYW5zaXRpb24gdGltZSBmb3IgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IHRvICR7c2Vjb25kc30uIFNlY29uZHMgbXVzdCBiZSBhIG51bWVyaWMgdmFsdWUgZ3JlYXRoZXIgdGhhbiBvciBlcXVhbCB0byB6ZXJvLmBcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl90cmFuc2l0aW9uVGltZSA9IHNlY29uZHM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGdldCBlYXNpbmdGbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZWFzaW5nRm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNldCBlYXNpbmdGbihmbikge1xyXG4gICAgICAgIHRoaXMuX2Vhc2luZ0ZuID0gZm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGdldCBjdXJyZW50U3RhdGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRTdGF0ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZ2V0IGN1cnJlbnRBbmltYXRpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRTdGF0ZSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRTdGF0ZS5uYW1lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGdldCBpc1RyYW5zaXRpb25pbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRTdGF0ZSA9PT0gdGhpcy5fdHJhbnNpdGlvblN0YXRlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBfcHJlcGFyZUN1cnJlbnRTdGF0ZShcclxuICAgICAgICBuYW1lLFxyXG4gICAgICAgIHBsYXlNZXRob2QsXHJcbiAgICAgICAgdHJhbnNpdGlvblRpbWUsXHJcbiAgICAgICAgZWFzaW5nRm4sXHJcbiAgICAgICAgb25FcnJvclxyXG4gICAgICApIHtcclxuICAgICAgICBpZiAobmFtZSAhPT0gbnVsbCAmJiAhdGhpcy5fc3RhdGVzLmhhcyhuYW1lKSkge1xyXG4gICAgICAgICAgY29uc3QgZSA9IG5ldyBFcnJvcihcclxuICAgICAgICAgICAgYENhbm5vdCAke3BsYXlNZXRob2R9IGFuaW1hdGlvbiAke25hbWV9LiBObyBhbmltYXRpb24gZXhpc3RzIHdpdGggdGhpcyBuYW1lLmBcclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgaWYgKHR5cGVvZiBvbkVycm9yID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIG9uRXJyb3IoZSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHRhcmdldFN0YXRlID0gbmFtZSAhPT0gbnVsbCA/IHRoaXMuX3N0YXRlcy5nZXQobmFtZSkgOiBudWxsO1xyXG5cclxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIG5ldyBzdGF0ZSBpc24ndCBhbHJlYWR5IHBsYXlpbmdcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50QW5pbWF0aW9uICE9PSBuYW1lKSB7XHJcbiAgICAgICAgICAvLyBTd2l0Y2ggdG8gdGhlIG5ldyBzdGF0ZSBpbW1lZGlhdGVseVxyXG4gICAgICAgICAgaWYgKHRyYW5zaXRpb25UaW1lIDw9IDApIHtcclxuICAgICAgICAgICAgLy8gQ2FuY2VsIHRoZSBjdXJyZW50IHN0YXRlIGFuZCBzZXQgaXRzIHdlaWdodCB0byAwXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50U3RhdGUpIHtcclxuICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50U3RhdGUuY2FuY2VsKCk7XHJcbiAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFN0YXRlLndlaWdodCA9IDA7XHJcbiAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFN0YXRlLmRlYWN0aXZhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudFN0YXRlID0gdGFyZ2V0U3RhdGU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBCbGVuZCB0byB0aGUgbmV3IHN0YXRlIG92ZXIgdGltZVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0byB0cmFuc2l0aW9uIG91dCBvZiBhbnkgc3RhdGVzIHdpdGggbm9uLXplcm8gd2VpZ2h0XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZXMgPSBbLi4udGhpcy5fc3RhdGVzLnZhbHVlcygpXS5maWx0ZXIoXHJcbiAgICAgICAgICAgICAgcyA9PiBzICE9PSB0YXJnZXRTdGF0ZSAmJiAocy53ZWlnaHQgfHwgcy53ZWlnaHRQZW5kaW5nKVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSB0cmFuc2l0aW9uIHN0YXRlIHdpdGggbmV3IGlucHV0c1xyXG4gICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uU3RhdGUuY29uZmlndXJlKFxyXG4gICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZXMsXHJcbiAgICAgICAgICAgICAgdGFyZ2V0U3RhdGUsXHJcbiAgICAgICAgICAgICAgdHJhbnNpdGlvblRpbWUsXHJcbiAgICAgICAgICAgICAgZWFzaW5nRm4sXHJcbiAgICAgICAgICAgICAgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFN0YXRlID0gdGFyZ2V0U3RhdGU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uU3RhdGUud2VpZ2h0ID0gMDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50U3RhdGUgPSB0aGlzLl90cmFuc2l0aW9uU3RhdGU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChwbGF5TWV0aG9kID09PSAncGxheScpIHtcclxuICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZS5jYW5jZWwoKTtcclxuXHJcbiAgICAgICAgICBpZiAodGhpcy5fY3VycmVudFN0YXRlID09PSB0aGlzLl90cmFuc2l0aW9uU3RhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvblN0YXRlLnJlc2V0KHRyYW5zaXRpb25UaW1lLCBlYXNpbmdGbiwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZSA9IHRhcmdldFN0YXRlO1xyXG4gICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25TdGF0ZS53ZWlnaHQgPSAwO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSB3ZWlnaHQgZm9yIHRoZSBuZXcgY3VycmVudCBzdGF0ZSBzbyBpdCBoYXMgZnVsbCBpbmZsdWVuY2UgZm9yIHRoZSBwbGF5ZXJcclxuICAgICAgICB0aGlzLl9jdXJyZW50U3RhdGUud2VpZ2h0ID0gMTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50U3RhdGUudXBkYXRlSW50ZXJuYWxXZWlnaHQodGhpcy5faW50ZXJuYWxXZWlnaHQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwbGF5QW5pbWF0aW9uKFxyXG4gICAgICAgIG5hbWUsXHJcbiAgICAgICAgdHJhbnNpdGlvblRpbWUsXHJcbiAgICAgICAgZWFzaW5nRm4sXHJcbiAgICAgICAgb25GaW5pc2gsXHJcbiAgICAgICAgb25FcnJvcixcclxuICAgICAgICBvbkNhbmNlbCxcclxuICAgICAgICBvbk5leHRcclxuICAgICAgKSB7XHJcbiAgICAgICAgbGV0IGVycm9yO1xyXG4gICAgICAgIGxldCByZWplY3QgPSBmYWxzZTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgdGhpcy5fcHJlcGFyZUN1cnJlbnRTdGF0ZShcclxuICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICAgICAgJ3BsYXknLFxyXG4gICAgICAgICAgICB0cmFuc2l0aW9uVGltZSAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgPyB0cmFuc2l0aW9uVGltZVxyXG4gICAgICAgICAgICAgIDogdGhpcy5fdHJhbnNpdGlvblRpbWUsXHJcbiAgICAgICAgICAgIGVhc2luZ0ZuICE9PSB1bmRlZmluZWQgPyBlYXNpbmdGbiA6IHRoaXMuX2Vhc2luZ0ZuLFxyXG4gICAgICAgICAgICBvbkVycm9yXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIGVycm9yID0gZTtcclxuICAgICAgICAgIHJlamVjdCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocmVqZWN0KSB7XHJcbiAgICAgICAgICByZXR1cm4gRGVmZXJyZWQucmVqZWN0KGVycm9yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50U3RhdGUucGxheShvbkZpbmlzaCwgb25FcnJvciwgb25DYW5jZWwsIG9uTmV4dCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHBhdXNlQW5pbWF0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50U3RhdGUpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50U3RhdGUucGF1c2UoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmVzdW1lQW5pbWF0aW9uKFxyXG4gICAgICAgIG5hbWUsXHJcbiAgICAgICAgdHJhbnNpdGlvblRpbWUsXHJcbiAgICAgICAgZWFzaW5nRm4sXHJcbiAgICAgICAgb25GaW5pc2gsXHJcbiAgICAgICAgb25FcnJvcixcclxuICAgICAgICBvbkNhbmNlbCxcclxuICAgICAgICBvbk5leHRcclxuICAgICAgKSB7XHJcbiAgICAgICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9jdXJyZW50U3RhdGUpIHtcclxuICAgICAgICAgIG5hbWUgPSB0aGlzLl9jdXJyZW50U3RhdGUubmFtZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBlcnJvcjtcclxuICAgICAgICBsZXQgcmVqZWN0ID0gZmFsc2U7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHRoaXMuX3ByZXBhcmVDdXJyZW50U3RhdGUoXHJcbiAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgICdyZXN1bWUnLFxyXG4gICAgICAgICAgICB0cmFuc2l0aW9uVGltZSAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgPyB0cmFuc2l0aW9uVGltZVxyXG4gICAgICAgICAgICAgIDogdGhpcy5fdHJhbnNpdGlvblRpbWUsXHJcbiAgICAgICAgICAgIGVhc2luZ0ZuICE9PSB1bmRlZmluZWQgPyBlYXNpbmdGbiA6IHRoaXMuX2Vhc2luZ0ZuLFxyXG4gICAgICAgICAgICBvbkVycm9yXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIGVycm9yID0gZTtcclxuICAgICAgICAgIHJlamVjdCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocmVqZWN0KSB7XHJcbiAgICAgICAgICByZXR1cm4gRGVmZXJyZWQucmVqZWN0KGVycm9yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50U3RhdGUucmVzdW1lKG9uRmluaXNoLCBvbkVycm9yLCBvbkNhbmNlbCwgb25OZXh0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY2FuY2VsQW5pbWF0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50U3RhdGUpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50U3RhdGUuY2FuY2VsKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHN0b3BBbmltYXRpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRTdGF0ZSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRTdGF0ZS5zdG9wKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHVwZGF0ZShkZWx0YVRpbWUpIHtcclxuICAgICAgICBpZiAoc3VwZXIudXBkYXRlKSB7XHJcbiAgICAgICAgICBzdXBlci51cGRhdGUoZGVsdGFUaW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50U3RhdGUpIHtcclxuICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZS51cGRhdGUoZGVsdGFUaW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGRpc2NhcmQoKSB7XHJcbiAgICAgICAgaWYgKHN1cGVyLmRpc2NhcmQpIHtcclxuICAgICAgICAgIHN1cGVyLmRpc2NhcmQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25TdGF0ZS5kaXNjYXJkKCk7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX3RyYW5zaXRpb25TdGF0ZTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gQW5pbWF0aW9uUGxheWVyTWl4aW47XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBBbmltYXRpb25QbGF5ZXJJbnRlcmZhY2U7XHJcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcclxuLyogZXNsaW50LWRpc2FibGUgbWF4LWNsYXNzZXMtcGVyLWZpbGUgKi9cclxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cclxuLyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHktZnVuY3Rpb24gKi9cclxuLyogZXNsaW50LWRpc2FibGUgZ2V0dGVyLXJldHVybiAqL1xyXG5cclxuaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uL1V0aWxzJztcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyBmYWN0b3J5IGludGVyZmFjZSBmb3IgbWFuaXB1bGF0aW5nIGEgY29sbGVjdGlvbiBvZiB7QGxpbmsgQWJzdHJhY3RTdGF0ZX0uXHJcbiAqXHJcbiAqIEBpbnRlcmZhY2VcclxuICovXHJcbmNsYXNzIFN0YXRlQ29udGFpbmVySW50ZXJmYWNlIHtcclxuICAvKipcclxuICAgKiBSZXR1cm4gdGhlIHN0YXRlIHdpdGggdGhlIGdpdmVuIG5hbWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIHN0YXRlLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0Fic3RyYWN0U3RhdGV9XHJcbiAgICovXHJcbiAgZ2V0U3RhdGUobmFtZSkge31cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyBhbiBhcnJheSBvZiB0aGUgbmFtZXMgb2YgYWxsIHN0YXRlcyBpbiB0aGUgY29udGFpbmVyLlxyXG4gICAqXHJcbiAgICogQHR5cGUge0FycmF5LjxzdHJpbmc+fVxyXG4gICAqL1xyXG4gIGdldFN0YXRlTmFtZXMoKSB7fVxyXG5cclxuICAvKipcclxuICAgKiBBZGQgYSBuZXcgc3RhdGUgdG8gYmUgY29udHJvbGxlZCBieSB0aGUgY29udGFpbmVyLiBTdGF0ZXMgYXJlIHN0b3JlZCBrZXllZFxyXG4gICAqIGJ5IHRoZWlyIG5hbWUgcHJvcGVydHksIHdoaWNoIG11c3QgYmUgdW5pcXVlLiBJZiBpdCBpc24ndCwgYSBudW1iZXIgd2lsbFxyXG4gICAqIGJlIGFkZGVkIG9yIGluY3JlbWVudGVkIHVudGlsIGEgdW5pcXVlIGtleSBpcyBnZW5lcmF0ZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0Fic3RyYWN0U3RhdGV9IHN0YXRlIC0gU3RhdGUgdG8gYWRkIHRvIHRoZSBjb250YWluZXIuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIFVuaXF1ZSBuYW1lIG9mIHRoZSBzdGF0ZS5cclxuICAgKi9cclxuICBhZGRTdGF0ZShzdGF0ZSkge31cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBhIHN0YXRlIHdpdGggdGhlIGdpdmVuIG5hbWUgZnJvbSB0aGUgY29udGFpbmVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBzdGF0ZSB0byByZW1vdmUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBXaGV0aGVyIG9yIG5vdCBhIHN0YXRlIHdhcyByZW1vdmVkLlxyXG4gICAqL1xyXG4gIHJlbW92ZVN0YXRlKG5hbWUpIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbmFtZXMgYSBzdGF0ZSB3aXRoIHRoZSBnaXZlbiBuYW1lIGluIHRoZSBjb250YWluZXIuIE5hbWUgbXVzdCBiZSB1bmlxdWVcclxuICAgKiB0byB0aGUgY29udGFpbmVyLCBpZiBpdCBpc24ndCB0aGUgbmFtZSB3aWxsIGJlIGluY3JlbWVudGVkIHVudGlsIGl0IGlzIHVuaXF1ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjdXJyZW50TmFtZSAtIE5hbWUgb2YgdGhlIHN0YXRlIHRvIHJlbmFtZS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3TmFtZSAtIE5hbWUgdG8gdXBkYXRlIHRoZSBzdGF0ZSB3aXRoLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge3N0cmluZ30gLSBVcGRhdGVkIG5hbWUgZm9yIHRoZSBzdGF0ZS5cclxuICAgKi9cclxuICByZW5hbWVTdGF0ZShjdXJyZW50TmFtZSwgbmV3TmFtZSkge31cclxuXHJcbiAgLyoqXHJcbiAgICogRGlzY2FyZHMgYWxsIHN0YXRlcy5cclxuICAgKi9cclxuICBkaXNjYXJkU3RhdGVzKCkge31cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIGNsYXNzIHRoYXQgaW1wbGVtZW50cyB7QGxpbmsgU3RhdGVDb250YWluZXJJbnRlcmZhY2V9IGFuZCBleHRlbmRzXHJcbiAgICogYSBzcGVjaWZpZWQgYmFzZSBjbGFzcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Q2xhc3N9IFtCYXNlQ2xhc3MgPSBjbGFzc3t9XSAtIFRoZSBjbGFzcyB0byBleHRlbmQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtDbGFzc30gQSBjbGFzcyB0aGF0IGV4dGVuZHMgYEJhc2VDbGFzc2AgYW5kIGltcGxlbWVudHMge0BsaW5rIFN0YXRlQ29udGFpbmVySW50ZXJmYWNlfS5cclxuICAgKi9cclxuICBzdGF0aWMgTWl4aW4oQmFzZUNsYXNzID0gY2xhc3Mge30pIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtaXhpbiBhZGRzIGZ1bmN0aW9uYWxpdHkgZm9yIG1hbmlwdWxhdGluZyB1bmlxdWVseS1uYW1lZCBhbmltYXRpb24gc3RhdGVzIGluXHJcbiAgICAgKiBhIG1hcC5cclxuICAgICAqL1xyXG4gICAgY29uc3QgU3RhdGVDb250YWluZXJNaXhpbiA9IGNsYXNzIGV4dGVuZHMgQmFzZUNsYXNzIHtcclxuICAgICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9LCAuLi5hcmdzKSB7XHJcbiAgICAgICAgc3VwZXIob3B0aW9ucywgLi4uYXJncyk7XHJcblxyXG4gICAgICAgIHRoaXMuX3N0YXRlcyA9IHRoaXMuX3N0YXRlcyAhPT0gdW5kZWZpbmVkID8gdGhpcy5fc3RhdGVzIDogbmV3IE1hcCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBnZXRTdGF0ZShuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlcy5nZXQobmFtZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGdldFN0YXRlTmFtZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFsuLi50aGlzLl9zdGF0ZXMua2V5cygpXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgYWRkU3RhdGUoc3RhdGUpIHtcclxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHN0YXRlIGlzIG5vdCBhbHJlYWR5IGluIHRoaXMgY29udGFpbmVyXHJcbiAgICAgICAgaWYgKFsuLi50aGlzLl9zdGF0ZXMudmFsdWVzKCldLmluY2x1ZGVzKHN0YXRlKSkge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgICAgICBgQ2Fubm90IGFkZCBhbmltYXRpb24gdG8gc3RhdGUgJHt0aGlzLm5hbWV9LiBBbmltYXRpb24gd2FzIGFscmVhZHkgYWRkZWQuYFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIHJldHVybiBzdGF0ZS5uYW1lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBzdGF0ZSBuYW1lIGlzIHVuaXF1ZVxyXG4gICAgICAgIGNvbnN0IHVuaXF1ZU5hbWUgPSBVdGlscy5nZXRVbmlxdWVOYW1lKHN0YXRlLm5hbWUsIFtcclxuICAgICAgICAgIC4uLnRoaXMuX3N0YXRlcy5rZXlzKCksXHJcbiAgICAgICAgXSk7XHJcblxyXG4gICAgICAgIGlmIChzdGF0ZS5uYW1lICE9PSB1bmlxdWVOYW1lKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgICAgIGBBbmltYXRpb24gbmFtZSAke3N0YXRlLm5hbWV9IGlzIG5vdCB1bmlxdWUgZm9yIHN0YXRlICR7dGhpcy5uYW1lfS4gTmV3IGFuaW1hdGlvbiB3aWxsIGJlIGFkZGVkIHdpdGggbmFtZSAke3VuaXF1ZU5hbWV9LmBcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBzdGF0ZS5uYW1lID0gdW5pcXVlTmFtZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX3N0YXRlcy5zZXQoc3RhdGUubmFtZSwgc3RhdGUpO1xyXG5cclxuICAgICAgICByZXR1cm4gc3RhdGUubmFtZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmVtb3ZlU3RhdGUobmFtZSkge1xyXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBzdGF0ZSBpcyBpbiB0aGlzIGNvbnRhaW5lclxyXG4gICAgICAgIGlmICghdGhpcy5fc3RhdGVzIHx8ICF0aGlzLl9zdGF0ZXMuaGFzKG5hbWUpKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgICAgIGBEaWQgbm90IHJlbW92ZSBhbmltYXRpb24gJHtuYW1lfSBmcm9tIHN0YXRlICR7dGhpcy5uYW1lfS4gTm8gYW5pbWF0aW9uIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fc3RhdGVzLmdldChuYW1lKS5kaXNjYXJkKCk7XHJcbiAgICAgICAgdGhpcy5fc3RhdGVzLmRlbGV0ZShuYW1lKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmVuYW1lU3RhdGUoY3VycmVudE5hbWUsIG5ld05hbWUpIHtcclxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHN0YXRlIGlzIGluIHRoaXMgY29udGFpbmVyXHJcbiAgICAgICAgaWYgKCF0aGlzLl9zdGF0ZXMgfHwgIXRoaXMuX3N0YXRlcy5oYXMoY3VycmVudE5hbWUpKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgIGBDYW5ub3QgcmVuYW1lIGFuaW1hdGlvbiAke2N1cnJlbnROYW1lfSBpbiAke3RoaXMubmFtZX0uIE5vIGFuaW1hdGlvbiBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGVzLmdldChjdXJyZW50TmFtZSk7XHJcblxyXG4gICAgICAgIC8vIEV4aXQgaWYgdGhlIG5hbWVzIGFyZSB0aGUgc2FtZVxyXG4gICAgICAgIGlmIChjdXJyZW50TmFtZSA9PT0gbmV3TmFtZSkge1xyXG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnROYW1lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBuYW1lIGlzIHVuaXF1ZVxyXG4gICAgICAgIGNvbnN0IHVuaXF1ZU5hbWUgPSBVdGlscy5nZXRVbmlxdWVOYW1lKFxyXG4gICAgICAgICAgbmV3TmFtZSxcclxuICAgICAgICAgIFsuLi50aGlzLl9zdGF0ZXMua2V5cygpXS5maWx0ZXIocyA9PiBzLm5hbWUgIT09IGN1cnJlbnROYW1lKVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGlmIChuZXdOYW1lICE9PSB1bmlxdWVOYW1lKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgICAgIGBBbmltYXRpb24gbmFtZSAke25ld05hbWV9IGlzIG5vdCB1bmlxdWUgaW4gc3RhdGUgJHt0aGlzLm5hbWV9LiBBbmltYXRpb24gd2lsbCBiZSByZW5hbWVkIHRvICR7dW5pcXVlTmFtZX0uYFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIG5ld05hbWUgPSB1bmlxdWVOYW1lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhdGUubmFtZSA9IG5ld05hbWU7XHJcbiAgICAgICAgdGhpcy5fc3RhdGVzLmRlbGV0ZShjdXJyZW50TmFtZSk7XHJcbiAgICAgICAgdGhpcy5fc3RhdGVzLnNldChzdGF0ZS5uYW1lLCBzdGF0ZSk7XHJcblxyXG4gICAgICAgIHJldHVybiBzdGF0ZS5uYW1lO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBkaXNjYXJkU3RhdGVzKCkge1xyXG4gICAgICAgIHRoaXMuX3N0YXRlcy5mb3JFYWNoKHN0YXRlID0+IHtcclxuICAgICAgICAgIHN0YXRlLmRpc2NhcmQoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX3N0YXRlcztcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBTdGF0ZUNvbnRhaW5lck1peGluO1xyXG4gIH1cclxufVxyXG5leHBvcnQgZGVmYXVsdCBTdGF0ZUNvbnRhaW5lckludGVyZmFjZTtcclxuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxyXG5pbXBvcnQgQWJzdHJhY3RTdGF0ZSBmcm9tICcuL0Fic3RyYWN0U3RhdGUnO1xyXG5pbXBvcnQgQW5pbWF0aW9uUGxheWVySW50ZXJmYWNlIGZyb20gJy4uL0FuaW1hdGlvblBsYXllckludGVyZmFjZSc7XHJcbmltcG9ydCBTdGF0ZUNvbnRhaW5lckludGVyZmFjZSBmcm9tICcuL1N0YXRlQ29udGFpbmVySW50ZXJmYWNlJztcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyBmb3IgcGxheWluZyBhbiBvcmRlcmVkIGFycmF5IG9mIGFuaW1hdGlvbiBzdGF0ZXMgaW4gc2VxdWVuY2UuXHJcbiAqXHJcbiAqIEBleHRlbmRzIEFic3RyYWN0U3RhdGVcclxuICogQGltcGxlbWVudHMgQEFuaW1hdGlvblBsYXllckludGVyZmFjZVxyXG4gKi9cclxuY2xhc3MgUXVldWVTdGF0ZSBleHRlbmRzIEFuaW1hdGlvblBsYXllckludGVyZmFjZS5NaXhpbihcclxuICBTdGF0ZUNvbnRhaW5lckludGVyZmFjZS5NaXhpbihBYnN0cmFjdFN0YXRlKVxyXG4pIHtcclxuICAvKipcclxuICAgKiBAY29uc3RydWN0b3JcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gLSBPcHRpb25zIGZvciB0aGUgc3RhdGUuXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hdXRvQWR2YW5jZT10cnVlXSAtIFdoZXRoZXIgdG8gYXV0bWF0aWNhbGx5IGFkdmFuY2VcclxuICAgKiB0byB0aGUgbmV4dCBzdGF0ZSBpbiB0aGUgcXVldWUgYXMgZWFjaCBzdGF0ZSBjb21wbGV0ZXMuXHJcbiAgICogQHBhcmFtIHtBcnJheS48QWJzdHJhY3RTdGF0ZT59IFtxdWV1ZVN0YXRlcz1bXV0gLSBBcnJheSBvZiBzdGF0ZXMgdG8gYmUgcGxheWVkXHJcbiAgICogaW4gb3JkZXIuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9LCBxdWV1ZVN0YXRlcyA9IFtdKSB7XHJcbiAgICBzdXBlcihvcHRpb25zKTtcclxuXHJcbiAgICBxdWV1ZVN0YXRlcy5mb3JFYWNoKHN0YXRlID0+IHtcclxuICAgICAgdGhpcy5hZGRTdGF0ZShzdGF0ZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLl9xdWV1ZSA9IHRoaXMuX3N0YXRlcy5rZXlzKCk7XHJcbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgd2hldGhlciB0aGUgYW5pbWF0aW9uIHF1ZXVlIGhhcyByZWFjaGVkIHRoZSBlbmQuXHJcbiAgICovXHJcbiAgZ2V0IGRvbmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZG9uZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIGludGVybmFsIHdlaWdodC5cclxuICAgKlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IGludGVybmFsV2VpZ2h0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRTdGF0ZVxyXG4gICAgICA/IHRoaXMuX2N1cnJlbnRTdGF0ZS5pbnRlcm5hbFdlaWdodCAqIHRoaXMuX2ludGVybmFsV2VpZ2h0XHJcbiAgICAgIDogMDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc3RhcnQgdGhlIHF1ZXVlIGl0ZXJhdG9yLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfcmVzZXQoKSB7XHJcbiAgICB0aGlzLl9xdWV1ZSA9IHRoaXMuX3N0YXRlcy5rZXlzKCk7XHJcbiAgICBjb25zdCB7dmFsdWUsIGRvbmV9ID0gdGhpcy5fcXVldWUubmV4dCgpO1xyXG4gICAgdGhpcy5fZG9uZSA9IGRvbmU7XHJcblxyXG4gICAgcmV0dXJuIHZhbHVlIHx8IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNdWx0aXBsaWVzIHRoZSB1c2VyIHdlaWdodCBieSBhIGZhY3RvciB0byBkZXRlcm1pbmUgdGhlIGludGVybmFsIHdlaWdodC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmYWN0b3IgLSAwLTEgbXVsdGlwbGllciB0byBhcHBseSB0byB0aGUgdXNlciB3ZWlnaHQuXHJcbiAgICovXHJcbiAgdXBkYXRlSW50ZXJuYWxXZWlnaHQoZmFjdG9yKSB7XHJcbiAgICBzdXBlci51cGRhdGVJbnRlcm5hbFdlaWdodChmYWN0b3IpO1xyXG5cclxuICAgIGlmICh0aGlzLl9jdXJyZW50U3RhdGUpIHtcclxuICAgICAgdGhpcy5fY3VycmVudFN0YXRlLnVwZGF0ZUludGVybmFsV2VpZ2h0KHRoaXMuX2ludGVybmFsV2VpZ2h0KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0IHRoZSBuZXh0IGFuaW1hdGlvbiBpbiB0aGUgcXVldWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25OZXh0IC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBlYWNoIHRpbWUgYW4gYW5pbWF0aW9uIGNvbXBsZXRlc1xyXG4gICAqIGFuZCB0aGUgcXVldWUgbW92ZXMgdG8gdGhlIG5leHQgYW5pbWF0aW9uLlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3dyYXA9ZmFsc2VdIC0gV2hldGhlciBvciBub3QgdG8gc3RhcnQgdGhlIHF1ZXVlIGZyb20gdGhlXHJcbiAgICogYmVnaW5uaW5nIGFnYWluIGlmIHRoZSBlbmQgaGFzIGJlZW4gcmVhY2hlZC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH1cclxuICAgKi9cclxuICBuZXh0KG9uTmV4dCwgd3JhcCA9IGZhbHNlKSB7XHJcbiAgICAvLyBNb3ZlIHRoZSBxdWV1ZSBmb3J3YXJkXHJcbiAgICBjb25zdCB7dmFsdWU6IG5hbWUsIGRvbmV9ID0gdGhpcy5fcXVldWUubmV4dCgpO1xyXG4gICAgdGhpcy5fZG9uZSA9IGRvbmU7XHJcbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcclxuXHJcbiAgICAvLyBUaGUgcXVldWUgaGFzIHJlYWNoZWQgdGhlIGVuZFxyXG4gICAgaWYgKGRvbmUpIHtcclxuICAgICAgLy8gU3RhcnQgdGhlIHF1ZXVlIG92ZXJcclxuICAgICAgaWYgKHdyYXApIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wbGF5KFxyXG4gICAgICAgICAgdGhpcy5fcGxheUNhbGxiYWNrcy5vbkZpbmlzaCxcclxuICAgICAgICAgIHRoaXMuX3BsYXlDYWxsYmFja3Mub25FcnJvcixcclxuICAgICAgICAgIHRoaXMuX3BsYXlDYWxsYmFja3Mub25DYW5jZWwsXHJcbiAgICAgICAgICBvbk5leHRcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIFN0b3AgdGhlIHF1ZXVlXHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHRoaXMuX3Byb21pc2VzLmZpbmlzaC5yZXNvbHZlKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb21pc2VzLmZpbmlzaDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFNpZ25hbCB0aGUgbmV4dCBhbmltYXRpb24gaXMgc3RhcnRpbmdcclxuICAgIGlmICh0eXBlb2Ygb25OZXh0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIGNvbnN0IGxhc3ROYW1lID0gWy4uLnRoaXMuX3N0YXRlcy5rZXlzKCldW3RoaXMuX3N0YXRlcy5zaXplIC0gMV07XHJcbiAgICAgIGNvbnN0IGlzUXVldWVFbmQgPSBuYW1lID09PSBsYXN0TmFtZTtcclxuICAgICAgb25OZXh0KHtcclxuICAgICAgICBuYW1lLFxyXG4gICAgICAgIGNhbkFkdmFuY2U6IHRoaXMuZ2V0U3RhdGUobmFtZSkubG9vcENvdW50ICE9PSBJbmZpbml0eSAmJiAhaXNRdWV1ZUVuZCxcclxuICAgICAgICBpc1F1ZXVlRW5kLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdGFydCB0aGUgbmV4dCBhbmltYXRpb25cclxuICAgIHRoaXMucGxheUFuaW1hdGlvbihcclxuICAgICAgbmFtZSxcclxuICAgICAgdGhpcy5fdHJhbnNpdGlvblRpbWUsXHJcbiAgICAgIHRoaXMuX2Vhc2luZ0ZuLFxyXG4gICAgICAoKSA9PiB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9wYXVzZWQgJiYgIXRoaXMuaXNUcmFuc2l0aW9uaW5nKSB7XHJcbiAgICAgICAgICB0aGlzLm5leHQob25OZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIHRoaXMuX3BsYXlDYWxsYmFja3Mub25FcnJvclxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZXMuZmluaXNoO1xyXG4gIH1cclxuXHJcbiAgcGxheShvbkZpbmlzaCwgb25FcnJvciwgb25DYW5jZWwsIG9uTmV4dCkge1xyXG4gICAgY29uc3QgbmFtZSA9IHRoaXMuX3Jlc2V0KCk7XHJcbiAgICBzdXBlci5wbGF5KG9uRmluaXNoLCBvbkVycm9yLCBvbkNhbmNlbCk7XHJcblxyXG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcclxuICAgICAgdGhpcy5fcHJvbWlzZXMuZmluaXNoLnJlc29sdmUoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIFNpZ25hbCB0aGUgbmV4dCBhbmltYXRpb24gaXMgc3RhcnRpbmdcclxuICAgICAgaWYgKG5hbWUgIT09IHRoaXMuY3VycmVudEFuaW1hdGlvbiAmJiB0eXBlb2Ygb25OZXh0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgY29uc3QgbGFzdE5hbWUgPSBbLi4udGhpcy5fc3RhdGVzLmtleXMoKV1bdGhpcy5fc3RhdGVzLnNpemUgLSAxXTtcclxuICAgICAgICBjb25zdCBpc1F1ZXVlRW5kID0gbmFtZSA9PT0gbGFzdE5hbWU7XHJcbiAgICAgICAgb25OZXh0KHtcclxuICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICBjYW5BZHZhbmNlOiBuYW1lXHJcbiAgICAgICAgICAgID8gdGhpcy5nZXRTdGF0ZShuYW1lKS5sb29wQ291bnQgIT09IEluZmluaXR5ICYmICFpc1F1ZXVlRW5kXHJcbiAgICAgICAgICAgIDogdHJ1ZSxcclxuICAgICAgICAgIGlzUXVldWVFbmQ6ICFuYW1lIHx8IGlzUXVldWVFbmQsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFN0YXJ0IHRoZSBuZXh0IGFuaW1hdGlvblxyXG4gICAgICB0aGlzLnBsYXlBbmltYXRpb24oXHJcbiAgICAgICAgbmFtZSxcclxuICAgICAgICB0aGlzLl9jdXJyZW50U3RhdGUgPyB0aGlzLl90cmFuc2l0aW9uVGltZSA6IDAsXHJcbiAgICAgICAgdGhpcy5fZWFzaW5nRm4sXHJcbiAgICAgICAgKCkgPT4ge1xyXG4gICAgICAgICAgaWYgKCF0aGlzLl9wYXVzZWQgJiYgIXRoaXMuaXNUcmFuc2l0aW9uaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMubmV4dChvbk5leHQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25FcnJvclxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLl9wcm9taXNlcy5maW5pc2g7XHJcbiAgfVxyXG5cclxuICBwYXVzZSgpIHtcclxuICAgIGNvbnN0IHBhdXNlZCA9IHN1cGVyLnBhdXNlKCk7XHJcbiAgICB0aGlzLnBhdXNlQW5pbWF0aW9uKCk7XHJcblxyXG4gICAgcmV0dXJuIHBhdXNlZDtcclxuICB9XHJcblxyXG4gIHJlc3VtZShvbkZpbmlzaCwgb25FcnJvciwgb25DYW5jZWwsIG9uTmV4dCkge1xyXG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucGxheShvbkZpbmlzaCwgb25FcnJvciwgb25DYW5jZWwsIG9uTmV4dCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzdXBlci5yZXN1bWUob25GaW5pc2gsIG9uRXJyb3IsIG9uQ2FuY2VsKTtcclxuXHJcbiAgICAgIHRoaXMucmVzdW1lQW5pbWF0aW9uKFxyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZS5uYW1lLFxyXG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25UaW1lLFxyXG4gICAgICAgIHRoaXMuX2Vhc2luZ0ZuLFxyXG4gICAgICAgICgpID0+IHtcclxuICAgICAgICAgIGlmICghdGhpcy5fcGF1c2VkICYmICF0aGlzLmlzVHJhbnNpdGlvbmluZykge1xyXG4gICAgICAgICAgICB0aGlzLm5leHQob25OZXh0KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uRXJyb3JcclxuICAgICAgKTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLl9wcm9taXNlcy5maW5pc2g7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjYW5jZWwoKSB7XHJcbiAgICBjb25zdCBjYW5jZWxlZCA9IHN1cGVyLmNhbmNlbCgpO1xyXG5cclxuICAgIGlmICh0aGlzLl9jdXJyZW50U3RhdGUpIHtcclxuICAgICAgdGhpcy5fY3VycmVudFN0YXRlLmNhbmNlbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjYW5jZWxlZDtcclxuICB9XHJcblxyXG4gIHN0b3AoKSB7XHJcbiAgICBjb25zdCBzdG9wcGVkID0gc3VwZXIuc3RvcCgpO1xyXG4gICAgdGhpcy5zdG9wQW5pbWF0aW9uKCk7XHJcbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcclxuXHJcbiAgICByZXR1cm4gc3RvcHBlZDtcclxuICB9XHJcblxyXG4gIGRpc2NhcmQoKSB7XHJcbiAgICBzdXBlci5kaXNjYXJkKCk7XHJcblxyXG4gICAgdGhpcy5kaXNjYXJkU3RhdGVzKCk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBRdWV1ZVN0YXRlO1xyXG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXHJcbmltcG9ydCBEZWZlcnJlZCBmcm9tICdjb3JlL0RlZmVycmVkJztcclxuaW1wb3J0IE1hdGhVdGlscyBmcm9tICdjb3JlL01hdGhVdGlscyc7XHJcbmltcG9ydCBBYnN0cmFjdFN0YXRlIGZyb20gJy4vQWJzdHJhY3RTdGF0ZSc7XHJcbmltcG9ydCBTdGF0ZUNvbnRhaW5lckludGVyZmFjZSBmcm9tICcuL1N0YXRlQ29udGFpbmVySW50ZXJmYWNlJztcclxuXHJcbi8qKlxyXG4gKiBCYXNlIGNsYXNzIGZvciBhIHN0YXRlIHRoYXQgYmxlbmRzIGEgY29sbGVjdGlvbiBvZiB7QGxpbmsgQWJzdHJhY3RTdGF0ZX0uXHJcbiAqXHJcbiAqIEBhYnN0cmFjdFxyXG4gKiBAaW1wbGVtZW50cyBTdGF0ZUNvbnRhaW5lckludGVyZmFjZVxyXG4gKi9cclxuY2xhc3MgQWJzdHJhY3RCbGVuZFN0YXRlIGV4dGVuZHMgU3RhdGVDb250YWluZXJJbnRlcmZhY2UuTWl4aW4oQWJzdHJhY3RTdGF0ZSkge1xyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSwgYmxlbmRTdGF0ZXMgPSBbXSwgLi4uYXJncykge1xyXG4gICAgc3VwZXIob3B0aW9ucywgLi4uYXJncyk7XHJcbiAgICBibGVuZFN0YXRlcy5mb3JFYWNoKHN0YXRlID0+IHtcclxuICAgICAgdGhpcy5hZGRTdGF0ZShzdGF0ZSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIHN1bSBvZiBpbnRlcm5hbCB3ZWlnaHRzIG9mIHRoZSBzdWItc3RhdGVzLlxyXG4gICAqXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgaW50ZXJuYWxXZWlnaHQoKSB7XHJcbiAgICBsZXQgYmxlbmRXZWlnaHRzID0gMDtcclxuICAgIHRoaXMuX3N0YXRlcy5mb3JFYWNoKHN0YXRlID0+IHtcclxuICAgICAgYmxlbmRXZWlnaHRzICs9IHN0YXRlLmludGVybmFsV2VpZ2h0O1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gYmxlbmRXZWlnaHRzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgd2VpZ2h0IG9mIGEgc3RhdGUgY29udHJvbGxlZCBieSB0aGUgY29udGFpbmVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBzdGF0ZSB0byByZXR1cm4gdGhlIHdlaWdodCBmcm9tLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge251bWJlcn0gLSBXZWlnaHQgb2YgdGhlIHN0YXRlLlxyXG4gICAqL1xyXG4gIGdldEJsZW5kV2VpZ2h0KG5hbWUpIHtcclxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgbmFtZSBpcyB2YWxpZFxyXG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFN0YXRlKG5hbWUpO1xyXG4gICAgaWYgKHN0YXRlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBDYW5ub3QgZ2V0IHdlaWdodCBvZiBzdGF0ZSAke25hbWV9IGZyb20gQmxlbmRTdGF0ZSAke3RoaXMubmFtZX0uIE5vIHN0YXRlIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN0YXRlLndlaWdodDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIHdlaWdodCBvZiBhIHN0YXRlIGNvbnRyb2xsZWQgYnkgdGhlIGNvbnRhaW5lci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgc3RhdGUgdG8gc2V0IHRoZSB3ZWlnaHQgb2YuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHdlaWdodCAtIFdlaWdodCB2YWx1ZSB0byBzZXQgb24gdGhlIHN0YXRlLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0RlZmVycmVkfVxyXG4gICAqL1xyXG4gIHNldEJsZW5kV2VpZ2h0KG5hbWUsIHdlaWdodCwgc2Vjb25kcyA9IDAsIGVhc2luZ0ZuKSB7XHJcbiAgICAvLyBNYWtlIHN1cmUgdGhlIG5hbWUgaXMgdmFsaWRcclxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRTdGF0ZShuYW1lKTtcclxuXHJcbiAgICBpZiAoc3RhdGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYENhbm5vdCBzZXQgd2VpZ2h0IG9mIHN0YXRlICR7bmFtZX0gZnJvbSBCbGVuZFN0YXRlICR7dGhpcy5uYW1lfS4gTm8gc3RhdGUgZXhpc3RzIHdpdGggdGhpcyBuYW1lLmBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICB3ZWlnaHQgPSBNYXRoVXRpbHMuY2xhbXAod2VpZ2h0KTtcclxuICAgIHJldHVybiBzdGF0ZS5zZXRXZWlnaHQod2VpZ2h0LCBzZWNvbmRzLCBlYXNpbmdGbik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNdWx0aXBsaWVzIHRoZSB3ZWlnaHQgb2YgZWFjaCBzdWItc3RhdGUgYnkgYSBmYWN0b3IgdG8gZGV0ZXJtaW5lIHRoZSBpbnRlcm5hbCB3ZWlnaHQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZmFjdG9yIC0gMC0xIG11bHRpcGxpZXIgdG8gYXBwbHkgdG8gdGhlIHVzZXIgd2VpZ2h0LlxyXG4gICAqL1xyXG4gIHVwZGF0ZUludGVybmFsV2VpZ2h0KGZhY3Rvcikge1xyXG4gICAgc3VwZXIudXBkYXRlSW50ZXJuYWxXZWlnaHQoZmFjdG9yKTtcclxuXHJcbiAgICB0aGlzLl9zdGF0ZXMuZm9yRWFjaChzdGF0ZSA9PiB7XHJcbiAgICAgIHN0YXRlLnVwZGF0ZUludGVybmFsV2VpZ2h0KHRoaXMuX2ludGVybmFsV2VpZ2h0KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIGFueSB2YWx1ZXMgb2YgdGhlIHN1Yi1zdGF0ZXMgdGhhdCBuZWVkIHRvIGJlIGV2YWx1YXRlZCBldmVyeSBmcmFtZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVRpbWUgLSBUaW1lIGluIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgbGFzdCB1cGRhdGUuXHJcbiAgICovXHJcbiAgdXBkYXRlKGRlbHRhVGltZSkge1xyXG4gICAgc3VwZXIudXBkYXRlKGRlbHRhVGltZSk7XHJcblxyXG4gICAgdGhpcy5fc3RhdGVzLmZvckVhY2goc3RhdGUgPT4ge1xyXG4gICAgICBzdGF0ZS51cGRhdGUoZGVsdGFUaW1lKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnQgcGxheWJhY2sgb2YgdGhlIHN1Yi1zdGF0ZXMgZnJvbSB0aGUgYmVnaW5uaW5nLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uRmluaXNoIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHRoZSBzdGF0ZSBmaW5pc2hlcy5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25FcnJvciAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgaWYgdGhlIHN0YXRlIGVuY291bnRlcnNcclxuICAgKiBhbiBlcnJvciBkdXJpbmcgcGxheWJhY2suXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uQ2FuY2VsIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBpZiBwbGF5YmFjayBpcyBjYW5jZWxlZC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH1cclxuICAgKi9cclxuICBwbGF5KG9uRmluaXNoLCBvbkVycm9yLCBvbkNhbmNlbCkge1xyXG4gICAgY29uc3QgcHJvbWlzZXMgPSBbc3VwZXIucGxheSgpXTtcclxuXHJcbiAgICB0aGlzLl9zdGF0ZXMuZm9yRWFjaChzdGF0ZSA9PiB7XHJcbiAgICAgIHByb21pc2VzLnB1c2goc3RhdGUucGxheSgpKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIERlZmVycmVkLmFsbChwcm9taXNlcywgb25GaW5pc2gsIG9uRXJyb3IsIG9uQ2FuY2VsKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhdXNlIHBsYXliYWNrIG9mIHRoZSBzdWItc3RhdGVzLiBUaGlzIHByZXZlbnRzIHBlbmRpbmcgcHJvbWlzZXMgZnJvbSBiZWluZyBleGVjdXRlZC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xyXG4gIHBhdXNlKCkge1xyXG4gICAgdGhpcy5fc3RhdGVzLmZvckVhY2goc3RhdGUgPT4ge1xyXG4gICAgICBzdGF0ZS5wYXVzZSgpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gc3VwZXIucGF1c2UoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc3VtZSBwbGF5YmFjayBvZiB0aGUgc3ViLXN0YXRlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkZpbmlzaCAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgc3RhdGUgZmluaXNoZXMuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uRXJyb3IgLSBGdW5jdGlvbiB0byBleGVjdXRlIGlmIHRoZSBzdGF0ZSBlbmNvdW50ZXJzXHJcbiAgICogYW4gZXJyb3IgZHVyaW5nIHBsYXliYWNrLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkNhbmNlbCAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgaWYgcGxheWJhY2sgaXMgY2FuY2VsZWQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9XHJcbiAgICovXHJcbiAgcmVzdW1lKG9uRmluaXNoLCBvbkVycm9yLCBvbkNhbmNlbCkge1xyXG4gICAgY29uc3QgcHJvbWlzZXMgPSBbc3VwZXIucmVzdW1lKCldO1xyXG5cclxuICAgIHRoaXMuX3N0YXRlcy5mb3JFYWNoKHN0YXRlID0+IHtcclxuICAgICAgcHJvbWlzZXMucHVzaChzdGF0ZS5yZXN1bWUoKSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBEZWZlcnJlZC5hbGwocHJvbWlzZXMsIG9uRmluaXNoLCBvbkVycm9yLCBvbkNhbmNlbCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYW5jZWwgcGxheWJhY2sgb2YgdGhlIHN1Yi1zdGF0ZXMgYW5kIGNhbmNlbCBhbnkgcGVuZGluZyBwcm9taXNlcy5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGNhbmNlbCgpIHtcclxuICAgIHRoaXMuX3N0YXRlcy5mb3JFYWNoKHN0YXRlID0+IHtcclxuICAgICAgc3RhdGUuY2FuY2VsKCk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBzdXBlci5jYW5jZWwoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0b3AgcGxheWJhY2sgb2YgdGhlIHN1Yi1zdGF0ZXMgYW5kIHJlc29sdmUgYW55IHBlbmRpbmcgcHJvbWlzZXMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBzdG9wKCkge1xyXG4gICAgdGhpcy5fc3RhdGVzLmZvckVhY2goc3RhdGUgPT4ge1xyXG4gICAgICBzdGF0ZS5zdG9wKCk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBzdXBlci5zdG9wKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEaXNjYXJkcyBhbGwgc3ViLXN0YXRlIHJlc291cmNlcy5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGRpc2NhcmQoKSB7XHJcbiAgICBzdXBlci5kaXNjYXJkKCk7XHJcblxyXG4gICAgdGhpcy5kaXNjYXJkU3RhdGVzKCk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBBYnN0cmFjdEJsZW5kU3RhdGU7XHJcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcclxuaW1wb3J0IEFic3RyYWN0QmxlbmRTdGF0ZSBmcm9tICcuL0Fic3RyYWN0QmxlbmRTdGF0ZSc7XHJcblxyXG4vKipcclxuICogQ2xhc3MgZm9yIGJsZW5kaW5nIE4gbnVtYmVyIG9mIGJsZW5kIHN0YXRlcy5cclxuICpcclxuICogQGV4dGVuZHMgQWJzdHJhY3RCbGVuZFN0YXRlXHJcbiAqL1xyXG5jbGFzcyBGcmVlQmxlbmRTdGF0ZSBleHRlbmRzIEFic3RyYWN0QmxlbmRTdGF0ZSB7XHJcbiAgLyoqXHJcbiAgICogQGNvbnN0cnVjdG9yXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIC0gT3B0aW9ucyBmb3IgdGhlIGNvbnRhaW5lciBzdGF0ZS5cclxuICAgKiBAcGFyYW0ge0FycmF5LjxBYnN0cmFjdFN0YXRlPn0gW2JsZW5kU3RhdGVzPVtdXSAtIEJsZW5kIHN0YXRlcyB0byBiZSBjb250cm9sbGVkIGJ5XHJcbiAgICogdGhpcyBjb250YWluZXIuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9LCBibGVuZFN0YXRlcyA9IFtdKSB7XHJcbiAgICBzdXBlcihvcHRpb25zLCBibGVuZFN0YXRlcyk7XHJcbiAgfVxyXG5cclxuICB1cGRhdGVJbnRlcm5hbFdlaWdodChmYWN0b3IpIHtcclxuICAgIHN1cGVyLnVwZGF0ZUludGVybmFsV2VpZ2h0KGZhY3Rvcik7XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSB0b3RhbCBhY3RpdmUgd2VpZ2h0IG9mIGJsZW5kIHN0YXRlc1xyXG4gICAgbGV0IHN1bVdlaWdodHMgPSAwO1xyXG5cclxuICAgIHRoaXMuX3N0YXRlcy5mb3JFYWNoKHN0YXRlID0+IHtcclxuICAgICAgc3VtV2VpZ2h0cyArPSBzdGF0ZS53ZWlnaHQ7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBFbnN1cmUgdGhlIHN1bSBvZiBibGVuZCBzdGF0ZSBpbnRlcm5hbCB3ZWlnaHRzIGRvZXMgbm90IGV4Y2VlZCBjb250YWluZXIgaW50ZXJuYWwgd2VpZ2h0XHJcbiAgICBmYWN0b3IgLz0gTWF0aC5tYXgoc3VtV2VpZ2h0cywgMSk7XHJcblxyXG4gICAgLy8gU3VtIG9mIGJsZW5kIHN0YXRlIGludGVybmFsIHdlaWdodHMgc2hvdWxkIG5vdCBleGNlZWQgY29udGFpbmVyIGludGVybmFsIHdlaWdodFxyXG4gICAgdGhpcy5fc3RhdGVzLmZvckVhY2goc3RhdGUgPT4ge1xyXG4gICAgICBzdGF0ZS51cGRhdGVJbnRlcm5hbFdlaWdodChmYWN0b3IgKiB0aGlzLl93ZWlnaHQpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBGcmVlQmxlbmRTdGF0ZTtcclxuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxyXG5pbXBvcnQgRGVmZXJyZWQgZnJvbSAnY29yZS9EZWZlcnJlZCc7XHJcbmltcG9ydCBBYnN0cmFjdEJsZW5kU3RhdGUgZnJvbSAnLi9BYnN0cmFjdEJsZW5kU3RhdGUnO1xyXG5pbXBvcnQgQW5pbWF0aW9uVXRpbHMgZnJvbSAnLi4vQW5pbWF0aW9uVXRpbHMnO1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIGZvciBibGVuZGluZyBOIG51bWJlciBvZiBibGVuZCBzdGF0ZXMgYmFzZWQgb24gYSBzaW5nbGVcclxuICogcGFyYW1ldGVyLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEJsZW5kU3RhdGVcclxuICovXHJcbmNsYXNzIEJsZW5kMWRTdGF0ZSBleHRlbmRzIEFic3RyYWN0QmxlbmRTdGF0ZSB7XHJcbiAgLyoqXHJcbiAgICogQGNvbnN0cnVjdG9yXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucyBmb3IgdGhlIGNvbnRhaW5lciBzdGF0ZVxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPEFic3RyYWN0QmxlbmRTdGF0ZT59IFtibGVuZFN0YXRlcz1bXV0gLSBCbGVuZCBzdGF0ZXMgdG8gYmVcclxuICAgKiBjb250cm9sbGVkIGJ5IHRoaXMgY29udGFpbmVyLlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtibGVuZFRocmVzaG9sZHM9W11dIC0gVGhyZXNob2xkIHZhbHVlcyBmb3IgYWN0aXZhdGluZ1xyXG4gICAqIGVhY2ggYmxlbmQgc3RhdGUuXHJcbiAgICogQHBhcmFtIHtBcnJheS48Ym9vbGVhbj59IFtwaGFzZU1hdGNoZXM9W11dIC0gQm9vbGVhbnMgaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdFxyXG4gICAqIGVhY2ggYmxlbmQgc3RhdGUgc2hvdWxkIGJlIHBoYXNlIG1hdGNoZWQuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBvcHRpb25zID0ge30sXHJcbiAgICBibGVuZFN0YXRlcyA9IFtdLFxyXG4gICAgYmxlbmRUaHJlc2hvbGRzID0gW10sXHJcbiAgICBwaGFzZU1hdGNoZXMgPSBbXVxyXG4gICkge1xyXG4gICAgc3VwZXIob3B0aW9ucywgYmxlbmRTdGF0ZXMpO1xyXG5cclxuICAgIHRoaXMuX2JsZW5kVmFsdWUgPSAwO1xyXG4gICAgdGhpcy5fcHJvbWlzZXMgPSB7XHJcbiAgICAgIC4uLnRoaXMuX3Byb21pc2VzLFxyXG4gICAgICBibGVuZFZhbHVlOiBEZWZlcnJlZC5yZXNvbHZlKCksXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFZhbGlkYXRlIHRoZXJlIGFyZSBubyBkdXBsaWNhdGUgdGhyZXNob2xkc1xyXG4gICAgY29uc3Qgbm9uWmVyb0RpZmZlcmVudFNpemUgPVxyXG4gICAgICBibGVuZFN0YXRlcy5sZW5ndGggIT09IDAgJiYgYmxlbmRTdGF0ZXMubGVuZ3RoICE9PSBibGVuZFRocmVzaG9sZHMubGVuZ3RoO1xyXG4gICAgaWYgKG5vblplcm9EaWZmZXJlbnRTaXplKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgQ2Fubm90IGNyZWF0ZSBCbGVuZDFkU3RhdGUgd2l0aCBibGVuZFRocmVzaG9sZHMgJHtibGVuZFRocmVzaG9sZHN9LiBCbGVuZFRocmVzaG9sZHMgY291bnQgZG9lcyBub3QgbWF0Y2ggYmxlbmRTdGF0ZXMgY291bnQuYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNvbnRhaW5zRHVwbGljYXRlcyA9XHJcbiAgICAgIG5ldyBTZXQoYmxlbmRUaHJlc2hvbGRzKS5zaXplICE9PSBibGVuZFRocmVzaG9sZHMubGVuZ3RoO1xyXG4gICAgaWYgKGNvbnRhaW5zRHVwbGljYXRlcykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYENhbm5vdCBjcmVhdGUgQmxlbmQxZFN0YXRlIHdpdGggYmxlbmRUaHJlc2hvbGRzICR7YmxlbmRUaHJlc2hvbGRzfS4gQmxlbmRUaHJlc2hvbGRzIGNvbnRhaW5zIGR1cGxpY2F0ZSB2YWx1ZXNgXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgdGhyZXNob2xkcyBtYXBcclxuICAgIHRoaXMuX3RocmVzaG9sZHMgPSBbXTtcclxuICAgIFsuLi50aGlzLl9zdGF0ZXMudmFsdWVzKCldLmZvckVhY2goKHN0YXRlLCBpbmRleCkgPT4ge1xyXG4gICAgICB0aGlzLl90aHJlc2hvbGRzLnB1c2goe1xyXG4gICAgICAgIHZhbHVlOiBibGVuZFRocmVzaG9sZHNbaW5kZXhdLFxyXG4gICAgICAgIG5hbWU6IHN0YXRlLm5hbWUsXHJcbiAgICAgICAgcGhhc2VNYXRjaDogcGhhc2VNYXRjaGVzW2luZGV4XSB8fCBmYWxzZSxcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLl9zb3J0VGhyZXNob2xkcygpO1xyXG4gICAgdGhpcy5fZm9yY2VOb1RocmVzaG9sZER1cGVzID0gdHJ1ZTtcclxuXHJcbiAgICB0aGlzLl9waGFzZUxlYWRTdGF0ZSA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5fdXBkYXRlQmxlbmRXZWlnaHRzKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIGFuZCBzZXRzIHRoZSBibGVuZCBwYXJhbWV0ZXIgdmFsdWUuXHJcbiAgICovXHJcbiAgZ2V0IGJsZW5kVmFsdWUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fYmxlbmRWYWx1ZTtcclxuICB9XHJcblxyXG4gIHNldCBibGVuZFZhbHVlKHZhbHVlKSB7XHJcbiAgICB0aGlzLl9ibGVuZFZhbHVlID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHdoZXRoZXIgb3Igbm90IHRoZSBibGVuZCB2YWx1ZSBpcyBjdXJyZW50bHkgYmVpbmcgYW5pbWF0ZWQuXHJcbiAgICovXHJcbiAgZ2V0IGJsZW5kVmFsdWVQZW5kaW5nKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VzLmJsZW5kVmFsdWUgJiYgdGhpcy5fcHJvbWlzZXMuYmxlbmRWYWx1ZS5wZW5kaW5nO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlcyB0aGUgdXNlciBkZWZpbmVkIHdlaWdodCBvdmVyIHRpbWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bGx9IG5hbWUgLSBVbnVzZWQgcGFyYW1ldGVyLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3ZWlnaHQgLSBUaGUgdGFyZ2V0IHdlaWdodCB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NlY29uZHM9MF0gLSBUaGUgYW1vdW50IG9mIHRpbWUgaXQgd2lsbCB0YWtlIHRvIHJlYWNoIHRoZVxyXG4gICAqIHRhcmdldCB3ZWlnaHQuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGVhc2luZ0ZuIC0gVGhlIGVhc2luZyBmdW5jdGlvbiB0byB1c2UgZm9yIGludGVycG9sYXRpb24uXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9XHJcbiAgICovXHJcbiAgc2V0QmxlbmRXZWlnaHQobmFtZSwgdmFsdWUsIHNlY29uZHMgPSAwLCBlYXNpbmdGbikge1xyXG4gICAgdGhpcy5fcHJvbWlzZXMuYmxlbmRWYWx1ZS5jYW5jZWwoKTtcclxuXHJcbiAgICB0aGlzLl9wcm9taXNlcy5ibGVuZFZhbHVlID0gQW5pbWF0aW9uVXRpbHMuaW50ZXJwb2xhdGVQcm9wZXJ0eShcclxuICAgICAgdGhpcyxcclxuICAgICAgJ2JsZW5kVmFsdWUnLFxyXG4gICAgICB2YWx1ZSxcclxuICAgICAge1xyXG4gICAgICAgIHNlY29uZHMsXHJcbiAgICAgICAgZWFzaW5nRm4sXHJcbiAgICAgICAgb25Qcm9ncmVzczogKCkgPT4ge1xyXG4gICAgICAgICAgdGhpcy5fdXBkYXRlQmxlbmRXZWlnaHRzKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkZpbmlzaDogKCkgPT4ge1xyXG4gICAgICAgICAgdGhpcy5fdXBkYXRlQmxlbmRXZWlnaHRzKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgfVxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZXMuYmxlbmRWYWx1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIHVzZXIgZGVmaW5lZCB3ZWlnaHQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldEJsZW5kV2VpZ2h0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuYmxlbmRWYWx1ZTtcclxuICB9XHJcblxyXG4gIGFkZFN0YXRlKHN0YXRlLCB0aHJlc2hvbGRWYWx1ZSA9IDAsIHBoYXNlTWF0Y2ggPSBmYWxzZSkge1xyXG4gICAgdGhpcy5fdGhyZXNob2xkcyA9IHRoaXMuX3RocmVzaG9sZHMgfHwgW107XHJcblxyXG4gICAgLy8gTWFrZSBzdXJlIHRoZXJlIGlzIG5vdCBhbHJlYWR5IGEgc3RhdGUgd2l0aCB0aGlzIHRocmVzaG9sZFxyXG4gICAgY29uc3Qgc2FtZVZhbHVlID0gdGhpcy5fdGhyZXNob2xkcy5maW5kKFxyXG4gICAgICB0aHJlc2hvbGQgPT4gdGhyZXNob2xkLnZhbHVlID09PSB0aHJlc2hvbGRWYWx1ZVxyXG4gICAgKTtcclxuICAgIGlmICh0aGlzLl9mb3JjZU5vVGhyZXNob2xkRHVwZXMgJiYgc2FtZVZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBDYW5ub3Qgc2V0IGJsZW5kIHRocmVzaG9sZCBvZiAke3RocmVzaG9sZFZhbHVlfSBmb3Igc3RhdGUgJHtzdGF0ZS5uYW1lfSBvbiAke3RoaXMubmFtZX0uIEEgc3RhdGUgYWxyZWFkeSBleGlzdHMgd2l0aCB0aGF0IHRocmVzaG9sZC5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgc3VwZXIuYWRkU3RhdGUoc3RhdGUpO1xyXG4gICAgdGhpcy5fdGhyZXNob2xkcy5wdXNoKHtcclxuICAgICAgdmFsdWU6IHRocmVzaG9sZFZhbHVlLFxyXG4gICAgICBuYW1lOiBzdGF0ZS5uYW1lLFxyXG4gICAgICBwaGFzZU1hdGNoOiBwaGFzZU1hdGNoIHx8IGZhbHNlLFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5fc29ydFRocmVzaG9sZHMoKTtcclxuXHJcbiAgICByZXR1cm4gc3RhdGUubmFtZTtcclxuICB9XHJcblxyXG4gIHJlbW92ZVN0YXRlKG5hbWUpIHtcclxuICAgIGNvbnN0IHJlbW92ZWQgPSBzdXBlci5yZW1vdmVTdGF0ZShuYW1lKTtcclxuXHJcbiAgICBpZiAocmVtb3ZlZCkge1xyXG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuX3RocmVzaG9sZHMuZmluZEluZGV4KFxyXG4gICAgICAgIHRocmVzaG9sZCA9PiB0aHJlc2hvbGQubmFtZSA9PT0gbmFtZVxyXG4gICAgICApO1xyXG4gICAgICB0aGlzLl90aHJlc2hvbGRzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlbW92ZWQ7XHJcbiAgfVxyXG5cclxuICByZW5hbWVTdGF0ZShjdXJyZW50TmFtZSwgbmV3TmFtZSkge1xyXG4gICAgbmV3TmFtZSA9IHN1cGVyLnJlbmFtZVN0YXRlKGN1cnJlbnROYW1lLCBuZXdOYW1lKTtcclxuXHJcbiAgICBjb25zdCB0aHJlc2hvbGQgPSB0aGlzLl90aHJlc2hvbGRzLmZpbmQoXHJcbiAgICAgIHRocmVzaG9sZCA9PiB0aHJlc2hvbGQubmFtZSA9PT0gY3VycmVudE5hbWVcclxuICAgICk7XHJcbiAgICB0aHJlc2hvbGQubmFtZSA9IG5ld05hbWU7XHJcblxyXG4gICAgcmV0dXJuIG5ld05hbWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSB0aHJlc2hvbGQgdmFsdWUgb2YgYSBibGVuZCB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIG5hbWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIGJsZW5kIHRvIGdldCB0aGUgdGhyZXNob2xkIG9mLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge251bWJlcn0gVGhyZWhvbGQgdmFsdWUuXHJcbiAgICovXHJcbiAgZ2V0QmxlbmRUaHJlc2hvbGQobmFtZSkge1xyXG4gICAgY29uc3QgdGhyZXNob2xkID0gdGhpcy5fdGhyZXNob2xkcy5maW5kKFxyXG4gICAgICB0aHJlc2hvbGQgPT4gdGhyZXNob2xkLm5hbWUgPT09IG5hbWVcclxuICAgICk7XHJcblxyXG4gICAgaWYgKHRocmVzaG9sZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgQ2Fubm90IGdldCBibGVuZCB0aHJlc2hvbGQgb2Ygc3RhdGUgJHtuYW1lfSBvbiAke3RoaXMubmFtZX0uIE5vIHN0YXRlIGV4aXN0cyB3aXRoIHRoYXQgbmFtZS5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRocmVzaG9sZC52YWx1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIHRocmVzaG9sZCB2YWx1ZSBvZiBhIGJsZW5kIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgbmFtZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgYmxlbmQgdG8gc2V0IHRoZSB0aHJlc2hvbGQuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVmFsdWUgb2YgdGhlIHRocmVzaG9sZCB0byBzZXQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBTZXQgdGhyZXNob2xkIHZhbHVlLlxyXG4gICAqL1xyXG4gIHNldEJsZW5kVGhyZXNob2xkKG5hbWUsIHZhbHVlKSB7XHJcbiAgICAvLyBNYWtlIHN1cmUgdGhlcmUgaXMgbm90IGFscmVhZHkgYSBzdGF0ZSB3aXRoIHRoaXMgdGhyZXNob2xkXHJcbiAgICBjb25zdCBzYW1lVmFsdWUgPSB0aGlzLl90aHJlc2hvbGRzLmZpbmQoXHJcbiAgICAgIHRocmVzaG9sZCA9PiB0aHJlc2hvbGQudmFsdWUgPT09IHZhbHVlXHJcbiAgICApO1xyXG4gICAgaWYgKHNhbWVWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgQ2Fubm90IHNldCBibGVuZCB0aHJlc2hvbGQgb2YgJHt2YWx1ZX0gZm9yIHN0YXRlICR7bmFtZX0gb24gJHt0aGlzLm5hbWV9LiBBIHN0YXRlIGFscmVhZHkgZXhpc3RzIHdpdGggdGhhdCB0aHJlc2hvbGQuYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHRocmVzaG9sZCA9IHRoaXMuX3RocmVzaG9sZHMuZmluZChcclxuICAgICAgdGhyZXNob2xkID0+IHRocmVzaG9sZC5uYW1lID09PSBuYW1lXHJcbiAgICApO1xyXG5cclxuICAgIGlmICh0aHJlc2hvbGQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYENhbm5vdCBzZXQgYmxlbmQgdGhyZXNob2xkIG9mIHN0YXRlICR7bmFtZX0gb24gJHt0aGlzLm5hbWV9LiBObyBzdGF0ZSBleGlzdHMgd2l0aCB0aGF0IG5hbWUuYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHRocmVzaG9sZC52YWx1ZSA9IHZhbHVlO1xyXG5cclxuICAgIHRoaXMuX3NvcnRUaHJlc2hvbGRzKCk7XHJcblxyXG4gICAgcmV0dXJuIHRocmVzaG9sZC52YWx1ZTtcclxuICB9XHJcblxyXG4gIHVwZGF0ZUludGVybmFsV2VpZ2h0KGZhY3Rvcikge1xyXG4gICAgc3VwZXIudXBkYXRlSW50ZXJuYWxXZWlnaHQoZmFjdG9yKTtcclxuXHJcbiAgICBpZiAodGhpcy5fcGhhc2VMZWFkU3RhdGUpIHtcclxuICAgICAgdGhpcy5fc3RhdGVzLmZvckVhY2goc3RhdGUgPT4ge1xyXG4gICAgICAgIGlmIChzdGF0ZS53ZWlnaHQgIT09IDApIHtcclxuICAgICAgICAgIHN0YXRlLm5vcm1hbGl6ZWRUaW1lID0gdGhpcy5fcGhhc2VMZWFkU3RhdGUubm9ybWFsaXplZFRpbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgdGhlIGJsZW5kIHdlaWdodHMgYmFzZWQgb24gdGhlaXIgY29ycmVzcG9uZGluZyB0aHJlc2hvbGQgdmFsdWVzXHJcbiAgICogYW5kIHRoZSBjdXJyZW50IGJsZW5kVmFsdWUuIEFkZGl0aW9uYWxseSwgc2V0cyBhIGxlYWQgcGhhc2Ugc3RhdGUgaWYgdGhlXHJcbiAgICogY29uZGl0aW9ucyBmb3IgcGhhc2UtbWF0Y2hpbmcgaGF2ZSBiZWVuIHNhdGlzZmllZC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX3VwZGF0ZUJsZW5kV2VpZ2h0cygpIHtcclxuICAgIGlmICh0aGlzLl90aHJlc2hvbGRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xyXG5cclxuICAgIGlmICh0aGlzLl90aHJlc2hvbGRzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlcy5nZXQodGhpcy5fdGhyZXNob2xkc1swXS5uYW1lKTtcclxuICAgICAgc3RhdGUuc2V0V2VpZ2h0KDEpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSW5pdGlhbGx5IHNldCBhbGwgc3ViLXN0YXRlIHdlaWdodHMgdG8gemVyb1xyXG4gICAgdGhpcy5fc3RhdGVzLmZvckVhY2goc3RhdGUgPT4ge1xyXG4gICAgICBzdGF0ZS5zZXRXZWlnaHQoMCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLl9waGFzZUxlYWRTdGF0ZSA9IG51bGw7XHJcblxyXG4gICAgLy8gRmluZCB0aGUgZmlyc3QgdGhyZXNob2xkIHRoYXQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwYXJhbWV0ZXIgdmFsdWVcclxuICAgIGxldCB0YXJnZXRJbmRleCA9IHRoaXMuX3RocmVzaG9sZHMuZmluZEluZGV4KHRocmVzaG9sZCA9PiB7XHJcbiAgICAgIHJldHVybiB0aHJlc2hvbGQudmFsdWUgPj0gdGhpcy5fYmxlbmRWYWx1ZTtcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICh0YXJnZXRJbmRleCA9PT0gMCB8fCB0YXJnZXRJbmRleCA9PT0gLTEpIHtcclxuICAgICAgLy8gR2l2ZSBvbmUgc3RhdGUgZnVsbCBpbmZsdWVuY2VcclxuICAgICAgdGFyZ2V0SW5kZXggPSB0YXJnZXRJbmRleCA9PT0gLTEgPyB0aGlzLl90aHJlc2hvbGRzLmxlbmd0aCAtIDEgOiAwO1xyXG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlcy5nZXQodGhpcy5fdGhyZXNob2xkc1t0YXJnZXRJbmRleF0ubmFtZSk7XHJcbiAgICAgIHN0YXRlLnNldFdlaWdodCgxKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIExpbmVhciBpbnRlcnBvbGF0ZSBpbmZsdWVuY2UgYmV0d2VlbiB0d28gc3RhdGVzXHJcbiAgICAgIGNvbnN0IHRocmVzaG9sZEEgPSB0aGlzLl90aHJlc2hvbGRzW3RhcmdldEluZGV4IC0gMV07XHJcbiAgICAgIGNvbnN0IHRocmVzaG9sZEIgPSB0aGlzLl90aHJlc2hvbGRzW3RhcmdldEluZGV4XTtcclxuXHJcbiAgICAgIGNvbnN0IGZhY3RvckIgPVxyXG4gICAgICAgICh0aGlzLmJsZW5kVmFsdWUgLSB0aHJlc2hvbGRBLnZhbHVlKSAvXHJcbiAgICAgICAgKHRocmVzaG9sZEIudmFsdWUgLSB0aHJlc2hvbGRBLnZhbHVlKTtcclxuICAgICAgY29uc3QgZmFjdG9yQSA9IDEgLSBmYWN0b3JCO1xyXG5cclxuICAgICAgY29uc3Qgc3RhdGVBID0gdGhpcy5fc3RhdGVzLmdldCh0aHJlc2hvbGRBLm5hbWUpO1xyXG4gICAgICBjb25zdCBzdGF0ZUIgPSB0aGlzLl9zdGF0ZXMuZ2V0KHRocmVzaG9sZEIubmFtZSk7XHJcblxyXG4gICAgICBzdGF0ZUEuc2V0V2VpZ2h0KGZhY3RvckEpO1xyXG4gICAgICBzdGF0ZUIuc2V0V2VpZ2h0KGZhY3RvckIpO1xyXG5cclxuICAgICAgLy8gU2V0IHBoYXNlLW1hdGNoaW5nIGlmIG5lZWRlZFxyXG4gICAgICBpZiAodGhyZXNob2xkQS5waGFzZU1hdGNoICYmIHRocmVzaG9sZEIucGhhc2VNYXRjaCkge1xyXG4gICAgICAgIHRoaXMuX3BoYXNlTGVhZFN0YXRlID0gZmFjdG9yQSA+IGZhY3RvckIgPyBzdGF0ZUEgOiBzdGF0ZUI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNvcnRzIHRoZSB0aHJlc2hvbGRzIGZyb20gbG93IHRvIGhpZ2ggYmFzZWQgb24gdmFsdWUuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9zb3J0VGhyZXNob2xkcygpIHtcclxuICAgIHRoaXMuX3RocmVzaG9sZHMuc29ydCgoYSwgYikgPT4gYS52YWx1ZSAtIGIudmFsdWUpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQmxlbmQxZFN0YXRlO1xyXG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVyc2NvcmUtZGFuZ2xlICovXHJcbmltcG9ydCBEZWZlcnJlZCBmcm9tICdjb3JlL0RlZmVycmVkJztcclxuaW1wb3J0IE1hdGhVdGlscyBmcm9tICdjb3JlL01hdGhVdGlscyc7XHJcbmltcG9ydCBBYnN0cmFjdEJsZW5kU3RhdGUgZnJvbSAnLi9BYnN0cmFjdEJsZW5kU3RhdGUnO1xyXG5pbXBvcnQgQW5pbWF0aW9uVXRpbHMgZnJvbSAnLi4vQW5pbWF0aW9uVXRpbHMnO1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIGZvciBibGVuZGluZyBOIG51bWJlciBvZiBibGVuZCBzdGF0ZXMgYmFzZWQgb24gdHdvXHJcbiAqIHBhcmFtdGVycy5cclxuICpcclxuICogQGV4dGVuZHMgQWJzdHJhY3RCbGVuZFN0YXRlXHJcbiAqL1xyXG5jbGFzcyBCbGVuZDJkU3RhdGUgZXh0ZW5kcyBBYnN0cmFjdEJsZW5kU3RhdGUge1xyXG4gIC8qKlxyXG4gICAqIEBjb25zdHJ1Y3RvclxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMgZm9yIHRoZSBjb250YWluZXIgc3RhdGVcclxuICAgKiBAcGFyYW0ge0FycmF5LjxBYnN0cmFjdEJsZW5kU3RhdGU+fSBbYmxlbmRTdGF0ZXM9W11dIC0gQmxlbmQgc3RhdGVzIHRvIGJlXHJcbiAgICogY29udHJvbGxlZCBieSB0aGlzIGNvbnRhaW5lci5cclxuICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IFtibGVuZFRocmVzaG9sZHM9W11dIC0gVGhyZXNob2xkIHZhbHVlcyBmb3IgYWN0aXZhdGluZ1xyXG4gICAqIGVhY2ggYmxlbmQgc3RhdGUuXHJcbiAgICogQHBhcmFtIHtBcnJheS48Ym9vbGVhbj59IFtwaGFzZU1hdGNoZXM9W11dIC0gQm9vbGVhbnMgaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdFxyXG4gICAqIGVhY2ggYmxlbmQgc3RhdGUgc2hvdWxkIGJlIHBoYXNlIG1hdGNoZWQuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBvcHRpb25zID0ge30sXHJcbiAgICBibGVuZFN0YXRlcyA9IFtdLFxyXG4gICAgYmxlbmRUaHJlc2hvbGRzID0gW10sXHJcbiAgICBwaGFzZU1hdGNoZXMgPSBbXVxyXG4gICkge1xyXG4gICAgc3VwZXIob3B0aW9ucywgYmxlbmRTdGF0ZXMpO1xyXG5cclxuICAgIGlmIChibGVuZFN0YXRlcy5sZW5ndGggIT09IGJsZW5kVGhyZXNob2xkcy5sZW5ndGgpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBDYW5ub3QgY3JlYXRlIEJsZW5kMmRTdGF0ZSB3aXRoIGJsZW5kU3RhdGVzICR7YmxlbmRTdGF0ZXN9IGFuZCBibGVuZFRocmVzaG9sZHMgJHtibGVuZFRocmVzaG9sZHN9LiBDb3VudCBvZiBibGVuZFN0YXRlcyBtdXN0IG1hdGNoIGNvdW50IG9mIGJsZW5kVGhyZXNob2xkcy5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgYmxlbmRUaHJlc2hvbGRzXHJcbiAgICAgIC5zbGljZSgwLCBibGVuZFRocmVzaG9sZHMubGVuZ3RoIC0gMSlcclxuICAgICAgLmZvckVhY2goKHRocmVzaG9sZCwgaW5kZXgpID0+IHtcclxuICAgICAgICBibGVuZFRocmVzaG9sZHMuc2xpY2UoaW5kZXggKyAxKS5mb3JFYWNoKG90aGVyVGhyZXNob2xkID0+IHtcclxuICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgdGhyZXNob2xkWzBdID09PSBvdGhlclRocmVzaG9sZFswXSAmJlxyXG4gICAgICAgICAgICB0aHJlc2hvbGRbMV0gPT09IG90aGVyVGhyZXNob2xkWzFdXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAgIGBDYW5ub3QgY3JlYXRlIEJsZW5kMmRTdGF0ZSB3aXRoIGJsZW5kVGhyZXNob2xkcyAke2JsZW5kVGhyZXNob2xkc30uIE5vIGR1cGxpY2F0ZSB2YWx1ZXMgYWxsb3dlZCBpbiBibGVuZFRocmVzaG9sZHMuYFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICB0aGlzLl9ibGVuZFZhbHVlWCA9IDA7XHJcbiAgICB0aGlzLl9ibGVuZFZhbHVlWSA9IDA7XHJcblxyXG4gICAgdGhpcy5fcHJvbWlzZXMgPSB7XHJcbiAgICAgIC4uLnRoaXMuX3Byb21pc2VzLFxyXG4gICAgICBibGVuZFZhbHVlWDogRGVmZXJyZWQucmVzb2x2ZSgpLFxyXG4gICAgICBibGVuZFZhbHVlWTogRGVmZXJyZWQucmVzb2x2ZSgpLFxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLl90aHJlc2hvbGRzID0gW107XHJcbiAgICBbLi4udGhpcy5fc3RhdGVzLnZhbHVlcygpXS5mb3JFYWNoKChzdGF0ZSwgaW5kZXgpID0+IHtcclxuICAgICAgdGhpcy5fdGhyZXNob2xkcy5wdXNoKHtcclxuICAgICAgICBuYW1lOiBzdGF0ZS5uYW1lLFxyXG4gICAgICAgIHBoYXNlTWF0Y2g6IHBoYXNlTWF0Y2hlc1tpbmRleF0gfHwgZmFsc2UsXHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5fdmVydGljZXMgPSBibGVuZFRocmVzaG9sZHM7XHJcblxyXG4gICAgaWYgKHRoaXMuX3ZlcnRpY2VzLmxlbmd0aCA+PSAzKSB7XHJcbiAgICAgIHRoaXMuX3RyaWFuZ2xlcyA9IE1hdGhVdGlscy5nZXREZWxhdW5heVRyaWFuZ3VsYXRpb24odGhpcy5fdmVydGljZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3BoYXNlTGVhZFN0YXRlID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLl91cGRhdGVCbGVuZFdlaWdodHMoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgdGhlIHVzZXIgZGVmaW5lZCB3ZWlnaHQgb3ZlciB0aW1lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIGJsZW5kIHdlaWdodCB0byB1cGRhdGUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHdlaWdodCAtIFRhcmdldCB3ZWlnaHQgdmFsdWUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzZWNvbmRzPTBdIC0gVGhlIGFtb3VudCBvZiB0aW1lIGl0IHdpbGwgdGFrZSB0byByZWFjaCB0aGVcclxuICAgKiB0YXJnZXQgdmFsdWUuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGVhc2luZ0ZuIC0gVGhlIGVhc2luZyBmdW5jdGlvbiB0byB1c2UgZm9yIGludGVycG9sYXRpb24uXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9XHJcbiAgICovXHJcbiAgc2V0QmxlbmRXZWlnaHQobmFtZSwgdmFsdWUsIHNlY29uZHMgPSAwLCBlYXNpbmdGbikge1xyXG4gICAgY29uc3QgcHJvcGVydHkgPSBgYmxlbmRWYWx1ZSR7bmFtZS50b1VwcGVyQ2FzZSgpfWA7XHJcbiAgICBpZiAocHJvcGVydHkgIT09ICdibGVuZFZhbHVlWCcgJiYgcHJvcGVydHkgIT09ICdibGVuZFZhbHVlWScpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBDYW5ub3Qgc2V0IGJsZW5kIHdlaWdodCBmb3IgJHtuYW1lfSBvbiAke3RoaXMubmFtZX0uIEJsZW5kMmRTdGF0ZSBvbmx5IGFjY2VwdHMgJ1gnIG9yICdZJyBmb3Igc2V0QmxlbmRXZWlnaHRgXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fcHJvbWlzZXNbcHJvcGVydHldLmNhbmNlbCgpO1xyXG5cclxuICAgIHRoaXMuX3Byb21pc2VzW3Byb3BlcnR5XSA9IEFuaW1hdGlvblV0aWxzLmludGVycG9sYXRlUHJvcGVydHkoXHJcbiAgICAgIHRoaXMsXHJcbiAgICAgIHByb3BlcnR5LFxyXG4gICAgICB2YWx1ZSxcclxuICAgICAge1xyXG4gICAgICAgIHNlY29uZHMsXHJcbiAgICAgICAgZWFzaW5nRm4sXHJcbiAgICAgICAgb25Qcm9ncmVzczogKCkgPT4ge1xyXG4gICAgICAgICAgdGhpcy5fdXBkYXRlQmxlbmRXZWlnaHRzKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkZpbmlzaDogKCkgPT4ge1xyXG4gICAgICAgICAgdGhpcy5fdXBkYXRlQmxlbmRXZWlnaHRzKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgfVxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZXNbcHJvcGVydHldO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgdXNlciBkZWZpbmVkIHdlaWdodC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBvZiBibGVuZCB3ZWlnaHQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldEJsZW5kV2VpZ2h0KG5hbWUpIHtcclxuICAgIGNvbnN0IHByb3BlcnR5ID0gbmFtZS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgaWYgKHByb3BlcnR5ICE9PSAnWCcgJiYgcHJvcGVydHkgIT09ICdZJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYENhbm5vdCBnZXQgYmxlbmQgd2VpZ2h0IGZvciAke25hbWV9IG9uICR7dGhpcy5uYW1lfS4gQmxlbmQyZFN0YXRlIG9ubHkgYWNjZXB0cyAnWCcgb3IgJ1knIGZvciBnZXRCbGVuZFdlaWdodGBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcHJvcGVydHkgPT09ICdYJyA/IHRoaXMuX2JsZW5kVmFsdWVYIDogdGhpcy5fYmxlbmRWYWx1ZVk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIGFuZCBzZXRzIHRoZSB4IGJsZW5kIHdlaWdodC5cclxuICAgKi9cclxuICBnZXQgYmxlbmRWYWx1ZVgoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fYmxlbmRWYWx1ZVg7XHJcbiAgfVxyXG5cclxuICBzZXQgYmxlbmRWYWx1ZVgodmFsdWUpIHtcclxuICAgIHRoaXMuX2JsZW5kVmFsdWVYID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIGFuZCBzZXRzIHRoZSB5IGJsZW5kIHdlaWdodC5cclxuICAgKi9cclxuICBnZXQgYmxlbmRWYWx1ZVkoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fYmxlbmRWYWx1ZVk7XHJcbiAgfVxyXG5cclxuICBzZXQgYmxlbmRWYWx1ZVkodmFsdWUpIHtcclxuICAgIHRoaXMuX2JsZW5kVmFsdWVZID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHdoZXRoZXIgb3Igbm90IHRoZSB4IGJsZW5kIHZhbHVlIGlzIGN1cnJlbnRseSBiZWluZyBhbmltYXRlZC5cclxuICAgKi9cclxuICBnZXQgYmxlbmRWYWx1ZVhQZW5kaW5nKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VzLmJsZW5kVmFsdWVYICYmIHRoaXMuX3Byb21pc2VzLmJsZW5kVmFsdWVYLnBlbmRpbmc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHdoZXRoZXIgb3Igbm90IHRoZSB5IGJsZW5kIHZhbHVlIGlzIGN1cnJlbnRseSBiZWluZyBhbmltYXRlZC5cclxuICAgKi9cclxuICBnZXQgYmxlbmRWYWx1ZVlQZW5kaW5nKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VzLmJsZW5kVmFsdWVZICYmIHRoaXMuX3Byb21pc2VzLmJsZW5kVmFsdWVZLnBlbmRpbmc7XHJcbiAgfVxyXG5cclxuICB1cGRhdGVJbnRlcm5hbFdlaWdodChmYWN0b3IpIHtcclxuICAgIHN1cGVyLnVwZGF0ZUludGVybmFsV2VpZ2h0KGZhY3Rvcik7XHJcblxyXG4gICAgaWYgKHRoaXMuX3BoYXNlTGVhZFN0YXRlKSB7XHJcbiAgICAgIFsuLi50aGlzLl9zdGF0ZXMudmFsdWVzKCldLmZvckVhY2goKHN0YXRlLCBpbmRleCkgPT4ge1xyXG4gICAgICAgIGlmIChzdGF0ZS53ZWlnaHQgIT09IDAgJiYgdGhpcy5fdGhyZXNob2xkc1tpbmRleF0ucGhhc2VNYXRjaCkge1xyXG4gICAgICAgICAgc3RhdGUubm9ybWFsaXplZFRpbWUgPSB0aGlzLl9waGFzZUxlYWRTdGF0ZS5ub3JtYWxpemVkVGltZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlcyB0aGUgYmxlbmQgd2VpZ2h0cyBiYXNlZCBvbiB0aGVpciBjb3JyZXNwb25kaW5nIHRocmVzaG9sZCB2YWx1ZXNcclxuICAgKiBhbmQgdGhlIGN1cnJlbnQgW3gseV0gYmxlbmRWYWx1ZS4gQWRkaXRpb25hbGx5LCBzZXRzIGEgbGVhZCBwaGFzZSBzdGF0ZSBpZiB0aGVcclxuICAgKiBjb25kaXRpb25zIGZvciBwaGFzZS1tYXRjaGluZyBoYXZlIGJlZW4gc2F0aXNmaWVkLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfdXBkYXRlQmxlbmRXZWlnaHRzKCkge1xyXG4gICAgaWYgKCF0aGlzLl92ZXJ0aWNlcyB8fCB0aGlzLl92ZXJ0aWNlcy5sZW5ndGggPT09IDApIHJldHVybjtcclxuXHJcbiAgICBpZiAodGhpcy5fdmVydGljZXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgIFsuLi50aGlzLl9zdGF0ZXMudmFsdWVzKCldWzBdLndlaWdodCA9IDE7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJbml0aWFsbHkgc2V0IGFsbCBzdWItc3RhdGUgd2VpZ2h0cyB0byB6ZXJvXHJcbiAgICB0aGlzLl9zdGF0ZXMuZm9yRWFjaChzdGF0ZSA9PiB7XHJcbiAgICAgIHN0YXRlLnNldFdlaWdodCgwKTtcclxuICAgIH0pO1xyXG4gICAgdGhpcy5fcGhhc2VMZWFkU3RhdGUgPSBudWxsO1xyXG5cclxuICAgIGNvbnN0IHAgPSBbdGhpcy5fYmxlbmRWYWx1ZVgsIHRoaXMuX2JsZW5kVmFsdWVZXTtcclxuXHJcbiAgICBpZiAodGhpcy5fdmVydGljZXMubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgIHRoaXMuX3NldEluZmx1ZW5jZUNsb3Nlc3RQb2ludE9uTGluZShwKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IHRyaWFuZ2xlID0gdGhpcy5fdHJpYW5nbGVzLmZpbmQodHJpYW5nbGUgPT4ge1xyXG4gICAgICAgIHJldHVybiBNYXRoVXRpbHMuaXNQb2ludEluVHJpYW5nbGUoXHJcbiAgICAgICAgICB0aGlzLl92ZXJ0aWNlc1t0cmlhbmdsZVswXV0sXHJcbiAgICAgICAgICB0aGlzLl92ZXJ0aWNlc1t0cmlhbmdsZVsxXV0sXHJcbiAgICAgICAgICB0aGlzLl92ZXJ0aWNlc1t0cmlhbmdsZVsyXV0sXHJcbiAgICAgICAgICBwXHJcbiAgICAgICAgKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAodHJpYW5nbGUpIHtcclxuICAgICAgICB0aGlzLl9zZXRJbmZsdWVuY2VUcmlhbmdsZSh0cmlhbmdsZSwgcCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5fc2V0SW5mbHVlbmNlQ2xvc2VzdFBvaW50SW5UcmlhbmdsZXMocCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgYmxlbmQgd2VpZ2h0cyBmb3Igc3RhdGVzIGNvcnJlc3BvbmRpbmcgdG8gYVxyXG4gICAqIHRyaWFuZ2xlIG9mIHRocmVzaG9sZHMgYW5kIGEgZ2l2ZW4gW3gseV0gYmxlbmRWYWx1ZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IHRyaWFuZ2xlIC0gU2V0IG9mIHRyaWFuZ2x1YXRlZCBpbmRpY2VzXHJcbiAgICogdGhhdCBjb3JyZXNwb25kIHRvIGJsZW5kIHRocmVzaG9sZHMuXHJcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcCAtIEdpdmVuIFt4LHldIGJsZW5kVmFsdWUuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9zZXRJbmZsdWVuY2VUcmlhbmdsZSh0cmlhbmdsZSwgcCkge1xyXG4gICAgY29uc3QgYXJlYUEgPSBNYXRoVXRpbHMudHJpYW5nbGVBcmVhKFxyXG4gICAgICB0aGlzLl92ZXJ0aWNlc1t0cmlhbmdsZVsxXV0sXHJcbiAgICAgIHRoaXMuX3ZlcnRpY2VzW3RyaWFuZ2xlWzJdXSxcclxuICAgICAgcFxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBhcmVhQiA9IE1hdGhVdGlscy50cmlhbmdsZUFyZWEoXHJcbiAgICAgIHRoaXMuX3ZlcnRpY2VzW3RyaWFuZ2xlWzBdXSxcclxuICAgICAgdGhpcy5fdmVydGljZXNbdHJpYW5nbGVbMl1dLFxyXG4gICAgICBwXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IGFyZWFDID0gTWF0aFV0aWxzLnRyaWFuZ2xlQXJlYShcclxuICAgICAgdGhpcy5fdmVydGljZXNbdHJpYW5nbGVbMF1dLFxyXG4gICAgICB0aGlzLl92ZXJ0aWNlc1t0cmlhbmdsZVsxXV0sXHJcbiAgICAgIHBcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgdG90YWxBcmVhID0gYXJlYUEgKyBhcmVhQiArIGFyZWFDO1xyXG5cclxuICAgIGNvbnN0IHdlaWdodEEgPSBhcmVhQSAvIHRvdGFsQXJlYTtcclxuICAgIGNvbnN0IHdlaWdodEIgPSBhcmVhQiAvIHRvdGFsQXJlYTtcclxuICAgIGNvbnN0IHdlaWdodEMgPSBhcmVhQyAvIHRvdGFsQXJlYTtcclxuXHJcbiAgICBjb25zdCB0aHJlc2hvbGRBID0gdGhpcy5fdGhyZXNob2xkc1t0cmlhbmdsZVswXV07XHJcbiAgICBjb25zdCB0aHJlc2hvbGRCID0gdGhpcy5fdGhyZXNob2xkc1t0cmlhbmdsZVsxXV07XHJcbiAgICBjb25zdCB0aHJlc2hvbGRDID0gdGhpcy5fdGhyZXNob2xkc1t0cmlhbmdsZVsyXV07XHJcblxyXG4gICAgY29uc3Qgc3RhdGVBID0gdGhpcy5fc3RhdGVzLmdldCh0aHJlc2hvbGRBLm5hbWUpO1xyXG4gICAgY29uc3Qgc3RhdGVCID0gdGhpcy5fc3RhdGVzLmdldCh0aHJlc2hvbGRCLm5hbWUpO1xyXG4gICAgY29uc3Qgc3RhdGVDID0gdGhpcy5fc3RhdGVzLmdldCh0aHJlc2hvbGRDLm5hbWUpO1xyXG5cclxuICAgIHN0YXRlQS5zZXRXZWlnaHQod2VpZ2h0QSk7XHJcbiAgICBzdGF0ZUIuc2V0V2VpZ2h0KHdlaWdodEIpO1xyXG4gICAgc3RhdGVDLnNldFdlaWdodCh3ZWlnaHRDKTtcclxuXHJcbiAgICB0aGlzLl9zZXRQaGFzZUxlYWRTdGF0ZShcclxuICAgICAgW3N0YXRlQSwgc3RhdGVCLCBzdGF0ZUNdLFxyXG4gICAgICBbdGhyZXNob2xkQS5waGFzZU1hdGNoLCB0aHJlc2hvbGRCLnBoYXNlTWF0Y2gsIHRocmVzaG9sZEMucGhhc2VNYXRjaF1cclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRlcm1pbmVzIHRoZSBjbG9zZXN0IHBvaW50IHdpdGhpbiBhIHRyaWFuZ2xlIG9mXHJcbiAgICogdGhyZXNob2xkcyBiYXNlZCBvbiB0aGUgY3VycmVudCBbeCx5XSBibGVuZFZhbHVlcyBhbmRcclxuICAgKiB0aGVuIHNldHMgYmxlbmQgd2VpZ2h0cyBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgc3RhdGVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcCAtIEdpdmVuIFt4LHldIGJsZW5kVmFsdWUuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9zZXRJbmZsdWVuY2VDbG9zZXN0UG9pbnRJblRyaWFuZ2xlcyhwKSB7XHJcbiAgICBsZXQgZ2xvYmFsQ2xvc2VzdFBvaW50ID0gbnVsbDtcclxuICAgIGxldCBnbG9iYWxNaW5EaXN0ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG4gICAgbGV0IGNsb3Nlc3RUcmlhbmdsZSA9IC0xO1xyXG5cclxuICAgIHRoaXMuX3RyaWFuZ2xlcy5mb3JFYWNoKCh0cmlhbmdsZSwgaW5kZXgpID0+IHtcclxuICAgICAgY29uc3QgcG9pbnRBID0gTWF0aFV0aWxzLmNsb3Nlc3RQb2ludE9uTGluZShcclxuICAgICAgICB0aGlzLl92ZXJ0aWNlc1t0cmlhbmdsZVswXV0sXHJcbiAgICAgICAgdGhpcy5fdmVydGljZXNbdHJpYW5nbGVbMV1dLFxyXG4gICAgICAgIHBcclxuICAgICAgKTtcclxuICAgICAgY29uc3QgcG9pbnRCID0gTWF0aFV0aWxzLmNsb3Nlc3RQb2ludE9uTGluZShcclxuICAgICAgICB0aGlzLl92ZXJ0aWNlc1t0cmlhbmdsZVsxXV0sXHJcbiAgICAgICAgdGhpcy5fdmVydGljZXNbdHJpYW5nbGVbMl1dLFxyXG4gICAgICAgIHBcclxuICAgICAgKTtcclxuICAgICAgY29uc3QgcG9pbnRDID0gTWF0aFV0aWxzLmNsb3Nlc3RQb2ludE9uTGluZShcclxuICAgICAgICB0aGlzLl92ZXJ0aWNlc1t0cmlhbmdsZVsyXV0sXHJcbiAgICAgICAgdGhpcy5fdmVydGljZXNbdHJpYW5nbGVbMF1dLFxyXG4gICAgICAgIHBcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGNvbnN0IGRpc3RBID0gTWF0aFV0aWxzLmRpc3RhbmNlU3F1YXJlZChwb2ludEEsIHApO1xyXG4gICAgICBjb25zdCBkaXN0QiA9IE1hdGhVdGlscy5kaXN0YW5jZVNxdWFyZWQocG9pbnRCLCBwKTtcclxuICAgICAgY29uc3QgZGlzdEMgPSBNYXRoVXRpbHMuZGlzdGFuY2VTcXVhcmVkKHBvaW50QywgcCk7XHJcblxyXG4gICAgICBsZXQgbG9jYWxDbG9zZXN0UG9pbnQgPSBwb2ludEM7XHJcbiAgICAgIGxldCBsb2NhbE1pbkRpc3QgPSBkaXN0QztcclxuXHJcbiAgICAgIGlmIChkaXN0QSA8IGxvY2FsTWluRGlzdCkge1xyXG4gICAgICAgIGxvY2FsQ2xvc2VzdFBvaW50ID0gcG9pbnRBO1xyXG4gICAgICAgIGxvY2FsTWluRGlzdCA9IGRpc3RBO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChkaXN0QiA8IGxvY2FsTWluRGlzdCkge1xyXG4gICAgICAgIGxvY2FsQ2xvc2VzdFBvaW50ID0gcG9pbnRCO1xyXG4gICAgICAgIGxvY2FsTWluRGlzdCA9IGRpc3RCO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobG9jYWxNaW5EaXN0IDwgZ2xvYmFsTWluRGlzdCkge1xyXG4gICAgICAgIGdsb2JhbE1pbkRpc3QgPSBsb2NhbE1pbkRpc3Q7XHJcbiAgICAgICAgZ2xvYmFsQ2xvc2VzdFBvaW50ID0gWy4uLmxvY2FsQ2xvc2VzdFBvaW50XTtcclxuICAgICAgICBjbG9zZXN0VHJpYW5nbGUgPSBpbmRleDtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5fc2V0SW5mbHVlbmNlVHJpYW5nbGUoXHJcbiAgICAgIHRoaXMuX3RyaWFuZ2xlc1tjbG9zZXN0VHJpYW5nbGVdLFxyXG4gICAgICBnbG9iYWxDbG9zZXN0UG9pbnRcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRlcm1pbmVzIHRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSBsaW5lIGZvcm1lZCBiZXR3ZWVuIHRoZVxyXG4gICAqIHR3byBibGVuZCB0aHJlc2hvbGRzIGJhc2VkIG9uIHRoZSBjdXJyZW50IFt4LHldIGJsZW5kVmFsdWVzIGFuZFxyXG4gICAqIHRoZW4gc2V0cyBibGVuZCB3ZWlnaHRzIGZvciB0aGUgY29ycmVzcG9uZGluZyBzdGF0ZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBwIC0gR2l2ZW4gW3gseV0gYmxlbmRWYWx1ZS5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX3NldEluZmx1ZW5jZUNsb3Nlc3RQb2ludE9uTGluZShwKSB7XHJcbiAgICBjb25zdCBjbG9zZXN0UG9pbnQgPSBNYXRoVXRpbHMuY2xvc2VzdFBvaW50T25MaW5lKFxyXG4gICAgICB0aGlzLl92ZXJ0aWNlc1tbMF1dLFxyXG4gICAgICB0aGlzLl92ZXJ0aWNlc1tbMV1dLFxyXG4gICAgICBwXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IGRpc3RBID0gTWF0aFV0aWxzLmRpc3RhbmNlU3F1YXJlZCh0aGlzLl92ZXJ0aWNlc1swXSwgY2xvc2VzdFBvaW50KTtcclxuICAgIGNvbnN0IGRpc3RCID0gTWF0aFV0aWxzLmRpc3RhbmNlU3F1YXJlZCh0aGlzLl92ZXJ0aWNlc1sxXSwgY2xvc2VzdFBvaW50KTtcclxuXHJcbiAgICBjb25zdCB3ZWlnaHRBID0gZGlzdEIgLyAoZGlzdEEgKyBkaXN0Qik7XHJcbiAgICBjb25zdCB3ZWlnaHRCID0gZGlzdEEgLyAoZGlzdEEgKyBkaXN0Qik7XHJcblxyXG4gICAgY29uc3QgdGhyZXNob2xkQSA9IHRoaXMuX3RocmVzaG9sZHNbMF07XHJcbiAgICBjb25zdCB0aHJlc2hvbGRCID0gdGhpcy5fdGhyZXNob2xkc1sxXTtcclxuXHJcbiAgICBjb25zdCBzdGF0ZUEgPSB0aGlzLl9zdGF0ZXMuZ2V0KHRocmVzaG9sZEEubmFtZSk7XHJcbiAgICBjb25zdCBzdGF0ZUIgPSB0aGlzLl9zdGF0ZXMuZ2V0KHRocmVzaG9sZEIubmFtZSk7XHJcblxyXG4gICAgc3RhdGVBLnNldFdlaWdodCh3ZWlnaHRBKTtcclxuICAgIHN0YXRlQi5zZXRXZWlnaHQod2VpZ2h0Qik7XHJcblxyXG4gICAgdGhpcy5fc2V0UGhhc2VMZWFkU3RhdGUoXHJcbiAgICAgIFtzdGF0ZUEsIHN0YXRlQl0sXHJcbiAgICAgIFt0aHJlc2hvbGRBLnBoYXNlTWF0Y2gsIHRocmVzaG9sZEIucGhhc2VNYXRjaF1cclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIGEgbGVhZCBwaGFzZSBzdGF0ZSBpZiB0aGUgY29uZGl0aW9uc1xyXG4gICAqIGZvciBwaGFzZS1tYXRjaGluZyBhcmUgc2F0aXNmaWVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheS48QWJzdHJhY3RCbGVuZFN0YXRlPn0gc3RhdGVzIC0gU3RhdGVzIHRvXHJcbiAgICogY2hlY2sgcGhhc2UtbWF0Y2hpbmcgY3JpdGVyaWEuXHJcbiAgICogQHBhcmFtIHtBcnJheS48Ym9vbGVhbj59IHBoYXNlTWF0Y2hlZCAtIExpc3Qgb2YgcGhhc2UtbWF0Y2ggYm9vbGVhbnMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9zZXRQaGFzZUxlYWRTdGF0ZShzdGF0ZXMsIHBoYXNlTWF0Y2hlZCkge1xyXG4gICAgbGV0IG1heCA9IDA7XHJcbiAgICBzdGF0ZXMuZm9yRWFjaCgoc3RhdGUsIGluZGV4KSA9PiB7XHJcbiAgICAgIGlmIChwaGFzZU1hdGNoZWRbaW5kZXhdICYmIHN0YXRlLndlaWdodCA+IG1heCkge1xyXG4gICAgICAgIHRoaXMuX3BoYXNlTGVhZFN0YXRlID0gc3RhdGU7XHJcbiAgICAgICAgbWF4ID0gc3RhdGUud2VpZ2h0O1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJsZW5kMmRTdGF0ZTtcclxuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxyXG5pbXBvcnQgQWJzdHJhY3RCbGVuZFN0YXRlIGZyb20gJy4vc3RhdGUvQWJzdHJhY3RCbGVuZFN0YXRlJztcclxuaW1wb3J0IEFuaW1hdGlvblBsYXllckludGVyZmFjZSBmcm9tICcuL0FuaW1hdGlvblBsYXllckludGVyZmFjZSc7XHJcbmltcG9ydCBBbmltYXRpb25VdGlscyBmcm9tICcuL0FuaW1hdGlvblV0aWxzJztcclxuaW1wb3J0IE1hdGhVdGlscyBmcm9tICcuLi9NYXRoVXRpbHMnO1xyXG5pbXBvcnQgRGVmZXJyZWQgZnJvbSAnLi4vRGVmZXJyZWQnO1xyXG5pbXBvcnQgU3RhdGVDb250YWluZXJJbnRlcmZhY2UgZnJvbSAnLi9zdGF0ZS9TdGF0ZUNvbnRhaW5lckludGVyZmFjZSc7XHJcblxyXG4vKipcclxuICogRW51bSBmb3IgdHlwZXMgb2Yge0BsaW5rIEFuaW1hdGlvbkxheWVyfSBibGVuZGluZy5cclxuICpcclxuICogQHJlYWRvbmx5XHJcbiAqIEBlbnVtIHtzdHJpbmd9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgTGF5ZXJCbGVuZE1vZGVzID0ge092ZXJyaWRlOiAnT3ZlcnJpZGUnLCBBZGRpdGl2ZTogJ0FkZGl0aXZlJ307XHJcblxyXG4vKipcclxuICogVGhlIGRlZmF1bHQgYmxlbmRpbmcgbW9kZSB7QGxpbmsgQW5pbWF0aW9uTGF5ZXJ9LlxyXG4gKlxyXG4gKiBAcmVhZG9ubHlcclxuICogQHR5cGUge3N0cmluZ31cclxuICovXHJcbmV4cG9ydCBjb25zdCBEZWZhdWx0TGF5ZXJCbGVuZE1vZGUgPSAnT3ZlcnJpZGUnO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhIGdpdmVuIGJsZW5kTW9kZSBpcyBwcmVzZW50IGluIHRoZSB2YWx1ZXMgb2Yge0BsaW5rIExheWVyQmxlbmRNb2Rlc30uXHJcbiAqIElmIGl0IGlzLCByZXR1cm4gdGhlIG9yaWdpbmFsIHZhbHVlLCBvdGhlcndpc2UgcmV0dXJuIHtAbGluayBEZWZhdWx0TGF5ZXJCbGVuZE1vZGV9LlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gYmxlbmRNb2RlIC0gVGhlIG5hbWUgb2YgdGhlIHR5cGUgb2YgYmxlbmRpbmcuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHsoc3RyaW5nfERlZmF1bHRMYXllckJsZW5kTW9kZSl9XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVCbGVuZE1vZGUoYmxlbmRNb2RlKSB7XHJcbiAgaWYgKEFycmF5LmZyb20oT2JqZWN0LnZhbHVlcyhMYXllckJsZW5kTW9kZXMpKS5pbmNsdWRlcyhibGVuZE1vZGUpKSB7XHJcbiAgICByZXR1cm4gYmxlbmRNb2RlO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gRGVmYXVsdExheWVyQmxlbmRNb2RlO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENsYXNzIGZvciBtYW5hZ2luZyBhIHNldCBvZiBhbmltYXRpb25zIHdoZXJlIG9ubHkgb25lIHN0YXRlIGNhbiBiZSBhY3RpdmUgYXRcclxuICogYW55IGdpdmVuIHRpbWUuXHJcbiAqXHJcbiAqIEBpbXBsZW1lbnRzIEFuaW1hdGlvblBsYXllckludGVyZmFjZVxyXG4gKiBAaW1wbGVtZW50cyBTdGF0ZUNvbnRhaW5lckludGVyZmFjZVxyXG4gKi9cclxuY2xhc3MgQW5pbWF0aW9uTGF5ZXIgZXh0ZW5kcyBBbmltYXRpb25QbGF5ZXJJbnRlcmZhY2UuTWl4aW4oXHJcbiAgU3RhdGVDb250YWluZXJJbnRlcmZhY2UuTWl4aW4oKVxyXG4pIHtcclxuICAvKipcclxuICAgKiBAY29uc3RydWN0b3JcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyAtICBPcHRpb25zIGZvciB0aGUgYW5pbWF0aW9uIGxheWVyLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm5hbWUgLSBOYW1lIG9mIHRoZSBsYXllci4gTmFtZXMgbXVzdCBiZSB1bmlxdWUgdG8gdGhlXHJcbiAgICogYW5pbWF0aW9uIGZlYXR1cmUgdGhhdCBjb250YWlucyB0aGUgbGF5ZXIuXHJcbiAgICogQHBhcmFtIHtMYXllckJsZW5kTW9kZXN9IFtvcHRpb25zLmJsZW5kTW9kZT1EZWZhdWx0TGF5ZXJCbGVuZE1vZGVdIC1cclxuICAgKiBUeXBlIG9mIGJsZW5kaW5nIHRvIHVzZSBmb3IgYWxsIHN0YXRlcyBjb250cm9sbGVkIGJ5IHRoZSBsYXllci5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMud2VpZ2h0PTFdIC0gVGhlIGFtb3VudCBvZiBpbmZsdWVuY2UgdGhlIGxheWVyJ3MgY3VycmVudFxyXG4gICAqIGFuaW1hdGlvbiBoYXMgb3ZlciB0aGUgcmVzdWx0IGZvciB0aGUgaG9zdC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMudHJhbnNpdGlvblRpbWU9MF0gLSBUaGUgZGVmYXVsdCBhbW91bnQgb2YgdGltZSB0byB1c2Ugd2hlblxyXG4gICAqIHBsYXlpbmcgYW5kIHJlc3VtaW5nIGFuaW1hdGlvbnMuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9wdGlvbnMuZWFzaW5nRm4gLSBUaGUgZGVmYXVsdCBlYXNpbmcgZnVuY3Rpb24gdG8gdXNlIHdoZW5cclxuICAgKiB0cmFuc2l0aW9uaW5nIGJldHdlZW4gYW5pbWF0aW9ucyBhbmQgc2V0dGluZyBsYXllciB3ZWlnaHQuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XHJcbiAgICBzdXBlcihvcHRpb25zKTtcclxuXHJcbiAgICB0aGlzLm5hbWUgPSBvcHRpb25zLm5hbWUgPT09IHVuZGVmaW5lZCA/ICdBbmltYXRpb25MYXllcicgOiBvcHRpb25zLm5hbWU7XHJcbiAgICB0aGlzLl9ibGVuZE1vZGUgPSBBcnJheS5mcm9tKE9iamVjdC52YWx1ZXMoTGF5ZXJCbGVuZE1vZGVzKSkuaW5jbHVkZXMoXHJcbiAgICAgIG9wdGlvbnMuYmxlbmRNb2RlXHJcbiAgICApXHJcbiAgICAgID8gb3B0aW9ucy5ibGVuZE1vZGVcclxuICAgICAgOiBEZWZhdWx0TGF5ZXJCbGVuZE1vZGU7XHJcbiAgICB0aGlzLl9wcm9taXNlcyA9IHtcclxuICAgICAgd2VpZ2h0OiBEZWZlcnJlZC5yZXNvbHZlKCksXHJcbiAgICB9O1xyXG4gICAgdGhpcy5fd2VpZ2h0UGF1c2VkID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy53ZWlnaHQgPSB0eXBlb2Ygb3B0aW9ucy53ZWlnaHQgPT09ICdudW1iZXInID8gb3B0aW9ucy53ZWlnaHQgOiAxO1xyXG4gICAgdGhpcy5faW50ZXJuYWxXZWlnaHQgPSB0aGlzLl93ZWlnaHQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSB0eXBlIG9mIGJsZW5kaW5nIHVzZWQgZm9yIHN0YXRlcyBjb250cm9sbGVkIGJ5IHRoZSBsYXllci5cclxuICAgKlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICovXHJcbiAgZ2V0IGJsZW5kTW9kZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9ibGVuZE1vZGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIGFuZCBzZXRzIHRoZSBhbW91bnQgb2YgaW5mbHVlbmNlIHRoZSBsYXllcidzIGN1cnJlbnQgYW5pbWF0aW9uIGhhcyBvdmVyXHJcbiAgICogdGhlIHJlc3VsdCBmb3IgdGhlIGhvc3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIHNldCB3ZWlnaHQod2VpZ2h0KSB7XHJcbiAgICB0aGlzLl93ZWlnaHQgPSBNYXRoVXRpbHMuY2xhbXAod2VpZ2h0LCAwLCAxKTtcclxuICB9XHJcblxyXG4gIGdldCB3ZWlnaHQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fd2VpZ2h0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgbGF5ZXIncyB3ZWlnaHQgdmFsdWUgaXMgY3VycmVudGx5IGJlaW5nIGFuaW1hdGVkLlxyXG4gICAqXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgZ2V0IHdlaWdodFBlbmRpbmcoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZXMud2VpZ2h0ICYmIHRoaXMuX3Byb21pc2VzLndlaWdodC5wZW5kaW5nO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGF1c2UgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIHN0YXRlIGFuZCBhbnkgaW50ZXJwb2xhdGlvbiBoYXBwZW5pbmcgb24gdGhlIGxheWVyJ3NcclxuICAgKiB3ZWlnaHQgcHJvcGVydHkuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBwYXVzZSgpIHtcclxuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XHJcbiAgICB0aGlzLl93ZWlnaHRQYXVzZWQgPSB0cnVlO1xyXG5cclxuICAgIHJldHVybiB0aGlzLnBhdXNlQW5pbWF0aW9uKCkgfHwgdGhpcy53ZWlnaHRQZW5kaW5nO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzdW1lIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBzdGF0ZSBhbmQgYW55IGludGVycG9sYXRpb24gaGFwcGVuaW5nIG9uIHRoZSBsYXllcidzXHJcbiAgICogd2VpZ2h0IHByb3BlcnR5LlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgcmVzdW1lKCkge1xyXG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XHJcbiAgICB0aGlzLl93ZWlnaHRQYXVzZWQgPSBmYWxzZTtcclxuXHJcbiAgICBjb25zdCBpc1dlaWdodEFjdGl2ZSA9IHRoaXMud2VpZ2h0UGVuZGluZztcclxuXHJcbiAgICBpZiAodGhpcy5fY3VycmVudFN0YXRlKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnJlc3VtZUFuaW1hdGlvbigpIHx8IGlzV2VpZ2h0QWN0aXZlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIGlzV2VpZ2h0QWN0aXZlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlcyB0aGUgdXNlciBkZWZpbmVkIHdlaWdodCBvdmVyIHRpbWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gd2VpZ2h0IC0gVGhlIHRhcmdldCB3ZWlnaHQgdmFsdWUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzZWNvbmRzPTBdIC0gVGhlIGFtb3VudCBvZiB0aW1lIGl0IHdpbGwgdGFrZSB0byByZWFjaCB0aGVcclxuICAgKiB0YXJnZXQgd2VpZ2h0LlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBlYXNpbmdGbiAtIFRoZSBlYXNpbmcgZnVuY3Rpb24gdG8gdXNlIGZvciBpbnRlcnBvbGF0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0RlZmVycmVkfVxyXG4gICAqL1xyXG4gIHNldFdlaWdodCh3ZWlnaHQsIHNlY29uZHMgPSAwLCBlYXNpbmdGbikge1xyXG4gICAgaWYgKHRoaXMud2VpZ2h0UGVuZGluZykge1xyXG4gICAgICB0aGlzLl9wcm9taXNlcy53ZWlnaHQuY2FuY2VsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgd2VpZ2h0ID0gTWF0aFV0aWxzLmNsYW1wKHdlaWdodCk7XHJcbiAgICB0aGlzLl9wcm9taXNlcy53ZWlnaHQgPSBBbmltYXRpb25VdGlscy5pbnRlcnBvbGF0ZVByb3BlcnR5KFxyXG4gICAgICB0aGlzLFxyXG4gICAgICAnd2VpZ2h0JyxcclxuICAgICAgd2VpZ2h0LFxyXG4gICAgICB7XHJcbiAgICAgICAgc2Vjb25kcyxcclxuICAgICAgICBlYXNpbmdGbjogZWFzaW5nRm4gIT09IHVuZGVmaW5lZCA/IGVhc2luZ0ZuIDogdGhpcy5fZWFzaW5nRm4sXHJcbiAgICAgIH1cclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VzLndlaWdodDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhdXNlIGFueSBpbnRlcnBvbGF0aW9uIGhhcHBlbmluZyBvbiB0aGUgbGF5ZXIncyB3ZWlnaHQgcHJvcGVydHkuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBwYXVzZVdlaWdodCgpIHtcclxuICAgIHRoaXMuX3dlaWdodFBhdXNlZCA9IHRydWU7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMud2VpZ2h0UGVuZGluZztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc3VtZSBhbnkgaW50ZXJwb2xhdGlvbiBoYXBwZW5pbmcgb24gdGhlIGxheWVyJ3Mgd2VpZ2h0IHByb3BlcnR5LlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgcmVzdW1lV2VpZ2h0KCkge1xyXG4gICAgdGhpcy5fd2VpZ2h0UGF1c2VkID0gZmFsc2U7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMud2VpZ2h0UGVuZGluZztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE11bHRpcGxpZXMgdGhlIHVzZXIgd2VpZ2h0IGJ5IGEgZmFjdG9yIHRvIGRldGVybWluZSB0aGUgaW50ZXJuYWwgd2VpZ2h0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZhY3RvciAtIDAtMSBtdWx0aXBsaWVyIHRvIGFwcGx5IHRvIHRoZSB1c2VyIHdlaWdodC5cclxuICAgKi9cclxuICB1cGRhdGVJbnRlcm5hbFdlaWdodChmYWN0b3IpIHtcclxuICAgIHRoaXMuX2ludGVybmFsV2VpZ2h0ID0gdGhpcy5fd2VpZ2h0ICogZmFjdG9yO1xyXG5cclxuICAgIGlmICh0aGlzLl9jdXJyZW50U3RhdGUpIHtcclxuICAgICAgdGhpcy5fY3VycmVudFN0YXRlLnVwZGF0ZUludGVybmFsV2VpZ2h0KHRoaXMuX2ludGVybmFsV2VpZ2h0KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIG5hbWVzIG9mIGJsZW5kIHN0YXRlcyBpbiBhbiBhbmltYXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gYW5pbWF0aW9uTmFtZSAtIE5hbWUgb2YgdGhlIGFuaW1hdGlvbi5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtBcnJheS48c3RyaW5nPn0gLSBOYW1lcyBvZiBibGVuZCBzdGF0ZXMuXHJcbiAgICovXHJcbiAgZ2V0QW5pbWF0aW9uQmxlbmROYW1lcyhhbmltYXRpb25OYW1lKSB7XHJcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoYW5pbWF0aW9uTmFtZSk7XHJcblxyXG4gICAgaWYgKHN0YXRlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBDYW5ub3QgZ2V0IGJsZW5kIG5hbWVzIG9mIGFuaW1hdGlvbiAke2FuaW1hdGlvbk5hbWV9IG9uIGxheWVyICR7dGhpcy5uYW1lfS4gTm8gYW5pbWF0aW9uIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHN0YXRlIGluc3RhbmNlb2YgQWJzdHJhY3RCbGVuZFN0YXRlKSB7XHJcbiAgICAgIHJldHVybiBzdGF0ZS5nZXRTdGF0ZU5hbWVzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICBgQ2Fubm90IGdldCBibGVuZCBuYW1lcyBvZiBhbmltYXRpb24gJHthbmltYXRpb25OYW1lfSBvbiBsYXllciAke3RoaXMubmFtZX0uIEFuaW1hdGlvbiBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgQWJzdHJhY3RCbGVuZFN0YXRlLmBcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgdGhlIHdlaWdodCBmb3IgYSBibGVuZCBzdGF0ZSBvZiBhbiBhbmltYXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gYW5pbWF0aW9uTmFtZSAtIE5hbWUgb2YgdGhlIGFuaW1hdGlvbiBjb250YWluaW5nIHRoZSBibGVuZCBzdGF0ZVxyXG4gICAqIHRvIHVwZGF0ZS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gYmxlbmROYW1lIC0gTmFtZSBvZiB0aGUgYmxlbmQgc3RhdGUgdG8gdXBkYXRlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3ZWlnaHQgLSBXZWlnaHQgdmFsdWUgdG8gc2V0IG9uIHRoZSBhbmltYXRpb24uIFRoaXMgbnVtYmVyIHNob3VkbGQgYmVcclxuICAgKiBpbiB0aGUgMC0xIHJhbmdlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gc2Vjb25kcyAtIE51bWJlciBvZiBzZWNvbmRzIGl0IHNob3VsZCB0YWtlIHRvIHJlYWNoIHRoZSBuZXcgd2VpZ2h0LlxyXG4gICAqIERlZmF1bHQgaXMgemVybyBhbmQgd2lsbCBzZXQgaW1tZWRpYXRlbHkuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGVhc2luZ0ZuIC0gRWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSB3aGlsZSBpbnRlcnBvbGF0aW5nIHRoZSBuZXdcclxuICAgKiB3ZWlnaHQuIERlZmF1bHQgaXMgRWFzaW5nLkxpbmVhci5Jbk91dC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH0gLSBQcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIG9uY2UgdGhlIGFuaW1hdGlvbidzIHdlaWdodCByZWFjaGVzXHJcbiAgICogdGhlIHRhcmdldCB2YWx1ZS5cclxuICAgKi9cclxuICBzZXRBbmltYXRpb25CbGVuZFdlaWdodChcclxuICAgIGFuaW1hdGlvbk5hbWUsXHJcbiAgICBibGVuZE5hbWUsXHJcbiAgICB3ZWlnaHQsXHJcbiAgICBzZWNvbmRzID0gMCxcclxuICAgIGVhc2luZ0ZuXHJcbiAgKSB7XHJcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoYW5pbWF0aW9uTmFtZSk7XHJcblxyXG4gICAgaWYgKHN0YXRlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBDYW5ub3Qgc2V0IGJsZW5kIHdlaWdodCBvZiBhbmltYXRpb24gJHthbmltYXRpb25OYW1lfSBvbiBsYXllciAke3RoaXMubmFtZX0uIE5vIGFuaW1hdGlvbiBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzdGF0ZSBpbnN0YW5jZW9mIEFic3RyYWN0QmxlbmRTdGF0ZSkge1xyXG4gICAgICByZXR1cm4gc3RhdGUuc2V0QmxlbmRXZWlnaHQoYmxlbmROYW1lLCB3ZWlnaHQsIHNlY29uZHMsIGVhc2luZ0ZuKTtcclxuICAgIH1cclxuXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgIGBDYW5ub3Qgc2V0IGJsZW5kIHdlaWdodCBvZiBhbmltYXRpb24gJHthbmltYXRpb25OYW1lfSBvbiBsYXllciAke3RoaXMubmFtZX0uIEFuaW1hdGlvbiBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgQWJzdHJhY3RCbGVuZFN0YXRlLmBcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSB3ZWlnaHQgZm9yIGEgYmxlbmQgc3RhdGUgb2YgYW4gYW5pbWF0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFuaW1hdGlvbk5hbWUgLSBOYW1lIG9mIHRoZSBhbmltYXRpb24gY29udGFpbmluZyB0aGUgYmxlbmQgc3RhdGVcclxuICAgKiB0byB1cGRhdGUuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGJsZW5kTmFtZSAtIE5hbWUgb2YgdGhlIGJsZW5kIHN0YXRlIHRvIHJldHJpZXZlIHRoZSB3ZWlnaHQgb2YuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIFdlaWdodCBvZiB0aGUgYmxlbmQgc3RhdGUuXHJcbiAgICovXHJcbiAgZ2V0QW5pbWF0aW9uQmxlbmRXZWlnaHQoYW5pbWF0aW9uTmFtZSwgYmxlbmROYW1lKSB7XHJcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoYW5pbWF0aW9uTmFtZSk7XHJcblxyXG4gICAgaWYgKHN0YXRlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBDYW5ub3QgZ2V0IGJsZW5kIHdlaWdodCBvZiBhbmltYXRpb24gJHthbmltYXRpb25OYW1lfSBvbiBsYXllciAke3RoaXMubmFtZX0uIE5vIGFuaW1hdGlvbiBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzdGF0ZSBpbnN0YW5jZW9mIEFic3RyYWN0QmxlbmRTdGF0ZSkge1xyXG4gICAgICByZXR1cm4gc3RhdGUuZ2V0QmxlbmRXZWlnaHQoYmxlbmROYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgIGBDYW5ub3QgZ2V0IGJsZW5kIHdlaWdodCBvZiBhbmltYXRpb24gJHthbmltYXRpb25OYW1lfSBvbiBsYXllciAke3RoaXMubmFtZX0uIEFuaW1hdGlvbiBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgQWJzdHJhY3RCbGVuZFN0YXRlLmBcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgYW55IHdlaWdodCBpbnRlcnBvbGF0b3JzIGFuZCB0aGUgY3VycmVudCBhbmltYXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFUaW1lIC0gVGltZSBpbiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGxhc3QgdXBkYXRlLlxyXG4gICAqL1xyXG4gIHVwZGF0ZShkZWx0YVRpbWUpIHtcclxuICAgIHN1cGVyLnVwZGF0ZShkZWx0YVRpbWUpO1xyXG5cclxuICAgIGlmICghdGhpcy5fcGF1c2VkICYmICF0aGlzLl93ZWlnaHRQYXVzZWQpIHtcclxuICAgICAgdGhpcy5fcHJvbWlzZXMud2VpZ2h0LmV4ZWN1dGUoZGVsdGFUaW1lKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbmNlbCBhbnkgcGVuZGluZyBwcm9taXNlcyBhbmQgZGlzY2FyZCBzdGF0ZXMgY29udHJvbGxlZCBieSB0aGUgbGF5ZXIuXHJcbiAgICovXHJcbiAgZGlzY2FyZCgpIHtcclxuICAgIHN1cGVyLmRpc2NhcmQoKTtcclxuXHJcbiAgICB0aGlzLmRpc2NhcmRTdGF0ZXMoKTtcclxuXHJcbiAgICB0aGlzLl9wcm9taXNlcy53ZWlnaHQuY2FuY2VsKCk7XHJcbiAgICBkZWxldGUgdGhpcy5fcHJvbWlzZXM7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBBbmltYXRpb25MYXllcjtcclxuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxyXG5pbXBvcnQgRGVmZXJyZWQgZnJvbSAnY29yZS9EZWZlcnJlZCc7XHJcbmltcG9ydCBBYnN0cmFjdFN0YXRlIGZyb20gJy4vQWJzdHJhY3RTdGF0ZSc7XHJcbmltcG9ydCB7dmFsaWRhdGVCbGVuZE1vZGV9IGZyb20gJy4uL0FuaW1hdGlvbkxheWVyJztcclxuaW1wb3J0IEFuaW1hdGlvblV0aWxzIGZyb20gJy4uL0FuaW1hdGlvblV0aWxzJztcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyBmb3IgcGxheWluZyBhIHNpbmdsZSBhbmltYXRpb24gY2xpcC5cclxuICpcclxuICogQGV4dGVuZHMgQWJzdHJhY3RTdGF0ZVxyXG4gKiBAYWxpYXMgY29yZS9TaW5nbGVTdGF0ZVxyXG4gKi9cclxuY2xhc3MgU2luZ2xlU3RhdGUgZXh0ZW5kcyBBYnN0cmFjdFN0YXRlIHtcclxuICAvKipcclxuICAgKiBAY29uc3RydWN0b3JcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBhbmltYXRpb24gc3RhdGUuXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRpb25zLm5hbWUgLSBOYW1lIGZvciB0aGUgYW5pbWF0aW9uIHN0YXRlLiBOYW1lcyBtdXN0IGJlXHJcbiAgICogdW5pcXVlIGZvciB0aGUgbGF5ZXIgdGhlIHN0YXRlIGlzIGFwcGxpZWQgdG8uXHJcbiAgICogQHBhcmFtIHt3ZWlnaHR9IFtvcHRpb25zLndlaWdodD0wXSAtIFRoZSAwLTEgYW1vdW50IG9mIGluZmx1ZW5jZSB0aGUgc3RhdGUgd2lsbCBoYXZlLlxyXG4gICAqIEBwYXJhbSB7dGltZVNjYWxlfSBbb3B0aW9ucy50aW1lU2NhbGU9MV0gLSBGYWN0b3IgdG8gc2NhbGUgdGhlIHBsYXliYWNrIHNwZWVkIG9mIHRoZVxyXG4gICAqIGFuaW1hdGlvbi5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubG9vcENvdW50PUluZmluaXR5XSAtIE51bWJlciBvZiB0aW1lcyB0aGUgYW5pbWF0aW9uIHNob3VsZFxyXG4gICAqIHJlcGVhdCBiZWZvcmUgZmluaXNoaW5nLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5ibGVuZE1vZGU9RGVmYXVsdExheWVyQmxlbmRNb2RlXSAtIFR5cGUgb2ZcclxuICAgKiBibGVuZGluZyB0aGUgYW5pbWF0aW9uIHNob3VsZCB1c2UuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XHJcbiAgICBzdXBlcihvcHRpb25zKTtcclxuXHJcbiAgICB0aGlzLl90aW1lU2NhbGUgPSBvcHRpb25zLnRpbWVTY2FsZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50aW1lU2NhbGUgOiAxO1xyXG4gICAgdGhpcy5fcHJvbWlzZXMudGltZVNjYWxlID0gRGVmZXJyZWQucmVzb2x2ZSgpO1xyXG4gICAgdGhpcy5fbG9vcENvdW50ID1cclxuICAgICAgb3B0aW9ucy5sb29wQ291bnQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubG9vcENvdW50IDogSW5maW5pdHk7XHJcbiAgICB0aGlzLl9ibGVuZE1vZGUgPSB2YWxpZGF0ZUJsZW5kTW9kZShvcHRpb25zLmJsZW5kTW9kZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIGFuZCBzZXRzIHRoZSBub3JtYWxpemVkIHBsYXlpbmcgdGltZSBvZiB0aGUgY3VycmVudCBhbmltYXRpb25cclxuICAgKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IG5vcm1hbGl6ZWRUaW1lKCkge1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG5cclxuICBzZXQgbm9ybWFsaXplZFRpbWUodGltZSkge1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyBhbmQgc2V0cyB0aGUgYSBmYWN0b3IgdG8gc2NhbGUgYW5pbWF0aW9uIHBsYXliYWNrIHNwZWVkIHdpdGguXHJcbiAgICpcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCB0aW1lU2NhbGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fdGltZVNjYWxlO1xyXG4gIH1cclxuXHJcbiAgc2V0IHRpbWVTY2FsZSh0aW1lU2NhbGUpIHtcclxuICAgIHRoaXMuX3RpbWVTY2FsZSA9IHRpbWVTY2FsZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgd2hldGhlciBvciBub3QgdGhlIHRpbWVTY2FsZSBpcyBjdXJyZW50bHkgYmVpbmcgYW5pbWF0ZWQuXHJcbiAgICpcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBnZXQgdGltZVNjYWxlUGVuZGluZygpIHtcclxuICAgIHJldHVybiB0aGlzLl9wcm9taXNlcy50aW1lU2NhbGUucGVuZGluZztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgdGhlIHRpbWVTY2FsZSB2YWx1ZSBvdmVyIHRpbWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gd2VpZ2h0IC0gVGhlIHRhcmdldCB0aW1lU2NhbGUgdmFsdWUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzZWNvbmRzPTBdIC0gVGhlIGFtb3VudCBvZiB0aW1lIGl0IHdpbGwgdGFrZSB0byByZWFjaCB0aGVcclxuICAgKiB0YXJnZXQgdGltZVNjYWxlLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBlYXNpbmdGbiAtIFRoZSBlYXNpbmcgZnVuY3Rpb24gdG8gdXNlIGZvciBpbnRlcnBvbGF0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0RlZmVycmVkfVxyXG4gICAqL1xyXG4gIHNldFRpbWVTY2FsZSh0aW1lU2NhbGUsIHNlY29uZHMgPSAwLCBlYXNpbmdGbikge1xyXG4gICAgdGhpcy5fcHJvbWlzZXMudGltZVNjYWxlLmNhbmNlbCgpO1xyXG5cclxuICAgIHRoaXMuX3Byb21pc2VzLnRpbWVTY2FsZSA9IEFuaW1hdGlvblV0aWxzLmludGVycG9sYXRlUHJvcGVydHkoXHJcbiAgICAgIHRoaXMsXHJcbiAgICAgICd0aW1lU2NhbGUnLFxyXG4gICAgICB0aW1lU2NhbGUsXHJcbiAgICAgIHtzZWNvbmRzLCBlYXNpbmdGbn1cclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VzLnRpbWVTY2FsZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgYW5kIHNldHMgdGhlIG51bWJlciBvZiB0aW1lcyB0aGUgYW5pbWF0aW9uIHdpbGwgcmVwZWF0IGJlZm9yZSBmaW5pc2hpbmcuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBsb29wQ291bnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbG9vcENvdW50O1xyXG4gIH1cclxuXHJcbiAgc2V0IGxvb3BDb3VudChsb29wQ291bnQpIHtcclxuICAgIHRoaXMuX2xvb3BDb3VudCA9IGxvb3BDb3VudDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIHR5cGUgb2YgYmxlbmRpbmcgdXNlZCBmb3IgdGhlIGFuaW1hdGlvbi5cclxuICAgKlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICovXHJcbiAgZ2V0IGJsZW5kTW9kZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9ibGVuZE1vZGU7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTaW5nbGVTdGF0ZTtcclxuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxyXG5pbXBvcnQgQWJzdHJhY3RTdGF0ZSBmcm9tICcuL0Fic3RyYWN0U3RhdGUnO1xyXG5pbXBvcnQgU3RhdGVDb250YWluZXJJbnRlcmZhY2UgZnJvbSAnLi9TdGF0ZUNvbnRhaW5lckludGVyZmFjZSc7XHJcbmltcG9ydCBBbmltYXRpb25QbGF5ZXJJbnRlcmZhY2UgZnJvbSAnLi4vQW5pbWF0aW9uUGxheWVySW50ZXJmYWNlJztcclxuaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uL1V0aWxzJztcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyBmb3IgcGxheWluZyByYW5kb20gYW5pbWF0aW9ucyBhdCByYW5kb20gaW50ZXJ2YWxzIHdpdGhpbiB0aGlzIHN0YXRlLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFN0YXRlXHJcbiAqIEBpbXBsZW1lbnRzIEFuaW1hdGlvblBsYXllckludGVyZmFjZVxyXG4gKiBAaW1wbGVtZW50cyBTdGF0ZUNvbnRhaW5lckludGVyZmFjZVxyXG4gKi9cclxuY2xhc3MgUmFuZG9tQW5pbWF0aW9uU3RhdGUgZXh0ZW5kcyBBbmltYXRpb25QbGF5ZXJJbnRlcmZhY2UuTWl4aW4oU3RhdGVDb250YWluZXJJbnRlcmZhY2UuTWl4aW4oQWJzdHJhY3RTdGF0ZSkpIHtcclxuICAvKipcclxuICAgKiBAY29uc3RydWN0b3JcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gLSBPcHRpb25zIGZvciB0aGUgY29udGFpbmVyIHN0YXRlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5wbGF5SW50ZXJ2YWw9M10gLSBUaGUgYmFzZSBhbmltYXRpb24gcGxheWJhY2sgaW50ZXJ2YWwuXHJcbiAgICogQHBhcmFtIHtBcnJheS48QWJzdHJhY3RTdGF0ZT59IFtzdWJTdGF0ZXM9W11dIC0gc3RhdGVzIHRvIGJlIHJhbmRvbWx5IHBpY2tlZCB0byBwbGF5XHJcbiAgICovXHJcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9LCBzdWJTdGF0ZXMgPSBbXSkge1xyXG4gICAgc3VwZXIob3B0aW9ucyk7XHJcblxyXG4gICAgdGhpcy5fcGxheUludGVydmFsID0gb3B0aW9ucy5wbGF5SW50ZXJ2YWwgPyBvcHRpb25zLnBsYXlJbnRlcnZhbCA6IDM7XHJcblxyXG4gICAgc3ViU3RhdGVzLmZvckVhY2goc3RhdGUgPT4ge1xyXG4gICAgICB0aGlzLmFkZFN0YXRlKHN0YXRlKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyBhbmQgc2V0cyB0aGUgYmFzZSBhbmltYXRpb24gcGxheSBpbnRlcnZhbFxyXG4gICAqXHJcbiAgICogQHR5cGUge2Zsb2F0fVxyXG4gICAqL1xyXG4gIGdldCBwbGF5SW50ZXJ2YWwoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcGxheUludGVydmFsO1xyXG4gIH1cclxuXHJcbiAgc2V0IHBsYXlJbnRlcnZhbChwbGF5SW50ZXJ2YWwpIHtcclxuICAgIHRoaXMuX3BsYXlJbnRlcnZhbCA9IHBsYXlJbnRlcnZhbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc2V0IHRoZSBpbnRlcm5hbCB0aW1lciBmb3IgYW5pbWF0aW9uIHBsYXkgaW50ZXJ2YWxcclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX3Jlc2V0VGltZXIoKSB7XHJcbiAgICBjb25zdCBwbGF5VGltZXIgPSBVdGlscy5nZXRSYW5kb21GbG9hdCh0aGlzLl9wbGF5SW50ZXJ2YWwgLyA0LCB0aGlzLl9wbGF5SW50ZXJ2YWwgKiAyKTtcclxuICAgIGNvbnN0IG9uRmluaXNoID0gKCkgPT4ge1xyXG4gICAgICB0aGlzLnBsYXlSYW5kb21BbmltYXRpb24odGhpcy5fcGxheUNhbGxiYWNrcy5vbkVycm9yKTtcclxuICAgIH1cclxuICAgIHRoaXMuX3Byb21pc2VzLnRpbWVyID0gVXRpbHMud2FpdChwbGF5VGltZXIsIHtvbkZpbmlzaH0pO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlSW50ZXJuYWxXZWlnaHQoZmFjdG9yKSB7XHJcbiAgICBzdXBlci51cGRhdGVJbnRlcm5hbFdlaWdodChmYWN0b3IpO1xyXG5cclxuICAgIGlmICh0aGlzLl9jdXJyZW50U3RhdGUpIHtcclxuICAgICAgdGhpcy5fY3VycmVudFN0YXRlLnVwZGF0ZUludGVybmFsV2VpZ2h0KHRoaXMuX2ludGVybmFsV2VpZ2h0KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBpY2sgYSByYW5kb20gYW5pbWF0aW9uIGFuZCB1dGlsaXplIEFuaW1hdGlvblBsYXllckludGVyZmFjZSB0byBwbGF5IHRoYXQgYW5pbWF0aW9uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25FcnJvciAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgaWYgdGhlIHN0YXRlIGVuY291bnRlcnNcclxuICAgKiBhbiBlcnJvciBkdXJpbmcgcGxheWJhY2suXHJcbiAgICovXHJcbiAgcGxheVJhbmRvbUFuaW1hdGlvbihvbkVycm9yKSB7XHJcbiAgICB0aGlzLl9yZXNldFRpbWVyKCk7XHJcblxyXG4gICAgY29uc3Qgc3RhdGVzID0gdGhpcy5nZXRTdGF0ZU5hbWVzKCk7XHJcbiAgICBpZiAodGhpcy5fY3VycmVudFN0YXRlKSB7XHJcbiAgICAgIHN0YXRlcy5zcGxpY2Uoc3RhdGVzLmluZGV4T2YodGhpcy5fY3VycmVudFN0YXRlLm5hbWUpLCAxKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHJhbmRvbVN0YXRlID0gIHN0YXRlc1tVdGlscy5nZXRSYW5kb21JbnQoMCwgc3RhdGVzLmxlbmd0aCldO1xyXG5cclxuICAgIHRoaXMucGxheUFuaW1hdGlvbihyYW5kb21TdGF0ZSwgdGhpcy5fdHJhbnNpdGlvblRpbWUsIHRoaXMuX2Vhc2luZ0ZuLCB1bmRlZmluZWQsIG9uRXJyb3IsIHVuZGVmaW5lZCk7XHJcbiAgfVxyXG5cclxuICBwbGF5KG9uRmluaXNoLCBvbkVycm9yLCBvbkNhbmNlbCkge1xyXG4gICAgdGhpcy5wbGF5UmFuZG9tQW5pbWF0aW9uKG9uRXJyb3IpO1xyXG4gICAgcmV0dXJuIHN1cGVyLnBsYXkob25GaW5pc2gsIG9uRXJyb3IsIG9uQ2FuY2VsKTtcclxuICB9XHJcblxyXG4gIHBhdXNlKCkge1xyXG4gICAgcmV0dXJuIHN1cGVyLnBhdXNlKCkgJiYgdGhpcy5wYXVzZUFuaW1hdGlvbigpO1xyXG4gIH1cclxuXHJcbiAgcmVzdW1lKG9uRmluaXNoLCBvbkVycm9yLCBvbkNhbmNlbCkge1xyXG4gICAgaWYgKHRoaXMuX2N1cnJlbnRTdGF0ZSkge1xyXG4gICAgICB0aGlzLnJlc3VtZUFuaW1hdGlvbih0aGlzLl9jdXJyZW50U3RhdGUubmFtZSwgdGhpcy5fdHJhbnNpdGlvblRpbWUsIHRoaXMuX2Vhc2luZ0ZuLCB1bmRlZmluZWQsIG9uRXJyb3IsIHVuZGVmaW5lZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3VwZXIucmVzdW1lKG9uRmluaXNoLCBvbkVycm9yLCBvbkNhbmNlbCk7XHJcbiAgfVxyXG5cclxuICBjYW5jZWwoKSB7XHJcbiAgICByZXR1cm4gc3VwZXIuY2FuY2VsKCkgJiYgdGhpcy5jYW5jZWxBbmltYXRpb24oKTtcclxuICB9XHJcblxyXG4gIHN0b3AoKSB7XHJcbiAgICByZXR1cm4gc3VwZXIuc3RvcCgpICYmIHRoaXMuc3RvcEFuaW1hdGlvbigpO1xyXG4gIH1cclxuXHJcbiAgZGlzY2FyZCgpIHtcclxuICAgIHN1cGVyLmRpc2NhcmQoKTtcclxuICAgIHRoaXMuZGlzY2FyZFN0YXRlcygpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUmFuZG9tQW5pbWF0aW9uU3RhdGU7XHJcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcclxuaW1wb3J0IEFic3RyYWN0SG9zdEZlYXR1cmUgZnJvbSAnY29yZS9BYnN0cmFjdEhvc3RGZWF0dXJlJztcclxuaW1wb3J0IFV0aWxzIGZyb20gJ2NvcmUvVXRpbHMnO1xyXG5pbXBvcnQgUXVldWVTdGF0ZSBmcm9tICcuL3N0YXRlL1F1ZXVlU3RhdGUnO1xyXG5pbXBvcnQgRnJlZUJsZW5kU3RhdGUgZnJvbSAnLi9zdGF0ZS9GcmVlQmxlbmRTdGF0ZSc7XHJcbmltcG9ydCBCbGVuZDFkU3RhdGUgZnJvbSAnLi9zdGF0ZS9CbGVuZDFkU3RhdGUnO1xyXG5pbXBvcnQgQmxlbmQyZFN0YXRlIGZyb20gJy4vc3RhdGUvQmxlbmQyZFN0YXRlJztcclxuaW1wb3J0IFNpbmdsZVN0YXRlIGZyb20gJy4vc3RhdGUvU2luZ2xlU3RhdGUnO1xyXG5pbXBvcnQgUmFuZG9tQW5pbWF0aW9uU3RhdGUgZnJvbSAnLi9zdGF0ZS9SYW5kb21BbmltYXRpb25TdGF0ZSc7XHJcbmltcG9ydCBBbmltYXRpb25MYXllciwge0xheWVyQmxlbmRNb2Rlc30gZnJvbSAnLi9BbmltYXRpb25MYXllcic7XHJcbmltcG9ydCBEZWZlcnJlZCBmcm9tICcuLi9EZWZlcnJlZCc7XHJcblxyXG4vKipcclxuICogRW51bSBmb3IgYW5pbWF0aW9uIHN0YXRlIGNsYXNzZXMuXHJcbiAqXHJcbiAqIEByZWFkb25seVxyXG4gKiBAZW51bSB7Q2xhc3N9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgQW5pbWF0aW9uVHlwZXMgPSB7XHJcbiAgc2luZ2xlOiBTaW5nbGVTdGF0ZSxcclxuICBmcmVlQmxlbmQ6IEZyZWVCbGVuZFN0YXRlLFxyXG4gIHF1ZXVlOiBRdWV1ZVN0YXRlLFxyXG4gIHJhbmRvbUFuaW1hdGlvbjogUmFuZG9tQW5pbWF0aW9uU3RhdGUsXHJcbiAgYmxlbmQxZDogQmxlbmQxZFN0YXRlLFxyXG4gIGJsZW5kMmQ6IEJsZW5kMmRTdGF0ZSxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBGZWF0dXJlIGZvciBtYW5hZ2luZyBhbmltYXRpb25zIG9uIGFuIG9iamVjdC5cclxuICpcclxuICogQGV4dGVuZHMgQWJzdHJhY3RIb3N0RmVhdHVyZVxyXG4gKiBAYWxpYXMgY29yZS9BbmltYXRpb25GZWF0dXJlXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBFVkVOVFMgLSBCdWlsdC1pbiBtZXNzYWdlcyB0aGF0IHRoZSBmZWF0dXJlIGVtaXRzLiBXaGVuIHRoZVxyXG4gKiBmZWF0dXJlIGlzIGFkZGVkIHRvIGEge0BsaW5rIGNvcmUvSG9zdE9iamVjdH0sIGV2ZW50IG5hbWVzIHdpbGwgYmUgcHJlZml4ZWQgYnkgdGhlXHJcbiAqIG5hbWUgb2YgdGhlIGZlYXR1cmUgY2xhc3MgKyAnLicuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLmFkZExheWVyPW9uQWRkTGF5ZXJFdmVudF0gLSBNZXNzYWdlIHRoYXQgaXMgZW1pdHRlZCBhZnRlclxyXG4gKiBbYWRkTGF5ZXJde0BsaW5rIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNhZGRMYXllcn0gaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGV4ZWN1dGVkLlxyXG4gKiBBbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBuYW1lIG9mIHRoZSBsYXllciB0aGF0IHdhcyBhZGRlZCBhbmQgaXRzIGluZGV4IGluXHJcbiAqIHRoZSBsYXllciBzdGFjayB3aXRoIHRoZSBzaWduYXR1cmUge25hbWU6IHN0cmluZywgaW5kZXg6IG51bWJlcn0gaXMgc3VwcGxpZWRcclxuICogYXMgYW4gYXJndW1lbnQgdG8gbGlzdGVuZXIgZnVuY3Rpb25zLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UUy5yZW1vdmVMYXllcj1vblJlbW92ZUxheWVyRXZlbnRdIC0gTWVzc2FnZSB0aGF0IGlzXHJcbiAqIGVtaXR0ZWQgYWZ0ZXIgW3JlbW92ZUxheWVyXXtAbGluayBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjcmVtb3ZlTGF5ZXJ9IGhhcyBiZWVuXHJcbiAqIHN1Y2Nlc3NmdWxseSBleGVjdXRlZC4gQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgbmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCB3YXNcclxuICogcmVtb3ZlZCBhbmQgaXRzIGluZGV4IGluIHRoZSBsYXllciBzdGFjayB3aXRoIHRoZSBzaWduYXR1cmUge25hbWU6IHN0cmluZywgaW5kZXg6IG51bWJlcn1cclxuICogaXMgc3VwcGxpZWQgYXMgYW4gYXJndW1lbnQgdG8gbGlzdGVuZXIgZnVuY3Rpb25zLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UUy5yZW5hbWVMYXllcj1vblJlbmFtZUxheWVyRXZlbnRdIC0gTWVzc2FnZSB0aGF0IGlzXHJcbiAqIGVtaXR0ZWQgYWZ0ZXIgW3JlbmFtZUxheWVyXXtAbGluayBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjcmVuYW1lTGF5ZXJ9IGhhcyBiZWVuXHJcbiAqIHN1Y2Nlc3NmdWxseSBleGVjdXRlZC4gQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgb3JpZ2luYWwgbmFtZSBvZiB0aGUgbGF5ZXJcclxuICogdGhhdCB3YXMgcmVuYW1lZCBhbmQgaXRzIHVwZGF0ZWQgbmFtZSB3aXRoIHRoZSBzaWduYXR1cmUge29sZE5hbWU6IHN0cmluZywgbmV3TmFtZTogc3RyaW5nfVxyXG4gKiBpcyBzdXBwbGllZCBhcyBhbiBhcmd1bWVudCB0byBsaXN0ZW5lciBmdW5jdGlvbnMuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLmFkZEFuaW1hdGlvbj1vbkFkZEFuaW1hdGlvbkV2ZW50XSAtIE1lc3NhZ2UgdGhhdCBpc1xyXG4gKiBlbWl0dGVkIGFmdGVyIFthZGRBbmltYXRpb25de0BsaW5rIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNhZGRBbmltYXRpb259IGhhcyBiZWVuXHJcbiAqIHN1Y2Nlc3NmdWxseSBleGVjdXRlZC4gQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgbmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCB0aGVcclxuICogYW5pbWF0aW9uIHdhcyBhZGRlZCB0byBhbmQgdGhlIG5hbWUgb2YgdGhlIGFuaW1hdGlvbiB0aGF0IHdhcyBhZGRlZCB3aXRoIHRoZVxyXG4gKiBzaWduYXR1cmUge2xheWVyTmFtZTogc3RyaW5nLCBhbmltYXRpb25OYW1lOiBzdHJpbmd9IGlzIHN1cHBsaWVkIGFzIGFuIGFyZ3VtZW50XHJcbiAqIHRvIGxpc3RlbmVyIGZ1bmN0aW9ucy5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVFMucmVtb3ZlQW5pbWF0aW9uPW9uUmVtb3ZlZEFuaW1hdGlvbkV2ZW50XSAtIE1lc3NhZ2VcclxuICogdGhhdCBpcyBlbWl0dGVkIGFmdGVyIFtyZW1vdmVBbmltYXRpb25de0BsaW5rIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNyZW1vdmVBbmltYXRpb259XHJcbiAqIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBleGVjdXRlZC4gQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgbmFtZSBvZiB0aGUgbGF5ZXJcclxuICogdGhhdCB0aGUgYW5pbWF0aW9uIHdhcyByZW1vdmVkIGZyb20gYW5kIHRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb24gdGhhdCB3YXMgcmVtb3ZlZFxyXG4gKiB3aXRoIHRoZSBzaWduYXR1cmUge2xheWVyTmFtZTogc3RyaW5nLCBhbmltYXRpb25OYW1lOiBzdHJpbmd9IGlzIHN1cHBsaWVkIGFzXHJcbiAqIGFuIGFyZ3VtZW50IHRvIGxpc3RlbmVyIGZ1bmN0aW9ucy5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVFMucmVuYW1lQW5pbWF0aW9uPW9uUmVuYW1lQW5pbWF0aW9uRXZlbnRdIC0gTWVzc2FnZVxyXG4gKiB0aGF0IGlzIGVtaXR0ZWQgYWZ0ZXIgW3JlbmFtZUFuaW1hdGlvbl17QGxpbmsgY29yZS9BbmltYXRpb25GZWF0dXJlI3JlbmFtZUFuaW1hdGlvbn1cclxuICogaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGV4ZWN1dGVkLiBBbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBuYW1lIG9mIHRoZSBsYXllclxyXG4gKiB0aGF0IGNvbnRhaW5zIHRoZSBhbmltYXRpb24gdGhhdCB3YXMgcmVuYW1lZCwgdGhlIG9yaWdpbmFsIG5hbWUgb2YgdGhlIGFuaW1hdGlvblxyXG4gKiB0aGF0IHdhcyByZW5hbWVkIGFuZCBpdHMgdXBkYXRlZCBuYW1lIHdpdGggdGhlIHNpZ25hdHVyZSB7bGF5ZXJOYW1lOiBzdHJpbmcsIG9sZE5hbWU6IHN0cmluZywgbmV3TmFtZTogc3RyaW5nfVxyXG4gKiBpcyBzdXBwbGllZCBhcyBhbiBhcmd1bWVudCB0byBsaXN0ZW5lciBmdW5jdGlvbnMuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLnBsYXk9b25QbGF5RXZlbnRdIC0gTWVzc2FnZSB0aGF0IGlzIGVtaXR0ZWQgYWZ0ZXJcclxuICogZWFjaCBjYWxsIHRvIFtwbGF5XXtAbGluayBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjcGxheUFuaW1hdGlvbn0uIEFuIG9iamVjdCByZXByZXNlbnRpbmdcclxuICogdGhlIG5hbWUgb2YgdGhlIGxheWVyIGNvbnRhaW5zIHRoZSBhbmltYXRpb24gdGhhdCB3YXMgcGxheWVkIGFuZCB0aGUgbmFtZSBvZlxyXG4gKiB0aGUgYW5pbWF0aW9uIHRoYXQgd2FzIHBsYXllZCB3aXRoIHRoZSBzaWduYXR1cmUge2xheWVyTmFtZTogc3RyaW5nLCBhbmltYXRpb25OYW1lOiBzdHJpbmd9XHJcbiAqIGlzIHN1cHBsaWVkIGFzIGFuIGFyZ3VtZW50IHRvIGxpc3RlbmVyIGZ1bmN0aW9ucy5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVFMucGF1c2U9b25QYXVzZUV2ZW50XSAtIE1lc3NhZ2UgdGhhdCBpcyBlbWl0dGVkIGFmdGVyXHJcbiAqIGVhY2ggY2FsbCB0byBbcGF1c2Vde0BsaW5rIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNwYXVzZUFuaW1hdGlvbn0uIEFuIG9iamVjdCByZXByZXNlbnRpbmdcclxuICogdGhlIG5hbWUgb2YgdGhlIGxheWVyIGNvbnRhaW5zIHRoZSBhbmltYXRpb24gdGhhdCB3YXMgcGF1c2VkIGFuZCB0aGUgbmFtZSBvZlxyXG4gKiB0aGUgYW5pbWF0aW9uIHRoYXQgd2FzIHBhdXNlZCB3aXRoIHRoZSBzaWduYXR1cmUge2xheWVyTmFtZTogc3RyaW5nLCBhbmltYXRpb25OYW1lOiBzdHJpbmd9XHJcbiAqIGlzIHN1cHBsaWVkIGFzIGFuIGFyZ3VtZW50IHRvIGxpc3RlbmVyIGZ1bmN0aW9ucy5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVFMucmVzdW1lPW9uUmVzdW1lRXZlbnRdIC0gTWVzc2FnZSB0aGF0IGlzIGVtaXR0ZWQgYWZ0ZXJcclxuICogZWFjaCBjYWxsIHRvIFtyZXN1bWVde0BsaW5rIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNyZXN1bWVBbmltYXRpb259LiBBbiBvYmplY3QgcmVwcmVzZW50aW5nXHJcbiAqIHRoZSBuYW1lIG9mIHRoZSBsYXllciBjb250YWlucyB0aGUgYW5pbWF0aW9uIHRoYXQgd2FzIHJlc3VtZWQgYW5kIHRoZSBuYW1lIG9mXHJcbiAqIHRoZSBhbmltYXRpb24gdGhhdCB3YXMgcmVzdW1lZCB3aXRoIHRoZSBzaWduYXR1cmUge2xheWVyTmFtZTogc3RyaW5nLCBhbmltYXRpb25OYW1lOiBzdHJpbmd9XHJcbiAqIGlzIHN1cHBsaWVkIGFzIGFuIGFyZ3VtZW50IHRvIGxpc3RlbmVyIGZ1bmN0aW9ucy5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVFMuaW50ZXJydXB0PW9uSW50ZXJydXB0RXZlbnRdIC0gTWVzc2FnZSB0aGF0IGlzIGVtaXR0ZWRcclxuICogaWYgdGhlcmUgaXMgYSBjdXJyZW50IHNwZWVjaCBpbiBwcm9ncmVzcyBhbmQgW3BsYXlde0BsaW5rIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNwbGF5QW5pbWF0aW9ufVxyXG4gKiBvciBbcmVzdW1lXXtAbGluayBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjcmVzdW1lQW5pbWF0aW9ufSBhcmUgZXhlY3V0ZWQgZm9yIGEgbmV3IHNwZWVjaC5cclxuICogQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgbmFtZSBvZiB0aGUgbGF5ZXIgY29udGFpbnMgdGhlIGFuaW1hdGlvbiB0aGF0IHdhc1xyXG4gKiBpbnRlcnJ1cHRlZCBhbmQgdGhlIG5hbWUgb2YgdGhlIGFuaW1hdGlvbiB0aGF0IHdhcyBpbnRlcnJ1cHRlZCB3aXRoIHRoZSBzaWduYXR1cmVcclxuICoge2xheWVyTmFtZTogc3RyaW5nLCBhbmltYXRpb25OYW1lOiBzdHJpbmd9IGlzIHN1cHBsaWVkIGFzIGFuIGFyZ3VtZW50IHRvIGxpc3RlbmVyXHJcbiAqIGZ1bmN0aW9ucy5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVFMuc3RvcD1vblN0b3BFdmVudF0gLSBNZXNzYWdlIHRoYXQgaXMgZW1pdHRlZCBhZnRlclxyXG4gKiBlYWNoIGNhbGwgdG8gW3N0b3Bde0BsaW5rIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNzdG9wQW5pbWF0aW9ufSBhbmQgd2hlbiBhIHNwZWVjaCByZWFjaGVzXHJcbiAqIHRoZSBlbmQgb2YgcGxheWJhY2suIEFuIG9iamVjdCByZXByZXNlbnRpbmdcclxuICogdGhlIG5hbWUgb2YgdGhlIGxheWVyIGNvbnRhaW5zIHRoZSBhbmltYXRpb24gdGhhdCB3YXMgc3RvcHBlZCBhbmQgdGhlIG5hbWUgb2ZcclxuICogdGhlIGFuaW1hdGlvbiB0aGF0IHdhcyBzdG9wcGVkIHdpdGggdGhlIHNpZ25hdHVyZSB7bGF5ZXJOYW1lOiBzdHJpbmcsIGFuaW1hdGlvbk5hbWU6IHN0cmluZ31cclxuICogaXMgc3VwcGxpZWQgYXMgYW4gYXJndW1lbnQgdG8gbGlzdGVuZXIgZnVuY3Rpb25zLlxyXG4gKi9cclxuY2xhc3MgQW5pbWF0aW9uRmVhdHVyZSBleHRlbmRzIEFic3RyYWN0SG9zdEZlYXR1cmUge1xyXG4gIC8qKlxyXG4gICAqIEBjb25zdHJ1Y3RvclxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtjb3JlL0hvc3RPYmplY3R9IGhvc3QgLSBIb3N0IG9iamVjdCB0aGF0IG93bnMgdGhlIGZlYXR1cmUuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoaG9zdCkge1xyXG4gICAgc3VwZXIoaG9zdCk7XHJcblxyXG4gICAgdGhpcy5fbGF5ZXJzID0gW107XHJcbiAgICB0aGlzLl9sYXllck1hcCA9IHt9O1xyXG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNYWtlIHN1cmUgYSBzdXBwbGllZCBsYXllciBpbmRleCBpcyB3aXRoaW4gdGhlIHJhbmdlIG9mIGxheWVycy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtleGlzdGluZz10cnVlXSAtIFdoZXRoZXIgdGhlIGluZGV4IHJlcHJlc2VudHMgYW5kIGV4aXN0aW5nXHJcbiAgICogbGF5ZXIgb3IgYSBuZXcgbGF5ZXIgdG8gYmUgYWRkZWQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyPX1cclxuICAgKi9cclxuICBfdmFsaWRhdGVJbmRleChpbmRleCwgZXhpc3RpbmcgPSB0cnVlKSB7XHJcbiAgICAvLyBJbmRleCBpcyBpbnZhbGlkIGlmIHRoZXJlIGFyZSBubyBsYXllcnMgYW5kIHdlJ3JlIGNoZWNraW5nIGZvciBhbiBleGlzdGluZyBsYXllciBpbmRleFxyXG4gICAgaWYgKHRoaXMuX2xheWVycy5sZW5ndGggPT09IDAgJiYgZXhpc3RpbmcpIHtcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBsYXN0SW5kZXggPSBleGlzdGluZyA/IHRoaXMuX2xheWVycy5sZW5ndGggLSAxIDogdGhpcy5fbGF5ZXJzLmxlbmd0aDtcclxuXHJcbiAgICAvLyBDb3VudCBmcm9tIHRoZSBlbmQgb2YgdGhlIGFycmF5IGZvciBuZWdhdGl2ZSBpbmRpY2VzXHJcbiAgICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgIGluZGV4ID0gbGFzdEluZGV4ICsgaW5kZXggKyAxO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiBsYXN0SW5kZXgpIHtcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBpbmRleDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlLWV2YWx1YXRlIGludGVybmFsIHdlaWdodCB2YWx1ZXMgb2YgbGF5ZXJzIHN0YXJ0aW5nIGZyb20gdGhlIHRvcCBvZiB0aGVcclxuICAgKiBzdGFjay4gT3ZlcnJpZGUgbGF5ZXJzJyB3ZWlnaHRzIGFmZmVjdCB0aGUgdmFsdWVzIG9mIGFsbCBsYXllcnMgbG93ZXIgaW4gdGhlXHJcbiAgICogc3RhY2suXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF91cGRhdGVJbnRlcm5hbFdlaWdodHMoKSB7XHJcbiAgICBjb25zdCBudW1MYXllcnMgPSB0aGlzLl9sYXllcnMubGVuZ3RoO1xyXG4gICAgbGV0IHdlaWdodE11bHRpcGxpZXIgPSAxO1xyXG5cclxuICAgIC8vIFVwZGF0ZSBpbnRlcm5hbCB3ZWlnaHQgdmFsdWVzIG9uIGxheWVycyBpbiByZXZlcnNlIG9yZGVyXHJcbiAgICBmb3IgKGxldCBpID0gbnVtTGF5ZXJzIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllcnNbaV07XHJcbiAgICAgIGxheWVyLnVwZGF0ZUludGVybmFsV2VpZ2h0KHdlaWdodE11bHRpcGxpZXIpO1xyXG5cclxuICAgICAgLy8gSWYgdGhlIGxheWVyIGlzIG92ZXJyaWRlLCB1cGRhdGUgdGhlIG11bHRpcGxpZXIgd2l0aCB0aGUgcmVtYWluZGVyIG9mIHRoZSBmdWxsIHdlaWdodFxyXG4gICAgICBpZiAobGF5ZXIuYmxlbmRNb2RlID09PSBMYXllckJsZW5kTW9kZXMuT3ZlcnJpZGUgJiYgbGF5ZXIuY3VycmVudFN0YXRlKSB7XHJcbiAgICAgICAgd2VpZ2h0TXVsdGlwbGllciAqPSAxIC0gbGF5ZXIuY3VycmVudFN0YXRlLmludGVybmFsV2VpZ2h0O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gYSBuZXcgaW5zdGFuY2Ugb2YgYSBTaW5nbGVTdGF0ZS5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gcGFzcyB0byB0aGUgU2luZ2xlU3RhdGUgY29uc3RydWN0b3IuXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRpb25zLm5hbWUgLSBOYW1lIGZvciB0aGUgYW5pbWF0aW9uIHN0YXRlLiBOYW1lcyBtdXN0IGJlXHJcbiAgICogdW5pcXVlIGZvciB0aGUgbGF5ZXIgdGhlIHN0YXRlIGlzIGFwcGxpZWQgdG8uXHJcbiAgICogQHBhcmFtIHt3ZWlnaHR9IFtvcHRpb25zLndlaWdodD0wXSAtIFRoZSAwLTEgYW1vdW50IG9mIGluZmx1ZW5jZSB0aGUgc3RhdGUgd2lsbCBoYXZlLlxyXG4gICAqIEBwYXJhbSB7dGltZVNjYWxlfSBbb3B0aW9ucy50aW1lU2NhbGU9MV0gLSBGYWN0b3IgdG8gc2NhbGUgdGhlIHBsYXliYWNrIHNwZWVkIG9mIHRoZVxyXG4gICAqIGFuaW1hdGlvbi5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubG9vcENvdW50PUluZmluaXR5XSAtIE51bWJlciBvZiB0aW1lcyB0aGUgYW5pbWF0aW9uIHNob3VsZFxyXG4gICAqIHJlcGVhdCBiZWZvcmUgZmluaXNoaW5nLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5ibGVuZE1vZGU9TGF5ZXJCbGVuZE1vZGVzW0RlZmF1bHRMYXllckJsZW5kTW9kZV1dIC0gVHlwZSBvZlxyXG4gICAqIGJsZW5kaW5nIHRoZSBhbmltYXRpb24gc2hvdWxkIHVzZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtjb3JlL1NpbmdsZVN0YXRlfVxyXG4gICAqL1xyXG4gIF9jcmVhdGVTaW5nbGVTdGF0ZShvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gbmV3IFNpbmdsZVN0YXRlKG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgbmV3IGluc3RhbmNlIG9mIGEgRnJlZUJsZW5kU3RhdGUuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIHRvIHBhc3MgdG8gdGhlIEZyZWVCbGVuZFN0YXRlIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0aW9ucy5uYW1lIC0gTmFtZSBmb3IgdGhlIGFuaW1hdGlvbiBzdGF0ZS4gTmFtZXMgbXVzdCBiZVxyXG4gICAqIHVuaXF1ZSBmb3IgdGhlIGxheWVyIHRoZSBzdGF0ZSBpcyBhcHBsaWVkIHRvLlxyXG4gICAqIEBwYXJhbSB7d2VpZ2h0fSBbb3B0aW9ucy53ZWlnaHQ9MF0gLSBUaGUgMC0xIGFtb3VudCBvZiBpbmZsdWVuY2UgdGhlIHN0YXRlIHdpbGwgaGF2ZS5cclxuICAgKiBAcGFyYW0ge3RpbWVTY2FsZX0gW29wdGlvbnMudGltZVNjYWxlPTFdIC0gRmFjdG9yIHRvIHNjYWxlIHRoZSBwbGF5YmFjayBzcGVlZCBvZiB0aGVcclxuICAgKiBhbmltYXRpb24uXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxvb3BDb3VudD1JbmZpbml0eV0gLSBOdW1iZXIgb2YgdGltZXMgdGhlIGFuaW1hdGlvbiBzaG91bGRcclxuICAgKiByZXBlYXQgYmVmb3JlIGZpbmlzaGluZy5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYmxlbmRNb2RlPUxheWVyQmxlbmRNb2Rlc1tEZWZhdWx0TGF5ZXJCbGVuZE1vZGVdXSAtIFR5cGUgb2ZcclxuICAgKiBibGVuZGluZyB0aGUgYW5pbWF0aW9uIHNob3VsZCB1c2UuXHJcbiAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gW29wdGlvbnMuYmxlbmRTdGF0ZU9wdGlvbnNdIC0gQXJyYXkgb2Ygb3B0aW9ucyB1c2VkIHRvIGNyZWF0ZSB0aGVcclxuICAgKiBibGVuZCBzdGF0ZXMgZm9yIHRoaXMgY29udGFpbmVyLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0ZyZWVCbGVuZFN0YXRlfVxyXG4gICAqL1xyXG4gIF9jcmVhdGVGcmVlQmxlbmRTdGF0ZShvcHRpb25zKSB7XHJcbiAgICBjb25zdCB7YmxlbmRTdGF0ZU9wdGlvbnMgPSBbXX0gPSBvcHRpb25zO1xyXG5cclxuICAgIGNvbnN0IGJsZW5kU3RhdGVzID0gW107XHJcbiAgICBibGVuZFN0YXRlT3B0aW9ucy5mb3JFYWNoKGJsZW5kT3B0aW9ucyA9PiB7XHJcbiAgICAgIGJsZW5kU3RhdGVzLnB1c2goXHJcbiAgICAgICAgdGhpcy5fY3JlYXRlU2luZ2xlU3RhdGUoey4uLmJsZW5kT3B0aW9ucywgYmxlbmRNb2RlOiBvcHRpb25zLmJsZW5kTW9kZX0pXHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gbmV3IEZyZWVCbGVuZFN0YXRlKG9wdGlvbnMsIGJsZW5kU3RhdGVzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiBhIG5ldyBpbnN0YW5jZSBvZiBhIFF1ZXVlU3RhdGUuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIHRvIHBhc3MgdG8gdGhlIFF1ZXVlU3RhdGUgY29uc3RydWN0b3IuXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRpb25zLm5hbWUgLSBOYW1lIGZvciB0aGUgYW5pbWF0aW9uIHN0YXRlLiBOYW1lcyBtdXN0IGJlXHJcbiAgICogdW5pcXVlIGZvciB0aGUgbGF5ZXIgdGhlIHN0YXRlIGlzIGFwcGxpZWQgdG8uXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLndlaWdodD0wXSAtIFRoZSAwLTEgYW1vdW50IG9mIGluZmx1ZW5jZSB0aGUgc3RhdGUgd2lsbCBoYXZlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0aW9ucy50cmFuc2l0aW9uVGltZSAtIFRoZSBhbW91bnQgb2YgdGltZSBpdCB0YWtlcyB0byB0cmFuc2l0aW9uXHJcbiAgICogYmV0d2VlbiBxdWV1ZWQgc3RhdGVzLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5ibGVuZE1vZGU9TGF5ZXJCbGVuZE1vZGVzW0RlZmF1bHRMYXllckJsZW5kTW9kZV1dIC0gVHlwZSBvZlxyXG4gICAqIGJsZW5kaW5nIHRoZSBhbmltYXRpb24gc2hvdWxkIHVzZS5cclxuICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBbb3B0aW9ucy5xdWV1ZU9wdGlvbnNdIC0gQXJyYXkgb2Ygb3B0aW9ucyB1c2VkIHRvIGNyZWF0ZSB0aGVcclxuICAgKiBxdWV1ZSBzdGF0ZXMgZm9yIHRoaXMgY29udGFpbmVyLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge1F1ZXVlU3RhdGV9XHJcbiAgICovXHJcbiAgX2NyZWF0ZVF1ZXVlU3RhdGUob3B0aW9ucykge1xyXG4gICAgY29uc3Qge3F1ZXVlT3B0aW9ucyA9IFtdfSA9IG9wdGlvbnM7XHJcblxyXG4gICAgY29uc3QgcXVldWVTdGF0ZXMgPSBxdWV1ZU9wdGlvbnMubWFwKHF1ZXVlT3B0aW9uID0+XHJcbiAgICAgIHRoaXMuX2NyZWF0ZVNpbmdsZVN0YXRlKHtcclxuICAgICAgICB0cmFuc2l0aW9uVGltZTogb3B0aW9ucy50cmFuc2l0aW9uVGltZSxcclxuICAgICAgICAuLi5xdWV1ZU9wdGlvbixcclxuICAgICAgICBibGVuZE1vZGU6IG9wdGlvbnMuYmxlbmRNb2RlLFxyXG4gICAgICB9KVxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gbmV3IFF1ZXVlU3RhdGUob3B0aW9ucywgcXVldWVTdGF0ZXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgbmV3IGluc3RhbmNlIG9mIGEgQmxlbmQxZFN0YXRlLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyB0byBwYXNzIHRvIHRoZSBCbGVuZDFkU3RhdGUgY29uc3RydWN0b3IuXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRpb25zLm5hbWUgLSBOYW1lIGZvciB0aGUgYW5pbWF0aW9uIHN0YXRlLiBOYW1lcyBtdXN0IGJlXHJcbiAgICogdW5pcXVlIGZvciB0aGUgbGF5ZXIgdGhlIHN0YXRlIGlzIGFwcGxpZWQgdG8uXHJcbiAgICogQHBhcmFtIHt3ZWlnaHR9IFtvcHRpb25zLndlaWdodD0wXSAtIFRoZSAwLTEgYW1vdW50IG9mIGluZmx1ZW5jZSB0aGUgc3RhdGUgd2lsbCBoYXZlLlxyXG4gICAqIEBwYXJhbSB7dGltZVNjYWxlfSBbb3B0aW9ucy50aW1lU2NhbGU9MV0gLSBGYWN0b3IgdG8gc2NhbGUgdGhlIHBsYXliYWNrIHNwZWVkIG9mIHRoZVxyXG4gICAqIGFuaW1hdGlvbi5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubG9vcENvdW50PUluZmluaXR5XSAtIE51bWJlciBvZiB0aW1lcyB0aGUgYW5pbWF0aW9uIHNob3VsZFxyXG4gICAqIHJlcGVhdCBiZWZvcmUgZmluaXNoaW5nLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5ibGVuZE1vZGU9TGF5ZXJCbGVuZE1vZGVzW0RlZmF1bHRMYXllckJsZW5kTW9kZV1dIC0gVHlwZSBvZlxyXG4gICAqIGJsZW5kaW5nIHRoZSBhbmltYXRpb24gc2hvdWxkIHVzZS5cclxuICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBbb3B0aW9ucy5ibGVuZFN0YXRlT3B0aW9uc10gLSBBcnJheSBvZiBvcHRpb25zIHVzZWQgdG8gY3JlYXRlIHRoZVxyXG4gICAqIGJsZW5kIHN0YXRlcyBmb3IgdGhpcyBjb250YWluZXIuXHJcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW29wdGlvbnMuYmxlbmRUaHJlc2hvbGRzXSAtIEFycmF5IG9mIG51bWJlcnMgdXNlZCB0byBzZXQgdGhlXHJcbiAgICogdGhyZXNob2xkcyBmb3IgZWFjaCBibGVuZCBzdGF0ZSBpbiB0aGlzIGNvbnRhaW5lci5cclxuICAgKiBAcGFyYW0ge0FycmF5Ljxib29sZWFuPn0gW29wdGlvbnMuYmxlbmRNYXRjaFBoYXNlcz1bXV0gLSBPcHRpb25hbCBhcnJheSBvZiBib29sZWFucyB1c2VkIHRvXHJcbiAgICogc2V0IHdoZXRoZXIgb3Igbm90IGVhY2ggYmxlbmQgc3RhdGUgaW4gdGhpcyBjb250YWluZXIgd2lsbCBtYXRjaCBwaGFzZXMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7QmxlbmQxZFN0YXRlfVxyXG4gICAqL1xyXG4gIF9jcmVhdGVCbGVuZDFkU3RhdGUob3B0aW9ucykge1xyXG4gICAgY29uc3Qge2JsZW5kU3RhdGVPcHRpb25zID0gW119ID0gb3B0aW9ucztcclxuICAgIGNvbnN0IHtibGVuZFRocmVzaG9sZHMgPSBbXX0gPSBvcHRpb25zO1xyXG4gICAgY29uc3Qge2JsZW5kTWF0Y2hQaGFzZXMgPSBbXX0gPSBvcHRpb25zO1xyXG5cclxuICAgIGNvbnN0IGJsZW5kU3RhdGVzID0gW107XHJcbiAgICBibGVuZFN0YXRlT3B0aW9ucy5mb3JFYWNoKGJsZW5kT3B0aW9ucyA9PiB7XHJcbiAgICAgIGJsZW5kU3RhdGVzLnB1c2goXHJcbiAgICAgICAgdGhpcy5fY3JlYXRlU2luZ2xlU3RhdGUoey4uLmJsZW5kT3B0aW9ucywgYmxlbmRNb2RlOiBvcHRpb25zLmJsZW5kTW9kZX0pXHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gbmV3IEJsZW5kMWRTdGF0ZShcclxuICAgICAgb3B0aW9ucyxcclxuICAgICAgYmxlbmRTdGF0ZXMsXHJcbiAgICAgIGJsZW5kVGhyZXNob2xkcyxcclxuICAgICAgYmxlbmRNYXRjaFBoYXNlc1xyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiBhIG5ldyBpbnN0YW5jZSBvZiBhIEJsZW5kMmRTdGF0ZS5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gcGFzcyB0byB0aGUgQmxlbmQxZFN0YXRlIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0aW9ucy5uYW1lIC0gTmFtZSBmb3IgdGhlIGFuaW1hdGlvbiBzdGF0ZS4gTmFtZXMgbXVzdCBiZVxyXG4gICAqIHVuaXF1ZSBmb3IgdGhlIGxheWVyIHRoZSBzdGF0ZSBpcyBhcHBsaWVkIHRvLlxyXG4gICAqIEBwYXJhbSB7d2VpZ2h0fSBbb3B0aW9ucy53ZWlnaHQ9MF0gLSBUaGUgMC0xIGFtb3VudCBvZiBpbmZsdWVuY2UgdGhlIHN0YXRlIHdpbGwgaGF2ZS5cclxuICAgKiBAcGFyYW0ge3RpbWVTY2FsZX0gW29wdGlvbnMudGltZVNjYWxlPTFdIC0gRmFjdG9yIHRvIHNjYWxlIHRoZSBwbGF5YmFjayBzcGVlZCBvZiB0aGVcclxuICAgKiBhbmltYXRpb24uXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxvb3BDb3VudD1JbmZpbml0eV0gLSBOdW1iZXIgb2YgdGltZXMgdGhlIGFuaW1hdGlvbiBzaG91bGRcclxuICAgKiByZXBlYXQgYmVmb3JlIGZpbmlzaGluZy5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYmxlbmRNb2RlPUxheWVyQmxlbmRNb2Rlc1tEZWZhdWx0TGF5ZXJCbGVuZE1vZGVdXSAtIFR5cGUgb2ZcclxuICAgKiBibGVuZGluZyB0aGUgYW5pbWF0aW9uIHNob3VsZCB1c2UuXHJcbiAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gW29wdGlvbnMuYmxlbmRTdGF0ZU9wdGlvbnNdIC0gQXJyYXkgb2Ygb3B0aW9ucyB1c2VkIHRvIGNyZWF0ZSB0aGVcclxuICAgKiBibGVuZCBzdGF0ZXMgZm9yIHRoaXMgY29udGFpbmVyLlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gW29wdGlvbnMuYmxlbmRUaHJlc2hvbGRzXSAtIEFycmF5IG9mIEFycmF5IG9mIG51bWJlcnMgdXNlZCB0byBzZXQgdGhlXHJcbiAgICogdGhyZXNob2xkcyBmb3IgZWFjaCBibGVuZCBzdGF0ZSBpbiB0aGlzIGNvbnRhaW5lci5cclxuICAgKiBAcGFyYW0ge0FycmF5Ljxib29sZWFuPn0gW29wdGlvbnMuYmxlbmRNYXRjaFBoYXNlcz1bXV0gLSBPcHRpb25hbCBhcnJheSBvZiBib29sZWFucyB1c2VkIHRvXHJcbiAgICogc2V0IHdoZXRoZXIgb3Igbm90IGVhY2ggYmxlbmQgc3RhdGUgaW4gdGhpcyBjb250YWluZXIgd2lsbCBtYXRjaCBwaGFzZXMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7QmxlbmQxZFN0YXRlfVxyXG4gICAqL1xyXG4gIF9jcmVhdGVCbGVuZDJkU3RhdGUob3B0aW9ucykge1xyXG4gICAgY29uc3Qge2JsZW5kU3RhdGVPcHRpb25zID0gW119ID0gb3B0aW9ucztcclxuICAgIGNvbnN0IHtibGVuZFRocmVzaG9sZHMgPSBbXX0gPSBvcHRpb25zO1xyXG4gICAgY29uc3Qge2JsZW5kTWF0Y2hQaGFzZXMgPSBbXX0gPSBvcHRpb25zO1xyXG5cclxuICAgIGNvbnN0IGJsZW5kU3RhdGVzID0gW107XHJcbiAgICBibGVuZFN0YXRlT3B0aW9ucy5mb3JFYWNoKGJsZW5kT3B0aW9ucyA9PiB7XHJcbiAgICAgIGJsZW5kU3RhdGVzLnB1c2goXHJcbiAgICAgICAgdGhpcy5fY3JlYXRlU2luZ2xlU3RhdGUoey4uLmJsZW5kT3B0aW9ucywgYmxlbmRNb2RlOiBvcHRpb25zLmJsZW5kTW9kZX0pXHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gbmV3IEJsZW5kMmRTdGF0ZShcclxuICAgICAgb3B0aW9ucyxcclxuICAgICAgYmxlbmRTdGF0ZXMsXHJcbiAgICAgIGJsZW5kVGhyZXNob2xkcyxcclxuICAgICAgYmxlbmRNYXRjaFBoYXNlc1xyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiBhIG5ldyBpbnN0YW5jZSBvZiBhIFJhbmRvbUFuaW1hdGlvblN0YXRlLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyB0byBwYXNzIHRvIHRoZSBSYW5kb21BbmltYXRpb25TdGF0ZSBjb25zdHJ1Y3Rvci5cclxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdGlvbnMubmFtZSAtIE5hbWUgZm9yIHRoZSBhbmltYXRpb24gc3RhdGUuIE5hbWVzIG11c3QgYmVcclxuICAgKiB1bmlxdWUgZm9yIHRoZSBsYXllciB0aGUgc3RhdGUgaXMgYXBwbGllZCB0by5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucGxheUludGVydmFsPTNdIC0gVGhlIGJhc2UgYW5pbWF0aW9uIHBsYXliYWNrIGludGVydmFsLlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IFtvcHRpb25zLnN1YlN0YXRlT3B0aW9uc10gLSBBcnJheSBvZiBvcHRpb25zIHVzZWQgdG8gY3JlYXRlIHRoZVxyXG4gICAqIHN1YiBzdGF0ZXMgZm9yIHRoaXMgY29udGFpbmVyLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge1JhbmRvbUFuaW1hdGlvblN0YXRlfVxyXG4gICAqL1xyXG4gIF9jcmVhdGVSYW5kb21BbmltYXRpb25TdGF0ZShvcHRpb25zKSB7XHJcbiAgICBjb25zdCB7c3ViU3RhdGVPcHRpb25zID0gW119ID0gb3B0aW9ucztcclxuXHJcbiAgICBjb25zdCBzdWJTdGF0ZXMgPSBbXTtcclxuICAgIHN1YlN0YXRlT3B0aW9ucy5mb3JFYWNoKHN1YlN0YXRlT3B0aW9ucyA9PiB7XHJcbiAgICAgIHN1YlN0YXRlcy5wdXNoKFxyXG4gICAgICAgIHRoaXMuX2NyZWF0ZVNpbmdsZVN0YXRlKHtcclxuICAgICAgICAgIC4uLnN1YlN0YXRlT3B0aW9ucyxcclxuICAgICAgICAgIGJsZW5kTW9kZTogb3B0aW9ucy5ibGVuZE1vZGUsXHJcbiAgICAgICAgfSlcclxuICAgICAgKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBuZXcgUmFuZG9tQW5pbWF0aW9uU3RhdGUob3B0aW9ucywgc3ViU3RhdGVzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1ha2Ugc3VyZSB0aGUgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBleGlzdHMgYW5kIHJldHVybiBhIHVuaXF1ZSB2ZXJzaW9uXHJcbiAgICogb2YgdGhlIGFuaW1hdGlvbiBuYW1lIHN1cHBsaWVkIGZvciB0aGF0IGxheWVyLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0byBjaGVjayBhZ2FpbnN0LlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbmltYXRpb25OYW1lIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRvIHZhbGlkYXRlLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge3N0cmluZ30gVmFsaWRhdGVkIGFuaW1hdGlvbiBuYW1lLlxyXG4gICAqL1xyXG4gIF92YWxpZGF0ZU5ld0FuaW1hdGlvbihsYXllck5hbWUsIGFuaW1hdGlvbk5hbWUpIHtcclxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgbGF5ZXJOYW1lIGlzIHZhbGlkXHJcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW2xheWVyTmFtZV07XHJcblxyXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBDYW5ub3QgYWRkIGFuaW1hdGlvbiB0byBsYXllciAke2xheWVyTmFtZX0gZnJvbSBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5vIGxheWVyIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBhbmltYXRpb25OYW1lIGlzIHVuaXF1ZVxyXG4gICAgY29uc3QgbmFtZSA9IFV0aWxzLmdldFVuaXF1ZU5hbWUoYW5pbWF0aW9uTmFtZSwgbGF5ZXIuZ2V0U3RhdGVOYW1lcygpKTtcclxuXHJcbiAgICBpZiAobmFtZSAhPT0gYW5pbWF0aW9uTmFtZSkge1xyXG4gICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgYEFuaW1hdGlvbiBuYW1lICR7YW5pbWF0aW9uTmFtZX0gaXMgbm90IHVuaXF1ZSBmb3IgbGF5ZXIgJHtsYXllci5uYW1lfS4gQW5pbWF0aW9uIHdpbGwgYmUgcmVuYW1lZCB0byAke25hbWV9LmBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmFtZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgd2hldGhlciBvciBub3QgYWxsIGFuaW1hdGlvbnMgYXJlIHBhdXNlZC5cclxuICAgKlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGdldCBwYXVzZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcGF1c2VkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyBhbiBhcnJheSBvZiBuYW1lcyBvZiBhbmltYXRpb24gbGF5ZXJzLlxyXG4gICAqXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHR5cGUge0FycmF5LjxzdHJpbmc+fVxyXG4gICAqL1xyXG4gIGdldCBsYXllcnMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbGF5ZXJzLm1hcChsYXllciA9PiBsYXllci5uYW1lKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhbmQgc3RvcmUgYSBuZXcgYW5pbWF0aW9uIGxheWVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lPSdOZXdMYXllciddIC0gTmFtZSBmb3IgdGhlIGxheWVyLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gLSBPcHRpb25zIHRvIHBhc3MgdG8ge0BsaW5rIEFuaW1hdGlvbkxheWVyI2NvbnN0cnVjdG9yfVxyXG4gICAqIEBwYXJhbSB7aW5kZXg9fSBpbmRleCAtIEluZGV4IHRvIGluc2VydCB0aGUgbmV3IGxheWVyIGF0LiBJZiBub25lIGlzIHByb3ZpZGVkXHJcbiAgICogaXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgZW5kIG9mIHRoZSBzdGFjay5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IEluZGV4IG9mIHRoZSBuZXcgbGF5ZXIuXHJcbiAgICovXHJcbiAgYWRkTGF5ZXIobmFtZSA9ICdOZXdMYXllcicsIG9wdGlvbnMgPSB7fSwgaW5kZXgpIHtcclxuICAgIGNvbnN0IG51bUxheWVycyA9IHRoaXMuX2xheWVycy5sZW5ndGg7XHJcbiAgICBsZXQgbGF5ZXJJbmRleCA9IGluZGV4O1xyXG5cclxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgZ2l2ZW4gaW5kZXggaXMgd2l0aGluIHRoZSByYW5nZSBvZiBsYXllcnNcclxuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkIHx8IGluZGV4ID09PSAtMSkge1xyXG4gICAgICBsYXllckluZGV4ID0gdGhpcy5fbGF5ZXJzLmxlbmd0aDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGxheWVySW5kZXggPSB0aGlzLl92YWxpZGF0ZUluZGV4KGluZGV4LCBmYWxzZSk7XHJcblxyXG4gICAgICBpZiAobGF5ZXJJbmRleCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgLy8gSW5zZXJ0IGF0IHRoZSBiZWdpbm5pbmcgaWYgdGhlIHVzZXIgcGFzc2VkIGluIGEgbmVnYXRpdmUgaW5kZXhcclxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgICBsYXllckluZGV4ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlIGFwcGVuZCB0byB0aGUgZW5kXHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBsYXllckluZGV4ID0gdGhpcy5fbGF5ZXJzLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICAgIGBJbmRleCAke2luZGV4fSBpcyBpbnZhbGlkIGZvciBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5ldyBsYXllciB3aWxsIGJlIGFkZGVkIGF0IHRoZSBjbG9zZXN0IHZhbGlkIGluZGV4OiAke2xheWVySW5kZXh9LmBcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBsYXllciBuYW1lIGlzIHVuaXF1ZVxyXG4gICAgY29uc3QgbGF5ZXJOYW1lID0gVXRpbHMuZ2V0VW5pcXVlTmFtZShuYW1lLCBPYmplY3Qua2V5cyh0aGlzLl9sYXllck1hcCkpO1xyXG5cclxuICAgIGlmIChuYW1lICE9PSBsYXllck5hbWUpIHtcclxuICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgIGBMYXllciBuYW1lICR7bmFtZX0gaXMgbm90IHVuaXF1ZS4gTmV3IGxheWVyIHdpbGwgYmUgYWRkZWQgd2l0aCB0aGUgbmFtZSAke2xheWVyTmFtZX0uYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGxheWVyID0gbmV3IEFuaW1hdGlvbkxheWVyKHsuLi5vcHRpb25zLCBuYW1lOiBsYXllck5hbWV9KTtcclxuICAgIHRoaXMuX2xheWVyTWFwW2xheWVyTmFtZV0gPSBsYXllcjtcclxuXHJcbiAgICBpZiAobGF5ZXJJbmRleCA9PT0gbnVtTGF5ZXJzKSB7XHJcbiAgICAgIHRoaXMuX2xheWVycy5wdXNoKGxheWVyKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX2xheWVycy5zcGxpY2UobGF5ZXJJbmRleCwgMCwgbGF5ZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE5vdGlmeSB0aGF0IGEgbGF5ZXIgaGFzIGJlZW4gYWRkZWQgdG8gdGhlIGZlYXR1cmVcclxuICAgIGNvbnN0IGV2ZW50RGF0YSA9IHtuYW1lOiBsYXllck5hbWUsIGluZGV4OiBsYXllckluZGV4fTtcclxuICAgIHRoaXMuZW1pdCh0aGlzLmNvbnN0cnVjdG9yLkVWRU5UUy5hZGRMYXllciwgZXZlbnREYXRhKTtcclxuXHJcbiAgICByZXR1cm4gZXZlbnREYXRhO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIGFuIGFuaW1hdGlvbiBsYXllciBmcm9tIHRoZSBzdGFjay4gQW5pbWF0aW9ucyBvbiB0aGlzIGxheWVyIHdpbGwgbm9cclxuICAgKiBsb25nZXIgYmUgZXZhbHVhdGVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIGZvciB0aGUgbGF5ZXIgdG8gcmVtb3ZlLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHJlbW92YWwgd2FzIHN1Y2Nlc3NmdWwuXHJcbiAgICovXHJcbiAgcmVtb3ZlTGF5ZXIobmFtZSkge1xyXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllck1hcFtuYW1lXTtcclxuXHJcbiAgICBpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgYERpZCBub3QgcmVtb3ZlIGxheWVyICR7bmFtZX0gZnJvbSBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5vIGxheWVyIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gXHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBsYXllci5kaXNjYXJkKCk7XHJcblxyXG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9sYXllcnMuaW5kZXhPZihsYXllcik7XHJcbiAgICB0aGlzLl9sYXllcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgIGRlbGV0ZSB0aGlzLl9sYXllck1hcFtuYW1lXTtcclxuXHJcbiAgICAvLyBOb3RpZnkgdGhhdCBhIGxheWVyIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgZmVhdHVyZVxyXG4gICAgdGhpcy5lbWl0KHRoaXMuY29uc3RydWN0b3IuRVZFTlRTLnJlbW92ZUxheWVyLCB7bmFtZSwgaW5kZXh9KTtcclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlLW9yZGVyIHRoZSBsYXllciBzdGFjayBzbyB0aGF0IHRoZSBsYXllciB3aXRoIHRoZSBnaXZlbiBuYW1lIGlzIHBvc2l0aW9uZWRcclxuICAgKiBhdCB0aGUgZ2l2ZW4gaW5kZXguXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRvIG1vdmUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gTmV3IGluZGV4IHRvIHBvc2l0aW9uIHRoZSBsYXllciBhdC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBuZXcgaW5kZXggb2YgdGhlIGxheWVyXHJcbiAgICovXHJcbiAgbW92ZUxheWVyKG5hbWUsIGluZGV4KSB7XHJcbiAgICAvLyBNYWtlIHN1cmUgdGhlIG5hbWUgaXMgdmFsaWRcclxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJNYXBbbmFtZV07XHJcblxyXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBDYW5ub3QgbW92ZSBsYXllciAke25hbWV9IGZyb20gaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBsYXllciBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgaW5kZXggZmFsbHMgaW4gdGhlIHJhbmdlIG9mIGV4aXN0aW5nIGxheWVyc1xyXG4gICAgY29uc3QgbGF5ZXJJbmRleCA9IHRoaXMuX3ZhbGlkYXRlSW5kZXgoaW5kZXgsIHRydWUpO1xyXG4gICAgY29uc3QgbGFzdEluZGV4ID0gdGhpcy5fbGF5ZXJzLmxlbmd0aCAtIDE7XHJcblxyXG4gICAgaWYgKGxheWVySW5kZXggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYENhbm5vdCBtb3ZlIGxheWVyICR7bmFtZX0gZnJvbSBob3N0ICR7dGhpcy5faG9zdC5pZH0gdG8gaW5kZXggJHtpbmRleH0uIEluZGV4IG11c3QgYmUgaW4gdGhlIDAgLSAke2xhc3RJbmRleH0gcmFuZ2UuYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHRoaXMuX2xheWVycy5pbmRleE9mKGxheWVyKTtcclxuICAgIGlmIChjdXJyZW50SW5kZXggPT09IGxheWVySW5kZXgpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlbW92ZSBmcm9tIHRoZSBjdXJyZW50IHBvc2l0aW9uXHJcbiAgICB0aGlzLl9sYXllcnMuc3BsaWNlKGN1cnJlbnRJbmRleCwgMSk7XHJcblxyXG4gICAgLy8gSW5zZXJ0IGF0IHRoZSBuZXcgcG9zaXRpb25cclxuICAgIGlmIChsYXllckluZGV4ID09PSBsYXN0SW5kZXgpIHtcclxuICAgICAgdGhpcy5fbGF5ZXJzLnB1c2gobGF5ZXIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fbGF5ZXJzLnNwbGljZShsYXllckluZGV4LCAwLCBsYXllcik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGxheWVySW5kZXg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgdGhlIG5hbWUgb2YgYSBsYXllci4gTmFtZXMgbXVzdCBiZSB1bmlxdWUsIGlmIHRoZSBuZXcgbmFtZSBpcyBub3RcclxuICAgKiB1bmlxdWUgaXQgd2lsbCBoYXZlIHRyYWlsaW5nIG51bWJlcnMgYXBwZW5kZWQgdW50aWwgaXQgaXMgdW5pcXVlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGN1cnJlbnROYW1lIC0gQ3VycmVudCBuYW1lIG9mIHRoZSBsYXllci5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3TmFtZSAtIE5ldyBuYW1lIHRvIHNldCBvbiB0aGUgbGF5ZXIuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgbmV3IG5hbWUgb2YgdGhlIGxheWVyXHJcbiAgICovXHJcbiAgcmVuYW1lTGF5ZXIoY3VycmVudE5hbWUsIG5ld05hbWUpIHtcclxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgbmFtZSBpcyB2YWxpZFxyXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllck1hcFtjdXJyZW50TmFtZV07XHJcblxyXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBDYW5ub3QgcmVuYW1lIGxheWVyICR7Y3VycmVudE5hbWV9IGZyb20gaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBsYXllciBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgbGF5ZXIgbmFtZSBpcyB1bmlxdWVcclxuICAgIGNvbnN0IG5hbWUgPSBVdGlscy5nZXRVbmlxdWVOYW1lKG5ld05hbWUsIE9iamVjdC5rZXlzKHRoaXMuX2xheWVyTWFwKSk7XHJcblxyXG4gICAgaWYgKG5hbWUgIT09IG5ld05hbWUpIHtcclxuICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgIGBMYXllciBuYW1lICR7bmV3TmFtZX0gaXMgbm90IHVuaXF1ZS4gTGF5ZXIgd2lsbCBiZSByZW5hbWVkIHRvICR7bmFtZX0uYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGRlbGV0ZSB0aGlzLl9sYXllck1hcFtjdXJyZW50TmFtZV07XHJcbiAgICB0aGlzLl9sYXllck1hcFtuYW1lXSA9IGxheWVyO1xyXG4gICAgbGF5ZXIubmFtZSA9IG5hbWU7XHJcblxyXG4gICAgLy8gTm90aWZ5IHRoYXQgYSBsYXllciBoYXMgYmVlbiByZW5hbWVkIG9uIHRoZSBmZWF0dXJlXHJcbiAgICB0aGlzLmVtaXQodGhpcy5jb25zdHJ1Y3Rvci5FVkVOVFMucmVuYW1lTGF5ZXIsIHtcclxuICAgICAgb2xkTmFtZTogY3VycmVudE5hbWUsXHJcbiAgICAgIG5ld05hbWU6IG5hbWUsXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gbmFtZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiB0aGUgd2VpZ2h0IG9mIGFuIGFuaW1hdGlvbiBsYXllci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdG8gcmV0dXJuIHdlaWdodCBmcm9tLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBnZXRMYXllcldlaWdodChuYW1lKSB7XHJcbiAgICAvLyBNYWtlIHN1cmUgdGhlIG5hbWUgaXMgdmFsaWRcclxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJNYXBbbmFtZV07XHJcblxyXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBDYW5ub3QgZ2V0IHdlaWdodCBvbiBsYXllciAke25hbWV9IGZyb20gaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBsYXllciBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBsYXllci53ZWlnaHQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgdGhlIHdlaWdodCBvZiBhbiBhbmltYXRpb24gbGF5ZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBsYXllciB0byB1cGRhdGUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHdlaWdodCAtIFRoZSB3ZWlnaHQgdmFsdWUgdG8gc2V0IG9uIHRoZSBsYXllci4gVGhpcyBudW1iZXJcclxuICAgKiBzaG91bGQgYmUgaW4gdGhlIDAtMSByYW5nZS5cclxuICAgKiBAcGFyYW0ge251bWJlcj19IHNlY29uZHMgLSBUaGUgbnVtYmVyIG9mIHNlY29uZHMgaXQgc2hvdWxkIHRha2UgdG8gcmVhY2ggdGhlXHJcbiAgICogbmV3IHdlaWdodC4gRGVmYXVsdCBpcyB6ZXJvIGFuZCB3aWxsIHNldCBpbW1lZGlhdGVseS5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gZWFzaW5nRm4gLSBUaGUgZWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSB3aGlsZSBpbnRlcnBvbGF0aW5nXHJcbiAgICogdGhlIHdlaWdodC4gRGVmYXVsdCBpcyBFYXNpbmcuTGluZWFyLkluT3V0LlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0RlZmVycmVkfSBBIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgb25jZSB0aGUgbGF5ZXIncyB3ZWlnaHQgcmVhY2hlc1xyXG4gICAqIHRoZSB0YXJnZXQgdmFsdWUuXHJcbiAgICovXHJcbiAgc2V0TGF5ZXJXZWlnaHQobmFtZSwgd2VpZ2h0LCBzZWNvbmRzLCBlYXNpbmdGbikge1xyXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBuYW1lIGlzIHZhbGlkXHJcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW25hbWVdO1xyXG5cclxuICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGNvbnN0IGUgPSBgQ2Fubm90IHNldCB3ZWlnaHQgb24gbGF5ZXIgJHtuYW1lfSBmcm9tIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTm8gbGF5ZXIgZXhpc3RzIHdpdGggdGhpcyBuYW1lLmA7XHJcbiAgICAgIHJldHVybiBEZWZlcnJlZC5yZWplY3QoZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGxheWVyLnNldFdlaWdodCh3ZWlnaHQsIHNlY29uZHMsIGVhc2luZ0ZuKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIG5hbWVzIG9mIGJsZW5kIHN0YXRlcyBpbiBhbiBhbmltYXRpb24gaW4gYSBsYXllci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciBjb250YWluaW5nIHRoZSBhbmltYXRpb24gY29udGFpbmluZ1xyXG4gICAqIHRoZSBibGVuZCBzdGF0ZSB0byB1cGRhdGUuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFuaW1hdGlvbk5hbWUgLSBOYW1lIG9mIHRoZSBhbmltYXRpb24gY29udGFpbmluZyB0aGUgYmxlbmQgc3RhdGVcclxuICAgKiB0byB1cGRhdGUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZz59IC0gTmFtZXMgb2YgYmxlbmQgc3RhdGVzLlxyXG4gICAqL1xyXG4gIGdldEFuaW1hdGlvbkJsZW5kTmFtZXMobGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lKSB7XHJcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW2xheWVyTmFtZV07XHJcblxyXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBDYW5ub3QgZ2V0IGJsZW5kIG5hbWVzIG9uIGxheWVyICR7bGF5ZXJOYW1lfSBmcm9tIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTm8gbGF5ZXIgZXhpc3RzIHdpdGggdGhpcyBuYW1lLmBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbGF5ZXIuZ2V0QW5pbWF0aW9uQmxlbmROYW1lcyhhbmltYXRpb25OYW1lKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB0aGUgd2VpZ2h0IGZvciBhIGJsZW5kIHN0YXRlIGluIGFuIGFuaW1hdGlvbiBpbiBhIGxheWVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIGNvbnRhaW5pbmcgdGhlIGFuaW1hdGlvbiBjb250YWluaW5nXHJcbiAgICogdGhlIGJsZW5kIHN0YXRlIHRvIHVwZGF0ZS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gYW5pbWF0aW9uTmFtZSAtIE5hbWUgb2YgdGhlIGFuaW1hdGlvbiBjb250YWluaW5nIHRoZSBibGVuZCBzdGF0ZVxyXG4gICAqIHRvIHVwZGF0ZS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gYmxlbmROYW1lIC0gTmFtZSBvZiB0aGUgYmxlbmQgc3RhdGUgdG8gdXBkYXRlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3ZWlnaHQgLSBXZWlnaHQgdmFsdWUgdG8gc2V0IG9uIHRoZSBhbmltYXRpb24uIFRoaXMgbnVtYmVyIHNob3VkbGQgYmVcclxuICAgKiBpbiB0aGUgMC0xIHJhbmdlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gc2Vjb25kcyAtIE51bWJlciBvZiBzZWNvbmRzIGl0IHNob3VsZCB0YWtlIHRvIHJlYWNoIHRoZSBuZXcgd2VpZ2h0LlxyXG4gICAqIERlZmF1bHQgaXMgemVybyBhbmQgd2lsbCBzZXQgaW1tZWRpYXRlbHkuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGVhc2luZ0ZuIC0gRWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSB3aGlsZSBpbnRlcnBvbGF0aW5nIHRoZSBuZXdcclxuICAgKiB3ZWlnaHQuIERlZmF1bHQgaXMgRWFzaW5nLkxpbmVhci5Jbk91dC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH0gLSBQcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIG9uY2UgdGhlIGFuaW1hdGlvbidzIHdlaWdodCByZWFjaGVzXHJcbiAgICogdGhlIHRhcmdldCB2YWx1ZS5cclxuICAgKi9cclxuICBzZXRBbmltYXRpb25CbGVuZFdlaWdodChcclxuICAgIGxheWVyTmFtZSxcclxuICAgIGFuaW1hdGlvbk5hbWUsXHJcbiAgICBibGVuZE5hbWUsXHJcbiAgICB3ZWlnaHQsXHJcbiAgICBzZWNvbmRzLFxyXG4gICAgZWFzaW5nRm5cclxuICApIHtcclxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJNYXBbbGF5ZXJOYW1lXTtcclxuXHJcbiAgICBpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBjb25zdCBlID0gYENhbm5vdCBzZXQgYmxlbmQgd2VpZ2h0IG9uIGxheWVyICR7bGF5ZXJOYW1lfSBmcm9tIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTm8gbGF5ZXIgZXhpc3RzIHdpdGggdGhpcyBuYW1lLmA7XHJcbiAgICAgIHJldHVybiBEZWZlcnJlZC5yZWplY3QoZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGxheWVyLnNldEFuaW1hdGlvbkJsZW5kV2VpZ2h0KFxyXG4gICAgICBhbmltYXRpb25OYW1lLFxyXG4gICAgICBibGVuZE5hbWUsXHJcbiAgICAgIHdlaWdodCxcclxuICAgICAgc2Vjb25kcyxcclxuICAgICAgZWFzaW5nRm5cclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSB3ZWlnaHQgZm9yIGEgYmxlbmQgc3RhdGUgaW4gYW4gYW5pbWF0aW9uIGluIGEgbGF5ZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgY29udGFpbmluZyB0aGUgYW5pbWF0aW9uIGNvbnRhaW5pbmdcclxuICAgKiB0aGUgYmxlbmQgc3RhdGUgdG8gdXBkYXRlLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbmltYXRpb25OYW1lIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uIGNvbnRhaW5pbmcgdGhlIGJsZW5kIHN0YXRlXHJcbiAgICogdG8gdXBkYXRlLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBibGVuZE5hbWUgLSBOYW1lIG9mIHRoZSBibGVuZCBzdGF0ZSB0byB1cGRhdGUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIFdlaWdodCBvZiB0aGUgYmxlbmQgc3RhdGUuXHJcbiAgICovXHJcbiAgZ2V0QW5pbWF0aW9uQmxlbmRXZWlnaHQobGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lLCBibGVuZE5hbWUpIHtcclxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJNYXBbbGF5ZXJOYW1lXTtcclxuXHJcbiAgICBpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYENhbm5vdCBnZXQgYmxlbmQgd2VpZ2h0IG9uIGxheWVyICR7bGF5ZXJOYW1lfSBmcm9tIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTm8gbGF5ZXIgZXhpc3RzIHdpdGggdGhpcyBuYW1lLmBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbGF5ZXIuZ2V0QW5pbWF0aW9uQmxlbmRXZWlnaHQoYW5pbWF0aW9uTmFtZSwgYmxlbmROYW1lKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhdXNlIHdlaWdodCBpbnRlcnBvbGF0aW9uIGFuaW1hdGlvbiBvbiBhIGxheWVyIHdpdGggdGhlIGdpdmVuIG5hbWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRvIHBhdXNlLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59IC0gV2hldGhlciBvciBub3QgdGhlcmUgd2FzIGFuIGV4aXN0aW5nIGludGVycG9sYXRpb24gdG8gcGF1c2UuXHJcbiAgICovXHJcbiAgcGF1c2VMYXllcldlaWdodChuYW1lKSB7XHJcbiAgICAvLyBNYWtlIHN1cmUgdGhlIG5hbWUgaXMgdmFsaWRcclxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJNYXBbbmFtZV07XHJcblxyXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBDYW5ub3QgcGF1c2Ugd2VpZ2h0IGludGVycG9sYXRpb24gb24gbGF5ZXIgJHtuYW1lfSBmcm9tIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTm8gbGF5ZXIgZXhpc3RzIHdpdGggdGhpcyBuYW1lLmBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbGF5ZXIucGF1c2VXZWlnaHQoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc3VtZSB3ZWlnaHQgaW50ZXJwb2xhdGlvbiBhbmltYXRpb24gb24gYSBsYXllciB3aXRoIHRoZSBnaXZlbiBuYW1lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0byByZXN1bWUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9IC0gUmVzb2x2ZXMgb25jZSB0aGUgbGF5ZXIncyB3ZWlnaHQgcmVhY2hlcyBpdHMgdGFyZ2V0IHZhbHVlLlxyXG4gICAqL1xyXG4gIHJlc3VtZUxheWVyV2VpZ2h0KG5hbWUpIHtcclxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgbmFtZSBpcyB2YWxpZFxyXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllck1hcFtuYW1lXTtcclxuXHJcbiAgICBpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBjb25zdCBlID0gYENhbm5vdCByZXN1bWUgd2VpZ2h0IGludGVycG9sYXRpb24gb24gbGF5ZXIgJHtuYW1lfSBmcm9tIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTm8gbGF5ZXIgZXhpc3RzIHdpdGggdGhpcyBuYW1lLmA7XHJcbiAgICAgIHJldHVybiBEZWZlcnJlZC5yZWplY3QoZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGxheWVyLnJlc3VtZVdlaWdodCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGF1c2UgY3VycmVudCBhbmltYXRpb24gYW5kIHdlaWdodCBpbnRlcnBvbGF0aW9uIGFuaW1hdGlvbiBvbiBhIGxheWVyIHdpdGhcclxuICAgKiB0aGUgZ2l2ZW4gbmFtZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdG8gcGF1c2UuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBXaGV0aGVyIG9yIG5vdCB0aGVyZSB3YXMgYW4gZXhpc3RpbmcgaW50ZXJwb2xhdGlvbiBvclxyXG4gICAqIGN1cnJlbnQgYW5pbWF0aW9uIHRvIHBhdXNlLlxyXG4gICAqL1xyXG4gIHBhdXNlTGF5ZXIobmFtZSkge1xyXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBuYW1lIGlzIHZhbGlkXHJcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW25hbWVdO1xyXG5cclxuICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgQ2Fubm90IHBhdXNlIGxheWVyICR7bmFtZX0gZnJvbSBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5vIGxheWVyIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGxheWVyLnBhdXNlKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXN1bWUgY3VycmVudCBhbmltYXRpb24gYW5kIHdlaWdodCBpbnRlcnBvbGF0aW9uIGFuaW1hdGlvbiBvbiBhIGxheWVyIHdpdGhcclxuICAgKiB0aGUgZ2l2ZW4gbmFtZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdG8gcmVzdW1lLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0RlZmVycmVkfSAtIFJlc29sdmVzIG9uY2UgdGhlIGxheWVyJ3Mgd2VpZ2h0IHJlYWNoZXMgaXRzIHRhcmdldCB2YWx1ZVxyXG4gICAqIGFuZCBpdCdzIGN1cnJlbnQgYW5pbWF0aW9uIGZpbmlzaGVzIHBsYXlpbmcuXHJcbiAgICovXHJcbiAgcmVzdW1lTGF5ZXIobmFtZSkge1xyXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBuYW1lIGlzIHZhbGlkXHJcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW25hbWVdO1xyXG5cclxuICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGNvbnN0IGUgPSBgQ2Fubm90IHJlc3VtZSBsYXllciAke25hbWV9IGZyb20gaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBsYXllciBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYDtcclxuICAgICAgcmV0dXJuIERlZmVycmVkLnJlamVjdChlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbGF5ZXIucmVzdW1lKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gd2hldGhlciBvciBub3QgdGhlIGFuaW1hdGlvbiBsYXllciB3aXRoIHRoZSBnaXZlbiBuYW1lIGlzIGN1cnJlbnRseVxyXG4gICAqIHRyYW5zaXRpb25pbmcgYmV0d2VlbiBhbmltYXRpb25zLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRvIGNoZWNrLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgZ2V0VHJhbnNpdGlvbmluZyhsYXllck5hbWUpIHtcclxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgbGF5ZXJOYW1lIGlzIHZhbGlkXHJcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW2xheWVyTmFtZV07XHJcblxyXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBHZXQgdHJhbnNpdGlvbmluZyBvbiBsYXllciAke2xheWVyTmFtZX0gZnJvbSBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5vIGxheWVyIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGxheWVyLmlzVHJhbnNpdGlvbmluZztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiB0aGUgbmFtZXMgb2YgYWxsIHN0YXRlcyB0aGUgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBjb250cm9scy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0byBzZWFyY2guXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZz59XHJcbiAgICovXHJcbiAgZ2V0QW5pbWF0aW9ucyhsYXllck5hbWUpIHtcclxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgbGF5ZXJOYW1lIGlzIHZhbGlkXHJcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW2xheWVyTmFtZV07XHJcblxyXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBHZXQgYW5pbWF0aW9ucyBvbiBsYXllciAke2xheWVyTmFtZX0gZnJvbSBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5vIGxheWVyIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGxheWVyLmdldFN0YXRlTmFtZXMoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiB0aGUgbmFtZSBvZiB0aGUgc3RhdGUgY3VycmVudGx5IGFjdGl2ZSBvbiB0aGUgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cclxuICAgKiBSZXR1cm4gbnVsbCBpZiB0aGVyZSBpcyBubyBjdXJyZW50IGFuaW1hdGlvbiBmb3IgdGhlIGxheWVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMgeyhzdHJpbmd8bnVsbCl9XHJcbiAgICovXHJcbiAgZ2V0Q3VycmVudEFuaW1hdGlvbihsYXllck5hbWUpIHtcclxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgbGF5ZXJOYW1lIGlzIHZhbGlkXHJcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW2xheWVyTmFtZV07XHJcblxyXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBHZXQgY3VycmVudCBhbmltYXRpb24gb24gbGF5ZXIgJHtsYXllck5hbWV9IGZyb20gaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBsYXllciBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBsYXllci5jdXJyZW50QW5pbWF0aW9uO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIHdoZXRoZXIgb3Igbm90IGEgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpcyBjdXJyZW50bHkgcGxheWluZyBhblxyXG4gICAqIGFuaW1hdGlvbiBhbmQgdGhhdCBhbmltYXRpb24gaXMgcGF1c2VkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgZ2V0UGF1c2VkKGxheWVyTmFtZSkge1xyXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBsYXllck5hbWUgaXMgdmFsaWRcclxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJNYXBbbGF5ZXJOYW1lXTtcclxuXHJcbiAgICBpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYEdldCBwYXVzZWQgb24gbGF5ZXIgJHtsYXllck5hbWV9IGZyb20gaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBsYXllciBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBsYXllci5jdXJyZW50U3RhdGUgJiYgbGF5ZXIuY3VycmVudFN0YXRlLnBhdXNlZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiB0aGUgdHlwZSBuYW1lIG9mIHRoZSBnaXZlbiBhbmltYXRpb24uIEBzZWUgQW5pbWF0aW9uVHlwZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCBjb250YWlucyB0aGUgYW5pbWF0aW9uLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbmltYXRpb25OYW1lIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRvIGNoZWNrLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgKi9cclxuICBnZXRBbmltYXRpb25UeXBlKGxheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSkge1xyXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBsYXllck5hbWUgaXMgdmFsaWRcclxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJNYXBbbGF5ZXJOYW1lXTtcclxuXHJcbiAgICBpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYEdldCBhbmltYXRpb24gdHlwZSBvbiBsYXllciAke2xheWVyTmFtZX0gZnJvbSBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5vIGxheWVyIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc3RhdGUgPSBsYXllci5nZXRTdGF0ZShhbmltYXRpb25OYW1lKTtcclxuXHJcbiAgICBpZiAoc3RhdGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYEdldCBhbmltYXRpb24gdHlwZSBmb3IgYW5pbWF0aW9uICR7YW5pbWF0aW9uTmFtZX0gb24gbGF5ZXIgJHtsYXllck5hbWV9IGZyb20gaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBhbmltYXRpb24gZXhpc3RzIHdpdGggdGhpcyBuYW1lLmBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7Y29uc3RydWN0b3J9ID0gc3RhdGU7XHJcblxyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKEFuaW1hdGlvblR5cGVzKS5maW5kKFxyXG4gICAgICB0eXBlTmFtZSA9PiBBbmltYXRpb25UeXBlc1t0eXBlTmFtZV0gPT09IGNvbnN0cnVjdG9yXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGEgbmV3IGFuaW1hdGlvbiB0byBhbiBhbmltYXRpb24gbGF5ZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdG8gYWRkIHRoZSBhbmltYXRpb24gdG8uXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFuaW1hdGlvbk5hbWUgLSBOYW1lIHRvIHVzZSB3aGVuIGNhbGxpbmcgdGhlIGFuaW1hdGlvbi5cclxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgLSBPcHRpb25zIHRvIHBhc3MgdG8gdGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgbmV3XHJcbiAgICogU2luZ2xlU3RhdGUgYW5pbWF0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge3N0cmluZ30gLSBUaGUgbmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRoYXQgd2FzIGFkZGVkXHJcbiAgICovXHJcbiAgYWRkQW5pbWF0aW9uKFxyXG4gICAgbGF5ZXJOYW1lLFxyXG4gICAgYW5pbWF0aW9uTmFtZSxcclxuICAgIGFuaW1hdGlvblR5cGUgPSBBbmltYXRpb25UeXBlcy5zaW5nbGUsXHJcbiAgICBvcHRpb25zID0ge31cclxuICApIHtcclxuICAgIG9wdGlvbnMubmFtZSA9IHRoaXMuX3ZhbGlkYXRlTmV3QW5pbWF0aW9uKGxheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSk7XHJcblxyXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBhbmltYXRpb24gdHlwZSBpcyB2YWxpZFxyXG4gICAgaWYgKCFPYmplY3QudmFsdWVzKEFuaW1hdGlvblR5cGVzKS5pbmNsdWRlcyhhbmltYXRpb25UeXBlKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYENhbm5vdCBhZGQgYW5pbWF0aW9uICR7YW5pbWF0aW9uTmFtZX0gdG8gbGF5ZXIgJHtsYXllck5hbWV9IG9uIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gSW52YWxpZCBhbmltYXRpb24gdHlwZS5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllck1hcFtsYXllck5hbWVdO1xyXG4gICAgb3B0aW9ucy5ibGVuZE1vZGUgPSBsYXllci5ibGVuZE1vZGU7XHJcbiAgICBvcHRpb25zLnRyYW5zaXRpb25UaW1lID0gbGF5ZXIudHJhbnNpdGlvblRpbWU7XHJcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXNbYF9jcmVhdGUke2FuaW1hdGlvblR5cGUubmFtZX1gXShvcHRpb25zKTtcclxuXHJcbiAgICBjb25zdCBuYW1lID0gbGF5ZXIuYWRkU3RhdGUoc3RhdGUpO1xyXG5cclxuICAgIC8vIE5vdGlmeSB0aGF0IGFuIGFuaW1hdGlvbiBoYXMgYmVlbiBhZGRlZCB0byB0aGUgZmVhdHVyZVxyXG4gICAgdGhpcy5lbWl0KHRoaXMuY29uc3RydWN0b3IuRVZFTlRTLmFkZEFuaW1hdGlvbiwge1xyXG4gICAgICBsYXllck5hbWUsXHJcbiAgICAgIGFuaW1hdGlvbk5hbWU6IG5hbWUsXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gbmFtZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSBhbiBhbmltYXRpb24gZnJvbSBhbiBhbmltYXRpb24gbGF5ZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdG8gcmVtb3ZlIHRoZSBhbmltYXRpb24gZnJvbS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIGFuaW1hdGlvbiB0byByZW1vdmUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cclxuICByZW1vdmVBbmltYXRpb24obGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lKSB7XHJcbiAgICAvLyBNYWtlIHN1cmUgdGhlIG5hbWUgaXMgdmFsaWRcclxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJNYXBbbGF5ZXJOYW1lXTtcclxuXHJcbiAgICBpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYENhbm5vdCByZW1vdmUgYW5pbWF0aW9uIGZyb20gbGF5ZXIgJHtsYXllck5hbWV9IGZyb20gaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBsYXllciBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJlbW92ZWQgPSBsYXllci5yZW1vdmVTdGF0ZShhbmltYXRpb25OYW1lKTtcclxuXHJcbiAgICAvLyBOb3RpZnkgdGhhdCBhbiBhbmltYXRpb24gaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBmZWF0dXJlXHJcbiAgICBpZiAocmVtb3ZlZCA9PT0gdHJ1ZSkge1xyXG4gICAgICB0aGlzLmVtaXQodGhpcy5jb25zdHJ1Y3Rvci5FVkVOVFMucmVtb3ZlQW5pbWF0aW9uLCB7XHJcbiAgICAgICAgbGF5ZXJOYW1lLFxyXG4gICAgICAgIGFuaW1hdGlvbk5hbWUsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZW1vdmVkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHRoZSBuYW1lIG9mIGFuIGFuaW1hdGlvbi4gTmFtZXMgbXVzdCBiZSB1bmlxdWUgb24gZWFjaCBsYXllciwgaWYgdGhlIG5ld1xyXG4gICAqIG5hbWUgaXMgbm90IHVuaXF1ZSBpdCB3aWxsIGhhdmUgdHJhaWxpbmcgbnVtYmVycyBhcHBlbmRlZCB1bnRpbCBpdCBpcyB1bmlxdWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCBjb250YWlucyB0aGUgYW5pbWF0aW9uIHRoYXRcclxuICAgKiB3aWxsIGJlIHJlbmFtZWQsXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGN1cnJlbnRBbmltYXRpb25OYW1lIC0gQ3VycmVudCBuYW1lIG9mIHRoZSBhbmltYXRpb24uXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5ld0FuaW1hdGlvbk5hbWUgLSBOZXcgbmFtZSB0byBzZXQgb24gdGhlIGFuaW1hdGlvbi5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVGhlIG5ldyBuYW1lIG9mIHRoZSBhbmltYXRpb25cclxuICAgKi9cclxuICByZW5hbWVBbmltYXRpb24obGF5ZXJOYW1lLCBjdXJyZW50QW5pbWF0aW9uTmFtZSwgbmV3QW5pbWF0aW9uTmFtZSkge1xyXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllck1hcFtsYXllck5hbWVdO1xyXG5cclxuICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgQ2Fubm90IHJlbmFtZSBhbmltYXRpb24gJHtjdXJyZW50QW5pbWF0aW9uTmFtZX0gb24gbGF5ZXIgJHtsYXllck5hbWV9IGZvciBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5vIGxheWVyIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbmFtZSA9IGxheWVyLnJlbmFtZVN0YXRlKGN1cnJlbnRBbmltYXRpb25OYW1lLCBuZXdBbmltYXRpb25OYW1lKTtcclxuXHJcbiAgICAvLyBOb3RpZnkgdGhhdCBhbiBhbmltYXRpb24gaGFzIGJlZW4gcmVuYW1lZCBvbiB0aGUgZmVhdHVyZVxyXG4gICAgdGhpcy5lbWl0KHRoaXMuY29uc3RydWN0b3IuRVZFTlRTLnJlbmFtZUFuaW1hdGlvbiwge1xyXG4gICAgICBsYXllck5hbWUsXHJcbiAgICAgIG9sZE5hbWU6IGN1cnJlbnRBbmltYXRpb25OYW1lLFxyXG4gICAgICBuZXdOYW1lOiBuYW1lLFxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIG5hbWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYXVzZSB0aGUgY3VycmVudGx5IHBsYXlpbmcgYW5pbWF0aW9uIGFuZCBwbGF5IGEgbmV3IGFuaW1hdGlvbiBmcm9tIHRoZSBiZWdpbm5pbmcuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCBjb250YWlucyB0aGUgYW5pbWF0aW9uLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbmltYXRpb25OYW1lIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uIHN0YXRlIHRvIHBsYXkuXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSBzZWNvbmRzIC0gVGhlIG51bWJlciBvZiBzZWNvbmRzIGl0IHNob3VsZCB0YWtlIHRvIHRyYW5zaXRpb25cclxuICAgKiB0byB0aGUgbmV3IGFuaW1hdGlvbi4gRGVmYXVsdCBpcyB6ZXJvIGFuZCB3aWxsIHNldCBpbW1lZGlhdGVseS5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gZWFzaW5nRm4gLSBUaGUgZWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSB3aGlsZSB0cmFuc2l0aW9uaW5nXHJcbiAgICogYmV0d2VlbiBhbmltYXRpb25zLiBEZWZhdWx0IGlzIEVhc2luZy5MaW5lYXIuSW5PdXQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9IC0gUmVzb2x2ZXMgb25jZSB0aGUgYW5pbWF0aW9uIHJlYWNoZXMgdGhlIGVuZCBvZiBpdHNcclxuICAgKiB0aW1lbGluZS4gTG9vcGluZyBhbmltYXRpb25zIGNhbiBvbmx5IHJlc29sdmUgaWYgdGhleSBhcmUgaW50ZXJydXB0ZWQgb3JcclxuICAgKiBtYW51YWxseSBzdG9wcGVkLlxyXG4gICAqL1xyXG4gIHBsYXlBbmltYXRpb24obGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lLCBzZWNvbmRzLCBlYXNpbmdGbikge1xyXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllck1hcFtsYXllck5hbWVdO1xyXG5cclxuICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGNvbnN0IGUgPSBgQ2Fubm90IHBsYXkgYW5pbWF0aW9uICR7YW5pbWF0aW9uTmFtZX0gb24gbGF5ZXIgJHtsYXllck5hbWV9IGZvciBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5vIGxheWVyIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gO1xyXG4gICAgICByZXR1cm4gRGVmZXJyZWQucmVqZWN0KGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE5vdGlmeSB0aGF0IGEgbmV3IGFuaW1hdGlvbiBoYXMgYmVndW5cclxuICAgIHRoaXMuZW1pdCh0aGlzLmNvbnN0cnVjdG9yLkVWRU5UUy5wbGF5QW5pbWF0aW9uLCB7XHJcbiAgICAgIGxheWVyTmFtZSxcclxuICAgICAgYW5pbWF0aW9uTmFtZSxcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBsYXllci5wbGF5QW5pbWF0aW9uKFxyXG4gICAgICBhbmltYXRpb25OYW1lLFxyXG4gICAgICBzZWNvbmRzLFxyXG4gICAgICBlYXNpbmdGbixcclxuICAgICAgKCkgPT4ge1xyXG4gICAgICAgIC8vIE5vdGlmeSB0aGF0IGFuIGFuaW1hdGlvbiBoYXMgc3RvcHBlZFxyXG4gICAgICAgIHRoaXMuZW1pdCh0aGlzLmNvbnN0cnVjdG9yLkVWRU5UUy5zdG9wQW5pbWF0aW9uLCB7XHJcbiAgICAgICAgICBsYXllck5hbWUsXHJcbiAgICAgICAgICBhbmltYXRpb25OYW1lLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9LFxyXG4gICAgICB1bmRlZmluZWQsXHJcbiAgICAgICgpID0+IHtcclxuICAgICAgICAvLyBOb3RpZnkgdGhhdCBhbiBhbmltYXRpb24gaGFzIGJlZW4gaW50ZXJydXB0ZWRcclxuICAgICAgICB0aGlzLmVtaXQodGhpcy5jb25zdHJ1Y3Rvci5FVkVOVFMuaW50ZXJydXB0QW5pbWF0aW9uLCB7XHJcbiAgICAgICAgICBsYXllck5hbWUsXHJcbiAgICAgICAgICBhbmltYXRpb25OYW1lLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9LFxyXG4gICAgICAoe25hbWUsIGNhbkFkdmFuY2UsIGlzUXVldWVFbmR9KSA9PiB7XHJcbiAgICAgICAgaWYgKGxheWVyLmN1cnJlbnRBbmltYXRpb24gPT09IGFuaW1hdGlvbk5hbWUpIHtcclxuICAgICAgICAgIC8vIE5vdGlmeSB0aGF0IGEgbmV3IGFuaW1hdGlvbiBoYXMgYmVndW5cclxuICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLmNvbnN0cnVjdG9yLkVWRU5UUy5wbGF5TmV4dEFuaW1hdGlvbiwge1xyXG4gICAgICAgICAgICBsYXllck5hbWUsXHJcbiAgICAgICAgICAgIGFuaW1hdGlvbk5hbWUsXHJcbiAgICAgICAgICAgIG5leHRRdWV1ZWRBbmltYXRpb246IG5hbWUsXHJcbiAgICAgICAgICAgIGNhbkFkdmFuY2UsXHJcbiAgICAgICAgICAgIGlzUXVldWVFbmQsXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQbGF5IHRoZSBuZXh0IGFuaW1hdGlvbiBpbiB0aGUgcXVldWUgb2YgYSBRdWV1ZVN0YXRlIGFuaW1hdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0aGF0IGNvbnRhaW5zIHRoZSBxdWV1ZSBhbmltYXRpb24uXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBhbmltYXRpb25OYW1lIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uIHF1ZXVlIGFuaW1hdGlvbi4gRGVmYXVsdHNcclxuICAgKiB0byB0aGUgbmFtZSBvZiB0aGUgY3VycmVudCBhbmltYXRpb24gZm9yIHRoZSBsYXllci5cclxuICAgKiBAcGFyYW0ge251bWJlcj19IHNlY29uZHMgLSBUaGUgbnVtYmVyIG9mIHNlY29uZHMgaXQgc2hvdWxkIHRha2UgdG8gdHJhbnNpdGlvblxyXG4gICAqIHRvIHRoZSBxdWV1ZSBhbmltYXRpb24gaWYgaXQncyBub3QgYWxyZWFkeSBjdXJyZW50bHkgcGxheWluZy4gRGVmYXVsdCBpcyB6ZXJvXHJcbiAgICogYW5kIHdpbGwgc2V0IGltbWVkaWF0ZWx5LlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBlYXNpbmdGbiAtIFRoZSBlYXNpbmcgZnVuY3Rpb24gdG8gdXNlIHdoaWxlIHRyYW5zaXRpb25pbmdcclxuICAgKiB0byB0aGUgcXVldWUgYW5pbWF0aW9uIGlmIGl0IGlzbid0IGFscmVhZHkgcGxheWluZy4gRGVmYXVsdCBpcyBFYXNpbmcuTGluZWFyLkluT3V0LlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0RlZmVycmVkfSAtIFJlc29sdmVzIG9uY2UgdGhlIGxhc3QgYW5pbWF0aW9uIGluIHRoZSBxdWV1ZSBmaW5pc2hlc1xyXG4gICAqIHBsYXlpbmcuXHJcbiAgICovXHJcbiAgcGxheU5leHRBbmltYXRpb24obGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lLCB0cmFuc2l0aW9uVGltZSwgZWFzaW5nRm4pIHtcclxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJNYXBbbGF5ZXJOYW1lXTtcclxuXHJcbiAgICBpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBjb25zdCBlID0gYENhbm5vdCBwbGF5IG5leHQgYW5pbWF0aW9uIG9uIGxheWVyICR7bGF5ZXJOYW1lfSBmb3IgaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBsYXllciBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYDtcclxuICAgICAgcmV0dXJuIERlZmVycmVkLnJlamVjdChlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYW5pbWF0aW9uTmFtZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGFuaW1hdGlvbk5hbWUgPSBsYXllci5jdXJyZW50QW5pbWF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGFuaW1hdGlvbiA9IGxheWVyLmdldFN0YXRlKGxheWVyLmN1cnJlbnRBbmltYXRpb24pO1xyXG5cclxuICAgIGlmIChhbmltYXRpb24gPT09IG51bGwpIHtcclxuICAgICAgY29uc3QgZSA9IGBDYW5ub3QgcGxheSBuZXh0IGFuaW1hdGlvbiBvbiBsYXllciAke2xheWVyTmFtZX0gZm9yIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTm8gYW5pbWF0aW9uIGV4aXN0cyB3aXRoIG5hbWUgJHthbmltYXRpb25OYW1lfS5gO1xyXG4gICAgICByZXR1cm4gRGVmZXJyZWQucmVqZWN0KGUpO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLmdldEFuaW1hdGlvblR5cGUobGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lKSAhPT0gJ3F1ZXVlJykge1xyXG4gICAgICBjb25zdCBlID0gYENhbm5vdCBwbGF5IG5leHQgYW5pbWF0aW9uIG9uIGxheWVyICR7bGF5ZXJOYW1lfSBmb3IgaG9zdCAke3RoaXMuX2hvc3QuaWR9LiAke2FuaW1hdGlvbk5hbWV9IGlzIG5vdCBhIHF1ZXVlIHN0YXRlLmA7XHJcbiAgICAgIHJldHVybiBEZWZlcnJlZC5yZWplY3QoZSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgb25OZXh0ID0gKHtuYW1lLCBjYW5BZHZhbmNlLCBpc1F1ZXVlRW5kfSkgPT4ge1xyXG4gICAgICBpZiAobGF5ZXIuY3VycmVudEFuaW1hdGlvbiA9PT0gYW5pbWF0aW9uTmFtZSkge1xyXG4gICAgICAgIC8vIE5vdGlmeSB0aGF0IGEgbmV3IGFuaW1hdGlvbiBoYXMgYmVndW5cclxuICAgICAgICB0aGlzLmVtaXQodGhpcy5jb25zdHJ1Y3Rvci5FVkVOVFMucGxheU5leHRBbmltYXRpb24sIHtcclxuICAgICAgICAgIGxheWVyTmFtZSxcclxuICAgICAgICAgIGFuaW1hdGlvbk5hbWUsXHJcbiAgICAgICAgICBuZXh0UXVldWVkQW5pbWF0aW9uOiBuYW1lLFxyXG4gICAgICAgICAgY2FuQWR2YW5jZSxcclxuICAgICAgICAgIGlzUXVldWVFbmQsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gTWFrZSB0aGUgcXVldWUgYW5pbWF0aW9uIGN1cnJlbnQgaWYgaXQgd2Fzbid0IGFscmVhZHlcclxuICAgIGlmIChsYXllci5jdXJyZW50QW5pbWF0aW9uID09PSBudWxsKSB7XHJcbiAgICAgIGxheWVyLnJlc3VtZUFuaW1hdGlvbihcclxuICAgICAgICBhbmltYXRpb24ubmFtZSxcclxuICAgICAgICB0cmFuc2l0aW9uVGltZSxcclxuICAgICAgICBlYXNpbmdGbixcclxuICAgICAgICB1bmRlZmluZWQsXHJcbiAgICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICAgIHVuZGVmaW5lZCxcclxuICAgICAgICBvbk5leHRcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYW5pbWF0aW9uLm5leHQob25OZXh0LCB0cnVlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhdXNlIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBvbiBhIGxheWVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0byBwYXVzZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCBhbiBhbmltYXRpb24gd2FzIHN1Y2Nlc3NmdWxseSBwYXVzZWQuXHJcbiAgICovXHJcbiAgcGF1c2VBbmltYXRpb24obmFtZSkge1xyXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllck1hcFtuYW1lXTtcclxuXHJcbiAgICBpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgYERpZCBub3QgcGF1c2UgYW5pbWF0aW9uIG9uIGxheWVyICR7bmFtZX0gZm9yIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTm8gbGF5ZXIgZXhpc3RzIHdpdGggdGhpcyBuYW1lLmBcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHBhdXNlZCA9IGxheWVyLnBhdXNlQW5pbWF0aW9uKCk7XHJcblxyXG4gICAgLy8gTm90aWZ5IHRoYXQgYW4gYW5pbWF0aW9uIHdhcyBwYXVzZWRcclxuICAgIGlmIChwYXVzZWQpIHtcclxuICAgICAgY29uc3QgYW5pbWF0aW9uTmFtZSA9IGxheWVyLmN1cnJlbnRBbmltYXRpb247XHJcbiAgICAgIHRoaXMuZW1pdCh0aGlzLmNvbnN0cnVjdG9yLkVWRU5UUy5wYXVzZUFuaW1hdGlvbiwge1xyXG4gICAgICAgIGxheWVyTmFtZTogbmFtZSxcclxuICAgICAgICBhbmltYXRpb25OYW1lLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcGF1c2VkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGF1c2UgdGhlIGN1cnJlbnRseSBwbGF5aW5nIGFuaW1hdGlvbiBhbmQgcGxheSBhIG5ldyBhbmltYXRpb24gZnJvbSB3aGVyZSBpdFxyXG4gICAqIGxhc3QgbGVmdCBvZmYuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCBjb250YWlucyB0aGUgYW5pbWF0aW9uLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gYW5pbWF0aW9uTmFtZSAtIE5hbWUgb2YgdGhlIGFuaW1hdGlvbiBzdGF0ZSB0byByZXN1bWUuIERlZmF1bHRzXHJcbiAgICogdG8gdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGZvciB0aGUgbGF5ZXIuXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSBzZWNvbmRzIC0gVGhlIG51bWJlciBvZiBzZWNvbmRzIGl0IHNob3VsZCB0YWtlIHRvIHRyYW5zaXRpb25cclxuICAgKiB0byB0aGUgbmV3IGFuaW1hdGlvbi4gRGVmYXVsdCBpcyB6ZXJvIGFuZCB3aWxsIHNldCBpbW1lZGlhdGVseS5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gZWFzaW5nRm4gLSBUaGUgZWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSB3aGlsZSB0cmFuc2l0aW9uaW5nXHJcbiAgICogYmV0d2VlbiBhbmltYXRpb25zLiBEZWZhdWx0IGlzIEVhc2luZy5MaW5lYXIuSW5PdXQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9IC0gUmVzb2x2ZXMgb25jZSB0aGUgYW5pbWF0aW9uIHJlYWNoZXMgdGhlIGVuZCBvZiBpdHNcclxuICAgKiB0aW1lbGluZS4gTG9vcGluZyBhbmltYXRpb25zIGNhbiBvbmx5IHJlc29sdmUgaWYgdGhleSBhcmUgaW50ZXJydXB0ZWQgb3JcclxuICAgKiBtYW51YWxseSBzdG9wcGVkLlxyXG4gICAqL1xyXG4gIHJlc3VtZUFuaW1hdGlvbihsYXllck5hbWUsIGFuaW1hdGlvbk5hbWUsIHNlY29uZHMsIGVhc2luZ0ZuKSB7XHJcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW2xheWVyTmFtZV07XHJcblxyXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgY29uc3QgZSA9IGBDYW5ub3QgcmVzdW1lIGFuaW1hdGlvbiAke2FuaW1hdGlvbk5hbWV9IG9uIGxheWVyICR7bGF5ZXJOYW1lfSBmb3IgaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBsYXllciBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYDtcclxuICAgICAgcmV0dXJuIERlZmVycmVkLnJlamVjdChlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBOb3RpZnkgdGhhdCBhbiBhbmltYXRpb24gd2FzIHJlc3VtZWRcclxuICAgIHRoaXMuZW1pdCh0aGlzLmNvbnN0cnVjdG9yLkVWRU5UUy5yZXN1bWVBbmltYXRpb24sIHtcclxuICAgICAgbGF5ZXJOYW1lLFxyXG4gICAgICBhbmltYXRpb25OYW1lLFxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGxheWVyLnJlc3VtZUFuaW1hdGlvbihcclxuICAgICAgYW5pbWF0aW9uTmFtZSxcclxuICAgICAgc2Vjb25kcyxcclxuICAgICAgZWFzaW5nRm4sXHJcbiAgICAgICgpID0+IHtcclxuICAgICAgICAvLyBOb3RpZnkgdGhhdCBhbiBhbmltYXRpb24gaGFzIHN0b3BwZWRcclxuICAgICAgICB0aGlzLmVtaXQodGhpcy5jb25zdHJ1Y3Rvci5FVkVOVFMuc3RvcEFuaW1hdGlvbiwge1xyXG4gICAgICAgICAgbGF5ZXJOYW1lLFxyXG4gICAgICAgICAgYW5pbWF0aW9uTmFtZSxcclxuICAgICAgICB9KTtcclxuICAgICAgfSxcclxuICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICAoKSA9PiB7XHJcbiAgICAgICAgLy8gTm90aWZ5IHRoYXQgYW4gYW5pbWF0aW9uIGhhcyBiZWVuIGludGVycnVwdGVkXHJcbiAgICAgICAgdGhpcy5lbWl0KHRoaXMuY29uc3RydWN0b3IuRVZFTlRTLmludGVycnVwdEFuaW1hdGlvbiwge1xyXG4gICAgICAgICAgbGF5ZXJOYW1lLFxyXG4gICAgICAgICAgYW5pbWF0aW9uTmFtZSxcclxuICAgICAgICB9KTtcclxuICAgICAgfSxcclxuICAgICAgKHtuYW1lLCBjYW5BZHZhbmNlLCBpc1F1ZXVlRW5kfSkgPT4ge1xyXG4gICAgICAgIGlmIChsYXllci5jdXJyZW50QW5pbWF0aW9uID09PSBhbmltYXRpb25OYW1lKSB7XHJcbiAgICAgICAgICAvLyBOb3RpZnkgdGhhdCBhIG5ldyBhbmltYXRpb24gaGFzIGJlZ3VuXHJcbiAgICAgICAgICB0aGlzLmVtaXQodGhpcy5jb25zdHJ1Y3Rvci5FVkVOVFMucGxheU5leHRBbmltYXRpb24sIHtcclxuICAgICAgICAgICAgbGF5ZXJOYW1lLFxyXG4gICAgICAgICAgICBhbmltYXRpb25OYW1lLFxyXG4gICAgICAgICAgICBuZXh0UXVldWVkQW5pbWF0aW9uOiBuYW1lLFxyXG4gICAgICAgICAgICBjYW5BZHZhbmNlLFxyXG4gICAgICAgICAgICBpc1F1ZXVlRW5kLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RvcCB0aGUgY3VycmVudCBhbmltYXRpb24gb24gYSBsYXllci4gU3RvcCByZXdpbmRzIHRoZSBhbmltYXRpb24gdG8gdGhlXHJcbiAgICogYmVnaW5uaW5nIGFuZCBwcmV2ZW50cyBpdCBmcm9tIHByb2dyZXNzaW5nIGZvcndhcmQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRoYXQgY29udGFpbnMgdGhlIGFuaW1hdGlvbi5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCBhbiBhbmltYXRpb24gd2FzIHN1Y2Nlc3NmdWxseSBzdG9wcGVkLlxyXG4gICAqL1xyXG4gIHN0b3BBbmltYXRpb24obmFtZSkge1xyXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllck1hcFtuYW1lXTtcclxuXHJcbiAgICBpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgYERpZCBub3Qgc3RvcCBhbmltYXRpb24gb24gbGF5ZXIgJHtuYW1lfSBmb3IgaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBsYXllciBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGxheWVyLnN0b3BBbmltYXRpb24oKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhdXNlIGN1cnJlbnQgYW5pbWF0aW9uIGFuZCB3ZWlnaHQgaW50ZXJwb2xhdGlvbiBhbmltYXRpb24gb24gYWxsIGxheWVycy5cclxuXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59IC0gV2hldGhlciBvciBub3QgdGhlcmUgd2FzIGFuIGV4aXN0aW5nIGludGVycG9sYXRpb24gb3JcclxuICAgKiBjdXJyZW50IGFuaW1hdGlvbnMgdG8gcGF1c2UuXHJcbiAgICovXHJcbiAgcGF1c2UoKSB7XHJcbiAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xyXG5cclxuICAgIGxldCBwYXVzZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX2xheWVycy5mb3JFYWNoKGwgPT4ge1xyXG4gICAgICBpZiAobC5wYXVzZSgpKSB7XHJcbiAgICAgICAgcGF1c2VkID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHBhdXNlZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc3VtZSBjdXJyZW50IGFuaW1hdGlvbiBhbmQgd2VpZ2h0IGludGVycG9sYXRpb24gYW5pbWF0aW9uIG9uIGFsbCBsYXllcnMuXHJcblxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAtIFdoZXRoZXIgb3Igbm90IHRoZXJlIHdhcyBhbiBleGlzdGluZyBpbnRlcnBvbGF0aW9uIG9yXHJcbiAgICogY3VycmVudCBhbmltYXRpb25zIHRvIHJlc3VtZS5cclxuICAgKi9cclxuICByZXN1bWUoKSB7XHJcbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcclxuXHJcbiAgICBsZXQgcmVzdW1lZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5fbGF5ZXJzLmZvckVhY2gobCA9PiB7XHJcbiAgICAgIGlmIChsLnJlc3VtZSgpKSB7XHJcbiAgICAgICAgcmVzdW1lZCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiByZXN1bWVkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBhIG5hbWVzcGFjZSB0byB0aGUgaG9zdCB3aXRoIHRoZSBuYW1lIG9mIHRoZSBmZWF0dXJlIHRvIGNvbnRhaW4gcHJvcGVydGllc1xyXG4gICAqIGFuZCBtZXRob2RzIGZyb20gdGhlIGZlYXR1cmUgdGhhdCB1c2VycyBvZiB0aGUgaG9zdCBuZWVkIGFjY2VzcyB0by5cclxuICAgKlxyXG4gICAqIEBzZWUgQW5pbWF0aW9uRmVhdHVyZVxyXG4gICAqL1xyXG4gIGluc3RhbGxBcGkoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEBpbm5lclxyXG4gICAgICogQG5hbWVzcGFjZSBBbmltYXRpb25GZWF0dXJlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGFwaSA9IHN1cGVyLmluc3RhbGxBcGkoKTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhhcGksIHtcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXHJcbiAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNwYXVzZWRcclxuICAgICAgICovXHJcbiAgICAgIHBhdXNlZDoge1xyXG4gICAgICAgIGdldDogKCkgPT4gdGhpcy5wYXVzZWQsXHJcbiAgICAgIH0sXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxyXG4gICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjbGF5ZXJzXHJcbiAgICAgICAqL1xyXG4gICAgICBsYXllcnM6IHtcclxuICAgICAgICBnZXQ6ICgpID0+IHRoaXMubGF5ZXJzLFxyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgT2JqZWN0LmFzc2lnbihhcGksIHtcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXHJcbiAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI2FkZExheWVyXHJcbiAgICAgICAqL1xyXG4gICAgICBhZGRMYXllcjogdGhpcy5hZGRMYXllci5iaW5kKHRoaXMpLFxyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBtZXRob2RcclxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjcmVtb3ZlTGF5ZXJcclxuICAgICAgICovXHJcbiAgICAgIHJlbW92ZUxheWVyOiB0aGlzLnJlbW92ZUxheWVyLmJpbmQodGhpcyksXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxyXG4gICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNtb3ZlTGF5ZXJcclxuICAgICAgICovXHJcbiAgICAgIG1vdmVMYXllcjogdGhpcy5tb3ZlTGF5ZXIuYmluZCh0aGlzKSxcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXHJcbiAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI3JlbmFtZUxheWVyXHJcbiAgICAgICAqL1xyXG4gICAgICByZW5hbWVMYXllcjogdGhpcy5yZW5hbWVMYXllci5iaW5kKHRoaXMpLFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXHJcbiAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI2dldExheWVyV2VpZ2h0XHJcbiAgICAgICAqL1xyXG4gICAgICBnZXRMYXllcldlaWdodDogdGhpcy5nZXRMYXllcldlaWdodC5iaW5kKHRoaXMpLFxyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBtZXRob2RcclxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjc2V0TGF5ZXJXZWlnaHRcclxuICAgICAgICovXHJcbiAgICAgIHNldExheWVyV2VpZ2h0OiB0aGlzLnNldExheWVyV2VpZ2h0LmJpbmQodGhpcyksXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxyXG4gICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNwYXVzZUxheWVyV2VpZ2h0XHJcbiAgICAgICAqL1xyXG4gICAgICBwYXVzZUxheWVyV2VpZ2h0OiB0aGlzLnBhdXNlTGF5ZXJXZWlnaHQuYmluZCh0aGlzKSxcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXHJcbiAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI3Jlc3VtZUxheWVyV2VpZ2h0XHJcbiAgICAgICAqL1xyXG4gICAgICByZXN1bWVMYXllcldlaWdodDogdGhpcy5yZXN1bWVMYXllcldlaWdodC5iaW5kKHRoaXMpLFxyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBtZXRob2RcclxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjcGF1c2VMYXllclxyXG4gICAgICAgKi9cclxuICAgICAgcGF1c2VMYXllcjogdGhpcy5wYXVzZUxheWVyLmJpbmQodGhpcyksXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxyXG4gICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNyZXN1bWVMYXllclxyXG4gICAgICAgKi9cclxuICAgICAgcmVzdW1lTGF5ZXI6IHRoaXMucmVzdW1lTGF5ZXIuYmluZCh0aGlzKSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxyXG4gICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNnZXRUcmFuc2l0aW9uaW5nXHJcbiAgICAgICAqL1xyXG4gICAgICBnZXRUcmFuc2l0aW9uaW5nOiB0aGlzLmdldFRyYW5zaXRpb25pbmcuYmluZCh0aGlzKSxcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXHJcbiAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI2dldEFuaW1hdGlvbnNcclxuICAgICAgICovXHJcbiAgICAgIGdldEFuaW1hdGlvbnM6IHRoaXMuZ2V0QW5pbWF0aW9ucy5iaW5kKHRoaXMpLFxyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBtZXRob2RcclxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjZ2V0Q3VycmVudEFuaW1hdGlvblxyXG4gICAgICAgKi9cclxuICAgICAgZ2V0Q3VycmVudEFuaW1hdGlvbjogdGhpcy5nZXRDdXJyZW50QW5pbWF0aW9uLmJpbmQodGhpcyksXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxyXG4gICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNnZXRQYXVzZWRcclxuICAgICAgICovXHJcbiAgICAgIGdldFBhdXNlZDogdGhpcy5nZXRQYXVzZWQuYmluZCh0aGlzKSxcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXHJcbiAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI2dldEFuaW1hdGlvblR5cGVcclxuICAgICAgICovXHJcbiAgICAgIGdldEFuaW1hdGlvblR5cGU6IHRoaXMuZ2V0QW5pbWF0aW9uVHlwZS5iaW5kKHRoaXMpLFxyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBtZXRob2RcclxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjYWRkQW5pbWF0aW9uXHJcbiAgICAgICAqL1xyXG4gICAgICBhZGRBbmltYXRpb246IHRoaXMuYWRkQW5pbWF0aW9uLmJpbmQodGhpcyksXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxyXG4gICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNyZW1vdmVBbmltYXRpb25cclxuICAgICAgICovXHJcbiAgICAgIHJlbW92ZUFuaW1hdGlvbjogdGhpcy5yZW1vdmVBbmltYXRpb24uYmluZCh0aGlzKSxcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXHJcbiAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI3JlbmFtZUFuaW1hdGlvblxyXG4gICAgICAgKi9cclxuICAgICAgcmVuYW1lQW5pbWF0aW9uOiB0aGlzLnJlbmFtZUFuaW1hdGlvbi5iaW5kKHRoaXMpLFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXHJcbiAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI2dldEFuaW1hdGlvbkJsZW5kTmFtZXNcclxuICAgICAgICovXHJcbiAgICAgIGdldEFuaW1hdGlvbkJsZW5kTmFtZXM6IHRoaXMuZ2V0QW5pbWF0aW9uQmxlbmROYW1lcy5iaW5kKHRoaXMpLFxyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBtZXRob2RcclxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjZ2V0QW5pbWF0aW9uQmxlbmRXZWlnaHRcclxuICAgICAgICovXHJcbiAgICAgIGdldEFuaW1hdGlvbkJsZW5kV2VpZ2h0OiB0aGlzLmdldEFuaW1hdGlvbkJsZW5kV2VpZ2h0LmJpbmQodGhpcyksXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxyXG4gICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNzZXRBbmltYXRpb25CbGVuZFdlaWdodFxyXG4gICAgICAgKi9cclxuICAgICAgc2V0QW5pbWF0aW9uQmxlbmRXZWlnaHQ6IHRoaXMuc2V0QW5pbWF0aW9uQmxlbmRXZWlnaHQuYmluZCh0aGlzKSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxyXG4gICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNwbGF5QW5pbWF0aW9uXHJcbiAgICAgICAqL1xyXG4gICAgICBwbGF5QW5pbWF0aW9uOiB0aGlzLnBsYXlBbmltYXRpb24uYmluZCh0aGlzKSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxyXG4gICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNwbGF5TmV4dEFuaW1hdGlvblxyXG4gICAgICAgKi9cclxuICAgICAgcGxheU5leHRBbmltYXRpb246IHRoaXMucGxheU5leHRBbmltYXRpb24uYmluZCh0aGlzKSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxyXG4gICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNwYXVzZUFuaW1hdGlvblxyXG4gICAgICAgKi9cclxuICAgICAgcGF1c2VBbmltYXRpb246IHRoaXMucGF1c2VBbmltYXRpb24uYmluZCh0aGlzKSxcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXHJcbiAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI3Jlc3VtZUFuaW1hdGlvblxyXG4gICAgICAgKi9cclxuICAgICAgcmVzdW1lQW5pbWF0aW9uOiB0aGlzLnJlc3VtZUFuaW1hdGlvbi5iaW5kKHRoaXMpLFxyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBtZXRob2RcclxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjc3RvcEFuaW1hdGlvblxyXG4gICAgICAgKi9cclxuICAgICAgc3RvcEFuaW1hdGlvbjogdGhpcy5zdG9wQW5pbWF0aW9uLmJpbmQodGhpcyksXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBtZXRob2RcclxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjcGF1c2VcclxuICAgICAgICovXHJcbiAgICAgIHBhdXNlOiB0aGlzLnBhdXNlLmJpbmQodGhpcyksXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxyXG4gICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNyZXN1bWVcclxuICAgICAgICovXHJcbiAgICAgIHJlc3VtZTogdGhpcy5yZXN1bWUuYmluZCh0aGlzKSxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIGVhY2ggYW5pbWF0aW9uIGxheWVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhVGltZSAtIFRpbWUgc2luY2UgdGhlIGxhc3QgdXBkYXRlLlxyXG4gICAqL1xyXG4gIHVwZGF0ZShkZWx0YVRpbWUpIHtcclxuICAgIGlmICghdGhpcy5fbGF5ZXJzLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX3BhdXNlZCkge1xyXG4gICAgICBkZWx0YVRpbWUgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlLWV2YWx1YXRlIGludGVybmFsIHdlaWdodHMgZm9yIGxheWVyc1xyXG4gICAgdGhpcy5fdXBkYXRlSW50ZXJuYWxXZWlnaHRzKCk7XHJcblxyXG4gICAgLy8gVXBkYXRlIGxheWVyc1xyXG4gICAgdGhpcy5fbGF5ZXJzLmZvckVhY2gobGF5ZXIgPT4ge1xyXG4gICAgICBsYXllci51cGRhdGUoZGVsdGFUaW1lKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHN1cGVyLnVwZGF0ZShkZWx0YVRpbWUpO1xyXG4gIH1cclxuXHJcbiAgZGlzY2FyZCgpIHtcclxuICAgIHRoaXMuX2xheWVycy5mb3JFYWNoKGxheWVyID0+IHtcclxuICAgICAgbGF5ZXIuZGlzY2FyZCgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZGVsZXRlIHRoaXMuX2xheWVycztcclxuICAgIGRlbGV0ZSB0aGlzLl9sYXllck1hcDtcclxuXHJcbiAgICBzdXBlci5kaXNjYXJkKCk7XHJcbiAgfVxyXG59XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQW5pbWF0aW9uRmVhdHVyZSwgJ0VWRU5UUycsIHtcclxuICB2YWx1ZToge1xyXG4gICAgLi4uT2JqZWN0LmdldFByb3RvdHlwZU9mKEFic3RyYWN0SG9zdEZlYXR1cmUpLkVWRU5UUyxcclxuICAgIGFkZExheWVyOiAnb25BZGRMYXllckV2ZW50JyxcclxuICAgIHJlbW92ZUxheWVyOiAnb25SZW1vdmVMYXllckV2ZW50JyxcclxuICAgIHJlbmFtZUxheWVyOiAnb25SZW5hbWVMYXllckV2ZW50JyxcclxuICAgIGFkZEFuaW1hdGlvbjogJ29uQWRkQW5pbWF0aW9uRXZlbnQnLFxyXG4gICAgcmVtb3ZlQW5pbWF0aW9uOiAnb25SZW1vdmVkQW5pbWF0aW9uRXZlbnQnLFxyXG4gICAgcmVuYW1lQW5pbWF0aW9uOiAnb25SZW5hbWVBbmltYXRpb25FdmVudCcsXHJcbiAgICBwbGF5QW5pbWF0aW9uOiAnb25QbGF5RXZlbnQnLFxyXG4gICAgcGxheU5leHRBbmltYXRpb246ICdvbk5leHRFdmVudCcsXHJcbiAgICBwYXVzZUFuaW1hdGlvbjogJ29uUGF1c2VFdmVudCcsXHJcbiAgICByZXN1bWVBbmltYXRpb246ICdvblJlc3VtZUV2ZW50JyxcclxuICAgIGludGVycnVwdEFuaW1hdGlvbjogJ29uSW50ZXJydXB0RXZlbnQnLFxyXG4gICAgc3RvcEFuaW1hdGlvbjogJ29uU3RvcEV2ZW50JyxcclxuICB9LFxyXG59KTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEFuaW1hdGlvbkZlYXR1cmU7XHJcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcclxuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZXJzY29yZS1kYW5nbGUgKi9cclxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cclxuaW1wb3J0IE1hbmFnZWRBbmltYXRpb25MYXllckludGVyZmFjZSBmcm9tICcuL2FuaW1wYWNrL01hbmFnZWRBbmltYXRpb25MYXllckludGVyZmFjZSc7XHJcbmltcG9ydCB7IEFuaW1hdGlvblR5cGVzIH0gZnJvbSAnLi9hbmltcGFjay9BbmltYXRpb25GZWF0dXJlJztcclxuaW1wb3J0IFNTTUxTcGVlY2htYXJrSW50ZXJmYWNlIGZyb20gJy4vYXdzcGFjay9TU01MU3BlZWNobWFya0ludGVyZmFjZSc7XHJcbmltcG9ydCBBYnN0cmFjdEhvc3RGZWF0dXJlIGZyb20gJy4vQWJzdHJhY3RIb3N0RmVhdHVyZSc7XHJcbmltcG9ydCB7IFF1YWRyYXRpYyB9IGZyb20gJy4vYW5pbXBhY2svRWFzaW5nJztcclxuaW1wb3J0IE1hdGhVdGlscyBmcm9tICcuL01hdGhVdGlscyc7XHJcbmltcG9ydCBVdGlscyBmcm9tICcuL1V0aWxzJztcclxuXHJcbi8qKlxyXG4gKiBFbnVtIGZvciBheGlzIGRpcmVjdGlvbnMuXHJcbiAqXHJcbiAqIEByZWFkb25seVxyXG4gKiBAZW51bSB7Q2xhc3N9XHJcbiAqL1xyXG5jb25zdCBBeGlzTWFwID0ge1xyXG4gIFBvc2l0aXZlWDogWzEsIDAsIDBdLFxyXG4gIE5lZ2F0aXZlWDogWy0xLCAwLCAwXSxcclxuICBQb3NpdGl2ZVk6IFswLCAxLCAwXSxcclxuICBOZWdhdGl2ZVk6IFswLCAtMSwgMF0sXHJcbiAgUG9zaXRpdmVaOiBbMCwgMCwgMV0sXHJcbiAgTmVnYXRpdmVaOiBbMCwgMCwgLTFdLFxyXG59O1xyXG5cclxuY29uc3QgRmFjZVRhcmdldFR5cGVzID0ge1xyXG4gIEV5ZUNlbnRlcjogMCxcclxuICBFeWVMZWZ0OiAxLFxyXG4gIEV5ZVJpZ2h0OiAyLFxyXG4gIE1vdXRoOiAzLFxyXG59XHJcblxyXG4vLyBBdmVyYWdlIGRpc3RhbmNlIGJldHdlZW4gcHVwaWxzIGlzIC4wNjRtLCBnb2xkZW4gcmF0aW8gc2F5cyB0aGF0IHRoZSBkaXN0YW5jZVxyXG4vLyBmcm9tIGNlbnRlciBvZiB0aGUgcHVwaWxzIHRvIHRoZSBjZW50ZXIgb2YgdGhlIG1vdXRoIHNob3VsZCBiZSBhYm91dCB0aGUgc2FtZS5cclxuY29uc3QgRmFjZVZlY3RvcnMgPSBbXHJcbiAgWzAsIDAsIDBdLFxyXG4gIFstLjAzMiwgMCwgMF0sXHJcbiAgWy4wMzIsIDAsIDBdLFxyXG4gIFswLCAtLjA2NCwgMF1cclxuXTtcclxuXHJcbi8vIFRpbWUgcmFuZ2VzIHRvIHVzZSB3aGVuIGNob29zaW5nIGEgbmV3IHJhbmRvbSB3YWl0IHRpbWUgYmV0d2VlbiBzYWNjYWRlc1xyXG5jb25zdCBNaWNyb1NhY2NhZGVXYWl0UmFuZ2VzID0ge1xyXG4gIGRlZmF1bHQ6IFswLjgsIDEuNzVdLFxyXG4gIHBvc3RNYWNybzogWzAuNiwgMS4zMTI1XSxcclxufTtcclxuXHJcbmNvbnN0IE1hY3JvU2FjY2FkZVdhaXRSYW5nZXMgPSB7XHJcbiAgZGVmYXVsdDogWzUuMCwgOC4wXSxcclxuICBtb3V0aFRhcmdldDogWzAuMiwgMC43NV0sIC8vIExvb2sgYXdheSBmcm9tIGEgbW91dGggdGFyZ2V0IHRoZSBmYXN0ZXN0XHJcbiAgZXllVGFyZ2V0OiBbMS41LCA0LjBdXHJcbn07XHJcblxyXG4vLyBNaW5pbXVtIGFuZ2xlIGluIGRlZ3JlZXMgdGhlIGV5ZSBkaXJlY3Rpb24gbXVzdCBjaGFuZ2UgdG8gdHJpZ2dlciBhIGJsaW5rIGFuaW1hdGlvblxyXG5jb25zdCBCbGlua1RocmVzaG9sZCA9IDM1O1xyXG5cclxuLy8gTWF4aW11bSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHVzZSBmb3IgY2FsY3VsYXRpbmcgbG9vayBzcGVlZFxyXG5jb25zdCBNYXhEZWx0YSA9IDEwMCAvIDM7XHJcblxyXG4vKipcclxuICogUG9pbnRPZkludGVyZXN0IGNvbnRyb2xzIHRoZSBnYXplIGRpcmVjdGlvbiBvZiB0aGUgaG9zdC4gR2l2ZW4gb25lIG9yIG1vcmVcclxuICogYW5pbWF0aW9ucyBvZiB0eXBlIEJsZW5kMmRTdGF0ZSwgaXQgY2FsY3VsYXRlcyB0aGUgYW5nbGVzIGJldHdlZW4gdGhlIGxvb2tUcmFja2VyXHJcbiAqIG9iamVjdCAoZ2VuZXJhbGx5IGEgam9pbnQgaW4gdGhlIGhvc3QncyBza2VsZXRvbikgYW5kIHRoZSBsb29rVGFyZ2V0ICh0aGUgb2JqZWN0XHJcbiAqIHRoZSBob3N0IHNob3VsZCBsb29rIGF0KSBhbmQgZHJpdmVzIHRoZSBtYW5hZ2VkIEJsZW5kMmRTdGF0ZXMnIFggYW5kIFkgYmxlbmRcclxuICogdmFsdWVzIHVzaW5nIHRoZSByZXN1bHQuIFlvdSBjYW4gb3B0aW9uYWxseSBhZGQgc2FjY2FkaWMgbW92ZW1lbnQgdG8gYW55IG1hbmFnZWRcclxuICogYW5pbWF0aW9uIHRvIGhlbHAgbWFrZSB0aGUgaG9zdCdzIGV5ZXMgYXBwZWFyIGFsaXZlIHdoZW4gZm9jdXNlZCBvbiB0aGUgc2FtZVxyXG4gKiBwb2ludCBmb3IgZXh0ZWRlZCBwZXJpb2RzIG9mIHRpbWUuIElmIGJsaW5rIGFuaW1hdGlvbnMgYXJlIHNwZWNpZmllZCwgYSBibGlua1xyXG4gKiB3aWxsIGJlIHBsYXllZCBkdXJpbmcgbGFyZ2UgY2hhbmdlcyBpbiBnYXplIGRpcmVjdGlvbi5cclxuICpcclxuICogQGV4dGVuZHMgQWJzdHJhY3RIb3N0RmVhdHVyZVxyXG4gKiBAYWxpYXMgY29yZS9Qb2ludE9mSW50ZXJlc3RGZWF0dXJlXHJcbiAqIEBpbXBsZW1lbnRzIFNTTUxTcGVlY2htYXJrSW50ZXJmYWNlXHJcbiAqIEBpbXBsZW1lbnRzIE1hbmFnZWRBbmltYXRpb25MYXllckludGVyZmFjZVxyXG4gKi9cclxuY2xhc3MgUG9pbnRPZkludGVyZXN0RmVhdHVyZSBleHRlbmRzIEFic3RyYWN0SG9zdEZlYXR1cmUubWl4KFxyXG4gIFNTTUxTcGVlY2htYXJrSW50ZXJmYWNlLk1peGluLFxyXG4gIE1hbmFnZWRBbmltYXRpb25MYXllckludGVyZmFjZS5NaXhpblxyXG4pIHtcclxuICAvKipcclxuICAgKiBAY29uc3RydWN0b3JcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Y29yZS9Ib3N0T2JqZWN0fSBob3N0IC0gSG9zdCB0aGF0IG93bnMgdGhlIGZlYXR1cmUuXHJcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGZlYXR1cmUuXHJcbiAgICogQHBhcmFtIHtPYmplY3Q9fSB0YXJnZXQgLSAzRCB0cmFuc2Zvcm1hdGlvbiBub2RlIHRoYXQgdGhlIGhvc3Qgc2hvdWxkIHRyeSB0b1xyXG4gICAqIGxvb2sgYXQuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMubG9va1RyYWNrZXIgLSAzRCB0cmFuc2Zvcm1hdGlvbiBub2RlIHRoYXQgcmVwcmVzZW50c1xyXG4gICAqIHRoZSBkaXJlY3Rpb24gdGhlIGhvc3QgaXMgY3VycmVudGx5IGxvb2tpbmcgZHVyaW5nIGFuaW1hdGlvbi5cclxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMuc2NlbmUgLSBFbmdpbmUtc3BlY2lmaWMgc2NlbmUgb2JqZWN0IHRoYXQgY29udGFpbnNcclxuICAgKiB0aGUgaG9zdC4gVGhpcyBvYmplY3QgbXVzdCBiZSBkZWZpbmVkIGlmIHVzaW5nICdzZXRUYXJnZXRCeU5hbWUnIG9yICdTZXRUYXJnZXRCeUlkJ1xyXG4gICAqIG1ldGhvZHMuXHJcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBsb29rT3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBsb29rIGFuaW1hdGlvbiBsYXllcnMuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtsb29rT3B0aW9ucy5ibGVuZFRpbWU9MC4xXSAtIERlZmF1bHQgYW1vdW50IG9mIHRpbWUgaXQgd2lsbFxyXG4gICAqIHRha2UgdG8gbWFuaXB1bGF0ZSB0aGUgd2VpZ2h0cyBvZiB0aGUgbG9vayBsYXllcnMuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtsb29rT3B0aW9ucy5lYXNpbmdGbj1RdWFkcmF0aWMuSW5PdXRdIC0gRGVmYXVsdCBlYXNpbmcgZnVuY3Rpb25cclxuICAgKiB0byB1c2Ugd2hlbiBtYW5pcHVsYXRpbmcgbG9vayBsYXllciB3ZWlnaHRzLlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IFtsb29rT3B0aW9ucy5sYXllcnM9W11dIC0gQW4gYXJyYXkgb2YgbGF5ZXIgb3B0aW9uc1xyXG4gICAqIG9iamVjdHMgdG8gcmVnaXN0ZXIgYXMgbG9vayBsYXllcnMuXHJcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBibGlua09wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgYmxpbmsgYW5pbWF0aW9uIGxheWVycy5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW2JsaW5rT3B0aW9ucy5ibGVuZFRpbWU9MC4wNzVdIC0gRGVmYXVsdCBhbW91bnQgb2YgdGltZSBpdFxyXG4gICAqIHdpbGwgdGFrZSB0byBtYW5pcHVsYXRlIHRoZSB3ZWlnaHRzIG9mIHRoZSBibGluayBsYXllcnMuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtibGlua09wdGlvbnMuZWFzaW5nRm49UXVhZHJhdGljLkluT3V0XSAtIERlZmF1bHQgZWFzaW5nIGZ1bmN0aW9uXHJcbiAgICogdG8gdXNlIHdoZW4gbWFuaXB1bGF0aW5nIGJsaW5rIGxheWVyIHdlaWdodHMuXHJcbiAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gW2JsaW5rT3B0aW9ucy5sYXllcnM9W11dIC0gQW4gYXJyYXkgb2YgbGF5ZXIgb3B0aW9uc1xyXG4gICAqIG9iamVjdHMgdG8gcmVnaXN0ZXIgYXMgYmxpbmsgbGF5ZXJzLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgaG9zdCxcclxuICAgIHtcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICBsb29rVHJhY2tlcixcclxuICAgICAgc2NlbmVcclxuICAgIH0gPSB7fSxcclxuICAgIHtcclxuICAgICAgYmxlbmRUaW1lOiBsb29rQmxlbmRUaW1lID0gMC4xLFxyXG4gICAgICBlYXNpbmdGbjogbG9va0Vhc2luZ0ZuID0gUXVhZHJhdGljLkluT3V0LFxyXG4gICAgICBsYXllcnM6IGxvb2tMYXllcnMgPSBbXSxcclxuICAgIH0gPSB7fSxcclxuICAgIHtcclxuICAgICAgYmxlbmRUaW1lOiBibGlua0JsZW5kVGltZSA9IDAuMDc1LFxyXG4gICAgICBlYXNpbmdGbjogYmxpbmtFYXNpbmdGbiA9IFF1YWRyYXRpYy5Jbk91dCxcclxuICAgICAgbGF5ZXJzOiBibGlua0xheWVycyA9IFtdLFxyXG4gICAgfSA9IHt9XHJcbiAgKSB7XHJcbiAgICBzdXBlcihob3N0KTtcclxuXHJcbiAgICBpZiAoIXRoaXMuY29uc3RydWN0b3IuX3ZhbGlkYXRlVHJhbnNmb3JtT2JqZWN0KGxvb2tUcmFja2VyKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBpbml0aWFsaXplIFBvaW50T2ZJbnRlcmVzdEZlYXR1cmUgb24gaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBMb29rVHJhY2tlciBtdXN0IGJlIGRlZmluZWQgYXMgYSB2YWxpZCB0cmFuc2Zvcm1hdGlvbiBvYmplY3QuYCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9sb29rVHJhY2tlciA9IGxvb2tUcmFja2VyO1xyXG5cclxuICAgIHRoaXMuX3NjZW5lID0gc2NlbmU7XHJcbiAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQgfHwgbnVsbDtcclxuICAgIHRoaXMuX3ByZXZUYXJnZXRQb3MgPSBbMCwgMCwgMF07XHJcbiAgICB0aGlzLl9pc1RhcmdldE1vdmluZyA9IGZhbHNlO1xyXG4gICAgdGhpcy5fbG9va0xheWVycyA9IHRoaXMuX2xvb2tMYXllcnMgfHwge307XHJcbiAgICB0aGlzLl90cmFja2luZ0NvbmZpZ3MgPSB0aGlzLl90cmFja2luZ0NvbmZpZ3MgfHwgW107XHJcbiAgICB0aGlzLl9ibGlua0xheWVycyA9IHRoaXMuX2JsaW5rTGF5ZXJzIHx8IHt9O1xyXG5cclxuICAgIC8vIFJlZ2lzdGVyIHRoZSBsb29rIGxheWVyc1xyXG4gICAgbG9va0xheWVycy5mb3JFYWNoKCh7XHJcbiAgICAgIG5hbWUsXHJcbiAgICAgIGFuaW1hdGlvbixcclxuICAgICAgbWF4U3BlZWQsXHJcbiAgICAgIHJlZmVyZW5jZSxcclxuICAgICAgZm9yd2FyZEF4aXMsXHJcbiAgICAgIGhhc1NhY2NhZGUsXHJcbiAgICAgIGJsZW5kVGltZSxcclxuICAgICAgZWFzaW5nRm5cclxuICAgIH0pID0+IHtcclxuICAgICAgdGhpcy5yZWdpc3Rlckxvb2tMYXllcihuYW1lLCB7XHJcbiAgICAgICAgYW5pbWF0aW9uLFxyXG4gICAgICAgIG1heFNwZWVkLFxyXG4gICAgICAgIHJlZmVyZW5jZSxcclxuICAgICAgICBmb3J3YXJkQXhpcyxcclxuICAgICAgICBoYXNTYWNjYWRlLFxyXG4gICAgICAgIGJsZW5kVGltZTogYmxlbmRUaW1lICE9PSB1bmRlZmluZWQgPyBibGVuZFRpbWUgOiBsb29rQmxlbmRUaW1lLFxyXG4gICAgICAgIGVhc2luZ0ZuOiBlYXNpbmdGbiAhPT0gdW5kZWZpbmVkID8gZWFzaW5nRm4gOiBsb29rRWFzaW5nRm4sXHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gUmVnaXN0ZXIgdGhlIGJsaW5rIGxheWVyc1xyXG4gICAgYmxpbmtMYXllcnMuZm9yRWFjaCgoeyBuYW1lLCBhbmltYXRpb24sIGJsZW5kVGltZSwgZWFzaW5nRm4gfSkgPT4ge1xyXG4gICAgICB0aGlzLnJlZ2lzdGVyQmxpbmtMYXllcihuYW1lLCB7XHJcbiAgICAgICAgYW5pbWF0aW9uLFxyXG4gICAgICAgIGJsZW5kVGltZTogYmxlbmRUaW1lICE9PSB1bmRlZmluZWQgPyBibGVuZFRpbWUgOiBibGlua0JsZW5kVGltZSxcclxuICAgICAgICBlYXNpbmdGbjogZWFzaW5nRm4gIT09IHVuZGVmaW5lZCA/IGVhc2luZ0ZuIDogYmxpbmtFYXNpbmdGbixcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgYW5kIHNldHMgdGhlIHRhcmdldCBvYmplY3QgdGhlIGhvc3Qgc2hvdWxkIGxvb2sgYXQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fG51bGx9XHJcbiAgICovXHJcbiAgZ2V0IHRhcmdldCgpIHtcclxuICAgIHJldHVybiB0aGlzLl90YXJnZXQ7XHJcbiAgfVxyXG5cclxuICBzZXQgdGFyZ2V0KHRhcmdldCkge1xyXG4gICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0IHx8IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gYSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBnbG9iYWwgcG9zaXRpb24gb2YgYW4gb2JqZWN0LiBTaG91bGQgYmVcclxuICAgKiBvdmVybG9hZGVkIGZvciBlYWNoIHJlbmRlcmluZyBlbmdpbmUgaW1wbGVtZW50YXRpb24uXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHthbnl9IF9vYmogLSBFbmdpbmUtc3BlY2lmaWMgM0QgdHJhbnNmb3JtIG9iamVjdC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtBcnJheS48bnVtYmVyPn0gLSBBbiBhcnJheSBjb25zaXN0aW5nIG9mIHRocmVlIG51bWJlcnMgcmVwcmVzZW50aW5nXHJcbiAgICogeCwgeSBhbmQgeiBjb29yZGluYXRlcy5cclxuICAgKi9cclxuICBzdGF0aWMgX2dldFdvcmxkUG9zaXRpb24ob2JqKSB7XHJcbiAgICByZXR1cm4gWzAsIDAsIDBdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgbWF0cml4IHJlcHJlc2VudGluZyB0aGUgZ2xvYmFsIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBvZiBhbiBvYmplY3QuXHJcbiAgICogU2hvdWxkIGJlIG92ZXJsb2FkZWQgZm9yIGVhY2ggcmVuZGVyaW5nIGVuZ2luZSBpbXBsZW1lbnRhdGlvbi5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2FueX0gb2JqIC0gRW5naW5lLXNwZWNpZmljIDNEIHRyYW5zZm9ybSBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59IC0gQW4gYXJyYXkgY29uc2lzdGluZyBvZiAxNiBudW1iZXJzIHJlcHJlc2VudGluZ1xyXG4gICAqIHRoZSAzZCB0cmFuc2Zvcm1hdGlvbi5cclxuICAgKi9cclxuICBzdGF0aWMgX2dldFdvcmxkTWF0cml4KG9iaikge1xyXG4gICAgcmV0dXJuIFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJvdGF0ZSB0aGUgZ2l2ZW4gbG9jYWwgZGlyZWN0aW9uIHZlY3RvciBieSB0aGUgb2JqZWN0J3Mgd29ybGQgcm90YXRpb24gbWF0cml4LlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7YW55fSBvYmogLSBFbmdpbmUtc3BlY2lmaWMgM0QgdHJhbnNmb3JtIG9iamVjdC5cclxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBmb3J3YXJkVmVjdG9yIC0gVW5pdCB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBsb2NhbFxyXG4gICAqIGZvcndhcmQgZGlyZWN0aW9uIG9mIHRoZSBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59XHJcbiAgICovXHJcbiAgc3RhdGljIF9nZXRPYmplY3REaXJlY3Rpb24ob2JqLCBmb3J3YXJkVmVjdG9yID0gQXhpc01hcC5Qb3NpdGl2ZVopIHtcclxuICAgIGNvbnN0IHJvdGF0aW9uID0gTWF0aFV0aWxzLmdldFJvdGF0aW9uTWF0cml4KHRoaXMuX2dldFdvcmxkTWF0cml4KG9iaikpO1xyXG5cclxuICAgIHJldHVybiBNYXRoVXRpbHMucm90YXRlVmVjdG9yKGZvcndhcmRWZWN0b3IsIHJvdGF0aW9uKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZSBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBsb29rIGFuZ2xlcyBpbiBkZWdyZWVzIGdpdmVuIHNwaGVyaWNhbCB0aGV0YVxyXG4gICAqIGFuZCBwaGkgYW5nbGVzIGluIHJhZGlhbnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdGhldGEgLSBWZXJ0aWNhbC9wb2xhciBhbmdsZSBpbiByYWRpYW5zIHdoZXJlIDAgcG9pbnRzIGRpcmVjdGx5XHJcbiAgICogYWxvbmcgcG9zaXRpdmUgWSBheGlzLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaGkgLSBIb3Jpem9udGFsL2F6aW11dGhhbCBhbmdsZSBpbiByYWRpYW5zLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge09iamVjdH0gLSBBbiBvYmplY3Qgd2l0aCB0aGUgc2lnbmF0dXJlIHtoOiBudW1iZXIsIHY6IG51bWJlcn0gd2hlcmVcclxuICAgKiBoIHJlcHJlc2VudHMgaG9yaXpvbnRhbCByb3RhdGlvbiBpbiBkZWdyZWVzIGFuZCB2IHJlcHJlc2VudHMgdmVydGljYWwgcm90YXRpb25cclxuICAgKiBpbiBkZWdyZWVzLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBfc3BoZXJpY2FsVG9CbGVuZFZhbHVlKHRoZXRhLCBwaGkpIHtcclxuICAgIGNvbnN0IGggPSBNYXRoVXRpbHMudG9EZWdyZWVzKHBoaSk7XHJcblxyXG4gICAgLy8gT2Zmc2V0IHRoZSB2ZXJ0aWNhbCBhbmdsZSBzbyAwIGlzIHBvaW50aW5nIGZvcndhcmQgaW5zdGVhZCBvZiB1cFxyXG4gICAgY29uc3QgdiA9IE1hdGhVdGlscy50b0RlZ3JlZXModGhldGEpIC0gOTA7XHJcblxyXG4gICAgLy8gQ29udmVydCB2ZXJ0aWNhbCBhbmdsZSB0byAtMTgwLCAxODAgcmFuZ2VcclxuICAgIHJldHVybiB7IGgsIHYgfVxyXG4gIH1cclxuXHJcbiAgX29uTGF5ZXJBZGRlZCh7IG5hbWUgfSkge1xyXG4gICAgdGhpcy5fbG9va0xheWVycyA9IHRoaXMuX2xvb2tMYXllcnMgfHwge307XHJcbiAgICB0aGlzLl9ibGlua0xheWVycyA9IHRoaXMuX2JsaW5rTGF5ZXJzIHx8IHt9O1xyXG5cclxuICAgIHN1cGVyLl9vbkxheWVyQWRkZWQoeyBuYW1lIH0pO1xyXG5cclxuICAgIC8vIFZhbGlkYXRlIHRoZSBsb29rIGFuaW1hdGlvblxyXG4gICAgaWYgKHRoaXMuX2xvb2tMYXllcnNbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aGlzLl9yZWdpc3Rlckxvb2tBbmltYXRpb24obmFtZSwgdGhpcy5fbG9va0xheWVyc1tuYW1lXSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfb25BbmltYXRpb25BZGRlZCh7IGxheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSB9KSB7XHJcbiAgICB0aGlzLl9sb29rTGF5ZXJzID0gdGhpcy5fbG9va0xheWVycyB8fCB7fTtcclxuICAgIHRoaXMuX2JsaW5rTGF5ZXJzID0gdGhpcy5fYmxpbmtMYXllcnMgfHwge307XHJcblxyXG4gICAgc3VwZXIuX29uQW5pbWF0aW9uQWRkZWQoeyBsYXllck5hbWUgfSk7XHJcblxyXG4gICAgLy8gVmFsaWRhdGUgdGhlIGxvb2sgYW5pbWF0aW9uXHJcbiAgICBpZiAodGhpcy5fbG9va0xheWVyc1tsYXllck5hbWVdID09PSBhbmltYXRpb25OYW1lKSB7XHJcbiAgICAgIHRoaXMuX3JlZ2lzdGVyTG9va0FuaW1hdGlvbihsYXllck5hbWUsIGFuaW1hdGlvbk5hbWUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRW5zdXJlIHRoYXQgcmVnaXN0ZXJlZCBsb29rIGFuaW1hdGlvbnMgYXJlIEJsZW5kMmRTdGF0ZXMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRoYXQgY29udGFpbnMgdGhlIGxvb2sgYW5pbWF0aW9uLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbmltYXRpb25OYW1lIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uLlxyXG4gICAqL1xyXG4gIF9yZWdpc3Rlckxvb2tBbmltYXRpb24obGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lKSB7XHJcbiAgICBpZiAodGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdLmFuaW1hdGlvbnNbYW5pbWF0aW9uTmFtZV0uaXNBY3RpdmUpIHtcclxuICAgICAgaWYgKFxyXG4gICAgICAgIEFuaW1hdGlvblR5cGVzW3RoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5nZXRBbmltYXRpb25UeXBlKFxyXG4gICAgICAgICAgbGF5ZXJOYW1lLFxyXG4gICAgICAgICAgYW5pbWF0aW9uTmFtZVxyXG4gICAgICAgICldICE9PSBBbmltYXRpb25UeXBlcy5ibGVuZDJkXHJcbiAgICAgICkge1xyXG4gICAgICAgIC8vIFdhcm4gYW5kIGRlYWN0aXZhdGUgaWYgdGhlIHJlZ2lzdGVyZWQgc3RhdGUgaXMgbm90IGJsZW5kMmRcclxuICAgICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgICBgQ2Fubm90IHJlZ2lzdGVyIFBvaW50IG9mIEludGVyZXN0IGxvb2sgYW5pbWF0aW9uICR7YW5pbWF0aW9uTmFtZX0gb24gbGF5ZXIgJHtsYXllck5hbWV9IGZvciBob3N0ICR7dGhpcy5faG9zdC5pZH0uIExvb2sgYW5pbWF0aW9ucyBtdXN0IGJlIG9mIHR5cGUgJ2JsZW5kMmQnLmBcclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXS5hbmltYXRpb25zW1xyXG4gICAgICAgICAgYW5pbWF0aW9uTmFtZVxyXG4gICAgICAgIF0uaXNBY3RpdmUgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdGhlIGdpdmVuIG9iamVjdCBpcyBub3Qgb2YgYW4gZW5naW5lLXNwZWNpZmljIHR5cGUuIFNob3VsZFxyXG4gICAqIGJlIG92ZXJsb2FkZWQgZm9yIGVhY2ggcmVuZGVyaW5nIGVuZ2luZSBpbXBsZW1lbnRhdGlvbi5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2FueX0gb2JqIC0gT2JqZWN0IHRvIHZhbGlkYXRlLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgc3RhdGljIF92YWxpZGF0ZVRyYW5zZm9ybU9iamVjdChvYmopIHtcclxuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBPYmplY3Q7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiB0aGUgZ2l2ZW4gY29uZmlndXJhdGlvbiBvYmplY3QgaGFzIGFscmVhZHkgYmVlbiBzdG9yZWQgYXMgYSB0cmFja2luZ1xyXG4gICAqIGNvbmZpZy4gSWYgaXQgaGFzLCByZXR1cm4gdGhlIHN0b3JlZCBjb25maWd1cmF0aW9uLiBPdGhlcndpc2UsIHN0b3JlIGFuZFxyXG4gICAqIHJldHVybiBpdC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIC0gT2JqZWN0IGNvbnRhaW5pbmcgdHJhY2tlciwgcmVmZXJlbmNlIGFuZCBmb3J3YXJkQXhpc1xyXG4gICAqIHByb3BlcnRpZXMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gICAqL1xyXG4gIF9hZGRUcmFja2luZ0NvbmZpZyhjb25maWcpIHtcclxuICAgIGNvbnN0IHRyYWNraW5nQ29uZmlnID0gdGhpcy5fdHJhY2tpbmdDb25maWdzLmZpbmQoYyA9PlxyXG4gICAgICBjLnJlZmVyZW5jZSA9PT0gY29uZmlnLnJlZmVyZW5jZSAmJiBjLmZvcndhcmRBeGlzID09PSBjb25maWcuZm9yd2FyZEF4aXNcclxuICAgICk7XHJcblxyXG4gICAgaWYgKHRyYWNraW5nQ29uZmlnKSB7XHJcbiAgICAgIHJldHVybiB0cmFja2luZ0NvbmZpZztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbmZpZy5hbmdsZXMgPSB7IGg6IDAsIHY6IDAgfTtcclxuICAgICAgY29uZmlnLnByZXZBbmdsZXMgPSB7IGg6IDAsIHY6IDAgfTtcclxuICAgICAgdGhpcy5fdHJhY2tpbmdDb25maWdzLnB1c2goY29uZmlnKTtcclxuICAgICAgcmV0dXJuIGNvbmZpZztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgbG9vayB0cmFja2VyIGFuZCB0aGUgbG9vayB0YXJnZXQuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBfZ2V0VGFyZ2V0RGlzdGFuY2UoKSB7XHJcbiAgICAvLyBGaW5kIHRoZSB2ZWN0b3IgYmV0d2VlbiB0aGUgZ2xvYmFsIHBvc2l0aW9ucyBvZiB0cmFja2VyIGFuZCB0YXJnZXRcclxuICAgIGNvbnN0IHNvdXJjZVBvc2l0aW9uID0gdGhpcy5jb25zdHJ1Y3Rvci5fZ2V0V29ybGRQb3NpdGlvbih0aGlzLl9sb29rVHJhY2tlcik7XHJcbiAgICBjb25zdCB0YXJnZXRQb3NpdGlvbiA9IHRoaXMuY29uc3RydWN0b3IuX2dldFdvcmxkUG9zaXRpb24odGhpcy5fdGFyZ2V0KTtcclxuICAgIGNvbnN0IGxvb2tWZWN0b3IgPSBbXHJcbiAgICAgIHRhcmdldFBvc2l0aW9uWzBdIC0gc291cmNlUG9zaXRpb25bMF0sXHJcbiAgICAgIHRhcmdldFBvc2l0aW9uWzFdIC0gc291cmNlUG9zaXRpb25bMV0sXHJcbiAgICAgIHRhcmdldFBvc2l0aW9uWzJdIC0gc291cmNlUG9zaXRpb25bMl1cclxuICAgIF07XHJcblxyXG4gICAgcmV0dXJuIE1hdGhVdGlscy5nZXRWZWN0b3JNYWduaXR1ZGUobG9va1ZlY3Rvcik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXNldCBhbGwgc3RvcmVkIHRyYWNraW5nIGFuZ2xlcyB0byAwLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfcmVzZXRMb29rQW5nbGVzKCkge1xyXG4gICAgdGhpcy5fdHJhY2tpbmdDb25maWdzLmZvckVhY2goKHsgYW5nbGVzIH0pID0+IHtcclxuICAgICAgYW5nbGVzLmggPSAwO1xyXG4gICAgICBhbmdsZXMudiA9IDA7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0b3JlIHRoZSBkaWZmZXJlbmNlIGluIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIHJvdGF0aW9uIGZvciB0aGUgdHJhY2tlcidzXHJcbiAgICogcmVmZXJlbmNlIHJvdGF0aW9uIGFuZCB0aGUgZGlyZWN0aW9uIG9mIHRoZSB0YXJnZXQgZnJvbSB0aGUgdHJhY2tlci5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX3NldExvb2tBbmdsZXMoKSB7XHJcbiAgICAvLyBHZXQgdGhlIGN1cnJlbnQgcG9zaXRpb25zIG9mIHRoZSB0cmFja2VyIGFuZCB0YXJnZXQgb2JqZWN0c1xyXG4gICAgY29uc3QgdGFyZ2V0UG9zID0gdGhpcy5jb25zdHJ1Y3Rvci5fZ2V0V29ybGRQb3NpdGlvbih0aGlzLl90YXJnZXQpO1xyXG4gICAgY29uc3QgdHJhY2tlclBvcyA9IHRoaXMuY29uc3RydWN0b3IuX2dldFdvcmxkUG9zaXRpb24odGhpcy5fbG9va1RyYWNrZXIpO1xyXG5cclxuICAgIC8vIENoZWNrIGlmIHRoZSB0YXJnZXQgaGFzIG1vdmVkXHJcbiAgICB0aGlzLl9pc1RhcmdldE1vdmluZyA9IE1hdGhVdGlscy5nZXRWZWN0b3JNYWduaXR1ZGUoW1xyXG4gICAgICB0YXJnZXRQb3NbMF0gLSB0aGlzLl9wcmV2VGFyZ2V0UG9zWzBdLFxyXG4gICAgICB0YXJnZXRQb3NbMV0gLSB0aGlzLl9wcmV2VGFyZ2V0UG9zWzFdLFxyXG4gICAgICB0YXJnZXRQb3NbMl0gLSB0aGlzLl9wcmV2VGFyZ2V0UG9zWzJdXVxyXG4gICAgKSA+IDA7XHJcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuX3ByZXZUYXJnZXRQb3MsIHRhcmdldFBvcyk7XHJcblxyXG5cclxuICAgIC8vIENhbGN1bGF0ZSB0aGUgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgYW5nbGVzIHRvIHJvdGF0ZSB0byB0aGUgdGFyZ2V0XHJcbiAgICBjb25zdCB0YXJnZXRTcGhlcmljYWwgPSBNYXRoVXRpbHMuY2FydGVzaWFuVG9TcGhlcmljYWwoXHJcbiAgICAgIHRhcmdldFBvc1swXSAtIHRyYWNrZXJQb3NbMF0sXHJcbiAgICAgIHRhcmdldFBvc1sxXSAtIHRyYWNrZXJQb3NbMV0sXHJcbiAgICAgIHRhcmdldFBvc1syXSAtIHRyYWNrZXJQb3NbMl1cclxuICAgICk7XHJcbiAgICBjb25zdCB0YXJnZXRBbmdsZXMgPSB0aGlzLmNvbnN0cnVjdG9yLl9zcGhlcmljYWxUb0JsZW5kVmFsdWUoXHJcbiAgICAgIHRhcmdldFNwaGVyaWNhbFsxXSxcclxuICAgICAgdGFyZ2V0U3BoZXJpY2FsWzJdXHJcbiAgICApO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBhbmdsZXMgcmVsYXRpdmUgdG8gdGhlIHJlZmVyZW5jZSBvYmplY3RzXHJcbiAgICB0aGlzLl90cmFja2luZ0NvbmZpZ3MuZm9yRWFjaCgoe1xyXG4gICAgICByZWZlcmVuY2UsXHJcbiAgICAgIGZvcndhcmRBeGlzLFxyXG4gICAgICBhbmdsZXNcclxuICAgIH0pID0+IHtcclxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBhbmdsZXMgdG8gcm90YXRlIHRvIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHRyYWNrZXJcclxuICAgICAgY29uc3QgcmVmRGlyZWN0aW9uID0gdGhpcy5jb25zdHJ1Y3Rvci5fZ2V0T2JqZWN0RGlyZWN0aW9uKFxyXG4gICAgICAgIHJlZmVyZW5jZSxcclxuICAgICAgICBmb3J3YXJkQXhpcyxcclxuICAgICAgKTtcclxuICAgICAgY29uc3QgcmVmU3BoZXJpY2FsID0gTWF0aFV0aWxzLmNhcnRlc2lhblRvU3BoZXJpY2FsKC4uLnJlZkRpcmVjdGlvbik7XHJcbiAgICAgIGNvbnN0IHJlZkFuZ2xlcyA9IHRoaXMuY29uc3RydWN0b3IuX3NwaGVyaWNhbFRvQmxlbmRWYWx1ZShcclxuICAgICAgICByZWZTcGhlcmljYWxbMV0sXHJcbiAgICAgICAgcmVmU3BoZXJpY2FsWzJdXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBTdG9yZSB0aGUgZGlmZmVyZW5jZVxyXG4gICAgICBhbmdsZXMuaCA9IHRhcmdldEFuZ2xlcy5oIC0gcmVmQW5nbGVzLmg7XHJcbiAgICAgIGFuZ2xlcy52ID0gdGFyZ2V0QW5nbGVzLnYgLSByZWZBbmdsZXMudjtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoZSBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBhbmdsZXMgaXQgd291bGQgcmVxdWlyZSB0byBzaW11bGF0ZSBsb29raW5nXHJcbiAgICogYXQgdGhlIGdpdmVuIHR5cGUgb2YgZmFjZSB0YXJnZXRcclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0VHlwZSAtIEludGVnZXIgcmVwcmVzZW50aW5nIHRoZSBGYWNlVGFyZ2V0VHlwZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtPYmplY3R9LSBBbiBvYmplY3Qgd2l0aCBzaWduYXR1cmUge3I6IG51bWJlciwgaDogbnVtYmVyLCB2OiBudW1iZXJ9XHJcbiAgICogd2hlcmUgJ3InIHJlcHJlc2VudHMgcmFkaXVzLCBoIHJlcHJlc2VudHMgdGhlIGhvcml6b250YWwvYXppbXV0aGFsIGFuZ2xlIGFuZFxyXG4gICAqIHYgcmVwcmVzZW50cyB0aGUgdmVydGljYWwvcG9sYXIgYW5nbGUuXHJcbiAgICovXHJcbiAgX2dldEZhY2VUYXJnZXRBbmdsZXModGFyZ2V0VHlwZSkge1xyXG4gICAgLy8gTm8gb2Zmc2V0IHdoZW4gdGhlIHRhcmdldCBpcyB0aGUgY2VudGVyIG9mIHRoZSBleWVzXHJcbiAgICBpZiAodGFyZ2V0VHlwZSA9PT0gMCkge1xyXG4gICAgICByZXR1cm4geyBoOiAwLCB2OiAwIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQnVpbGQgYSB2ZWN0b3IgdG8gdGhlIGZhY2UgdGFyZ2V0IHR5cGUgdXNpbmcgdGhlIGN1cnJlbnQgZGlzdGFuY2UgdG8gdGhlIHRhcmdldFxyXG4gICAgY29uc3QgZGlzdGFuY2UgPSB0aGlzLl9nZXRUYXJnZXREaXN0YW5jZSh0aGlzLl9sb29rVHJhY2tlcik7XHJcbiAgICBjb25zdCBmYWNlVmVjdG9yID0gWy4uLkZhY2VWZWN0b3JzW3RhcmdldFR5cGVdXTtcclxuICAgIGZhY2VWZWN0b3JbMl0gPSBkaXN0YW5jZTtcclxuICAgIGNvbnN0IHNwaGVyaWNhbCA9IE1hdGhVdGlscy5jYXJ0ZXNpYW5Ub1NwaGVyaWNhbCguLi5mYWNlVmVjdG9yKTtcclxuXHJcbiAgICAvLyBNYWtlIHN1cmUgdmFsdWVzIGFyZSBjbGFtcGVkIHdpdGhpbiB0aGUgcmFuZ2Ugb2YgbW90aW9uIG9mIHRoZSBodW1hbiBleWUsIGluIGNhc2UgdGhlIHRhcmdldCBpcyB2ZXJ5IGNsb3NlXHJcbiAgICBjb25zdCBibGVuZFZhbHVlcyA9IHRoaXMuY29uc3RydWN0b3IuX3NwaGVyaWNhbFRvQmxlbmRWYWx1ZShzcGhlcmljYWxbMV0sIHNwaGVyaWNhbFsyXSk7XHJcbiAgICBibGVuZFZhbHVlcy5oID0gTWF0aFV0aWxzLmNsYW1wKGJsZW5kVmFsdWVzLmgsIC0zNSwgMzUpO1xyXG4gICAgYmxlbmRWYWx1ZXMudiA9IE1hdGhVdGlscy5jbGFtcChibGVuZFZhbHVlcy52LCAtMjUsIDMwKTtcclxuXHJcbiAgICByZXR1cm4gYmxlbmRWYWx1ZXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGVkIHRoZSBzdG9yZWQgc3BlZWQgYW5kIGR1cmF0aW9uIHZhcmlhYmxlcyBmb3IgYSBsYXllciBiYXNlZCBvbiB0aGVcclxuICAgKiBjaGFuZ2UgaW4gaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgYW5nbGVzIG9mIHRoZSB0cmFja2VyLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0byBzdG9yZSB2YWx1ZXMgb24uXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGggLSBDaGFuZ2UgaW4gaG9yaXpvbnRhbCBhbmdsZSwgaW4gZGVncmVlcy5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gdiAtIENoYW5nZSBpbiB2ZXJ0aWNhbCBhbmdsZSwgaW4gZGVncmVlcy5cclxuICAgKi9cclxuICBfdXBkYXRlTGF5ZXJTcGVlZChsYXllck5hbWUsIGgsIHYpIHtcclxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdO1xyXG5cclxuICAgIC8vIEZyb20gXCJSZWFsaXN0aWMgQXZhdGFyIGFuZCBoZWFkIEFuaW1hdGlvbiBVc2luZyBhIE5ldXJvYmlvbG9naWNhbCBNb2RlbCBvZiBWaXN1YWwgQXR0ZW50aW9uXCIsIEl0dGksIERoYXZhbGUsIFBpZ2hpblxyXG4gICAgbGF5ZXIubWF4SFNwZWVkID0gNDczICogKDEgLSBNYXRoLmV4cCgtaCAvIDcuOCkpO1xyXG4gICAgbGF5ZXIubWF4VlNwZWVkID0gNDczICogKDEgLSBNYXRoLmV4cCgtdiAvIDcuOCkpO1xyXG5cclxuICAgIC8vIEZyb20gXCJFeWVzIEFsaXZlXCIsIExlZSwgQmFkbGVyXHJcbiAgICBjb25zdCBEMCA9IDAuMDI1O1xyXG4gICAgY29uc3QgZCA9IDAuMDAyMzU7XHJcbiAgICBsYXllci5oRHVyYXRpb24gPSBEMCArIGQgKiBoO1xyXG4gICAgbGF5ZXIudkR1cmF0aW9uID0gRDAgKyBkICogdjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgbWljcm9TYWNjYWRlIG9iamVjdCB3aXRoIG5ldyByYW5kb21pemVkIHZhbHVlcy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCBvd25zIHRoZSBzYWNjYWRlIG1vdGlvbi5cclxuICAgKi9cclxuICBfc2V0TWljcm9TYWNjYWRlKGxheWVyTmFtZSkge1xyXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV07XHJcbiAgICBjb25zdCB7IG1pY3JvU2FjY2FkZSB9ID0gbGF5ZXI7XHJcblxyXG4gICAgaWYgKHRoaXMuX3RhcmdldCkge1xyXG4gICAgICAvLyBNaWNybyBtb3ZlbWVudHMgc2hvdWxkIGJlIHNtYWxsZXIgd2hlbiBmb2N1c2VkIG9uIGEgdGFyZ2V0XHJcbiAgICAgIG1pY3JvU2FjY2FkZS5oID0gVXRpbHMuZ2V0UmFuZG9tRmxvYXQoLjAxLCAuMTUpO1xyXG4gICAgICBtaWNyb1NhY2NhZGUudiA9IFV0aWxzLmdldFJhbmRvbUZsb2F0KC4wMSwgLjE1KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIE1pY3Jvc2FjY2FkZXMuIEVuY3ljbG9wZWRpYSBvZiBOZXVyb3NjaWVuY2UuICgyMDA5KSBTcHJpbmdlciwgQmVybGluLCBIZWlkZWxiZXJnLiBodHRwczovL2RvaS5vcmcvMTAuMTAwNy85NzgtMy01NDAtMjk2NzgtMl8zNDkyXHJcbiAgICAgIG1pY3JvU2FjY2FkZS5oID0gVXRpbHMuZ2V0UmFuZG9tRmxvYXQoLjAxLCAuMyk7XHJcbiAgICAgIG1pY3JvU2FjY2FkZS52ID0gVXRpbHMuZ2V0UmFuZG9tRmxvYXQoLjAxLCAuMyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fdXBkYXRlTGF5ZXJTcGVlZChsYXllck5hbWUsIG1pY3JvU2FjY2FkZS5oLCBtaWNyb1NhY2NhZGUudik7XHJcblxyXG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXJcclxuICAgIHRoaXMuX2luaXRpYWxpemVNaWNyb1RpbWVyKGxheWVyTmFtZSwgLi4uTWljcm9TYWNjYWRlV2FpdFJhbmdlcy5kZWZhdWx0KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgbWFjcm9TYWNjYWRlIG9iamVjdCB3aXRoIG5ldyByYW5kb21pemVkIHZhbHVlcy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCBvd25zIHRoZSBzYWNjYWRlIG1vdGlvbi5cclxuICAgKi9cclxuICBfc2V0TWFjcm9TYWNjYWRlKGxheWVyTmFtZSkge1xyXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV07XHJcbiAgICBjb25zdCB7IG1hY3JvU2FjY2FkZSB9ID0gbGF5ZXI7XHJcbiAgICBsZXQgbWFjcm9TYWNjYWRlV2FpdFJhbmdlO1xyXG5cclxuICAgIC8vIEluY3JlYXNlIHJhbmRvbSB2YWx1ZSByYW5nZSB3aGVuIG5vdCBmb2N1c2VkIG9uIGEgdGFyZ2V0XHJcbiAgICBpZiAoIXRoaXMuX3RhcmdldCkge1xyXG4gICAgICBtYWNyb1NhY2NhZGVXYWl0UmFuZ2UgPSBNYWNyb1NhY2NhZGVXYWl0UmFuZ2VzLmRlZmF1bHQ7XHJcblxyXG4gICAgICAvLyBOb3JtYWwgaHVtYW4gaG9yaXpvbnRhbCBleWUgcm90YXRpb24gbGltaXQgaXMgYWJvdXQgMzUgZGVncmVlc1xyXG4gICAgICBjb25zdCBoTGltaXQgPSBVdGlscy5nZXRSYW5kb21GbG9hdCguMTQzLCAuMjg2KTtcclxuICAgICAgY29uc3QgaEZhY3RvciA9IFV0aWxzLmdldFJhbmRvbUZsb2F0KC1oTGltaXQsIGhMaW1pdCk7XHJcbiAgICAgIG1hY3JvU2FjY2FkZS5oID0gaEZhY3RvciAqIDM1O1xyXG5cclxuICAgICAgLy8gTm9ybWFsIGh1bWFuIHZlcnRpY2FsIGV5ZSByb3RhdGlvbiBsaW1pdCBpcyBhYm91dCAyNSBkZWdyZWVzIHVwd2FyZCBhbmQgMzAgZGVncmVlcyBkb3dud2FyZFxyXG4gICAgICBjb25zdCB2TGltaXQgPSBVdGlscy5nZXRSYW5kb21GbG9hdCguMDkzLCAuMTg2KTtcclxuICAgICAgY29uc3QgdkZhY3RvciA9IFV0aWxzLmdldFJhbmRvbUZsb2F0KC12TGltaXQsIHZMaW1pdCk7XHJcbiAgICAgIG1hY3JvU2FjY2FkZS52ID0gdkZhY3RvciA+IDAgPyB2RmFjdG9yICogMjUgOiB2RmFjdG9yICogMzA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUGljayBhIG5ldyBmYWNlIHRhcmdldFxyXG4gICAgZWxzZSB7XHJcbiAgICAgIC8vIFNvY2lhbCB0cmlhbmdsZSAtIHNhY2NhZGUgYmV0d2VlbiBleWVzIGFuZCBtb3V0aCwgd2VpZ2h0ZWQgdG8gbG9vayBhdCBleWVzIG1vcmUgb2Z0ZW5cclxuICAgICAgc3dpdGNoIChsYXllci5zYWNjYWRlVGFyZ2V0KSB7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgbWFjcm9TYWNjYWRlV2FpdFJhbmdlID0gTWFjcm9TYWNjYWRlV2FpdFJhbmdlcy5leWVUYXJnZXQ7XHJcbiAgICAgICAgICBsYXllci5zYWNjYWRlVGFyZ2V0ID0gTWF0aC5yYW5kb20oKSA8IDAuNzUgPyBGYWNlVGFyZ2V0VHlwZXMuRXllUmlnaHRcclxuICAgICAgICAgICAgOiBGYWNlVGFyZ2V0VHlwZXMuTW91dGg7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICBtYWNyb1NhY2NhZGVXYWl0UmFuZ2UgPSBNYWNyb1NhY2NhZGVXYWl0UmFuZ2VzLmV5ZVRhcmdldDtcclxuICAgICAgICAgIGxheWVyLnNhY2NhZGVUYXJnZXQgPSBNYXRoLnJhbmRvbSgpIDwgMC43NSA/IEZhY2VUYXJnZXRUeXBlcy5FeWVMZWZ0XHJcbiAgICAgICAgICAgIDogRmFjZVRhcmdldFR5cGVzLk1vdXRoO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgbWFjcm9TYWNjYWRlV2FpdFJhbmdlID0gTWFjcm9TYWNjYWRlV2FpdFJhbmdlcy5tb3V0aFRhcmdldDtcclxuICAgICAgICAgIGxheWVyLnNhY2NhZGVUYXJnZXQgPSBNYXRoLnJhbmRvbSgpIDwgMC41ID8gRmFjZVRhcmdldFR5cGVzLkV5ZUxlZnRcclxuICAgICAgICAgICAgOiBGYWNlVGFyZ2V0VHlwZXMuRXllUmlnaHQ7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIG1hY3JvU2FjY2FkZVdhaXRSYW5nZSA9IE1hY3JvU2FjY2FkZVdhaXRSYW5nZXMuZXllVGFyZ2V0O1xyXG4gICAgICAgICAgbGF5ZXIuc2FjY2FkZVRhcmdldCA9IE1hdGgucmFuZG9tKCkgPCAwLjUgPyBGYWNlVGFyZ2V0VHlwZXMuRXllTGVmdFxyXG4gICAgICAgICAgICA6IEZhY2VUYXJnZXRUeXBlcy5FeWVSaWdodDtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCB7IGgsIHYgfSA9IHRoaXMuX2dldEZhY2VUYXJnZXRBbmdsZXMobGF5ZXIuc2FjY2FkZVRhcmdldCk7XHJcbiAgICAgIG1hY3JvU2FjY2FkZS5oID0gaDtcclxuICAgICAgbWFjcm9TYWNjYWRlLnYgPSB2O1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3VwZGF0ZUxheWVyU3BlZWQobGF5ZXJOYW1lLCBtYWNyb1NhY2NhZGUuaCwgbWFjcm9TYWNjYWRlLnYpO1xyXG5cclxuICAgIC8vIFJlc3RhcnQgdGhlIHRpbWVyc1xyXG4gICAgdGhpcy5faW5pdGlhbGl6ZU1pY3JvVGltZXIobGF5ZXJOYW1lLCAuLi5NaWNyb1NhY2NhZGVXYWl0UmFuZ2VzLnBvc3RNYWNybyk7XHJcbiAgICB0aGlzLl9pbml0aWFsaXplTWFjcm9UaW1lcihsYXllck5hbWUsIC4uLm1hY3JvU2FjY2FkZVdhaXRSYW5nZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFydCBhIG5ldyB3YWl0IHRpbWVyIHRoYXQgd2lsbCBzZXQgYSBuZXcgbWljcm8gc2FjY2FkZSBtb3ZlbWVudCB3aGVuIGl0XHJcbiAgICogcmVzb2x2ZXMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRoYXQgb3ducyB0aGUgc2FjY2FkZSBtb3Rpb24uXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pbldhaXRUaW1lIC0gTWluaW11bSBudW1iZXIgb2Ygc2Vjb25kcyBiZWZvcmUgYSBuZXcgc2FjY2FkZVxyXG4gICAqIHdpbGwgYmUgdHJpZ2dlcmVkLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhXYWl0VGltZSAtIE1heGltdW0gbnVtYmVyIG9mIHNlY29uZHMgYmVmb3JlIGEgbmV3IHNhY2NhZGVcclxuICAgKiB3aWxsIGJlIHRyaWdnZXJlZC5cclxuICAgKi9cclxuICBfaW5pdGlhbGl6ZU1pY3JvVGltZXIobGF5ZXJOYW1lLCBtaW5XYWl0VGltZSwgbWF4V2FpdFRpbWUpIHtcclxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdO1xyXG4gICAgY29uc3Qgd2FpdFRpbWUgPSBVdGlscy5nZXRSYW5kb21GbG9hdChtaW5XYWl0VGltZSwgbWF4V2FpdFRpbWUpO1xyXG5cclxuICAgIGlmIChsYXllci5taWNyb1NhY2NhZGVUaW1lcikge1xyXG4gICAgICBsYXllci5taWNyb1NhY2NhZGVUaW1lci5jYW5jZWwoKTtcclxuICAgIH1cclxuICAgIGxheWVyLm1pY3JvU2FjY2FkZVRpbWVyID0gVXRpbHMud2FpdCh3YWl0VGltZSwge1xyXG4gICAgICBvbkZpbmlzaDogKCkgPT4geyB0aGlzLl9zZXRNaWNyb1NhY2NhZGUobGF5ZXJOYW1lKSB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0IGEgbmV3IHdhaXQgdGltZXIgdGhhdCB3aWxsIHNldCBhIG5ldyBtYWNybyBzYWNjYWRlIG1vdmVtZW50IHdoZW4gaXRcclxuICAgKiByZXNvbHZlcy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCBvd25zIHRoZSBzYWNjYWRlIG1vdGlvbi5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluV2FpdFRpbWUgLSBNaW5pbXVtIG51bWJlciBvZiBzZWNvbmRzIGJlZm9yZSBhIG5ldyBzYWNjYWRlXHJcbiAgICogd2lsbCBiZSB0cmlnZ2VyZWQuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heFdhaXRUaW1lIC0gTWF4aW11bSBudW1iZXIgb2Ygc2Vjb25kcyBiZWZvcmUgYSBuZXcgc2FjY2FkZVxyXG4gICAqIHdpbGwgYmUgdHJpZ2dlcmVkLlxyXG4gICAqL1xyXG4gIF9pbml0aWFsaXplTWFjcm9UaW1lcihsYXllck5hbWUsIG1pbldhaXRUaW1lLCBtYXhXYWl0VGltZSkge1xyXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV07XHJcbiAgICBjb25zdCB3YWl0VGltZSA9IFV0aWxzLmdldFJhbmRvbUZsb2F0KG1pbldhaXRUaW1lLCBtYXhXYWl0VGltZSk7XHJcblxyXG4gICAgaWYgKGxheWVyLm1hY3JvU2FjY2FkZVRpbWVyKSB7XHJcbiAgICAgIGxheWVyLm1hY3JvU2FjY2FkZVRpbWVyLmNhbmNlbCgpO1xyXG4gICAgfVxyXG4gICAgbGF5ZXIubWFjcm9TYWNjYWRlVGltZXIgPSBVdGlscy53YWl0KHdhaXRUaW1lLCB7XHJcbiAgICAgIG9uRmluaXNoOiAoKSA9PiB7IHRoaXMuX3NldE1hY3JvU2FjY2FkZShsYXllck5hbWUpIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyBhIG5ldyB0YXJnZXQgdG8gbG9vayBhdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IHRhcmdldCAtIFRoZSBuZXcgdGFyZ2V0IHRvIGxvb2sgYXQuXHJcbiAgICovXHJcbiAgc2V0VGFyZ2V0KHRhcmdldCkge1xyXG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGaW5kcyBhbiBvYmplY3QgZ2l2ZW4gaXRzIG5hbWUgYW5kIHNldHMgaXQgYXMgdGhlIG5ldyB0YXJnZXQgdG8gbG9vayBhdC5cclxuICAgKiBTaG91bGQgYmUgb3ZlcmxvYWRlZCBmb3IgZWFjaCByZW5kZXJpbmcgZW5naW5lIGltcGxlbWVudGF0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldCAtIE5hbWUgdG8gc2VhcmNoIGZvci5cclxuICAgKi9cclxuICBzZXRUYXJnZXRCeU5hbWUobmFtZSkge1xyXG4gICAgaWYgKCFuYW1lKSB7XHJcbiAgICAgIHRoaXMuX3RhcmdldCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0aGlzLl9zY2VuZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBzZXQgUG9pbnRPZkludGVyZXN0RmVhdHVyZSB0YXJnZXQgdXNpbmcgbmFtZSAke25hbWV9IG9uIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gU2NlbmUgbXVzdCBiZSBkZWZpbmVkLmApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmluZHMgYW4gb2JqZWN0IGdpdmVuIGl0cyBpZCBhbmQgc2V0cyBpdCBhcyB0aGUgbmV3IHRhcmdldCB0byBsb29rIGF0LlxyXG4gICAqIFNob3VsZCBiZSBvdmVybG9hZGVkIGZvciBlYWNoIHJlbmRlcmluZyBlbmdpbmUgaW1wbGVtZW50YXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHRhcmdldCAtIElkIHRvIHNlYXJjaCBmb3IuXHJcbiAgICovXHJcbiAgc2V0VGFyZ2V0QnlJZChpZCkge1xyXG4gICAgaWYgKCFpZCkge1xyXG4gICAgICB0aGlzLl90YXJnZXQgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdGhpcy5fc2NlbmUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgc2V0IFBvaW50T2ZJbnRlcmVzdEZlYXR1cmUgdGFyZ2V0IHVzaW5nIGlkICR7aWR9IG9uIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gU2NlbmUgbXVzdCBiZSBkZWZpbmVkLmApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnQga2VlcGluZyB0cmFjayBvZiBhbiBhbmltYXRpb24gbGF5ZXIgdGhhdCBvd25zIGEgYmxlbmQyZCBhbmltYXRpb24gd2l0aFxyXG4gICAqIGJsZW5kV2VpZ2h0cyBjb3JyZXNwb25kaW5nIHRvIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGxvb2sgYW5nbGVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRvIGtlZXAgdHJhY2sgb2YuXHJcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGxheWVyLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb24gPSAnbG9vayddIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uIG9uIHRoZVxyXG4gICAqIGxheWVyIHdob3NlIGJsZW5kV2VpZ2h0cyB3aWxsIGJlIGRyaXZlbiBiYXNlZCBvbiB0aGUgYW5nbGUgYmV0d2VlbiB0aGUgbG9va1RyYWNrZXJcclxuICAgKiBhbmQgdGhlIGxvb2tUYXJnZXQuIFRoaXMgYW5pbWF0aW9uIG11c3QgYmUgb2YgdHlwZSBibGVuZDJkLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhTcGVlZCA9IDI1XSAtIFRoZSBtYXhpbXVtIHNwZWVkIGF0IHdoaWNoIHRoZSBibGVuZDJkXHJcbiAgICogYmxlbmRXZWlnaHRzIGNhbiBiZSBtYW5pcHVsYXRlZC5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZm9yd2FyZEF4aXMgPSAnUG9zaXRpdmVaJ10gLSBBeGlzIHBvaW50aW5nIGZyb20gdGhlXHJcbiAgICogZnJvbnQgb2YgdGhlIGxvb2tSZWZlcmVuY2Ugb2JqZWN0LiBWYWxpZCBvcHRpb25zIGFyZSAnUG9zaXRpdmVYJywgJ05lZ2F0aXZlWCcsXHJcbiAgICogJ1Bvc2l0aXZlWScsICdOZWdhdGl2ZVknLCAnUG9zaXRpdmVaJywgJ05lZ2F0aXZlWicuXHJcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zLmxvb2tSZWZlcmVuY2UgLSAzRCB0cmFuc2Zvcm1hdGlvbiBub2RlIHRoYXQgdGhlIGxvb2tUcmFja2VyXHJcbiAgICogcm90YXRpb24gbGltaXRzIHNob3VsZCBiZSBjYWxjdWxhdGVkIHJlbGF0aXZlIHRvLiBEZWZhdWx0cyB0byB0aGUgaG9zdCBvd25lci5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaGFzU2FjY2FkZSA9IGZhbHNlXSAtIFdoZXRoZXIgb3Igbm90IHRvIGluY2x1ZGVcclxuICAgKiBzYWNjYWRpYyBtb3Rpb24gb250byB0aGUgYmxlbmRXZWlnaHQgYW5pbWF0aW9uLiBUaGlzIHNob3VsZCBvbmx5IGJlIHNldCB0b1xyXG4gICAqIHRydWUgZm9yIGJsZW5kMmQgYW5pbWF0aW9ucyByZXByZXNlbnRpbmcgZXllIGFuaW1hdGlvbi5cclxuICAgKiBAcGFyYW0ge251bWJlcj19IFtvcHRpb25zLmJsZW5kVGltZT1bUG9pbnRPZkludGVyZXN0RmVhdHVyZS5ERUZBVUxUX0xBWUVSX09QVElPTlMuYmxlbmRUaW1lXXtAbGluayBQb2ludE9mSW50ZXJlc3RGZWF0dXJlI0RFRkFVTFRfTEFZRVJfT1BUSU9OUyNibGVuZFRpbWV9XSAtXHJcbiAgICogRGVmYXVsdCBhbW91bnQgb2YgdGltZSB0byB1c2Ugd2hlbiBtYW5pcHVsYXRpbmcgbGF5ZXIgd2VpZ2h0LlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvcHRpb25zLmVhc2luZ0ZuIC0gRGVmYXVsdCBlYXNpbmcgZnVuY3Rpb24gdG8gdXNlIHdoZW5cclxuICAgKiBtYW5pcHVsYXRpbmcgbGF5ZXIgd2VpZ2h0LlxyXG4gICAqL1xyXG4gIHJlZ2lzdGVyTG9va0xheWVyKFxyXG4gICAgbGF5ZXJOYW1lLFxyXG4gICAge1xyXG4gICAgICBhbmltYXRpb24gPSAnbG9vaycsXHJcbiAgICAgIG1heFNwZWVkID0gMjUsXHJcbiAgICAgIHJlZmVyZW5jZSxcclxuICAgICAgZm9yd2FyZEF4aXMgPSAnUG9zaXRpdmVaJyxcclxuICAgICAgaGFzU2FjY2FkZSA9IGZhbHNlLFxyXG4gICAgICBibGVuZFRpbWUgPSBQb2ludE9mSW50ZXJlc3RGZWF0dXJlLkRFRkFVTFRfTEFZRVJfT1BUSU9OUy5ibGVuZFRpbWUsXHJcbiAgICAgIGVhc2luZ0ZuXHJcbiAgICB9ID0ge31cclxuICApIHtcclxuICAgIC8vIFZhbGlkYXRlIHJlZmVyZW5jZSBvYmplY3RcclxuICAgIHJlZmVyZW5jZSA9IHJlZmVyZW5jZSB8fCB0aGlzLl9ob3N0Lm93bmVyO1xyXG5cclxuICAgIGlmICghdGhpcy5jb25zdHJ1Y3Rvci5fdmFsaWRhdGVUcmFuc2Zvcm1PYmplY3QocmVmZXJlbmNlKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBpbml0aWFsaXplIHJlZ2lzdGVyIGxvb2sgbGF5ZXIgJHtsYXllck5hbWV9IGZvciBQb2ludE9mSW50ZXJlc3RGZWF0dXJlIG9uIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gUmVmZXJlbmNlIG11c3QgYmUgZGVmaW5lZCBhcyBhIHZhbGlkIHRyYW5zZm9ybWF0aW9uIG9iamVjdC5gKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGaW5kIHZlY3RvciBhc3NvY2lhdGVkIHdpdGggYXhpcyBzdHJpbmdcclxuICAgIGZvcndhcmRBeGlzID0gQXhpc01hcFtmb3J3YXJkQXhpc10gIT09IHVuZGVmaW5lZFxyXG4gICAgICA/IEF4aXNNYXBbZm9yd2FyZEF4aXNdXHJcbiAgICAgIDogQXhpc01hcC5Qb3NpdGl2ZVo7XHJcblxyXG4gICAgLy8gU3RvcmUgdHJhY2tpbmcgY29uZmlndXJhdGlvblxyXG4gICAgY29uc3QgdHJhY2tpbmdDb25maWcgPSB0aGlzLl9hZGRUcmFja2luZ0NvbmZpZyh7XHJcbiAgICAgIHJlZmVyZW5jZSxcclxuICAgICAgZm9yd2FyZEF4aXNcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFJlZ2lzdGVyIHRoZSBsYXllciBhbmQgYW5pbWF0aW9uXHJcbiAgICB0aGlzLnJlZ2lzdGVyTGF5ZXIobGF5ZXJOYW1lLCB7XHJcbiAgICAgIHRyYWNraW5nQ29uZmlnLFxyXG4gICAgICBtYXhTcGVlZCxcclxuICAgICAgbWF4SFNwZWVkOiB1bmRlZmluZWQsXHJcbiAgICAgIG1heFZTcGVlZDogdW5kZWZpbmVkLFxyXG4gICAgICBoRHVyYXRpb246IHVuZGVmaW5lZCxcclxuICAgICAgdkR1cmF0aW9uOiB1bmRlZmluZWQsXHJcbiAgICAgIGhWZWxvY2l0eTogWzAsIDBdLFxyXG4gICAgICB2VmVsb2NpdHk6IFswLCAwXSxcclxuICAgICAgaGFzU2FjY2FkZSxcclxuICAgICAgYmxlbmRUaW1lLFxyXG4gICAgICBlYXNpbmdGbixcclxuICAgICAgbWljcm9TYWNjYWRlOiB7IGg6IDAsIHY6IDAgfSxcclxuICAgICAgbWFjcm9TYWNjYWRlOiB7IGg6IDAsIHY6IDAgfSxcclxuICAgICAgc2FjY2FkZVRhcmdldDogRmFjZVRhcmdldFR5cGVzLkV5ZUNlbnRlcixcclxuICAgICAgYW5pbWF0aW9uczogeyBbYW5pbWF0aW9uXToge30gfSxcclxuICAgIH0pO1xyXG4gICAgdGhpcy5fbG9va0xheWVyc1tsYXllck5hbWVdID0gYW5pbWF0aW9uO1xyXG5cclxuICAgIC8vIFZhbGlkYXRlIHRoZSBsb29rIGFuaW1hdGlvblxyXG4gICAgdGhpcy5fcmVnaXN0ZXJMb29rQW5pbWF0aW9uKGxheWVyTmFtZSwgYW5pbWF0aW9uKTtcclxuXHJcbiAgICAvLyBJbml0aWFsaXplIHNhY2NhZGUgdGltZXJzXHJcbiAgICBpZiAoaGFzU2FjY2FkZSkge1xyXG4gICAgICBjb25zdCBtYWNyb1NhY2NhZGVXYWl0UmFuZ2UgPSB0aGlzLl90YXJnZXRcclxuICAgICAgICA/IE1hY3JvU2FjY2FkZVdhaXRSYW5nZXMuZXllVGFyZ2V0XHJcbiAgICAgICAgOiBNYWNyb1NhY2NhZGVXYWl0UmFuZ2VzLmRlZmF1bHQ7XHJcbiAgICAgIHRoaXMuX2luaXRpYWxpemVNaWNyb1RpbWVyKGxheWVyTmFtZSwgLi4uTWljcm9TYWNjYWRlV2FpdFJhbmdlcy5kZWZhdWx0KTtcclxuICAgICAgdGhpcy5faW5pdGlhbGl6ZU1hY3JvVGltZXIobGF5ZXJOYW1lLCAuLi5tYWNyb1NhY2NhZGVXYWl0UmFuZ2UpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnQga2VlcGluZyB0cmFjayBvZiBhbiBhbmltYXRpb24gbGF5ZXIgdGhhdCBvd25zIGEgYmxpbmsgYW5pbWF0aW9uLiBCbGlua1xyXG4gICAqIGFuaW1hdGlvbnMgY2FuIGJlIG9mIGFueSB0eXBlLCBidXQgaWYgaXQgaXMgb2YgdHlwZSByYW5kb21BbmltYXRpb24gdGhlbiBhXHJcbiAgICogaXQgd2lsbCBiZSByYW5kb21pemVkIGVhY2ggdGltZSBhIGJsaW5rIGlzIGNhbGxlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0byBrZWVwIHRyYWNrIG9mLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBsYXllci5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uID0gJ2JsaW5rJ10gLSBOYW1lIG9mIHRoZSBibGluayBhbmltYXRpb25cclxuICAgKiBvbiB0aGUgbGF5ZXIuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmJsZW5kVGltZT1bUG9pbnRPZkludGVyZXN0RmVhdHVyZS5ERUZBVUxUX0xBWUVSX09QVElPTlMuYmxlbmRUaW1lXXtAbGluayBQb2ludE9mSW50ZXJlc3RGZWF0dXJlI0RFRkFVTFRfTEFZRVJfT1BUSU9OUyNibGVuZFRpbWV9XSAtXHJcbiAgICogRGVmYXVsdCBhbW91bnQgb2YgdGltZSB0byB1c2Ugd2hlbiBtYW5pcHVsYXRpbmcgdGhlIGxheWVyJ3Mgd2VpZ2h0LlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvcHRpb25zLmVhc2luZ0ZuIC0gRGVmYXVsdCBlYXNpbmcgZnVuY3Rpb24gdG8gdXNlIHdoZW5cclxuICAgKiBtYW5pcHVsYXRpbmcgdGhlIGxheWVyJ3Mgd2VpZ2h0LlxyXG4gICAqL1xyXG4gIHJlZ2lzdGVyQmxpbmtMYXllcihcclxuICAgIGxheWVyTmFtZSxcclxuICAgIHtcclxuICAgICAgYW5pbWF0aW9uID0gJ2JsaW5rJyxcclxuICAgICAgYmxlbmRUaW1lID0gUG9pbnRPZkludGVyZXN0RmVhdHVyZS5ERUZBVUxUX0xBWUVSX09QVElPTlMuYmxlbmRUaW1lLFxyXG4gICAgICBlYXNpbmdGblxyXG4gICAgfSA9IHt9XHJcbiAgKSB7XHJcbiAgICAvLyBSZWdpc3RlciB0aGUgbGF5ZXIgYW5kIGFuaW1hdGlvblxyXG4gICAgdGhpcy5yZWdpc3RlckxheWVyKGxheWVyTmFtZSwge1xyXG4gICAgICBibGVuZFRpbWUsXHJcbiAgICAgIGVhc2luZ0ZuLFxyXG4gICAgICBhbmltYXRpb25zOiB7IFthbmltYXRpb25dOiB7fSB9LFxyXG4gICAgfSk7XHJcbiAgICB0aGlzLl9ibGlua0xheWVyc1tsYXllck5hbWVdID0gYW5pbWF0aW9uO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlKGRlbHRhVGltZSkge1xyXG4gICAgc3VwZXIudXBkYXRlKGRlbHRhVGltZSk7XHJcblxyXG4gICAgLy8gVXBkYXRlIHRoZSBsb29rIGFuZ2xlc1xyXG4gICAgaWYgKHRoaXMuX3RhcmdldCkge1xyXG4gICAgICB0aGlzLl9zZXRMb29rQW5nbGVzKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9yZXNldExvb2tBbmdsZXMoKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkZWx0YVNlY29uZHMgPSBNYXRoLm1pbihkZWx0YVRpbWUsIE1heERlbHRhKSAvIDEwMDA7XHJcbiAgICBsZXQgdHJpZ2dlckJsaW5rID0gZmFsc2U7XHJcblxyXG4gICAgLy8gU2V0IGxvb2sgYmxlbmQgdmFsdWVzXHJcbiAgICBPYmplY3QuZW50cmllcyh0aGlzLl9sb29rTGF5ZXJzKS5mb3JFYWNoKChbbGF5ZXJOYW1lLCBhbmltTmFtZV0pID0+IHtcclxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXTtcclxuXHJcbiAgICAgIC8vIEluY3JlbWVudCB0aGUgc2FjY2FkZSB0aW1lcnNcclxuICAgICAgaWYgKG9wdGlvbnMuaXNBY3RpdmUgJiYgb3B0aW9ucy5oYXNTYWNjYWRlKSB7XHJcbiAgICAgICAgb3B0aW9ucy5taWNyb1NhY2NhZGVUaW1lci5leGVjdXRlKGRlbHRhVGltZSk7XHJcbiAgICAgICAgb3B0aW9ucy5tYWNyb1NhY2NhZGVUaW1lci5leGVjdXRlKGRlbHRhVGltZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFNldCB0aGUgYmxlbmQgdmFsdWVzXHJcbiAgICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbnNbYW5pbU5hbWVdLmlzQWN0aXZlKSB7XHJcbiAgICAgICAgY29uc3QgY3VycmVudEggPSB0aGlzLl9ob3N0LkFuaW1hdGlvbkZlYXR1cmUuZ2V0QW5pbWF0aW9uQmxlbmRXZWlnaHQoXHJcbiAgICAgICAgICBsYXllck5hbWUsIGFuaW1OYW1lLCAnWCdcclxuICAgICAgICApO1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRWID0gdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlLmdldEFuaW1hdGlvbkJsZW5kV2VpZ2h0KFxyXG4gICAgICAgICAgbGF5ZXJOYW1lLCBhbmltTmFtZSwgJ1knXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgbGV0IHRhcmdldEggPSBvcHRpb25zLnRyYWNraW5nQ29uZmlnLmFuZ2xlcy5oO1xyXG4gICAgICAgIGxldCB0YXJnZXRWID0gb3B0aW9ucy50cmFja2luZ0NvbmZpZy5hbmdsZXMudjtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGxvb2sgYW5nbGUgaGFzIGNoYW5nZWQgZW5vdWdoIHRvIHRyaWdnZXIgYSBibGlua1xyXG4gICAgICAgIGlmICh0aGlzLl9pc1RhcmdldE1vdmluZyAmJiAhdHJpZ2dlckJsaW5rKSB7XHJcbiAgICAgICAgICBjb25zdCBwcmV2VGFyZ2V0SCA9IG9wdGlvbnMudHJhY2tpbmdDb25maWcucHJldkFuZ2xlcy5oO1xyXG4gICAgICAgICAgY29uc3QgcHJldlRhcmdldFYgPSBvcHRpb25zLnRyYWNraW5nQ29uZmlnLnByZXZBbmdsZXMudjtcclxuICAgICAgICAgIGNvbnN0IGNoYW5nZUFtb3VudCA9IE1hdGhVdGlscy50b0RlZ3JlZXMoXHJcbiAgICAgICAgICAgIE1hdGhVdGlscy5nZXRBbmdsZUJldHdlZW4oXHJcbiAgICAgICAgICAgICAgW3ByZXZUYXJnZXRILCBwcmV2VGFyZ2V0Vl0sXHJcbiAgICAgICAgICAgICAgW3RhcmdldEgsIHRhcmdldFZdXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgaWYgKGNoYW5nZUFtb3VudCA+PSBCbGlua1RocmVzaG9sZCkge1xyXG4gICAgICAgICAgICB0cmlnZ2VyQmxpbmsgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb3B0aW9ucy50cmFja2luZ0NvbmZpZy5wcmV2QW5nbGVzLmggPSB0YXJnZXRIO1xyXG4gICAgICAgIG9wdGlvbnMudHJhY2tpbmdDb25maWcucHJldkFuZ2xlcy52ID0gdGFyZ2V0VjtcclxuXHJcbiAgICAgICAgLy8gQWRkIGluIHRoZSBzYWNjYWRlIG1vdmVtZW50XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuaGFzU2FjY2FkZSkge1xyXG4gICAgICAgICAgTWF0aFV0aWxzLmRhbXBWYWx1ZShcclxuICAgICAgICAgICAgMCxcclxuICAgICAgICAgICAgb3B0aW9ucy5tYWNyb1NhY2NhZGUuaCArIG9wdGlvbnMubWFjcm9TYWNjYWRlLmgsXHJcbiAgICAgICAgICAgIG9wdGlvbnMuaFZlbG9jaXR5LFxyXG4gICAgICAgICAgICBvcHRpb25zLmhEdXJhdGlvbixcclxuICAgICAgICAgICAgb3B0aW9ucy5tYXhIU3BlZWRcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICB0YXJnZXRIICs9IG9wdGlvbnMuaFZlbG9jaXR5WzBdO1xyXG4gICAgICAgICAgTWF0aFV0aWxzLmRhbXBWYWx1ZShcclxuICAgICAgICAgICAgMCxcclxuICAgICAgICAgICAgb3B0aW9ucy5tYWNyb1NhY2NhZGUudiArIG9wdGlvbnMubWFjcm9TYWNjYWRlLnYsXHJcbiAgICAgICAgICAgIG9wdGlvbnMudlZlbG9jaXR5LFxyXG4gICAgICAgICAgICBvcHRpb25zLnZEdXJhdGlvbixcclxuICAgICAgICAgICAgb3B0aW9ucy5tYXhWU3BlZWRcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICB0YXJnZXRWICs9IG9wdGlvbnMudlZlbG9jaXR5WzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2xhbXAgdG8gbWF4IHNwZWVkXHJcbiAgICAgICAgY29uc3QgZmFjdG9yID0gTWF0aFV0aWxzLmNsYW1wKGRlbHRhU2Vjb25kcyAqIG9wdGlvbnMubWF4U3BlZWQsIDAsIDEpO1xyXG4gICAgICAgIHRhcmdldEggPSBNYXRoVXRpbHMubGVycChjdXJyZW50SCwgdGFyZ2V0SCwgZmFjdG9yKTtcclxuICAgICAgICB0YXJnZXRWID0gTWF0aFV0aWxzLmxlcnAoY3VycmVudFYsIHRhcmdldFYsIGZhY3Rvcik7XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgYmxlbmQgdmFsdWVzXHJcbiAgICAgICAgdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlLnNldEFuaW1hdGlvbkJsZW5kV2VpZ2h0KFxyXG4gICAgICAgICAgbGF5ZXJOYW1lLFxyXG4gICAgICAgICAgYW5pbU5hbWUsXHJcbiAgICAgICAgICAnWCcsXHJcbiAgICAgICAgICB0YXJnZXRIXHJcbiAgICAgICAgKTtcclxuICAgICAgICB0aGlzLl9ob3N0LkFuaW1hdGlvbkZlYXR1cmUuc2V0QW5pbWF0aW9uQmxlbmRXZWlnaHQoXHJcbiAgICAgICAgICBsYXllck5hbWUsXHJcbiAgICAgICAgICBhbmltTmFtZSxcclxuICAgICAgICAgICdZJyxcclxuICAgICAgICAgIHRhcmdldFZcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoIXRyaWdnZXJCbGluayB8fCAhdGhpcy5faXNUYXJnZXRNb3ZpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEV4ZWN1dGUgYmxpbmtcclxuICAgIE9iamVjdC5lbnRyaWVzKHRoaXMuX2JsaW5rTGF5ZXJzKS5mb3JFYWNoKChbbGF5ZXJOYW1lLCBhbmltTmFtZV0pID0+IHtcclxuICAgICAgY29uc3QgYW5pbWF0aW9uID0gdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdLmFuaW1hdGlvbnNbYW5pbU5hbWVdO1xyXG5cclxuICAgICAgaWYgKGFuaW1hdGlvbi5pc0FjdGl2ZSkge1xyXG4gICAgICAgIHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5wbGF5QW5pbWF0aW9uKGxheWVyTmFtZSwgYW5pbU5hbWUpO1xyXG4gICAgICB9XHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgaW5zdGFsbEFwaSgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKiBAbmFtZXNwYWNlIFBvaW50T2ZJbnRlcmVzdEZlYXR1cmVcclxuICAgICAqL1xyXG4gICAgY29uc3QgYXBpID0gc3VwZXIuaW5zdGFsbEFwaSgpO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGFwaSwge1xyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIFBvaW50T2ZJbnRlcmVzdEZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBzZWUgY29yZS9Qb2ludE9mSW50ZXJlc3RGZWF0dXJlI3RhcmdldFxyXG4gICAgICAgKi9cclxuICAgICAgdGFyZ2V0OiB7XHJcbiAgICAgICAgZ2V0OiAoKSA9PiB0aGlzLnRhcmdldCxcclxuICAgICAgICBzZXQ6IHRhcmdldCA9PiB7IHRoaXMudGFyZ2V0ID0gdGFyZ2V0IH0sXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICBPYmplY3QuYXNzaWduKGFwaSwge1xyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIFBvaW50T2ZJbnRlcmVzdEZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBtZXRob2RcclxuICAgICAgICogQHNlZSBjb3JlL1BvaW50T2ZJbnRlcmVzdEZlYXR1cmUjcmVnaXN0ZXJMb29rTGF5ZXJcclxuICAgICAgICovXHJcbiAgICAgIHJlZ2lzdGVyTG9va0xheWVyOiB0aGlzLnJlZ2lzdGVyTG9va0xheWVyLmJpbmQodGhpcyksXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbWVtYmVyb2YgUG9pbnRPZkludGVyZXN0RmVhdHVyZVxyXG4gICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgKiBAc2VlIGNvcmUvUG9pbnRPZkludGVyZXN0RmVhdHVyZSNyZWdpc3RlckJsaW5rTGF5ZXJcclxuICAgICAgICovXHJcbiAgICAgIHJlZ2lzdGVyQmxpbmtMYXllcjogdGhpcy5yZWdpc3RlckJsaW5rTGF5ZXIuYmluZCh0aGlzKSxcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBtZW1iZXJvZiBQb2ludE9mSW50ZXJlc3RGZWF0dXJlXHJcbiAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAqIEBzZWUgY29yZS9Qb2ludE9mSW50ZXJlc3RGZWF0dXJlI3NldFRhcmdldFxyXG4gICAgICAgKi9cclxuICAgICAgc2V0VGFyZ2V0OiB0aGlzLnNldFRhcmdldC5iaW5kKHRoaXMpLFxyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIFBvaW50T2ZJbnRlcmVzdEZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBtZXRob2RcclxuICAgICAgICogQHNlZSBjb3JlL1BvaW50T2ZJbnRlcmVzdEZlYXR1cmUjc2V0VGFyZ2V0QnlOYW1lXHJcbiAgICAgICAqL1xyXG4gICAgICBzZXRUYXJnZXRCeU5hbWU6IHRoaXMuc2V0VGFyZ2V0QnlOYW1lLmJpbmQodGhpcyksXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbWVtYmVyb2YgUG9pbnRPZkludGVyZXN0RmVhdHVyZVxyXG4gICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgKiBAc2VlIGNvcmUvUG9pbnRPZkludGVyZXN0RmVhdHVyZSNzZXRUYXJnZXRCeUlkXHJcbiAgICAgICAqL1xyXG4gICAgICBzZXRUYXJnZXRCeUlkOiB0aGlzLnNldFRhcmdldEJ5SWQuYmluZCh0aGlzKSxcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBhcGk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBQb2ludE9mSW50ZXJlc3RGZWF0dXJlO1xyXG5leHBvcnQgeyBBeGlzTWFwIH07IiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxyXG5cclxuLyoqXHJcbiAqIEBtb2R1bGUgY29yZS9hbmltcGFja1xyXG4gKi9cclxuXHJcbmltcG9ydCB7XHJcbiAgTGluZWFyLFxyXG4gIFF1YWRyYXRpYyxcclxuICBDdWJpYyxcclxuICBRdWFydGljLFxyXG4gIFF1aW50aWMsXHJcbiAgU2ludXNvaWRhbCxcclxuICBFeHBvbmVudGlhbCxcclxuICBDaXJjdWxhcixcclxuICBFbGFzdGljLFxyXG4gIEJhY2ssXHJcbiAgQm91bmNlLFxyXG59IGZyb20gJy4vRWFzaW5nJztcclxuaW1wb3J0IEFuaW1hdGlvbkZlYXR1cmUsIHtBbmltYXRpb25UeXBlc30gZnJvbSAnLi9BbmltYXRpb25GZWF0dXJlJztcclxuaW1wb3J0IEFuaW1hdGlvbkxheWVyLCB7XHJcbiAgTGF5ZXJCbGVuZE1vZGVzLFxyXG4gIERlZmF1bHRMYXllckJsZW5kTW9kZSxcclxufSBmcm9tICcuL0FuaW1hdGlvbkxheWVyJztcclxuaW1wb3J0IFNpbmdsZVN0YXRlIGZyb20gJy4vc3RhdGUvU2luZ2xlU3RhdGUnO1xyXG5pbXBvcnQgVHJhbnNpdGlvblN0YXRlIGZyb20gJy4vc3RhdGUvVHJhbnNpdGlvblN0YXRlJztcclxuaW1wb3J0IEZyZWVCbGVuZFN0YXRlIGZyb20gJy4vc3RhdGUvRnJlZUJsZW5kU3RhdGUnO1xyXG5pbXBvcnQgUXVldWVTdGF0ZSBmcm9tICcuL3N0YXRlL1F1ZXVlU3RhdGUnO1xyXG5pbXBvcnQgUmFuZG9tQW5pbWF0aW9uU3RhdGUgZnJvbSAnLi9zdGF0ZS9SYW5kb21BbmltYXRpb25TdGF0ZSc7XHJcbmltcG9ydCBCbGVuZDFkU3RhdGUgZnJvbSAnLi9zdGF0ZS9CbGVuZDFkU3RhdGUnO1xyXG5pbXBvcnQgQmxlbmQyZFN0YXRlIGZyb20gJy4vc3RhdGUvQmxlbmQyZFN0YXRlJztcclxuaW1wb3J0IEFuaW1hdGlvblV0aWxzIGZyb20gJy4vQW5pbWF0aW9uVXRpbHMnO1xyXG5cclxuLyoqXHJcbiAqIEBuYW1lc3BhY2VcclxuICovXHJcbmNvbnN0IEVhc2luZyA9IHtcclxuICAvKipcclxuICAgKiBAc2VlIExpbmVhclxyXG4gICAqL1xyXG4gIExpbmVhcixcclxuICAvKipcclxuICAgKiBAc2VlIFF1YWRyYXRpY1xyXG4gICAqL1xyXG4gIFF1YWRyYXRpYyxcclxuICAvKipcclxuICAgKiBAc2VlIEN1YmljXHJcbiAgICovXHJcbiAgQ3ViaWMsXHJcbiAgLyoqXHJcbiAgICogQHNlZSBRdWFydGljXHJcbiAgICovXHJcbiAgUXVhcnRpYyxcclxuICAvKipcclxuICAgKiBAc2VlIFF1aW50aWNcclxuICAgKi9cclxuICBRdWludGljLFxyXG4gIC8qKlxyXG4gICAqIEBzZWUgU2ludXNvaWRhbFxyXG4gICAqL1xyXG4gIFNpbnVzb2lkYWwsXHJcbiAgLyoqXHJcbiAgICogQHNlZSBFeHBvbmVudGlhbFxyXG4gICAqL1xyXG4gIEV4cG9uZW50aWFsLFxyXG4gIC8qKlxyXG4gICAqIEBzZWUgQ2lyY3VsYXJcclxuICAgKi9cclxuICBDaXJjdWxhcixcclxuICAvKipcclxuICAgKiBAc2VlIEVsYXN0aWNcclxuICAgKi9cclxuICBFbGFzdGljLFxyXG4gIC8qKlxyXG4gICAqIEBzZWUgQmFja1xyXG4gICAqL1xyXG4gIEJhY2ssXHJcbiAgLyoqXHJcbiAgICogQHNlZSBCb3VuY2VcclxuICAgKi9cclxuICBCb3VuY2UsXHJcbn07XHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZVxyXG4gICAqL1xyXG4gIEFuaW1hdGlvbkZlYXR1cmUsXHJcbiAgLyoqXHJcbiAgICogQHNlZSBBbmltYXRpb25MYXllclxyXG4gICAqL1xyXG4gIEFuaW1hdGlvbkxheWVyLFxyXG4gIC8qKlxyXG4gICAqIEBzZWUgY29yZS9TaW5nbGVTdGF0ZVxyXG4gICAqL1xyXG4gIFNpbmdsZVN0YXRlLFxyXG4gIC8qKlxyXG4gICAqIEBzZWUgVHJhbnNpdGlvblN0YXRlXHJcbiAgICovXHJcbiAgVHJhbnNpdGlvblN0YXRlLFxyXG4gIC8qKlxyXG4gICAqIEBzZWUgRnJlZUJsZW5kU3RhdGVcclxuICAgKi9cclxuICBGcmVlQmxlbmRTdGF0ZSxcclxuICAvKipcclxuICAgKiBAc2VlIFF1ZXVlU3RhdGVcclxuICAgKi9cclxuICBRdWV1ZVN0YXRlLFxyXG4gIC8qKlxyXG4gICAqIEBzZWUgUmFuZG9tQW5pbWF0aW9uU3RhdGVcclxuICAgKi9cclxuICBSYW5kb21BbmltYXRpb25TdGF0ZSxcclxuICAvKipcclxuICAgKiBAc2VlIEJsZW5kMWRTdGF0ZVxyXG4gICAqL1xyXG4gIEJsZW5kMWRTdGF0ZSxcclxuICAvKipcclxuICAgKiBAc2VlIEJsZW5kMmRTdGF0ZVxyXG4gICAqL1xyXG4gIEJsZW5kMmRTdGF0ZSxcclxuICAvKipcclxuICAgKiBAc2VlIEFuaW1hdGlvblV0aWxzXHJcbiAgICovXHJcbiAgQW5pbWF0aW9uVXRpbHMsXHJcblxyXG4gIEVhc2luZyxcclxuICAvKipcclxuICAgKiBAc2VlIExheWVyQmxlbmRNb2Rlc1xyXG4gICAqL1xyXG4gIExheWVyQmxlbmRNb2RlcyxcclxuICAvKipcclxuICAgKiBAc2VlIERlZmF1bHRMYXllckJsZW5kTW9kZVxyXG4gICAqL1xyXG4gIERlZmF1bHRMYXllckJsZW5kTW9kZSxcclxuICAvKipcclxuICAgKiBAc2VlIEFuaW1hdGlvblR5cGVzXHJcbiAgICovXHJcbiAgQW5pbWF0aW9uVHlwZXMsXHJcbn07XHJcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcclxuXHJcbmltcG9ydCBVdGlscyBmcm9tICdjb3JlL1V0aWxzJztcclxuXHJcbi8qKlxyXG4gKiBBIGNvbGxlY3Rpb24gb2YgdXNlZnVsIHRleHQtdG8tc3BlZWNoIGZ1bmN0aW9ucy5cclxuICpcclxuICogQGhpZGVjb25zdHJ1Y3RvclxyXG4gKi9cclxuY2xhc3MgVGV4dFRvU3BlZWNoVXRpbHMge1xyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYSBuZXcgc3RyaW5nIHdpdGggU1NNTCBtYXJrcyBpbnNlcnRlZCBiYXNlZCBvblxyXG4gICAqIG1hdGNoZXMgYmV0d2VlbiB0aGUgaW5wdXQgc3RyaW5nIGFuZCB0aGUgaW5wdXQgbWFwLiBUaGVcclxuICAgKiB3b3JkIG1hdGNoZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUuIFdvcmRzIHdpdGhpbiBleGlzdGluZ1xyXG4gICAqIFNTTUwgdGFncyB3aWxsIG5vdCBiZSBhZmZlY3RlZC4gSW5wdXQgdGV4dCB3aWxsIGJlIHN1cnJvdW5kZWRcclxuICAgKiBieSA8c3BlYWs+PC9zcGVhaz4gdGFncyBpZiBuZWVkZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIElucHV0IHN0cmluZy5cclxuICAgKiBAcGFyYW0ge29iamVjdH0gbWFwIC0gSW5wdXQgb2JqZWN0IHRoYXQgbWFwcyBtYXJrIGtleXNcclxuICAgKiB0byBhcnJheXMgb2Ygd29yZHMuIEV4YW1wbGU6XHJcbiAgICpcclxuICAgKiAge1xyXG4gICAqICAgICdtYXJrOnNhZCcgOiBbJ3NhZCcsICdibHVlJywgJ2Rvd24nXSxcclxuICAgKiAgICAnbWFyazpoYXBweScgOiBbJ2pveScsICdnbGFkJywgJ2dyZWF0J10sXHJcbiAgICogICAgJ21hcms6bm8nIDogWydubycsICduYWgnLCAnbmF5JywgJ3N1cmUnXVxyXG4gICAqICB9XHJcbiAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gW3JhbmRvbU1hcmtzID0gW11dIC0gSWYgdGhlcmUgYXJlIHNlbnRlbmNlcyB0aGF0IGRvbid0XHJcbiAgICogbWF0Y2ggYW55IHdvcmRzIGZyb20gdGhlIG1hcCBvYmplY3QsIG1hcmtzIGZyb20gdGhpcyBhcnJheSB3aWxsIGJlIHJhbmRvbWx5XHJcbiAgICogY2hvc2VuIGFuZCBpbnNlcnRlZC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVXBkYXRlZCBpbnB1dCBzdHJpbmcuXHJcbiAgICovXHJcbiAgc3RhdGljIGF1dG9HZW5lcmF0ZVNTTUxNYXJrcyh0ZXh0LCBtYXAsIHJhbmRvbU1hcmtzID0gW10pIHtcclxuICAgIGlmICh0eXBlb2YgbWFwICE9PSAnb2JqZWN0JyB8fCBtYXAgPT09IG51bGwpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBDYW5ub3QgZ2VuZXJhdGUgU1NNTCBtYXJrcyBmb3IgdGV4dCBcIiR7dGV4dH1cIiBiZWNhdXNlIG1hcCBpcyBub3QgYW4gb2JqZWN0LmBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBwcm9jZXNzIHRoZSBpbnB1dCBtYXAgaW50byBhbiBpbnRlcm5hbCBmb3JtYXRcclxuICAgIGNvbnN0IGludGVybmFsTWFwID0gdGhpcy5fcHJvY2Vzc0lucHV0TWFwKG1hcCk7XHJcblxyXG4gICAgY29uc3Qgc3BlYWtUYWdzID0gWyc8c3BlYWs+JywgJzwvc3BlYWs+J107XHJcbiAgICBjb25zdCBzc21sTWFya1JlZ2V4ID0gLzxtYXJrIG5hbWU9KD86XCJ8JykoLio/KSg/OlwifCcpXFwvPi87XHJcbiAgICBjb25zdCBzc21sVGFnUmVnZXggPSAvPFtePl0qPi9nO1xyXG5cclxuICAgIC8vIElkZW50aWZ5IGFueSBleGlzdGluZyBTU01MIHRhZ3NcclxuICAgIGNvbnN0IGV4aXN0aW5nVGFncyA9IFtdO1xyXG4gICAgbGV0IHJlc3VsdCA9IHNzbWxUYWdSZWdleC5leGVjKHRleHQpO1xyXG5cclxuICAgIHdoaWxlIChyZXN1bHQgIT09IG51bGwpIHtcclxuICAgICAgZXhpc3RpbmdUYWdzLnB1c2goe1xyXG4gICAgICAgIHN0YXJ0OiByZXN1bHQuaW5kZXgsXHJcbiAgICAgICAgZW5kOiByZXN1bHQuaW5kZXggKyByZXN1bHRbMF0ubGVuZ3RoLFxyXG4gICAgICAgIHRleHQ6IHJlc3VsdFswXSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXN1bHQgPSBzc21sVGFnUmVnZXguZXhlYyh0ZXh0KTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjaHVua3MgPSBbXTtcclxuICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICBsZXQgc3NtbE1hcmtSZXN1bHQ7XHJcbiAgICBsZXQgZHVwbGljYXRlTWFya1RvQ2hlY2sgPSBbXTtcclxuICAgIGV4aXN0aW5nVGFncy5mb3JFYWNoKGV4aXN0aW5nVGFnID0+IHtcclxuICAgICAgY29uc3Qgc3Vic3RyID0gdGV4dC5zbGljZShpbmRleCwgZXhpc3RpbmdUYWcuc3RhcnQpO1xyXG5cclxuICAgICAgaWYgKHN1YnN0ciAhPT0gJycpIHtcclxuICAgICAgICAvLyBhdXRvLW1hcmsgbm9uLXRhZyB0ZXh0XHJcbiAgICAgICAgY2h1bmtzLnB1c2goXHJcbiAgICAgICAgICB0aGlzLl9pbnNlcnRNYXJrcyhzdWJzdHIsIGludGVybmFsTWFwLCBkdXBsaWNhdGVNYXJrVG9DaGVjaylcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBkdXBsaWNhdGVNYXJrVG9DaGVjayA9IFtdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzc21sTWFya1Jlc3VsdCA9IHNzbWxNYXJrUmVnZXguZXhlYyhleGlzdGluZ1RhZy50ZXh0KTtcclxuXHJcbiAgICAgIGlmIChzc21sTWFya1Jlc3VsdCAhPT0gbnVsbCkge1xyXG4gICAgICAgIGNvbnN0IG1hcmtUZXh0ID0gc3NtbE1hcmtSZXN1bHRbMV07XHJcbiAgICAgICAgZHVwbGljYXRlTWFya1RvQ2hlY2sucHVzaChtYXJrVGV4dCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoIXNwZWFrVGFncy5pbmNsdWRlcyhleGlzdGluZ1RhZy50ZXh0KSkge1xyXG4gICAgICAgIGNodW5rcy5wdXNoKGV4aXN0aW5nVGFnLnRleHQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBhZHZhbmNlIHRoZSBpbmRleFxyXG4gICAgICBpbmRleCA9IGV4aXN0aW5nVGFnLmVuZDtcclxuICAgIH0pO1xyXG5cclxuICAgIGNodW5rcy5wdXNoKFxyXG4gICAgICB0aGlzLl9pbnNlcnRNYXJrcyh0ZXh0LnNsaWNlKGluZGV4KSwgaW50ZXJuYWxNYXAsIGR1cGxpY2F0ZU1hcmtUb0NoZWNrKVxyXG4gICAgKTtcclxuXHJcbiAgICBsZXQgbWFya2VkVGV4dCA9IGNodW5rcy5qb2luKCcnKTtcclxuXHJcbiAgICBpZiAocmFuZG9tTWFya3MgJiYgcmFuZG9tTWFya3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAvLyBhZGQgcmFuZG9tIG1hcmtzIHRvIGFueSB1bm1hcmtlZCBzZW50ZW5jZXNcclxuICAgICAgbWFya2VkVGV4dCA9IHRoaXMuYWRkTWFya3NUb1VubWFya2VkU2VudGVuY2VzKFxyXG4gICAgICAgIG1hcmtlZFRleHQsXHJcbiAgICAgICAgcmFuZG9tTWFya3NcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gVGV4dFRvU3BlZWNoVXRpbHMudmFsaWRhdGVUZXh0KG1hcmtlZFRleHQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIG5ldyBzdHJpbmcgd2l0aCBhIHJhbmRvbSBTU01MIG1hcmsgaW5zZXJ0ZWQgYXQgZWFjaCBzZW50ZW5jZSB0aGF0XHJcbiAgICogZG9lcyBub3QgYWxyZWFkeSBjb250YWluIGFuIFNTTUwgbWFyay5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gSW5wdXQgc3RyaW5nLlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IG1hcmtzIC0gQW55IGFycmF5IG9mIHJhbmRvbSBTU01MIG1hcmtzIHRvIGNob29zZSBmcm9tXHJcbiAgICogd2hlbiBtb2RpZnlpbmcgdGhlIHRleHQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBhZGRNYXJrc1RvVW5tYXJrZWRTZW50ZW5jZXModGV4dCwgbWFya3MpIHtcclxuICAgIGlmICghbWFya3MgfHwgbWFya3MubGVuZ3RoID09PSAwKSByZXR1cm4gdGV4dDtcclxuXHJcbiAgICBjb25zdCBzc21sTWFya1JlZ2V4ID0gLzxtYXJrIG5hbWU9KD86XCJ8JykoLio/KSg/OlwifCcpXFwvPi9nO1xyXG4gICAgY29uc3Qgc3NtbFRhZ1JlZ2V4ID0gLzxbXj5dKj4vZztcclxuXHJcbiAgICAvLyBGaW5kIHRoZSBpbmRpY2VzIG9mIGFueSBtYXJrcyBpbiB0aGUgdGV4dFxyXG4gICAgY29uc3QgbWFya0luZGljZXMgPSBbXTtcclxuICAgIGxldCBtYXJrUmVzdWx0ID0gc3NtbE1hcmtSZWdleC5leGVjKHRleHQpO1xyXG5cclxuICAgIHdoaWxlIChtYXJrUmVzdWx0ICE9PSBudWxsKSB7XHJcbiAgICAgIG1hcmtJbmRpY2VzLnB1c2gobWFya1Jlc3VsdC5pbmRleCk7XHJcbiAgICAgIG1hcmtSZXN1bHQgPSBzc21sTWFya1JlZ2V4LmV4ZWModGV4dCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmluZCBhbGwgU1NNTCB0YWdzIGluIHRoZSB0ZXh0XHJcbiAgICBjb25zdCBleGlzdGluZ1RhZ3MgPSBbXTtcclxuICAgIGxldCBzc21sUmVzdWx0ID0gc3NtbFRhZ1JlZ2V4LmV4ZWModGV4dCk7XHJcbiAgICB3aGlsZSAoc3NtbFJlc3VsdCAhPT0gbnVsbCkge1xyXG4gICAgICBleGlzdGluZ1RhZ3MucHVzaCh7XHJcbiAgICAgICAgc3RhcnQ6IHNzbWxSZXN1bHQuaW5kZXgsXHJcbiAgICAgICAgZW5kOiBzc21sUmVzdWx0LmluZGV4ICsgc3NtbFJlc3VsdFswXS5sZW5ndGgsXHJcbiAgICAgICAgdGV4dDogc3NtbFJlc3VsdFswXSxcclxuICAgICAgfSk7XHJcbiAgICAgIHNzbWxSZXN1bHQgPSBzc21sVGFnUmVnZXguZXhlYyh0ZXh0KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDcmVhdGUgYSBjb3B5IG9mIHRoZSB0ZXh0IHdpdGggYWxsIFNTTUwgbWFya3MgcmVwbGFjZXMgd2l0aCB3aGl0ZXNwYWNlXHJcbiAgICBsZXQgY2xlYW5lZFRleHQgPSB0ZXh0LnNsaWNlKCk7XHJcbiAgICBleGlzdGluZ1RhZ3MuZm9yRWFjaChleGlzdGluZ1NzbWwgPT4ge1xyXG4gICAgICBjb25zdCB3aGl0ZXNwYWNlID0gbmV3IEFycmF5KGV4aXN0aW5nU3NtbC50ZXh0Lmxlbmd0aCArIDEpLmpvaW4oJyAnKTtcclxuICAgICAgY2xlYW5lZFRleHQgPSBbXHJcbiAgICAgICAgY2xlYW5lZFRleHQuc2xpY2UoMCwgZXhpc3RpbmdTc21sLnN0YXJ0KSxcclxuICAgICAgICB3aGl0ZXNwYWNlLFxyXG4gICAgICAgIGNsZWFuZWRUZXh0LnNsaWNlKGV4aXN0aW5nU3NtbC5lbmQpLFxyXG4gICAgICBdLmpvaW4oJycpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3Qgc2VudGVuY2VFbmRJbmRpY2VzID0gdGhpcy5fZ2V0U2VudGVuY2VFbmRzKGNsZWFuZWRUZXh0KTtcclxuXHJcbiAgICAvLyBPbmx5IGluc2VydCByYW5kb20gbWFya3MgaW50byBzZW50ZW5jZXMgdGhhdCBkb24ndCBhbHJlYWR5IGhhdmUgYW55XHJcbiAgICBsZXQgcHJldkluZGV4ID0gMDtcclxuICAgIGNvbnN0IHRhcmdldEluZGljZXMgPSBzZW50ZW5jZUVuZEluZGljZXMuZmlsdGVyKGluZGV4ID0+IHtcclxuICAgICAgY29uc3QgY29udGFpbnNNYXJrID1cclxuICAgICAgICBtYXJrSW5kaWNlcy5maW5kSW5kZXgobWFya0luZGV4ID0+IHtcclxuICAgICAgICAgIHJldHVybiBwcmV2SW5kZXggPD0gbWFya0luZGV4ICYmIGluZGV4ID4gbWFya0luZGV4O1xyXG4gICAgICAgIH0pICE9PSAtMTtcclxuICAgICAgcHJldkluZGV4ID0gaW5kZXg7XHJcbiAgICAgIHJldHVybiAhY29udGFpbnNNYXJrO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgcmFuZG9tTWFya2VkVGV4dCA9IHRoaXMuX2luc2VydFJhbmRvbU1hcmtzQXQoXHJcbiAgICAgIHRleHQsXHJcbiAgICAgIHRhcmdldEluZGljZXMsXHJcbiAgICAgIG1hcmtzXHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiByYW5kb21NYXJrZWRUZXh0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2VuZXJhdGUgYSB2ZXJzaW9uIG9mIGdpdmVuIHRleHQgdGhhdCBpcyBlbmNsb3NlZCBieSBQb2xseSBzc21sIHNwZWFrIHRhZ3MuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIFRoZSB0ZXh0IHRvIHZhbGlkYXRlLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge3N0cmluZ30gLSBVcGRhdGVkIGlucHV0IHN0cmluZy5cclxuICAgKi9cclxuICBzdGF0aWMgdmFsaWRhdGVUZXh0KHRleHQpIHtcclxuICAgIGlmICghdGV4dCkge1xyXG4gICAgICB0ZXh0ID0gJzxzcGVhaz48L3NwZWFrPic7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0ZXh0ID0gdGV4dFxyXG4gICAgICAgIC5yZXBsYWNlKC8oXlxccyo8XFxzKnNwZWFrXFxzKik+XFxzKnwoXlxccyopLywgJzxzcGVhaz4nKVxyXG4gICAgICAgIC5yZXBsYWNlKC8oXFxzKjxcXHMqXFwvXFxzKnNwZWFrXFxzKj5cXHMqJHxcXHMqJCkvLCAnPC9zcGVhaz4nKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGV4dDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhcnNlIGFuIGlucHV0IHN0cmluZyBhbmQgaW5zZXJ0IFNTTUwgbWFya3MgYmFzZWQgb25cclxuICAgKiB3b3JkIG1hdGNoZXMgaW4gYSBtYXAuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBJbnB1dCBzdHJpbmcuXHJcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW2luZGljZXMgPSBbXV0gLSBBbiBhcnJheSBvZiBpbmRpY2VzIGluIHRoZSB0ZXh0IGlucHV0XHJcbiAgICogd2hlcmUgcmFuZG9tIG1hcmtzIHNob3VsZCBiZSBpbnNlcnRlZC5cclxuICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBbbWFya3MgPSBbXV0gLSBBbiBhcnJheSBvZiBtYXJrIHN0cmluZ3MgdG8gY2hvb3NlXHJcbiAgICogZnJvbSB3aGVuIGluc2VydGluZyByYW5kb20gbWFya3MuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIFVwZGF0ZWQgaW5wdXQgc3RyaW5nLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBfaW5zZXJ0UmFuZG9tTWFya3NBdCh0ZXh0LCBpbmRpY2VzID0gW10sIG1hcmtzID0gW10pIHtcclxuICAgIGlmICghbWFya3MgfHwgbWFya3MubGVuZ3RoID09PSAwIHx8ICFpbmRpY2VzIHx8IGluZGljZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHJldHVybiB0ZXh0O1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBvZmZzZXQgPSAwO1xyXG4gICAgaW5kaWNlcy5mb3JFYWNoKGluZGV4ID0+IHtcclxuICAgICAgY29uc3QgcmFuZG9tTWFyayA9IGA8bWFyayBuYW1lPScke1xyXG4gICAgICAgIG1hcmtzW1V0aWxzLmdldFJhbmRvbUludCgwLCBtYXJrcy5sZW5ndGgpXVxyXG4gICAgICB9Jy8+YDtcclxuICAgICAgdGV4dCA9IFtcclxuICAgICAgICB0ZXh0LnNsaWNlKDAsIGluZGV4ICsgb2Zmc2V0KSxcclxuICAgICAgICByYW5kb21NYXJrLFxyXG4gICAgICAgIHRleHQuc2xpY2UoaW5kZXggKyBvZmZzZXQpLFxyXG4gICAgICBdLmpvaW4oJycpO1xyXG4gICAgICBvZmZzZXQgKz0gcmFuZG9tTWFyay5sZW5ndGg7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gdGV4dDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhcnNlcyBhIHN0cmluZyBvZiB0ZXh0IGFuZCByZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGluZGljZXNcclxuICAgKiBvZiB0aGUgbGFzdCBjaGFyYWN0ZXIgaW4gYSBzZW50ZW5jZSB0aGF0IGlzIG5vdCBpbiB0aGUgZm9sbG93aW5nIGxpc3Q6XHJcbiAgICogICgnLicsICc/JywgJyEnKVxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gVGV4dCB0byBwcm9jZXNzIGZvciBlbmQgb2Ygc2VudGVuY2VcclxuICAgKiBpbmRpY2VzLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0FycmF5LjxudW1iZXI+fSAtIEFycmF5IG9mIGVuZCBvZiBzZW50ZW5jZSBpbmRpY2VzLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBfZ2V0U2VudGVuY2VFbmRzKHRleHQpIHtcclxuICAgIGNvbnN0IHNlbnRlbmNlUmVnZXggPSAvW14uIT9dK1suIT9dKy9nO1xyXG4gICAgY29uc3QgZW5kU2VudGVuY2VSZWdleCA9IC9bLiE/XSsvO1xyXG5cclxuICAgIGxldCByZXN1bHQgPSBzZW50ZW5jZVJlZ2V4LmV4ZWModGV4dCk7XHJcbiAgICBjb25zdCBzZW50ZW5jZUVuZHMgPSBbXTtcclxuICAgIHdoaWxlIChyZXN1bHQgIT09IG51bGwpIHtcclxuICAgICAgLy8gZmluZCB0aGUgbGFzdCBub24tcHVuY3R1YXRpb24gY2hhcmFjdGVyXHJcbiAgICAgIGNvbnN0IHB1bmN0UmVzdWx0ID0gZW5kU2VudGVuY2VSZWdleC5leGVjKHJlc3VsdFswXSk7XHJcbiAgICAgIHNlbnRlbmNlRW5kcy5wdXNoKFxyXG4gICAgICAgIHJlc3VsdC5pbmRleCArIHJlc3VsdFswXS5sZW5ndGggLSBwdW5jdFJlc3VsdFswXS5sZW5ndGhcclxuICAgICAgKTtcclxuICAgICAgcmVzdWx0ID0gc2VudGVuY2VSZWdleC5leGVjKHRleHQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzZW50ZW5jZUVuZHM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYXJzZSBhbiBpbnB1dCBzdHJpbmcgYW5kIGluc2VydCBTU01MIG1hcmtzIGJhc2VkIG9uXHJcbiAgICogd29yZCBtYXRjaGVzIGluIGEgbWFwLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gSW5wdXQgc3RyaW5nLlxyXG4gICAqIEBwYXJhbSB7TWFwfSBtYXAgLSBNYXBwaW5nIG9mIHdvcmRzIHRvIG1hcmsgdmFsdWVzIHRoYXRcclxuICAgKiB3aWxsIGJlIGluc2VydGVkIGFzIHRoZSB2YWx1ZSBmb3IgYSBtYXJrJ3MgJ25hbWUnIGF0dHJpYnV0ZS5cclxuICAgKiBAcGFyYW0ge0FycmF5fSBkdXBsaWNhdGVzVG9DaGVjayAtIEEgbGlzdCBvZiBtYXJrIHZhbHVlcyB0byBjaGVjayBmb3IgZHVwbGljYXRlIGFnYWluc3QgdGhlIGZpcnN0IHdvcmRcclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVXBkYXRlZCBpbnB1dCBzdHJpbmcuXHJcbiAgICovXHJcbiAgc3RhdGljIF9pbnNlcnRNYXJrcyh0ZXh0LCBtYXAsIGR1cGxpY2F0ZXNUb0NoZWNrKSB7XHJcbiAgICBpZiAodGV4dCA9PT0gJycpIHJldHVybiB0ZXh0O1xyXG5cclxuICAgIGNvbnN0IHdvcmRSZWdleCA9IC9cXHcrfFxccyt8W15cXHNcXHddKy9nO1xyXG5cclxuICAgIGxldCBsb3dlckNhc2VXb3JkO1xyXG4gICAgbGV0IGNoZWNrRHVwbGljYXRlID0gdHJ1ZTtcclxuICAgIGNvbnN0IG1hcmtlZFdvcmRzID0gdGV4dC5tYXRjaCh3b3JkUmVnZXgpLm1hcCh3b3JkID0+IHtcclxuICAgICAgbG93ZXJDYXNlV29yZCA9IHdvcmQudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICAgIGlmIChtYXAuaGFzKGxvd2VyQ2FzZVdvcmQpKSB7XHJcbiAgICAgICAgY29uc3QgbWFya3MgPSBtYXAuZ2V0KGxvd2VyQ2FzZVdvcmQpLm1hcChtYXJrID0+IHtcclxuICAgICAgICAgIGlmIChjaGVja0R1cGxpY2F0ZSkge1xyXG4gICAgICAgICAgICBjaGVja0R1cGxpY2F0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm4gZHVwbGljYXRlc1RvQ2hlY2suaW5jbHVkZXMobWFyaylcclxuICAgICAgICAgICAgICA/ICcnXHJcbiAgICAgICAgICAgICAgOiBgPG1hcmsgbmFtZT0nJHttYXJrfScvPmA7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gYDxtYXJrIG5hbWU9JyR7bWFya30nLz5gO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBgJHttYXJrcy5qb2luKCcnKX0ke3dvcmR9YDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjaGVja0R1cGxpY2F0ZSA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiB3b3JkO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBleGlzdGluZ01hcmtzID0gZHVwbGljYXRlc1RvQ2hlY2subWFwKG1hcmsgPT4ge1xyXG4gICAgICByZXR1cm4gYDxtYXJrIG5hbWU9JyR7bWFya30nLz5gO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGAke2V4aXN0aW5nTWFya3Muam9pbignJyl9JHttYXJrZWRXb3Jkcy5qb2luKCcnKX1gO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUHJvY2Vzc2VzIGFuIGlucHV0IG9iamVjdCBmb3IgbWFwcGluZyBhbiBhcnJheVxyXG4gICAqIG9mIHdvcmRzIHRvIHNwZWNpZmljIG1hcmsga2V5cy4gQ29udmVydHMgdGhlIGlucHV0XHJcbiAgICogbWFwIGludG8gYSBNYXAgd2l0aCBhIG1vcmUgZWZmaWNpZW50IGZvcm1hdCBmb3JcclxuICAgKiBwZXJmb3JtaW5nIG1hcmsgaW5qZWN0aW9uLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBtYXAgLSBJbnB1dCBvYmplY3QgdGhhdCBtYXBzIG1hcmsga2V5c1xyXG4gICAqIHRvIGFycmF5cyBvZiB3b3Jkcy5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtNYXB9IC0gTWFwIGZvciBpbnRlcm5hbCB1c2UuXHJcbiAgICovXHJcbiAgc3RhdGljIF9wcm9jZXNzSW5wdXRNYXAobWFwKSB7XHJcbiAgICBjb25zdCBpbnRlcm5hbE1hcCA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICBsZXQgbGlzdCA9IFtdO1xyXG4gICAgT2JqZWN0LmVudHJpZXMobWFwKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcclxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgIGBDYW5ub3QgZ2VuZXJhdGUgU1NNTCBtYXJrcyBmcm9tIG1hcCBcIiR7bWFwfVwiIGJlY2F1c2UgdmFsdWUgZm9yIGtleSAnJHtrZXl9JyBpcyBub3QgYW4gYXJyYXkuYFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhbHVlLmZvckVhY2god29yZCA9PiB7XHJcbiAgICAgICAgY29uc3QgbG93ZXJDYXNlV29yZCA9IHdvcmQudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBsaXN0ID0gaW50ZXJuYWxNYXAuZ2V0KGxvd2VyQ2FzZVdvcmQpO1xyXG5cclxuICAgICAgICBpZiAobGlzdCAhPT0gdW5kZWZpbmVkICYmICFsaXN0LmluY2x1ZGVzKGtleSkpIHtcclxuICAgICAgICAgIGludGVybmFsTWFwLnNldChsb3dlckNhc2VXb3JkLCBbLi4ubGlzdCwga2V5XSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGludGVybmFsTWFwLnNldChsb3dlckNhc2VXb3JkLCBba2V5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBpbnRlcm5hbE1hcDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRleHRUb1NwZWVjaFV0aWxzO1xyXG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXHJcbmltcG9ydCBEZWZlcnJlZCBmcm9tICdjb3JlL0RlZmVycmVkJztcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyB0aGF0IGNhbiBwbGF5IGJhY2sgYXVkaW8gZ2VuZXJhdGVkIGJ5IEFXUyBQb2xseSBhbmQgc3luY2hyb25pemVkIGVtaXRcclxuICogc3BlZWNobWFyayBtZXNzYWdlcy5cclxuICpcclxuICogQGFic3RyYWN0XHJcbiAqL1xyXG5jbGFzcyBBYnN0cmFjdFNwZWVjaCB7XHJcbiAgLyoqXHJcbiAgICogQGNvbnN0cnVjdG9yXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2NvcmUvVGV4dFRvU3BlZWNoRmVhdHVyZX0gc3BlYWtlciAtIFRoZSBmZWF0dXJlIHRoYXQgb3ducyB0aGUgU3BlZWNoIGFuZFxyXG4gICAqIHdpbGwgZW1pdCBzcGVlY2htYXJrIG1lc3NhZ2VzLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgb2YgdGhlIHNwZWVjaC5cclxuICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBbc3BlZWNobWFya3M9W11dIC0gQW4gYXJyYXkgb2Ygc3BlZWNobWFyayBvYmplY3RzIHJlcHJlc2VudGluZ1xyXG4gICAqIHRoZSB0ZXh0IGFuZCB0aW1pbmcgb2YgdGhlIHNwZWVjaC5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihzcGVha2VyLCB0ZXh0LCBzcGVlY2htYXJrcyA9IFtdKSB7XHJcbiAgICB0aGlzLl9zcGVha2VyID0gc3BlYWtlcjtcclxuICAgIHRoaXMuX3RleHQgPSB0ZXh0O1xyXG4gICAgdGhpcy5fc3BlZWNobWFya3MgPSBzcGVlY2htYXJrcztcclxuICAgIHRoaXMuX3NwZWVjaG1hcmtPZmZzZXQgPSAwO1xyXG4gICAgdGhpcy5fcmVzZXQoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc2V0IHRyYWNraW5nIHByb3BlcnRpZXMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtjdXJyZW50VGltZT0wXSAtIFRpbWUgdG8gdXNlIGZvciBfc3RhcnRUaW1lLlxyXG4gICAqL1xyXG4gIF9yZXNldChjdXJyZW50VGltZSA9IDApIHtcclxuICAgIHRoaXMuX3N0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xyXG4gICAgdGhpcy5fbG9jYWxUaW1lID0gMDtcclxuICAgIHRoaXMuX3BhdXNlVGltZSA9IDA7XHJcbiAgICB0aGlzLl9wbGF5aW5nID0gZmFsc2U7XHJcbiAgICB0aGlzLl9tYXJrSXRlciA9IHRoaXMuX3NwZWVjaG1hcmtzLnZhbHVlcygpO1xyXG4gICAgY29uc3Qge3ZhbHVlLCBkb25lfSA9IHRoaXMuX21hcmtJdGVyLm5leHQoKTtcclxuICAgIHRoaXMuX2N1cnJlbnRNYXJrID0gdmFsdWU7XHJcbiAgICB0aGlzLl9lbmRUaW1lID0gdGhpcy5fc3BlZWNobWFya3MubGVuZ3RoXHJcbiAgICAgID8gdGhpcy5fc3BlZWNobWFya3NbdGhpcy5fc3BlZWNobWFya3MubGVuZ3RoIC0gMV0udGltZVxyXG4gICAgICA6IDA7XHJcbiAgICB0aGlzLl9kb25lID0gZG9uZTtcclxuICAgIHRoaXMuX3Byb21pc2UgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IHByb21pc2UgdGhhdCB3aWxsIHN0b3AgcGxheWJhY2sgYW5kIGVtaXQgbWVzc2FnZXMgZm9yIHRoaXMgc3BlZWNoLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uRmluaXNoIC0gRnVuY2l0b24gdG8gZXhlY3V0ZSBvbmNlIHRoZSBzcGVlY2ggc3RvcHMuXHJcbiAgICogQHBhcmFtIHtvbkVycm9yPX0gb25FcnJvciAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgaWYgdGhlIHNwZWVjaCBlbmNvdW50ZXJzIGFuXHJcbiAgICogZXJyb3IuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uSW50ZXJydXB0IC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBpZiB0aGUgc3BlZWNoIGlzIGNhbmNlbGVkLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0RlZmVycmVkfVxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfY3JlYXRlUHJvbWlzZShvbkZpbmlzaCwgb25FcnJvciwgb25JbnRlcnJ1cHQpIHtcclxuICAgIGNvbnN0IG9uUmVzb2x2ZSA9IHZhbHVlID0+IHtcclxuICAgICAgdGhpcy5fcGxheWluZyA9IGZhbHNlO1xyXG5cclxuICAgICAgdGhpcy5fc3BlYWtlci5lbWl0KHRoaXMuX3NwZWFrZXIuY29uc3RydWN0b3IuRVZFTlRTLnN0b3AsIHRoaXMpO1xyXG4gICAgICB0aGlzLl9zcGVha2VyLmNvbnN0cnVjdG9yLmVtaXQoXHJcbiAgICAgICAgdGhpcy5fc3BlYWtlci5jb25zdHJ1Y3Rvci5FVkVOVFMuc3RvcCxcclxuICAgICAgICB0aGlzXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBpZiAodHlwZW9mIG9uRmluaXNoID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgb25GaW5pc2godmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IG9uUmVqZWN0ID0gZSA9PiB7XHJcbiAgICAgIHRoaXMuX3BsYXlpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgIHRoaXMuX3NwZWFrZXIuZW1pdCh0aGlzLl9zcGVha2VyLmNvbnN0cnVjdG9yLkVWRU5UUy5zdG9wLCB0aGlzKTtcclxuICAgICAgdGhpcy5fc3BlYWtlci5jb25zdHJ1Y3Rvci5lbWl0KFxyXG4gICAgICAgIHRoaXMuX3NwZWFrZXIuY29uc3RydWN0b3IuRVZFTlRTLnN0b3AsXHJcbiAgICAgICAgdGhpc1xyXG4gICAgICApO1xyXG5cclxuICAgICAgY29uc29sZS5lcnJvcihcclxuICAgICAgICBgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IGVuY291bnRlcmVkIGFuIHVuZXhwZWN0ZWQgZXJyb3I6ICR7ZX1gXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBpZiAodHlwZW9mIG9uRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBvbkVycm9yKGUpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IG9uQ2FuY2VsID0gdmFsdWUgPT4ge1xyXG4gICAgICB0aGlzLl9wbGF5aW5nID0gZmFsc2U7XHJcblxyXG4gICAgICB0aGlzLl9zcGVha2VyLmVtaXQodGhpcy5fc3BlYWtlci5jb25zdHJ1Y3Rvci5FVkVOVFMuaW50ZXJydXB0LCB0aGlzKTtcclxuICAgICAgdGhpcy5fc3BlYWtlci5jb25zdHJ1Y3Rvci5lbWl0KFxyXG4gICAgICAgIHRoaXMuX3NwZWFrZXIuY29uc3RydWN0b3IuRVZFTlRTLmludGVycnVwdCxcclxuICAgICAgICB0aGlzXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBpZiAodHlwZW9mIG9uSW50ZXJydXB0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgb25JbnRlcnJ1cHQodmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuX3Byb21pc2UgPSBuZXcgRGVmZXJyZWQodW5kZWZpbmVkLCBvblJlc29sdmUsIG9uUmVqZWN0LCBvbkNhbmNlbCk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gd2hldGhlciBvciBub3QgdGhlIHNwZWVjaCBoYXMgcmVhY2hlZCBpdCdzIGVuZC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBfY2hlY2tGaW5pc2hlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9kb25lICYmIHRoaXMuX2xvY2FsVGltZSA+PSB0aGlzLl9lbmRUaW1lO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgcGxheWJhY2sgc3RhdGUgb2YgdGhlIGF1ZGlvLlxyXG4gICAqXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgZ2V0IHBsYXlpbmcoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcGxheWluZztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIHRleHQgb2YgdGhlIHNwZWVjaC5cclxuICAgKlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICovXHJcbiAgZ2V0IHRleHQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fdGV4dDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgYSBzaGFsbG93IGNvcHkgb2YgdGhlIHNwZWVjaG1hcmtzIGFycmF5IGZvciB0aGUgc3BlZWNoLlxyXG4gICAqXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxyXG4gICAqL1xyXG4gIGdldCBzcGVlY2htYXJrcygpIHtcclxuICAgIHJldHVybiBbLi4udGhpcy5fc3BlZWNobWFya3NdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyBhbmQgc2V0cyB0aGUgbnVtYmVyIG9mIHNlY29uZHMgdG8gb2Zmc2V0IHNwZWVjaG1hcmsgZW1pc3Npb24uXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgc3BlZWNobWFya09mZnNldCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9zcGVlY2htYXJrT2Zmc2V0IC8gMTAwMDtcclxuICB9XHJcblxyXG4gIHNldCBzcGVlY2htYXJrT2Zmc2V0KG9mZnNldCkge1xyXG4gICAgdGhpcy5fc3BlZWNobWFya09mZnNldCA9IG9mZnNldCAqIDEwMDA7IC8vIFN0b3JlIGFzIG1pbGxpc2Vjb25kc1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRW1pdCBzcGVlY2htYXJrIG1lc3NhZ2VzIGFzIHRoZXkgYXJlIGVuY291bnRlcmVkIGluIHN5bmMgd2l0aCBhdWRpby5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50VGltZSAtIEN1cnJlbnQgZ2xvYmFsIHRpbWUgd2hlbiB1cGRhdGUgd2FzIGNhbGxlZC5cclxuICAgKi9cclxuICB1cGRhdGUoY3VycmVudFRpbWUpIHtcclxuICAgIGlmICghdGhpcy5fcGxheWluZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVXBkYXRlIGxvY2FsIGF1ZGlvIHRpbWVcclxuICAgIHRoaXMuX2xvY2FsVGltZSA9IGN1cnJlbnRUaW1lIC0gdGhpcy5fc3RhcnRUaW1lO1xyXG5cclxuICAgIGlmICghdGhpcy5fZG9uZSkge1xyXG4gICAgICAvLyBFbWl0IHNwZWVjaG1hcmsgbWVzc2FnZXMgZm9yIG1hcmtzIHVwIHRvIHRoZSBjdXJyZW50IHRpbWVcclxuICAgICAgd2hpbGUgKFxyXG4gICAgICAgICF0aGlzLl9kb25lICYmXHJcbiAgICAgICAgdGhpcy5fY3VycmVudE1hcmsudGltZSArIHRoaXMuX3NwZWVjaG1hcmtPZmZzZXQgPD0gdGhpcy5fbG9jYWxUaW1lXHJcbiAgICAgICkge1xyXG4gICAgICAgIHRoaXMuX3NwZWFrZXIuZW1pdChcclxuICAgICAgICAgIHRoaXMuX3NwZWFrZXIuY29uc3RydWN0b3IuRVZFTlRTW3RoaXMuX2N1cnJlbnRNYXJrLnR5cGVdLFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBzcGVlY2g6IHRoaXMsXHJcbiAgICAgICAgICAgIG1hcms6IHRoaXMuX2N1cnJlbnRNYXJrLFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgY29uc3Qge3ZhbHVlLCBkb25lfSA9IHRoaXMuX21hcmtJdGVyLm5leHQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5fY3VycmVudE1hcmsgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLl9kb25lID0gZG9uZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEVuZCBwbGF5YmFja1xyXG4gICAgaWYgKHRoaXMuX2NoZWNrRmluaXNoZWQoKSkge1xyXG4gICAgICB0aGlzLnN0b3AoKTtcclxuICAgICAgdGhpcy5fcmVzZXQoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBsYXkgdGhlIHNwZWVjaCBmcm9tIHRoZSBiZWdpbm5pbmcuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gY3VycmVudFRpbWUgLSBDdXJyZW50IGdsb2JhbCB0aW1lIHdoZW4gcGxheSB3YXMgY2FsbGVkLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkZpbmlzaCAtIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb25jZSB0aGUgc3BlZWNoXHJcbiAgICogcHJvbWlzZSByZXNvbHZlcy5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25FcnJvciAtIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgaWYgdGhlIHNwZWVjaFxyXG4gICAqIGVuY291bnRlcnMgYW5kIGVycm9yIGR1cmluZyBwbGF5YmFjay5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25JbnRlcnJ1cHQgLSBPcHRpb25hbCBmdW5jdGlvbiB0byBleGVjdXRlIGlmIHRoZSBzcGVlY2hcclxuICAgKiBpcyBjYW5jZWxlZC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH0gUmVzb2x2ZXMgb25jZSB0aGUgc3BlZWNoIHJlYWNoZXMgdGhlIGVuZCBvZiBwbGF5YmFjay5cclxuICAgKi9cclxuICBwbGF5KGN1cnJlbnRUaW1lLCBvbkZpbmlzaCwgb25FcnJvciwgb25JbnRlcnJ1cHQpIHtcclxuICAgIHRoaXMuX3Jlc2V0KGN1cnJlbnRUaW1lKTtcclxuICAgIHRoaXMuX3BsYXlpbmcgPSB0cnVlO1xyXG5cclxuICAgIHRoaXMuX3NwZWFrZXIuZW1pdCh0aGlzLl9zcGVha2VyLmNvbnN0cnVjdG9yLkVWRU5UUy5wbGF5LCB0aGlzKTtcclxuICAgIHRoaXMuX3NwZWFrZXIuY29uc3RydWN0b3IuZW1pdCh0aGlzLl9zcGVha2VyLmNvbnN0cnVjdG9yLkVWRU5UUy5wbGF5LCB0aGlzKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlUHJvbWlzZShvbkZpbmlzaCwgb25FcnJvciwgb25JbnRlcnJ1cHQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGF1c2UgdGhlIHNwZWVjaCBhdCB0aGUgY3VycmVudCB0aW1lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnRUaW1lIC0gQ3VycmVudCBnbG9iYWwgdGltZSB3aGVuIHBhdXNlIHdhcyBjYWxsZWQuXHJcbiAgICovXHJcbiAgcGF1c2UoY3VycmVudFRpbWUpIHtcclxuICAgIHRoaXMuX3BsYXlpbmcgPSBmYWxzZTtcclxuICAgIHRoaXMuX3BhdXNlVGltZSA9IGN1cnJlbnRUaW1lO1xyXG5cclxuICAgIHRoaXMuX3NwZWFrZXIuZW1pdCh0aGlzLl9zcGVha2VyLmNvbnN0cnVjdG9yLkVWRU5UUy5wYXVzZSwgdGhpcyk7XHJcbiAgICB0aGlzLl9zcGVha2VyLmNvbnN0cnVjdG9yLmVtaXQoXHJcbiAgICAgIHRoaXMuX3NwZWFrZXIuY29uc3RydWN0b3IuRVZFTlRTLnBhdXNlLFxyXG4gICAgICB0aGlzXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzdW1lIHRoZSBzcGVlY2ggYXQgdGhlIGN1cnJlbnQgdGltZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50VGltZSAtIEN1cnJlbnQgZ2xvYmFsIHRpbWUgd2hlbiByZXN1bWUgd2FzIGNhbGxlZC5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25GaW5pc2ggLSBPcHRpb25hbCBmdW5jdGlvbiB0byBleGVjdXRlIG9uY2UgdGhlIHNwZWVjaFxyXG4gICAqIHByb21pc2UgcmVzb2x2ZXMuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uRXJyb3IgLSBPcHRpb25hbCBmdW5jdGlvbiB0byBleGVjdXRlIGlmIHRoZSBzcGVlY2hcclxuICAgKiBlbmNvdW50ZXJzIGFuZCBlcnJvciBkdXJpbmcgcGxheWJhY2suXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uSW50ZXJydXB0IC0gT3B0aW9uYWwgZnVuY3Rpb24gdG8gZXhlY3V0ZSBpZiB0aGUgc3BlZWNoXHJcbiAgICogaXMgY2FuY2VsZWQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9IFJlc29sdmVzIG9uY2UgdGhlIHNwZWVjaCByZWFjaGVzIHRoZSBlbmQgb2YgcGxheWJhY2suXHJcbiAgICovXHJcbiAgcmVzdW1lKGN1cnJlbnRUaW1lLCBvbkZpbmlzaCwgb25FcnJvciwgb25JbnRlcnJ1cHQpIHtcclxuICAgIC8vIFBsYXkgZnJvbSB0aGUgYmVnaW5uaW5nIGlmIHRoZSBzcGVlY2ggaGFzbid0IHBsYXllZCB5ZXRcclxuICAgIGlmICghdGhpcy5fcHJvbWlzZSkge1xyXG4gICAgICB0aGlzLl9yZXNldChjdXJyZW50VGltZSk7XHJcbiAgICAgIHRoaXMuX2NyZWF0ZVByb21pc2Uob25GaW5pc2gsIG9uRXJyb3IsIG9uSW50ZXJydXB0KTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9wbGF5aW5nID0gdHJ1ZTtcclxuICAgIHRoaXMuX3N0YXJ0VGltZSArPSBjdXJyZW50VGltZSAtIHRoaXMuX3BhdXNlVGltZTtcclxuXHJcbiAgICB0aGlzLl9zcGVha2VyLmVtaXQodGhpcy5fc3BlYWtlci5jb25zdHJ1Y3Rvci5FVkVOVFMucmVzdW1lLCB0aGlzKTtcclxuICAgIHRoaXMuX3NwZWFrZXIuY29uc3RydWN0b3IuZW1pdChcclxuICAgICAgdGhpcy5fc3BlYWtlci5jb25zdHJ1Y3Rvci5FVkVOVFMucmVzdW1lLFxyXG4gICAgICB0aGlzXHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiB0aGlzLl9wcm9taXNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FuY2VscyBwbGF5YmFjayBvZiB0aGUgc3BlZWNoIGF0IHRoZSBjdXJyZW50IHRpbWUuIENhbmNlbCB0aGUgc3BlZWNoIHByb21pc2UuXHJcbiAgICovXHJcbiAgY2FuY2VsKCkge1xyXG4gICAgaWYgKHRoaXMuX3Byb21pc2UpIHtcclxuICAgICAgdGhpcy5fcHJvbWlzZS5jYW5jZWwoKTtcclxuICAgICAgdGhpcy5fcHJvbWlzZSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fcGxheWluZyA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RvcCB0aGUgc3BlZWNoIGFuZCByZXNldCB0aW1lIHRvIHRoZSBiZWdpbm5pbmcuIFJlc29sdmUgdGhlIHNwZWVjaCBwcm9taXNlLlxyXG4gICAqL1xyXG4gIHN0b3AoKSB7XHJcbiAgICBpZiAodGhpcy5fcHJvbWlzZSkge1xyXG4gICAgICB0aGlzLl9wcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgdGhpcy5fcHJvbWlzZSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fcGxheWluZyA9IGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQWJzdHJhY3RTcGVlY2g7IiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxyXG5pbXBvcnQgQWJzdHJhY3RTcGVlY2ggZnJvbSAnLi9BYnN0cmFjdFNwZWVjaCc7XHJcblxyXG4vKipcclxuICogVGhlIGJ1aWx0LWluIGNsYXNzIGZvciBhc3luY2hyb25vdXMgUHJvbWlzZXMuXHJcbiAqIEBleHRlcm5hbCBBdWRpb1xyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MQXVkaW9FbGVtZW50L0F1ZGlvXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBleHRlbmRzIEFic3RyYWN0U3BlZWNoXHJcbiAqIEBhbGlhcyBjb3JlL1NwZWVjaFxyXG4gKi9cclxuY2xhc3MgU3BlZWNoIGV4dGVuZHMgQWJzdHJhY3RTcGVlY2gge1xyXG4gIC8qKlxyXG4gICAqIEBjb25zdHJ1Y3RvclxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtUZXh0VG9TcGVlY2h9IHNwZWFrZXIgLSBUaGUgb3duZXIgb2YgdGhlIFNwZWVjaCB0aGF0IHdpbGwgZW1pdCBzcGVlY2htYXJrXHJcbiAgICogbWVzc2FnZXMuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCBvZiB0aGUgc3BlZWNoLlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IFtzcGVlY2htYXJrcz1bXV0gLSBBbiBhcnJheSBvZiBzcGVlY2htYXJrIG9iamVjdHMgcmVwcmVzZW50aW5nXHJcbiAgICogdGhlIHRleHQgYW5kIHRpbWluZyBvZiB0aGUgc3BlZWNoLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhdWRpb0NvbmZpZyAtIE9iamVjdCBjb250YWluaW5nIGF1ZGlvIGFuZCB1cmwuXHJcbiAgICogQHBhcmFtIHtleHRlcm5hbDpBdWRpb30gYXVkaW9Db25maWcuYXVkaW8gLSBQbGF5YWJsZSBhdWRpbyBvYmplY3QuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3Ioc3BlYWtlciwgdGV4dCwgc3BlZWNobWFya3MgPSBbXSwgYXVkaW9Db25maWcpIHtcclxuICAgIHN1cGVyKHNwZWFrZXIsIHRleHQsIHNwZWVjaG1hcmtzKTtcclxuICAgIHRoaXMuX2F1ZGlvID0gYXVkaW9Db25maWcuYXVkaW87XHJcblxyXG4gICAgLy8gS2VlcCB0cmFjayBvZiB3aGV0aGVyIHRoZSBhdWRpbyBoYXMgZmluaXNoZWQgcGxheWluZyB0aHJvdWdoXHJcbiAgICB0aGlzLl9hdWRpby5vbmVuZGVkID0gKCkgPT4ge1xyXG4gICAgICB0aGlzLl9hdWRpb0ZpbmlzaGVkID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICB0aGlzLl9hdWRpb0ZpbmlzaGVkID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIF9jaGVja0ZpbmlzaGVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2F1ZGlvRmluaXNoZWQgJiYgc3VwZXIuX2NoZWNrRmluaXNoZWQoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIHBsYXlhYmxlIGF1ZGlvIGZvciB0aGUgc3BlZWNoLlxyXG4gICAqXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHR5cGUge2V4dGVybmFsOkF1ZGlvfVxyXG4gICAqL1xyXG4gIGdldCBhdWRpbygpIHtcclxuICAgIHJldHVybiB0aGlzLl9hdWRpbztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIGF1ZGlvIHZvbHVtZSBmb3IgdGhlIHNwZWVjaC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IHZvbHVtZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9hdWRpby52b2x1bWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSBhdWRpbyB2b2x1bWUgZm9yIHRoZSBzcGVlY2guXHJcbiAgICovXHJcbiAgc2V0IHZvbHVtZSh2b2x1bWUpIHtcclxuICAgIHRoaXMuX2F1ZGlvLnZvbHVtZSA9IHZvbHVtZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgYXVkaW8ncyBjdXJyZW50IGxvY2FsIHRpbWUgYW5kIHBsYXkgaXQuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9wbGF5QXVkaW8oKSB7XHJcbiAgICBpZiAodGhpcy5fc3BlZWNobWFya09mZnNldCA8IDApIHtcclxuICAgICAgdGhpcy5fYXVkaW8uY3VycmVudFRpbWUgPSB0aGlzLl9zcGVlY2htYXJrT2Zmc2V0O1xyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBpZiAodGhpcy5fcGxheWluZykge1xyXG4gICAgICAgICAgdGhpcy5fYXVkaW8uY3VycmVudFRpbWUgPVxyXG4gICAgICAgICAgICAodGhpcy5fbG9jYWxUaW1lICsgdGhpcy5fc3BlZWNobWFya09mZnNldCkgLyAxMDAwO1xyXG4gICAgICAgICAgdGhpcy5fYXVkaW8ucGxheSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSwgLXRoaXMuX3NwZWVjaG1hcmtPZmZzZXQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fYXVkaW8uY3VycmVudFRpbWUgPSAwO1xyXG4gICAgICB0aGlzLl9hdWRpby5wbGF5KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYXVzZSB0aGUgYXVkaW8gb25jZSBpdCBpcyBwbGF5YWJsZS5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX3BhdXNlQXVkaW8oKSB7XHJcbiAgICB0aGlzLl9hdWRpby5wbGF5KCkudGhlbigoKSA9PiB7XHJcbiAgICAgIGlmICghdGhpcy5fcGxheWluZykge1xyXG4gICAgICAgIHRoaXMuX2F1ZGlvLnBhdXNlKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcGxheShjdXJyZW50VGltZSwgb25GaW5pc2gsIG9uRXJyb3IsIG9uSW50ZXJydXB0KSB7XHJcbiAgICB0aGlzLl9hdWRpb0ZpbmlzaGVkID0gZmFsc2U7XHJcbiAgICB0aGlzLl9wbGF5QXVkaW8oKTtcclxuXHJcbiAgICByZXR1cm4gc3VwZXIucGxheShjdXJyZW50VGltZSwgb25GaW5pc2gsIG9uRXJyb3IsIG9uSW50ZXJydXB0KTtcclxuICB9XHJcblxyXG4gIHBhdXNlKGN1cnJlbnRUaW1lKSB7XHJcbiAgICB0aGlzLl9wYXVzZUF1ZGlvKCk7XHJcbiAgICBzdXBlci5wYXVzZShjdXJyZW50VGltZSk7XHJcbiAgfVxyXG5cclxuICByZXN1bWUoY3VycmVudFRpbWUsIG9uRmluaXNoLCBvbkVycm9yLCBvbkludGVycnVwdCkge1xyXG4gICAgdGhpcy5fYXVkaW9GaW5pc2hlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5fYXVkaW8ucGxheSgpO1xyXG5cclxuICAgIHJldHVybiBzdXBlci5yZXN1bWUoY3VycmVudFRpbWUsIG9uRmluaXNoLCBvbkVycm9yLCBvbkludGVycnVwdCk7XHJcbiAgfVxyXG5cclxuICBjYW5jZWwoKSB7XHJcbiAgICB0aGlzLl9wYXVzZUF1ZGlvKCk7XHJcbiAgICBzdXBlci5jYW5jZWwoKTtcclxuICB9XHJcblxyXG4gIHN0b3AoKSB7XHJcbiAgICB0aGlzLl9wYXVzZUF1ZGlvKCk7XHJcbiAgICB0aGlzLl9hdWRpby5jdXJyZW50VGltZSA9IDA7XHJcbiAgICBzdXBlci5zdG9wKCk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTcGVlY2g7XHJcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcclxuaW1wb3J0IEFic3RyYWN0SG9zdEZlYXR1cmUgZnJvbSAnY29yZS9BYnN0cmFjdEhvc3RGZWF0dXJlJztcclxuaW1wb3J0IEFuaW1hdGlvblV0aWxzIGZyb20gJ2NvcmUvYW5pbXBhY2svQW5pbWF0aW9uVXRpbHMnO1xyXG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gJ2NvcmUvTWF0aFV0aWxzJztcclxuaW1wb3J0IERlZmVycmVkIGZyb20gJ2NvcmUvRGVmZXJyZWQnO1xyXG5pbXBvcnQgU3BlZWNoIGZyb20gJy4vQWJzdHJhY3RTcGVlY2gnO1xyXG5pbXBvcnQgVGV4dFRvU3BlZWNoVXRpbHMgZnJvbSAnLi9UZXh0VG9TcGVlY2hVdGlscyc7XHJcblxyXG4vKipcclxuICogVGhlIEFtYXpvbiBQb2xseSBzZXJ2aWNlIG9iamVjdC5cclxuICogQGV4dGVybmFsIFBvbGx5XHJcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FXU0phdmFTY3JpcHRTREsvbGF0ZXN0L0FXUy9Qb2xseS5odG1sXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFRoZSBwcmVzaWduZXIgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gZ2VuZXJhdGUgcHJlc2lnbmVkIHVybHMgZm9yIHRoZSBQb2xseSBzZXJ2aWNlLlxyXG4gKiBAZXh0ZXJuYWwgUHJlc2lnbmVyXHJcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FXU0phdmFTY3JpcHRTREsvbGF0ZXN0L0FXUy9Qb2xseS9QcmVzaWduZXIuaHRtbFxyXG4gKi9cclxuXHJcbi8vIEF2YWlsYWJsZSBvcHRpb25zIGZvciBQb2xseVxyXG5jb25zdCBlbmdpbmVzID0gWydzdGFuZGFyZCcsICduZXVyYWwnXTtcclxuY29uc3QgYXVkaW9Gb3JtYXRzID0gWydtcDMnLCAnb2dnX3ZvcmJpcycsICdwY20nXTtcclxuY29uc3Qgc3BlZWNobWFya1R5cGVzID0gWydzZW50ZW5jZScsICdzc21sJywgJ3Zpc2VtZScsICd3b3JkJ107XHJcbmNvbnN0IHNhbXBsZVJhdGVzID0ge1xyXG4gIG1wMzoge1xyXG4gICAgcmF0ZXM6IFsnODAwMCcsICcxNjAwMCcsICcyMjA1MCcsICcyNDAwMCddLFxyXG4gICAgZGVmYXVsdHM6IHtcclxuICAgICAgc3RhbmRhcmQ6ICcyMDUwJyxcclxuICAgICAgbmV1cmFsOiAnMjQwMCcsXHJcbiAgICB9LFxyXG4gIH0sXHJcbiAgcGNtOiB7XHJcbiAgICByYXRlczogWyc4MDAwJywgJzE2MDAwJ10sXHJcbiAgICBkZWZhdWx0czoge1xyXG4gICAgICBzdGFuZGFyZDogJzE2MDAnLFxyXG4gICAgICBuZXVyYWw6ICcxNjAwJyxcclxuICAgIH0sXHJcbiAgfSxcclxufTtcclxuc2FtcGxlUmF0ZXMub2dnX3ZvcmJpcyA9IHNhbXBsZVJhdGVzLm1wMztcclxubGV0IGF3c1ZlcnNpb247XHJcblxyXG4vKipcclxuICogQmFzZSBjbGFzcyBmb3IgdHVybmluZyB0ZXh0IGlucHV0IGludG8gcGxheWFibGUgYXVkaW8uIFRoZXJlIHNob3VsZCBiZSBvbmUgaW5zdGFuY2VcclxuICogcGVyIHNwZWFrZXIsIGVhY2ggaW5zdGFuY2UgY2FuIHBsYXkgb25seSBvbmUgcGllY2Ugb2YgdGV4dCBhdCBhIHRpbWUuXHJcbiAqXHJcbiAqIEBleHRlbmRzIEFic3RyYWN0SG9zdEZlYXR1cmVcclxuICogQGFic3RyYWN0XHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7KG51bWJlcnx1bmRlZmluZWQpfSBBV1NfVkVSU0lPTiAtIEdldHMgdGhlIHZlcnNpb24gb2YgQVdTIFNESyBiZWluZ1xyXG4gKiB1c2VkLiBXaWxsIGJlIHVuZGVmaW5lZCB1bnRpbCBbaW5pdGlhbGl6ZVNlcnZpY2Vde0BsaW5rIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZS5pbml0aWFsaXplU2VydmljZX1cclxuICogaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGV4ZWN1dGVkLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW1BPTExZX01JTl9ORVVSQUxfVkVSU0lPTj0nMi41MDMnXSAtIEdldHMgdGhlIG1pbmltdW0gdmVyc2lvblxyXG4gKiBvZiB0aGUgQVdTIFNESyB0aGF0IGlzIG5lY2Vzc2FyeSB0byB1c2UgbmV1cmFsIHZvaWNlcyB3aXRoIEFXUyBQb2xseS5cclxuICogQHByb3BlcnR5IHtPYmplY3R9IFBPTExZX0RFRkFVTFRTIC0gRGVmYXVsdCB2YWx1ZXMgdG8gdXNlIHdpdGggY2FsbHMgdG8ge0BsaW5rIGV4dGVybmFsOlBvbGx5fS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtQT0xMWV9ERUZBVUxUUy5FbmdpbmU9J3N0YW5kYXJkJ11cclxuICogQHByb3BlcnR5IHtBcnJheS48c3RyaW5nPn0gW1BPTExZX0RFRkFVTFRTLkxleGljb25OYW1lcz1bXV1cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtQT0xMWV9ERUZBVUxUUy5PdXRwdXRGb3JtYXQ9J21wMyddXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbUE9MTFlfREVGQVVMVFMuU2FtcGxlUmF0ZT0nMjIwNTAnXVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW1BPTExZX0RFRkFVTFRTLlRleHQ9JyddXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbUE9MTFlfREVGQVVMVFMuVGV4dFR5cGU9J3NzbWwnXVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW1BPTExZX0RFRkFVTFRTLlZvaWNlSWQ9J0FteSddXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbUE9MTFlfREVGQVVMVFMuTGFuZ3VhZ2VDb2RlPSdlbi1HQiddXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbUE9MTFlfREVGQVVMVFMuTGFuZ3VhZ2VOYW1lPSdCcml0aXNoIEVuZ2xpc2gnXVxyXG4gKiBAcHJvcGVydHkge0FycmF5LjxzdHJpbmc+fSBbUE9MTFlfVk9JQ0VTPVtdXSAtIEFuIGFycmF5IG9mIHZvaWNlcyBhdmFpbGFibGUgaW5cclxuICogUG9sbHkuIFdpbGwgYmUgZW1wdHkgdW50aWwgW2luaXRpYWxpemVTZXJ2aWNlXXtAbGluayBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUuaW5pdGlhbGl6ZVNlcnZpY2V9XHJcbiAqIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBleGVjdXRlZC4gU2VlIFtQb2xseSBEb2N1bWVudGF0aW9uXXtAbGluayBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vcG9sbHkvbGF0ZXN0L2RnL3ZvaWNlbGlzdC5odG1sfVxyXG4gKiBmb3IgYSBmdWxsIGxpc3Qgb2YgYXZhaWxhYmxlIHZvaWNlcy5cclxuICogQHByb3BlcnR5IHtPYmplY3R9IFtQT0xMWV9MQU5HVUFHRVM9e31dIC0gQW4gb2JqZWN0IHRoYXQgbWFwcyBsYW5ndWFnZSBuYW1lc1xyXG4gKiB0byBsYW5ndWFnZSBjb2RlcyB0aGF0IGFyZSBhdmFpbGFibGUgaW4gUG9sbHkuIFdpbGwgYmUgZW1wdHkgdW50aWxcclxuICogW2luaXRpYWxpemVTZXJ2aWNlXXtAbGluayBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUuaW5pdGlhbGl6ZVNlcnZpY2V9XHJcbiAqIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBleGVjdXRlZC4gU2VlIFtQb2xseSBEb2N1bWVudGF0aW9uXXtAbGluayBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vcG9sbHkvbGF0ZXN0L2RnL1N1cHBvcnRlZExhbmd1YWdlLmh0bWx9XHJcbiAqIGZvciBhIGZ1bGwgbGlzdCBvZiBhdmFpbGFibGUgbGFuZ3VhZ2VzIGFuZCBjb3JyZXNwb25kaW5nIGNvZGVzLlxyXG4gKiBAcHJvcGVydHkge09iamVjdH0gW1BPTExZX0xBTkdVQUdFX0NPREVTPXt9XSAtIEFuIG9iamVjdCB0aGF0IG1hcHMgbGFuZ3VhZ2UgY29kZXNcclxuICogdG8gbGFuZ3VhZ2UgbmFtZXMgdGhhdCBhcmUgYXZhaWxhYmxlIGluIFBvbGx5LiBXaWxsIGJlIGVtcHR5IHVudGlsXHJcbiAqIFtpbml0aWFsaXplU2VydmljZV17QGxpbmsgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlLmluaXRpYWxpemVTZXJ2aWNlfVxyXG4gKiBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgZXhlY3V0ZWQuIFNlZSBbUG9sbHkgRG9jdW1lbnRhdGlvbl17QGxpbmsgaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL3BvbGx5L2xhdGVzdC9kZy9TdXBwb3J0ZWRMYW5ndWFnZS5odG1sfVxyXG4gKiBmb3IgYSBmdWxsIGxpc3Qgb2YgYXZhaWxhYmxlIGxhbmd1YWdlcyBhbmQgY29ycmVzcG9uZGluZyBjb2Rlcy5cclxuICogQHByb3BlcnR5IHtPYmplY3R9IEVWRU5UUyAtIEJ1aWx0LWluIG1lc3NhZ2VzIHRoYXQgdGhlIGZlYXR1cmUgZW1pdHMuIFdoZW4gdGhlXHJcbiAqIGZlYXR1cmUgaXMgYWRkZWQgdG8gYSB7QGxpbmsgY29yZS9Ib3N0T2JqZWN0fSwgZXZlbnQgbmFtZXMgd2lsbCBiZSBwcmVmaXhlZCBieSB0aGVcclxuICogbmFtZSBvZiB0aGUgZmVhdHVyZSBjbGFzcyArICcuJy5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVFMucmVhZHk9b25SZWFkeUV2ZW50XSAtIE1lc3NhZ2UgdGhhdCBpcyBlbWl0dGVkIGFmdGVyXHJcbiAqIFtpbml0aWFsaXplU2VydmljZV17QGxpbmsgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlLmluaXRpYWxpemVTZXJ2aWNlfSBoYXMgYmVlblxyXG4gKiBzdWNjZXNzZnVsbHkgZXhlY3V0ZWQuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLnBsYXk9b25QbGF5RXZlbnRdIC0gTWVzc2FnZSB0aGF0IGlzIGVtaXR0ZWQgYWZ0ZXJcclxuICogZWFjaCBjYWxsIHRvIFtwbGF5XXtAbGluayBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUjcGxheX0uIFRoZSBzcGVlY2ggdGhhdCB3YXMgcGxheWVkXHJcbiAqIGlzIHN1cHBsaWVkIGFzIGFuIGFyZ3VtZW50IHRvIGxpc3RlbmVyIGZ1bmN0aW9ucy5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVFMucGF1c2U9b25QYXVzZUV2ZW50XSAtIE1lc3NhZ2UgdGhhdCBpcyBlbWl0dGVkIGFmdGVyXHJcbiAqIGVhY2ggY2FsbCB0byBbcGF1c2Vde0BsaW5rIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSNwYXVzZX0uIFRoZSBzcGVlY2ggdGhhdCB3YXMgcGF1c2VkXHJcbiAqIGlzIHN1cHBsaWVkIGFzIGFuIGFyZ3VtZW50IHRvIGxpc3RlbmVyIGZ1bmN0aW9ucy5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVFMucmVzdW1lPW9uUmVzdW1lRXZlbnRdIC0gTWVzc2FnZSB0aGF0IGlzIGVtaXR0ZWQgYWZ0ZXJcclxuICogZWFjaCBjYWxsIHRvIFtyZXN1bWVde0BsaW5rIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSNyZXN1bWV9LiBUaGUgc3BlZWNoIHRoYXQgd2FzXHJcbiAqIHJlc3VtZWQgaXMgc3VwcGxpZWQgYXMgYW4gYXJndW1lbnQgdG8gbGlzdGVuZXIgZnVuY3Rpb25zLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UUy5pbnRlcnJ1cHQ9b25JbnRlcnJ1cHRFdmVudF0gLSBNZXNzYWdlIHRoYXQgaXMgZW1pdHRlZFxyXG4gKiBpZiB0aGVyZSBpcyBhIGN1cnJlbnQgc3BlZWNoIGluIHByb2dyZXNzIGFuZCBbcGxheV17QGxpbmsgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlI3BsYXl9XHJcbiAqIG9yIFtyZXN1bWVde0BsaW5rIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSNyZXN1bWV9IGFyZSBleGVjdXRlZCBmb3IgYSBuZXcgc3BlZWNoLlxyXG4gKiBUaGUgc3BlZWNoIHRoYXQgd2FzIGludGVycnVwdGVkIGlzIHN1cHBsaWVkIGFzIGFuIGFyZ3VtZW50IHRvIGxpc3RlbmVyIGZ1bmN0aW9ucy5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVFMuc3RvcD1vblN0b3BFdmVudF0gLSBNZXNzYWdlIHRoYXQgaXMgZW1pdHRlZCBhZnRlclxyXG4gKiBlYWNoIGNhbGwgdG8gW3N0b3Bde0BsaW5rIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSNzdG9wfSBhbmQgd2hlbiBhIHNwZWVjaCByZWFjaGVzXHJcbiAqIHRoZSBlbmQgb2YgcGxheWJhY2suIFRoZSBzcGVlY2ggdGhhdCB3YXMgc3RvcHBlZCBpcyBzdXBwbGllZCBhcyBhbiBhcmd1bWVudFxyXG4gKiB0byBsaXN0ZW5lciBmdW5jdGlvbnMuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLnNlbnRlbmNlPW9uU2VudGVuY2VFdmVudF0gLSBNZXNzYWdlIHRoYXQgaXMgZW1pdHRlZFxyXG4gKiBlYWNoIHRpbWUgYSBzZW50ZW5jZSBzcGVlY2htYXJrIGlzIGVuY291bnRlcmVkIHdob3NlIHRpbWVzdGFtcCBtYXRjaGVzIHVwIHdpdGhcclxuICogdGhlIHNwZWVjaCBhdWRpbydzIGN1cnJlbnQgdGltZS4gVGhlIHNlbnRlbmNlIHNwZWVjaG1hcmsgb2JqZWN0IGlzIHN1cHBsaWVkIGFzXHJcbiAqIGFuIGFyZ3VtZW50IHRvIGxpc3RlbmVyIGZ1bmN0aW9ucy5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVFMud29yZD1vbldvcmRFdmVudF0gLSBNZXNzYWdlIHRoYXQgaXMgZW1pdHRlZFxyXG4gKiBlYWNoIHRpbWUgYSB3b3JkIHNwZWVjaG1hcmsgaXMgZW5jb3VudGVyZWQgd2hvc2UgdGltZXN0YW1wIG1hdGNoZXMgdXAgd2l0aFxyXG4gKiB0aGUgc3BlZWNoIGF1ZGlvJ3MgY3VycmVudCB0aW1lLiBUaGUgd29yZCBzcGVlY2htYXJrIG9iamVjdCBpcyBzdXBwbGllZCBhc1xyXG4gKiBhbiBhcmd1bWVudCB0byBsaXN0ZW5lciBmdW5jdGlvbnMuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLnZpc2VtZT1vblZpc2VtZUV2ZW50XSAtIE1lc3NhZ2UgdGhhdCBpcyBlbWl0dGVkXHJcbiAqIGVhY2ggdGltZSBhIHZpc2VtZSBzcGVlY2htYXJrIGlzIGVuY291bnRlcmVkIHdob3NlIHRpbWVzdGFtcCBtYXRjaGVzIHVwIHdpdGhcclxuICogdGhlIHNwZWVjaCBhdWRpbydzIGN1cnJlbnQgdGltZS4gVGhlIHZpc2VtZSBzcGVlY2htYXJrIG9iamVjdCBpcyBzdXBwbGllZCBhc1xyXG4gKiBhbiBhcmd1bWVudCB0byBsaXN0ZW5lciBmdW5jdGlvbnMuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLnNzbWw9b25Tc21sRXZlbnRdIC0gTWVzc2FnZSB0aGF0IGlzIGVtaXR0ZWRcclxuICogZWFjaCB0aW1lIGEgc3NtbCBzcGVlY2htYXJrIGlzIGVuY291bnRlcmVkIHdob3NlIHRpbWVzdGFtcCBtYXRjaGVzIHVwIHdpdGhcclxuICogdGhlIHNwZWVjaCBhdWRpbydzIGN1cnJlbnQgdGltZS4gVGhlIHNzbWwgc3BlZWNobWFyayBvYmplY3QgaXMgc3VwcGxpZWQgYXNcclxuICogYW4gYXJndW1lbnQgdG8gbGlzdGVuZXIgZnVuY3Rpb25zLlxyXG4gKiBAcHJvcGVydHkge09iamVjdH0gU0VSVklDRVMgLSBBV1Mgc2VydmljZXMgdGhhdCBhcmUgbmVjZXNzYXJ5IGZvciB0aGUgZmVhdHVyZVxyXG4gKiB0byBmdW5jdGlvbi5cclxuICogQHByb3BlcnR5IHtleHRlcm5hbDpQb2xseX0gU0VSVklDRVMucG9sbHkgLSBUaGUgUG9sbHkgc2VydmljZSB0aGF0IGlzIHVzZWRcclxuICogdG8gc3ludGhlc2l6ZSBzcGVlY2htYXJrcy4gV2lsbCBiZSB1bmRlZmluZWQgdW50aWwgW2luaXRpYWxpemVTZXJ2aWNlXXtAbGluayBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUuaW5pdGlhbGl6ZVNlcnZpY2V9XHJcbiAqIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBleGVjdXRlZFxyXG4gKiBAcHJvcGVydHkge2V4dGVybmFsOlByZXNpZ25lcn0gU0VSVklDRVMucHJlc2lnbmVyIC0gVGhlIFBvbGx5IFByZXNpZ25lclxyXG4gKiBvYmplY3QgdGhhdCBpcyB1c2VkIHRvIHN5bnRoZXNpemUgc3BlZWNoIGF1ZGlvLiBXaWxsIGJlIHVuZGVmaW5lZCB1bnRpbFxyXG4gKiBbaW5pdGlhbGl6ZVNlcnZpY2Vde0BsaW5rIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZS5pbml0aWFsaXplU2VydmljZX1cclxuICogaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGV4ZWN1dGVkLlxyXG4gKi9cclxuY2xhc3MgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlIGV4dGVuZHMgQWJzdHJhY3RIb3N0RmVhdHVyZSB7XHJcbiAgLyoqXHJcbiAgICogQGNvbnN0cnVjdG9yXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2NvcmUvSG9zdE9iamVjdH0gaG9zdCAtIEhvc3Qgb2JqZWN0IG1hbmFnaW5nIHRoZSBmZWF0dXJlLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyAtIE9wdGlvbnMgdGhhdCB3aWxsIGJlIHNlbnQgdG8gUG9sbHkgZm9yIGVhY2ggc3BlZWNoLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0aW9ucy52b2ljZSAtIFRoZSBuYW1lIG9mIHRoZSBQb2xseSB2b2ljZSB0byB1c2UgZm9yIGFsbCBzcGVlY2guXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRpb25zLmVuZ2luZSAtIFRoZSBuYW1lIG9mIHRoZSBQb2xseSBlbmdpbmUgdG8gdXNlIGZvciBhbGwgc3BlZWNoLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0aW9ucy5sYW5ndWFnZSAtIFRoZSBuYW1lIG9mIHRoZSBsYW5ndWFnZSB0byB1c2UgZm9yIGFsbCBzcGVlY2guXHJcbiAgICogQHBhcmFtIHthdWRpb0Zvcm1hdH0gW29wdGlvbnMuYXVkaW9Gb3JtYXQ9J21wMyddIC0gVGhlIGZvcm1hdCB0byB1c2UgZm9yIGdlbmVyYXRlZFxyXG4gICAqIGF1ZGlvIGZvciBhbGwgc3BlZWNoZXMuXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRpb25zLnNhbXBsZVJhdGUgLSBUaGUgc2FtcGxlIHJhdGUgZm9yIGF1ZGlvIGZpbGVzIGZvciBhbGxcclxuICAgKiBzcGVlY2hlcy5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3BlZWNobWFya09mZnNldD0wXSAtIEFtb3VudCBvZiB0aW1lIGluIHNlY29uZHMgdG9cclxuICAgKiBvZmZzZXQgc3BlZWNobWFyayBldmVudCBlbWlzc2lvbiBmcm9tIHRoZSBhdWRpby5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWluRW5kTWFya0R1cmF0aW9uPS4wNV0gLSBUaGUgbWluaW11bSBhbW91bnQgb2YgdGltZVxyXG4gICAqIGluIHNlY29uZHMgdGhhdCB0aGUgbGFzdCBzcGVlY2htYXJrIG9mIGVhY2ggdHlwZSBpbiBhIHNwZWVjaCBjYW4gaGF2ZSBpdHNcclxuICAgKiBkdXJhdGlvbiBwcm9wZXJ0eSBzZXQgdG8uXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnZvbHVtZT0xXSAtIFRoZSBkZWZhdWx0IHZvbHVtZSB0byBwbGF5IHNwZWVjaCBhdWRpb1xyXG4gICAqIHdpdGguXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pc0dsb2JhbD1mYWxzZV0gLSBXaGV0aGVyIHRoZSBhdWRpbyBzb3VyY2Ugc2hvdWxkIGRlZmF1bHRcclxuICAgKiB0byBnbG9iYWwgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIG9yIG5vdCBpdCBpcyBhdHRhY2hlZCB0byBhbiBvYmplY3QuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBob3N0LFxyXG4gICAgb3B0aW9ucyA9IHtcclxuICAgICAgdm9pY2U6IHVuZGVmaW5lZCxcclxuICAgICAgZW5naW5lOiB1bmRlZmluZWQsXHJcbiAgICAgIGxhbmd1YWdlOiB1bmRlZmluZWQsXHJcbiAgICAgIGF1ZGlvRm9ybWF0OiAnbXAzJyxcclxuICAgICAgc2FtcGxlUmF0ZTogdW5kZWZpbmVkLFxyXG4gICAgICBzcGVlY2htYXJrT2Zmc2V0OiAwLFxyXG4gICAgICBtaW5FbmRNYXJrRHVyYXRpb246IDAuMDUsXHJcbiAgICAgIHZvbHVtZTogMSxcclxuICAgICAgaXNHbG9iYWw6IGZhbHNlLFxyXG4gICAgfVxyXG4gICkge1xyXG4gICAgc3VwZXIoaG9zdCk7XHJcblxyXG4gICAgdGhpcy5fc3BlZWNoQ2FjaGUgPSB7fTtcclxuICAgIHRoaXMuX2N1cnJlbnRTcGVlY2ggPSBudWxsO1xyXG4gICAgdGhpcy5fY3VycmVudFByb21pc2UgPSBudWxsO1xyXG4gICAgdGhpcy5faXNWYWxpZGF0ZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuc3BlZWNobWFya09mZnNldCA9IE51bWJlci5pc05hTihOdW1iZXIob3B0aW9ucy5zcGVlY2htYXJrT2Zmc2V0KSlcclxuICAgICAgPyAwXHJcbiAgICAgIDogTnVtYmVyKG9wdGlvbnMuc3BlZWNobWFya09mZnNldCk7XHJcbiAgICB0aGlzLm1pbkVuZE1hcmtEdXJhdGlvbiA9IE51bWJlci5pc05hTihOdW1iZXIob3B0aW9ucy5taW5FbmRNYXJrRHVyYXRpb24pKVxyXG4gICAgICA/IDBcclxuICAgICAgOiBOdW1iZXIob3B0aW9ucy5taW5FbmRNYXJrRHVyYXRpb24pO1xyXG4gICAgdGhpcy52b2x1bWUgPSBOdW1iZXIuaXNOYU4oTnVtYmVyKG9wdGlvbnMudm9sdW1lKSlcclxuICAgICAgPyAxXHJcbiAgICAgIDogTnVtYmVyKG9wdGlvbnMudm9sdW1lKTtcclxuICAgIHRoaXMuX2lzR2xvYmFsID0gb3B0aW9ucy5pc0dsb2JhbCB8fCBmYWxzZTtcclxuICAgIHRoaXMuX3Byb21pc2VzID0ge1xyXG4gICAgICB2b2x1bWU6IERlZmVycmVkLnJlc29sdmUoKSxcclxuICAgIH07XHJcbiAgICB0aGlzLl92b2x1bWVQYXVzZWQgPSBmYWxzZTtcclxuXHJcbiAgICAvLyBTZXQgZGVmYXVsdCBvcHRpb25zIGZvciBlYWNoIHNwZWVjaFxyXG4gICAgdGhpcy5fdm9pY2UgPSBvcHRpb25zLnZvaWNlIHx8IHRoaXMuY29uc3RydWN0b3IuUE9MTFlfREVGQVVMVFMuVm9pY2VJZDtcclxuICAgIHRoaXMuX2xhbmd1YWdlID1cclxuICAgICAgb3B0aW9ucy5sYW5ndWFnZSB8fCB0aGlzLmNvbnN0cnVjdG9yLlBPTExZX0RFRkFVTFRTLkxhbmd1YWdlTmFtZTtcclxuICAgIHRoaXMuX2VuZ2luZSA9IGVuZ2luZXMuaW5jbHVkZXMob3B0aW9ucy5lbmdpbmUpXHJcbiAgICAgID8gb3B0aW9ucy5lbmdpbmVcclxuICAgICAgOiB0aGlzLmNvbnN0cnVjdG9yLlBPTExZX0RFRkFVTFRTLkVuZ2luZTtcclxuICAgIHRoaXMuX2F1ZGlvRm9ybWF0ID0gYXVkaW9Gb3JtYXRzLmluY2x1ZGVzKG9wdGlvbnMuYXVkaW9Gb3JtYXQpXHJcbiAgICAgID8gb3B0aW9ucy5hdWRpb0Zvcm1hdFxyXG4gICAgICA6IHRoaXMuY29uc3RydWN0b3IuUE9MTFlfREVGQVVMVFMuT3V0cHV0Rm9ybWF0O1xyXG4gICAgdGhpcy5fc2FtcGxlUmF0ZSA9IHNhbXBsZVJhdGVzW3RoaXMuX2F1ZGlvRm9ybWF0XS5yYXRlcy5pbmNsdWRlcyhcclxuICAgICAgb3B0aW9ucy5zYW1wbGVSYXRlXHJcbiAgICApXHJcbiAgICAgID8gb3B0aW9ucy5zYW1wbGVSYXRlXHJcbiAgICAgIDogdGhpcy5jb25zdHJ1Y3Rvci5QT0xMWV9ERUZBVUxUUy5TYW1wbGVSYXRlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RvcmUgUG9sbHksIFByZXNpZ25lciBhbmQgQVdTIFNESyBWZXJzaW9uIGZvciB1c2UgYWNyb3NzIGFsbCBpbnN0YW5jZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2V4dGVybmFsOlBvbGx5fSBwb2xseSAtIFBvbGx5IGluc3RhbmNlIHRvIHVzZSB0byBnZW5lcmF0ZSBzcGVlY2htYXJrcy5cclxuICAgKiBAcGFyYW0ge2V4dGVybmFsOlByZXNpZ25lcn0gcHJlc2lnbmVyIC0gUHJlc2lnbmVyIGluc3RhbmNlIHRvIHVzZSB0byBnZW5lcmF0ZVxyXG4gICAqIGF1ZGlvIFVSTHMuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZlcnNpb24gLSBWZXJzaW9uIG9mIHRoZSBBV1MgU0RLIHRvIHVzZSB0byB2YWxpZGF0ZSB2b2ljZSBvcHRpb25zLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBpbml0aWFsaXplU2VydmljZShwb2xseSwgcHJlc2lnbmVyLCB2ZXJzaW9uKSB7XHJcbiAgICAvLyBNYWtlIHN1cmUgYWxsIHdlcmUgZGVmaW5lZFxyXG4gICAgaWYgKFxyXG4gICAgICBwb2xseSA9PT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgIHByZXNpZ25lciA9PT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgIHZlcnNpb24gPT09IHVuZGVmaW5lZFxyXG4gICAgKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAnQ2Fubm90IGluaXRpYWxpemUgVGV4dFRvU3BlZWNoIGZlYXR1cmUuIEFsbCBhcmd1bWVudHMgbXVzdCBiZSBkZWZpbmVkLidcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgc3VtZXJpYW4gaG9zdHMgdXNlci1hZ2VudFxyXG4gICAgaWYgKHBvbGx5LmNvbmZpZykge1xyXG4gICAgICBwb2xseS5jb25maWcuY3VzdG9tVXNlckFnZW50ID0gdGhpcy5fd2l0aEN1c3RvbVVzZXJBZ2VudChcclxuICAgICAgICBwb2xseS5jb25maWcuY3VzdG9tVXNlckFnZW50XHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICBpZiAocHJlc2lnbmVyLnNlcnZpY2UgJiYgcHJlc2lnbmVyLnNlcnZpY2UuY29uZmlnKSB7XHJcbiAgICAgIHByZXNpZ25lci5zZXJ2aWNlLmNvbmZpZy5jdXN0b21Vc2VyQWdlbnQgPSB0aGlzLl93aXRoQ3VzdG9tVXNlckFnZW50KFxyXG4gICAgICAgIHByZXNpZ25lci5zZXJ2aWNlLmNvbmZpZy5jdXN0b21Vc2VyQWdlbnRcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9pc1JlYWR5ID0gZmFsc2U7XHJcblxyXG4gICAgLy8gU3RvcmUgcGFyYW1ldGVyc1xyXG4gICAgdGhpcy5TRVJWSUNFUy5wb2xseSA9IHBvbGx5O1xyXG4gICAgdGhpcy5TRVJWSUNFUy5wcmVzaWduZXIgPSBwcmVzaWduZXI7XHJcbiAgICBhd3NWZXJzaW9uID0gdmVyc2lvbjtcclxuXHJcbiAgICAvLyBDbGVhciB0aGUgY3VycmVudCBwb2xseSBvYmplY3RzXHJcbiAgICBjb25zdCBhdmFpbGFibGVWb2ljZXMgPSB0aGlzLlBPTExZX1ZPSUNFUztcclxuICAgIGF2YWlsYWJsZVZvaWNlcy5sZW5ndGggPSAwO1xyXG5cclxuICAgIGNvbnN0IGF2YWlsYWJsZUxhbmd1YWdlcyA9IHRoaXMuUE9MTFlfTEFOR1VBR0VTO1xyXG4gICAgT2JqZWN0LmtleXMoYXZhaWxhYmxlTGFuZ3VhZ2VzKS5mb3JFYWNoKG5hbWUgPT4ge1xyXG4gICAgICBkZWxldGUgYXZhaWxhYmxlTGFuZ3VhZ2VzW25hbWVdO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgYXZhaWxhYmxlTGFuZ3VhZ2VDb2RlcyA9IHRoaXMuUE9MTFlfTEFOR1VBR0VfQ09ERVM7XHJcbiAgICBPYmplY3Qua2V5cyhhdmFpbGFibGVMYW5ndWFnZUNvZGVzKS5mb3JFYWNoKG5hbWUgPT4ge1xyXG4gICAgICBkZWxldGUgYXZhaWxhYmxlTGFuZ3VhZ2VDb2Rlc1tuYW1lXTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFJlLXBvcHVsYXRlIGFjY29yZGluZyB0byB2ZXJzaW9uXHJcbiAgICBjb25zdCBtaW5OZXVyYWxTZGsgPSB0aGlzLlBPTExZX01JTl9ORVVSQUxfVkVSU0lPTjtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5TRVJWSUNFUy5wb2xseVxyXG4gICAgICAuZGVzY3JpYmVWb2ljZXMoKVxyXG4gICAgICAucHJvbWlzZSgpXHJcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcclxuICAgICAgICBjb25zdCBhbGxDb2RlcyA9IHt9O1xyXG5cclxuICAgICAgICByZXNwb25zZS5Wb2ljZXMuZm9yRWFjaCh2b2ljZSA9PiB7XHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIHZvaWNlLlN1cHBvcnRlZEVuZ2luZXMuaW5jbHVkZXMoJ3N0YW5kYXJkJykgfHxcclxuICAgICAgICAgICAgdmVyc2lvbiA+PSBtaW5OZXVyYWxTZGtcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICBhdmFpbGFibGVWb2ljZXMucHVzaCh2b2ljZSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgYXZhaWxhYmxlVm9pY2VzLmZvckVhY2godm9pY2UgPT4ge1xyXG4gICAgICAgICAgICBhdmFpbGFibGVMYW5ndWFnZXNbdm9pY2UuTGFuZ3VhZ2VOYW1lXSA9IHZvaWNlLkxhbmd1YWdlQ29kZTtcclxuICAgICAgICAgICAgYWxsQ29kZXNbdm9pY2UuTGFuZ3VhZ2VDb2RlXSA9IHZvaWNlLkxhbmd1YWdlTmFtZTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBPYmplY3QuZW50cmllcyhhdmFpbGFibGVMYW5ndWFnZXMpLmZvckVhY2goKFtuYW1lLCBjb2RlXSkgPT4ge1xyXG4gICAgICAgICAgYXZhaWxhYmxlTGFuZ3VhZ2VDb2Rlc1tjb2RlXSA9IG5hbWU7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIE5vdGlmeSB0aGF0IHdlJ3JlIHJlYWR5IHRvIGdlbmVyYXRlIHNwZWVjaGVzXHJcbiAgICAgICAgdGhpcy5faXNSZWFkeSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5lbWl0KHRoaXMuRVZFTlRTLnJlYWR5KTtcclxuICAgICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdGhlIGNsYXNzIGlzIGNhcGFibGUgb2YgZ2VuZXJhdGluZyBzcGVlY2ggYXVkaW8uIFBvbGx5LFxyXG4gICAqIFByZXNpZ25lciBhbmQgQVdTIFNESyB2ZXJzaW9uIG51bWJlciBtdXN0IGhhdmUgYmVlbiBkZWZpbmVkIHVzaW5nXHJcbiAgICogW2luaXRpYWxpemVTZXJ2aWNlXXtAbGluayBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUuaW5pdGlhbGl6ZVNlcnZpY2V9LlxyXG4gICAqXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgc3RhdGljIGdldCBpc1JlYWR5KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2lzUmVhZHk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSB0ZXh0IG9mIHRoZSBjdXJyZW50bHkgcGxheWluZyBzcGVlY2guXHJcbiAgICpcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAqL1xyXG4gIGdldCBjdXJyZW50U3BlZWNoKCkge1xyXG4gICAgaWYgKHRoaXMuX2N1cnJlbnRTcGVlY2gpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRTcGVlY2gudGV4dDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyBhbmQgc2V0cyB0aGUgbnVtYmVyIG9mIHNlY29uZHMgdG8gb2Zmc2V0IHNwZWVjaG1hcmsgZW1pc3Npb24uXHJcbiAgICpcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBzcGVlY2htYXJrT2Zmc2V0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3NwZWVjaG1hcmtPZmZzZXQ7XHJcbiAgfVxyXG5cclxuICBzZXQgc3BlZWNobWFya09mZnNldChvZmZzZXQpIHtcclxuICAgIHRoaXMuX3NwZWVjaG1hcmtPZmZzZXQgPSBvZmZzZXQ7XHJcblxyXG4gICAgaWYgKHRoaXMuX2N1cnJlbnRTcGVlY2gpIHtcclxuICAgICAgdGhpcy5fY3VycmVudFNwZWVjaC5zcGVlY2htYXJrT2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyBhbmQgc2V0cyB0aGUgVGhlIG1pbmltdW0gYW1vdW50IG9mIHRpbWUgaW4gc2Vjb25kcyB0aGF0IHRoZSBsYXN0XHJcbiAgICogc3BlZWNobWFyayBvZiBlYWNoIHR5cGUgaW4gYSBzcGVlY2ggY2FuIGhhdmUgaXRzIGR1cmF0aW9uIHByb3BlcnR5IHNldCB0by5cclxuICAgKlxyXG4gICAqIEB0eXBlIG51bWJlclxyXG4gICAqL1xyXG4gIGdldCBtaW5FbmRNYXJrRHVyYXRpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbWluRW5kTWFya0R1cmF0aW9uIC8gMTAwMDtcclxuICB9XHJcblxyXG4gIHNldCBtaW5FbmRNYXJrRHVyYXRpb24oZHVyYXRpb24pIHtcclxuICAgIHRoaXMuX21pbkVuZE1hcmtEdXJhdGlvbiA9IGR1cmF0aW9uICogMTAwMDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFwcGVuZHMgdGhlIFN1bWVyaWFuIEhvc3RzIGN1c3RvbSB1c2VyLWFnZW50IHRvIGEgc3RyaW5nIGlmIGl0IGlzIG5vdFxyXG4gICAqIGFscmVhZHkgcHJlc2VudC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gY3VycmVudFVzZXJBZ2VudCAtIFN0cmluZyB0byBhcHBlbmQgdG8gaWYgbmVlZGVkLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgKi9cclxuICBzdGF0aWMgX3dpdGhDdXN0b21Vc2VyQWdlbnQoY3VycmVudFVzZXJBZ2VudCkge1xyXG4gICAgY29uc3Qgc3VtZXJpYW5Ib3N0c1VzZXJBZ2VudCA9ICdyZXF1ZXN0LXNvdXJjZS9TdW1lcmlhbkhvc3RzJztcclxuXHJcbiAgICBpZiAoY3VycmVudFVzZXJBZ2VudCA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBzdW1lcmlhbkhvc3RzVXNlckFnZW50O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjdXJyZW50VXNlckFnZW50LmluZGV4T2Yoc3VtZXJpYW5Ib3N0c1VzZXJBZ2VudCkgIT09IC0xKSB7XHJcbiAgICAgIHJldHVybiBjdXJyZW50VXNlckFnZW50O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjdXJyZW50VXNlckFnZW50LmNvbmNhdCgnICcsIHN1bWVyaWFuSG9zdHNVc2VyQWdlbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIGEgZ2l2ZW4gZW5naW5lIHR5cGUgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBBV1MgU0RLIHZlcnNpb24uIElmIGl0XHJcbiAgICogaXMsIHJldHVybiB0aGUgb3JpZ2luYWwgdmFsdWUuIE90aGVyd2lzZSByZXR1cm4gYSBkZWZhdWx0LlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbmdpbmUgLSBUaGUgdHlwZSBvZiBQb2xseSB2b2ljZSBlbmdpbmUgdG8gdmFsaWRhdGUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAqL1xyXG4gIF92YWxpZGF0ZUVuZ2luZShlbmdpbmUpIHtcclxuICAgIC8vIERlZmF1bHQgdG8gdGhlIHN0YW5kYXJkIGVuZ2luZSBpZiBuZXVyYWwgaXMgbm90IGF2YWlsYWJsZSBmb3IgdGhpcyB2ZXJzaW9uXHJcbiAgICBpZiAoXHJcbiAgICAgIGVuZ2luZSA9PT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuQVdTX1ZFUlNJT04gPCB0aGlzLmNvbnN0cnVjdG9yLlBPTExZX01JTl9ORVVSQUxfVkVSU0lPTlxyXG4gICAgKSB7XHJcbiAgICAgIGVuZ2luZSA9IHRoaXMuY29uc3RydWN0b3IuUE9MTFlfREVGQVVMVFMuRW5naW5lO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBlbmdpbmU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVja3MgaWYgYSBnaXZlbiBhdWRpbyBmb3JtYXQgdHlwZSBpcyBjb21wYXRpYmxlIHdpdGggUG9sbHkuIElmIGl0IGlzLCByZXR1cm5cclxuICAgKiB0aGUgb3JpZ2luYWwgdmFsdWUuIE90aGVyd2lzZSByZXR1cm4gYSBkZWZhdWx0LlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbmdpbmUgLSBUaGUgdHlwZSBvZiBQb2xseSB2b2ljZSBlbmdpbmUgdG8gdmFsaWRhdGUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAqL1xyXG4gIF92YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHtcclxuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCB8fCAhYXVkaW9Gb3JtYXRzLmluY2x1ZGVzKGZvcm1hdCkpIHtcclxuICAgICAgZm9ybWF0ID0gdGhpcy5jb25zdHJ1Y3Rvci5QT0xMWV9ERUZBVUxUUy5PdXRwdXRGb3JtYXQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZvcm1hdDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyBpZiBhIGdpdmVuIGF1ZGlvIHNhbXBsaW5nIHJhdGUgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBjdXJyZW50IGF1ZGlvXHJcbiAgICogZm9ybWF0LiBJZiBpdCBpcywgcmV0dXJuIHRoZSBvcmlnaW5hbCB2YWx1ZS4gT3RoZXJ3aXNlIHJldHVybiBhIGRlZmF1bHQuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVuZ2luZSAtIFRoZSB0eXBlIG9mIFBvbGx5IHZvaWNlIGVuZ2luZSB0byB2YWxpZGF0ZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICovXHJcbiAgX3ZhbGlkYXRlUmF0ZShyYXRlKSB7XHJcbiAgICAvLyBVc2UgZGVmYXVsdCBpZiBzcGVjaWZpZWQgc2FtcGxlIHJhdGUgaXMgbm90IHZhbGlkIGZvciB0aGUgYXVkaW8gZm9ybWF0XHJcbiAgICBpZiAoXHJcbiAgICAgIHJhdGUgPT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICAhc2FtcGxlUmF0ZXNbdGhpcy5fYXVkaW9Gb3JtYXRdLnJhdGVzLmluY2x1ZGVzKHJhdGUpXHJcbiAgICApIHtcclxuICAgICAgcmF0ZSA9IHNhbXBsZVJhdGVzW3RoaXMuX2F1ZGlvRm9ybWF0XS5kZWZhdWx0c1t0aGlzLl9lbmdpbmVdO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByYXRlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIGEgZ2l2ZW4gUG9sbHkgdm9pY2UgaWQgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBjdXJyZW50IFBvbGx5IGVuZ2luZS5cclxuICAgKiBJZiBpdCBpcywgcmV0dXJuIHRoZSBvcmlnaW5hbCB2YWx1ZS4gT3RoZXJ3aXNlIHJldHVybiBhIGRlZmF1bHQuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVuZ2luZSAtIFRoZSB0eXBlIG9mIFBvbGx5IHZvaWNlIGVuZ2luZSB0byB2YWxpZGF0ZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICovXHJcbiAgX3ZhbGlkYXRlVm9pY2Uodm9pY2VJZCkge1xyXG4gICAgY29uc3Qgdm9pY2UgPSB0aGlzLmNvbnN0cnVjdG9yLlBPTExZX1ZPSUNFUy5maW5kKHYgPT4gdi5JZCA9PT0gdm9pY2VJZCk7XHJcblxyXG4gICAgLy8gVXNlIHRoZSBkZWZhdWx0IHZvaWNlIGlmIHRoZSB2b2ljZSBpc24ndCBzdXBwb3J0ZWQgYnkgdGhlIGVuZ2luZVxyXG4gICAgaWYgKHZvaWNlID09PSB1bmRlZmluZWQgfHwgIXZvaWNlLlN1cHBvcnRlZEVuZ2luZXMuaW5jbHVkZXModGhpcy5fZW5naW5lKSkge1xyXG4gICAgICB2b2ljZUlkID0gdGhpcy5jb25zdHJ1Y3Rvci5QT0xMWV9ERUZBVUxUUy5Wb2ljZUlkO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB2b2ljZUlkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIGEgZ2l2ZW4gUG9sbHkgbGFuZ3VhZ2UgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBjdXJyZW50IFBvbGx5IHZvaWNlLlxyXG4gICAqIElmIGl0IGlzLCByZXR1cm4gdGhlIG9yaWdpbmFsIHZhbHVlLiBPdGhlcndpc2UgcmV0dXJuIGEgZGVmYXVsdC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZW5naW5lIC0gVGhlIHR5cGUgb2YgUG9sbHkgdm9pY2UgZW5naW5lIHRvIHZhbGlkYXRlLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgKi9cclxuICBfdmFsaWRhdGVMYW5ndWFnZShsYW5ndWFnZSkge1xyXG4gICAgY29uc3Qgdm9pY2UgPSB0aGlzLmNvbnN0cnVjdG9yLlBPTExZX1ZPSUNFUy5maW5kKHYgPT4gdi5JZCA9PT0gdGhpcy5fdm9pY2UpO1xyXG4gICAgY29uc3QgbGFuZ3VhZ2VDb2RlID0gdGhpcy5jb25zdHJ1Y3Rvci5QT0xMWV9MQU5HVUFHRVNbbGFuZ3VhZ2VdO1xyXG5cclxuICAgIC8vIEZpbmQgdGhlIGxhbmd1YWdlcyBhdmFpbGFibGUgZm9yIHRoZSBjdXJyZW50IHZvaWNlXHJcbiAgICBjb25zdCBhdmFpbGFibGVDb2RlcyA9IFt2b2ljZS5MYW5ndWFnZUNvZGVdO1xyXG4gICAgaWYgKHZvaWNlLkFkZGl0aW9uYWxMYW5ndWFnZUNvZGVzKSB7XHJcbiAgICAgIGF2YWlsYWJsZUNvZGVzLnB1c2goLi4udm9pY2UuQWRkaXRpb25hbExhbmd1YWdlQ29kZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIHRoZSBjdXJyZW50IHZvaWNlIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgbGFuZ3VhZ2UsIHVzZSBpdHMgZGVmYXVsdFxyXG4gICAgaWYgKCFhdmFpbGFibGVDb2Rlcy5pbmNsdWRlcyhsYW5ndWFnZUNvZGUpKSB7XHJcbiAgICAgIGxhbmd1YWdlID0gdGhpcy5jb25zdHJ1Y3Rvci5QT0xMWV9MQU5HVUFHRV9DT0RFU1t2b2ljZS5MYW5ndWFnZUNvZGVdO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBsYW5ndWFnZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFZhbGlkYXRlIHRoZSBjdXJyZW50IFBvbGx5IG9wdGlvbnMgdG8gbWFrZSBzdXJlIHRoZXkgYXJlIGNvbXBhdGlibGUgd2l0aCBlYWNoXHJcbiAgICogb3RoZXIuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF92YWxpZGF0ZSgpIHtcclxuICAgIC8vIFZhbGlkYXRlIHNwZWVjaCBwYXJhbWV0ZXJzXHJcbiAgICB0aGlzLl9lbmdpbmUgPSB0aGlzLl92YWxpZGF0ZUVuZ2luZSh0aGlzLl9lbmdpbmUpO1xyXG4gICAgdGhpcy5fYXVkaW9Gb3JtYXQgPSB0aGlzLl92YWxpZGF0ZUZvcm1hdCh0aGlzLl9hdWRpb0Zvcm1hdCk7XHJcbiAgICB0aGlzLl9zYW1wbGVSYXRlID0gdGhpcy5fdmFsaWRhdGVSYXRlKHRoaXMuX3NhbXBsZVJhdGUpO1xyXG4gICAgdGhpcy5fdm9pY2UgPSB0aGlzLl92YWxpZGF0ZVZvaWNlKHRoaXMuX3ZvaWNlKTtcclxuICAgIHRoaXMuX2xhbmd1YWdlID0gdGhpcy5fdmFsaWRhdGVMYW5ndWFnZSh0aGlzLl9sYW5ndWFnZSk7XHJcbiAgICB0aGlzLl9pc1ZhbGlkYXRlZCA9IHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gYW4gb2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVycyBjb21wYXRpYmxlIHdpdGggUG9sbHkuc3ludGhlc2l6ZVNwZWVjaC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gICAqL1xyXG4gIF9nZXRDb25maWcoKSB7XHJcbiAgICAvLyBNYWtlIHN1cmUgcGFyYW1ldGVycyBoYXZlIGJlZW4gdmFsaWRhdGVkXHJcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5pc1JlYWR5ICYmICF0aGlzLl9pc1ZhbGlkYXRlZCkge1xyXG4gICAgICB0aGlzLl92YWxpZGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENyZWF0ZSBhIGNvbmZpZyBvYmplY3QgY29tcGF0aWJsZSB3aXRoIFBvbGx5XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBFbmdpbmU6IHRoaXMuX2VuZ2luZSxcclxuICAgICAgT3V0cHV0Rm9ybWF0OiB0aGlzLl9hdWRpb0Zvcm1hdCxcclxuICAgICAgU2FtcGxlUmF0ZTogdGhpcy5fc2FtcGxlUmF0ZSxcclxuICAgICAgVm9pY2VJZDogdGhpcy5fdm9pY2UsXHJcbiAgICAgIExhbmd1YWdlQ29kZTogdGhpcy5jb25zdHJ1Y3Rvci5QT0xMWV9MQU5HVUFHRVNbdGhpcy5fbGFuZ3VhZ2VdLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBQb2xseSBwYXJhbWV0ZXJzIHdpdGggb3B0aW9ucyBmcm9tIGEgZ2l2ZW4gY29uZmlnLiBBbGwgc3RvcmVkIHNwZWVjaGVzXHJcbiAgICogd2lsbCBiZSB1cGRhdGVkIHRvIHVzZSB0aGUgbmV3IHBhcmFtZXRlcnMsIHVubGVzcyB0aGUgc3BlZWNoIHRleHQgaXMgY29udGFpbmVkXHJcbiAgICogaW4gdGhlICdza2lwU3BlZWNoZXMnIHBhcmFtZXRlci5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIC0gUG9sbHkgcGFyYW1ldGVyIG9wdGlvbnMgdG8gb3ZlcndyaXRlLlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHNraXBTcGVlY2hlcyAtIFRleHQgb2YgYW55IHNwZWVjaGVzIHRoYXQgc2hvdWxkIG5vdFxyXG4gICAqIGhhdmUgcGFyYW1ldGVycyB1cGRhdGVkLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge09iamVjdH1cclxuICAgKi9cclxuICBfdXBkYXRlQ29uZmlnKGNvbmZpZywgc2tpcFNwZWVjaGVzID0gW10pIHtcclxuICAgIGNvbnN0IGN1cnJlbnRDb25maWcgPSB0aGlzLl9nZXRDb25maWcoKTtcclxuICAgIGlmICghY29uZmlnKSB7XHJcbiAgICAgIHJldHVybiBjdXJyZW50Q29uZmlnO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2lzVmFsaWRhdGVkID0gZmFsc2U7XHJcbiAgICBjb25zdCBjdXJyZW50Q29uZmlnU3RyID0gSlNPTi5zdHJpbmdpZnkoY3VycmVudENvbmZpZyk7XHJcblxyXG4gICAgLy8gVXBkYXRlIG9wdGlvbnNcclxuICAgIGlmIChjb25maWcuRW5naW5lKSB7XHJcbiAgICAgIHRoaXMuX2VuZ2luZSA9IGNvbmZpZy5FbmdpbmU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNvbmZpZy5hdWRpb0Zvcm1hdCkge1xyXG4gICAgICB0aGlzLl9hdWRpb0Zvcm1hdCA9IGNvbmZpZy5hdWRpb0Zvcm1hdDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY29uZmlnLlNhbXBsZVJhdGUpIHtcclxuICAgICAgdGhpcy5fc2FtcGxlUmF0ZSA9IGNvbmZpZy5TYW1wbGVSYXRlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjb25maWcuVm9pY2VJZCkge1xyXG4gICAgICB0aGlzLl92b2ljZSA9IGNvbmZpZy5Wb2ljZUlkO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjb25maWcuTGFuZ3VhZ2UpIHtcclxuICAgICAgdGhpcy5fbGFuZ3VhZ2UgPSBjb25maWcuTGFuZ3VhZ2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVmFsaWRhdGUgdGhlIGNvbmZpZ1xyXG4gICAgY29uc3QgdmFsaWRDb25maWcgPSB0aGlzLl9nZXRDb25maWcoKTtcclxuXHJcbiAgICAvLyBFeGl0IGlmIG5vdGhpbmcgaGFzIGNoYW5nZWRcclxuICAgIGNvbnN0IGNvbmZpZ1N0ciA9IEpTT04uc3RyaW5naWZ5KHZhbGlkQ29uZmlnKTtcclxuICAgIGlmIChjdXJyZW50Q29uZmlnU3RyID09PSBjb25maWdTdHIpIHtcclxuICAgICAgdGhpcy5faXNWYWxpZGF0ZWQgPSB0cnVlO1xyXG4gICAgICByZXR1cm4gdmFsaWRDb25maWc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVXBkYXRlIGFsbCBjYWNoZWQgY29uZmlnc1xyXG4gICAgT2JqZWN0LmVudHJpZXModGhpcy5fc3BlZWNoQ2FjaGUpLmZvckVhY2goKFt0ZXh0LCBzcGVlY2hdKSA9PiB7XHJcbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBza2lwcGVkIHNwZWVjaFxyXG4gICAgICBpZiAoc2tpcFNwZWVjaGVzLmluY2x1ZGVzKHRleHQpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBzcGVlY2hDb25maWdTdHIgPSBKU09OLnN0cmluZ2lmeShzcGVlY2guY29uZmlnKTtcclxuXHJcbiAgICAgIC8vIFVwZGF0ZSB0aGUgc3BlZWNoIHdpdGggbmV3IHBhcmFtZXRlcnNcclxuICAgICAgaWYgKHNwZWVjaENvbmZpZ1N0ciAhPT0gY29uZmlnU3RyKSB7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlU3BlZWNoKHRleHQsIHZhbGlkQ29uZmlnKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHZhbGlkQ29uZmlnO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIGFuIGV4aXN0aW5nIHNwZWVjaCwgb3IgYWRkIGEgbmV3IHNwZWVjaCB3aXRoIG5ldyBQb2xseSBwYXJhbWV0ZXJzIHdpdGhcclxuICAgKiBvcHRpb25zIGZyb20gYSBnaXZlbiBjb25maWcuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCBvZiB0aGUgc3BlZWNoIHRvIHVwZGF0ZS5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIC0gUG9sbHkgcGFyYW1ldGVyIG9wdGlvbnMgdG8gdXBkYXRlLlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlPWZhbHNlXSAtIFdoZXRoZXIgdG8gZm9yY2UgdGhlIHNwZWVjaCB0byBiZSB1cGRhdGVkXHJcbiAgICogaWYgbm8gcGFyYW1ldGVycyBoYXZlIGNoYW5nZXMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7QWJzdHJhY3RTcGVlY2h9XHJcbiAgICovXHJcbiAgX3VwZGF0ZVNwZWVjaCh0ZXh0LCBjb25maWcsIGZvcmNlID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IHNwZWVjaCA9IHRoaXMuX3NwZWVjaENhY2hlW3RleHRdIHx8IHt9O1xyXG4gICAgLy8gRXhpdCBpZiBub3RoaW5nIGhhcyBjaGFuZ2VkIGFuZCBmb3JjZSBpcyBmYWxzZVxyXG4gICAgaWYgKFxyXG4gICAgICAhZm9yY2UgJiZcclxuICAgICAgY29uZmlnICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgc3BlZWNoLmNvbmZpZyAmJlxyXG4gICAgICBKU09OLnN0cmluZ2lmeShjb25maWcpID09PSBKU09OLnN0cmluZ2lmeShzcGVlY2guY29uZmlnKVxyXG4gICAgKSB7XHJcbiAgICAgIHJldHVybiBzcGVlY2g7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ3JlYXRlIHNlcGFyYXRlIHBhcmFtZXRlcnMgZm9yIGF1ZGlvIGFuZCBzcGVlY2htYXJrIGdlbmVyYXRpb25cclxuICAgIGNvbnN0IGF1ZGlvUGFyYW1zID0ge1xyXG4gICAgICAuLi5jb25maWcsXHJcbiAgICAgIFRleHQ6IHRleHQsXHJcbiAgICAgIFRleHRUeXBlOiAnc3NtbCcsXHJcbiAgICB9O1xyXG4gICAgY29uc3Qgc3BlZWNobWFya1BhcmFtcyA9IHtcclxuICAgICAgLi4uYXVkaW9QYXJhbXMsXHJcbiAgICAgIE91dHB1dEZvcm1hdDogJ2pzb24nLFxyXG4gICAgICBTcGVlY2hNYXJrVHlwZXM6IHNwZWVjaG1hcmtUeXBlcyxcclxuICAgIH07XHJcblxyXG4gICAgLy8gR2VuZXJhdGUgYXVkaW8gYW5kIHNwZWVjaG1hcmtzXHJcbiAgICBzcGVlY2guY29uZmlnID0gY29uZmlnO1xyXG4gICAgc3BlZWNoLnByb21pc2UgPSBQcm9taXNlLmFsbChbXHJcbiAgICAgIHRoaXMuX3N5bnRoZXNpemVTcGVlY2htYXJrcyhzcGVlY2htYXJrUGFyYW1zKSxcclxuICAgICAgdGhpcy5fc3ludGhlc2l6ZUF1ZGlvKGF1ZGlvUGFyYW1zKSxcclxuICAgIF0pLnRoZW4ocmVzdWx0cyA9PiB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVTcGVlY2godGV4dCwgLi4ucmVzdWx0cyk7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuX3NwZWVjaENhY2hlW3RleHRdID0gc3BlZWNoO1xyXG5cclxuICAgIHJldHVybiBzcGVlY2g7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgU3BlZWNoIG9iamVjdCBmb3IgdGhlIHNwZWFrZXIuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtUZXh0VG9TcGVlY2h9IHNwZWFrZXIgLSBUaGUgVGV4dFRvU3BlZWNoIGluc3RhbmNlIHRoYXQgd2lsbCBvd24gdGhlIHNwZWVjaC5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIFRleHQgb2YgdGhlIHNwZWVjaC5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gc3BlZWNobWFya3MgLSBTcGVlY2htYXJrcyBmb3IgdGhlIHNwZWVjaC5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gYXVkaW9Db25maWcgLSBBdWRpbyBmb3IgdGhlIHNwZWVjaC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtBYnN0cmFjdFNwZWVjaH1cclxuICAgKi9cclxuICBfY3JlYXRlU3BlZWNoKHRleHQsIHNwZWVjaG1hcmtzLCBhdWRpb0NvbmZpZykge1xyXG4gICAgcmV0dXJuIG5ldyBTcGVlY2godGhpcywgdGV4dCwgc3BlZWNobWFya3MsIGF1ZGlvQ29uZmlnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBwcmVzaWduZWQgVVJMIG9mIHNwZWVjaCBhdWRpbyBmb3IgdGhlIGdpdmVuIHNwZWVjaCB0ZXh0LlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBQYXJhbWV0ZXJzIG9iamVjdCBjb21wYXRpYmxlIHdpdGggUG9sbHkuc3ludGhlc2l6ZVNwZWVjaC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH0gUmVzb2x2ZXMgd2l0aCBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgYXVkaW8gVVJMLlxyXG4gICAqL1xyXG4gIF9zeW50aGVzaXplQXVkaW8ocGFyYW1zKSB7XHJcbiAgICByZXR1cm4gbmV3IERlZmVycmVkKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5TRVJWSUNFUy5wcmVzaWduZXIuZ2V0U3ludGhlc2l6ZVNwZWVjaFVybChcclxuICAgICAgICBwYXJhbXMsXHJcbiAgICAgICAgZnVuY3Rpb24oZXJyb3IsIHVybCkge1xyXG4gICAgICAgICAgaWYgKCFlcnJvcikge1xyXG4gICAgICAgICAgICByZXNvbHZlKHt1cmx9KTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXRyaWV2ZXMgYW5kIHBhcnNlcyBzcGVlY2htYXJrcyBmb3IgdGhlIGdpdmVuIHNwZWVjaCB0ZXh0LlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBQYXJhbWV0ZXJzIG9iamVjdCBjb21wYXRpYmxlIHdpdGggUG9sbHkuc3ludGhlc2l6ZVNwZWVjaC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH0gUmVzb2x2ZXMgd2l0aCBhbiBhcnJheSBvZiBzcGVlY2htYXJrIG9iamVjdHNcclxuICAgKi9cclxuICBfc3ludGhlc2l6ZVNwZWVjaG1hcmtzKHBhcmFtcykge1xyXG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuU0VSVklDRVMucG9sbHlcclxuICAgICAgLnN5bnRoZXNpemVTcGVlY2gocGFyYW1zKVxyXG4gICAgICAucHJvbWlzZSgpXHJcbiAgICAgIC50aGVuKHJlc3VsdCA9PiB7XHJcbiAgICAgICAgLy8gQ29udmVydCBjaGFyY29kZXMgdG8gc3RyaW5nXHJcbiAgICAgICAgY29uc3QganNvblN0cmluZyA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdC5BdWRpb1N0cmVhbSk7XHJcbiAgICAgICAgY29uc3QganNvbiA9IEpTT04ucGFyc2UoanNvblN0cmluZyk7XHJcbiAgICAgICAgY29uc3QgZGF0YVN0ciA9IGpzb24uZGF0YS5tYXAoYyA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKS5qb2luKCcnKTtcclxuXHJcbiAgICAgICAgY29uc3QgbWFya1R5cGVzID0ge1xyXG4gICAgICAgICAgc2VudGVuY2U6IFtdLFxyXG4gICAgICAgICAgd29yZDogW10sXHJcbiAgICAgICAgICB2aXNlbWU6IFtdLFxyXG4gICAgICAgICAgc3NtbDogW10sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBlbmRNYXJrVHlwZXMgPSB7XHJcbiAgICAgICAgICBzZW50ZW5jZTogbnVsbCxcclxuICAgICAgICAgIHdvcmQ6IG51bGwsXHJcbiAgICAgICAgICB2aXNlbWU6IG51bGwsXHJcbiAgICAgICAgICBzc21sOiBudWxsLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIFNwbGl0IGJ5IGVuY2xvc2luZyB7fSB0byBjcmVhdGUgc3BlZWNobWFyayBvYmplY3RzXHJcbiAgICAgICAgY29uc3Qgc3BlZWNoTWFya3MgPSBbLi4uZGF0YVN0ci5tYXRjaEFsbCgvXFx7Lio/XFx9KD89XFxufCQpL2dtKV0ubWFwKFxyXG4gICAgICAgICAgbWF0Y2ggPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtYXJrID0gSlNPTi5wYXJzZShtYXRjaFswXSk7XHJcblxyXG4gICAgICAgICAgICAvLyBTZXQgdGhlIGR1cmF0aW9uIG9mIHRoZSBsYXN0IHNwZWVjaG1hcmsgc3RvcmVkIG1hdGNoaW5nIHRoaXMgb25lJ3MgdHlwZVxyXG4gICAgICAgICAgICBjb25zdCBudW1NYXJrcyA9IG1hcmtUeXBlc1ttYXJrLnR5cGVdLmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKG51bU1hcmtzID4gMCkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGxhc3RNYXJrID0gbWFya1R5cGVzW21hcmsudHlwZV1bbnVtTWFya3MgLSAxXTtcclxuICAgICAgICAgICAgICBsYXN0TWFyay5kdXJhdGlvbiA9IG1hcmsudGltZSAtIGxhc3RNYXJrLnRpbWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG1hcmtUeXBlc1ttYXJrLnR5cGVdLnB1c2gobWFyayk7XHJcbiAgICAgICAgICAgIGVuZE1hcmtUeXBlc1ttYXJrLnR5cGVdID0gbWFyaztcclxuICAgICAgICAgICAgcmV0dXJuIG1hcms7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gRmluZCB0aGUgdGltZSBvZiB0aGUgbGF0ZXN0IHNwZWVjaG1hcmtcclxuICAgICAgICBjb25zdCBlbmRUaW1lcyA9IFtdO1xyXG4gICAgICAgIGlmIChlbmRNYXJrVHlwZXMuc2VudGVuY2UpIHtcclxuICAgICAgICAgIGVuZFRpbWVzLnB1c2goZW5kTWFya1R5cGVzLnNlbnRlbmNlLnRpbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW5kTWFya1R5cGVzLndvcmQpIHtcclxuICAgICAgICAgIGVuZFRpbWVzLnB1c2goZW5kTWFya1R5cGVzLndvcmQudGltZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbmRNYXJrVHlwZXMudmlzZW1lKSB7XHJcbiAgICAgICAgICBlbmRUaW1lcy5wdXNoKGVuZE1hcmtUeXBlcy52aXNlbWUudGltZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbmRNYXJrVHlwZXMuc3NtbCkge1xyXG4gICAgICAgICAgZW5kVGltZXMucHVzaChlbmRNYXJrVHlwZXMuc3NtbC50aW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZW5kVGltZSA9IE1hdGgubWF4KC4uLmVuZFRpbWVzKTtcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGR1cmF0aW9uIGZvciB0aGUgZW5kaW5nIHNwZWVjaE1hcmtzIG9mIGVhY2ggdHlwZVxyXG4gICAgICAgIGlmIChlbmRNYXJrVHlwZXMuc2VudGVuY2UpIHtcclxuICAgICAgICAgIGVuZE1hcmtUeXBlcy5zZW50ZW5jZS5kdXJhdGlvbiA9IE1hdGgubWF4KFxyXG4gICAgICAgICAgICB0aGlzLl9taW5FbmRNYXJrRHVyYXRpb24sXHJcbiAgICAgICAgICAgIGVuZFRpbWUgLSBlbmRNYXJrVHlwZXMuc2VudGVuY2UudGltZVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVuZE1hcmtUeXBlcy53b3JkKSB7XHJcbiAgICAgICAgICBlbmRNYXJrVHlwZXMud29yZC5kdXJhdGlvbiA9IE1hdGgubWF4KFxyXG4gICAgICAgICAgICB0aGlzLl9taW5FbmRNYXJrRHVyYXRpb24sXHJcbiAgICAgICAgICAgIGVuZFRpbWUgLSBlbmRNYXJrVHlwZXMud29yZC50aW1lXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW5kTWFya1R5cGVzLnZpc2VtZSkge1xyXG4gICAgICAgICAgZW5kTWFya1R5cGVzLnZpc2VtZS5kdXJhdGlvbiA9IE1hdGgubWF4KFxyXG4gICAgICAgICAgICB0aGlzLl9taW5FbmRNYXJrRHVyYXRpb24sXHJcbiAgICAgICAgICAgIGVuZFRpbWUgLSBlbmRNYXJrVHlwZXMudmlzZW1lLnRpbWVcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbmRNYXJrVHlwZXMuc3NtbCkge1xyXG4gICAgICAgICAgZW5kTWFya1R5cGVzLnNzbWwuZHVyYXRpb24gPSBNYXRoLm1heChcclxuICAgICAgICAgICAgdGhpcy5fbWluRW5kTWFya0R1cmF0aW9uLFxyXG4gICAgICAgICAgICBlbmRUaW1lIC0gZW5kTWFya1R5cGVzLnNzbWwudGltZVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzcGVlY2hNYXJrcztcclxuICAgICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGEgU3BlZWNoIG9iamVjdCB0aGF0IGhhcyB0aGUgZ2l2ZW4gdGV4dC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIFRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIFNwZWVjaC5cclxuICAgKiBAcGFyYW0ge09iamVjdD19IGNvbmZpZyAtIE9wdGlvbnMgdG8gdXBkYXRlIHRoZSBTcGVlY2ggd2l0aC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH0gUmVzb2x2ZXMgd2l0aCBTcGVlY2ggb3IgbnVsbDtcclxuICAgKi9cclxuICBfZ2V0U3BlZWNoKHRleHQsIGNvbmZpZykge1xyXG4gICAgLy8gTWFrZSBzdXJlIEFXUyBzZXJ2aWNlcyBleGlzdFxyXG4gICAgaWYgKCF0aGlzLmNvbnN0cnVjdG9yLmlzUmVhZHkpIHtcclxuICAgICAgY29uc3QgZSA9ICdBV1Mgc2VydmljZXMgaGF2ZSBub3QgYmVlbiBpbml0aWFsaXplZC4nO1xyXG4gICAgICByZXR1cm4gRGVmZXJyZWQucmVqZWN0KGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE1ha2Ugc3VyZSBpdHMgcG9zc2libGUgdG8gZ2VuZXJhdGUgc3BlZWNoZXNcclxuICAgIGlmICghdGV4dCkge1xyXG4gICAgICBjb25zdCBlID0gJ0Nhbm5vdCBwbGF5IGEgc3BlZWNoIHdpdGggbm8gdGV4dC4nO1xyXG4gICAgICByZXR1cm4gRGVmZXJyZWQucmVqZWN0KGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFVwZGF0ZSB0aGUgc3BlZWNoIHdpdGggb3B0aW9uc1xyXG4gICAgdGV4dCA9IFRleHRUb1NwZWVjaFV0aWxzLnZhbGlkYXRlVGV4dCh0ZXh0KTtcclxuICAgIGNvbmZpZyA9IHRoaXMuX3VwZGF0ZUNvbmZpZyhjb25maWcsIHRleHQpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLl91cGRhdGVTcGVlY2godGV4dCwgY29uZmlnKS5wcm9taXNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBhIG5hbWVzcGFjZSB0byB0aGUgaG9zdCB3aXRoIHRoZSBuYW1lIG9mIHRoZSBmZWF0dXJlIHRvIGNvbnRhaW4gcHJvcGVydGllc1xyXG4gICAqIGFuZCBtZXRob2RzIGZyb20gdGhlIGZlYXR1cmUgdGhhdCB1c2VycyBvZiB0aGUgaG9zdCBuZWVkIGFjY2VzcyB0by5cclxuICAgKlxyXG4gICAqIEBzZWUgVGV4dFRvU3BlZWNoRmVhdHVyZVxyXG4gICAqL1xyXG4gIGluc3RhbGxBcGkoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEBpbm5lclxyXG4gICAgICogQG5hbWVzcGFjZSBUZXh0VG9TcGVlY2hGZWF0dXJlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGFwaSA9IHN1cGVyLmluc3RhbGxBcGkoKTtcclxuXHJcbiAgICBPYmplY3QuYXNzaWduKGFwaSwge1xyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIFRleHRUb1NwZWVjaEZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBtZXRob2RcclxuICAgICAgICogQHNlZSBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUjcGxheVxyXG4gICAgICAgKi9cclxuICAgICAgcGxheTogdGhpcy5wbGF5LmJpbmQodGhpcyksXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbWVtYmVyb2YgVGV4dFRvU3BlZWNoRmVhdHVyZVxyXG4gICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgKiBAc2VlIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSNwYXVzZVxyXG4gICAgICAgKi9cclxuICAgICAgcGF1c2U6IHRoaXMucGF1c2UuYmluZCh0aGlzKSxcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBtZW1iZXJvZiBUZXh0VG9TcGVlY2hGZWF0dXJlXHJcbiAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAqIEBzZWUgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlI3Jlc3VtZVxyXG4gICAgICAgKi9cclxuICAgICAgcmVzdW1lOiB0aGlzLnJlc3VtZS5iaW5kKHRoaXMpLFxyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIFRleHRUb1NwZWVjaEZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBtZXRob2RcclxuICAgICAgICogQHNlZSBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUjc3RvcFxyXG4gICAgICAgKi9cclxuICAgICAgc3RvcDogdGhpcy5zdG9wLmJpbmQodGhpcyksXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbWVtYmVyb2YgVGV4dFRvU3BlZWNoRmVhdHVyZVxyXG4gICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgKiBAc2VlIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSNnZXRWb2x1bWVcclxuICAgICAgICovXHJcbiAgICAgIGdldFZvbHVtZTogdGhpcy5nZXRWb2x1bWUuYmluZCh0aGlzKSxcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBtZW1iZXJvZiBUZXh0VG9TcGVlY2hGZWF0dXJlXHJcbiAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAqIEBzZWUgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlI3NldFZvbHVtZVxyXG4gICAgICAgKi9cclxuICAgICAgc2V0Vm9sdW1lOiB0aGlzLnNldFZvbHVtZS5iaW5kKHRoaXMpLFxyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIFRleHRUb1NwZWVjaEZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBtZXRob2RcclxuICAgICAgICogQHNlZSBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUjcGF1c2VWb2x1bWVcclxuICAgICAgICovXHJcbiAgICAgIHBhdXNlVm9sdW1lOiB0aGlzLnBhdXNlVm9sdW1lLmJpbmQodGhpcyksXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbWVtYmVyb2YgVGV4dFRvU3BlZWNoRmVhdHVyZVxyXG4gICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgKiBAc2VlIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSNyZXN1bWVWb2x1bWVcclxuICAgICAgICovXHJcbiAgICAgIHJlc3VtZVZvbHVtZTogdGhpcy5yZXN1bWVWb2x1bWUuYmluZCh0aGlzKSxcclxuICAgIH0pO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGFwaSwge1xyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIFRleHRUb1NwZWVjaEZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBzZWUgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlI3NwZWVjaG1hcmtPZmZzZXRcclxuICAgICAgICovXHJcbiAgICAgIHNwZWVjaG1hcmtPZmZzZXQ6IHtcclxuICAgICAgICBnZXQ6ICgpID0+IHRoaXMuc3BlZWNobWFya09mZnNldCxcclxuICAgICAgICBzZXQ6IG9mZnNldCA9PiB7XHJcbiAgICAgICAgICB0aGlzLnNwZWVjaG1hcmtPZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBhcGk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIGFuZCBzZXRzIHRoZSB2b2x1bWUgdXNlZCBmb3IgYWxsIGF1ZGlvIGNsaXBzIHBsYXllZCBieSB0aGUgc3BlYWtlci5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgc2V0IHZvbHVtZSh2b2x1bWUpIHtcclxuICAgIHRoaXMuX3ZvbHVtZSA9IE1hdGhVdGlscy5jbGFtcCh2b2x1bWUpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHZvbHVtZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl92b2x1bWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHdoZXRoZXIgb3Igbm90IHRoZSBzcGVha2VyJ3Mgdm9sdW1lIHZhbHVlIGlzIGN1cnJlbnRseSBiZWluZyB0d2VlbmVkLlxyXG4gICAqXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgZ2V0IHZvbHVtZVBlbmRpbmcoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZXMudm9sdW1lICYmIHRoaXMuX3Byb21pc2VzLnZvbHVtZS5wZW5kaW5nO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgdm9sdW1lIHVzZWQgZm9yIGFsbCBhdWRpbyBjbGlwcyBwbGF5ZWQgYnkgdGhlIHNwZWFrZXIuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldFZvbHVtZSgpIHtcclxuICAgIHJldHVybiB0aGlzLnZvbHVtZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgdGhlIHZvbHVtZSB1c2VkIGZvciBhbGwgYXVkaW8gY2xpcHMgcGxheWVkIGJ5IHRoZSBzcGVha2VyIG92ZXIgdGltZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2b2x1bWUgLSBUYXJnZXQgdm9sdW1lIHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2Vjb25kcz0wXSAtIEFtb3VudCBvZiB0aW1lIGl0IHdpbGwgdGFrZSB0byByZWFjaCB0aGUgdGFyZ2V0XHJcbiAgICogdm9sdW1lLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBlYXNpbmdGbiAtIEVhc2luZyBmdW5jdGlvbiB1c2VkIGZvciBpbnRlcnBvbGF0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0RlZmVycmVkfVxyXG4gICAqL1xyXG4gIHNldFZvbHVtZSh2b2x1bWUsIHNlY29uZHMgPSAwLCBlYXNpbmdGbikge1xyXG4gICAgaWYgKHRoaXMudm9sdW1lUGVuZGluZykge1xyXG4gICAgICB0aGlzLl9wcm9taXNlcy52b2x1bWUuY2FuY2VsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdm9sdW1lID0gTWF0aFV0aWxzLmNsYW1wKHZvbHVtZSk7XHJcbiAgICB0aGlzLl9wcm9taXNlcy52b2x1bWUgPSBBbmltYXRpb25VdGlscy5pbnRlcnBvbGF0ZVByb3BlcnR5KFxyXG4gICAgICB0aGlzLFxyXG4gICAgICAndm9sdW1lJyxcclxuICAgICAgdm9sdW1lLFxyXG4gICAgICB7c2Vjb25kcywgZWFzaW5nRm59XHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiB0aGlzLl9wcm9taXNlcy52b2x1bWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYXVzZSBpbnRlcnBvbGF0aW9uIGhhcHBlbmluZyBvbiB0aGUgc3BlYWtlcidzIHZvbHVtZSBwcm9wZXJ0eS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xyXG4gIHBhdXNlVm9sdW1lKCkge1xyXG4gICAgdGhpcy5fdm9sdW1lUGF1c2VkID0gdHJ1ZTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy52b2x1bWVQZW5kaW5nO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzdW1lIGFueSBpbnRlcnBvbGF0aW9uIGhhcHBlbmluZyBvbiB0aGUgc3BlYWtlcidzIHZvbHVtZSBwcm9wZXJ0eS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xyXG4gIHJlc3VtZVZvbHVtZSgpIHtcclxuICAgIHRoaXMuX3ZvbHVtZVBhdXNlZCA9IGZhbHNlO1xyXG5cclxuICAgIHJldHVybiB0aGlzLnZvbHVtZVBlbmRpbmc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgdGhlIGN1cnJlbnRseSBwbGF5aW5nIHNwZWVjaC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVRpbWUgLSBUaW1lIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZS5cclxuICAgKi9cclxuICB1cGRhdGUoZGVsdGFUaW1lKSB7XHJcbiAgICBpZiAoIXRoaXMuX3ZvbHVtZVBhdXNlZCkge1xyXG4gICAgICB0aGlzLl9wcm9taXNlcy52b2x1bWUuZXhlY3V0ZShkZWx0YVRpbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9jdXJyZW50U3BlZWNoICYmIHRoaXMuX2N1cnJlbnRTcGVlY2gucGxheWluZykge1xyXG4gICAgICB0aGlzLl9jdXJyZW50U3BlZWNoLnZvbHVtZSA9IHRoaXMuX3ZvbHVtZTtcclxuICAgICAgdGhpcy5fY3VycmVudFNwZWVjaC51cGRhdGUodGhpcy5faG9zdC5ub3cpO1xyXG4gICAgICBzdXBlci51cGRhdGUoZGVsdGFUaW1lKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgY3VycmVudCBzcGVlY2ggdG8gYSBuZXcgYXNzZXQgYW5kIHVwZGF0ZSB0aGUgc3BlZWNoJ3Mgc3BlZWNobWFya1xyXG4gICAqIG9mZnNldCB2YWx1ZSB0byBtYXRjaCB0aGF0IG9mIHRoZSBmZWF0dXJlLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RTcGVlY2h9IHNwZWVjaCAtIFNwZWVjaCB0byBzZXQgYXMgY3VycmVudC5cclxuICAgKi9cclxuICBfc2V0Q3VycmVudFNwZWVjaChzcGVlY2gpIHtcclxuICAgIHNwZWVjaC5zcGVlY2htYXJrT2Zmc2V0ID0gdGhpcy5fc3BlZWNobWFya09mZnNldDtcclxuICAgIHRoaXMuX2N1cnJlbnRTcGVlY2ggPSBzcGVlY2g7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgYSBwcm9taXNlIHRoYXQgd2lsbCBwbGF5L3Jlc3VtZSBhIHNwZWVjaCB3aXRoIHRoZSBnaXZlbiB0ZXh0IGFmdGVyXHJcbiAgICogdGhlIGF1ZGlvIGNvbnRleHQgYXR0ZW1wdHMgdG8gcmVzdW1lIGFuZCBzcGVlY2ggYXVkaW8gaXMgcmV0cmlldmVkIGZyb20gUG9sbHkuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCBvZiB0aGUgbmV3IHNwZWVjaCB0byBwbGF5LlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gY29uZmlnIC0gT3B0aW9uYWwgcGFyYW1ldGVycyBmb3IgdGhlIHNwZWVjaC5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3BsYXlNZXRob2QgPSAncGxheSddIC0gTWV0aG9kIHRvIGV4ZWN1dGUgb24gdGhlIHJlc3VsdGluZ1xyXG4gICAqIFNwZWVjaCBvYmplY3QuIFZhbGlkIG9wdGlvbnMgYXJlICdwbGF5JyBhbmQgJ3Jlc3VtZScuXHJcbiAgICovXHJcbiAgX3N0YXJ0U3BlZWNoKHRleHQsIGNvbmZpZywgcGxheU1ldGhvZCA9ICdwbGF5Jykge1xyXG4gICAgLy8gSWYgbm8gdGV4dCBpcyBwcm92aWRlZCwgdHJ5IHRvIHVzZSB0aGUgY3VycmVudCBzcGVlY2hcclxuICAgIGlmICh0ZXh0ID09PSB1bmRlZmluZWQgJiYgcGxheU1ldGhvZCA9PT0gJ3Jlc3VtZScgJiYgdGhpcy5fY3VycmVudFNwZWVjaCkge1xyXG4gICAgICB0ZXh0ID0gdGhpcy5fY3VycmVudFNwZWVjaC50ZXh0O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGN1cnJlbnRQcm9taXNlID0gdGhpcy5fY3VycmVudFByb21pc2UgfHwge1xyXG4gICAgICBwbGF5OiBuZXcgRGVmZXJyZWQoXHJcbiAgICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICAgICgpID0+IHtcclxuICAgICAgICAgIGN1cnJlbnRQcm9taXNlLnNwZWVjaC5jYW5jZWwoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgICgpID0+IHtcclxuICAgICAgICAgIGN1cnJlbnRQcm9taXNlLnNwZWVjaC5jYW5jZWwoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgICgpID0+IHtcclxuICAgICAgICAgIGN1cnJlbnRQcm9taXNlLnNwZWVjaC5jYW5jZWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICksXHJcbiAgICAgIHNwZWVjaDogbmV3IERlZmVycmVkKCksXHJcbiAgICB9O1xyXG4gICAgdGhpcy5fY3VycmVudFByb21pc2UgPSBjdXJyZW50UHJvbWlzZTtcclxuXHJcbiAgICB0aGlzLl9nZXRTcGVlY2godGV4dCwgY29uZmlnKVxyXG4gICAgICAudGhlbihzcGVlY2ggPT4ge1xyXG4gICAgICAgIC8vIEV4aXQgaWYgdGhlIHByb21pc2UgaXMgbm8gbG9uZ2VyIHBlbmRpbmcgYmVjYXVzZSBvZiB1c2VyIGludGVyYWN0aW9uXHJcbiAgICAgICAgaWYgKCFjdXJyZW50UHJvbWlzZS5wbGF5LnBlbmRpbmcpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2N1cnJlbnRQcm9taXNlICE9PSBjdXJyZW50UHJvbWlzZSkge1xyXG4gICAgICAgICAgLy8gQ2FuY2VsIGlmIGFub3RoZXIgY2FsbCB0byBwbGF5IGhhcyBhbHJlYWR5IGJlZW4gbWFkZVxyXG4gICAgICAgICAgY3VycmVudFByb21pc2UucGxheS5jYW5jZWwoKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlc2V0IGN1cnJlbnQgc3BlZWNoIHdoZW4gdGhlIHNwZWVjaCBlbmRzXHJcbiAgICAgICAgY29uc3Qgb25GaW5pc2ggPSAoKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLl9jdXJyZW50U3BlZWNoID0gbnVsbDtcclxuICAgICAgICAgIHRoaXMuX2N1cnJlbnRQcm9taXNlID0gbnVsbDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBDYW5jZWwgdGhlIGN1cnJlbnRseSBwbGF5aW5nIHNwZWVjaFxyXG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50U3BlZWNoICYmIHRoaXMuX2N1cnJlbnRTcGVlY2gucGxheWluZykge1xyXG4gICAgICAgICAgaWYgKHBsYXlNZXRob2QgPT09ICdwbGF5Jykge1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50U3BlZWNoLmNhbmNlbCgpO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChcclxuICAgICAgICAgICAgcGxheU1ldGhvZCA9PT0gJ3Jlc3VtZScgJiZcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudFNwZWVjaC5hdWRpbyAhPT0gc3BlZWNoLmF1ZGlvXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudFNwZWVjaC5jYW5jZWwoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX3NldEN1cnJlbnRTcGVlY2goc3BlZWNoKTtcclxuXHJcbiAgICAgICAgLy8gUGxheSB0aGUgc3BlZWNoXHJcbiAgICAgICAgY3VycmVudFByb21pc2Uuc3BlZWNoID0gc3BlZWNoW3BsYXlNZXRob2RdKFxyXG4gICAgICAgICAgdGhpcy5faG9zdC5ub3csXHJcbiAgICAgICAgICBvbkZpbmlzaCxcclxuICAgICAgICAgIG9uRmluaXNoLFxyXG4gICAgICAgICAgb25GaW5pc2hcclxuICAgICAgICApO1xyXG4gICAgICAgIGN1cnJlbnRQcm9taXNlLnNwZWVjaFxyXG4gICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudFByb21pc2Uuc3BlZWNoLnJlc29sdmVkKSB7XHJcbiAgICAgICAgICAgICAgY3VycmVudFByb21pc2UucGxheS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgY3VycmVudFByb21pc2UucGxheS5jYW5jZWwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSlcclxuICAgICAgICAgIC5jYXRjaChlcnJvciA9PiB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRQcm9taXNlLnBsYXkucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICB9KVxyXG4gICAgICAuY2F0Y2goZSA9PiB7XHJcbiAgICAgICAgZSA9IGBDYW5ub3QgJHtwbGF5TWV0aG9kfSBzcGVlY2ggJHt0ZXh0fSBvbiBob3N0ICR7dGhpcy5ob3N0LmlkfS4gJHtlfWA7XHJcbiAgICAgICAgY3VycmVudFByb21pc2UucGxheS5yZWplY3QoZSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBjdXJyZW50UHJvbWlzZS5wbGF5O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RvcCBhbnkgc3BlZWNoZXMgY3VycmVudGx5IHBsYXlpbmcgYW5kIHBsYXkgYSBuZXcgc3BlZWNoIGZyb20gdGhlIGJlZ2lubmluZy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgb2YgdGhlIG5ldyBzcGVlY2ggdG8gcGxheS5cclxuICAgKiBAcGFyYW0ge09iamVjdD19IGNvbmZpZyAtIE9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHRoZSBzcGVlY2guXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9XHJcbiAgICovXHJcbiAgcGxheSh0ZXh0LCBjb25maWcpIHtcclxuICAgIHJldHVybiB0aGlzLl9zdGFydFNwZWVjaCh0ZXh0LCBjb25maWcsICdwbGF5Jyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJZiBhIHNwZWVjaCBpcyBjdXJyZW50bHkgcGxheWluZywgcGF1c2UgaXQgYXQgdGhlIGN1cnJlbnQgdGltZS5cclxuICAgKi9cclxuICBwYXVzZSgpIHtcclxuICAgIGlmICh0aGlzLl9jdXJyZW50U3BlZWNoICYmIHRoaXMuX2N1cnJlbnRTcGVlY2gucGxheWluZykge1xyXG4gICAgICB0aGlzLl9jdXJyZW50U3BlZWNoLnBhdXNlKHRoaXMuX2hvc3Qubm93KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICBgQ2Fubm90IHBhdXNlIHNwZWVjaCBvbiBob3N0ICR7dGhpcy5ob3N0LmlkfS4gTm8gc3BlZWNoIGlzIGN1cnJlbnRseSBwbGF5aW5nYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RvcCBhbnkgc3BlZWNoZXMgY3VycmVudGx5IHBsYXlpbmcgYW5kIHJlc3VtZSBhIG5ldyBzcGVlY2ggZnJvbSB0aGUgY3VycmVudFxyXG4gICAqIHRpbWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZz19IHRleHQgLSBUaGUgdGV4dCBvZiB0aGUgbmV3IHNwZWVjaCB0byBwbGF5LiBJZiB1bmRlZmluZWQgYW5kXHJcbiAgICogdGhlcmUgaXMgYSBjdXJyZW50IHNwZWVjaCB0aGF0IGlzIHBhdXNlZCwgdGhlIGN1cnJlbnQgc3BlZWNoIHdpbGwgYmUgcmVzdW1lZC5cclxuICAgKiBAcGFyYW0ge09iamVjdD19IGNvbmZpZyAtIE9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHRoZSBzcGVlY2guXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9XHJcbiAgICovXHJcbiAgcmVzdW1lKHRleHQsIGNvbmZpZykge1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0U3BlZWNoKHRleHQsIGNvbmZpZywgJ3Jlc3VtZScpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSWYgYSBzcGVlY2ggaXMgY3VycmVudGx5IHBsYXlpbmcsIHN0b3AgcGxheWJhY2sgYW5kIHJlc2V0IHRpbWUuXHJcbiAgICovXHJcbiAgc3RvcCgpIHtcclxuICAgIGlmICh0aGlzLl9jdXJyZW50U3BlZWNoICYmIHRoaXMuX2N1cnJlbnRTcGVlY2gucGxheWluZykge1xyXG4gICAgICB0aGlzLl9jdXJyZW50U3BlZWNoLnN0b3AoKTtcclxuICAgICAgdGhpcy5fY3VycmVudFNwZWVjaCA9IG51bGw7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgYENhbm5vdCBzdG9wIHNwZWVjaCBvbiBob3N0ICR7dGhpcy5ob3N0LmlkfS4gTm8gc3BlZWNoIGlzIGN1cnJlbnRseSBwbGF5aW5nLmBcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGRpc2NhcmQoKSB7XHJcbiAgICBpZiAodGhpcy5fY3VycmVudFNwZWVjaCAmJiB0aGlzLl9jdXJyZW50U3BlZWNoLnBsYXlpbmcpIHtcclxuICAgICAgdGhpcy5fY3VycmVudFNwZWVjaC5zdG9wKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVsZXRlIHRoaXMuX3NwZWVjaENhY2hlO1xyXG5cclxuICAgIHN1cGVyLmRpc2NhcmQoKTtcclxuICB9XHJcbn1cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSwge1xyXG4gIEFXU19WRVJTSU9OOiB7XHJcbiAgICBnZXQ6ICgpID0+IGF3c1ZlcnNpb24sXHJcbiAgfSxcclxuICBQT0xMWV9NSU5fTkVVUkFMX1ZFUlNJT046IHtcclxuICAgIHZhbHVlOiAnMi41MDMnLFxyXG4gICAgd3JpdGFibGU6IGZhbHNlLFxyXG4gIH0sXHJcbiAgUE9MTFlfREVGQVVMVFM6IHtcclxuICAgIHZhbHVlOiB7XHJcbiAgICAgIEVuZ2luZTogJ3N0YW5kYXJkJyxcclxuICAgICAgTGV4aWNvbk5hbWVzOiBbXSxcclxuICAgICAgT3V0cHV0Rm9ybWF0OiAnbXAzJyxcclxuICAgICAgU2FtcGxlUmF0ZTogJzIyMDUwJyxcclxuICAgICAgVGV4dDogJycsXHJcbiAgICAgIFRleHRUeXBlOiAnc3NtbCcsXHJcbiAgICAgIFZvaWNlSWQ6ICdBbXknLFxyXG4gICAgICBMYW5ndWFnZUNvZGU6ICdlbi1HQicsXHJcbiAgICAgIExhbmd1YWdlTmFtZTogJ0JyaXRpc2ggRW5nbGlzaCcsXHJcbiAgICB9LFxyXG4gICAgd3JpdGFibGU6IGZhbHNlLFxyXG4gIH0sXHJcbiAgUE9MTFlfVk9JQ0VTOiB7XHJcbiAgICB2YWx1ZTogW10sXHJcbiAgICB3cml0YWJsZTogZmFsc2UsXHJcbiAgfSxcclxuICBQT0xMWV9MQU5HVUFHRVM6IHtcclxuICAgIHZhbHVlOiB7fSxcclxuICAgIHdyaXRhYmxlOiBmYWxzZSxcclxuICB9LFxyXG4gIFBPTExZX0xBTkdVQUdFX0NPREVTOiB7XHJcbiAgICB2YWx1ZToge30sXHJcbiAgICB3cml0YWJsZTogZmFsc2UsXHJcbiAgfSxcclxuICBfaXNSZWFkeToge1xyXG4gICAgdmFsdWU6IGZhbHNlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgfSxcclxuICBFVkVOVFM6IHtcclxuICAgIHZhbHVlOiB7XHJcbiAgICAgIC4uLk9iamVjdC5nZXRQcm90b3R5cGVPZihBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUpLkVWRU5UUyxcclxuICAgICAgcmVhZHk6ICdvblJlYWR5RXZlbnQnLFxyXG4gICAgICBwbGF5OiAnb25QbGF5RXZlbnQnLFxyXG4gICAgICBwYXVzZTogJ29uUGF1c2VFdmVudCcsXHJcbiAgICAgIHJlc3VtZTogJ29uUmVzdW1lRXZlbnQnLFxyXG4gICAgICBpbnRlcnJ1cHQ6ICdvbkludGVycnVwdEV2ZW50JyxcclxuICAgICAgc3RvcDogJ29uU3RvcEV2ZW50JyxcclxuICAgICAgc2VudGVuY2U6ICdvblNlbnRlbmNlRXZlbnQnLFxyXG4gICAgICB3b3JkOiAnb25Xb3JkRXZlbnQnLFxyXG4gICAgICB2aXNlbWU6ICdvblZpc2VtZUV2ZW50JyxcclxuICAgICAgc3NtbDogJ29uU3NtbEV2ZW50JyxcclxuICAgIH0sXHJcbiAgfSxcclxuICBTRVJWSUNFUzoge1xyXG4gICAgdmFsdWU6IHtcclxuICAgICAgLi4uT2JqZWN0LmdldFByb3RvdHlwZU9mKEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSkuU0VSVklDRVMsXHJcbiAgICAgIHBvbGx5OiB1bmRlZmluZWQsXHJcbiAgICAgIHByZXNpZ25lcjogdW5kZWZpbmVkLFxyXG4gICAgfSxcclxuICB9LFxyXG59KTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZTsiLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXHJcbmltcG9ydCBTcGVlY2ggZnJvbSAnLi9TcGVlY2gnO1xyXG5pbXBvcnQgRGVmZXJyZWQgZnJvbSAnLi4vRGVmZXJyZWQnO1xyXG5pbXBvcnQgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlIGZyb20gJy4vQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlJztcclxuXHJcbi8qKlxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmVcclxuICogQGFsaWFzIGNvcmUvVGV4dFRvU3BlZWNoRmVhdHVyZVxyXG4gKi9cclxuY2xhc3MgVGV4dFRvU3BlZWNoRmVhdHVyZSBleHRlbmRzIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSB7XHJcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xyXG4gICAgc3VwZXIoLi4uYXJncyk7XHJcblxyXG4gICAgdGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5fc2V0QXVkaW9Db250ZXh0KCk7XHJcbiAgICB0aGlzLl9vYnNlcnZlQXVkaW9Db250ZXh0KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdG9yZSB0aGUgYXVkaW8gY29udGV4dCB0aGF0IHdpbGwgYmUgdXNlZCB0byBlbnN1cmUgYXVkaW8gY2FuIGJlIHBsYXllZC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX3NldEF1ZGlvQ29udGV4dCgpIHtcclxuICAgIHRoaXMuX2F1ZGlvQ29udGV4dCA9IG5ldyBBdWRpb0NvbnRleHQoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExpc3RlbiBmb3Igc3RhdGUgY2hhbmdlcyBvbiB0aGUgYXVkaW8gY29udGV4dCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgZmVhdHVyZVxyXG4gICAqIGlzIGVuYWJsZWQuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9vYnNlcnZlQXVkaW9Db250ZXh0KCkge1xyXG4gICAgaWYgKHRoaXMuX2F1ZGlvQ29udGV4dCkge1xyXG4gICAgICB0aGlzLl9hdWRpb0NvbnRleHQub25zdGF0ZWNoYW5nZSA9ICgpID0+IHtcclxuICAgICAgICBpZiAodGhpcy5fYXVkaW9Db250ZXh0LnN0YXRlID09PSAncnVubmluZycpIHtcclxuICAgICAgICAgIHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLl9lbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgICAgICdUaGUgYXVkaW8gY29udGV4dCBpcyBub3QgcnVubmluZy4gU3BlZWNoIHdpbGwgbm90IGJlIGFibGUgdG8gYmUgcGxheWVkIHVudGlsIGl0IGlzIHJlc3VtZWQuIFVzZSB0aGUgXCJUZXh0VG9TcGVlY2hGZWF0dXJlLnJlc3VtZUF1ZGlvXCIgbWV0aG9kIHRvIHRyeSB0byByZXN1bWUgaXQgYWZ0ZXIgYSB1c2VyIGdlc3R1cmUuJ1xyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0aGlzLl9hdWRpb0NvbnRleHQub25zdGF0ZWNoYW5nZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGFuIEF1ZGlvIG9iamVjdCBvZiBzcGVlY2ggYXVkaW8gZm9yIHRoZSBnaXZlbiBzcGVlY2ggdGV4dC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gUGFyYW1ldGVycyBvYmplY3QgY29tcGF0aWJsZSB3aXRoIFBvbGx5LnN5bnRoZXNpemVTcGVlY2guXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gUmVzb2x2ZXMgd2l0aCBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgYXVkaW8gVVJMIGFuZCBBdWRpb1xyXG4gICAqIG9iamVjdC5cclxuICAgKi9cclxuICBfc3ludGhlc2l6ZUF1ZGlvKHBhcmFtcykge1xyXG4gICAgcmV0dXJuIHN1cGVyLl9zeW50aGVzaXplQXVkaW8ocGFyYW1zKS50aGVuKHJlc3VsdCA9PiB7XHJcbiAgICAgIGNvbnN0IHt1cmx9ID0gcmVzdWx0O1xyXG5cclxuICAgICAgLy8gQ3JlYXRlIGFuIEF1ZGlvIG9iamVjdCB0aGF0IHBvaW50cyB0byB0aGUgcHJlc2lnbmVkIHVybFxyXG4gICAgICBjb25zdCBhdWRpbyA9IG5ldyBBdWRpbyh1cmwpO1xyXG4gICAgICBhdWRpby5sb29wID0gdGhpcy5sb29wO1xyXG4gICAgICBhdWRpby5jcm9zc09yaWdpbiA9ICdhbm9ueW1vdXMnO1xyXG4gICAgICBhdWRpby5wcmVsb2FkID0gJ2F1dG8nO1xyXG4gICAgICByZXN1bHQuYXVkaW8gPSBhdWRpbztcclxuXHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgICAgICAvLyBSZXNvbHZlIG9uY2UgdGhlIG1pbmltdW0gYW1vdW50IGlzIGxvYWRlZFxyXG4gICAgICAgIGF1ZGlvLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnBsYXl0aHJvdWdoJywgKCkgPT4ge1xyXG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBTdGFydCBsb2FkaW5nIHRoZSBhdWRpb1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYXVkaW8pO1xyXG4gICAgICAgIGF1ZGlvLmxvYWQoKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBTcGVlY2ggb2JqZWN0IGZvciB0aGUgc3BlYWtlci5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1RleHRUb1NwZWVjaH0gc3BlYWtlciAtIFRoZSBUZXh0VG9TcGVlY2ggaW5zdGFuY2UgdGhhdCB3aWxsIG93biB0aGUgc3BlZWNoLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gVGV4dCBvZiB0aGUgc3BlZWNoLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzcGVlY2htYXJrcyAtIFNwZWVjaG1hcmtzIGZvciB0aGUgc3BlZWNoLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhdWRpb0NvbmZpZyAtIEF1ZGlvIGZvciB0aGUgc3BlZWNoLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0Fic3RyYWN0U3BlZWNofVxyXG4gICAqL1xyXG4gIF9jcmVhdGVTcGVlY2godGV4dCwgc3BlZWNobWFya3MsIGF1ZGlvQ29uZmlnKSB7XHJcbiAgICByZXR1cm4gbmV3IFNwZWVjaCh0aGlzLCB0ZXh0LCBzcGVlY2htYXJrcywgYXVkaW9Db25maWcpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgYXVkaW8gY29udGV4dCBpcyBydW5uaW5nIGFuZCBzcGVlY2ggY2FuIGJlIHBsYXllZC5cclxuICAgKlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGdldCBlbmFibGVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUcnkgdG8gcmVzdW1lIHRoZSBhdWRpbyBjb250ZXh0LiBUaGlzIHdpbGwgYmUgYXV0b21hdGljYWxseSBleGVjdXRlZCBlYWNoIHRpbWVcclxuICAgKiBzcGVlY2ggaXMgcGxheWVkIG9yIHJlc3VtZWQuIElmIHVzaW5nIG1hbnVhbGx5LCBpdCBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIGFcclxuICAgKiB1c2VyIGludGVyYWN0aW9uIG9jY3Vycy5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH0gLSBSZXNvbHZlcyBvbmNlIHRoZSBhdWRpbyBjb250ZXh0IGhhcyByZXN1bWVkLlxyXG4gICAqL1xyXG4gIHJlc3VtZUF1ZGlvKCkge1xyXG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBEZWZlcnJlZCgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIHRoaXMuX2F1ZGlvQ29udGV4dFxyXG4gICAgICAgIC5yZXN1bWUoKVxyXG4gICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgIHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmNhdGNoKGUgPT4ge1xyXG4gICAgICAgICAgdGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcHJvbWlzZTtcclxuICB9XHJcblxyXG4gIF9zdGFydFNwZWVjaCh0ZXh0LCBjb25maWcsIHBsYXlNZXRob2QgPSAncGxheScpIHtcclxuICAgIGNvbnN0IGN1cnJlbnRQcm9taXNlID0ge1xyXG4gICAgICBwbGF5OiBuZXcgRGVmZXJyZWQoXHJcbiAgICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICAgICgpID0+IHsgY3VycmVudFByb21pc2Uuc3BlZWNoLmNhbmNlbCgpOyB9LFxyXG4gICAgICAgICgpID0+IHsgY3VycmVudFByb21pc2Uuc3BlZWNoLmNhbmNlbCgpOyB9LFxyXG4gICAgICAgICgpID0+IHsgY3VycmVudFByb21pc2Uuc3BlZWNoLmNhbmNlbCgpOyB9XHJcbiAgICAgICksXHJcbiAgICAgIHNwZWVjaDogbmV3IERlZmVycmVkKCksXHJcbiAgICB9O1xyXG4gICAgdGhpcy5fY3VycmVudFByb21pc2UgPSBjdXJyZW50UHJvbWlzZTtcclxuXHJcbiAgICAvLyBUcnkgdG8gc3RhcnQgdGhlIGF1ZGlvIGNvbnRleHRcclxuICAgIHRoaXMucmVzdW1lQXVkaW8oKS50aGVuKCgpID0+IHtcclxuICAgICAgLy8gRXhpdCBpZiB0aGUgcHJvbWlzZSBpcyBubyBsb25nZXIgcGVuZGluZyBiZWNhdXNlIG9mIHVzZXIgaW50ZXJhY3Rpb25cclxuICAgICAgaWYgKCFjdXJyZW50UHJvbWlzZS5wbGF5LnBlbmRpbmcpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgLy8gQ2FuY2VsIGlmIGFub3RoZXIgY2FsbCB0byBwbGF5IGhhcyBhbHJlYWR5IGJlZW4gbWFkZVxyXG4gICAgICBlbHNlIGlmICh0aGlzLl9jdXJyZW50UHJvbWlzZSAhPT0gY3VycmVudFByb21pc2UpIHtcclxuICAgICAgICBjdXJyZW50UHJvbWlzZS5wbGF5LmNhbmNlbCgpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVGhlIGF1ZGlvIGNvbnRleHQgaXMgcnVubmluZyBzbyB0aGUgc3BlZWNoIGNhbiBiZSBwbGF5ZWRcclxuICAgICAgaWYgKHRoaXMuX2VuYWJsZWQpIHtcclxuICAgICAgICBzdXBlci5fc3RhcnRTcGVlY2godGV4dCwgY29uZmlnLCBwbGF5TWV0aG9kKTtcclxuICAgICAgfVxyXG4gICAgICAvLyBSZWplY3QgaWYgdGhlIGF1ZGlvIGNvbnRleHQgaXMgbm90IHJ1bm5pbmdcclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgY3VycmVudFByb21pc2UucmVqZWN0KFxyXG4gICAgICAgICAgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICBgQ2Fubm90ICR7cGxheU1ldGhvZH0gc3BlZWNoIG9uIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gVGhlIGF1ZGlvIGNvbnRleHQgaXMgbm90IHJ1bm5pbmcuIFVzZSB0aGUgXCJUZXh0VG9TcGVlY2hGZWF0dXJlLnJlc3VtZUF1ZGlvXCIgbWV0aG9kIHRvIHRyeSB0byByZXN1bWUgaXQgYWZ0ZXIgYSB1c2VyIGdlc3R1cmUuYFxyXG4gICAgICAgICAgKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBjdXJyZW50UHJvbWlzZS5wbGF5O1xyXG4gIH1cclxuXHJcbiAgcGxheSh0ZXh0LCBjb25maWcpIHtcclxuICAgIHJldHVybiB0aGlzLl9zdGFydFNwZWVjaCh0ZXh0LCBjb25maWcsICdwbGF5Jyk7XHJcbiAgfVxyXG5cclxuICByZXN1bWUodGV4dCwgY29uZmlnKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc3RhcnRTcGVlY2godGV4dCwgY29uZmlnLCAncmVzdW1lJyk7XHJcbiAgfVxyXG5cclxuICBpbnN0YWxsQXBpKCkge1xyXG4gICAgY29uc3QgYXBpID0gc3VwZXIuaW5zdGFsbEFwaSgpO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGFwaSwge1xyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIFRleHRUb1NwZWVjaEZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBzZWUgY29yZS9UZXh0VG9TcGVlY2hGZWF0dXJlI2VuYWJsZWRcclxuICAgICAgICovXHJcbiAgICAgIGVuYWJsZWQ6IHtcclxuICAgICAgICBnZXQ6ICgpID0+IHRoaXMuX2VuYWJsZWQsXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gYXBpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgVGV4dFRvU3BlZWNoRmVhdHVyZTtcclxuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxyXG5pbXBvcnQgVGV4dFRvU3BlZWNoVXRpbHMgZnJvbSAnLi9UZXh0VG9TcGVlY2hVdGlscyc7XHJcbmltcG9ydCBBYnN0cmFjdFNwZWVjaCBmcm9tICcuL0Fic3RyYWN0U3BlZWNoJztcclxuaW1wb3J0IFNwZWVjaCBmcm9tICcuL1NwZWVjaCc7XHJcbmltcG9ydCBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUgZnJvbSAnLi9BYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUnO1xyXG5pbXBvcnQgVGV4dFRvU3BlZWNoRmVhdHVyZSBmcm9tICcuL1RleHRUb1NwZWVjaEZlYXR1cmUnO1xyXG4vKipcclxuICogQG1vZHVsZSBjb3JlL2F3c3BhY2tcclxuICovXHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgLyoqXHJcbiAgICogQHNlZSBjb3JlL0Fic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZVxyXG4gICAqL1xyXG4gIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSxcclxuICAvKipcclxuICAgKiBAc2VlIGNvcmUvVGV4dFRvU3BlZWNoRmVhdHVyZVxyXG4gICAqL1xyXG4gIFRleHRUb1NwZWVjaEZlYXR1cmUsXHJcbiAgLyoqXHJcbiAgICogQHNlZSBjb3JlL1RleHRUb1NwZWVjaFV0aWxzXHJcbiAgICovXHJcbiAgVGV4dFRvU3BlZWNoVXRpbHMsXHJcbiAgLyoqIFxyXG4gICAqIEBzZWUgY29yZS9BYnN0cmFjdFNwZWVjaFxyXG4gICAqL1xyXG4gIEFic3RyYWN0U3BlZWNoLFxyXG4gIC8qKlxyXG4gICAqIEBzZWUgY29yZS9TcGVlY2hcclxuICAgKi9cclxuICBTcGVlY2ggIFxyXG59O1xyXG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXHJcblxyXG4vKipcclxuICogQG1vZHVsZSBjb3JlL0hPU1RcclxuICovXHJcblxyXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi9VdGlscyc7XHJcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSAnLi9NYXRoVXRpbHMnO1xyXG5pbXBvcnQgRGVmZXJyZWQgZnJvbSAnLi9EZWZlcnJlZCc7XHJcbmltcG9ydCB7ZW52fSBmcm9tICcuL0hvc3RFbnZpcm9ubWVudCc7XHJcbmltcG9ydCBNZXNzZW5nZXIgZnJvbSAnLi9NZXNzZW5nZXInO1xyXG5pbXBvcnQgSG9zdE9iamVjdCBmcm9tICcuL0hvc3RPYmplY3QnO1xyXG5pbXBvcnQgTGlwc3luY0ZlYXR1cmUsIHsgRGVmYXVsdFZpc2VtZU1hcCB9IGZyb20gJy4vTGlwc3luY0ZlYXR1cmUnO1xyXG5pbXBvcnQgR2VzdHVyZUZlYXR1cmUsIHsgRGVmYXVsdEdlc3R1cmVXb3JkcyB9IGZyb20gJy4vR2VzdHVyZUZlYXR1cmUnO1xyXG5pbXBvcnQgUG9pbnRPZkludGVyZXN0RmVhdHVyZSwgeyBBeGlzTWFwIH0gZnJvbSAnLi9Qb2ludE9mSW50ZXJlc3RGZWF0dXJlJztcclxuXHJcbmltcG9ydCBhbmltcGFjayBmcm9tICcuL2FuaW1wYWNrJztcclxuY29uc3QgeyBFYXNpbmcsXHJcbiAgQW5pbWF0aW9uRmVhdHVyZSxcclxuICBBbmltYXRpb25UeXBlcyxcclxuICBBbmltYXRpb25MYXllcixcclxuICBMYXllckJsZW5kTW9kZXMsXHJcbiAgRGVmYXVsdExheWVyQmxlbmRNb2RlLFxyXG4gIFNpbmdsZVN0YXRlLFxyXG4gIFRyYW5zaXRpb25TdGF0ZSxcclxuICBGcmVlQmxlbmRTdGF0ZSxcclxuICBRdWV1ZVN0YXRlLFxyXG4gIFJhbmRvbUFuaW1hdGlvblN0YXRlLFxyXG4gIEJsZW5kMWRTdGF0ZSxcclxuICBCbGVuZDJkU3RhdGUsXHJcbiAgQW5pbWF0aW9uVXRpbHMgfSA9IGFuaW1wYWNrXHJcblxyXG5pbXBvcnQgYXdzIGZyb20gJy4vYXdzcGFjayc7XHJcbmNvbnN0IHtcclxuICBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUsXHJcbiAgVGV4dFRvU3BlZWNoRmVhdHVyZSxcclxuICBUZXh0VG9TcGVlY2hVdGlscyxcclxuICBBYnN0cmFjdFNwZWVjaCxcclxuICBTcGVlY2ggXHJcbiAgfSA9IGF3c1xyXG4gIFxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgLyoqXHJcbiAgICogQHNlZSBlbnZcclxuICAgKi9cclxuICBlbnYsXHJcbiAgLyoqXHJcbiAgICogQHNlZSBVdGlsc1xyXG4gICAqL1xyXG4gIFV0aWxzLFxyXG4gIC8qKlxyXG4gICAqIEBzZWUgTWF0aFV0aWxzXHJcbiAgICovXHJcbiAgTWF0aFV0aWxzLFxyXG4gIC8qKlxyXG4gICAqIEBzZWUgRGVmZXJyZWRcclxuICAgKi9cclxuICBEZWZlcnJlZCxcclxuICAvKipcclxuICAgKiBAc2VlIGNvcmUvTWVzc2VuZ2VyXHJcbiAgICovXHJcbiAgTWVzc2VuZ2VyLFxyXG4gIC8qKlxyXG4gICAqIEBzZWUgY29yZS9Ib3N0T2JqZWN0XHJcbiAgICovXHJcbiAgSG9zdE9iamVjdCxcclxuICAvKipcclxuICAgKiBAc2VlIGNvcmUvTGlwc3luY0ZlYXR1cmVcclxuICAgKi9cclxuICBMaXBzeW5jRmVhdHVyZSxcclxuICAvKipcclxuICAgKiBAc2VlIEdlc3R1cmVGZWF0dXJlXHJcbiAgICovXHJcbiAgR2VzdHVyZUZlYXR1cmUsXHJcbiAgLyoqXHJcbiAgICogQHNlZSBjb3JlL1BvaW50T2ZJbnRlcmVzdEZlYXR1cmVcclxuICAgKi9cclxuICBQb2ludE9mSW50ZXJlc3RGZWF0dXJlLFxyXG4gIC8qKlxyXG4gICAqIEBzZWUgRGVmYXVsdFZpc2VtZU1hcFxyXG4gICAqL1xyXG4gIERlZmF1bHRWaXNlbWVNYXAsXHJcbiAgLyoqXHJcbiAgICogQHNlZSBEZWZhdWx0R2VzdHVyZVdvcmRzXHJcbiAgICovXHJcbiAgRGVmYXVsdEdlc3R1cmVXb3JkcyxcclxuICAvKipcclxuICAgKiBAc2VlIEF4aXNNYXBcclxuICAgKi9cclxuICBBeGlzTWFwLFxyXG4gIC8qKlxyXG4gICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlXHJcbiAgICovXHJcbiAgQW5pbWF0aW9uRmVhdHVyZSxcclxuICAgLyoqXHJcbiAgICAqIEBzZWUgQW5pbWF0aW9uTGF5ZXJcclxuICAgICovXHJcbiAgQW5pbWF0aW9uTGF5ZXIsXHJcbiAgIC8qKlxyXG4gICAgKiBAc2VlIGNvcmUvU2luZ2xlU3RhdGVcclxuICAgICovXHJcbiAgU2luZ2xlU3RhdGUsXHJcbiAgIC8qKlxyXG4gICAgKiBAc2VlIFRyYW5zaXRpb25TdGF0ZVxyXG4gICAgKi9cclxuICBUcmFuc2l0aW9uU3RhdGUsXHJcbiAgIC8qKlxyXG4gICAgKiBAc2VlIEZyZWVCbGVuZFN0YXRlXHJcbiAgICAqL1xyXG4gIEZyZWVCbGVuZFN0YXRlLFxyXG4gICAvKipcclxuICAgICogQHNlZSBRdWV1ZVN0YXRlXHJcbiAgICAqL1xyXG4gIFF1ZXVlU3RhdGUsXHJcbiAgIC8qKlxyXG4gICAgKiBAc2VlIFJhbmRvbUFuaW1hdGlvblN0YXRlXHJcbiAgICAqL1xyXG4gIFJhbmRvbUFuaW1hdGlvblN0YXRlLFxyXG4gICAvKipcclxuICAgICogQHNlZSBCbGVuZDFkU3RhdGVcclxuICAgICovXHJcbiAgQmxlbmQxZFN0YXRlLFxyXG4gICAvKipcclxuICAgICogQHNlZSBCbGVuZDJkU3RhdGVcclxuICAgICovXHJcbiAgQmxlbmQyZFN0YXRlLFxyXG4gICAvKipcclxuICAgICogQHNlZSBBbmltYXRpb25VdGlsc1xyXG4gICAgKi9cclxuICBBbmltYXRpb25VdGlscyxcclxuIFxyXG4gIEVhc2luZyxcclxuICAgLyoqXHJcbiAgICAqIEBzZWUgTGF5ZXJCbGVuZE1vZGVzXHJcbiAgICAqL1xyXG4gIExheWVyQmxlbmRNb2RlcyxcclxuICAgLyoqXHJcbiAgICAqIEBzZWUgRGVmYXVsdExheWVyQmxlbmRNb2RlXHJcbiAgICAqL1xyXG4gIERlZmF1bHRMYXllckJsZW5kTW9kZSxcclxuICAgLyoqXHJcbiAgICAqIEBzZWUgQW5pbWF0aW9uVHlwZXNcclxuICAgICovXHJcbiAgQW5pbWF0aW9uVHlwZXMsXHJcblxyXG4gICAvLyBBV1MgUGFja1xyXG4gICAvKipcclxuICAgKiBAc2VlIGNvcmUvQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlXHJcbiAgICovXHJcbiAgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlLFxyXG4gIC8qKlxyXG4gICAqIEBzZWUgY29yZS9UZXh0VG9TcGVlY2hGZWF0dXJlXHJcbiAgICovXHJcbiAgVGV4dFRvU3BlZWNoRmVhdHVyZSxcclxuICAvKipcclxuICAgKiBAc2VlIGNvcmUvVGV4dFRvU3BlZWNoVXRpbHNcclxuICAgKi9cclxuICBUZXh0VG9TcGVlY2hVdGlscyxcclxuICAvKipcclxuICAgKiBAc2VlIGNvcmUvQWJzdHJhY3RTcGVlY2hcclxuICAgKi9cclxuICBBYnN0cmFjdFNwZWVjaCxcclxuICBcclxuICAvKipcclxuICAgKiBAc2VlIGNvcmUvU3BlZWNoXHJcbiAgICovXHJcbiAgIFNwZWVjaFxyXG59O1xyXG4iXSwibmFtZXMiOlsiRGVmZXJyZWQiLCJleGVjdXRhYmxlIiwib25SZXNvbHZlIiwib25SZWplY3QiLCJvbkNhbmNlbCIsIkVycm9yIiwicmVzIiwicmVqIiwiY2FuY2VsIiwic3RhdHVzIiwicmVzb2x2ZWQiLCJyZWplY3RlZCIsImNhbmNlbGVkIiwicGVuZGluZyIsInJlc29sdmUiLCJyZWplY3QiLCJ2YWx1ZSIsIl9zdGF0dXMiLCJfcmVzb2x2ZSIsIl9yZWplY3QiLCJfY2FuY2VsIiwiX2V4ZWN1dGFibGUiLCJhcmdzIiwiaXRlcmFibGUiLCJTeW1ib2wiLCJpdGVyYXRvciIsImUiLCJhcnJheSIsImRlZmVycmVkIiwiZmlsdGVyIiwiaXRlbSIsInJlc3VsdCIsInVuZGVmaW5lZCIsInJlc29sdmVWYWx1ZSIsImZvckVhY2giLCJsZW5ndGgiLCJlcnJvciIsImNhbmNlbFZhbHVlIiwibnVtSXRlbXMiLCJpdGVtVHJhY2tlciIsImZhaWxlZCIsIm51bVJlc29sdmVkIiwicmVzb2x1dGlvbnMiLCJpbmRleCIsIlByb21pc2UiLCJ0aGVuIiwiVXRpbHMiLCJyZXBsYWNlIiwiYyIsInJhbmRvbU51bWJlciIsIk1hdGgiLCJmbG9vciIsIkRhdGUiLCJub3ciLCJyYW5kb20iLCJ0b1N0cmluZyIsIm5hbWUiLCJuYW1lQXJyYXkiLCJpbmNsdWRlcyIsIm5hbWVTZXQiLCJTZXQiLCJtYXRjaEdyb3VwIiwibWF0Y2giLCJiYXNlTmFtZSIsInNsaWNlIiwiaW5jcmVtZW50IiwiTnVtYmVyIiwic2V0TmFtZSIsInNldE1hdGNoR3JvdXAiLCJzZXRJbmNyZW1lbnQiLCJzZWNvbmRzIiwib25GaW5pc2giLCJvblByb2dyZXNzIiwib25FcnJvciIsImNvbnNvbGUiLCJ3YXJuIiwiY3VycmVudFRpbWUiLCJ0b3RhbFRpbWUiLCJvblVwZGF0ZSIsImRlbHRhVGltZSIsIm1pbiIsIm1heCIsImNlaWwiLCJSYWRpYW5Ub0RlZ3JlZSIsIlBJIiwiRGVncmVlVG9SYWRpYW4iLCJNYXRoVXRpbHMiLCJyYWRpYW5zIiwiZGVncmVlcyIsImZyb20iLCJ0byIsImZhY3RvciIsImEiLCJiIiwicCIsImRpc3RTcXIiLCJkaXN0YW5jZVNxdWFyZWQiLCJ0IiwicG9pbnQiLCJ2ZXJ0aWNlcyIsIm1pblgiLCJQT1NJVElWRV9JTkZJTklUWSIsIm1pblkiLCJtYXhYIiwiTkVHQVRJVkVfSU5GSU5JVFkiLCJtYXhZIiwidiIsImRYIiwiZFkiLCJtaWRYIiwibWlkWSIsImRNYXgiLCJzdXBlckluZGljZXMiLCJ2ZXJ0c1dpdGhTdXBlciIsInN1cGVyU29ydGVkSW5kaWNlcyIsInNvcnRQb2ludHNDQ1ciLCJzdXBlclRyaWFuZ2xlIiwiaW5kaWNlcyIsImVkZ2VzIiwidHJpYW5nbGVzIiwibmV3VmVydCIsIm5ld0luZGV4IiwiaW52YWxpZFRyaWFuZ2xlcyIsInRyaWFuZ2xlIiwiaXNQb2ludEluQ2lyY3VtQ2lyY2xlIiwicHVzaCIsImJvdW5kaW5nUG9seSIsImVkZ2UiLCJjb3VudCIsIm90aGVyVHJpYW5nbGUiLCJvdGhlckVkZ2UiLCJzcGxpY2UiLCJpbmRleE9mIiwic29ydGVkSW5kaWNlcyIsInRyaWFuZ2xlc1RvUmVtb3ZlIiwibWFwIiwiYXgiLCJheSIsImJ4IiwiYnkiLCJjeCIsImN5IiwiZGVub20iLCJhVmFsIiwiYlZhbCIsImNWYWwiLCJjZW50cm9pZCIsInNvcnQiLCJhdGFuMiIsImFicyIsInZlY3RvciIsIkFycmF5IiwicmVkdWNlciIsImFjY3VtdWxhdG9yIiwiY3VycmVudFZhbHVlIiwic3FydCIsInJlZHVjZSIsInZlY3RvckEiLCJ2ZWN0b3JCIiwidmFsdWVBIiwidmFsdWVCIiwibm9ybWFsQSIsIm5vcm1hbGl6ZVZlY3RvciIsIm5vcm1hbEIiLCJkb3QiLCJnZXREb3RQcm9kdWN0IiwiYWNvcyIsImNsYW1wIiwidmVjdG9yMyIsIm1hdHJpeDMiLCJldmVyeSIsIngiLCJ5IiwieiIsIm1hZ25pdHVkZSIsImdldFZlY3Rvck1hZ25pdHVkZSIsImZpbGwiLCJtYXRyaXg0Iiwic2NhbGVYIiwic2NhbGVZIiwic2NhbGVaIiwiciIsInRhcmdldFZhbHVlIiwidmFsdWVTdG9yZSIsInNtb290aFRpbWUiLCJtYXhTcGVlZCIsImNsYW1wVGltZSIsImRlbHRhVmFsdWUiLCJjbGFtcERlbHRhVmFsdWUiLCJsYXN0VmFsdWUiLCJkMSIsImQyIiwiZDMiLCJkNCIsImVudiIsIk1lc3NlbmdlciIsImlkIiwiX2lkIiwiY3JlYXRlSWQiLCJfZGlzcGF0Y2hlciIsIndpbmRvdyIsIl9jYWxsYmFja3MiLCJfZXZlbnRMaXN0ZW5lcnMiLCJtZXNzYWdlIiwiY2FsbGJhY2siLCJkZXRhaWwiLCJDdXN0b21FdmVudCIsImxpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsIl9jcmVhdGVMb2NhbE1lc3NhZ2UiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiX2NyZWF0ZUxpc3RlbmVyIiwiX2FkZExpc3RlbmVyIiwiaSIsInN0b3BMaXN0ZW5pbmciLCJfcmVtb3ZlTGlzdGVuZXIiLCJyZWdleHAiLCJtZXNzYWdlcyIsIk9iamVjdCIsImtleXMiLCJ0ZXN0IiwiZXZlbnQiLCJfY3JlYXRlRXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwibWVzc2VuZ2VyIiwiR2xvYmFsTWVzc2VuZ2VyIiwibGlzdGVuVG8iLCJzdG9wTGlzdGVuaW5nVG9BbGwiLCJlbWl0IiwiZGVmaW5lUHJvcGVydGllcyIsIndyaXRhYmxlIiwiRVZFTlRTIiwiQWJzdHJhY3RIb3N0RmVhdHVyZSIsImhvc3QiLCJfaG9zdCIsImV2ZW50cyIsImFwaSIsImVudHJpZXMiLCJjb25zdHJ1Y3RvciIsIm93bmVyIiwic3RvcExpc3RlbmluZ0J5UmVnZXhwIiwidXBkYXRlIiwiUmVnRXhwIiwic291cmNlIiwiUmVzdWx0Q2xhc3MiLCJtaXhpbkNsYXNzRmFjdG9yaWVzIiwibWl4aW5DbGFzc0ZhY3RvcnkiLCJTRVJWSUNFUyIsIkhvc3RPYmplY3QiLCJfb3duZXIiLCJfZmVhdHVyZXMiLCJfd2FpdHMiLCJfbGFzdFVwZGF0ZSIsImR0Iiwid2FpdCIsImV4ZWN1dGUiLCJ2YWx1ZXMiLCJmZWF0dXJlIiwib25Db21wbGV0ZSIsIkZlYXR1cmVDbGFzcyIsImZvcmNlIiwiaW5wdXRUeXBlIiwicHJvdG90eXBlIiwiaW5zdGFsbEFwaSIsImFkZEZlYXR1cmUiLCJ0eXBlTmFtZSIsInJlbW92ZUZlYXR1cmUiLCJkaXNjYXJkIiwiZGVmaW5lUHJvcGVydHkiLCJnZXRQcm90b3R5cGVPZiIsIkxpbmVhciIsIk5vbmUiLCJrIiwiSW4iLCJPdXQiLCJJbk91dCIsIlF1YWRyYXRpYyIsIkN1YmljIiwiUXVhcnRpYyIsIlF1aW50aWMiLCJTaW51c29pZGFsIiwiY29zIiwic2luIiwiRXhwb25lbnRpYWwiLCJDaXJjdWxhciIsIkVsYXN0aWMiLCJzIiwiYXNpbiIsIkJhY2siLCJCb3VuY2UiLCJGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlIiwiQmFzZUNsYXNzIiwiRmVhdHVyZURlcGVuZGVudE1peGluIiwiX2luaXRpYWxpemVkIiwiX29uRmVhdHVyZUFkZGVkIiwiYmluZCIsIl9vbkZlYXR1cmVSZW1vdmVkIiwiRVZFTlRfREVQRU5ERU5DSUVTIiwiZXZlbnROYW1lIiwiQW5pbWF0aW9uRmVhdHVyZURlcGVuZGVudEludGVyZmFjZSIsIm9sZE5hbWUiLCJuZXdOYW1lIiwibGF5ZXJOYW1lIiwiYW5pbWF0aW9uTmFtZSIsIlBhcmVudENsYXNzIiwiTWl4aW4iLCJBbmltYXRpb25GZWF0dXJlRGVwZW5kZW50TWl4aW4iLCJBbmltYXRpb25GZWF0dXJlIiwiYWRkTGF5ZXIiLCJyZW1vdmVMYXllciIsInJlbmFtZUxheWVyIiwiYWRkQW5pbWF0aW9uIiwicmVtb3ZlQW5pbWF0aW9uIiwicmVuYW1lQW5pbWF0aW9uIiwiTWFuYWdlZEFuaW1hdGlvbkxheWVySW50ZXJmYWNlIiwib3B0aW9ucyIsIm5hbWVGaWx0ZXIiLCJ3ZWlnaHQiLCJlYXNpbmdGbiIsIk1hbmFnZWRBbmltYXRpb25MYXllck1peGluIiwiX21hbmFnZWRMYXllcnMiLCJsYXllcnMiLCJfb25MYXllckFkZGVkIiwiX29uTGF5ZXJSZW1vdmVkIiwiaXNBY3RpdmUiLCJnZXRBbmltYXRpb25zIiwiYW5pbU5hbWUiLCJfb25BbmltYXRpb25BZGRlZCIsImFuaW1hdGlvbnMiLCJfb25BbmltYXRpb25SZW1vdmVkIiwibGF5ZXJPcHRpb25zIiwiYW5pbU9wdGlvbnMiLCJERUZBVUxUX0xBWUVSX09QVElPTlMiLCJhbmltYXRpb25PcHRpb25zIiwiYXNzaWduIiwicmVnaXN0ZXJBbmltYXRpb24iLCJyZWdpc3RlckxheWVyIiwibGF5ZXJOYW1lcyIsInNldExheWVyV2VpZ2h0IiwiYmxlbmRUaW1lIiwic2V0TGF5ZXJXZWlnaHRzIiwiZW5hYmxlIiwiZGlzYWJsZSIsIlRleHRUb1NwZWVjaEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UiLCJUZXh0VG9TcGVlY2hGZWF0dXJlRGVwZW5kZW50TWl4aW4iLCJUZXh0VG9TcGVlY2hGZWF0dXJlIiwicGxheSIsInBhdXNlIiwicmVzdW1lIiwic3RvcCIsInNlbnRlbmNlIiwid29yZCIsInZpc2VtZSIsInNzbWwiLCJEZWZhdWx0VmlzZW1lTWFwIiwic2lsIiwib3ZlcnJpZGVXZWlnaHQiLCJTIiwiVCIsImYiLCJ1IiwiRSIsIm8iLCJPIiwiTGlwc3luY0ZlYXR1cmUiLCJ2aXNlbWVCbGVuZFRpbWUiLCJkZWNheVJhdGUiLCJhbW91bnQiLCJ2aXNlbWVFYXNpbmdGbiIsInZpc2VtZUxheWVycyIsInRhbGtpbmdCbGVuZFRpbWUiLCJ0YWxraW5nRWFzaW5nRm4iLCJ0YWxraW5nTGF5ZXJzIiwidmlzZW1lTGVhZFRpbWUiLCJfdmlzZW1lTGF5ZXJzIiwiX3RhbGtpbmdMYXllcnMiLCJhbmltYXRpb24iLCJ2aXNlbWVNYXAiLCJyZWdpc3RlclZpc2VtZUxheWVyIiwicmVnaXN0ZXJUYWxraW5nTGF5ZXIiLCJnZXRBbmltYXRpb25UeXBlIiwid2VpZ2h0TmFtZXMiLCJnZXRBbmltYXRpb25CbGVuZE5hbWVzIiwidmlzZW1lT3B0aW9ucyIsInNwZWVjaG1hcmtPZmZzZXQiLCJfdmlzZW1lTGVhZFRpbWUiLCJfcmVnaXN0ZXJWaXNlbWVBbmltYXRpb24iLCJyZXN1bWVBbmltYXRpb24iLCJfb25TdG9wIiwiX29uUGxheSIsInBhdXNlQW5pbWF0aW9uIiwibWFyayIsImlzVmlzZW1lQWN0aXZlIiwidmlzZW1lTmFtZXMiLCJkdXJhdGlvbiIsImxlcnBGYWN0b3IiLCJsZXJwIiwiYmxlbmRJblRpbWUiLCJob2xkVGltZSIsIl9hbmltYXRlU2ltcGxlVmlzZW1lIiwiZGVjYXlXZWlnaHQiLCJfYW5pbWF0ZUhlbGRWaXNlbWUiLCJ2aXNlbWVOYW1lIiwicGVha1dlaWdodCIsImJsZW5kT3V0VGltZSIsIndlaWdodFByb21pc2UiLCJzZXRBbmltYXRpb25CbGVuZFdlaWdodCIsInN0YXJ0UHJvbWlzZSIsImhvbGRQcm9taXNlIiwiZ2V0Iiwic2V0IiwibWl4IiwiU1NNTFNwZWVjaG1hcmtJbnRlcmZhY2UiLCJTU01MU3BlZWNoTWFya01peGluIiwiSlNPTiIsInBhcnNlIiwibWV0aG9kIiwiYXBwbHkiLCJEZWZhdWx0R2VzdHVyZVdvcmRzIiwiYmlnIiwiaGVhcnQiLCJtYW55IiwibW92ZW1lbnQiLCJvbmUiLCJhZ2dyZXNzaXZlIiwieW91IiwiZGVmZW5zZSIsIndhdmUiLCJzZWxmIiwiR2VzdHVyZUZlYXR1cmUiLCJtaW5pbXVtSW50ZXJ2YWwiLCJsYXllciIsImxheWVySG9sZFRpbWUiLCJsYXllck1pbmltdW1JbnRlcnZhbCIsImNhbkFkdmFuY2UiLCJpc1F1ZXVlRW5kIiwiY3VycmVudEdlc3R1cmUiLCJfZ2V0SG9sZFRpbWUiLCJob2xkVGltZXIiLCJwbGF5TmV4dEFuaW1hdGlvbiIsInBsYXlUaW1lciIsImF1dG9EaXNhYmxlIiwiYW5pbSIsIndvcmRzIiwiZ2VzdHVyZU1hcCIsInRyYW5zaXRpb25UaW1lIiwia2V5Iiwic3RyaW5naWZ5IiwiZ2VuZXJpY0dlc3R1cmVzIiwicmVhc29uIiwiX2dldE1pbmltdW1JbnRlcnZhbCIsInBsYXlBbmltYXRpb24iLCJnZXRQYXVzZWQiLCJjcmVhdGVHZXN0dXJlTWFwIiwiY3JlYXRlR2VuZXJpY0dlc3R1cmVBcnJheSIsInBsYXlHZXN0dXJlIiwic3RvcEFuaW1hdGlvbiIsImludGVycnVwdEFuaW1hdGlvbiIsIkFuaW1hdGlvblV0aWxzIiwicHJvcGVydHlPd25lciIsInByb3BlcnR5TmFtZSIsImlzTmFOIiwic3RhcnRWYWx1ZSIsImludGVycG9sYXRvciIsInByb2dyZXNzIiwiZWFzZUZhY3RvciIsIkFic3RyYWN0U3RhdGUiLCJfd2VpZ2h0IiwiX2ludGVybmFsV2VpZ2h0IiwiX3BhdXNlZCIsIl9wcm9taXNlcyIsImZpbmlzaCIsIl9wbGF5Q2FsbGJhY2tzIiwiaW50ZXJwb2xhdGVQcm9wZXJ0eSIsInByb21pc2UiLCJhbGwiLCJ1cGRhdGVJbnRlcm5hbFdlaWdodCIsIlRyYW5zaXRpb25TdGF0ZSIsIl90byIsIl9mcm9tIiwiX3dlaWdodFByb21pc2UiLCJ0b3RhbFdlaWdodCIsInN0YXRlIiwiY3VycmVudFN0YXRlcyIsInRhcmdldFN0YXRlIiwiZGVhY3RpdmF0ZSIsInJlc2V0Iiwid2VpZ2h0UHJvbWlzZXMiLCJzZXRXZWlnaHQiLCJvbk5leHQiLCJwcm9taXNlcyIsIkFuaW1hdGlvblBsYXllckludGVyZmFjZSIsImZuIiwicGxheU1ldGhvZCIsIkFuaW1hdGlvblBsYXllck1peGluIiwiX3RyYW5zaXRpb25TdGF0ZSIsIl9zdGF0ZXMiLCJNYXAiLCJfY3VycmVudFN0YXRlIiwiX3RyYW5zaXRpb25UaW1lIiwiX2Vhc2luZ0ZuIiwiaGFzIiwiY3VycmVudEFuaW1hdGlvbiIsIndlaWdodFBlbmRpbmciLCJjb25maWd1cmUiLCJfcHJlcGFyZUN1cnJlbnRTdGF0ZSIsIlN0YXRlQ29udGFpbmVySW50ZXJmYWNlIiwiY3VycmVudE5hbWUiLCJTdGF0ZUNvbnRhaW5lck1peGluIiwidW5pcXVlTmFtZSIsImdldFVuaXF1ZU5hbWUiLCJRdWV1ZVN0YXRlIiwicXVldWVTdGF0ZXMiLCJhZGRTdGF0ZSIsIl9xdWV1ZSIsIl9kb25lIiwiaW50ZXJuYWxXZWlnaHQiLCJuZXh0IiwiZG9uZSIsIndyYXAiLCJsYXN0TmFtZSIsInNpemUiLCJnZXRTdGF0ZSIsImxvb3BDb3VudCIsIkluZmluaXR5IiwiaXNUcmFuc2l0aW9uaW5nIiwiX3Jlc2V0IiwicGF1c2VkIiwic3RvcHBlZCIsImRpc2NhcmRTdGF0ZXMiLCJBYnN0cmFjdEJsZW5kU3RhdGUiLCJibGVuZFN0YXRlcyIsImJsZW5kV2VpZ2h0cyIsIkZyZWVCbGVuZFN0YXRlIiwic3VtV2VpZ2h0cyIsIkJsZW5kMWRTdGF0ZSIsImJsZW5kVGhyZXNob2xkcyIsInBoYXNlTWF0Y2hlcyIsIl9ibGVuZFZhbHVlIiwiYmxlbmRWYWx1ZSIsIm5vblplcm9EaWZmZXJlbnRTaXplIiwiY29udGFpbnNEdXBsaWNhdGVzIiwiX3RocmVzaG9sZHMiLCJwaGFzZU1hdGNoIiwiX3NvcnRUaHJlc2hvbGRzIiwiX2ZvcmNlTm9UaHJlc2hvbGREdXBlcyIsIl9waGFzZUxlYWRTdGF0ZSIsIl91cGRhdGVCbGVuZFdlaWdodHMiLCJ0aHJlc2hvbGRWYWx1ZSIsInNhbWVWYWx1ZSIsImZpbmQiLCJ0aHJlc2hvbGQiLCJyZW1vdmVkIiwiZmluZEluZGV4Iiwibm9ybWFsaXplZFRpbWUiLCJ0YXJnZXRJbmRleCIsInRocmVzaG9sZEEiLCJ0aHJlc2hvbGRCIiwiZmFjdG9yQiIsImZhY3RvckEiLCJzdGF0ZUEiLCJzdGF0ZUIiLCJCbGVuZDJkU3RhdGUiLCJvdGhlclRocmVzaG9sZCIsIl9ibGVuZFZhbHVlWCIsIl9ibGVuZFZhbHVlWSIsImJsZW5kVmFsdWVYIiwiYmxlbmRWYWx1ZVkiLCJfdmVydGljZXMiLCJfdHJpYW5nbGVzIiwiZ2V0RGVsYXVuYXlUcmlhbmd1bGF0aW9uIiwicHJvcGVydHkiLCJ0b1VwcGVyQ2FzZSIsIl9zZXRJbmZsdWVuY2VDbG9zZXN0UG9pbnRPbkxpbmUiLCJpc1BvaW50SW5UcmlhbmdsZSIsIl9zZXRJbmZsdWVuY2VUcmlhbmdsZSIsIl9zZXRJbmZsdWVuY2VDbG9zZXN0UG9pbnRJblRyaWFuZ2xlcyIsImFyZWFBIiwidHJpYW5nbGVBcmVhIiwiYXJlYUIiLCJhcmVhQyIsInRvdGFsQXJlYSIsIndlaWdodEEiLCJ3ZWlnaHRCIiwid2VpZ2h0QyIsInRocmVzaG9sZEMiLCJzdGF0ZUMiLCJfc2V0UGhhc2VMZWFkU3RhdGUiLCJnbG9iYWxDbG9zZXN0UG9pbnQiLCJnbG9iYWxNaW5EaXN0IiwiY2xvc2VzdFRyaWFuZ2xlIiwicG9pbnRBIiwiY2xvc2VzdFBvaW50T25MaW5lIiwicG9pbnRCIiwicG9pbnRDIiwiZGlzdEEiLCJkaXN0QiIsImRpc3RDIiwibG9jYWxDbG9zZXN0UG9pbnQiLCJsb2NhbE1pbkRpc3QiLCJjbG9zZXN0UG9pbnQiLCJzdGF0ZXMiLCJwaGFzZU1hdGNoZWQiLCJMYXllckJsZW5kTW9kZXMiLCJPdmVycmlkZSIsIkFkZGl0aXZlIiwiRGVmYXVsdExheWVyQmxlbmRNb2RlIiwidmFsaWRhdGVCbGVuZE1vZGUiLCJibGVuZE1vZGUiLCJBbmltYXRpb25MYXllciIsIl9ibGVuZE1vZGUiLCJfd2VpZ2h0UGF1c2VkIiwiaXNXZWlnaHRBY3RpdmUiLCJnZXRTdGF0ZU5hbWVzIiwiYmxlbmROYW1lIiwic2V0QmxlbmRXZWlnaHQiLCJnZXRCbGVuZFdlaWdodCIsIlNpbmdsZVN0YXRlIiwiX3RpbWVTY2FsZSIsInRpbWVTY2FsZSIsIl9sb29wQ291bnQiLCJ0aW1lIiwiUmFuZG9tQW5pbWF0aW9uU3RhdGUiLCJzdWJTdGF0ZXMiLCJfcGxheUludGVydmFsIiwicGxheUludGVydmFsIiwiZ2V0UmFuZG9tRmxvYXQiLCJwbGF5UmFuZG9tQW5pbWF0aW9uIiwidGltZXIiLCJfcmVzZXRUaW1lciIsInJhbmRvbVN0YXRlIiwiZ2V0UmFuZG9tSW50IiwiY2FuY2VsQW5pbWF0aW9uIiwiQW5pbWF0aW9uVHlwZXMiLCJzaW5nbGUiLCJmcmVlQmxlbmQiLCJxdWV1ZSIsInJhbmRvbUFuaW1hdGlvbiIsImJsZW5kMWQiLCJibGVuZDJkIiwiX2xheWVycyIsIl9sYXllck1hcCIsImV4aXN0aW5nIiwibGFzdEluZGV4IiwibnVtTGF5ZXJzIiwid2VpZ2h0TXVsdGlwbGllciIsImN1cnJlbnRTdGF0ZSIsImJsZW5kU3RhdGVPcHRpb25zIiwiYmxlbmRPcHRpb25zIiwiX2NyZWF0ZVNpbmdsZVN0YXRlIiwicXVldWVPcHRpb25zIiwicXVldWVPcHRpb24iLCJibGVuZE1hdGNoUGhhc2VzIiwic3ViU3RhdGVPcHRpb25zIiwibGF5ZXJJbmRleCIsIl92YWxpZGF0ZUluZGV4IiwiZXZlbnREYXRhIiwiY3VycmVudEluZGV4IiwiZ2V0QW5pbWF0aW9uQmxlbmRXZWlnaHQiLCJwYXVzZVdlaWdodCIsInJlc3VtZVdlaWdodCIsImFuaW1hdGlvblR5cGUiLCJfdmFsaWRhdGVOZXdBbmltYXRpb24iLCJyZW1vdmVTdGF0ZSIsImN1cnJlbnRBbmltYXRpb25OYW1lIiwibmV3QW5pbWF0aW9uTmFtZSIsInJlbmFtZVN0YXRlIiwibmV4dFF1ZXVlZEFuaW1hdGlvbiIsImwiLCJyZXN1bWVkIiwibW92ZUxheWVyIiwiZ2V0TGF5ZXJXZWlnaHQiLCJwYXVzZUxheWVyV2VpZ2h0IiwicmVzdW1lTGF5ZXJXZWlnaHQiLCJwYXVzZUxheWVyIiwicmVzdW1lTGF5ZXIiLCJnZXRUcmFuc2l0aW9uaW5nIiwiZ2V0Q3VycmVudEFuaW1hdGlvbiIsIl91cGRhdGVJbnRlcm5hbFdlaWdodHMiLCJBeGlzTWFwIiwiUG9zaXRpdmVYIiwiTmVnYXRpdmVYIiwiUG9zaXRpdmVZIiwiTmVnYXRpdmVZIiwiUG9zaXRpdmVaIiwiTmVnYXRpdmVaIiwiRmFjZVRhcmdldFR5cGVzIiwiRXllQ2VudGVyIiwiRXllTGVmdCIsIkV5ZVJpZ2h0IiwiTW91dGgiLCJGYWNlVmVjdG9ycyIsIk1pY3JvU2FjY2FkZVdhaXRSYW5nZXMiLCJwb3N0TWFjcm8iLCJNYWNyb1NhY2NhZGVXYWl0UmFuZ2VzIiwibW91dGhUYXJnZXQiLCJleWVUYXJnZXQiLCJCbGlua1RocmVzaG9sZCIsIk1heERlbHRhIiwiUG9pbnRPZkludGVyZXN0RmVhdHVyZSIsInRhcmdldCIsImxvb2tUcmFja2VyIiwic2NlbmUiLCJsb29rQmxlbmRUaW1lIiwibG9va0Vhc2luZ0ZuIiwibG9va0xheWVycyIsImJsaW5rQmxlbmRUaW1lIiwiYmxpbmtFYXNpbmdGbiIsImJsaW5rTGF5ZXJzIiwiX3ZhbGlkYXRlVHJhbnNmb3JtT2JqZWN0IiwiX2xvb2tUcmFja2VyIiwiX3NjZW5lIiwiX3RhcmdldCIsIl9wcmV2VGFyZ2V0UG9zIiwiX2lzVGFyZ2V0TW92aW5nIiwiX2xvb2tMYXllcnMiLCJfdHJhY2tpbmdDb25maWdzIiwiX2JsaW5rTGF5ZXJzIiwicmVmZXJlbmNlIiwiZm9yd2FyZEF4aXMiLCJoYXNTYWNjYWRlIiwicmVnaXN0ZXJMb29rTGF5ZXIiLCJyZWdpc3RlckJsaW5rTGF5ZXIiLCJfcmVnaXN0ZXJMb29rQW5pbWF0aW9uIiwiY29uZmlnIiwidHJhY2tpbmdDb25maWciLCJhbmdsZXMiLCJoIiwicHJldkFuZ2xlcyIsInNvdXJjZVBvc2l0aW9uIiwiX2dldFdvcmxkUG9zaXRpb24iLCJ0YXJnZXRQb3NpdGlvbiIsImxvb2tWZWN0b3IiLCJ0YXJnZXRQb3MiLCJ0cmFja2VyUG9zIiwidGFyZ2V0U3BoZXJpY2FsIiwiY2FydGVzaWFuVG9TcGhlcmljYWwiLCJ0YXJnZXRBbmdsZXMiLCJfc3BoZXJpY2FsVG9CbGVuZFZhbHVlIiwicmVmRGlyZWN0aW9uIiwiX2dldE9iamVjdERpcmVjdGlvbiIsInJlZlNwaGVyaWNhbCIsInJlZkFuZ2xlcyIsInRhcmdldFR5cGUiLCJkaXN0YW5jZSIsIl9nZXRUYXJnZXREaXN0YW5jZSIsImZhY2VWZWN0b3IiLCJzcGhlcmljYWwiLCJibGVuZFZhbHVlcyIsIm1heEhTcGVlZCIsImV4cCIsIm1heFZTcGVlZCIsIkQwIiwiZCIsImhEdXJhdGlvbiIsInZEdXJhdGlvbiIsIm1pY3JvU2FjY2FkZSIsIl91cGRhdGVMYXllclNwZWVkIiwiX2luaXRpYWxpemVNaWNyb1RpbWVyIiwibWFjcm9TYWNjYWRlIiwibWFjcm9TYWNjYWRlV2FpdFJhbmdlIiwiaExpbWl0IiwiaEZhY3RvciIsInZMaW1pdCIsInZGYWN0b3IiLCJzYWNjYWRlVGFyZ2V0IiwiX2dldEZhY2VUYXJnZXRBbmdsZXMiLCJfaW5pdGlhbGl6ZU1hY3JvVGltZXIiLCJtaW5XYWl0VGltZSIsIm1heFdhaXRUaW1lIiwid2FpdFRpbWUiLCJtaWNyb1NhY2NhZGVUaW1lciIsIl9zZXRNaWNyb1NhY2NhZGUiLCJtYWNyb1NhY2NhZGVUaW1lciIsIl9zZXRNYWNyb1NhY2NhZGUiLCJfYWRkVHJhY2tpbmdDb25maWciLCJoVmVsb2NpdHkiLCJ2VmVsb2NpdHkiLCJfc2V0TG9va0FuZ2xlcyIsIl9yZXNldExvb2tBbmdsZXMiLCJkZWx0YVNlY29uZHMiLCJ0cmlnZ2VyQmxpbmsiLCJjdXJyZW50SCIsImN1cnJlbnRWIiwidGFyZ2V0SCIsInRhcmdldFYiLCJwcmV2VGFyZ2V0SCIsInByZXZUYXJnZXRWIiwiY2hhbmdlQW1vdW50IiwidG9EZWdyZWVzIiwiZ2V0QW5nbGVCZXR3ZWVuIiwiZGFtcFZhbHVlIiwic2V0VGFyZ2V0Iiwic2V0VGFyZ2V0QnlOYW1lIiwic2V0VGFyZ2V0QnlJZCIsIm9iaiIsImZvcndhcmRWZWN0b3IiLCJyb3RhdGlvbiIsImdldFJvdGF0aW9uTWF0cml4IiwiX2dldFdvcmxkTWF0cml4Iiwicm90YXRlVmVjdG9yIiwidGhldGEiLCJwaGkiLCJFYXNpbmciLCJUZXh0VG9TcGVlY2hVdGlscyIsInRleHQiLCJyYW5kb21NYXJrcyIsImludGVybmFsTWFwIiwiX3Byb2Nlc3NJbnB1dE1hcCIsInNwZWFrVGFncyIsInNzbWxNYXJrUmVnZXgiLCJzc21sVGFnUmVnZXgiLCJleGlzdGluZ1RhZ3MiLCJleGVjIiwic3RhcnQiLCJlbmQiLCJjaHVua3MiLCJzc21sTWFya1Jlc3VsdCIsImR1cGxpY2F0ZU1hcmtUb0NoZWNrIiwiZXhpc3RpbmdUYWciLCJzdWJzdHIiLCJfaW5zZXJ0TWFya3MiLCJtYXJrVGV4dCIsIm1hcmtlZFRleHQiLCJqb2luIiwiYWRkTWFya3NUb1VubWFya2VkU2VudGVuY2VzIiwidmFsaWRhdGVUZXh0IiwibWFya3MiLCJtYXJrSW5kaWNlcyIsIm1hcmtSZXN1bHQiLCJzc21sUmVzdWx0IiwiY2xlYW5lZFRleHQiLCJleGlzdGluZ1NzbWwiLCJ3aGl0ZXNwYWNlIiwic2VudGVuY2VFbmRJbmRpY2VzIiwiX2dldFNlbnRlbmNlRW5kcyIsInByZXZJbmRleCIsInRhcmdldEluZGljZXMiLCJjb250YWluc01hcmsiLCJtYXJrSW5kZXgiLCJyYW5kb21NYXJrZWRUZXh0IiwiX2luc2VydFJhbmRvbU1hcmtzQXQiLCJvZmZzZXQiLCJyYW5kb21NYXJrIiwic2VudGVuY2VSZWdleCIsImVuZFNlbnRlbmNlUmVnZXgiLCJzZW50ZW5jZUVuZHMiLCJwdW5jdFJlc3VsdCIsImR1cGxpY2F0ZXNUb0NoZWNrIiwid29yZFJlZ2V4IiwibG93ZXJDYXNlV29yZCIsImNoZWNrRHVwbGljYXRlIiwibWFya2VkV29yZHMiLCJ0b0xvd2VyQ2FzZSIsImV4aXN0aW5nTWFya3MiLCJsaXN0IiwiaXNBcnJheSIsIkFic3RyYWN0U3BlZWNoIiwic3BlYWtlciIsInNwZWVjaG1hcmtzIiwiX3NwZWFrZXIiLCJfdGV4dCIsIl9zcGVlY2htYXJrcyIsIl9zcGVlY2htYXJrT2Zmc2V0IiwiX3N0YXJ0VGltZSIsIl9sb2NhbFRpbWUiLCJfcGF1c2VUaW1lIiwiX3BsYXlpbmciLCJfbWFya0l0ZXIiLCJfY3VycmVudE1hcmsiLCJfZW5kVGltZSIsIl9wcm9taXNlIiwib25JbnRlcnJ1cHQiLCJpbnRlcnJ1cHQiLCJ0eXBlIiwic3BlZWNoIiwiX2NoZWNrRmluaXNoZWQiLCJfY3JlYXRlUHJvbWlzZSIsIlNwZWVjaCIsImF1ZGlvQ29uZmlnIiwiX2F1ZGlvIiwiYXVkaW8iLCJvbmVuZGVkIiwiX2F1ZGlvRmluaXNoZWQiLCJ2b2x1bWUiLCJzZXRUaW1lb3V0IiwiX3BsYXlBdWRpbyIsIl9wYXVzZUF1ZGlvIiwiZW5naW5lcyIsImF1ZGlvRm9ybWF0cyIsInNwZWVjaG1hcmtUeXBlcyIsInNhbXBsZVJhdGVzIiwibXAzIiwicmF0ZXMiLCJkZWZhdWx0cyIsInN0YW5kYXJkIiwibmV1cmFsIiwicGNtIiwib2dnX3ZvcmJpcyIsImF3c1ZlcnNpb24iLCJBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUiLCJ2b2ljZSIsImVuZ2luZSIsImxhbmd1YWdlIiwiYXVkaW9Gb3JtYXQiLCJzYW1wbGVSYXRlIiwibWluRW5kTWFya0R1cmF0aW9uIiwiaXNHbG9iYWwiLCJfc3BlZWNoQ2FjaGUiLCJfY3VycmVudFNwZWVjaCIsIl9jdXJyZW50UHJvbWlzZSIsIl9pc1ZhbGlkYXRlZCIsIl9pc0dsb2JhbCIsIl92b2x1bWVQYXVzZWQiLCJfdm9pY2UiLCJQT0xMWV9ERUZBVUxUUyIsIlZvaWNlSWQiLCJfbGFuZ3VhZ2UiLCJMYW5ndWFnZU5hbWUiLCJfZW5naW5lIiwiRW5naW5lIiwiX2F1ZGlvRm9ybWF0IiwiT3V0cHV0Rm9ybWF0IiwiX3NhbXBsZVJhdGUiLCJTYW1wbGVSYXRlIiwiX21pbkVuZE1hcmtEdXJhdGlvbiIsIkFXU19WRVJTSU9OIiwiUE9MTFlfTUlOX05FVVJBTF9WRVJTSU9OIiwiZm9ybWF0IiwicmF0ZSIsInZvaWNlSWQiLCJQT0xMWV9WT0lDRVMiLCJJZCIsIlN1cHBvcnRlZEVuZ2luZXMiLCJsYW5ndWFnZUNvZGUiLCJQT0xMWV9MQU5HVUFHRVMiLCJhdmFpbGFibGVDb2RlcyIsIkxhbmd1YWdlQ29kZSIsIkFkZGl0aW9uYWxMYW5ndWFnZUNvZGVzIiwiUE9MTFlfTEFOR1VBR0VfQ09ERVMiLCJfdmFsaWRhdGVFbmdpbmUiLCJfdmFsaWRhdGVGb3JtYXQiLCJfdmFsaWRhdGVSYXRlIiwiX3ZhbGlkYXRlVm9pY2UiLCJfdmFsaWRhdGVMYW5ndWFnZSIsImlzUmVhZHkiLCJfdmFsaWRhdGUiLCJza2lwU3BlZWNoZXMiLCJjdXJyZW50Q29uZmlnIiwiX2dldENvbmZpZyIsImN1cnJlbnRDb25maWdTdHIiLCJMYW5ndWFnZSIsInZhbGlkQ29uZmlnIiwiY29uZmlnU3RyIiwic3BlZWNoQ29uZmlnU3RyIiwiX3VwZGF0ZVNwZWVjaCIsImF1ZGlvUGFyYW1zIiwiVGV4dCIsIlRleHRUeXBlIiwic3BlZWNobWFya1BhcmFtcyIsIlNwZWVjaE1hcmtUeXBlcyIsIl9zeW50aGVzaXplU3BlZWNobWFya3MiLCJfc3ludGhlc2l6ZUF1ZGlvIiwicmVzdWx0cyIsIl9jcmVhdGVTcGVlY2giLCJwYXJhbXMiLCJwcmVzaWduZXIiLCJnZXRTeW50aGVzaXplU3BlZWNoVXJsIiwidXJsIiwicG9sbHkiLCJzeW50aGVzaXplU3BlZWNoIiwianNvblN0cmluZyIsIkF1ZGlvU3RyZWFtIiwianNvbiIsImRhdGFTdHIiLCJkYXRhIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwibWFya1R5cGVzIiwiZW5kTWFya1R5cGVzIiwic3BlZWNoTWFya3MiLCJtYXRjaEFsbCIsIm51bU1hcmtzIiwibGFzdE1hcmsiLCJlbmRUaW1lcyIsImVuZFRpbWUiLCJfdXBkYXRlQ29uZmlnIiwiZ2V0Vm9sdW1lIiwic2V0Vm9sdW1lIiwicGF1c2VWb2x1bWUiLCJyZXN1bWVWb2x1bWUiLCJfdm9sdW1lIiwidm9sdW1lUGVuZGluZyIsInBsYXlpbmciLCJjdXJyZW50UHJvbWlzZSIsIl9nZXRTcGVlY2giLCJfc2V0Q3VycmVudFNwZWVjaCIsIl9zdGFydFNwZWVjaCIsInZlcnNpb24iLCJjdXN0b21Vc2VyQWdlbnQiLCJfd2l0aEN1c3RvbVVzZXJBZ2VudCIsInNlcnZpY2UiLCJfaXNSZWFkeSIsImF2YWlsYWJsZVZvaWNlcyIsImF2YWlsYWJsZUxhbmd1YWdlcyIsImF2YWlsYWJsZUxhbmd1YWdlQ29kZXMiLCJtaW5OZXVyYWxTZGsiLCJkZXNjcmliZVZvaWNlcyIsInJlc3BvbnNlIiwiYWxsQ29kZXMiLCJWb2ljZXMiLCJjb2RlIiwicmVhZHkiLCJjdXJyZW50VXNlckFnZW50Iiwic3VtZXJpYW5Ib3N0c1VzZXJBZ2VudCIsImNvbmNhdCIsIkxleGljb25OYW1lcyIsIl9lbmFibGVkIiwiX3NldEF1ZGlvQ29udGV4dCIsIl9vYnNlcnZlQXVkaW9Db250ZXh0IiwiX2F1ZGlvQ29udGV4dCIsIkF1ZGlvQ29udGV4dCIsIm9uc3RhdGVjaGFuZ2UiLCJBdWRpbyIsImxvb3AiLCJjcm9zc09yaWdpbiIsInByZWxvYWQiLCJkb2N1bWVudCIsImJvZHkiLCJhcHBlbmRDaGlsZCIsImxvYWQiLCJyZXN1bWVBdWRpbyIsImVuYWJsZWQiLCJhbmltcGFjayIsImF3cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///437\n')}},__webpack_require__={d:(e,t)=>{for(var n in t)__webpack_require__.o(t,n)&&!__webpack_require__.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},__webpack_exports__={};return __webpack_modules__[437](0,__webpack_exports__,__webpack_require__),__webpack_exports__=__webpack_exports__.default,__webpack_exports__})()}));