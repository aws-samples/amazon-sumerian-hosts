/*! For license information please see host.core.js.LICENSE.txt */
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("HOST",[],t):"object"==typeof exports?exports.HOST=t():e.HOST=t()}("undefined"!=typeof self?self:"undefined"!=typeof global?global:this,(function(){return(()=>{"use strict";var __webpack_modules__={437:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "default": () => (/* binding */ core)\n});\n\n;// CONCATENATED MODULE: ./src/core/Deferred.js\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\n * The built-in class for asynchronous Promises.\n * @external Promise\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\n */\n\n/**\n * A Promise object that can be resolved, rejected or canceled at any time by the\n * user.\n *\n * @extends external:Promise\n */\nvar Deferred = /*#__PURE__*/function (_Promise) {\n  _inherits(Deferred, _Promise);\n\n  var _super = _createSuper(Deferred);\n\n  /**\n   * @constructor\n   *\n   * @param {Function} [executable=() => {}] - The function to be executed by the\n   * constructor, during the process of constructing the promise. The signature\n   * of this is expected to be: executable(  resolutionFunc, rejectionFunc, cancellationFunc ).\n   * @param {Function=} onResolve - Optional function to execute once the promise\n   * is resolved.\n   * @param {Function=} onReject - Optional function to execute once the promise\n   * is rejected.\n   * @param {Function=} onCancel - Optional function to execute if the user cancels\n   * the promise. Canceling results in the promise having a status of \'resolved\'.\n   */\n  function Deferred() {\n    var _this;\n\n    var executable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n    var onResolve = arguments.length > 1 ? arguments[1] : undefined;\n    var onReject = arguments.length > 2 ? arguments[2] : undefined;\n    var onCancel = arguments.length > 3 ? arguments[3] : undefined;\n\n    _classCallCheck(this, Deferred);\n\n    if (typeof executable !== \'function\') {\n      throw new Error("Cannot create new Deferred. Executable must be a function.");\n    }\n\n    if (typeof onResolve !== \'undefined\' && typeof onResolve !== \'function\') {\n      throw new Error("Cannot create new Deferred. OnResolve must be a function.");\n    }\n\n    if (typeof onReject !== \'undefined\' && typeof onReject !== \'function\') {\n      throw new Error("Cannot create new Deferred. OnReject must be a function.");\n    }\n\n    if (typeof onCancel !== \'undefined\' && typeof onCancel !== \'function\') {\n      throw new Error("Cannot create new Deferred. OnCancel must be a function.");\n    }\n\n    var res;\n    var rej;\n    var cancel;\n    var status = {\n      resolved: false,\n      rejected: false,\n      canceled: false,\n      pending: true\n    };\n    _this = _super.call(this, function (resolve, reject) {\n      // Store the resolver\n      res = function res(value) {\n        if (status.pending) {\n          status.resolved = true;\n          status.pending = false;\n\n          if (typeof onResolve === \'function\') {\n            value = onResolve(value);\n          }\n\n          return resolve(value);\n        }\n      }; // Store the rejecter\n\n\n      rej = function rej(value) {\n        if (status.pending) {\n          status.rejected = true;\n          status.pending = false;\n\n          if (typeof onReject === \'function\') {\n            value = onReject(value);\n          }\n\n          return reject(value);\n        }\n      }; // Store the canceler\n\n\n      cancel = function cancel(value) {\n        if (status.pending) {\n          status.canceled = true;\n          status.pending = false;\n\n          if (typeof onCancel === \'function\') {\n            value = onCancel(value);\n          }\n\n          return resolve(value);\n        }\n      }; // Run the executable with custom resolver and rejecter\n\n\n      executable(res, rej, cancel);\n    });\n    _this._status = status;\n    _this._resolve = res;\n    _this._reject = rej;\n    _this._cancel = cancel;\n    _this._executable = executable;\n    return _this;\n  }\n  /**\n   * Gets the resolved state of the promise.\n   *\n   * @readonly\n   */\n\n\n  _createClass(Deferred, [{\n    key: "resolved",\n    get: function get() {\n      return this._status.resolved;\n    }\n    /**\n     * Gets the rejected state of the promise.\n     *\n     * @readonly\n     */\n\n  }, {\n    key: "rejected",\n    get: function get() {\n      return this._status.rejected;\n    }\n    /**\n     * Gets the canceled state of the promise.\n     *\n     * @readonly\n     */\n\n  }, {\n    key: "canceled",\n    get: function get() {\n      return this._status.canceled;\n    }\n    /**\n     * Gets the pending state of the promise.\n     *\n     * @readonly\n     */\n\n  }, {\n    key: "pending",\n    get: function get() {\n      return this._status.pending;\n    }\n    /**\n     * Force the promise to resolve.\n     *\n     * @param {any=} value - Value to pass to the resolver.\n     *\n     * @returns {any} - The return value of the resolver function.\n     */\n\n  }, {\n    key: "resolve",\n    value: function resolve(value) {\n      return this._resolve(value);\n    }\n    /**\n     * Force the promise to reject.\n     *\n     * @param {any=} value - Value to pass to the rejecter.\n     *\n     * @returns {any} - The return value of the rejecter function.\n     */\n\n  }, {\n    key: "reject",\n    value: function reject(value) {\n      return this._reject(value);\n    }\n    /**\n     * Force the promise to resolve and set the canceled state to true.\n     *\n     * @param {any=} value - Value to pass to the canceller.\n     *\n     * @returns {any} - The return value of the canceller function.\n     */\n\n  }, {\n    key: "cancel",\n    value: function cancel(value) {\n      return this._cancel(value);\n    }\n    /**\n     * Run the promise function to try to resolve the promise. Promise must be\n     * pending.\n     *\n     * @param {...any} args - Optional arguments to pass after resolve and reject.\n     */\n\n  }, {\n    key: "execute",\n    value: function execute() {\n      if (this.pending) {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        this._executable.apply(this, [this._resolve, this._reject, this._cancel].concat(args));\n      }\n    }\n    /**\n     * Return a canceled deferred promise.\n     *\n     * @param {any=} value - Value to cancel the promise with.\n     *\n     * @returns {Deferred}\n     */\n\n  }], [{\n    key: "cancel",\n    value: function cancel(value) {\n      return new Deferred(function (_resolve, _reject, cancel) {\n        cancel(value);\n      });\n    }\n    /**\n     * Return a new Deferred promise that will resolve or reject once all promises\n     * in the input array have been resolved or one promise is canceled or rejected.\n     * Promises in the array that are Deferred promises will be manually resolved,\n     * rejected or canceled when calling resolve, reject or cancel on the return promise.\n     *\n     * @param {Array.<any>} iterable - An iterable such as an array.\n     * @param {Function=} onResolve - Optional function to execute once the promise\n     * is resolved.\n     * @param {Function=} onReject - Optional function to execute once the promise\n     * is rejected.\n     * @param {Function=} onCancel - Optional function to execute if the user cancels\n     * the promise. Canceling results in the promise having a status of \'canceled\'.\n     *\n     * @returns Deferred\n     */\n\n  }, {\n    key: "all",\n    value: function all(iterable, onResolve, onReject, onCancel) {\n      if (iterable == null || typeof iterable[Symbol.iterator] !== \'function\') {\n        var e = "Cannot execute Deferred.all. First argument must be iterable.";\n\n        if (typeof onReject === \'function\') {\n          e = onReject(e);\n        }\n\n        return Deferred.reject(e);\n      }\n\n      var array = _toConsumableArray(iterable);\n\n      var deferred = array.filter(function (item) {\n        return item instanceof Deferred;\n      });\n      var result = new Deferred(undefined, function (resolveValue) {\n        deferred.forEach(function (item) {\n          item.resolve(resolveValue);\n        });\n        deferred.length = 0;\n\n        if (typeof onResolve === \'function\') {\n          return onResolve(resolveValue);\n        } else {\n          return resolveValue;\n        }\n      }, function (error) {\n        deferred.forEach(function (item) {\n          item.reject(error);\n        });\n        deferred.length = 0;\n\n        if (typeof onReject === \'function\') {\n          return onReject(error);\n        } else {\n          return error;\n        }\n      }, function (cancelValue) {\n        deferred.forEach(function (item) {\n          item.cancel(cancelValue);\n        });\n        deferred.length = 0;\n\n        if (typeof onCancel === \'function\') {\n          return onCancel(cancelValue);\n        } else {\n          return cancelValue;\n        }\n      });\n      var numItems = array.length;\n      var itemTracker = {\n        failed: false,\n        numResolved: 0,\n        resolutions: []\n      };\n      array.forEach(function (item, index) {\n        if (itemTracker.failed) {\n          return;\n        } else if (!(item instanceof Promise)) {\n          itemTracker.resolutions[index] = item;\n          itemTracker.numResolved += 1;\n\n          if (itemTracker.numResolved === numItems) {\n            result.resolve(itemTracker.resolutions);\n          }\n\n          return;\n        }\n\n        item.then(function (value) {\n          if (!itemTracker.failed && !item.canceled) {\n            itemTracker.resolutions[index] = value;\n            itemTracker.numResolved += 1;\n\n            if (itemTracker.numResolved === numItems) {\n              result.resolve(itemTracker.resolutions);\n            }\n          } else if (!itemTracker.failed) {\n            itemTracker.failed = true;\n            result.cancel(value);\n          }\n        }, function (error) {\n          if (!itemTracker.failed) {\n            itemTracker.failed = true;\n            result.reject(error);\n          }\n        });\n      });\n      return result;\n    }\n  }]);\n\n  return Deferred;\n}( /*#__PURE__*/_wrapNativeSuper(Promise));\n\n/* harmony default export */ const core_Deferred = (Deferred);\n;// CONCATENATED MODULE: ./src/core/Utils.js\nfunction Utils_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Utils_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Utils_createClass(Constructor, protoProps, staticProps) { if (protoProps) Utils_defineProperties(Constructor.prototype, protoProps); if (staticProps) Utils_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\n * A collection of useful generic functions.\n *\n * @hideconstructor\n */\n\nvar Utils = /*#__PURE__*/function () {\n  function Utils() {\n    Utils_classCallCheck(this, Utils);\n  }\n\n  Utils_createClass(Utils, null, [{\n    key: "createId",\n    value:\n    /**\n     * @static\n     *\n     * Generate a unique id\n     *\n     * @returns {String}\n     */\n    function createId() {\n      return \'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx\'.replace(/[xy]/g, function (c) {\n        var randomNumber = Math.floor((Date.now() + Math.random() * 16) % 16);\n\n        if (c === \'x\') {\n          return randomNumber.toString(16);\n        } // Set bit 6 and 7 to 0 and 1\n\n\n        return (randomNumber & 0x3 | 0x8).toString(16);\n      });\n    }\n    /**\n     * @static\n     *\n     * Check a name string against an array of strings to determine if it is unique.\n     * If it isn\'t, append incremented trailing integers to the end of the name\n     * until it is unique.\n     *\n     * @param {string} name - String name to make unique.\n     * @param {Array.<string>=} nameArray - Array of string names to check agains.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: "getUniqueName",\n    value: function getUniqueName(name) {\n      var nameArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n      // If the name isn\'t in the array return it right away\n      if (!nameArray.includes(name)) {\n        return name;\n      }\n\n      var nameSet = new Set(nameArray); // Separate the name into string and trailing numbers\n\n      var matchGroup = name.match(/\\d*$/);\n      var index = matchGroup.index;\n      var baseName = name.slice(0, index);\n      var increment = Number(matchGroup[0]); // Find the highest trailing number value for the base of the name\n\n      nameSet.forEach(function (setName) {\n        var setMatchGroup = setName.match(/\\d*$/);\n\n        if (setName.slice(0, setMatchGroup.index) === baseName) {\n          var setIncrement = Number(setMatchGroup[0]);\n\n          if (setIncrement > increment) {\n            increment = setIncrement;\n          }\n        }\n      }); // Increment the highest trailing number and append to the name\n\n      return "".concat(baseName).concat(increment + 1);\n    }\n    /**\n     * Return a deferred promise that will wait a given number of seconds before\n     * resolving. Pass delta time in milliseconds to the deferred promise\'s execute\n     * method in an update loop to progress time.\n     *\n     * @param {number} [seconds=0] - Number of seconds to wait before resolving.\n     * @param {Object=} options - Optional options object\n     * @param {Function} [options.onFinish] - Callback to execute once the wait time\n     * is met.\n     * @param {Function=} options.onProgress - Callback to execute each time the wait\n     * time progresses towards the target number of seconds. The amount of progress\n     * as a 0-1 percentage is passed as an argument.\n     * @param {Function=} options.onCancel - Callback to execute if the user cancels\n     * the wait before completion.\n     * @param {Function=} options.onError - Callback to execute if the wait stops\n     * because an error is encountered. The error message is passed as a parameter.\n     *\n     * @returns {Deferred}\n     */\n\n  }, {\n    key: "wait",\n    value: function wait() {\n      var seconds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          onFinish = _ref.onFinish,\n          onProgress = _ref.onProgress,\n          onCancel = _ref.onCancel,\n          onError = _ref.onError;\n\n      // Make sure seconds is numeric\n      if (typeof seconds !== \'number\') {\n        console.warn("Invalid seconds value ".concat(seconds, " for wait. Defaulting to 0."));\n        seconds = 0;\n      } // Resolve immediately if the wait time is not greater than 0\n\n\n      if (seconds <= 0) {\n        if (typeof onFinish === \'function\') {\n          onFinish();\n        }\n\n        return core_Deferred.resolve();\n      }\n\n      var currentTime = 0;\n      var totalTime = seconds * 1000; // convert to milliseconds\n      // Executable to pass to Deferred, meant to be run in an update loop\n\n      var onUpdate = function onUpdate(resolve, reject, _cancel) {\n        var deltaTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n        if (typeof deltaTime !== \'number\') {\n          var e = new Error("Invalid property wait deltaTime. DeltaTime must be a number.");\n          reject(e);\n          return;\n        } // Make sure time has passed\n\n\n        if (deltaTime === 0) {\n          return;\n        } // Signal progress\n\n\n        currentTime += deltaTime;\n\n        if (currentTime < 0) {\n          currentTime = 0;\n        }\n\n        if (typeof onProgress === \'function\') {\n          onProgress(Math.min(currentTime / totalTime, 1));\n        } // Signal completion once time is up\n\n\n        if (currentTime >= totalTime) {\n          resolve();\n        }\n      };\n\n      return new core_Deferred(onUpdate, onFinish, onError, onCancel);\n    }\n    /**\n     * Get a random float number between a min (inclusive) and max (exclusive) value\n     * @param {number} min minimum value\n     * @param {number} max maximum value\n     * @returns {float}\n     */\n\n  }, {\n    key: "getRandomFloat",\n    value: function getRandomFloat(min, max) {\n      return Math.random() * (max - min) + min;\n    }\n    /**\n     * Get a random integer number between a min (inclusive) and max (exclusive) value\n     * @param {number} min minimum value\n     * @param {number} max maximum value\n     * @returns {integer}\n     */\n\n  }, {\n    key: "getRandomInt",\n    value: function getRandomInt(min, max) {\n      min = Math.ceil(min);\n      max = Math.floor(max);\n      return Math.floor(Math.random() * (max - min)) + min;\n    }\n  }]);\n\n  return Utils;\n}();\n\n/* harmony default export */ const core_Utils = (Utils);\n;// CONCATENATED MODULE: ./src/core/MathUtils.js\nfunction MathUtils_toConsumableArray(arr) { return MathUtils_arrayWithoutHoles(arr) || MathUtils_iterableToArray(arr) || MathUtils_unsupportedIterableToArray(arr) || MathUtils_nonIterableSpread(); }\n\nfunction MathUtils_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction MathUtils_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return MathUtils_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return MathUtils_arrayLikeToArray(o, minLen); }\n\nfunction MathUtils_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction MathUtils_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return MathUtils_arrayLikeToArray(arr); }\n\nfunction MathUtils_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction MathUtils_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction MathUtils_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction MathUtils_createClass(Constructor, protoProps, staticProps) { if (protoProps) MathUtils_defineProperties(Constructor.prototype, protoProps); if (staticProps) MathUtils_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\nvar RadianToDegree = 180 / Math.PI;\nvar DegreeToRadian = Math.PI / 180;\n/**\n * A collection of useful math functions.\n *\n * @hideconstructor\n */\n\nvar MathUtils = /*#__PURE__*/function () {\n  function MathUtils() {\n    MathUtils_classCallCheck(this, MathUtils);\n  }\n\n  MathUtils_createClass(MathUtils, null, [{\n    key: "toDegrees",\n    value:\n    /**\n     * Convert the given angle from radians to degrees.\n     *\n     * @param {number} radians - Angle in radians.\n     *\n     * @returns {number} - Angle in degrees.\n     */\n    function toDegrees(radians) {\n      return radians * RadianToDegree;\n    }\n    /**\n     * Convert the given angle from degrees to radians.\n     *\n     * @param {number} degrees - Angle in degrees.\n     *\n     * @returns {number} - Angle in radians.\n     */\n\n  }, {\n    key: "toRadians",\n    value: function toRadians(degrees) {\n      return degrees * DegreeToRadian;\n    }\n    /**\n     * Linearly interpolate between two values.\n     *\n     * @param {number} from - Start value.\n     * @param {number} to - Target value.\n     * @param {number} factor - 0-1 amount to interpolate between from and to.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: "lerp",\n    value: function lerp(from, to, factor) {\n      return from + (to - from) * factor;\n    }\n    /**\n     * Clamp a number between 2 values.\n     *\n     * @param {number} value - Value to clamp.\n     * @param {number} [min=0] - Minumum value.\n     * @param {number} [max=1] - Maximum value.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: "clamp",\n    value: function clamp(value) {\n      var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      return Math.max(min, Math.min(value, max));\n    }\n    /**\n     * Calculates the closest point on a given 2D line segement\n     * from a given 2D point.\n     *\n     * @param {Array.<number>} a - First point on line segment.\n     * @param {Array.<number>} b - Second point on line segment.\n     * @param {Array.<number>} p - 2D point.\n     *\n     * @returns {Array.<number>}\n     */\n\n  }, {\n    key: "closestPointOnLine",\n    value: function closestPointOnLine(a, b, p) {\n      var distSqr = MathUtils.distanceSquared(a, b); // Line segment is a single point\n\n      if (distSqr === 0) {\n        return a;\n      }\n\n      var t = ((p[0] - a[0]) * (b[0] - a[0]) + (p[1] - a[1]) * (b[1] - a[1])) / distSqr;\n\n      var point = MathUtils_toConsumableArray(a);\n\n      if (t > 1) {\n        point = MathUtils_toConsumableArray(b);\n      } else if (t > 0) {\n        point = [a[0] + t * (b[0] - a[0]), a[1] + t * (b[1] - a[1])];\n      }\n\n      return point;\n    }\n    /**\n     * Gets the distance squared for two 2D points.\n     * @param {Array.<number>} a - 2D point.\n     * @param {Array.<number>} b - 2D point.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: "distanceSquared",\n    value: function distanceSquared(a, b) {\n      return (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]);\n    }\n    /**\n     * Triangulates a set of 2D points using an implementation\n     * of the Bowyer-Watson incremental Delaunay triangulation.\n     *\n     * @param {Array.<Array.<number>>} vertices - Array of 2D points.\n     *\n     * @returns {Array.<Array<number>>} - Array of triangle indices.\n     */\n\n  }, {\n    key: "getDelaunayTriangulation",\n    value: function getDelaunayTriangulation(vertices) {\n      if (!vertices || vertices.length < 3) {\n        throw new Error("Cannot get delaunay triangulation for points ".concat(vertices, ". Input must contain at least three points."));\n      }\n\n      var minX = Number.POSITIVE_INFINITY;\n      var minY = Number.POSITIVE_INFINITY;\n      var maxX = Number.NEGATIVE_INFINITY;\n      var maxY = Number.NEGATIVE_INFINITY;\n      vertices.forEach(function (v) {\n        minX = v[0] < minX ? v[0] : minX;\n        minY = v[1] < minY ? v[1] : minY;\n        maxX = v[0] > maxX ? v[0] : maxX;\n        maxY = v[1] > maxY ? v[1] : maxY;\n      });\n      var dX = maxX - minX;\n      var dY = maxY - minY;\n      var midX = (minX + maxX) / 2;\n      var midY = (minY + maxY) / 2;\n      var dMax = dX > dY ? dX : dY;\n      var superIndices = [vertices.length, vertices.length + 1, vertices.length + 2];\n      var vertsWithSuper = [].concat(MathUtils_toConsumableArray(vertices), [[midX - 20 * dMax, midY - dMax], [midX, midY + 20 * dMax], [midX + 20 * dMax, midY - dMax]]);\n      var superSortedIndices = MathUtils.sortPointsCCW(superIndices, vertsWithSuper);\n      var superTriangle = {\n        indices: superSortedIndices,\n        edges: [[superSortedIndices[0], superSortedIndices[1]], [superSortedIndices[1], superSortedIndices[2]], [superSortedIndices[2], superSortedIndices[0]]]\n      };\n      var triangles = [superTriangle];\n      vertsWithSuper.forEach(function (newVert, newIndex) {\n        var invalidTriangles = [];\n        triangles.forEach(function (triangle) {\n          if (MathUtils.isPointInCircumCircle(vertsWithSuper[triangle.indices[0]], vertsWithSuper[triangle.indices[1]], vertsWithSuper[triangle.indices[2]], newVert)) {\n            invalidTriangles.push(triangle);\n          }\n        });\n        var boundingPoly = [];\n        invalidTriangles.forEach(function (triangle) {\n          triangle.edges.forEach(function (edge) {\n            var count = 0;\n            invalidTriangles.forEach(function (otherTriangle) {\n              if (triangle !== otherTriangle) {\n                otherTriangle.edges.forEach(function (otherEdge) {\n                  if (edge[0] === otherEdge[0] && edge[1] === otherEdge[1] || edge[1] === otherEdge[0] && edge[0] === otherEdge[1]) {\n                    count += 1;\n                  }\n                });\n              }\n            });\n            if (count === 0) boundingPoly.push(edge);\n          });\n        });\n        invalidTriangles.forEach(function (triangle) {\n          triangles.splice(triangles.indexOf(triangle), 1);\n        });\n        boundingPoly.forEach(function (edge) {\n          var sortedIndices = MathUtils.sortPointsCCW([edge[0], edge[1], newIndex], vertsWithSuper);\n          triangles.push({\n            indices: sortedIndices,\n            edges: [[sortedIndices[0], sortedIndices[1]], [sortedIndices[1], sortedIndices[2]], [sortedIndices[2], sortedIndices[0]]]\n          });\n        });\n      });\n      var trianglesToRemove = [];\n      triangles.forEach(function (triangle) {\n        triangle.indices.forEach(function (index) {\n          if (superIndices.includes(index)) {\n            trianglesToRemove.push(triangle);\n          }\n        });\n      });\n      trianglesToRemove.forEach(function (triangle) {\n        var index = triangles.indexOf(triangle);\n\n        if (index !== -1) {\n          triangles.splice(index, 1);\n        }\n      });\n      return triangles.map(function (triangle) {\n        return triangle.indices;\n      });\n    }\n    /**\n     * Determines if a given 2D point is within the cicrumcircle\n     * defined by three 2D points. The triangle points must be in\n     * counter-clockwise order a -> b -> c.\n     *\n     * @param {Array.<number>} a - First triangle point.\n     * @param {Array.<number>} b - Second triangle point.\n     * @param {Array.<number>} c - Third triangle point.\n     * @param {Array.<number>} p - 2D point.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "isPointInCircumCircle",\n    value: function isPointInCircumCircle(a, b, c, p) {\n      var ax = a[0] - p[0];\n      var ay = a[1] - p[1];\n      var bx = b[0] - p[0];\n      var by = b[1] - p[1];\n      var cx = c[0] - p[0];\n      var cy = c[1] - p[1];\n      return (ax * ax + ay * ay) * (bx * cy - cx * by) - (bx * bx + by * by) * (ax * cy - cx * ay) + (cx * cx + cy * cy) * (ax * by - bx * ay) > 0;\n    }\n    /**\n     * Determines if a given 2D point is within a given triangle.\n     *\n     * @param {Array.<number>} a - First triangle point.\n     * @param {Array.<number>} b - Second triangle point.\n     * @param {Array.<number>} c - Third triangle point.\n     * @param {Array.<number>} p - 2D point.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "isPointInTriangle",\n    value: function isPointInTriangle(a, b, c, p) {\n      var denom = (b[1] - c[1]) * (a[0] - c[0]) + (c[0] - b[0]) * (a[1] - c[1]);\n      var aVal = ((b[1] - c[1]) * (p[0] - c[0]) + (c[0] - b[0]) * (p[1] - c[1])) / denom;\n      var bVal = ((c[1] - a[1]) * (p[0] - c[0]) + (a[0] - c[0]) * (p[1] - c[1])) / denom;\n      var cVal = 1 - aVal - bVal;\n      return aVal >= 0 && aVal <= 1 && bVal >= 0 && bVal <= 1 && cVal >= 0 && cVal <= 1;\n    }\n    /**\n     * Gets the sorted indices of a given set of 2D points in\n     * counter-clockwise order.\n     *\n     * @param {Array.<number>} indices - List of indices.\n     * @param {Array.<Array.<number>>} vertices - List of 2D points.\n     *\n     * @returns {Array.<Array.<number>>} - List of sorted indices.\n     */\n\n  }, {\n    key: "sortPointsCCW",\n    value: function sortPointsCCW(indices, vertices) {\n      var centroid = [0, 0];\n      indices.forEach(function (index) {\n        centroid[0] += vertices[index][0];\n        centroid[1] += vertices[index][1];\n      });\n      centroid[0] /= indices.length;\n      centroid[1] /= indices.length;\n      indices.sort(function (a, b) {\n        var bVal = Math.atan2(vertices[b][1] - centroid[1], vertices[b][0] - centroid[0]);\n        var aVal = Math.atan2(vertices[a][1] - centroid[1], vertices[a][0] - centroid[0]);\n        return aVal - bVal;\n      });\n      return indices;\n    }\n    /**\n     * Cacluates the area of a triangle\n     * @param {Array.<number>} a - First triangle point.\n     * @param {Array.<number>} b - Second triangle point.\n     * @param {Array.<number>} c - Third triangle point.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: "triangleArea",\n    value: function triangleArea(a, b, c) {\n      return Math.abs((a[0] * (b[1] - c[1]) + b[0] * (c[1] - a[1]) + c[0] * (a[1] - b[1])) * 0.5);\n    }\n    /**\n     * Return the magnitude of a given vector array.\n     *\n     * @param {Array.<number>} vector - Array consisting of numbers.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: "getVectorMagnitude",\n    value: function getVectorMagnitude(vector) {\n      if (!(vector instanceof Array)) {\n        throw new Error("Cannot get magnitude for vector ".concat(vector, ". Input must be an Array numbers."));\n      }\n\n      var reducer = function reducer(accumulator, currentValue) {\n        if (typeof currentValue !== \'number\') {\n          throw new Error("Cannot get magnitude for vector ".concat(vector, ". All items in the input Array must be numbers."));\n        }\n\n        return accumulator + Math.pow(currentValue, 2);\n      };\n\n      return Math.sqrt(vector.reduce(reducer, 0));\n    }\n    /**\n     * Return the dot product between two vectors.\n     *\n     * @param {Array.<number>} vectorA - Array consisting of numbers.\n     * @param {Array.<number>} vectorB - Array consisting of numbers.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: "getDotProduct",\n    value: function getDotProduct(vectorA, vectorB) {\n      if (!(vectorA instanceof Array) || !(vectorB instanceof Array) || vectorA.length !== vectorB.length) {\n        throw new Error("Cannot get dot product between ".concat(vectorA, " and ").concat(vectorB, ". Inputs must be vectors of the same length."));\n      }\n\n      var result = 0;\n      vectorA.forEach(function (valueA, index) {\n        var valueB = vectorB[index];\n\n        if (typeof valueA !== \'number\' || typeof valueB !== \'number\') {\n          throw new Error("Cannot get dot product between ".concat(vectorA, " and ").concat(vectorB, ". Vectors must only consist of numeric values."));\n        }\n\n        result += valueA * valueB;\n      });\n      return result;\n    }\n    /**\n     * Return the angle in radians between vectorA and vectorB.\n     *\n     * @param {Array.<number>} vectorA - Array consisting of numbers.\n     * @param {Array.<number>} vectorB - Array consisting of numbers.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: "getAngleBetween",\n    value: function getAngleBetween(vectorA, vectorB) {\n      var normalA = this.normalizeVector(MathUtils_toConsumableArray(vectorA));\n      var normalB = this.normalizeVector(MathUtils_toConsumableArray(vectorB));\n      var dot = this.getDotProduct(normalA, normalB);\n      return Math.acos(this.clamp(dot, -1, 1));\n    }\n    /**\n     * Multiply a 3x3 rotation matrix with a vector3.\n     *\n     * @param {Array.<number>} vector3 - Array consisting of 3 numbers representing\n     * a direction vector.\n     * @param {Array.<number>} matrix3 - An array of 9 numbers representing a row\n     * major rotation matrix.\n     *\n     * @returns {Array.<number>} - An array of 3 numbers representing the new direction\n     * of the vector.\n     */\n\n  }, {\n    key: "rotateVector",\n    value: function rotateVector(vector3, matrix3) {\n      if (!(vector3 instanceof Array) || vector3.length !== 3 || !vector3.every(function (v) {\n        return typeof v === \'number\';\n      })) {\n        throw new Error("Cannot rotate vector ".concat(vector3, " by rotation matrix ").concat(matrix3, ". Input vector must be an array of 3 numbers."));\n      }\n\n      if (!(matrix3 instanceof Array) || matrix3.length !== 9 || !matrix3.every(function (v) {\n        return typeof v === \'number\';\n      })) {\n        throw new Error("Cannot rotate vector ".concat(vector3, " by rotation matrix ").concat(matrix3, ". Input matrix3 must be an array of 9 numbers."));\n      }\n\n      var x = matrix3[0] * vector3[0] + matrix3[3] * vector3[1] + matrix3[6] * vector3[2];\n      var y = matrix3[1] * vector3[0] + matrix3[4] * vector3[1] + matrix3[7] * vector3[2];\n      var z = matrix3[2] * vector3[0] + matrix3[5] * vector3[1] + matrix3[8] * vector3[2];\n      return [x, y, z];\n    }\n    /**\n     * Normalize a given vector array.\n     *\n     * @param {Array.<number>} vector - Array consisting of numbers.\n     *\n     * @returns {Array.<number>} The original vector with normalized values, for chaining.\n     */\n\n  }, {\n    key: "normalizeVector",\n    value: function normalizeVector(vector) {\n      var magnitude = this.getVectorMagnitude(vector);\n\n      if (magnitude === 0) {\n        vector.fill(0);\n      } else {\n        vector.forEach(function (value, index) {\n          vector[index] = value / magnitude;\n        });\n      }\n\n      return vector;\n    }\n    /**\n     * Extract the 3x3 rotation matrix from a given 4x4 transformation matrix.\n     *\n     * @param {Array.<number>} matrix4 - An array of 16 numbers representing a row\n     * major transformation matrix.\n     *\n     * @returns {Array.<number>} - An array of 9 numbers representing a row major\n     * rotation matrix.\n     */\n\n  }, {\n    key: "getRotationMatrix",\n    value: function getRotationMatrix(matrix4) {\n      if (!(matrix4 instanceof Array) || matrix4.length !== 16 || !matrix4.every(function (v) {\n        return typeof v === \'number\';\n      })) {\n        throw new Error("Cannot convert matrix ".concat(matrix4, " to a rotation matrix. Input matrix must be an array of 16 numbers."));\n      } // Extract scale\n\n\n      var scaleX = 1 / (this.getVectorMagnitude(matrix4.slice(0, 4)) || 1);\n      var scaleY = 1 / (this.getVectorMagnitude(matrix4.slice(4, 8)) || 1);\n      var scaleZ = 1 / (this.getVectorMagnitude(matrix4.slice(8, 12)) || 1);\n      return [matrix4[0] * scaleX, matrix4[1] * scaleX, matrix4[2] * scaleX, matrix4[4] * scaleY, matrix4[5] * scaleY, matrix4[6] * scaleY, matrix4[8] * scaleZ, matrix4[9] * scaleZ, matrix4[10] * scaleZ];\n    }\n    /**\n     * Return an array containing the spherical coordinates of the given cartesian\n     * xyz coordinates.\n     *\n     * @private\n     *\n     * @param {number} x - Position along the x axis.\n     * @param {number} y - Position along the y axis.\n     * @param {number} z - Position along the z axis.\n     *\n     * @returns {Array.<number>} - An array consisting of three numberes where index\n     * 0 represents the radius, index 1 represents the vertical/polar angle in radians\n     * and index 2 represents the horizontal/azimuthal angle in radians.\n     */\n\n  }, {\n    key: "cartesianToSpherical",\n    value: function cartesianToSpherical(x, y, z) {\n      var r = this.getVectorMagnitude([x, y, z]); // Return identity if the vector has no length\n\n      if (r === 0) {\n        return [0, 0, 0];\n      }\n\n      return [r, Math.acos(this.clamp(y / r, -1, 1)), Math.atan2(x, z)];\n    }\n    /**\n     * Gradually change a value of a numeric property towards a goal over time using\n     * a critically damped spring function.\n     *\n     * @param {number} currentValue - The starting value.\n     * @param {number} targetValue- The goal value.\n     * @param {Array.<number>} [valueStore = [0, 0]] - An Array consisting of two\n     * numbers where the first number holds the result value and the second holds\n     * the velocity that resulted in that value. The same array should be provided\n     * with each call to this function.\n     * @param {number} [deltaTime = 1e-7] - The time since the last call to this function\n     * in seconds.\n     * @param {number} [smoothTime = 0.3] - The approximate amount of time in seconds\n     * it should take to reach the target value.\n     * @param {number} [maxSpeed = 1e7] - A clamping value for the maximum speed the\n     * value can change.\n     *\n     * @returns {Array.<number>} - The valueStore array.\n     */\n\n  }, {\n    key: "dampValue",\n    value: function dampValue(currentValue, targetValue) {\n      var valueStore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0];\n      var deltaTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1e-7;\n      var smoothTime = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.3;\n      var maxSpeed = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1e7;\n      smoothTime = Math.max(0.0001, smoothTime);\n      deltaTime = Math.max(1e-7, deltaTime); // Find the delta between values and use it to estimate the previous value\n\n      var clampTime = maxSpeed * smoothTime;\n      var deltaValue = currentValue - targetValue;\n      var clampDeltaValue = this.clamp(deltaValue, -clampTime, clampTime);\n      var lastValue = currentValue - clampDeltaValue; // Calculate damping factors\n\n      var d1 = 2 / smoothTime;\n      var d2 = d1 * deltaTime;\n      var d3 = 1 / (1 + d2 + 0.5 * Math.pow(d2, 2) + 0.25 * Math.pow(d2, 3));\n      var d4 = (valueStore[1] + d1 * clampDeltaValue) * deltaTime; // Damp the target value and update the velocity\n\n      valueStore[0] = lastValue + (clampDeltaValue + d4) * d3;\n      valueStore[1] = (valueStore[1] - d1 * d4) * d3; // Prevent overshooting\n\n      if (targetValue - currentValue > 0 === valueStore[0] > targetValue) {\n        valueStore[0] = targetValue;\n        valueStore[1] = (valueStore[0] - targetValue) / deltaTime;\n      }\n\n      return valueStore;\n    }\n  }]);\n\n  return MathUtils;\n}();\n\n/* harmony default export */ const core_MathUtils = (MathUtils);\n;// CONCATENATED MODULE: ./src/core/HostEnvironment.js\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable import/prefer-default-export */\n\n/**\n * Indicates the type of host build.\n *\n * @type {string}\n */\nvar env = \'core\';\n\n;// CONCATENATED MODULE: ./src/core/Messenger.js\nfunction Messenger_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Messenger_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Messenger_createClass(Constructor, protoProps, staticProps) { if (protoProps) Messenger_defineProperties(Constructor.prototype, protoProps); if (staticProps) Messenger_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable no-underscore-dangle */\n\n/**\n * Class that can execute functions when local messages are received. Local messages\n * are prefixed with the instance\'s id.\n *\n * @alias core/Messenger\n *\n * @property {core/Messenger} GlobalMessenger - A messenger that can be used for\n * global messaging. When using static listen and emit methods they are executed\n * on this messenger.\n * @property {Object} EVENTS - Built-in events that the Messenger emits.\n */\n\nvar Messenger = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   *\n   * @param {any=} id - Id for the object. If none is provided a new id will\n   * be created. Id should be able to be represented as a string.\n   */\n  function Messenger(id) {\n    Messenger_classCallCheck(this, Messenger);\n\n    this._id = id !== undefined ? id : core_Utils.createId();\n    this._dispatcher = window;\n    this._callbacks = {};\n    this._eventListeners = {};\n  }\n  /**\n   * Gets the string id of the object.\n   *\n   * @readonly\n   * @type {string}\n   */\n\n\n  Messenger_createClass(Messenger, [{\n    key: "id",\n    get: function get() {\n      return this._id;\n    }\n    /**\n     * Prefix a message with the instance id.\n     *\n     * @private\n     *\n     * @param {string} message\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: "_createLocalMessage",\n    value: function _createLocalMessage(message) {\n      return "".concat(this.id, ".").concat(message);\n    }\n    /**\n     * Return a function that will call a callback function and supply the event\'s\n     * detail property as an argument.\n     *\n     * @private\n     *\n     * @param {Function} callback\n     *\n     * @returns {Function}\n     */\n\n  }, {\n    key: "_createListener",\n    value: function _createListener(callback) {\n      return function (e) {\n        var value;\n\n        if (e.detail !== null) {\n          value = e.detail;\n        }\n\n        callback(value);\n      };\n    }\n    /**\n     * Create an event object and send it to listeners.\n     *\n     * @private\n     *\n     * @param {string} message - Event type name.\n     * @param {any=} value - Value to send to listeners.\n     *\n     * @returns {CustomEvent}\n     */\n\n  }, {\n    key: "_createEvent",\n    value: function _createEvent(message, value) {\n      return new CustomEvent(message, {\n        detail: value\n      });\n    }\n    /**\n     * Register an event.\n     *\n     * @private\n     *\n     * @param {string} message - Event type name.\n     * @param {Function} listener - A listener function generated using _createListener.\n     */\n\n  }, {\n    key: "_addListener",\n    value: function _addListener(message, listener) {\n      this._dispatcher.addEventListener(this._createLocalMessage(message), listener);\n    }\n    /**\n     * Unregister an event.\n     *\n     * @private\n     *\n     * @param {string} message - Event type name.\n     * @param {Function} listener - A listener function generated using _createListener.\n     */\n\n  }, {\n    key: "_removeListener",\n    value: function _removeListener(message, listener) {\n      this._dispatcher.removeEventListener(this._createLocalMessage(message), listener);\n    }\n    /**\n     * Execute a function when a message is received for this object.\n     *\n     * @param {string} message - The message to listen for.\n     * @param {Function} callback - Function to execute once the message is received.\n     */\n\n  }, {\n    key: "listenTo",\n    value: function listenTo(message, callback) {\n      if (typeof callback !== \'function\') {\n        throw new Error("Cannot add listener for ".concat(message, " on ").concat(this.id, ". Callback must be a function."));\n      }\n\n      if (this._callbacks[message] === undefined) {\n        this._callbacks[message] = [];\n        this._eventListeners[message] = [];\n      }\n\n      var listener = this._createListener(callback);\n\n      this._callbacks[message].push(callback);\n\n      this._eventListeners[message].push(listener);\n\n      this._addListener(message, listener);\n    }\n    /**\n     * Prevent a function from being executed when a message is received for this\n     * object.\n     *\n     * @param {string} message - The message to stop listening for.\n     * @param {Function=} callback - Optional callback to remove. If none is defined,\n     * remove all callbacks for the message.\n     */\n\n  }, {\n    key: "stopListening",\n    value: function stopListening(message, callback) {\n      if (this._callbacks[message] === undefined) {\n        return;\n      } else if (callback === undefined) {\n        // If no callback was defined, call stopListening on all callbacks for the message\n        for (var i = this._callbacks[message].length - 1; i > -1; i--) {\n          this.stopListening(message, this._callbacks[message][i]);\n        }\n\n        return;\n      } // If a callback was defined, make sure it\'s a listener\n\n\n      var index = this._callbacks[message].indexOf(callback);\n\n      if (index === -1) {\n        return;\n      }\n\n      var listener = this._eventListeners[message][index];\n\n      this._removeListener(message, listener);\n\n      this._callbacks[message].splice(index, 1);\n\n      this._eventListeners[message].splice(index, 1);\n\n      if (this._callbacks[message].length === 0) {\n        delete this._callbacks[message];\n        delete this._eventListeners[message];\n      }\n    }\n    /**\n     * De-register callback(s) from being executed when messages matching the given\n     * regular expression are received.\n     *\n     * @param {Regexp} regexp - regexp - The regular expression to filter messages with.\n     * @param {Function=} callback - Optional callback to remove. If none is defined,\n     * remove all callbacks for messages matching the regular expression.\n     */\n\n  }, {\n    key: "stopListeningByRegexp",\n    value: function stopListeningByRegexp(regexp, callback) {\n      var _this = this;\n\n      var messages = Object.keys(this._callbacks).filter(function (message) {\n        return regexp.test(message);\n      });\n      messages.forEach(function (message) {\n        _this.stopListening(message, callback);\n      });\n    }\n    /**\n     * Prevent any functions from being executed when any message is received for\n     * this object.\n     */\n\n  }, {\n    key: "stopListeningToAll",\n    value: function stopListeningToAll() {\n      var messages = Object.keys(this._callbacks);\n\n      for (var i = messages.length - 1; i > -1; i--) {\n        this.stopListening(messages[i]);\n      }\n    }\n    /**\n     * Send a message, causing listener functions for the message on this object\n     * to be executed.\n     *\n     * @param {string} message - The message to emit.\n     * @param {any=} value - Optional argument to pass to listener callbacks.\n     */\n\n  }, {\n    key: "emit",\n    value: function emit(message, value) {\n      if (this._callbacks[message] === undefined) {\n        return;\n      }\n\n      message = this._createLocalMessage(message);\n\n      var event = this._createEvent(message, value);\n\n      this._dispatcher.dispatchEvent(event);\n    }\n    /**\n     * Execute a function when a message is received for the global Messenger instance.\n     *\n     * @static\n     *\n     * @param {string} message - The message to listen for.\n     * @param {Function} callback - Function to execute once the message is received.\n     */\n\n  }], [{\n    key: "listenTo",\n    value: function listenTo(message, callback, messenger) {\n      this.GlobalMessenger.listenTo(message, callback, messenger);\n    }\n    /**\n     * Prevent a function from being executed when a message is received for the\n     * global Messenger instance.\n     *\n     * @static\n     *\n     * @param {string} message - The message to stop listening for.\n     * @param {Function=} callback - Optional callback to remove. If none is defined,\n     * remove all callbacks for the message.\n     */\n\n  }, {\n    key: "stopListening",\n    value: function stopListening(message, callback) {\n      this.GlobalMessenger.stopListening(message, callback);\n    }\n    /**\n     * De-register callback(s) from being executed on the global messengerr instance\n     * when messages matching the given regular expression are received.\n     *\n     * @param {Regexp} regexp - regexp - The regular expression to filter messages with.\n     * @param {Function=} callback - Optional callback to remove. If none is defined,\n     * remove all callbacks for messages matching the regular expression.\n     */\n\n  }, {\n    key: "stopListeningByRegexp",\n    value: function stopListeningByRegexp(regexp, callback) {\n      var _this2 = this;\n\n      var messages = Object.keys(this.GlobalMessenger._callbacks).filter(function (message) {\n        return regexp.test(message);\n      });\n      messages.forEach(function (message) {\n        _this2.stopListening(message, callback);\n      });\n    }\n    /**\n     * Prevent any functions from being executed when any message is received for\n     * the global Messenger instance.\n     *\n     * @static\n     */\n\n  }, {\n    key: "stopListeningToAll",\n    value: function stopListeningToAll() {\n      this.GlobalMessenger.stopListeningToAll();\n    }\n    /**\n     * Send a message, causing listener functions for the message on the global Messenger\n     * instance to be executed.\n     *\n     * @static\n     *\n     * @param {string} message - The message to emit.\n     * @param {any=} value - Optional argument to pass to listener callbacks.\n     */\n\n  }, {\n    key: "emit",\n    value: function emit(message, value) {\n      this.GlobalMessenger.emit(message, value);\n    }\n  }]);\n\n  return Messenger;\n}();\n\nObject.defineProperties(Messenger, {\n  GlobalMessenger: {\n    value: new Messenger(),\n    writable: false\n  },\n  EVENTS: {\n    value: {},\n    writable: false\n  }\n});\n/* harmony default export */ const core_Messenger = (Messenger);\n;// CONCATENATED MODULE: ./src/core/AbstractHostFeature.js\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || AbstractHostFeature_unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction AbstractHostFeature_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return AbstractHostFeature_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return AbstractHostFeature_arrayLikeToArray(o, minLen); }\n\nfunction AbstractHostFeature_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction AbstractHostFeature_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AbstractHostFeature_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AbstractHostFeature_createClass(Constructor, protoProps, staticProps) { if (protoProps) AbstractHostFeature_defineProperties(Constructor.prototype, protoProps); if (staticProps) AbstractHostFeature_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\n * Base class for all host features. Keeps a reference to the host object managing\n * the feature.\n *\n * @abstract\n *\n * @property {Object} EVENTS - Built-in messages that the feature emits. When the\n * feature is added to a {@link core/HostObject}, event names will be prefixed by the\n * name of the feature class + \'.\'.\n * @property {string} [EVENTS.update=onUpdate] - Message that is emitted after\n * each call to [update]{@link AbstractHostFeature#update}.\n * @property {Object} SERVICES - Any AWS services that are necessary for the\n * feature to function.\n */\n\nvar AbstractHostFeature = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   *\n   * @param {core/HostObject} host - The HostObject managing the feature.\n   */\n  function AbstractHostFeature(host) {\n    AbstractHostFeature_classCallCheck(this, AbstractHostFeature);\n\n    this._host = host;\n  }\n  /**\n   * Adds a namespace to the host with the name of the feature to contain properties\n   * and methods from the feature that users of the host need access to.\n   */\n\n\n  AbstractHostFeature_createClass(AbstractHostFeature, [{\n    key: "installApi",\n    value: function installApi() {\n      var _this = this;\n\n      var events = {};\n      var api = {\n        EVENTS: events\n      }; // Add the class name to event names\n\n      Object.entries(this.constructor.EVENTS).forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            name = _ref2[0],\n            value = _ref2[1];\n\n        events[name] = "".concat(_this.constructor.name, ".").concat(value);\n      });\n      this._host[this.constructor.name] = api;\n      return api;\n    }\n    /**\n     * Gets the host that manages the feature.\n     *\n     * @readonly\n     */\n\n  }, {\n    key: "host",\n    get: function get() {\n      return this._host;\n    }\n    /**\n     * Gets the engine owner object of the host.\n     *\n     * @readonly\n     */\n\n  }, {\n    key: "owner",\n    get: function get() {\n      return this._host.owner;\n    }\n    /**\n     * Listen to a feature message from the host object.\n     *\n     * @param {string} message - Message to listen for.\n     * @param {Function} callback - The callback to execute when the message is received.\n     */\n\n  }, {\n    key: "listenTo",\n    value: function listenTo(message, callback) {\n      this._host.listenTo(message, callback);\n    }\n    /**\n     * Listen to a feature message from the global messenger. Feature messages will\n     * be prefixed with the class name of the feature.\n     *\n     * @param {string} message - Message to listen for.\n     * @param {Function} callback - The callback to execute when the message is received.\n     */\n\n  }, {\n    key: "stopListening",\n    value:\n    /**\n     * Stop listening to a message from the host object.\n     *\n     * @param {string} message - Message to stop listening for.\n     * @param {Function=} callback - Optional callback to remove. If none is defined,\n     * remove all callbacks for the message.\n     */\n    function stopListening(message, callback) {\n      this._host.stopListening(message, callback);\n    }\n    /**\n     * Stop listening to a message from the global messenger.\n     *\n     * @param {string} message - Message to stop listening for.\n     * @param {Function=} callback - Optional callback to remove. If none is defined,\n     * remove all callbacks for the message.\n     */\n\n  }, {\n    key: "stopListeningByRegexp",\n    value:\n    /**\n     * Stop listening to a message matching the given regular expression from the\n     * host object.\n     *\n     * @param {Regexp} regexp - The regular expression to stop listening for.\n     * @param {Function=} callback - Optional callback to remove. If none is defined,\n     * remove all callbacks for the message.\n     */\n    function stopListeningByRegexp(regexp, callback) {\n      this._host.stopListeningByRegexp(regexp, callback);\n    }\n    /**\n     * Stop listening to a message matching the given regular expression from the\n     * global messenger.\n     *\n     * @param {Regexp} regexp - The regular expression to stop listening for.\n     * @param {Function=} callback - Optional callback to remove. If none is defined,\n     * remove all callbacks for the message.\n     */\n\n  }, {\n    key: "stopListeningToAll",\n    value:\n    /**\n     * Stop listening to all messages.\n     */\n    function stopListeningToAll() {\n      this._host.stopListeningToAll();\n    }\n    /**\n     * Stop listening to all feature messages.\n     */\n\n  }, {\n    key: "emit",\n    value:\n    /**\n     * Emit feature messages from the host. Feature messages will be prefixed with\n     * the class name of the feature.\n     *\n     * @param {string} message - The message to emit.\n     * @param {any=} value - Optional parameter to pass to listener callbacks.\n     */\n    function emit(message, value) {\n      message = "".concat(this.constructor.name, ".").concat(message);\n\n      this._host.emit(message, value);\n    }\n    /**\n     * Emit feature messages from the global messenger. Feature messages will be prefixed\n     * with the class name of the feature.\n     *\n     * @param {string} message - The message to emit.\n     * @param {any=} value - Optional parameter to pass to listener callbacks.\n     */\n\n  }, {\n    key: "update",\n    value:\n    /**\n     * Executes each time the host is updated.\n     *\n     * @param {number} deltaTime - Amount of time since the last host update was\n     * called.\n     */\n    function update(deltaTime) {\n      this.emit(this.constructor.EVENTS.update, deltaTime);\n    }\n    /**\n     * Clean up once the feature is no longer in use. Remove the feature namespace\n     * from the host and remove reference to the host.\n     */\n\n  }, {\n    key: "discard",\n    value: function discard() {\n      var _this2 = this;\n\n      Object.keys(this._host[this.constructor.name]).forEach(function (name) {\n        delete _this2._host[_this2.constructor.name][name];\n      });\n      delete this._host[this.constructor.name];\n      delete this._host;\n    }\n    /**\n     * Applies a sequence of mixin class factory functions to this class and\n     * returns the result. Each function is expected to return a class that\n     * extends the class it was given. The functions are applied in the order\n     * that parameters are given, meaning that the first factory will\n     * extend this base class.\n     *\n     * @param {...Function} mixinClassFactories Class factory functions that will\n     * be applied.\n     *\n     * @returns {Class} A class that is the result of applying the factory functions.\n     * The resulting class will always inherit from AbstractHostFeature.\n     */\n\n  }], [{\n    key: "listenTo",\n    value: function listenTo(message, callback) {\n      message = "".concat(this.name, ".").concat(message);\n      core_Messenger.listenTo(message, callback);\n    }\n  }, {\n    key: "stopListening",\n    value: function stopListening(message, callback) {\n      message = "".concat(this.name, ".").concat(message);\n      core_Messenger.stopListening(message, callback);\n    }\n  }, {\n    key: "stopListeningByRegexp",\n    value: function stopListeningByRegexp(regexp, callback) {\n      regexp = new RegExp("^".concat(this.name, ".").concat(regexp.source.replace(/\\^/, \'\')));\n      core_Messenger.stopListeningByRegexp(regexp, callback);\n    }\n  }, {\n    key: "stopListeningToAll",\n    value: function stopListeningToAll() {\n      core_Messenger.stopListeningByRegexp(new RegExp("^".concat(this.name, ".")));\n    }\n  }, {\n    key: "emit",\n    value: function emit(message, value) {\n      message = "".concat(this.name, ".").concat(message);\n      core_Messenger.emit(message, value);\n    }\n  }, {\n    key: "mix",\n    value: function mix() {\n      var ResultClass = this;\n\n      for (var _len = arguments.length, mixinClassFactories = new Array(_len), _key = 0; _key < _len; _key++) {\n        mixinClassFactories[_key] = arguments[_key];\n      }\n\n      mixinClassFactories.forEach(function (mixinClassFactory) {\n        ResultClass = mixinClassFactory(ResultClass);\n      });\n      return ResultClass;\n    }\n  }]);\n\n  return AbstractHostFeature;\n}();\n\nObject.defineProperties(AbstractHostFeature, {\n  EVENTS: {\n    value: {\n      update: \'onUpdate\'\n    },\n    writable: false\n  },\n  SERVICES: {\n    value: {},\n    writable: false\n  }\n});\n/* harmony default export */ const core_AbstractHostFeature = (AbstractHostFeature);\n;// CONCATENATED MODULE: ./src/core/HostObject.js\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction HostObject_construct(Parent, args, Class) { if (HostObject_isNativeReflectConstruct()) { HostObject_construct = Reflect.construct; } else { HostObject_construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) HostObject_setPrototypeOf(instance, Class.prototype); return instance; }; } return HostObject_construct.apply(null, arguments); }\n\nfunction HostObject_typeof(obj) { "@babel/helpers - typeof"; return HostObject_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, HostObject_typeof(obj); }\n\nfunction HostObject_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction HostObject_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction HostObject_createClass(Constructor, protoProps, staticProps) { if (protoProps) HostObject_defineProperties(Constructor.prototype, protoProps); if (staticProps) HostObject_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction HostObject_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) HostObject_setPrototypeOf(subClass, superClass); }\n\nfunction HostObject_setPrototypeOf(o, p) { HostObject_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return HostObject_setPrototypeOf(o, p); }\n\nfunction HostObject_createSuper(Derived) { var hasNativeReflectConstruct = HostObject_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = HostObject_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = HostObject_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return HostObject_possibleConstructorReturn(this, result); }; }\n\nfunction HostObject_possibleConstructorReturn(self, call) { if (call && (HostObject_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return HostObject_assertThisInitialized(self); }\n\nfunction HostObject_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction HostObject_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction HostObject_getPrototypeOf(o) { HostObject_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return HostObject_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n/**\n * Object that manages access to all Host features. Contains a reference to\n * engine-specific visuals if applicable.\n *\n * @extends core/Messenger\n * @alias core/HostObject\n *\n * @property {Object} EVENTS - Built-in messages that the Messenger emits.\n * @property {string} [EVENTS.update=\'onUpdate\'] - Message that is emitted after\n * each call to [update]{@link core/HostObject#update}.\n * @property {string} [EVENTS.addFeature=\'onAddFeature\'] - Message that is emitted\n * after each call to [addFeature]{@link core/HostObject#addFeature}.\n * @property {string} [EVENTS.removeFeature=\'onRemoveFeature\'] - Message that is emitted\n * after each call to [removeFeature]{@link core/HostObject#removeFeature}.\n */\n\nvar HostObject = /*#__PURE__*/function (_Messenger) {\n  HostObject_inherits(HostObject, _Messenger);\n\n  var _super = HostObject_createSuper(HostObject);\n\n  /**\n   * @constructor\n   *\n   * @param {Object=} options - Options for the host.\n   * @param {Object=} options.owner - Optional engine-specific owner of the host.\n   */\n  function HostObject() {\n    var _this;\n\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$owner = _ref.owner,\n        owner = _ref$owner === void 0 ? {} : _ref$owner;\n\n    HostObject_classCallCheck(this, HostObject);\n\n    // If an owner is specified, use its id for messaging\n    _this = _super.call(this, owner.id);\n    _this._owner = owner;\n    _this._features = {};\n    _this._waits = [];\n    _this._lastUpdate = _this.now;\n    return _this;\n  }\n  /**\n   * Gets the engine owner object of the host.\n   *\n   * @readonly\n   * @type {Object}\n   */\n\n\n  HostObject_createClass(HostObject, [{\n    key: "owner",\n    get: function get() {\n      return this._owner;\n    }\n    /**\n     * Gets the current time in milliseconds.\n     *\n     * @readonly\n     * @type {number}\n     */\n\n  }, {\n    key: "now",\n    get: function get() {\n      return Date.now();\n    }\n    /**\n     * Gets the amount of time in milliseconds since update was last called.\n     *\n     * @readonly\n     * @type {number}\n     */\n\n  }, {\n    key: "deltaTime",\n    get: function get() {\n      return this.now - this._lastUpdate;\n    }\n    /**\n     * This function should be called in the engine\'s render loop. Executes update\n     * loops for all features.\n     */\n\n  }, {\n    key: "update",\n    value: function update() {\n      var currentTime = this.now;\n      var dt = this.deltaTime; // Progress stored waits\n\n      this._waits.forEach(function (wait) {\n        wait.execute(dt);\n      }); // Update all features\n\n\n      Object.values(this._features).forEach(function (feature) {\n        feature.update(dt);\n      }); // Notify listeners an update occured\n\n      this.emit(this.constructor.EVENTS.update, dt);\n      this._lastUpdate = currentTime;\n    }\n    /**\n     * Return a deferred promise that will wait a given number of seconds before\n     * resolving. The host will continuously update the wait promise during the\n     * update loop until it resolves.\n     *\n     * @param {number} [seconds=0] - Number of seconds to wait before resolving.\n     * @param {Object=} options - Optional options object\n     * @param {Function} [options.onFinish] - Callback to execute once the wait time\n     * is met.\n     * @param {Function=} options.onProgress - Callback to execute each time the wait\n     * time progresses towards the target number of seconds. The amount of progress\n     * as a 0-1 percentage is passed as an argument.\n     * @param {Function=} options.onCancel - Callback to execute if the user cancels\n     * the wait before completion.\n     * @param {Function=} options.onError - Callback to execute if the wait stops\n     * because an error is encountered. The error message is passed as a parameter.\n     *\n     * @returns {Deferred}\n     */\n\n  }, {\n    key: "wait",\n    value: function wait(seconds) {\n      var _this2 = this;\n\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          onFinish = _ref2.onFinish,\n          onProgress = _ref2.onProgress,\n          onCancel = _ref2.onCancel,\n          onError = _ref2.onError;\n\n      var wait = core_Utils.wait(seconds, {\n        onFinish: onFinish,\n        onProgress: onProgress,\n        onCancel: onCancel,\n        onError: onError\n      });\n\n      this._waits.push(wait); // Once the wait promise is no longer pending remove it from the waits array\n\n\n      var onComplete = function onComplete() {\n        _this2._waits.splice(_this2._waits.indexOf(wait), 1);\n      };\n\n      wait.then(onComplete, onComplete);\n      return wait;\n    }\n    /**\n     * Instantiate a new Host feature and store it. Features must inherit from\n     * AbstractHostFeature.\n     *\n     * @param {Class} FeatureClass - Class that will instantiate the feature. Must\n     * extend {@link AbstractHostFeature}.\n     * @param {boolean} [force=false] - Whether or not to overwrite an existing\n     * feature if one of this type already exists on the object.\n     * @param  {...any} args - Additional arguments to pass to the FeatureClass\n     * constructor. The HostObject will always be passed as the first argument.\n     *\n     * @returns {boolean} - Whether or not a feature was successfully added.\n     */\n\n  }, {\n    key: "addFeature",\n    value: function addFeature(FeatureClass) {\n      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      var inputType = HostObject_typeof(FeatureClass); // Make sure the FeatureClass can be executed\n\n\n      if (inputType !== \'function\') {\n        throw new Error("Cannot add feature to host ".concat(this.id, ". FeatureClass must be a class."));\n      } // Make sure the feature is a host feature\n      else if (!(FeatureClass.prototype instanceof core_AbstractHostFeature)) {\n        throw new Error("Cannot add feature ".concat(FeatureClass.name, " to host ").concat(this.id, ". FeatureClass must extend AbstractHostFeature."));\n      } // Check if the FeatureClass already exists on this object\n\n\n      if (this._features[FeatureClass.name] !== undefined) {\n        if (force) {\n          console.warn("Feature ".concat(FeatureClass.name, " already exists on host ").concat(this.id, ". Existing feature will be overwritten."));\n        } else {\n          throw new Error("Feature ".concat(FeatureClass.name, " already exists on host ").concat(this.id, ". Use \'force\' argument to overwrite the feature."));\n        }\n      } // Initialize the feature\n\n\n      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n      }\n\n      var feature = HostObject_construct(FeatureClass, [this].concat(args));\n\n      feature.installApi();\n      this._features[FeatureClass.name] = feature;\n      this.emit(this.constructor.EVENTS.addFeature, FeatureClass.name);\n      return true;\n    }\n    /**\n     * Remove a feature from the object.\n     *\n     * @param {string} typeName - Name of the type of feature to remove.\n     *\n     * @returns {boolean} - Whether or not a feature was successfully removed.\n     */\n\n  }, {\n    key: "removeFeature",\n    value: function removeFeature(typeName) {\n      if (this._features[typeName] === undefined) {\n        console.warn("Feature of type ".concat(typeName, " does not exist on host ").concat(this.id, ". No feature will be removed."));\n        return false;\n      } else {\n        // Remove the feature\n        this.emit(this.constructor.EVENTS.removeFeature, typeName);\n\n        this._features[typeName].discard();\n\n        delete this._features[typeName];\n        return true;\n      }\n    }\n    /**\n     * Indicate whether a specified feature is installed on the host.\n     *\n     * @param {string} typeName - Name of the type of feature to look for.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "hasFeature",\n    value: function hasFeature(typeName) {\n      return !!this._features[typeName];\n    }\n    /**\n     * List the names of the features installed on the host.\n     *\n     * @returns {Array.<string>}\n     */\n\n  }, {\n    key: "listFeatures",\n    value: function listFeatures() {\n      return Object.keys(this._features);\n    }\n  }]);\n\n  return HostObject;\n}(core_Messenger);\n\nObject.defineProperty(HostObject, \'EVENTS\', {\n  value: _objectSpread(_objectSpread({}, Object.getPrototypeOf(HostObject).EVENTS), {}, {\n    update: \'onUpdate\',\n    addFeature: \'onAddFeature\',\n    removeFeature: \'onRemoveFeature\'\n  }),\n  writable: false\n});\n/* harmony default export */ const core_HostObject = (HostObject);\n;// CONCATENATED MODULE: ./src/core/animpack/Easing.js\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\n * @typedef {Object} EasingObject Object containing easing functions\n * @property {Function} In - Easing \'In\' function. Should use the signature (k:number):number.\n * @property {Function} Out - Easing \'Out\' function. Should use the signature (k:number):number.\n * @property {Function} InOut - Easing \'InOut\' function. Should use the signature (k:number):number.\n */\n\n/**\n * Linear Easing\n * @type {EasingObject}\n */\nvar Linear = {\n  None: function None(k) {\n    return k;\n  },\n  In: function In(k) {\n    return k;\n  },\n  Out: function Out(k) {\n    return k;\n  },\n  InOut: function InOut(k) {\n    return k;\n  }\n};\n/**\n * Quadratic Easing\n * @type {EasingObject}\n */\n\nvar Quadratic = {\n  In: function In(k) {\n    return k * k;\n  },\n  Out: function Out(k) {\n    return k * (2 - k);\n  },\n  InOut: function InOut(k) {\n    k *= 2;\n\n    if (k < 1) {\n      return 0.5 * k * k;\n    }\n\n    return -0.5 * (--k * (k - 2) - 1);\n  }\n};\n/**\n * Cubic Easing\n * @type {EasingObject}\n */\n\nvar Cubic = {\n  In: function In(k) {\n    return k * k * k;\n  },\n  Out: function Out(k) {\n    return --k * k * k + 1;\n  },\n  InOut: function InOut(k) {\n    k *= 2;\n\n    if (k < 1) {\n      return 0.5 * k * k * k;\n    }\n\n    k -= 2;\n    return 0.5 * (k * k * k + 2);\n  }\n};\n/**\n * Quartic Easing\n * @type {EasingObject}\n */\n\nvar Quartic = {\n  In: function In(k) {\n    return k * k * k * k;\n  },\n  Out: function Out(k) {\n    return 1 - --k * k * k * k;\n  },\n  InOut: function InOut(k) {\n    k *= 2;\n\n    if (k < 1) {\n      return 0.5 * k * k * k * k;\n    }\n\n    k -= 2;\n    return -0.5 * (k * k * k * k - 2);\n  }\n};\n/**\n * Quintic Easing\n * @type {EasingObject}\n */\n\nvar Quintic = {\n  In: function In(k) {\n    return k * k * k * k * k;\n  },\n  Out: function Out(k) {\n    return --k * k * k * k * k + 1;\n  },\n  InOut: function InOut(k) {\n    k *= 2;\n\n    if (k < 1) {\n      return 0.5 * k * k * k * k * k;\n    }\n\n    k -= 2;\n    return 0.5 * (k * k * k * k * k + 2);\n  }\n};\n/**\n * Sinusoidal Easing\n * @type {EasingObject}\n */\n\nvar Sinusoidal = {\n  In: function In(k) {\n    return 1 - Math.cos(k * Math.PI / 2);\n  },\n  Out: function Out(k) {\n    return Math.sin(k * Math.PI / 2);\n  },\n  InOut: function InOut(k) {\n    return 0.5 * (1 - Math.cos(Math.PI * k));\n  }\n};\n/**\n * Exponential Easing\n * @type {EasingObject}\n */\n\nvar Exponential = {\n  In: function In(k) {\n    return k === 0 ? 0 : Math.pow(1024, k - 1);\n  },\n  Out: function Out(k) {\n    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n  },\n  InOut: function InOut(k) {\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    k *= 2;\n\n    if (k < 1) {\n      return 0.5 * Math.pow(1024, k - 1);\n    }\n\n    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n  }\n};\n/**\n * Circular Easing\n * @type {EasingObject}\n */\n\nvar Circular = {\n  In: function In(k) {\n    return 1 - Math.sqrt(1 - k * k);\n  },\n  Out: function Out(k) {\n    return Math.sqrt(1 - --k * k);\n  },\n  InOut: function InOut(k) {\n    k *= 2;\n\n    if (k < 1) {\n      return -0.5 * (Math.sqrt(1 - k * k) - 1);\n    }\n\n    k -= 2;\n    return 0.5 * (Math.sqrt(1 - k * k) + 1);\n  }\n};\n/**\n * Elastic Easing\n * @type {EasingObject}\n */\n\nvar Elastic = {\n  In: function In(k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * Math.asin(1 / a) / (2 * Math.PI);\n    }\n\n    k -= 1;\n    return -(a * Math.pow(2, 10 * k) * Math.sin((k - s) * (2 * Math.PI) / p));\n  },\n  Out: function Out(k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * Math.asin(1 / a) / (2 * Math.PI);\n    }\n\n    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;\n  },\n  InOut: function InOut(k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * Math.asin(1 / a) / (2 * Math.PI);\n    }\n\n    k *= 2;\n\n    if (k < 1) {\n      k -= 1;\n      return -0.5 * (a * Math.pow(2, 10 * k) * Math.sin((k - s) * (2 * Math.PI) / p));\n    }\n\n    k -= 1;\n    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n  }\n};\n/**\n * Back Easing\n * @type {EasingObject}\n */\n\nvar Back = {\n  In: function In(k) {\n    var s = 1.70158;\n    return k * k * ((s + 1) * k - s);\n  },\n  Out: function Out(k) {\n    var s = 1.70158;\n    return --k * k * ((s + 1) * k + s) + 1;\n  },\n  InOut: function InOut(k) {\n    var s = 1.70158 * 1.525;\n    k *= 2;\n\n    if (k < 1) {\n      return 0.5 * (k * k * ((s + 1) * k - s));\n    }\n\n    k -= 2;\n    return 0.5 * (k * k * ((s + 1) * k + s) + 2);\n  }\n};\n/**\n * Bounce Easing\n * @type {EasingObject}\n */\n\nvar Bounce = {\n  In: function In(k) {\n    return 1 - Bounce.Out(1 - k);\n  },\n  Out: function Out(k) {\n    if (k < 1 / 2.75) {\n      return 7.5625 * k * k;\n    } else if (k < 2 / 2.75) {\n      k -= 1.5;\n      return 7.5625 * (k / 2.75) * k + 0.75;\n    } else if (k < 2.5 / 2.75) {\n      k -= 2.25;\n      return 7.5625 * (k / 2.75) * k + 0.9375;\n    }\n\n    k -= 2.625;\n    return 7.5625 * (k / 2.75) * k + 0.984375;\n  },\n  InOut: function InOut(k) {\n    if (k < 0.5) {\n      return Bounce.In(k * 2) * 0.5;\n    }\n\n    return Bounce.Out(k * 2 - 1) * 0.5 + 0.5;\n  }\n};\n;// CONCATENATED MODULE: ./src/core/FeatureDependentInterface.js\nfunction FeatureDependentInterface_typeof(obj) { "@babel/helpers - typeof"; return FeatureDependentInterface_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, FeatureDependentInterface_typeof(obj); }\n\nfunction FeatureDependentInterface_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction FeatureDependentInterface_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? FeatureDependentInterface_ownKeys(Object(source), !0).forEach(function (key) { FeatureDependentInterface_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : FeatureDependentInterface_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction FeatureDependentInterface_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction FeatureDependentInterface_slicedToArray(arr, i) { return FeatureDependentInterface_arrayWithHoles(arr) || FeatureDependentInterface_iterableToArrayLimit(arr, i) || FeatureDependentInterface_unsupportedIterableToArray(arr, i) || FeatureDependentInterface_nonIterableRest(); }\n\nfunction FeatureDependentInterface_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction FeatureDependentInterface_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return FeatureDependentInterface_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return FeatureDependentInterface_arrayLikeToArray(o, minLen); }\n\nfunction FeatureDependentInterface_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction FeatureDependentInterface_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction FeatureDependentInterface_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = FeatureDependentInterface_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction FeatureDependentInterface_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) FeatureDependentInterface_setPrototypeOf(subClass, superClass); }\n\nfunction FeatureDependentInterface_setPrototypeOf(o, p) { FeatureDependentInterface_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return FeatureDependentInterface_setPrototypeOf(o, p); }\n\nfunction FeatureDependentInterface_createSuper(Derived) { var hasNativeReflectConstruct = FeatureDependentInterface_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = FeatureDependentInterface_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = FeatureDependentInterface_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return FeatureDependentInterface_possibleConstructorReturn(this, result); }; }\n\nfunction FeatureDependentInterface_possibleConstructorReturn(self, call) { if (call && (FeatureDependentInterface_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return FeatureDependentInterface_assertThisInitialized(self); }\n\nfunction FeatureDependentInterface_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction FeatureDependentInterface_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction FeatureDependentInterface_getPrototypeOf(o) { FeatureDependentInterface_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return FeatureDependentInterface_getPrototypeOf(o); }\n\nfunction FeatureDependentInterface_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction FeatureDependentInterface_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction FeatureDependentInterface_createClass(Constructor, protoProps, staticProps) { if (protoProps) FeatureDependentInterface_defineProperties(Constructor.prototype, protoProps); if (staticProps) FeatureDependentInterface_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable no-unused-vars */\n\n/* eslint-disable max-classes-per-file */\n\n/**\n * Class factory interface for features that are dependent on other features being\n * present on the host. Event dependencies will be listened for when a feature of\n * matching type is added to the host and will stop being listened for when one\n * is removed. If the feature is already present when constructed, events will\n * be listened for right away.\n *\n * @interface\n *\n * @property {Object} EVENT_DEPENDENCIES - Events that the feature should start/stop\n * listening for when a feature of type FeatureName is added/removed from the host.\n * Event dependencies should follow the signature:\n *  { FeatureName: { eventName: callbackName, ... }, ... }\n */\n\nvar FeatureDependentInterface = /*#__PURE__*/function () {\n  function FeatureDependentInterface() {\n    FeatureDependentInterface_classCallCheck(this, FeatureDependentInterface);\n  }\n\n  FeatureDependentInterface_createClass(FeatureDependentInterface, [{\n    key: "_onFeatureAdded",\n    value:\n    /**\n     * Start listening for event dependencies that match the given feature type.\n     *\n     * @private\n     *\n     * @param {string} typeName - type of feature to listen for.\n     */\n    function _onFeatureAdded(typeName) {}\n    /**\n     * Stop listening for event dependencies that match the given feature type.\n     *\n     * @private\n     *\n     * @param {string} typeName - type of feature to stop listening for.\n     */\n\n  }, {\n    key: "_onFeatureRemoved",\n    value: function _onFeatureRemoved(typeName) {}\n    /**\n     * @augments {@link AbstractHostFeature#discard}\n     */\n\n  }, {\n    key: "discard",\n    value: function discard() {}\n    /**\n     * Creates a class that implements {@link FeatureDependentInterface} and extends\n     * a specified base class.\n     *\n     * @param {Class} BaseClass - The class to extend.\n     *\n     * @return {Class} A class that extends `BaseClass` and implements {@link FeatureDependentInterface}.\n     */\n\n  }], [{\n    key: "Mixin",\n    value: function Mixin(BaseClass) {\n      var FeatureDependentMixin = /*#__PURE__*/function (_BaseClass) {\n        FeatureDependentInterface_inherits(FeatureDependentMixin, _BaseClass);\n\n        var _super = FeatureDependentInterface_createSuper(FeatureDependentMixin);\n\n        function FeatureDependentMixin(host) {\n          var _this;\n\n          FeatureDependentInterface_classCallCheck(this, FeatureDependentMixin);\n\n          _this = _super.call(this, host);\n          _this._host = host; // No need to listen for events if the mixin is in the prototype chain multiple times\n\n          if (!_this._initialized) {\n            _this._initialized = true; // Start listening for feature events\n\n            _this._onFeatureAdded = _this._onFeatureAdded.bind(FeatureDependentInterface_assertThisInitialized(_this));\n            _this._onFeatureRemoved = _this._onFeatureRemoved.bind(FeatureDependentInterface_assertThisInitialized(_this));\n\n            _this._host.listenTo(core_HostObject.EVENTS.addFeature, _this._onFeatureAdded);\n\n            _this._host.listenTo(core_HostObject.EVENTS.removeFeature, _this._onFeatureRemoved); // Register features that already exist\n\n\n            Object.keys(_this.constructor.EVENT_DEPENDENCIES).forEach(function (typeName) {\n              if (_this._host[typeName] !== undefined) {\n                _this._onFeatureAdded(typeName);\n              }\n            });\n          }\n\n          return _this;\n        }\n\n        FeatureDependentInterface_createClass(FeatureDependentMixin, [{\n          key: "_onFeatureAdded",\n          value: function _onFeatureAdded(typeName) {\n            var _this2 = this;\n\n            if (this.constructor.EVENT_DEPENDENCIES[typeName] !== undefined) {\n              var events = this.constructor.EVENT_DEPENDENCIES[typeName];\n              Object.entries(events).forEach(function (_ref) {\n                var _ref2 = FeatureDependentInterface_slicedToArray(_ref, 2),\n                    eventName = _ref2[0],\n                    callback = _ref2[1];\n\n                _this2[callback] = _this2[callback].bind(_this2);\n\n                _this2._host.listenTo(_this2._host[typeName].EVENTS[eventName], _this2[callback]);\n              });\n            }\n          }\n        }, {\n          key: "_onFeatureRemoved",\n          value: function _onFeatureRemoved(typeName) {\n            var _this3 = this;\n\n            if (this.constructor.EVENT_DEPENDENCIES[typeName] !== undefined) {\n              var events = this.constructor.EVENT_DEPENDENCIES[typeName];\n              Object.entries(events).forEach(function (_ref3) {\n                var _ref4 = FeatureDependentInterface_slicedToArray(_ref3, 2),\n                    eventName = _ref4[0],\n                    callback = _ref4[1];\n\n                _this3._host.stopListening(_this3._host[typeName].EVENTS[eventName], _this3[callback]);\n              });\n            }\n          }\n        }, {\n          key: "discard",\n          value: function discard() {\n            var _this4 = this;\n\n            // Stop listening for feature events\n            this._host.stopListening(core_HostObject.EVENTS.addFeature, this._onFeatureAdded);\n\n            this._host.stopListening(core_HostObject.EVENTS.removeFeature, this._onFeatureRemoved); // Stop listening to feature-specific events\n\n\n            Object.keys(this.constructor.EVENT_DEPENDENCIES).forEach(function (typeName) {\n              if (_this4._host[typeName] !== undefined) {\n                _this4._onFeatureRemoved(typeName);\n              }\n            });\n\n            _get(FeatureDependentInterface_getPrototypeOf(FeatureDependentMixin.prototype), "discard", this).call(this);\n          }\n        }]);\n\n        return FeatureDependentMixin;\n      }(BaseClass);\n\n      var EVENT_DEPENDENCIES = BaseClass.EVENT_DEPENDENCIES || {};\n      Object.defineProperties(FeatureDependentMixin, {\n        EVENT_DEPENDENCIES: {\n          value: FeatureDependentInterface_objectSpread({}, EVENT_DEPENDENCIES),\n          writable: false\n        }\n      });\n      return FeatureDependentMixin;\n    }\n  }]);\n\n  return FeatureDependentInterface;\n}();\n/**\n * Event dependencies should follow the signature:\n * {\n *  FeatureName: {\n *    // Events that the feature should start/stop listening for when a feature\n *    // of type FeatureName is added/removed from the host\n *    {\n *      eventName: callbackName,\n *      ...\n *    },\n *  }\n * }\n */\n\n\nObject.defineProperties(FeatureDependentInterface, {\n  EVENT_DEPENDENCIES: {\n    value: {},\n    writable: false\n  }\n});\n/* harmony default export */ const core_FeatureDependentInterface = (FeatureDependentInterface);\n;// CONCATENATED MODULE: ./src/core/animpack/AnimationFeatureDependentInterface.js\nfunction AnimationFeatureDependentInterface_typeof(obj) { "@babel/helpers - typeof"; return AnimationFeatureDependentInterface_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, AnimationFeatureDependentInterface_typeof(obj); }\n\nfunction AnimationFeatureDependentInterface_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction AnimationFeatureDependentInterface_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? AnimationFeatureDependentInterface_ownKeys(Object(source), !0).forEach(function (key) { AnimationFeatureDependentInterface_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : AnimationFeatureDependentInterface_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction AnimationFeatureDependentInterface_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction AnimationFeatureDependentInterface_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AnimationFeatureDependentInterface_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AnimationFeatureDependentInterface_createClass(Constructor, protoProps, staticProps) { if (protoProps) AnimationFeatureDependentInterface_defineProperties(Constructor.prototype, protoProps); if (staticProps) AnimationFeatureDependentInterface_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction AnimationFeatureDependentInterface_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) AnimationFeatureDependentInterface_setPrototypeOf(subClass, superClass); }\n\nfunction AnimationFeatureDependentInterface_setPrototypeOf(o, p) { AnimationFeatureDependentInterface_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return AnimationFeatureDependentInterface_setPrototypeOf(o, p); }\n\nfunction AnimationFeatureDependentInterface_createSuper(Derived) { var hasNativeReflectConstruct = AnimationFeatureDependentInterface_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = AnimationFeatureDependentInterface_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = AnimationFeatureDependentInterface_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return AnimationFeatureDependentInterface_possibleConstructorReturn(this, result); }; }\n\nfunction AnimationFeatureDependentInterface_possibleConstructorReturn(self, call) { if (call && (AnimationFeatureDependentInterface_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return AnimationFeatureDependentInterface_assertThisInitialized(self); }\n\nfunction AnimationFeatureDependentInterface_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction AnimationFeatureDependentInterface_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction AnimationFeatureDependentInterface_getPrototypeOf(o) { AnimationFeatureDependentInterface_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return AnimationFeatureDependentInterface_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable no-unused-vars */\n\n/* eslint-disable max-classes-per-file */\n\n/**\n * Class factory interface for features that are dependent on the AnimationFeature\n * being present on the host. Layer and animation events will automatically be\n * listened for once a AnimationFeature is added to the host and stopped once it\n * is removed.\n *\n * @interface\n * @extends FeatureDependentInterface\n *\n * @property {Object} EVENT_DEPENDENCIES - Events that the feature should start/stop\n * listening for when a feature of type FeatureName is added/removed from the host.\n * @property {Object} EVENT_DEPENDENCIES.AnimationFeature - Events that are\n * specific to the AnimationFeature.\n * @property {string} [EVENT_DEPENDENCIES.AnimationFeature.addLayer=\'_onLayerAdded\'] -\n * The name of the method that will be executed when AnimationFeature addLayer\n * events are emitted.\n * @property {string} [EVENT_DEPENDENCIES.AnimationFeature.removeLayer=\'_onLayerRemoved\'] -\n * The name of the method that will be executed when AnimationFeature removeLayer\n * events are emitted.\n * @property {string} [EVENT_DEPENDENCIES.AnimationFeature.renameLayer=\'_onLayerRenamed\'] -\n * The name of the method that will be executed when AnimationFeature renameLayer\n * events are emitted.\n * @property {string} [EVENT_DEPENDENCIES.AnimationFeature.addAnimation=\'_onAnimationAdded\'] -\n * The name of the method that will be executed when AnimationFeature addAnimation\n * events are emitted.\n * @property {string} [EVENT_DEPENDENCIES.AnimationFeature.removeAnimation=\'_onAnimationRemoved\'] -\n * The name of the method that will be executed when AnimationFeature removeAnimation\n * events are emitted.\n * @property {string} [EVENT_DEPENDENCIES.AnimationFeature.renameAnimation=\'_onAnimationRenamed\'] -\n * The name of the method that will be executed when AnimationFeature renameAnimation\n * events are emitted.\n */\n\nvar AnimationFeatureDependentInterface = /*#__PURE__*/function (_FeatureDependentInte) {\n  AnimationFeatureDependentInterface_inherits(AnimationFeatureDependentInterface, _FeatureDependentInte);\n\n  var _super = AnimationFeatureDependentInterface_createSuper(AnimationFeatureDependentInterface);\n\n  function AnimationFeatureDependentInterface() {\n    AnimationFeatureDependentInterface_classCallCheck(this, AnimationFeatureDependentInterface);\n\n    return _super.apply(this, arguments);\n  }\n\n  AnimationFeatureDependentInterface_createClass(AnimationFeatureDependentInterface, [{\n    key: "_onLayerAdded",\n    value:\n    /**\n     * Executed when animation layer added events are caught.\n     *\n     * @private\n     *\n     * @param {string} name - Name of the layer that was added.\n     */\n    function _onLayerAdded(_ref) {\n      var name = _ref.name;\n    }\n    /**\n     * Executed when animation layer removed events are caught.\n     *\n     * @private\n     *\n     * @param {string} name - Name of the layer that was removed.\n     */\n\n  }, {\n    key: "_onLayerRemoved",\n    value: function _onLayerRemoved(_ref2) {\n      var name = _ref2.name;\n    }\n    /**\n     * Executed when animation layer renamed events are caught.\n     *\n     * @private\n     *\n     * @param {string} oldName - Name of the layer that was renamed.\n     * @param {string} newName - New name of the layer.\n     */\n\n  }, {\n    key: "_onLayerRenamed",\n    value: function _onLayerRenamed(_ref3) {\n      var oldName = _ref3.oldName,\n          newName = _ref3.newName;\n    }\n    /**\n     * Executed when animation added events are caught.\n     *\n     * @private\n     *\n     * @param {string} layerName - Name of the layer that an animation was added to.\n     * @param {string} animationName - Name of the animation that was added.\n     */\n\n  }, {\n    key: "_onAnimationAdded",\n    value: function _onAnimationAdded(_ref4) {\n      var layerName = _ref4.layerName,\n          animationName = _ref4.animationName;\n    }\n    /**\n     * Executed when animation removed events are caught.\n     *\n     * @private\n     *\n     * @param {string} layerName - Name of the layer that an animation was removed from.\n     * @param {string} animationName - Name of the animation that was removed.\n     */\n\n  }, {\n    key: "_onAnimationRemoved",\n    value: function _onAnimationRemoved(_ref5) {\n      var layerName = _ref5.layerName,\n          animationName = _ref5.animationName;\n    }\n    /**\n     * Executed when animation renamed events are caught.\n     *\n     * @private\n     *\n     * @param {string} layerName - Name of the layer that an animation belongs to.\n     * @param {string} oldName - Name of the animation that was renamed.\n     * @param {string} newName - New name of the animation.\n     */\n\n  }, {\n    key: "_onAnimationRenamed",\n    value: function _onAnimationRenamed(_ref6) {\n      var layerName = _ref6.layerName,\n          oldName = _ref6.oldName,\n          newName = _ref6.newName;\n    }\n    /**\n     * Creates a class that implements {@link AnimationFeatureDependentInterface}\n     * and extends a specified base class.\n     *\n     * @param {Class} BaseClass - The class to extend.\n     *\n     * @return {Class} A class that extends `BaseClass` and implements {@link AnimationFeatureDependentInterface}.\n     */\n\n  }], [{\n    key: "Mixin",\n    value: function Mixin(BaseClass) {\n      var ParentClass = core_FeatureDependentInterface.Mixin(BaseClass);\n\n      var AnimationFeatureDependentMixin = /*#__PURE__*/function (_ParentClass) {\n        AnimationFeatureDependentInterface_inherits(AnimationFeatureDependentMixin, _ParentClass);\n\n        var _super2 = AnimationFeatureDependentInterface_createSuper(AnimationFeatureDependentMixin);\n\n        function AnimationFeatureDependentMixin() {\n          AnimationFeatureDependentInterface_classCallCheck(this, AnimationFeatureDependentMixin);\n\n          return _super2.apply(this, arguments);\n        }\n\n        AnimationFeatureDependentInterface_createClass(AnimationFeatureDependentMixin, [{\n          key: "_onLayerAdded",\n          value: function _onLayerAdded(_ref7) {\n            var name = _ref7.name;\n          }\n        }, {\n          key: "_onLayerRemoved",\n          value: function _onLayerRemoved(_ref8) {\n            var name = _ref8.name;\n          }\n        }, {\n          key: "_onLayerRenamed",\n          value: function _onLayerRenamed(_ref9) {\n            var oldName = _ref9.oldName,\n                newName = _ref9.newName;\n          }\n        }, {\n          key: "_onAnimationAdded",\n          value: function _onAnimationAdded(_ref10) {\n            var layerName = _ref10.layerName,\n                animationName = _ref10.animationName;\n          }\n        }, {\n          key: "_onAnimationRemoved",\n          value: function _onAnimationRemoved(_ref11) {\n            var layerName = _ref11.layerName,\n                animationName = _ref11.animationName;\n          }\n        }, {\n          key: "_onAnimationRenamed",\n          value: function _onAnimationRenamed(_ref12) {\n            var layerName = _ref12.layerName,\n                oldName = _ref12.oldName,\n                newName = _ref12.newName;\n          }\n        }]);\n\n        return AnimationFeatureDependentMixin;\n      }(ParentClass);\n\n      Object.defineProperties(AnimationFeatureDependentMixin, {\n        EVENT_DEPENDENCIES: {\n          value: AnimationFeatureDependentInterface_objectSpread(AnimationFeatureDependentInterface_objectSpread({}, ParentClass.EVENT_DEPENDENCIES), AnimationFeatureDependentInterface.EVENT_DEPENDENCIES),\n          writable: false\n        }\n      });\n      return AnimationFeatureDependentMixin;\n    }\n  }]);\n\n  return AnimationFeatureDependentInterface;\n}(core_FeatureDependentInterface);\n\nObject.defineProperties(AnimationFeatureDependentInterface, {\n  EVENT_DEPENDENCIES: {\n    value: {\n      AnimationFeature: {\n        addLayer: \'_onLayerAdded\',\n        removeLayer: \'_onLayerRemoved\',\n        renameLayer: \'_onLayerRenamed\',\n        addAnimation: \'_onAnimationAdded\',\n        removeAnimation: \'_onAnimationRemoved\',\n        renameAnimation: \'_onAnimationRenamed\'\n      }\n    },\n    writable: false\n  }\n});\n/* harmony default export */ const animpack_AnimationFeatureDependentInterface = (AnimationFeatureDependentInterface);\n;// CONCATENATED MODULE: ./src/core/animpack/ManagedAnimationLayerInterface.js\nfunction ManagedAnimationLayerInterface_typeof(obj) { "@babel/helpers - typeof"; return ManagedAnimationLayerInterface_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, ManagedAnimationLayerInterface_typeof(obj); }\n\nfunction ManagedAnimationLayerInterface_slicedToArray(arr, i) { return ManagedAnimationLayerInterface_arrayWithHoles(arr) || ManagedAnimationLayerInterface_iterableToArrayLimit(arr, i) || ManagedAnimationLayerInterface_unsupportedIterableToArray(arr, i) || ManagedAnimationLayerInterface_nonIterableRest(); }\n\nfunction ManagedAnimationLayerInterface_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction ManagedAnimationLayerInterface_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return ManagedAnimationLayerInterface_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return ManagedAnimationLayerInterface_arrayLikeToArray(o, minLen); }\n\nfunction ManagedAnimationLayerInterface_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ManagedAnimationLayerInterface_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction ManagedAnimationLayerInterface_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction ManagedAnimationLayerInterface_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction ManagedAnimationLayerInterface_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ManagedAnimationLayerInterface_ownKeys(Object(source), !0).forEach(function (key) { ManagedAnimationLayerInterface_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ManagedAnimationLayerInterface_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction ManagedAnimationLayerInterface_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ManagedAnimationLayerInterface_get() { if (typeof Reflect !== "undefined" && Reflect.get) { ManagedAnimationLayerInterface_get = Reflect.get; } else { ManagedAnimationLayerInterface_get = function _get(target, property, receiver) { var base = ManagedAnimationLayerInterface_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return ManagedAnimationLayerInterface_get.apply(this, arguments); }\n\nfunction ManagedAnimationLayerInterface_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = ManagedAnimationLayerInterface_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction ManagedAnimationLayerInterface_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction ManagedAnimationLayerInterface_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction ManagedAnimationLayerInterface_createClass(Constructor, protoProps, staticProps) { if (protoProps) ManagedAnimationLayerInterface_defineProperties(Constructor.prototype, protoProps); if (staticProps) ManagedAnimationLayerInterface_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction ManagedAnimationLayerInterface_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) ManagedAnimationLayerInterface_setPrototypeOf(subClass, superClass); }\n\nfunction ManagedAnimationLayerInterface_setPrototypeOf(o, p) { ManagedAnimationLayerInterface_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return ManagedAnimationLayerInterface_setPrototypeOf(o, p); }\n\nfunction ManagedAnimationLayerInterface_createSuper(Derived) { var hasNativeReflectConstruct = ManagedAnimationLayerInterface_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = ManagedAnimationLayerInterface_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = ManagedAnimationLayerInterface_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return ManagedAnimationLayerInterface_possibleConstructorReturn(this, result); }; }\n\nfunction ManagedAnimationLayerInterface_possibleConstructorReturn(self, call) { if (call && (ManagedAnimationLayerInterface_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return ManagedAnimationLayerInterface_assertThisInitialized(self); }\n\nfunction ManagedAnimationLayerInterface_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction ManagedAnimationLayerInterface_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction ManagedAnimationLayerInterface_getPrototypeOf(o) { ManagedAnimationLayerInterface_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return ManagedAnimationLayerInterface_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable no-unused-vars */\n\n/* eslint-disable max-classes-per-file */\n\n/**\n * Class factory interface for that keeps track of layers and animations on a host.\n * Tracked assets are marked as inactive until layers and animations with matching\n * names are detected as present on the host.\n *\n * @interface\n * @extends AnimationFeatureDependentInterface\n *\n * @property {Object} DEFAULT_LAYER_OPTIONS - Default options to use when executing\n * {@link AnimationLayer} methods.\n * @property {number} [DEFAULT_LAYER_OPTIONS.blendTime=0.5] - Default time in seconds\n * to use when executing {@link AnimationLayer.setBlendWeight}.\n * @property {Object} [DEFAULT_LAYER_OPTIONS.animations={}] - Maps animation names\n * to default options objects to use for managed animations.\n */\n\nvar ManagedAnimationLayerInterface = /*#__PURE__*/function (_AnimationFeatureDepe) {\n  ManagedAnimationLayerInterface_inherits(ManagedAnimationLayerInterface, _AnimationFeatureDepe);\n\n  var _super = ManagedAnimationLayerInterface_createSuper(ManagedAnimationLayerInterface);\n\n  function ManagedAnimationLayerInterface() {\n    ManagedAnimationLayerInterface_classCallCheck(this, ManagedAnimationLayerInterface);\n\n    return _super.apply(this, arguments);\n  }\n\n  ManagedAnimationLayerInterface_createClass(ManagedAnimationLayerInterface, [{\n    key: "registerLayer",\n    value:\n    /**\n     * Start tracking keeping track of whether a layer with the given name is present\n     * on the host.\n     *\n     * @param {string} name - Name of the layer to keep track of.\n     * @param {Object=} options - Options for the layer.\n     * @param {number=} options.blendTime - Default amount of time to use when\n     * manipulating layer weights on this layer.\n     * @param {Function=} options.easingFn - Default easing function to use when\n     * manipulating layer weights on this layer.\n     * @param {Object=} options.animations - Animations to keep track of on the layer.\n     * Animations are represented as key/value pairs of animation names and their\n     * options.\n     */\n    function registerLayer(name) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    }\n    /**\n     * Start tracking keeping track of whether an animation with the given name is\n     * present on the host.\n     *\n     * @param {string} layerName - Name of the layer that will own the animation.\n     * @param {string} animationName - Name of the animation to keep track of.\n     * @param {Object=} options - Options for the animation.\n     */\n\n  }, {\n    key: "registerAnimation",\n    value: function registerAnimation(layerName, animationName) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    }\n    /**\n     * Set layer weights on tracked layers.\n     *\n     * @param {Function=} nameFilter - Predicate function to test each tracked layer\n     * with. By default all layers will pass.\n     * @param {number} weight - Weight value to set on layers.\n     * @param {number=} seconds - Number of seconds it will take to reach the weight\n     * on each layer. If undefined, each layers\' blendTime option is used.\n     * @param {Function=} easingFn - Easing function to use when setting weight\n     * on each layer. If undefined, each layers\' easingFn option is used.\n     */\n\n  }, {\n    key: "setLayerWeights",\n    value: function setLayerWeights() {\n      var nameFilter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {\n        return true;\n      };\n      var weight = arguments.length > 1 ? arguments[1] : undefined;\n      var seconds = arguments.length > 2 ? arguments[2] : undefined;\n      var easingFn = arguments.length > 3 ? arguments[3] : undefined;\n    }\n    /**\n     * Set all tracked layers\' weights to 1.\n     *\n     * @param {number=} seconds - Number of seconds it will take to reach the weight\n     * on each layer. If undefined, each layers\' blendTime option is used.\n     * @param {Function=} easingFn - Easing function to use when setting weight\n     * on each layer. If undefined, each layers\' easingFn option is used.\n     */\n\n  }, {\n    key: "enable",\n    value: function enable(seconds, easingFn) {}\n    /**\n     * Set all tracked layers\' weights to 0.\n     *\n     * @param {number=} seconds - Number of seconds it will take to reach the weight\n     * on each layer. If undefined, each layers\' blendTime option is used.\n     * @param {Function=} easingFn - Easing function to use when setting weight\n     * on each layer. If undefined, each layers\' easingFn option is used.\n     */\n\n  }, {\n    key: "disable",\n    value: function disable(seconds, easingFn) {}\n    /**\n     * Creates a class that implements {@link ManagedAnimationLayerInterface}\n     * and extends a specified base class.\n     *\n     * @param {Class} BaseClass - The class to extend.\n     *\n     * @return {Class} A class that extends `BaseClass` and implements {@link ManagedAnimationLayerInterface}.\n     */\n\n  }], [{\n    key: "Mixin",\n    value: function Mixin(BaseClass) {\n      var ParentClass = animpack_AnimationFeatureDependentInterface.Mixin(BaseClass);\n\n      var ManagedAnimationLayerMixin = /*#__PURE__*/function (_ParentClass) {\n        ManagedAnimationLayerInterface_inherits(ManagedAnimationLayerMixin, _ParentClass);\n\n        var _super2 = ManagedAnimationLayerInterface_createSuper(ManagedAnimationLayerMixin);\n\n        function ManagedAnimationLayerMixin() {\n          var _this;\n\n          ManagedAnimationLayerInterface_classCallCheck(this, ManagedAnimationLayerMixin);\n\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          _this = _super2.call.apply(_super2, [this].concat(args));\n          _this._managedLayers = {};\n          return _this;\n        }\n\n        ManagedAnimationLayerInterface_createClass(ManagedAnimationLayerMixin, [{\n          key: "_onFeatureAdded",\n          value: function _onFeatureAdded(typeName) {\n            var _this2 = this;\n\n            ManagedAnimationLayerInterface_get(ManagedAnimationLayerInterface_getPrototypeOf(ManagedAnimationLayerMixin.prototype), "_onFeatureAdded", this).call(this, typeName);\n\n            if (typeName !== \'AnimationFeature\') {\n              return;\n            }\n\n            this._managedLayers = this._managedLayers || {}; // Detect new layers\n\n            this._host.AnimationFeature.layers.forEach(function (name) {\n              _this2._onLayerAdded({\n                name: name\n              });\n            });\n          }\n        }, {\n          key: "_onFeatureRemoved",\n          value: function _onFeatureRemoved(typeName) {\n            var _this3 = this;\n\n            ManagedAnimationLayerInterface_get(ManagedAnimationLayerInterface_getPrototypeOf(ManagedAnimationLayerMixin.prototype), "_onFeatureRemoved", this).call(this, typeName);\n\n            if (typeName !== \'AnimationFeature\') {\n              return;\n            }\n\n            this._managedLayers = this._managedLayers || {}; // Deactivate the layers\n\n            Object.keys(this._managedLayers).forEach(function (name) {\n              _this3._onLayerRemoved({\n                name: name\n              });\n            });\n          }\n        }, {\n          key: "_onLayerAdded",\n          value: function _onLayerAdded(_ref) {\n            var _this4 = this;\n\n            var name = _ref.name;\n\n            // Mark the layer as active if it is managed\n            if (this._managedLayers[name] !== undefined) {\n              this._managedLayers[name].isActive = true; // Detect new animations\n\n              this._host.AnimationFeature.getAnimations(name).forEach(function (animName) {\n                _this4._onAnimationAdded({\n                  layerName: name,\n                  animationName: animName\n                });\n              });\n            }\n          }\n        }, {\n          key: "_onLayerRemoved",\n          value: function _onLayerRemoved(_ref2) {\n            var _this5 = this;\n\n            var name = _ref2.name;\n\n            // Deactivate the layer if it is managed\n            if (this._managedLayers[name] !== undefined) {\n              this._managedLayers[name].isActive = false; // Deactivate the animations\n\n              Object.keys(this._managedLayers[name].animations).forEach(function (animName) {\n                _this5._onAnimationRemoved({\n                  layerName: name,\n                  animationName: animName\n                });\n              });\n            }\n          }\n        }, {\n          key: "_onLayerRenamed",\n          value: function _onLayerRenamed(_ref3) {\n            var oldName = _ref3.oldName,\n                newName = _ref3.newName;\n            var layerOptions = this._managedLayers[oldName]; // Replace the layer key with the new name\n\n            if (layerOptions !== undefined) {\n              delete this._managedLayers[oldName];\n              this._managedLayers[newName] = layerOptions;\n            }\n          }\n        }, {\n          key: "_onAnimationAdded",\n          value: function _onAnimationAdded(_ref4) {\n            var layerName = _ref4.layerName,\n                animationName = _ref4.animationName;\n\n            // Mark the animation as active if it is managed\n            if (this._managedLayers[layerName] !== undefined && this._managedLayers[layerName].animations[animationName] !== undefined) {\n              this._managedLayers[layerName].animations[animationName].isActive = true;\n            }\n          }\n        }, {\n          key: "_onAnimationRemoved",\n          value: function _onAnimationRemoved(_ref5) {\n            var layerName = _ref5.layerName,\n                animationName = _ref5.animationName;\n\n            // Deactivate the animation if it is managed\n            if (this._managedLayers[layerName] !== undefined && this._managedLayers[layerName].animations[animationName] !== undefined) {\n              this._managedLayers[layerName].animations[animationName].isActive = false;\n            }\n          }\n        }, {\n          key: "_onAnimationRenamed",\n          value: function _onAnimationRenamed(_ref6) {\n            var layerName = _ref6.layerName,\n                oldName = _ref6.oldName,\n                newName = _ref6.newName;\n\n            if (this._managedLayers[layerName] !== undefined && this._managedLayers[layerName].animations[oldName] !== undefined) {\n              // Replace the animation key with the new name\n              var animOptions = this._managedLayers[layerName].animations[oldName];\n              delete this._managedLayers[layerName].animations[oldName];\n              this._managedLayers[layerName].animations[newName] = animOptions;\n            }\n          }\n        }, {\n          key: "registerLayer",\n          value: function registerLayer(name) {\n            var _this6 = this;\n\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            // Start with default options for each new layer\n            if (this._managedLayers[name] === undefined) {\n              this._managedLayers[name] = ManagedAnimationLayerInterface_objectSpread(ManagedAnimationLayerInterface_objectSpread({}, this.constructor.DEFAULT_LAYER_OPTIONS), {}, {\n                animations: {}\n              });\n            } // Update all options except animations\n\n\n            var layerOptions = this._managedLayers[name];\n            options = ManagedAnimationLayerInterface_objectSpread({}, options);\n            var animationOptions = options.animations || {};\n            delete options.animations;\n            Object.assign(layerOptions, options); // Check whether the layer can be manipulated now\n\n            layerOptions.isActive = this._host.AnimationFeature !== undefined && this._host.AnimationFeature.layers.includes(name); // Register the animations\n\n            Object.entries(animationOptions).forEach(function (_ref7) {\n              var _ref8 = ManagedAnimationLayerInterface_slicedToArray(_ref7, 2),\n                  animName = _ref8[0],\n                  animOptions = _ref8[1];\n\n              _this6.registerAnimation(name, animName, animOptions);\n            });\n          }\n        }, {\n          key: "registerAnimation",\n          value: function registerAnimation(layerName, animationName) {\n            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n            // Register the layer if it hasn\'t been registered yet\n            if (this._managedLayers[layerName] === undefined) {\n              this.registerLayer(layerName);\n            } // Update animation options\n\n\n            var animOptions = this._managedLayers[layerName].animations[animationName] || {};\n            Object.assign(animOptions, options);\n            this._managedLayers[layerName].animations[animationName] = animOptions; // Check whether the animation can be manipulated now\n\n            this._managedLayers[layerName].animations[animationName].isActive = this._managedLayers[layerName].isActive && this._host.AnimationFeature.getAnimations(layerName).includes(animationName);\n          }\n        }, {\n          key: "setLayerWeights",\n          value: function setLayerWeights() {\n            var _this7 = this;\n\n            var nameFilter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {\n              return true;\n            };\n            var weight = arguments.length > 1 ? arguments[1] : undefined;\n            var seconds = arguments.length > 2 ? arguments[2] : undefined;\n            var easingFn = arguments.length > 3 ? arguments[3] : undefined;\n            var layerNames = Object.keys(this._managedLayers).filter(nameFilter);\n            layerNames.forEach(function (name) {\n              var layerOptions = _this7._managedLayers[name];\n\n              if (layerOptions.isActive) {\n                _this7._host.AnimationFeature.setLayerWeight(name, weight, seconds !== undefined ? seconds : layerOptions.blendTime, easingFn || layerOptions.easingFn);\n              }\n            });\n          }\n        }, {\n          key: "enable",\n          value: function enable(seconds, easingFn) {\n            this.setLayerWeights(undefined, 1, seconds, easingFn);\n          }\n        }, {\n          key: "disable",\n          value: function disable(seconds, easingFn) {\n            this.setLayerWeights(undefined, 0, seconds, easingFn);\n          }\n        }, {\n          key: "installApi",\n          value: function installApi() {\n            var api = ManagedAnimationLayerInterface_get(ManagedAnimationLayerInterface_getPrototypeOf(ManagedAnimationLayerMixin.prototype), "installApi", this).call(this);\n\n            Object.assign(api, {\n              registerLayer: this.registerLayer.bind(this),\n              registerAnimation: this.registerAnimation.bind(this),\n              setLayerWeights: this.setLayerWeights.bind(this),\n              enable: this.enable.bind(this),\n              disable: this.disable.bind(this)\n            });\n            return api;\n          }\n        }]);\n\n        return ManagedAnimationLayerMixin;\n      }(ParentClass);\n\n      Object.defineProperties(ManagedAnimationLayerMixin, {\n        DEFAULT_LAYER_OPTIONS: {\n          value: ManagedAnimationLayerInterface.DEFAULT_LAYER_OPTIONS,\n          writable: false\n        }\n      });\n      return ManagedAnimationLayerMixin;\n    }\n  }]);\n\n  return ManagedAnimationLayerInterface;\n}(animpack_AnimationFeatureDependentInterface);\n\nObject.defineProperties(ManagedAnimationLayerInterface, {\n  DEFAULT_LAYER_OPTIONS: {\n    value: {\n      blendTime: 0.5,\n      animations: {}\n    },\n    writable: false\n  }\n});\n/* harmony default export */ const animpack_ManagedAnimationLayerInterface = (ManagedAnimationLayerInterface);\n;// CONCATENATED MODULE: ./src/core/awspack/TextToSpeechFeatureDependentInterface.js\nfunction TextToSpeechFeatureDependentInterface_typeof(obj) { "@babel/helpers - typeof"; return TextToSpeechFeatureDependentInterface_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, TextToSpeechFeatureDependentInterface_typeof(obj); }\n\nfunction TextToSpeechFeatureDependentInterface_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction TextToSpeechFeatureDependentInterface_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? TextToSpeechFeatureDependentInterface_ownKeys(Object(source), !0).forEach(function (key) { TextToSpeechFeatureDependentInterface_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : TextToSpeechFeatureDependentInterface_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction TextToSpeechFeatureDependentInterface_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TextToSpeechFeatureDependentInterface_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction TextToSpeechFeatureDependentInterface_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction TextToSpeechFeatureDependentInterface_createClass(Constructor, protoProps, staticProps) { if (protoProps) TextToSpeechFeatureDependentInterface_defineProperties(Constructor.prototype, protoProps); if (staticProps) TextToSpeechFeatureDependentInterface_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction TextToSpeechFeatureDependentInterface_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) TextToSpeechFeatureDependentInterface_setPrototypeOf(subClass, superClass); }\n\nfunction TextToSpeechFeatureDependentInterface_setPrototypeOf(o, p) { TextToSpeechFeatureDependentInterface_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return TextToSpeechFeatureDependentInterface_setPrototypeOf(o, p); }\n\nfunction TextToSpeechFeatureDependentInterface_createSuper(Derived) { var hasNativeReflectConstruct = TextToSpeechFeatureDependentInterface_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = TextToSpeechFeatureDependentInterface_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = TextToSpeechFeatureDependentInterface_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return TextToSpeechFeatureDependentInterface_possibleConstructorReturn(this, result); }; }\n\nfunction TextToSpeechFeatureDependentInterface_possibleConstructorReturn(self, call) { if (call && (TextToSpeechFeatureDependentInterface_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return TextToSpeechFeatureDependentInterface_assertThisInitialized(self); }\n\nfunction TextToSpeechFeatureDependentInterface_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction TextToSpeechFeatureDependentInterface_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction TextToSpeechFeatureDependentInterface_getPrototypeOf(o) { TextToSpeechFeatureDependentInterface_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return TextToSpeechFeatureDependentInterface_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable max-classes-per-file */\n\n/**\n * Class factory interface for features that are dependent on the TextToSpeechFeature\n * being present on the host. Speech events will automatically be listened for once a\n * TextToSpeechFeature is added to the host and stopped once it is removed.\n *\n * @interface\n * @extends FeatureDependentInterface\n *\n * @property {Object} EVENT_DEPENDENCIES - Events that the feature should start/stop\n * listening for when a feature of type FeatureName is added/removed from the host.\n * @property {Object} EVENT_DEPENDENCIES.TextToSpeechFeature - Events that are\n * specific to the TextToSpeechFeature.\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.play=\'_onPlay\'] -\n * The name of the method that will be executed when TextToSpeechFeature play\n * events are emitted.\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.pause=\'_onPause\'] -\n * The name of the method that will be executed when TextToSpeechFeature pause\n * events are emitted.\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.resume=\'_onResume\'] -\n * The name of the method that will be executed when TextToSpeechFeature resume\n * events are emitted.\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.stop=\'_onStop\'] -\n * The name of the method that will be executed when TextToSpeechFeature stop\n * events are emitted.\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.sentence=\'_onSentence\'] -\n * The name of the method that will be executed when TextToSpeechFeature sentence\n * events are emitted.\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.word=\'_onWord\'] -\n * The name of the method that will be executed when TextToSpeechFeature word\n * events are emitted.\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.viseme=\'_onViseme\'] -\n * The name of the method that will be executed when TextToSpeechFeature viseme\n * events are emitted.\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.ssml=\'_onSsml\'] -\n * The name of the method that will be executed when TextToSpeechFeature ssml\n * events are emitted.\n */\n\nvar TextToSpeechFeatureDependentInterface = /*#__PURE__*/function (_FeatureDependentInte) {\n  TextToSpeechFeatureDependentInterface_inherits(TextToSpeechFeatureDependentInterface, _FeatureDependentInte);\n\n  var _super = TextToSpeechFeatureDependentInterface_createSuper(TextToSpeechFeatureDependentInterface);\n\n  function TextToSpeechFeatureDependentInterface() {\n    TextToSpeechFeatureDependentInterface_classCallCheck(this, TextToSpeechFeatureDependentInterface);\n\n    return _super.apply(this, arguments);\n  }\n\n  TextToSpeechFeatureDependentInterface_createClass(TextToSpeechFeatureDependentInterface, [{\n    key: "_onPlay",\n    value:\n    /**\n     * Executed when speech play events are caught.\n     *\n     * @private\n     */\n    function _onPlay() {}\n    /**\n     * Executed when speech pause events are caught.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_onPause",\n    value: function _onPause() {}\n    /**\n     * Executed when speech resume events are caught.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_onResume",\n    value: function _onResume() {}\n    /**\n     * Executed when speech stop events are caught.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_onStop",\n    value: function _onStop() {}\n    /**\n     * Executed when speech sentence events are caught.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_onSentence",\n    value: function _onSentence() {}\n    /**\n     * Executed when speech word events are caught.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_onWord",\n    value: function _onWord() {}\n    /**\n     * Executed when speech viseme events are caught.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_onViseme",\n    value: function _onViseme() {}\n    /**\n     * Executed when speech ssml events are caught.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_onSsml",\n    value: function _onSsml() {}\n    /**\n     * Creates a class that implements {@link TextToSpeechFeatureDependentInterface}\n     * and extends a specified base class.\n     *\n     * @param {Class} BaseClass - The class to extend.\n     *\n     * @return {Class} A class that extends `BaseClass` and implements {@link TextToSpeechFeatureDependentInterface}.\n     */\n\n  }], [{\n    key: "Mixin",\n    value: function Mixin(BaseClass) {\n      var ParentClass = core_FeatureDependentInterface.Mixin(BaseClass);\n\n      var TextToSpeechFeatureDependentMixin = /*#__PURE__*/function (_ParentClass) {\n        TextToSpeechFeatureDependentInterface_inherits(TextToSpeechFeatureDependentMixin, _ParentClass);\n\n        var _super2 = TextToSpeechFeatureDependentInterface_createSuper(TextToSpeechFeatureDependentMixin);\n\n        function TextToSpeechFeatureDependentMixin() {\n          TextToSpeechFeatureDependentInterface_classCallCheck(this, TextToSpeechFeatureDependentMixin);\n\n          return _super2.apply(this, arguments);\n        }\n\n        TextToSpeechFeatureDependentInterface_createClass(TextToSpeechFeatureDependentMixin, [{\n          key: "_onPlay",\n          value: function _onPlay() {}\n        }, {\n          key: "_onPause",\n          value: function _onPause() {}\n        }, {\n          key: "_onResume",\n          value: function _onResume() {}\n        }, {\n          key: "_onStop",\n          value: function _onStop() {}\n        }, {\n          key: "_onSentence",\n          value: function _onSentence() {}\n        }, {\n          key: "_onWord",\n          value: function _onWord() {}\n        }, {\n          key: "_onViseme",\n          value: function _onViseme() {}\n        }, {\n          key: "_onSsml",\n          value: function _onSsml() {}\n        }]);\n\n        return TextToSpeechFeatureDependentMixin;\n      }(ParentClass);\n\n      Object.defineProperties(TextToSpeechFeatureDependentMixin, {\n        EVENT_DEPENDENCIES: {\n          value: TextToSpeechFeatureDependentInterface_objectSpread(TextToSpeechFeatureDependentInterface_objectSpread({}, ParentClass.EVENT_DEPENDENCIES), TextToSpeechFeatureDependentInterface.EVENT_DEPENDENCIES),\n          writable: false\n        }\n      });\n      return TextToSpeechFeatureDependentMixin;\n    }\n  }]);\n\n  return TextToSpeechFeatureDependentInterface;\n}(core_FeatureDependentInterface);\n\nObject.defineProperties(TextToSpeechFeatureDependentInterface, {\n  EVENT_DEPENDENCIES: {\n    value: {\n      TextToSpeechFeature: {\n        play: \'_onPlay\',\n        pause: \'_onPause\',\n        resume: \'_onResume\',\n        stop: \'_onStop\',\n        sentence: \'_onSentence\',\n        word: \'_onWord\',\n        viseme: \'_onViseme\',\n        ssml: \'_onSsml\'\n      }\n    },\n    writable: false\n  }\n});\n/* harmony default export */ const awspack_TextToSpeechFeatureDependentInterface = (TextToSpeechFeatureDependentInterface);\n;// CONCATENATED MODULE: ./src/core/LipsyncFeature.js\nfunction LipsyncFeature_typeof(obj) { "@babel/helpers - typeof"; return LipsyncFeature_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, LipsyncFeature_typeof(obj); }\n\nfunction LipsyncFeature_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction LipsyncFeature_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? LipsyncFeature_ownKeys(Object(source), !0).forEach(function (key) { LipsyncFeature_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : LipsyncFeature_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction LipsyncFeature_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\nfunction LipsyncFeature_slicedToArray(arr, i) { return LipsyncFeature_arrayWithHoles(arr) || LipsyncFeature_iterableToArrayLimit(arr, i) || LipsyncFeature_unsupportedIterableToArray(arr, i) || LipsyncFeature_nonIterableRest(); }\n\nfunction LipsyncFeature_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction LipsyncFeature_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return LipsyncFeature_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return LipsyncFeature_arrayLikeToArray(o, minLen); }\n\nfunction LipsyncFeature_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction LipsyncFeature_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction LipsyncFeature_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction LipsyncFeature_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction LipsyncFeature_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction LipsyncFeature_createClass(Constructor, protoProps, staticProps) { if (protoProps) LipsyncFeature_defineProperties(Constructor.prototype, protoProps); if (staticProps) LipsyncFeature_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction LipsyncFeature_get() { if (typeof Reflect !== "undefined" && Reflect.get) { LipsyncFeature_get = Reflect.get; } else { LipsyncFeature_get = function _get(target, property, receiver) { var base = LipsyncFeature_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return LipsyncFeature_get.apply(this, arguments); }\n\nfunction LipsyncFeature_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = LipsyncFeature_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction LipsyncFeature_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) LipsyncFeature_setPrototypeOf(subClass, superClass); }\n\nfunction LipsyncFeature_setPrototypeOf(o, p) { LipsyncFeature_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return LipsyncFeature_setPrototypeOf(o, p); }\n\nfunction LipsyncFeature_createSuper(Derived) { var hasNativeReflectConstruct = LipsyncFeature_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = LipsyncFeature_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = LipsyncFeature_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return LipsyncFeature_possibleConstructorReturn(this, result); }; }\n\nfunction LipsyncFeature_possibleConstructorReturn(self, call) { if (call && (LipsyncFeature_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return LipsyncFeature_assertThisInitialized(self); }\n\nfunction LipsyncFeature_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction LipsyncFeature_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction LipsyncFeature_getPrototypeOf(o) { LipsyncFeature_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return LipsyncFeature_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n\n/**\n * Default mapping of Polly viseme names to animation options objects.\n *\n * @property {Object} [sil={name: \'sil\'}]\n * @property {Object} [p={name: \'p\', overrideWeight: 0.9}]\n * @property {Object} [t={name: \'t\', blendTime: 0.2}]\n * @property {Object} [S={name: \'S\'}]\n * @property {Object} [T={name: \'T\'}]\n * @property {Object} [f={name: \'f\', overrideWeight: 0.75}]\n * @property {Object} [k={name: \'k\'}]\n * @property {Object} [i={name: \'i\'}]\n * @property {Object} [r={name: \'r\'}]\n * @property {Object} [s={name: \'s\', blendTime: 0.25}]\n * @property {Object} [u={name: \'u\'}]\n * @property {Object} [@={name: \'@\'}]\n * @property {Object} [a={name: \'a\'}]\n * @property {Object} [e={name: \'e\', blendTime: 0.2}]\n * @property {Object} [E={name: \'E\'}]\n * @property {Object} [o={name: \'o\'}]\n * @property {Object} [O={name: \'O\'}]\n */\n\nvar DefaultVisemeMap = {\n  sil: {\n    name: \'sil\'\n  },\n  p: {\n    name: \'p\',\n    overrideWeight: 0.9\n  },\n  t: {\n    name: \'t\',\n    blendTime: 0.2\n  },\n  S: {\n    name: \'S\'\n  },\n  T: {\n    name: \'T\'\n  },\n  f: {\n    name: \'f\',\n    overrideWeight: 0.75\n  },\n  k: {\n    name: \'k\'\n  },\n  i: {\n    name: \'i\'\n  },\n  r: {\n    name: \'r\'\n  },\n  s: {\n    name: \'s\',\n    blendTime: 0.25\n  },\n  u: {\n    name: \'u\'\n  },\n  \'@\': {\n    name: \'@\'\n  },\n  a: {\n    name: \'a\'\n  },\n  e: {\n    name: \'e\',\n    blendTime: 0.2\n  },\n  E: {\n    name: \'E\'\n  },\n  o: {\n    name: \'o\'\n  },\n  O: {\n    name: \'O\'\n  }\n};\n/**\n * Lipsync controls two types of movement: idle animation that should play while\n * speech is playing and viseme animations corresponding to Polly visemes whose\n * weights should be turned on and off as they are encountered in the Polly SSML\n * transcript. Layers owned by this feature will be enabled while speech is playing\n * and disabled once it stops.\n *\n * @extends AbstractHostFeature\n * @alias core/LipsyncFeature\n * @implements TextToSpeechFeatureDependentInterface\n * @implements ManagedAnimationLayerInterface\n */\n\nvar LipsyncFeature = /*#__PURE__*/function (_AbstractHostFeature$) {\n  LipsyncFeature_inherits(LipsyncFeature, _AbstractHostFeature$);\n\n  var _super = LipsyncFeature_createSuper(LipsyncFeature);\n\n  /**\n   * @constructor\n   *\n   * @param {core/HostObject} host - Host that owns the feature.\n   * @param {Object=} visemeOptions - Options for the viseme layers.\n   * @param {number} [visemeOptions.blendTime=0.15] - Default amount of time it\n   * will take to manipulate each freeBlend weight on the viseme states.\n   * @param {Object} [visemeOptions.decayRate={amount: .5, seconds: .5}] - An object\n   * describing the 0-1 factor viseme weight will decay if the viseme duration is\n   * longer than the blendTime and the number of seconds it would take to decay\n   * by that factor.\n   * @param {number} [visemeOptions.easingFn=Quadratic.InOut] - Default easing function\n   * to use when manipulating viseme freeBlend weights.\n   * @param {Array.<Object>} [visemeOptions..layers=[]] - An array of layer options\n   * objects to register as viseme layers.\n   * @param {Object=} talkingOptions - Options for the talking layers.\n   * @param {number} [talkingOptions.blendTime=0.75] - Default amount of time to\n   * enable and disable the talking idle layers\n   * @param {number} [talkingOptions.easingFn=Quadratic.InOut] - Default easing\n   * function to use when manipulating weights on the talking idle layers.\n   * @param {Array.<Object>} [talkingOptions.layers=[]] - An array of layer options\n   * objects to register as talking layers.\n   * @param {number} [visemeLeadTime=.067] - The amount of time to instruct the\n   * TextToSpeechFeature to emit speechmarks before each one\'s actual timestamp\n   * is reached. This will set the \'speechMarkOffset\' variable on the TextToSpeechFeature.\n   */\n  function LipsyncFeature(host) {\n    var _this;\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$blendTime = _ref.blendTime,\n        visemeBlendTime = _ref$blendTime === void 0 ? 0.15 : _ref$blendTime,\n        _ref$decayRate = _ref.decayRate;\n\n    _ref$decayRate = _ref$decayRate === void 0 ? {} : _ref$decayRate;\n    var _ref$decayRate$amount = _ref$decayRate.amount,\n        amount = _ref$decayRate$amount === void 0 ? 0.5 : _ref$decayRate$amount,\n        _ref$decayRate$second = _ref$decayRate.seconds,\n        seconds = _ref$decayRate$second === void 0 ? 0.5 : _ref$decayRate$second,\n        _ref$easingFn = _ref.easingFn,\n        visemeEasingFn = _ref$easingFn === void 0 ? Quadratic.InOut : _ref$easingFn,\n        _ref$layers = _ref.layers,\n        visemeLayers = _ref$layers === void 0 ? [] : _ref$layers;\n\n    var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref2$blendTime = _ref2.blendTime,\n        talkingBlendTime = _ref2$blendTime === void 0 ? 0.75 : _ref2$blendTime,\n        _ref2$easingFn = _ref2.easingFn,\n        talkingEasingFn = _ref2$easingFn === void 0 ? Quadratic.InOut : _ref2$easingFn,\n        _ref2$layers = _ref2.layers,\n        talkingLayers = _ref2$layers === void 0 ? [] : _ref2$layers;\n\n    var visemeLeadTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.067;\n\n    LipsyncFeature_classCallCheck(this, LipsyncFeature);\n\n    _this = _super.call(this, host);\n    _this._visemeLayers = {};\n    _this._talkingLayers = {};\n    _this.visemeLeadTime = visemeLeadTime; // Register the viseme layers\n\n    visemeLayers.forEach(function (_ref3) {\n      var name = _ref3.name,\n          animation = _ref3.animation,\n          _ref3$visemeMap = _ref3.visemeMap,\n          visemeMap = _ref3$visemeMap === void 0 ? DefaultVisemeMap : _ref3$visemeMap;\n\n      _this.registerVisemeLayer(name, {\n        animation: animation,\n        visemeMap: visemeMap,\n        decayRate: {\n          amount: amount,\n          seconds: seconds\n        },\n        blendTime: visemeBlendTime,\n        easingFn: visemeEasingFn\n      });\n    }); // Register the talking layers\n\n    talkingLayers.forEach(function (_ref4) {\n      var name = _ref4.name,\n          animation = _ref4.animation;\n\n      _this.registerTalkingLayer(name, {\n        animation: animation,\n        blendTime: talkingBlendTime,\n        easingFn: talkingEasingFn\n      });\n    });\n    return _this;\n  }\n  /**\n   * Ensure that registered viseme animations are FreeBlendStates.\n   *\n   * @private\n   *\n   * @param {string} layerName - Name of the layer that contains the viseme animation.\n   * @param {string} animationName - Name of the animation.\n   */\n\n\n  LipsyncFeature_createClass(LipsyncFeature, [{\n    key: "_registerVisemeAnimation",\n    value: function _registerVisemeAnimation(layerName, animationName) {\n      if (this._managedLayers[layerName].animations[animationName].isActive) {\n        if (this._host.AnimationFeature.getAnimationType(layerName, animationName) !== \'freeBlend\') {\n          // Warn and deactivate if the registered state is not freeBlend\n          console.warn("Cannot register Lipsync viseme animation ".concat(animationName, " on layer ").concat(layerName, " for host ").concat(this._host.id, ". Viseme animations must be of type \'freeBlend\'."));\n          this._managedLayers[layerName].animations[animationName].isActive = false;\n        } else {\n          // Check if the blendWeights can be manipulated now\n          var weightNames = this._host.AnimationFeature.getAnimationBlendNames(layerName, animationName);\n\n          var visemeMap = this._managedLayers[layerName].animations[animationName].visemeMap;\n          Object.values(visemeMap).forEach(function (visemeOptions) {\n            visemeOptions.isActive = weightNames.includes(visemeOptions.name);\n          });\n        }\n      }\n    }\n    /**\n     * If the added feature is TextToSpeech, update its speechMarkOffset variable.\n     *\n     * @private\n     *\n     * @param {string} typeName - Name of the type of feature that was added.\n     */\n\n  }, {\n    key: "_onFeatureAdded",\n    value: function _onFeatureAdded(typeName) {\n      this._visemeLayers = this._visemeLayers || {};\n      this._talkingLayers = this._talkingLayers || {};\n\n      LipsyncFeature_get(LipsyncFeature_getPrototypeOf(LipsyncFeature.prototype), "_onFeatureAdded", this).call(this, typeName);\n\n      if (typeName === \'TextToSpeechFeature\') {\n        this._host.TextToSpeechFeature.speechmarkOffset = -this._visemeLeadTime || 0;\n      }\n    }\n  }, {\n    key: "_onLayerAdded",\n    value: function _onLayerAdded(_ref5) {\n      var name = _ref5.name;\n\n      LipsyncFeature_get(LipsyncFeature_getPrototypeOf(LipsyncFeature.prototype), "_onLayerAdded", this).call(this, {\n        name: name\n      }); // Validate the viseme animation\n\n\n      if (this._visemeLayers[name] !== undefined) {\n        this._registerVisemeAnimation(name, this._visemeLayers[name]);\n      }\n    }\n  }, {\n    key: "_onAnimationAdded",\n    value: function _onAnimationAdded(_ref6) {\n      var layerName = _ref6.layerName,\n          animationName = _ref6.animationName;\n\n      LipsyncFeature_get(LipsyncFeature_getPrototypeOf(LipsyncFeature.prototype), "_onAnimationAdded", this).call(this, {\n        layerName: layerName\n      }); // Validate the viseme animation\n\n\n      if (this._visemeLayers[layerName] === animationName) {\n        this._registerVisemeAnimation(layerName, this._visemeLayers[layerName]);\n      }\n    }\n  }, {\n    key: "_onPlay",\n    value: function _onPlay() {\n      var _this2 = this;\n\n      // Turn on the layer weights\n      this.enable(); // Set the current animations\n\n      [this._visemeLayers, this._talkingLayers].forEach(function (layers) {\n        Object.entries(layers).forEach(function (_ref7) {\n          var _ref8 = LipsyncFeature_slicedToArray(_ref7, 2),\n              layerName = _ref8[0],\n              animationName = _ref8[1];\n\n          if (_this2._managedLayers[layerName].animations[animationName].isActive) {\n            _this2._host.AnimationFeature.resumeAnimation(layerName, animationName);\n          }\n        });\n      });\n    }\n  }, {\n    key: "_onPause",\n    value: function _onPause() {\n      this._onStop();\n    }\n  }, {\n    key: "_onResume",\n    value: function _onResume() {\n      this._onPlay();\n    }\n  }, {\n    key: "_onStop",\n    value: function _onStop() {\n      var _this3 = this;\n\n      // Turn off the layer weights\n      this.disable(); // Pause the current animations\n\n      [this._visemeLayers, this._talkingLayers].forEach(function (layers) {\n        Object.entries(layers).forEach(function (_ref9) {\n          var _ref10 = LipsyncFeature_slicedToArray(_ref9, 2),\n              layerName = _ref10[0],\n              animationName = _ref10[1];\n\n          if (_this3._managedLayers[layerName].animations[animationName].isActive) {\n            _this3._host.AnimationFeature.pauseAnimation(layerName, animationName);\n          }\n        });\n      });\n    }\n    /**\n     * When viseme events are caught, turn on weight of the new viseme for the duration\n     * of the speech mark, then turn weight back off.\n     *\n     * @private\n     *\n     * @param {Object} event - Event data passed from the speech.\n     * @param {Object} event.mark - Speechmark object.\n     */\n\n  }, {\n    key: "_onViseme",\n    value: function () {\n      var _onViseme2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref11) {\n        var _this4 = this;\n\n        var mark;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                mark = _ref11.mark;\n                Object.entries(this._visemeLayers).forEach(function (_ref12) {\n                  var _ref13 = LipsyncFeature_slicedToArray(_ref12, 2),\n                      layerName = _ref13[0],\n                      animName = _ref13[1];\n\n                  // Make sure the layer can be manipulated\n                  var _this4$_managedLayers = _this4._managedLayers[layerName].animations[animName],\n                      isActive = _this4$_managedLayers.isActive,\n                      visemeMap = _this4$_managedLayers.visemeMap;\n\n                  if (!isActive) {\n                    return;\n                  } // Take variables from the viseme if they exist and default to the layer\n\n\n                  var _this4$_managedLayers2 = LipsyncFeature_objectSpread(LipsyncFeature_objectSpread({}, _this4._managedLayers[layerName]), visemeMap[mark.value]),\n                      viseme = _this4$_managedLayers2.name,\n                      isVisemeActive = _this4$_managedLayers2.isActive,\n                      decayRate = _this4$_managedLayers2.decayRate,\n                      blendTime = _this4$_managedLayers2.blendTime,\n                      easingFn = _this4$_managedLayers2.easingFn,\n                      overrideWeight = _this4$_managedLayers2.overrideWeight;\n\n                  var visemeNames = _this4._host.AnimationFeature.getAnimationBlendNames(layerName, animName); // Make sure the new viseme has an active freeBlend weight\n\n\n                  if (!isVisemeActive || !visemeNames.includes(viseme)) {\n                    return;\n                  } // Find the peak weight for the viseme and the amount of time it should\n                  // take to reach it\n\n\n                  var weight = 1;\n                  var duration = mark.duration / 1000;\n\n                  if (duration < blendTime) {\n                    var lerpFactor = blendTime > 0 ? duration / blendTime : 1;\n                    weight = overrideWeight !== undefined ? overrideWeight : core_MathUtils.lerp(0, 1, lerpFactor);\n                  }\n\n                  var blendInTime = Math.min(duration, blendTime); // Find the amount and time viseme will be held for\n\n                  var holdTime = duration - blendTime;\n\n                  if (holdTime < 0) {\n                    // Perform in -> out animation\n                    _this4._animateSimpleViseme(layerName, animName, viseme, weight, blendInTime, blendTime, easingFn);\n                  } else {\n                    var _lerpFactor = decayRate.seconds > 0 ? holdTime / decayRate.seconds : 1; // Perform in -> hold -> out animation\n\n\n                    var decayWeight = core_MathUtils.lerp(weight, weight * decayRate.amount, Math.min(1, _lerpFactor));\n\n                    _this4._animateHeldViseme(layerName, animName, viseme, weight, decayWeight, blendInTime, holdTime, blendTime, easingFn);\n                  }\n                });\n\n              case 2:\n              case "end":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _onViseme(_x) {\n        return _onViseme2.apply(this, arguments);\n      }\n\n      return _onViseme;\n    }()\n    /**\n     * Animate a viseme blend weight towards a value and then back to zero.\n     *\n     * @private\n     *\n     * @param {string} layerName - Name of the layer that contains the viseme.\n     * @param {string} animName - Name of the freeblend animation that contains\n     * the viseme.\n     * @param {string} visemeName - Name of the blend weight to manipulate.\n     * @param {number} weight - Peak weight to animate towards.\n     * @param {number} blendInTime - Amount of time it should take to reach the\n     * peak weight.\n     * @param {number} blendOutTime - Amount of time it should take to animate back\n     * to zero after reaching the peak weight.\n     * @param {Function} easingFn - Easing function to use during animation.\n     */\n\n  }, {\n    key: "_animateSimpleViseme",\n    value: function _animateSimpleViseme(layerName, animName, visemeName, peakWeight, blendInTime, blendOutTime, easingFn) {\n      var _this5 = this;\n\n      // Animate towards the peak value\n      var weightPromise = this._host.AnimationFeature.setAnimationBlendWeight(layerName, animName, visemeName, peakWeight, blendInTime, easingFn); // Animate back to zero if there was no weight interruption\n\n\n      weightPromise.then(function () {\n        if (!weightPromise.canceled) {\n          _this5._host.AnimationFeature.setAnimationBlendWeight(layerName, animName, visemeName, 0, blendOutTime, easingFn);\n        }\n      });\n    }\n    /**\n     * Animate a viseme blend weight towards a value and then back to zero.\n     *\n     * @private\n     *\n     * @param {string} layerName - Name of the layer that contains the viseme.\n     * @param {string} animName - Name of the freeblend animation that contains\n     * the viseme.\n     * @param {string} visemeName - Name of the blend weight to manipulate.\n     * @param {number} peakWeight - Peak weight to animate towards.\n     * @param {number} decayWeight - Weight to animate towards after reaching the\n     * peak weight.\n     * @param {number} blendInTime - Amount of time it should take to reach the\n     * peak weight.\n     * @param {number} holdTime - Amount of time it should take to reach the decay\n     * weight after the peak weight has been reached.\n     * @param {number} blendOutTime - Amount of time it should take to animate back\n     * to zero after reaching the decay weight.\n     * @param {Function} easingFn - Easing function to use during animation.\n     */\n\n  }, {\n    key: "_animateHeldViseme",\n    value: function () {\n      var _animateHeldViseme2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(layerName, animName, visemeName, peakWeight, decayWeight, blendInTime, holdTime, blendOutTime, easingFn) {\n        var startPromise, holdPromise;\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                // Animate towards the peak value\n                startPromise = this._host.AnimationFeature.setAnimationBlendWeight(layerName, animName, visemeName, peakWeight, blendInTime, easingFn);\n                _context2.next = 3;\n                return startPromise;\n\n              case 3:\n                if (startPromise.canceled) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                // Animate towards the decay value if there was no weight interruption\n                holdPromise = this._host.AnimationFeature.setAnimationBlendWeight(layerName, animName, visemeName, decayWeight, holdTime, easingFn);\n                _context2.next = 7;\n                return holdPromise;\n\n              case 7:\n                if (!holdPromise.canceled) {\n                  // Animate back to zero if there was no weight interruption\n                  this._host.AnimationFeature.setAnimationBlendWeight(layerName, animName, visemeName, 0, blendOutTime, easingFn);\n                }\n\n              case 8:\n              case "end":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _animateHeldViseme(_x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9, _x10) {\n        return _animateHeldViseme2.apply(this, arguments);\n      }\n\n      return _animateHeldViseme;\n    }()\n    /**\n     * Gets and sets the amount of time in seconds to negatively offset speechmark\n     * emission by.\n     *\n     * @type {number}\n     */\n\n  }, {\n    key: "visemeLeadTime",\n    get: function get() {\n      return this._visemeLeadTime;\n    },\n    set: function set(seconds) {\n      this._visemeLeadTime = seconds;\n\n      if (this._host.TextToSpeechFeature) {\n        this._host.TextToSpeechFeature.speechmarkOffset = -seconds;\n      }\n    }\n    /**\n     * Start keeping track of an animation layer that owns a freeBlend animation\n     * with blendWeights corresponding to visemes.\n     *\n     * @param {string} layerName - Name of the layer to keep track of.\n     * @param {Object=} options - Options for the layer.\n     * @param {string} [options.animation=\'visemes\'] - Name of the animation on the\n     * layer that will be played during speech. This animation must be of type\n     * freeBlend.\n     * @param {Object=} decayRate\n     * @param {number} [decayRate.amount=0.5] - The percentage to decrease the viseme\'s\n     * peak value by over time once the peak value has been reached.\n     * @param {number} [decayRate.seconds=0.5] - The amount of time in seconds to\n     * decrease the viseme\'s weight once it has reached its peak value.\n     * @param {number=} [options.blendTime=[LipsyncFeature.DEFAULT_LAYER_OPTIONS.blendTime]{@link LipsyncFeature#DEFAULT_LAYER_OPTIONS#blendTime}] -\n     * Default amount of time to use when manipulating animation blendWeights.\n     * @param {Function=} options.easingFn - Default easing function to use when\n     * manipulating animation blendWeights.\n     * @param {Object} [options.visemeMap=DefaultVisemeMap] - Object containing key/value pairs of\n     * Polly viseme names mapped to objects containing the name of the corresponding\n     * animation blendWeight and any other animation options to use such as viseme\n     * specific blend times and easing functions.\n     */\n\n  }, {\n    key: "registerVisemeLayer",\n    value: function registerVisemeLayer(layerName) {\n      var _ref14 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref14$animation = _ref14.animation,\n          animation = _ref14$animation === void 0 ? \'visemes\' : _ref14$animation,\n          _ref14$decayRate = _ref14.decayRate,\n          decayRate = _ref14$decayRate === void 0 ? {\n        amount: 0.5,\n        seconds: 0.5\n      } : _ref14$decayRate,\n          _ref14$blendTime = _ref14.blendTime,\n          blendTime = _ref14$blendTime === void 0 ? LipsyncFeature.DEFAULT_LAYER_OPTIONS.blendTime : _ref14$blendTime,\n          easingFn = _ref14.easingFn,\n          _ref14$visemeMap = _ref14.visemeMap,\n          visemeMap = _ref14$visemeMap === void 0 ? DefaultVisemeMap : _ref14$visemeMap;\n\n      // Register the layer and animation\n      this.registerLayer(layerName, {\n        decayRate: decayRate,\n        blendTime: blendTime,\n        easingFn: easingFn,\n        animations: LipsyncFeature_defineProperty({}, animation, {\n          visemeMap: visemeMap\n        })\n      });\n      this._visemeLayers[layerName] = animation; // Validate the viseme animation\n\n      this._registerVisemeAnimation(layerName, animation);\n    }\n    /**\n     * Start keeping track of an animation layer that contains a looping animation\n     * to be played during speech.\n     *\n     * @param {string} layerName - Name of the layer to keep track of.\n     * @param {Object=} options - Options for the layer.\n     * @param {string} [options.animation=\'stand_talk\'] - Name of the animation on the\n     * layer that will be played during speech.\n     * @param {number} [options.blendTime=[LipsyncFeature.DEFAULT_LAYER_OPTIONS.blendTime]{@link LipsyncFeature#DEFAULT_LAYER_OPTIONS#blendTime}] -\n     * Default amount of time to use when manipulating the layer\'s weights.\n     * @param {Function=} options.easingFn - Default easing function to use when\n     * manipulating the layer\'s weights.\n     */\n\n  }, {\n    key: "registerTalkingLayer",\n    value: function registerTalkingLayer(layerName) {\n      var _ref15 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref15$animation = _ref15.animation,\n          animation = _ref15$animation === void 0 ? \'stand_talk\' : _ref15$animation,\n          _ref15$blendTime = _ref15.blendTime,\n          blendTime = _ref15$blendTime === void 0 ? LipsyncFeature.DEFAULT_LAYER_OPTIONS.blendTime : _ref15$blendTime,\n          easingFn = _ref15.easingFn;\n\n      // Register the layer and animation\n      this.registerLayer(layerName, {\n        blendTime: blendTime,\n        easingFn: easingFn,\n        animations: LipsyncFeature_defineProperty({}, animation, {})\n      });\n      this._talkingLayers[layerName] = animation;\n    }\n    /**\n     * Adds a namespace to the host with the name of the feature to contain properties\n     * and methods from the feature that users of the host need access to.\n     *\n     * @see LipsyncFeature\n     */\n\n  }, {\n    key: "installApi",\n    value: function installApi() {\n      var _this6 = this;\n\n      /**\n       * @inner\n       * @namespace LipsyncFeature\n       */\n      var api = LipsyncFeature_get(LipsyncFeature_getPrototypeOf(LipsyncFeature.prototype), "installApi", this).call(this);\n      /**\n       * @memberof LipsyncFeature\n       * @name registerLayer\n       * @instance\n       * @method\n       * @see ManagedAnimationLayerInterface#registerLayer\n       */\n\n      /**\n       * @memberof LipsyncFeature\n       * @name registerAnimation\n       * @instance\n       * @method\n       * @see ManagedAnimationLayerInterface#registerAnimation\n       */\n\n      /**\n       * @memberof LipsyncFeature\n       * @name setLayerWeights\n       * @instance\n       * @method\n       * @see ManagedAnimationLayerInterface#setLayerWeights\n       */\n\n      /**\n       * @memberof LipsyncFeature\n       * @name enable\n       * @instance\n       * @method\n       * @see ManagedAnimationLayerInterface#enable\n       */\n\n      /**\n       * @memberof LipsyncFeature\n       * @name disable\n       * @instance\n       * @method\n       * @see ManagedAnimationLayerInterface#disable\n       */\n\n\n      Object.assign(api, {\n        /**\n         * @memberof LipsyncFeature\n         * @instance\n         * @method\n         * @see core/LipsyncFeature#registerVisemeLayer\n         */\n        registerVisemeLayer: this.registerVisemeLayer.bind(this),\n\n        /**\n         * @memberof LipsyncFeature\n         * @instance\n         * @method\n         * @see core/LipsyncFeature#registerTalkingLayer\n         */\n        registerTalkingLayer: this.registerTalkingLayer.bind(this)\n      });\n      /**\n       * @memberof LipsyncFeature\n       * @instance\n       * @name visemeLeadTime\n       * @see core/LipsyncFeature#visemeLeadTime\n       */\n\n      Object.defineProperty(api, \'visemeLeadTime\', {\n        get: function get() {\n          return _this6.visemeLeadTime;\n        },\n        set: function set(seconds) {\n          _this6.visemeLeadTime = seconds;\n        }\n      });\n      return api;\n    }\n  }]);\n\n  return LipsyncFeature;\n}(core_AbstractHostFeature.mix(awspack_TextToSpeechFeatureDependentInterface.Mixin, animpack_ManagedAnimationLayerInterface.Mixin));\n\n/* harmony default export */ const core_LipsyncFeature = (LipsyncFeature);\n\n;// CONCATENATED MODULE: ./src/core/awspack/SSMLSpeechmarkInterface.js\nfunction SSMLSpeechmarkInterface_typeof(obj) { "@babel/helpers - typeof"; return SSMLSpeechmarkInterface_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, SSMLSpeechmarkInterface_typeof(obj); }\n\nfunction SSMLSpeechmarkInterface_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction SSMLSpeechmarkInterface_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction SSMLSpeechmarkInterface_createClass(Constructor, protoProps, staticProps) { if (protoProps) SSMLSpeechmarkInterface_defineProperties(Constructor.prototype, protoProps); if (staticProps) SSMLSpeechmarkInterface_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction SSMLSpeechmarkInterface_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) SSMLSpeechmarkInterface_setPrototypeOf(subClass, superClass); }\n\nfunction SSMLSpeechmarkInterface_setPrototypeOf(o, p) { SSMLSpeechmarkInterface_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return SSMLSpeechmarkInterface_setPrototypeOf(o, p); }\n\nfunction SSMLSpeechmarkInterface_createSuper(Derived) { var hasNativeReflectConstruct = SSMLSpeechmarkInterface_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = SSMLSpeechmarkInterface_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = SSMLSpeechmarkInterface_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return SSMLSpeechmarkInterface_possibleConstructorReturn(this, result); }; }\n\nfunction SSMLSpeechmarkInterface_possibleConstructorReturn(self, call) { if (call && (SSMLSpeechmarkInterface_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return SSMLSpeechmarkInterface_assertThisInitialized(self); }\n\nfunction SSMLSpeechmarkInterface_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction SSMLSpeechmarkInterface_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction SSMLSpeechmarkInterface_getPrototypeOf(o) { SSMLSpeechmarkInterface_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return SSMLSpeechmarkInterface_getPrototypeOf(o); }\n\n/* eslint-disable no-unused-vars */\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable max-classes-per-file */\n\n/* eslint-disable no-empty */\n\n/**\n * Class factory interface for that registers callback method when a ssml speechmark event is emitted.\n *\n * @interface\n * @extends TextToSpeechFeatureDependentInterface\n */\n\nvar SSMLSpeechmarkInterface = /*#__PURE__*/function (_TextToSpeechFeatureD) {\n  SSMLSpeechmarkInterface_inherits(SSMLSpeechmarkInterface, _TextToSpeechFeatureD);\n\n  var _super = SSMLSpeechmarkInterface_createSuper(SSMLSpeechmarkInterface);\n\n  function SSMLSpeechmarkInterface() {\n    SSMLSpeechmarkInterface_classCallCheck(this, SSMLSpeechmarkInterface);\n\n    return _super.apply(this, arguments);\n  }\n\n  SSMLSpeechmarkInterface_createClass(SSMLSpeechmarkInterface, [{\n    key: "_onSsml",\n    value:\n    /**\n     * When ssml events are caught, this will try to parse the speech mark value and execute any function which meets criteria defined in the value.\n     * Speech mark value will be treated as stringified json format containing required feature name, function name and argument array to pass in.\n     * Example speech mark value might look like: \'{"feature":"GestureFeature", "method":"switchToGesture", "args":["genricA", 0.5]}\'\n     *\n     * @private\n     *\n     * @param {Object} event - Event data passed from the speech.\n     * @param {Object} event.mark - Speechmark object.\n     */\n    function _onSsml(_ref) {\n      var mark = _ref.mark;\n    }\n    /**\n     * Creates a class that implements {@link SSMLSpeechmarkInterface}\n     * and extends a specified base class.\n     *\n     * @param {Class} BaseClass - The class to extend.\n     *\n     * @return {Class} A class that extends `BaseClass` and implements {@link SSMLSpeechmarkInterface}.\n     */\n\n  }], [{\n    key: "Mixin",\n    value: function Mixin(BaseClass) {\n      var ParentClass = awspack_TextToSpeechFeatureDependentInterface.Mixin(BaseClass);\n\n      var SSMLSpeechMarkMixin = /*#__PURE__*/function (_ParentClass) {\n        SSMLSpeechmarkInterface_inherits(SSMLSpeechMarkMixin, _ParentClass);\n\n        var _super2 = SSMLSpeechmarkInterface_createSuper(SSMLSpeechMarkMixin);\n\n        function SSMLSpeechMarkMixin() {\n          SSMLSpeechmarkInterface_classCallCheck(this, SSMLSpeechMarkMixin);\n\n          return _super2.apply(this, arguments);\n        }\n\n        SSMLSpeechmarkInterface_createClass(SSMLSpeechMarkMixin, [{\n          key: "_onSsml",\n          value: function _onSsml(_ref2) {\n            var mark = _ref2.mark;\n\n            try {\n              var _JSON$parse = JSON.parse(mark.value),\n                  feature = _JSON$parse.feature,\n                  method = _JSON$parse.method,\n                  args = _JSON$parse.args;\n\n              if (this.constructor.name === feature) {\n                var callback = this[method];\n\n                if (callback && typeof callback === \'function\') {\n                  callback.apply(this, args);\n                } else {\n                  console.warn("Function ".concat(method, " does not exist within feature ").concat(feature));\n                }\n              }\n            } catch (e) {}\n          }\n        }]);\n\n        return SSMLSpeechMarkMixin;\n      }(ParentClass);\n\n      return SSMLSpeechMarkMixin;\n    }\n  }]);\n\n  return SSMLSpeechmarkInterface;\n}(awspack_TextToSpeechFeatureDependentInterface);\n\n/* harmony default export */ const awspack_SSMLSpeechmarkInterface = (SSMLSpeechmarkInterface);\n;// CONCATENATED MODULE: ./src/core/GestureFeature.js\nfunction GestureFeature_typeof(obj) { "@babel/helpers - typeof"; return GestureFeature_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, GestureFeature_typeof(obj); }\n\nfunction GestureFeature_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction GestureFeature_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? GestureFeature_ownKeys(Object(source), !0).forEach(function (key) { GestureFeature_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : GestureFeature_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction GestureFeature_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction GestureFeature_slicedToArray(arr, i) { return GestureFeature_arrayWithHoles(arr) || GestureFeature_iterableToArrayLimit(arr, i) || GestureFeature_unsupportedIterableToArray(arr, i) || GestureFeature_nonIterableRest(); }\n\nfunction GestureFeature_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction GestureFeature_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return GestureFeature_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return GestureFeature_arrayLikeToArray(o, minLen); }\n\nfunction GestureFeature_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction GestureFeature_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction GestureFeature_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction GestureFeature_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction GestureFeature_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction GestureFeature_createClass(Constructor, protoProps, staticProps) { if (protoProps) GestureFeature_defineProperties(Constructor.prototype, protoProps); if (staticProps) GestureFeature_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction GestureFeature_get() { if (typeof Reflect !== "undefined" && Reflect.get) { GestureFeature_get = Reflect.get; } else { GestureFeature_get = function _get(target, property, receiver) { var base = GestureFeature_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return GestureFeature_get.apply(this, arguments); }\n\nfunction GestureFeature_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = GestureFeature_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction GestureFeature_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) GestureFeature_setPrototypeOf(subClass, superClass); }\n\nfunction GestureFeature_setPrototypeOf(o, p) { GestureFeature_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return GestureFeature_setPrototypeOf(o, p); }\n\nfunction GestureFeature_createSuper(Derived) { var hasNativeReflectConstruct = GestureFeature_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = GestureFeature_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = GestureFeature_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return GestureFeature_possibleConstructorReturn(this, result); }; }\n\nfunction GestureFeature_possibleConstructorReturn(self, call) { if (call && (GestureFeature_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return GestureFeature_assertThisInitialized(self); }\n\nfunction GestureFeature_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction GestureFeature_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction GestureFeature_getPrototypeOf(o) { GestureFeature_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return GestureFeature_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n\n/**\n * @constant\n */\n\nvar DefaultGestureWords = {\n  big: [\'add\', \'above\', \'authority\', \'big\', \'cover\', \'full\', \'fly\', \'grow\', \'growth\', \'high\', \'huge\', \'increase\', \'major\', \'majority\', \'large\', \'leader\', \'lot\', \'raise\', \'rise\', \'tall\'],\n  heart: [\'accept\', \'admit\', \'believe\', \'care\', \'feeling\', \'feel\', \'friend\', \'grateful\', \'happy\', \'heart\', \'human\', \'pain\', \'save\', \'safe\', \'kind\', \'love\'],\n  "in": [\'include\', \'including\', \'inside\', \'into\', \'now\', \'near\', \'nearest\', \'closest\', \'therein\', \'within\'],\n  many: [\'all\', \'always\', \'any\', \'anyone\', \'among\', \'area\', \'around\', \'beautiful\', \'entire\', \'environment\', \'environments\', \'environmental\', \'everybody\', \'everyone\', \'everything\', \'audience\', \'total\', \'group\', \'groups\', \'million\', \'millions\', \'others\', \'billion\', \'billions\', \'hundred\', \'hundreds\', \'many\', \'thousand\', \'thousands\', \'world\', \'worlds\', \'outside\', \'reveal\'],\n  movement: [\'away\', \'across\', \'ahead\', \'along\', \'far\', \'fast\', \'follow\', \'go\', \'leave\', \'move\', \'movement\', \'through\', \'throughout\', \'toward\', \'travel\', \'turned\', \'passed\'],\n  one: [\'single\', \'one\', \'once\', \'first\', \'firstly\', \'only\', \'solo\', \'warned\', \'truly\', \'up\', \'alone\'],\n  aggressive: [\'power\', \'powers\', \'powerful\', \'assert\', \'assertive\', \'strong\', \'stronger\', \'strongest\', \'strength\', \'flex\', \'dang\', \'damn\', \'damnit\', \'darn\', \'shucks\', \'doh\', \'drat\', \'angry\', \'angrier\', \'angriest\', \'aggressive\', \'annoyed\', \'annoying\', \'attack\', \'attacking\', \'offense\', \'offensive\', \'battle\'],\n  you: [\'you\', \'yall\', "y\'all", \'your\', \'yours\', \'thou\', \'thy\'],\n  defense: [\'defense\', \'fear\', \'repulsed\', \'scared\', \'scary\', \'scarier\', \'scariest\', \'fearful\', \'afraid\', \'cower\', \'cowers\', \'cowering\', \'hideous\', \'doomed\', \'terrified\', \'terrify\', \'terrifying\', \'terrifies\', \'spooky\', \'spookier\', \'spookiest\'],\n  wave: [\'hello\', \'hi\', \'hiya\', \'howdy\', \'welcome\', \'aloha\', \'heya\', \'hey\', \'bye\', \'goodbye\', \'hola\', \'adios\', \'chao\'],\n  self: [\'my\', \'I\', \'myself\', \'self\', "I\'ve", \'Ive\', \'me\', \'mine\', \'own\']\n};\n/**\n * Gesture allows you to play animations on demand on one or more layers from script\n * or ssml. If gesture is played that is a QueueState, the queue will automatically\n * be progressed after a given hold time if a looping queued state is reached. Gesture\n * layers can optionally be automatically disabled when no gesture animation is\n * in progress.\n *\n * @extends AbstractHostFeature\n * @alias core/GestureFeature\n * @implements SSMLSpeechmarkInterface\n * @implements ManagedAnimationLayerInterface\n */\n\nvar GestureFeature = /*#__PURE__*/function (_AbstractHostFeature$) {\n  GestureFeature_inherits(GestureFeature, _AbstractHostFeature$);\n\n  var _super = GestureFeature_createSuper(GestureFeature);\n\n  /**\n   * @constructor\n   *\n   * @param {core/HostObject} host - Host object that owns the feature.\n   * @param {Object=} options - Optional options for the feature.\n   * @param {number} [options.holdTime = 3] - Amount of time in seconds that must\n   * elapse before advancing a gesture that\'s a {@link QueueState} when the current\n   * state in the queue is set to loop infinitely.\n   * @param {number} [options.minimumInterval = 0.25] - The minimum amount of time\n   * in seconds that must elapse before another gesture can be played.\n   * @param  {Object} layers - An object that maps layer names to layer options.\n   * These are the layers that will be registered as tracked gesture layers. See\n   * {@link ManagedAnimationLayerInterface#registerLayer} for more information\n   * on expected format for each layer options object.\n   */\n  function GestureFeature(host) {\n    var _this;\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$holdTime = _ref.holdTime,\n        holdTime = _ref$holdTime === void 0 ? 3 : _ref$holdTime,\n        _ref$minimumInterval = _ref.minimumInterval,\n        minimumInterval = _ref$minimumInterval === void 0 ? 1 : _ref$minimumInterval,\n        _ref$layers = _ref.layers,\n        layers = _ref$layers === void 0 ? {} : _ref$layers;\n\n    GestureFeature_classCallCheck(this, GestureFeature);\n\n    _this = _super.call(this, host);\n    _this.holdTime = holdTime;\n    _this.minimumInterval = minimumInterval; // Register the gesture layers\n\n    Object.entries(layers).forEach(function (_ref2) {\n      var _ref3 = GestureFeature_slicedToArray(_ref2, 2),\n          name = _ref3[0],\n          _ref3$ = _ref3[1],\n          options = _ref3$ === void 0 ? {} : _ref3$;\n\n      _this.registerLayer(name, options);\n    });\n    return _this;\n  }\n  /**\n   * Return a valid hold time value. If hold time isn\'t defined for the animation,\n   * try to use the hold time for the layer. If that\'s not defined, fall back to\n   * the hold time for the feature.\n   *\n   * @private\n   *\n   * @param {Object} layer - Managed layer options object.\n   * @param {Object} animation - Managed animation options object.\n   *\n   * @returns {number}\n   */\n\n\n  GestureFeature_createClass(GestureFeature, [{\n    key: "_getHoldTime",\n    value: function _getHoldTime(layer, animation) {\n      var layerHoldTime = layer.holdTime !== undefined ? layer.holdTime : this.holdTime;\n      return animation.holdTime !== undefined ? animation.holdTime : layerHoldTime;\n    }\n    /**\n     * Return a valid minimum interval value. If minimum interval isn\'t defined for\n     * the animation, try to use the minimum interval for the layer. If that\'s not\n     * defined, fall back to the minimum interval for the feature.\n     *\n     * @private\n     *\n     * @param {Object} layer - Managed layer options object.\n     * @param {Object} animation - Managed animation options object.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: "_getMinimumInterval",\n    value: function _getMinimumInterval(layer, animation) {\n      var layerMinimumInterval = layer.minimumInterval !== undefined ? layer.minimumInterval : this.minimumInterval;\n      return animation.minimumInterval !== undefined ? animation.minimumInterval : layerMinimumInterval;\n    }\n    /**\n     * Callback for {@link core/AnimationFeature#playNextAnimation} event. If the\n     * event is emitted for a managed animation and the new queued state cannot\n     * advance on its own, start a new timer promise that will advance the queue\n     * once it resolves.\n     *\n     * @private\n     *\n     * @param {Object} options - Options object passed from playNextAnimation event.\n     * @param {string} layerName - Name of the layer that owns the queue state.\n     * @param {string} animationName - Name of the queue state animation.\n     * @param {boolean} canAdvance - Whether or not the current state in the queue\n     * can advance on its own.\n     * @param {boolean} isQueueEnd - Whether the current state in the queue is the last\n     * state in the queue.\n     */\n\n  }, {\n    key: "_onNext",\n    value: function _onNext(_ref4) {\n      var _this2 = this;\n\n      var layerName = _ref4.layerName,\n          animationName = _ref4.animationName,\n          canAdvance = _ref4.canAdvance,\n          isQueueEnd = _ref4.isQueueEnd;\n      // Exit if this isn\'t a managed layer\n      var layer = this._managedLayers[layerName];\n\n      if (layer === undefined) {\n        return;\n      } // Exit if it isn\'t a managed animation\n\n\n      var animation = layer.animations[animationName];\n\n      if (animation === undefined) {\n        return;\n      } // Start a new timer for looping states that aren\'t the end of the queue\n\n\n      if (!canAdvance && !isQueueEnd && layer.currentGesture === animationName) {\n        var holdTime = this._getHoldTime(layer, animation);\n\n        layer.holdTimer.cancel(); // Skip to the next animation right away if hold time is zero\n\n        if (holdTime <= 0) {\n          this._host.AnimationFeature.playNextAnimation(layerName, animationName);\n        } // Wait for the given hold time before progressing\n        else {\n          layer.holdTimer = core_Utils.wait(holdTime, {\n            onFinish: function onFinish() {\n              // Advance the queue to the next state\n              if (layer.currentGesture === animationName) {\n                _this2._host.AnimationFeature.playNextAnimation(layerName, animationName);\n              }\n            }\n          });\n        }\n      }\n    }\n    /**\n     * Callback for {@link core/AnimationFeature#stopAnimation} event. If the\n     * event is emitted for a managed animation cancel the layer\'s stored timers.\n     * If the layer is set to auto-disable set its weight to 0.\n     *\n     * @private\n     *\n     * @param {Object} options - Options object passed from playNextAnimation event.\n     * @param {string} layerName - Name of the layer that owns the stopped animation.\n     * @param {string} animationName - Name of the animation that was stopped.\n     */\n\n  }, {\n    key: "_onStop",\n    value: function _onStop(_ref5) {\n      var layerName = _ref5.layerName,\n          animationName = _ref5.animationName;\n      // Make sure the layer is managed\n      var layer = this._managedLayers[layerName];\n\n      if (layer === undefined) {\n        return;\n      } // Make sure the animation is managed\n\n\n      var animation = layer.animations[animationName];\n\n      if (animation !== undefined && animationName === layer.currentGesture) {\n        layer.currentGesture = null;\n        layer.playTimer = null;\n        layer.holdTimer.cancel(); // Turn off layer weight\n\n        if (layer.autoDisable) {\n          this.setLayerWeights(function (name) {\n            return name === layerName;\n          }, 0);\n        }\n      }\n    }\n  }, {\n    key: "_onAnimationAdded",\n    value: function _onAnimationAdded(_ref6) {\n      var layerName = _ref6.layerName,\n          animationName = _ref6.animationName;\n      var layer = this._managedLayers[layerName];\n\n      if (layer !== undefined) {\n        var animation = layer.animations[animationName]; // Register the animation as active if it is unmanaged\n\n        if (animation === undefined) {\n          this.registerAnimation(layerName, animationName);\n        } // Mark the animation as active if it is managed\n        else {\n          animation.isActive = true;\n        }\n      }\n    }\n  }, {\n    key: "registerLayer",\n    value: function registerLayer(name) {\n      var _this3 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      GestureFeature_get(GestureFeature_getPrototypeOf(GestureFeature.prototype), "registerLayer", this).call(this, name, GestureFeature_objectSpread(GestureFeature_objectSpread({}, options), {}, {\n        holdTimer: core_Deferred.resolve(),\n        playTimer: null,\n        currentGesture: null\n      }));\n\n      if (this._managedLayers[name].isActive) {\n        this._host.AnimationFeature.getAnimations(name).forEach(function (anim) {\n          // Automatically register all animations on the layer\n          if (_this3._managedLayers[name].animations[anim] === undefined) {\n            _this3.registerAnimation(name, anim, _this3._managedLayers[name].animations[anim]);\n          }\n        });\n      }\n    }\n  }, {\n    key: "registerAnimation",\n    value: function registerAnimation(layerName, animationName) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      // Try to fall back to a default word array\n      if (!(options.words instanceof Array) && !(options.words instanceof Set)) {\n        options.words = DefaultGestureWords[animationName] || [];\n      }\n\n      GestureFeature_get(GestureFeature_getPrototypeOf(GestureFeature.prototype), "registerAnimation", this).call(this, layerName, animationName, options);\n    }\n    /**\n     * Create an object that maps ssml mark syntax required to play each gesture to\n     * the words array associated with each gesture. Words arrays are defined at when\n     * the gesture animation is registered. Gestures without associated words will\n     * be excluded from the result. The resulting object can be used as an input\n     * for {@link TextToSpeechUtils.autoGenerateSSMLMarks} to update a speech string\n     * with the markup required to play gestures timed with their associated words.\n     *\n     * @returns {Object}\n     */\n\n  }, {\n    key: "createGestureMap",\n    value: function createGestureMap() {\n      var _this4 = this;\n\n      var gestureMap = {};\n      Object.entries(this._managedLayers).forEach(function (_ref7) {\n        var _ref8 = GestureFeature_slicedToArray(_ref7, 2),\n            layerName = _ref8[0],\n            animations = _ref8[1].animations;\n\n        Object.entries(animations).forEach(function (_ref9) {\n          var _ref10 = GestureFeature_slicedToArray(_ref9, 2),\n              animationName = _ref10[0],\n              _ref10$ = _ref10[1],\n              holdTime = _ref10$.holdTime,\n              minimumInterval = _ref10$.minimumInterval,\n              words = _ref10$.words,\n              transitionTime = _ref10$.transitionTime;\n\n          // Only store gestures that have any associated words\n          if (words.length) {\n            var options = GestureFeature_objectSpread(GestureFeature_objectSpread(GestureFeature_objectSpread({}, holdTime && {\n              holdTime: holdTime\n            }), minimumInterval && {\n              minimumInterval: minimumInterval\n            }), transitionTime && {\n              transitionTime: transitionTime\n            });\n\n            var key = {\n              feature: _this4.constructor.name,\n              method: \'playGesture\',\n              args: [layerName, animationName, options]\n            };\n            gestureMap[JSON.stringify(key)] = words;\n          }\n        });\n      });\n      return gestureMap;\n    }\n    /**\n     * Create an array that contains ssml mark syntax required to play each gesture\n     * that does not have any associated words. The resulting array can be used as\n     * an input for {@link TextToSpeechUtils.autoGenerateSSMLMarks} or\n     * {@link TextToSpeechUtils.addMarksToUnmarkedSentences} to update a speech\n     * string with the markup required to play random gestures at each unmarked\n     * sentence in the string.\n     *\n     * @param {Array.<string>=} layers - An array of names of managed layers to generate\n     * marks for. If undefined, use all managed layers.\n     *\n     * @returns {Array.<string>}\n     */\n\n  }, {\n    key: "createGenericGestureArray",\n    value: function createGenericGestureArray(layers) {\n      var _this5 = this;\n\n      var genericGestures = [];\n      layers = layers || Object.keys(this._managedLayers);\n      layers.forEach(function (layerName) {\n        var layer = _this5._managedLayers[layerName]; // Make sure the layer is managed\n\n        if (!layer) {\n          return;\n        }\n\n        Object.entries(layer.animations).forEach(function (_ref11) {\n          var _ref12 = GestureFeature_slicedToArray(_ref11, 2),\n              animationName = _ref12[0],\n              _ref12$ = _ref12[1],\n              holdTime = _ref12$.holdTime,\n              minimumInterval = _ref12$.minimumInterval,\n              words = _ref12$.words,\n              transitionTime = _ref12$.transitionTime;\n\n          // Only store gestures that don\'t have any associated words\n          if (!words.length) {\n            var options = GestureFeature_objectSpread(GestureFeature_objectSpread(GestureFeature_objectSpread({}, holdTime && {\n              holdTime: holdTime\n            }), minimumInterval && {\n              minimumInterval: minimumInterval\n            }), transitionTime && {\n              transitionTime: transitionTime\n            });\n\n            var key = JSON.stringify({\n              feature: _this5.constructor.name,\n              method: \'playGesture\',\n              args: [layerName, animationName, options]\n            });\n\n            if (!genericGestures.includes(key)) {\n              genericGestures.push(key);\n            }\n          }\n        });\n      });\n      return genericGestures;\n    }\n    /**\n     * Play a managed gesture animation.\n     *\n     * @param {string} layerName - The name of the layer that contains the gesture\n     * animation.\n     * @param {string} animationName - The name of the gesture animation.\n     * @param {Object=} options - Optional gesture options.\n     * @param {number=} options.holdTime - This option only applies to {@link QueueState}\n     * gestures. When a QueueState gesture progresses to a looping state, this option\n     * defines how many seconds should elapse before moving the queue forward. If\n     * undefined, it will fall back first to the holdTime defined in the options when\n     * the gesture animation was registered and then to the holdTime defined on the\n     * feature.\n     * @param {number=} options.minimumInterval - The minimum amount of time that\n     * must have elapsed since the last time a gesture was played.\n     */\n\n  }, {\n    key: "playGesture",\n    value: function playGesture(layerName, animationName) {\n      var _ref13 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n          holdTime = _ref13.holdTime,\n          minimumInterval = _ref13.minimumInterval,\n          transitionTime = _ref13.transitionTime,\n          _ref13$force = _ref13.force,\n          force = _ref13$force === void 0 ? false : _ref13$force;\n\n      // Make sure the animation is registered\n      if (this._managedLayers[layerName] === undefined || this._managedLayers[layerName].animations[animationName] === undefined) {\n        this.registerAnimation(layerName, animationName, {\n          holdTime: holdTime,\n          minimumInterval: minimumInterval,\n          transitionTime: transitionTime\n        });\n      }\n\n      var layer = this._managedLayers[layerName];\n      var animation = layer.animations[animationName]; // Make sure the animation is active\n\n      if (!animation.isActive) {\n        // Create warning message based on which object doesn\'t exist yet\n        var typeName = layer.isActive ? \'animation\' : \'layer\';\n        var message = "Skipping gesture ".concat(animationName, " on layer ").concat(layerName, " for host ").concat(this._host.id, ". No ").concat(typeName, " exists with this name yet.");\n        console.warn(message);\n        return core_Deferred.cancel({\n          reason: \'inactive\',\n          value: typeName\n        });\n      } // Check if the gesture is already playing\n\n\n      var currentGesture = layer.currentGesture;\n\n      if (currentGesture === animationName && !force) {\n        var _message = "Skipping gesture ".concat(animationName, " on layer ").concat(layerName, " for host ").concat(this._host.id, ". The gesture is already playing. Use options.force to force the gesture replay, which may result in a hard transition.");\n\n        console.warn(_message);\n        return core_Deferred.cancel({\n          reason: \'playing\',\n          value: animationName\n        });\n      } // Update animation options\n\n\n      if (holdTime !== undefined) {\n        animation.holdTime = holdTime;\n      }\n\n      if (minimumInterval !== undefined) {\n        animation.minimumInterval = minimumInterval;\n      } else {\n        minimumInterval = this._getMinimumInterval(layer, animation);\n      } // Check the interval\n\n\n      if (!force && layer.playTimer !== null && layer.playTimer < minimumInterval) {\n        console.warn("Skipping gesture ".concat(animationName, " on layer ").concat(layerName, " for host ").concat(this._host.id, ". Minimum interval ").concat(minimumInterval, " has not been met."));\n        return core_Deferred.cancel({\n          reason: \'minimumInterval\',\n          value: minimumInterval - layer.playTimer\n        });\n      } // Play the animation\n\n\n      layer.currentGesture = animationName;\n      layer.playTimer = 0;\n      layer.holdTimer.cancel();\n\n      if (layer.autoDisable) {\n        this.setLayerWeights(function (name) {\n          return name === layerName;\n        }, 1);\n      }\n\n      return this._host.AnimationFeature.playAnimation(layerName, animationName, transitionTime);\n    }\n  }, {\n    key: "update",\n    value: function update(deltaTime) {\n      var _this6 = this;\n\n      GestureFeature_get(GestureFeature_getPrototypeOf(GestureFeature.prototype), "update", this).call(this, deltaTime); // Increment the timers\n\n\n      Object.entries(this._managedLayers).forEach(function (_ref14) {\n        var _ref15 = GestureFeature_slicedToArray(_ref14, 2),\n            name = _ref15[0],\n            options = _ref15[1];\n\n        if (options.isActive && !_this6._host.AnimationFeature.getPaused(name)) {\n          options.holdTimer.execute(deltaTime);\n\n          if (options.playTimer !== null) {\n            options.playTimer += deltaTime / 1000;\n          }\n        }\n      });\n    }\n  }, {\n    key: "installApi",\n    value: function installApi() {\n      /**\n       * @inner\n       * @namespace GestureFeature\n       */\n      var api = GestureFeature_get(GestureFeature_getPrototypeOf(GestureFeature.prototype), "installApi", this).call(this);\n\n      Object.assign(api, {\n        /**\n         * @memberof GestureFeature\n         * @instance\n         * @method\n         * @see GestureFeature#createGestureMap\n         */\n        createGestureMap: this.createGestureMap.bind(this),\n\n        /**\n         * @memberof GestureFeature\n         * @instance\n         * @method\n         * @see GestureFeature#createGenericGestureArray\n         */\n        createGenericGestureArray: this.createGenericGestureArray.bind(this),\n\n        /**\n         * @memberof GestureFeature\n         * @instance\n         * @method\n         * @see GestureFeature#playGesture\n         */\n        playGesture: this.playGesture.bind(this)\n      });\n    }\n  }]);\n\n  return GestureFeature;\n}(core_AbstractHostFeature.mix(awspack_SSMLSpeechmarkInterface.Mixin, animpack_ManagedAnimationLayerInterface.Mixin));\n\nObject.defineProperties(GestureFeature, {\n  DEFAULT_LAYER_OPTIONS: {\n    value: GestureFeature_objectSpread(GestureFeature_objectSpread({}, GestureFeature.DEFAULT_LAYER_OPTIONS), {}, {\n      autoDisable: true\n    }),\n    writable: false\n  },\n  EVENT_DEPENDENCIES: {\n    value: GestureFeature_objectSpread(GestureFeature_objectSpread({}, GestureFeature.EVENT_DEPENDENCIES), {}, {\n      AnimationFeature: GestureFeature_objectSpread(GestureFeature_objectSpread({}, GestureFeature.EVENT_DEPENDENCIES.AnimationFeature), {}, {\n        playNextAnimation: \'_onNext\',\n        stopAnimation: \'_onStop\',\n        interruptAnimation: \'_onStop\'\n      })\n    })\n  }\n});\n/* harmony default export */ const core_GestureFeature = (GestureFeature);\n\n;// CONCATENATED MODULE: ./src/core/animpack/AnimationUtils.js\nfunction AnimationUtils_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AnimationUtils_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AnimationUtils_createClass(Constructor, protoProps, staticProps) { if (protoProps) AnimationUtils_defineProperties(Constructor.prototype, protoProps); if (staticProps) AnimationUtils_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n/**\n * A collection of useful animation functions.\n *\n * @hideconstructor\n */\n\nvar AnimationUtils = /*#__PURE__*/function () {\n  function AnimationUtils() {\n    AnimationUtils_classCallCheck(this, AnimationUtils);\n  }\n\n  AnimationUtils_createClass(AnimationUtils, null, [{\n    key: "lerp",\n    value: function lerp(from, to, factor) {\n      console.warn("AnimationUtils.lerp is being deprecated. Use MathUtils.lerp instead.");\n      return core_MathUtils.lerp(from, to, factor);\n    }\n    /**\n     * Clamp a number between 2 values.\n     *\n     * @param {number} value - Value to clamp.\n     * @param {number} [min=0] - Minumum value.\n     * @param {number} [max=1] - Maximum value.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: "clamp",\n    value: function clamp(value) {\n      var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      console.warn("AnimationUtils.clamp is being deprecated. Use MathUtils.clamp instead.");\n      return core_MathUtils.clamp(value, min, max);\n    }\n    /**\n     * Return a deferred promise that can be used to update the value of a numeric\n     * property of this object over time. Pass delta time in milliseconds to the\n     * deferred promise\'s execute method in an update loop to animate the property\n     * towards the target value.\n     *\n     * @param {Object} propertyOwner - Object that contains the property to animation.\n     * @param {string} propertyName - Name of the property to animate.\n     * @param {number} targetValue - Target value to reach.\n     * @param {Object=} options - Optional options object\n     * @param {number} [options.seconds=0] - Number of seconds it will take to reach\n     * the target value.\n     * @param {Function} [options.easingFn=Linear.InOut] - Easing function to use for animation.\n     * @param {Function} [options.onFinish] - Callback to execute once the animation completes.\n     * The target value is passed as a parameter.\n     * @param {Function=} options.onProgress - Callback to execute each time the animation\n     * property is updated during the animation. The property\'s value at the time of\n     * the update is passed as a parameter.\n     * @param {Function=} options.onCancel - Callback to execute if the user cancels the\n     * animation before completion. The animation property\'s value at the time of\n     * cancel is passed as a parameter.\n     * @param {Function=} options.onError - Callback to execute if the animation stops\n     * because an error is encountered. The error message is passed as a parameter.\n     *\n     * @returns {Deferred} Resolves with the property\'s value once it reaches the\n     * target value.\n     */\n\n  }, {\n    key: "interpolateProperty",\n    value: function interpolateProperty(propertyOwner, propertyName, targetValue) {\n      var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n          _ref$seconds = _ref.seconds,\n          seconds = _ref$seconds === void 0 ? 0 : _ref$seconds,\n          easingFn = _ref.easingFn,\n          _onFinish = _ref.onFinish,\n          _onProgress = _ref.onProgress,\n          _onCancel = _ref.onCancel,\n          onError = _ref.onError;\n\n      // Make sure property is an object\n      if (!(propertyOwner instanceof Object)) {\n        var e = new Error("Cannot interpolate property ".concat(propertyName, ". Property owner must be an object."));\n\n        if (typeof onError === \'function\') {\n          onError(e);\n        }\n\n        return core_Deferred.reject(e);\n      } // Make sure property is numeric\n\n\n      if (Number.isNaN(Number(propertyOwner[propertyName]))) {\n        var _e = new Error("Cannot interpolate property ".concat(propertyName, ". Property must be numeric."));\n\n        if (typeof onError === \'function\') {\n          onError(_e);\n        }\n\n        return core_Deferred.reject(_e);\n      } // Make sure the target value is numeric\n\n\n      if (Number.isNaN(Number(targetValue))) {\n        var _e2 = new Error("Cannot interpolate property ".concat(propertyName, " to value ").concat(targetValue, ". Target value must be numeric."));\n\n        if (typeof onError === \'function\') {\n          onError(_e2);\n        }\n\n        return core_Deferred.reject(_e2);\n      } // Resolve immediately if the target has already been reached\n\n\n      var startValue = propertyOwner[propertyName];\n\n      if (startValue === targetValue) {\n        if (typeof _onFinish === \'function\') {\n          _onFinish(targetValue);\n        }\n\n        return core_Deferred.resolve(targetValue);\n      } // Default to linear interpolation\n\n\n      if (typeof easingFn !== \'function\') {\n        if (easingFn !== undefined) {\n          console.warn("Invalid property interpolation easingFn. Defaulting to linear interpolation.");\n        }\n\n        easingFn = Linear.InOut;\n      }\n\n      var interpolator = core_Utils.wait(seconds, {\n        onFinish: function onFinish() {\n          propertyOwner[propertyName] = targetValue;\n\n          if (typeof _onFinish === \'function\') {\n            _onFinish(targetValue);\n          }\n        },\n        onCancel: function onCancel() {\n          if (typeof _onCancel === \'function\') {\n            _onCancel(propertyOwner[propertyName]);\n          }\n        },\n        onProgress: function onProgress(progress) {\n          if (propertyOwner[propertyName] !== targetValue) {\n            // Calculate the lerp factor\n            var easeFactor = easingFn(progress);\n\n            if (typeof easeFactor !== \'number\') {\n              var _e3 = new Error("Invalid property interpolation easingFn. EasingFn must return a number.");\n\n              interpolator.reject(_e3);\n              return;\n            } // Update the value\n\n\n            propertyOwner[propertyName] = core_MathUtils.lerp(startValue, targetValue, easeFactor);\n          } // Signal progress\n\n\n          if (typeof _onProgress === \'function\') {\n            _onProgress(propertyOwner[propertyName]);\n          } // Signal completion once time is up\n\n\n          if (progress === 1) {\n            propertyOwner[propertyName] = targetValue;\n            interpolator.resolve(targetValue);\n          }\n        },\n        onError: onError\n      });\n      return interpolator;\n    }\n  }]);\n\n  return AnimationUtils;\n}();\n\n/* harmony default export */ const animpack_AnimationUtils = (AnimationUtils);\n;// CONCATENATED MODULE: ./src/core/animpack/state/AbstractState.js\nfunction AbstractState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AbstractState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AbstractState_createClass(Constructor, protoProps, staticProps) { if (protoProps) AbstractState_defineProperties(Constructor.prototype, protoProps); if (staticProps) AbstractState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n/**\n * Base class for a state in our animation system.\n *\n * @abstract\n */\n\nvar AbstractState = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   *\n   * @param {Object=} options - Options for the animation state.\n   * @param {string=} options.name - Name for the animation state. Names must be\n   * unique for the container the state is applied to and should be validated at\n   * the container level. If no name is given it will default to the constructor\n   * name.\n   * @param {weight} [options.weight=0] - The 0-1 amount of influence the state will have.\n   */\n  function AbstractState() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    AbstractState_classCallCheck(this, AbstractState);\n\n    this.name = options.name !== undefined ? options.name : this.constructor.name;\n    this._weight = options.weight !== undefined ? core_MathUtils.clamp(options.weight, 0, 1) : 0;\n    this._internalWeight = this._weight;\n    this._paused = false;\n    this._promises = {\n      finish: core_Deferred.resolve(),\n      weight: core_Deferred.resolve(),\n      play: core_Deferred.resolve()\n    };\n    this._playCallbacks = {\n      onFinish: undefined,\n      onError: undefined,\n      onCancel: undefined\n    };\n  }\n  /**\n   * Gets whether or not the state is currently paused.\n   *\n   * @type {number}\n   */\n\n\n  AbstractState_createClass(AbstractState, [{\n    key: "paused",\n    get: function get() {\n      return this._paused;\n    }\n    /**\n     * Gets and sets the user defined weight.\n     *\n     * @type {number}\n     */\n\n  }, {\n    key: "weight",\n    get: function get() {\n      return this._weight;\n    },\n    set: function set(weight) {\n      this._weight = core_MathUtils.clamp(weight, 0, 1);\n    }\n    /**\n     * Gets whether or not the weight is currently being animated.\n     *\n     * @readonly\n     * @type {boolean}\n     */\n\n  }, {\n    key: "weightPending",\n    get: function get() {\n      return this._promises.weight && this._promises.weight.pending;\n    }\n    /**\n     * Updates the user defined weight over time.\n     *\n     * @param {number} weight - The target weight value.\n     * @param {number} [seconds=0] - The amount of time it will take to reach the\n     * target weight.\n     * @param {Function=} easingFn - The easing function to use for interpolation.\n     *\n     * @returns {Deferred}\n     */\n\n  }, {\n    key: "setWeight",\n    value: function setWeight(weight) {\n      var seconds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var easingFn = arguments.length > 2 ? arguments[2] : undefined;\n\n      this._promises.weight.cancel();\n\n      weight = core_MathUtils.clamp(weight);\n      this._promises.weight = animpack_AnimationUtils.interpolateProperty(this, \'weight\', weight, {\n        seconds: seconds,\n        easingFn: easingFn\n      });\n      return this._promises.weight;\n    }\n    /**\n     * Gets the internal weight.\n     *\n     * @readonly\n     * @type {number}\n     */\n\n  }, {\n    key: "internalWeight",\n    get: function get() {\n      return this._internalWeight;\n    }\n    /**\n     * Multiplies the user weight by a factor to determine the internal weight.\n     *\n     * @param {number} factor - 0-1 multiplier to apply to the user weight.\n     */\n\n  }, {\n    key: "updateInternalWeight",\n    value: function updateInternalWeight(factor) {\n      this._internalWeight = this._weight * factor;\n    }\n    /**\n     * Update any values that need to be evaluated every frame.\n     *\n     * @param {number} deltaTime - Time in milliseconds since the last update.\n     */\n\n  }, {\n    key: "update",\n    value: function update(deltaTime) {\n      if (!this._paused) {\n        Object.values(this._promises).forEach(function (promise) {\n          promise.execute(deltaTime);\n        });\n      }\n    }\n    /**\n     * Start playback of the state from the beginning.\n     *\n     * @param {Function=} onFinish - Function to execute when the state finishes.\n     * @param {Function=} onError - Function to execute if the state encounters\n     * an error during playback.\n     * @param {Function=} onCancel - Function to execute if playback is canceled.\n     *\n     * @returns {Deferred}\n     */\n\n  }, {\n    key: "play",\n    value: function play(onFinish, onError, onCancel) {\n      this._paused = false;\n      this._playCallbacks.onFinish = onFinish;\n      this._playCallbacks.onError = onError;\n      this._playCallbacks.onCancel = onCancel;\n      this._promises.play = new core_Deferred(undefined, onFinish, onError, onCancel);\n      this._promises.finish = core_Deferred.all([this._promises.play, this._promises.weight]);\n      return this._promises.finish;\n    }\n    /**\n     * Pause playback of the state. This prevents pending promises from being executed.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "pause",\n    value: function pause() {\n      this._paused = true;\n      return true;\n    }\n    /**\n     * Resume playback of the state.\n     *\n     * @param {Function=} onFinish - Function to execute when the state finishes.\n     * @param {Function=} onError - Function to execute if the state encounters\n     * an error during playback.\n     * @param {Function=} onCancel - Function to execute if playback is canceled.\n     *\n     * @returns {Deferred}\n     */\n\n  }, {\n    key: "resume",\n    value: function resume(onFinish, onError, onCancel) {\n      this._paused = false;\n\n      if (!this._promises.play.pending) {\n        this._playCallbacks.onFinish = onFinish || this._playCallbacks.onFinish;\n        this._playCallbacks.onError = onError || this._playCallbacks.onError;\n        this._playCallbacks.onCancel = onCancel || this._playCallbacks.onCancel;\n        this._promises.play = new core_Deferred(undefined, this._playCallbacks.onFinish, this._playCallbacks.onError, this._playCallbacks.onCancel);\n        this._promises.finish = core_Deferred.all([this._promises.play, this._promises.weight]);\n      }\n\n      return this._promises.finish;\n    }\n    /**\n     * Cancel playback of the state and cancel any pending promises.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "cancel",\n    value: function cancel() {\n      this._paused = true;\n      Object.values(this._promises).forEach(function (promise) {\n        promise.cancel();\n      });\n      return true;\n    }\n    /**\n     * Stop playback of the state and resolve any pending promises.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "stop",\n    value: function stop() {\n      this._paused = true;\n      Object.values(this._promises).forEach(function (promise) {\n        promise.resolve();\n      });\n      return true;\n    }\n    /**\n     * Cancel any pending promises and remove reference to them.\n     */\n\n  }, {\n    key: "discard",\n    value: function discard() {\n      this.cancel();\n      delete this._promises;\n    }\n    /**\n     * Force the internal weight to 0. Should be called before switching or transitioning\n     * to a new state.\n     */\n\n  }, {\n    key: "deactivate",\n    value: function deactivate() {\n      this.updateInternalWeight(0);\n    }\n  }]);\n\n  return AbstractState;\n}();\n\n/* harmony default export */ const state_AbstractState = (AbstractState);\n;// CONCATENATED MODULE: ./src/core/animpack/state/TransitionState.js\nfunction TransitionState_typeof(obj) { "@babel/helpers - typeof"; return TransitionState_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, TransitionState_typeof(obj); }\n\nfunction TransitionState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction TransitionState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction TransitionState_createClass(Constructor, protoProps, staticProps) { if (protoProps) TransitionState_defineProperties(Constructor.prototype, protoProps); if (staticProps) TransitionState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction TransitionState_get() { if (typeof Reflect !== "undefined" && Reflect.get) { TransitionState_get = Reflect.get; } else { TransitionState_get = function _get(target, property, receiver) { var base = TransitionState_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return TransitionState_get.apply(this, arguments); }\n\nfunction TransitionState_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = TransitionState_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction TransitionState_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) TransitionState_setPrototypeOf(subClass, superClass); }\n\nfunction TransitionState_setPrototypeOf(o, p) { TransitionState_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return TransitionState_setPrototypeOf(o, p); }\n\nfunction TransitionState_createSuper(Derived) { var hasNativeReflectConstruct = TransitionState_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = TransitionState_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = TransitionState_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return TransitionState_possibleConstructorReturn(this, result); }; }\n\nfunction TransitionState_possibleConstructorReturn(self, call) { if (call && (TransitionState_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return TransitionState_assertThisInitialized(self); }\n\nfunction TransitionState_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction TransitionState_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction TransitionState_getPrototypeOf(o) { TransitionState_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return TransitionState_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n/**\n * Class for smooth transitioning between states on an animation layer.\n *\n * @extends AbstractState\n */\n\nvar TransitionState = /*#__PURE__*/function (_AbstractState) {\n  TransitionState_inherits(TransitionState, _AbstractState);\n\n  var _super = TransitionState_createSuper(TransitionState);\n\n  function TransitionState() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    TransitionState_classCallCheck(this, TransitionState);\n\n    _this = _super.call(this, options);\n    _this._to = null;\n    _this._from = [];\n    _this._weightPromise = core_Deferred.resolve();\n    return _this;\n  }\n\n  TransitionState_createClass(TransitionState, [{\n    key: "internalWeight",\n    get: function get() {\n      // Find the combined weight of all sub-states\n      var totalWeight = 0;\n\n      if (this._to) {\n        totalWeight += this._to.weight;\n      }\n\n      this._from.forEach(function (state) {\n        totalWeight += state.weight;\n      });\n\n      return totalWeight * this._internalWeight;\n    }\n  }, {\n    key: "updateInternalWeight",\n    value: function updateInternalWeight(factor) {\n      var _this2 = this;\n\n      TransitionState_get(TransitionState_getPrototypeOf(TransitionState.prototype), "updateInternalWeight", this).call(this, factor);\n\n      this._from.forEach(function (state) {\n        state.updateInternalWeight(_this2._internalWeight);\n      });\n\n      if (this._to) {\n        this._to.updateInternalWeight(this._internalWeight);\n      }\n    }\n    /**\n     * Update sub-states the transition is controlling and start new weight\n     * animations on each one. This should be called each time the current state of\n     * an animation layer gets updated to a new value and a transition time greater\n     * that zero is specified.\n     *\n     * @param {Array.<AbstractState>} [currentStates=[]] - States whose weight values\n     * will be animated to 0.\n     * @param {AbstractState=} targetState - State whose weight will be animated\n     * to 1.\n     * @param {number} transitionTime - Amount of time it will in seconds take for\n     * weight animations to complete.\n     * @param {Function=} easingFn - Easing function to use for weight animations.\n     * Default is Easing.Linear.InOut.\n     * @param {Function=} onComplete - Function to execute once all weight animations\n     * complete.\n     */\n\n  }, {\n    key: "configure",\n    value: function configure() {\n      var currentStates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var targetState = arguments.length > 1 ? arguments[1] : undefined;\n      var transitionTime = arguments.length > 2 ? arguments[2] : undefined;\n      var easingFn = arguments.length > 3 ? arguments[3] : undefined;\n      var onComplete = arguments.length > 4 ? arguments[4] : undefined;\n\n      // Deactivate any states that aren\'t in the new configuration\n      if (this._to === targetState || currentStates.includes(this._to)) {\n        this._to = null;\n      }\n\n      this._from = this._from.filter(function (state) {\n        return state !== targetState && !currentStates.includes(state);\n      });\n      this.deactivate();\n      this._from = currentStates;\n      this._to = targetState;\n      this.reset(transitionTime, easingFn, onComplete);\n    }\n    /**\n     * Start new weight animations state the transition controls. This should be called\n     * if an animation is played with a transition time greater than zero and a transtion\n     * to that animation was already in progress.\n     *\n     * @param {number} transitionTime - Amount of time it will in seconds take for\n     * weight animations to complete.\n     * @param {Function=} easingFn - Easing function to use for weight animations.\n     * Default is Easing.Linear.InOut.\n     * @param {Function=} onComplete - Function to execute once all weight animations\n     * complete.\n     */\n\n  }, {\n    key: "reset",\n    value: function reset(transitionTime, easingFn, onComplete) {\n      var _this3 = this;\n\n      // Stop any pending promises\n      this._weightPromise.cancel(); // Start tweening weight to 0 for the current states\n\n\n      var weightPromises = this._from.map(function (state) {\n        return state.setWeight(0, transitionTime, easingFn);\n      }); // Start tweening weight to 1 for the target state\n\n\n      if (this._to) {\n        weightPromises.push(this._to.setWeight(1, transitionTime, easingFn));\n        this.name = this._to.name;\n      } else {\n        this.name = null;\n      }\n\n      this._weightPromise = core_Deferred.all(weightPromises, function () {\n        _this3._from.forEach(function (state) {\n          state.cancel();\n          state.deactivate();\n        });\n\n        if (typeof onComplete === \'function\') {\n          onComplete();\n        }\n      });\n    }\n  }, {\n    key: "play",\n    value: function play(onFinish, onError, onCancel, onNext) {\n      this._paused = false;\n      this._playCallbacks.onFinish = onFinish;\n      this._playCallbacks.onError = onError;\n      this._playCallbacks.onCancel = onCancel;\n      var promises = [this._weightPromise];\n\n      this._from.forEach(function (state) {\n        state.resume();\n      });\n\n      if (this._to) {\n        this._promises.play = this._to.play(undefined, undefined, undefined, onNext);\n        promises.push(this._promises.play);\n      }\n\n      this._promises.finish = core_Deferred.all(promises, onFinish, onError, onCancel);\n      return this._promises.finish;\n    }\n  }, {\n    key: "pause",\n    value: function pause() {\n      this._from.forEach(function (state) {\n        state.pause();\n      });\n\n      if (this._to) {\n        this._to.pause();\n      }\n\n      return TransitionState_get(TransitionState_getPrototypeOf(TransitionState.prototype), "pause", this).call(this);\n    }\n  }, {\n    key: "resume",\n    value: function resume(onFinish, onError, onCancel, onNext) {\n      this._paused = false;\n\n      if (!this._promises.play.pending) {\n        this._playCallbacks.onFinish = onFinish || this._playCallbacks.onFinish;\n        this._playCallbacks.onError = onError || this._playCallbacks.onError;\n        this._playCallbacks.onCancel = onCancel || this._playCallbacks.onCancel;\n      }\n\n      var promises = [this._weightPromise];\n\n      this._from.forEach(function (state) {\n        state.resume();\n      });\n\n      if (this._to) {\n        this._promises.play = this._to.resume(undefined, undefined, undefined, onNext);\n        promises.push(this._promises.play);\n      }\n\n      this._promises.finish = core_Deferred.all(promises, this._playCallbacks.onFinish, this._playCallbacks.onError, this._playCallbacks.onCancel);\n      return this._promises.finish;\n    }\n  }, {\n    key: "cancel",\n    value: function cancel() {\n      this._from.forEach(function (state) {\n        state.pause();\n      });\n\n      if (this._to) {\n        this._to.cancel();\n      }\n\n      this._weightPromise.cancel();\n\n      return TransitionState_get(TransitionState_getPrototypeOf(TransitionState.prototype), "cancel", this).call(this);\n    }\n  }, {\n    key: "stop",\n    value: function stop() {\n      this._from.forEach(function (state) {\n        state.pause();\n      });\n\n      if (this._to) {\n        this._to.stop();\n      }\n\n      return TransitionState_get(TransitionState_getPrototypeOf(TransitionState.prototype), "stop", this).call(this);\n    }\n  }, {\n    key: "update",\n    value: function update(deltaTime) {\n      TransitionState_get(TransitionState_getPrototypeOf(TransitionState.prototype), "update", this).call(this, deltaTime);\n\n      this._from.forEach(function (state) {\n        state.update(deltaTime);\n      });\n\n      if (this._to) {\n        this._to.update(deltaTime);\n      }\n    }\n  }, {\n    key: "discard",\n    value: function discard() {\n      TransitionState_get(TransitionState_getPrototypeOf(TransitionState.prototype), "discard", this).call(this);\n\n      this._weightPromise.cancel();\n\n      delete this._weightPromise;\n      this._to = null;\n      this._from.length = 0;\n    }\n  }, {\n    key: "deactivate",\n    value: function deactivate() {\n      if (this._to) {\n        this._to.deactivate();\n      }\n\n      this._from.forEach(function (state) {\n        state.deactivate();\n      });\n    }\n  }]);\n\n  return TransitionState;\n}(state_AbstractState);\n\n/* harmony default export */ const state_TransitionState = (TransitionState);\n;// CONCATENATED MODULE: ./src/core/animpack/AnimationPlayerInterface.js\nfunction AnimationPlayerInterface_typeof(obj) { "@babel/helpers - typeof"; return AnimationPlayerInterface_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, AnimationPlayerInterface_typeof(obj); }\n\nfunction AnimationPlayerInterface_toConsumableArray(arr) { return AnimationPlayerInterface_arrayWithoutHoles(arr) || AnimationPlayerInterface_iterableToArray(arr) || AnimationPlayerInterface_unsupportedIterableToArray(arr) || AnimationPlayerInterface_nonIterableSpread(); }\n\nfunction AnimationPlayerInterface_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction AnimationPlayerInterface_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return AnimationPlayerInterface_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return AnimationPlayerInterface_arrayLikeToArray(o, minLen); }\n\nfunction AnimationPlayerInterface_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction AnimationPlayerInterface_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return AnimationPlayerInterface_arrayLikeToArray(arr); }\n\nfunction AnimationPlayerInterface_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction AnimationPlayerInterface_get() { if (typeof Reflect !== "undefined" && Reflect.get) { AnimationPlayerInterface_get = Reflect.get; } else { AnimationPlayerInterface_get = function _get(target, property, receiver) { var base = AnimationPlayerInterface_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return AnimationPlayerInterface_get.apply(this, arguments); }\n\nfunction AnimationPlayerInterface_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = AnimationPlayerInterface_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction AnimationPlayerInterface_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) AnimationPlayerInterface_setPrototypeOf(subClass, superClass); }\n\nfunction AnimationPlayerInterface_setPrototypeOf(o, p) { AnimationPlayerInterface_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return AnimationPlayerInterface_setPrototypeOf(o, p); }\n\nfunction AnimationPlayerInterface_createSuper(Derived) { var hasNativeReflectConstruct = AnimationPlayerInterface_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = AnimationPlayerInterface_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = AnimationPlayerInterface_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return AnimationPlayerInterface_possibleConstructorReturn(this, result); }; }\n\nfunction AnimationPlayerInterface_possibleConstructorReturn(self, call) { if (call && (AnimationPlayerInterface_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return AnimationPlayerInterface_assertThisInitialized(self); }\n\nfunction AnimationPlayerInterface_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction AnimationPlayerInterface_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction AnimationPlayerInterface_getPrototypeOf(o) { AnimationPlayerInterface_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return AnimationPlayerInterface_getPrototypeOf(o); }\n\nfunction AnimationPlayerInterface_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AnimationPlayerInterface_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AnimationPlayerInterface_createClass(Constructor, protoProps, staticProps) { if (protoProps) AnimationPlayerInterface_defineProperties(Constructor.prototype, protoProps); if (staticProps) AnimationPlayerInterface_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable max-classes-per-file */\n\n/* eslint-disable no-unused-vars */\n\n/* eslint-disable no-empty-function */\n\n/* eslint-disable getter-return */\n\n/* eslint-disable no-useless-constructor */\n\n\n/**\n * Class factory interface for controlling playback of a collection of animations.\n * One animation can be played at any given time, crossfading between animations\n * will result in playing a {@link TransitionState}.\n *\n * @interface\n */\n\nvar AnimationPlayerInterface = /*#__PURE__*/function () {\n  function AnimationPlayerInterface() {\n    AnimationPlayerInterface_classCallCheck(this, AnimationPlayerInterface);\n  }\n\n  AnimationPlayerInterface_createClass(AnimationPlayerInterface, [{\n    key: "paused",\n    get:\n    /**\n     * Gets whether or not the player is updating states.\n     *\n     * @readonly\n     * @type {boolean}\n     */\n    function get() {\n      return this._paused;\n    }\n    /**\n     * Gets and sets the default number of seconds it takes to transition to a new\n     * animation.\n     *\n     * @type {number}\n     */\n\n  }, {\n    key: "transitionTime",\n    get: function get() {},\n    set: function set(seconds) {}\n    /**\n     * Gets and sets the default easing function to use when transitioning and\n     * setting weights.\n     *\n     * @type {Function}\n     */\n\n  }, {\n    key: "easingFn",\n    get: function get() {},\n    set: function set(fn) {}\n    /**\n     * Gets the state the layer is currently in control of.\n     *\n     * @readonly\n     * @type {AbstractState}\n     */\n\n  }, {\n    key: "currentState",\n    get: function get() {}\n    /**\n     * Gets the name of the state the layer is currently in control of.\n     *\n     * @readonly\n     * @type {string}\n     */\n\n  }, {\n    key: "currentAnimation",\n    get: function get() {}\n    /**\n     * Gets whether or not the layer is currently transitioning to a new animation.\n     *\n     * @readonly\n     * @type {boolean}\n     */\n\n  }, {\n    key: "isTransitioning",\n    get: function get() {}\n    /**\n     * Update the layer\'s current state to a new value. If transitionTime is defined\n     * and greater than zero, perform a smooth blend between any states that currently\n     * have non-zero weight values and the new state.\n     *\n     * @private\n     *\n     * @param {(string|null)} name - Name of the state to transition to.\n     * @param {string} playMethod - Name of the operation being prepared for, to be\n     * used in error messaging.\n     * @param {number=} transitionTime - Amount of time in seconds it will take to\n     * switch to the new state.\n     * @param {Function=} easingFn - Easing function to use when transitioning to a\n     * new state over time.\n     * @param {Function=} onError - Function to execute if an error is encountered.\n     */\n\n  }, {\n    key: "_prepareCurrentState",\n    value: function _prepareCurrentState(name, playMethod, transitionTime, easingFn, onError) {}\n    /**\n     * Start playback an animation from the beginning.\n     *\n     * @param {string} name - Name of the animation to play.\n     * @param {number=} transitionTime - Amount of time it will take before the\n     * new state has full influence for the layer.\n     * @param {Function=} easingFn - Easing function to use for blending if transitionTime\n     * is greater than zero.\n     * @param {Function=} onFinish - Function to execute when the animation finishes.\n     * @param {Function=} onError - Function to execute if the animation encounters\n     * an error during playback.\n     * @param {Function=} onCancel - Function to execute if playback is canceled.\n     * @param {Function=} onNext - Function to execute if an animation queue is\n     * played and it advances to the next animation.\n     *\n     * @returns {Deferred}\n     */\n\n  }, {\n    key: "playAnimation",\n    value: function playAnimation(name, transitionTime, easingFn, onFinish, onError, onCancel, onNext) {}\n    /**\n     * Cancel playback of the current animation.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "cancelAnimation",\n    value: function cancelAnimation() {}\n    /**\n     * Pause playback of the current animation.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "pauseAnimation",\n    value: function pauseAnimation() {}\n    /**\n     * Resume playback of an animation.\n     *\n     * @param {string=} name - Name of the animation to resume playback for. Default\n     * is the layer\'s current animation name.\n     * @param {number=} transitionTime - Amount of time it will take before the\n     * new state has full influence for the layer.\n     * @param {Function=} onFinish - Function to execute when the state finishes.\n     * @param {Function=} onError - Function to execute if the state encounters\n     * an error during playback.\n     * @param {Function=} onCancel - Function to execute if playback is canceled.\n     * @param {Function=} onNext - Function to execute if an animation queue is\n     * played and it advances to the next animation.\n     *\n     * @returns {Deferred}\n     */\n\n  }, {\n    key: "resumeAnimation",\n    value: function resumeAnimation(name, transitionTime, easingFn, onFinish, onError, onCancel, onNext) {}\n    /**\n     * Stop playback of the current animation.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "stopAnimation",\n    value: function stopAnimation() {}\n    /**\n     * Update the current animation.\n     *\n     * @param {number} deltaTime - Time in milliseconds since the last update.\n     */\n\n  }, {\n    key: "update",\n    value: function update(deltaTime) {}\n    /**\n     * Discard the transition state.\n     */\n\n  }, {\n    key: "discard",\n    value: function discard() {}\n    /**\n     * Creates a class that implements {@link AnimationPlayerInterface} and extends\n     * a specified base class.\n     *\n     * @param {Class} [BaseClass = class{}] - The class to extend.\n     *\n     * @return {Class} A class that extends `BaseClass` and implements {@link AnimationPlayerInterface}.\n     */\n\n  }], [{\n    key: "Mixin",\n    value: function Mixin() {\n      var BaseClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : /*#__PURE__*/function () {\n        function _class() {\n          AnimationPlayerInterface_classCallCheck(this, _class);\n        }\n\n        return AnimationPlayerInterface_createClass(_class);\n      }();\n\n      var AnimationPlayerMixin = /*#__PURE__*/function (_BaseClass) {\n        AnimationPlayerInterface_inherits(AnimationPlayerMixin, _BaseClass);\n\n        var _super = AnimationPlayerInterface_createSuper(AnimationPlayerMixin);\n\n        function AnimationPlayerMixin() {\n          var _this;\n\n          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n          AnimationPlayerInterface_classCallCheck(this, AnimationPlayerMixin);\n\n          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n          }\n\n          _this = _super.call.apply(_super, [this, options].concat(args));\n          _this._transitionState = new state_TransitionState();\n          _this._states = _this._states !== undefined ? _this._states : new Map();\n          _this._currentState = null;\n          _this._paused = false;\n          _this._transitionTime = Number(options.transitionTime) >= 0 ? Number(options.transitionTime) : 0;\n          _this._easingFn = typeof options.easingFn === \'function\' ? options.easingFn : undefined;\n          return _this;\n        }\n\n        AnimationPlayerInterface_createClass(AnimationPlayerMixin, [{\n          key: "paused",\n          get: function get() {\n            return this._paused;\n          }\n        }, {\n          key: "transitionTime",\n          get: function get() {\n            return this._transitionTime;\n          },\n          set: function set(seconds) {\n            seconds = Number(seconds);\n\n            if (!(seconds >= 0)) {\n              throw new Error("Cannot set transition time for ".concat(this.constructor.name, " to ").concat(seconds, ". Seconds must be a numeric value greather than or equal to zero."));\n            }\n\n            this._transitionTime = seconds;\n          }\n        }, {\n          key: "easingFn",\n          get: function get() {\n            return this._easingFn;\n          },\n          set: function set(fn) {\n            this._easingFn = fn;\n          }\n        }, {\n          key: "currentState",\n          get: function get() {\n            return this._currentState;\n          }\n        }, {\n          key: "currentAnimation",\n          get: function get() {\n            if (this._currentState) {\n              return this._currentState.name;\n            }\n\n            return null;\n          }\n        }, {\n          key: "isTransitioning",\n          get: function get() {\n            return this._currentState === this._transitionState;\n          }\n        }, {\n          key: "_prepareCurrentState",\n          value: function _prepareCurrentState(name, playMethod, transitionTime, easingFn, onError) {\n            var _this2 = this;\n\n            if (name !== null && !this._states.has(name)) {\n              var e = new Error("Cannot ".concat(playMethod, " animation ").concat(name, ". No animation exists with this name."));\n\n              if (typeof onError === \'function\') {\n                onError(e);\n              }\n\n              throw e;\n            }\n\n            var targetState = name !== null ? this._states.get(name) : null; // Make sure the new state isn\'t already playing\n\n            if (this.currentAnimation !== name) {\n              // Switch to the new state immediately\n              if (transitionTime <= 0) {\n                // Cancel the current state and set its weight to 0\n                if (this._currentState) {\n                  this._currentState.cancel();\n\n                  this._currentState.weight = 0;\n\n                  this._currentState.deactivate();\n                }\n\n                this._currentState = targetState;\n              } // Blend to the new state over time\n              else {\n                // Make sure to transition out of any states with non-zero weight\n                var currentStates = AnimationPlayerInterface_toConsumableArray(this._states.values()).filter(function (s) {\n                  return s !== targetState && (s.weight || s.weightPending);\n                }); // Update the transition state with new inputs\n\n\n                this._transitionState.configure(currentStates, targetState, transitionTime, easingFn, function () {\n                  _this2._currentState = targetState;\n                  _this2._transitionState.weight = 0;\n                });\n\n                this._currentState = this._transitionState;\n              }\n            } else if (playMethod === \'play\') {\n              this._currentState.cancel();\n\n              if (this._currentState === this._transitionState) {\n                this._transitionState.reset(transitionTime, easingFn, function () {\n                  _this2._currentState = targetState;\n                  _this2._transitionState.weight = 0;\n                });\n              }\n            } // Update weight for the new current state so it has full influence for the player\n\n\n            this._currentState.weight = 1;\n\n            this._currentState.updateInternalWeight(this._internalWeight);\n          }\n        }, {\n          key: "playAnimation",\n          value: function playAnimation(name, transitionTime, easingFn, onFinish, onError, onCancel, onNext) {\n            var error;\n            var reject = false;\n\n            try {\n              this._prepareCurrentState(name, \'play\', transitionTime !== undefined ? transitionTime : this._transitionTime, easingFn !== undefined ? easingFn : this._easingFn, onError);\n            } catch (e) {\n              error = e;\n              reject = true;\n            }\n\n            if (reject) {\n              return core_Deferred.reject(error);\n            }\n\n            return this._currentState.play(onFinish, onError, onCancel, onNext);\n          }\n        }, {\n          key: "pauseAnimation",\n          value: function pauseAnimation() {\n            if (this._currentState) {\n              return this._currentState.pause();\n            } else {\n              return false;\n            }\n          }\n        }, {\n          key: "resumeAnimation",\n          value: function resumeAnimation(name, transitionTime, easingFn, onFinish, onError, onCancel, onNext) {\n            if (name === undefined && this._currentState) {\n              name = this._currentState.name;\n            }\n\n            var error;\n            var reject = false;\n\n            try {\n              this._prepareCurrentState(name, \'resume\', transitionTime !== undefined ? transitionTime : this._transitionTime, easingFn !== undefined ? easingFn : this._easingFn, onError);\n            } catch (e) {\n              error = e;\n              reject = true;\n            }\n\n            if (reject) {\n              return core_Deferred.reject(error);\n            }\n\n            return this._currentState.resume(onFinish, onError, onCancel, onNext);\n          }\n        }, {\n          key: "cancelAnimation",\n          value: function cancelAnimation() {\n            if (this._currentState) {\n              return this._currentState.cancel();\n            } else {\n              return false;\n            }\n          }\n        }, {\n          key: "stopAnimation",\n          value: function stopAnimation() {\n            if (this._currentState) {\n              return this._currentState.stop();\n            } else {\n              return false;\n            }\n          }\n        }, {\n          key: "update",\n          value: function update(deltaTime) {\n            if (AnimationPlayerInterface_get(AnimationPlayerInterface_getPrototypeOf(AnimationPlayerMixin.prototype), "update", this)) {\n              AnimationPlayerInterface_get(AnimationPlayerInterface_getPrototypeOf(AnimationPlayerMixin.prototype), "update", this).call(this, deltaTime);\n            }\n\n            if (this._currentState) {\n              this._currentState.update(deltaTime);\n            }\n          }\n        }, {\n          key: "discard",\n          value: function discard() {\n            if (AnimationPlayerInterface_get(AnimationPlayerInterface_getPrototypeOf(AnimationPlayerMixin.prototype), "discard", this)) {\n              AnimationPlayerInterface_get(AnimationPlayerInterface_getPrototypeOf(AnimationPlayerMixin.prototype), "discard", this).call(this);\n            }\n\n            this._transitionState.discard();\n\n            delete this._transitionState;\n          }\n        }]);\n\n        return AnimationPlayerMixin;\n      }(BaseClass);\n\n      return AnimationPlayerMixin;\n    }\n  }]);\n\n  return AnimationPlayerInterface;\n}();\n\n/* harmony default export */ const animpack_AnimationPlayerInterface = (AnimationPlayerInterface);\n;// CONCATENATED MODULE: ./src/core/animpack/state/StateContainerInterface.js\nfunction StateContainerInterface_typeof(obj) { "@babel/helpers - typeof"; return StateContainerInterface_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, StateContainerInterface_typeof(obj); }\n\nfunction StateContainerInterface_toConsumableArray(arr) { return StateContainerInterface_arrayWithoutHoles(arr) || StateContainerInterface_iterableToArray(arr) || StateContainerInterface_unsupportedIterableToArray(arr) || StateContainerInterface_nonIterableSpread(); }\n\nfunction StateContainerInterface_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction StateContainerInterface_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return StateContainerInterface_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return StateContainerInterface_arrayLikeToArray(o, minLen); }\n\nfunction StateContainerInterface_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction StateContainerInterface_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return StateContainerInterface_arrayLikeToArray(arr); }\n\nfunction StateContainerInterface_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction StateContainerInterface_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) StateContainerInterface_setPrototypeOf(subClass, superClass); }\n\nfunction StateContainerInterface_setPrototypeOf(o, p) { StateContainerInterface_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return StateContainerInterface_setPrototypeOf(o, p); }\n\nfunction StateContainerInterface_createSuper(Derived) { var hasNativeReflectConstruct = StateContainerInterface_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = StateContainerInterface_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = StateContainerInterface_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return StateContainerInterface_possibleConstructorReturn(this, result); }; }\n\nfunction StateContainerInterface_possibleConstructorReturn(self, call) { if (call && (StateContainerInterface_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return StateContainerInterface_assertThisInitialized(self); }\n\nfunction StateContainerInterface_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction StateContainerInterface_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction StateContainerInterface_getPrototypeOf(o) { StateContainerInterface_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return StateContainerInterface_getPrototypeOf(o); }\n\nfunction StateContainerInterface_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction StateContainerInterface_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction StateContainerInterface_createClass(Constructor, protoProps, staticProps) { if (protoProps) StateContainerInterface_defineProperties(Constructor.prototype, protoProps); if (staticProps) StateContainerInterface_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable max-classes-per-file */\n\n/* eslint-disable no-unused-vars */\n\n/* eslint-disable no-empty-function */\n\n/* eslint-disable getter-return */\n\n/**\n * Class factory interface for manipulating a collection of {@link AbstractState}.\n *\n * @interface\n */\n\nvar StateContainerInterface = /*#__PURE__*/function () {\n  function StateContainerInterface() {\n    StateContainerInterface_classCallCheck(this, StateContainerInterface);\n  }\n\n  StateContainerInterface_createClass(StateContainerInterface, [{\n    key: "getState",\n    value:\n    /**\n     * Return the state with the given name.\n     *\n     * @param {string} name - Name of the state.\n     *\n     * @returns {AbstractState}\n     */\n    function getState(name) {}\n    /**\n     * Gets an array of the names of all states in the container.\n     *\n     * @type {Array.<string>}\n     */\n\n  }, {\n    key: "getStateNames",\n    value: function getStateNames() {}\n    /**\n     * Add a new state to be controlled by the container. States are stored keyed\n     * by their name property, which must be unique. If it isn\'t, a number will\n     * be added or incremented until a unique key is generated.\n     *\n     * @param {AbstractState} state - State to add to the container.\n     *\n     * @returns {string} - Unique name of the state.\n     */\n\n  }, {\n    key: "addState",\n    value: function addState(state) {}\n    /**\n     * Removes a state with the given name from the container.\n     *\n     * @param {string} name - Name of the state to remove.\n     *\n     * @returns {boolean} - Whether or not a state was removed.\n     */\n\n  }, {\n    key: "removeState",\n    value: function removeState(name) {}\n    /**\n     * Renames a state with the given name in the container. Name must be unique\n     * to the container, if it isn\'t the name will be incremented until it is unique.\n     *\n     * @param {string} currentName - Name of the state to rename.\n     * @param {string} newName - Name to update the state with.\n     *\n     * @returns {string} - Updated name for the state.\n     */\n\n  }, {\n    key: "renameState",\n    value: function renameState(currentName, newName) {}\n    /**\n     * Discards all states.\n     */\n\n  }, {\n    key: "discardStates",\n    value: function discardStates() {}\n    /**\n     * Creates a class that implements {@link StateContainerInterface} and extends\n     * a specified base class.\n     *\n     * @param {Class} [BaseClass = class{}] - The class to extend.\n     *\n     * @return {Class} A class that extends `BaseClass` and implements {@link StateContainerInterface}.\n     */\n\n  }], [{\n    key: "Mixin",\n    value: function Mixin() {\n      var BaseClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : /*#__PURE__*/function () {\n        function _class() {\n          StateContainerInterface_classCallCheck(this, _class);\n        }\n\n        return StateContainerInterface_createClass(_class);\n      }();\n\n      /**\n       * This mixin adds functionality for manipulating uniquely-named animation states in\n       * a map.\n       */\n      var StateContainerMixin = /*#__PURE__*/function (_BaseClass) {\n        StateContainerInterface_inherits(StateContainerMixin, _BaseClass);\n\n        var _super = StateContainerInterface_createSuper(StateContainerMixin);\n\n        function StateContainerMixin() {\n          var _this;\n\n          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n          StateContainerInterface_classCallCheck(this, StateContainerMixin);\n\n          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n          }\n\n          _this = _super.call.apply(_super, [this, options].concat(args));\n          _this._states = _this._states !== undefined ? _this._states : new Map();\n          return _this;\n        }\n\n        StateContainerInterface_createClass(StateContainerMixin, [{\n          key: "getState",\n          value: function getState(name) {\n            return this._states.get(name);\n          }\n        }, {\n          key: "getStateNames",\n          value: function getStateNames() {\n            return StateContainerInterface_toConsumableArray(this._states.keys());\n          }\n        }, {\n          key: "addState",\n          value: function addState(state) {\n            // Make sure the state is not already in this container\n            if (StateContainerInterface_toConsumableArray(this._states.values()).includes(state)) {\n              console.warn("Cannot add animation to state ".concat(this.name, ". Animation was already added."));\n              return state.name;\n            } // Make sure the state name is unique\n\n\n            var uniqueName = core_Utils.getUniqueName(state.name, StateContainerInterface_toConsumableArray(this._states.keys()));\n\n            if (state.name !== uniqueName) {\n              console.warn("Animation name ".concat(state.name, " is not unique for state ").concat(this.name, ". New animation will be added with name ").concat(uniqueName, "."));\n              state.name = uniqueName;\n            }\n\n            this._states.set(state.name, state);\n\n            return state.name;\n          }\n        }, {\n          key: "removeState",\n          value: function removeState(name) {\n            // Check if the state is in this container\n            if (!this._states || !this._states.has(name)) {\n              console.warn("Did not remove animation ".concat(name, " from state ").concat(this.name, ". No animation exists with this name."));\n              return false;\n            }\n\n            this._states.get(name).discard();\n\n            this._states["delete"](name);\n\n            return true;\n          }\n        }, {\n          key: "renameState",\n          value: function renameState(currentName, newName) {\n            // Make sure the state is in this container\n            if (!this._states || !this._states.has(currentName)) {\n              throw new Error("Cannot rename animation ".concat(currentName, " in ").concat(this.name, ". No animation exists with this name."));\n            }\n\n            var state = this._states.get(currentName); // Exit if the names are the same\n\n\n            if (currentName === newName) {\n              return currentName;\n            } // Make sure the name is unique\n\n\n            var uniqueName = core_Utils.getUniqueName(newName, StateContainerInterface_toConsumableArray(this._states.keys()).filter(function (s) {\n              return s.name !== currentName;\n            }));\n\n            if (newName !== uniqueName) {\n              console.warn("Animation name ".concat(newName, " is not unique in state ").concat(this.name, ". Animation will be renamed to ").concat(uniqueName, "."));\n              newName = uniqueName;\n            }\n\n            state.name = newName;\n\n            this._states["delete"](currentName);\n\n            this._states.set(state.name, state);\n\n            return state.name;\n          }\n        }, {\n          key: "discardStates",\n          value: function discardStates() {\n            this._states.forEach(function (state) {\n              state.discard();\n            });\n\n            delete this._states;\n          }\n        }]);\n\n        return StateContainerMixin;\n      }(BaseClass);\n\n      return StateContainerMixin;\n    }\n  }]);\n\n  return StateContainerInterface;\n}();\n\n/* harmony default export */ const state_StateContainerInterface = (StateContainerInterface);\n;// CONCATENATED MODULE: ./src/core/animpack/state/QueueState.js\nfunction QueueState_typeof(obj) { "@babel/helpers - typeof"; return QueueState_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, QueueState_typeof(obj); }\n\nfunction QueueState_toConsumableArray(arr) { return QueueState_arrayWithoutHoles(arr) || QueueState_iterableToArray(arr) || QueueState_unsupportedIterableToArray(arr) || QueueState_nonIterableSpread(); }\n\nfunction QueueState_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction QueueState_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return QueueState_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return QueueState_arrayLikeToArray(o, minLen); }\n\nfunction QueueState_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction QueueState_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return QueueState_arrayLikeToArray(arr); }\n\nfunction QueueState_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction QueueState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction QueueState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction QueueState_createClass(Constructor, protoProps, staticProps) { if (protoProps) QueueState_defineProperties(Constructor.prototype, protoProps); if (staticProps) QueueState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction QueueState_get() { if (typeof Reflect !== "undefined" && Reflect.get) { QueueState_get = Reflect.get; } else { QueueState_get = function _get(target, property, receiver) { var base = QueueState_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return QueueState_get.apply(this, arguments); }\n\nfunction QueueState_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = QueueState_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction QueueState_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) QueueState_setPrototypeOf(subClass, superClass); }\n\nfunction QueueState_setPrototypeOf(o, p) { QueueState_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return QueueState_setPrototypeOf(o, p); }\n\nfunction QueueState_createSuper(Derived) { var hasNativeReflectConstruct = QueueState_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = QueueState_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = QueueState_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return QueueState_possibleConstructorReturn(this, result); }; }\n\nfunction QueueState_possibleConstructorReturn(self, call) { if (call && (QueueState_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return QueueState_assertThisInitialized(self); }\n\nfunction QueueState_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction QueueState_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction QueueState_getPrototypeOf(o) { QueueState_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return QueueState_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n/**\n * Class for playing an ordered array of animation states in sequence.\n *\n * @extends AbstractState\n * @implements @AnimationPlayerInterface\n */\n\nvar QueueState = /*#__PURE__*/function (_AnimationPlayerInter) {\n  QueueState_inherits(QueueState, _AnimationPlayerInter);\n\n  var _super = QueueState_createSuper(QueueState);\n\n  /**\n   * @constructor\n   *\n   * @param {Object} [options={}] - Options for the state.\n   * @param {boolean} [options.autoAdvance=true] - Whether to autmatically advance\n   * to the next state in the queue as each state completes.\n   * @param {Array.<AbstractState>} [queueStates=[]] - Array of states to be played\n   * in order.\n   */\n  function QueueState() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var queueStates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    QueueState_classCallCheck(this, QueueState);\n\n    _this = _super.call(this, options);\n    queueStates.forEach(function (state) {\n      _this.addState(state);\n    });\n    _this._queue = _this._states.keys();\n    _this._done = true;\n    return _this;\n  }\n  /**\n   * Gets whether the animation queue has reached the end.\n   */\n\n\n  QueueState_createClass(QueueState, [{\n    key: "done",\n    get: function get() {\n      return this._done;\n    }\n    /**\n     * Gets the internal weight.\n     *\n     * @readonly\n     * @type {number}\n     */\n\n  }, {\n    key: "internalWeight",\n    get: function get() {\n      return this._currentState ? this._currentState.internalWeight * this._internalWeight : 0;\n    }\n    /**\n     * Restart the queue iterator.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_reset",\n    value: function _reset() {\n      this._queue = this._states.keys();\n\n      var _this$_queue$next = this._queue.next(),\n          value = _this$_queue$next.value,\n          done = _this$_queue$next.done;\n\n      this._done = done;\n      return value || null;\n    }\n    /**\n     * Multiplies the user weight by a factor to determine the internal weight.\n     *\n     * @param {number} factor - 0-1 multiplier to apply to the user weight.\n     */\n\n  }, {\n    key: "updateInternalWeight",\n    value: function updateInternalWeight(factor) {\n      QueueState_get(QueueState_getPrototypeOf(QueueState.prototype), "updateInternalWeight", this).call(this, factor);\n\n      if (this._currentState) {\n        this._currentState.updateInternalWeight(this._internalWeight);\n      }\n    }\n    /**\n     * Start the next animation in the queue.\n     *\n     * @param {Function=} onNext - Function to execute each time an animation completes\n     * and the queue moves to the next animation.\n     * @param {boolean} [wrap=false] - Whether or not to start the queue from the\n     * beginning again if the end has been reached.\n     *\n     * @returns {Deferred}\n     */\n\n  }, {\n    key: "next",\n    value: function next(onNext) {\n      var _this2 = this;\n\n      var wrap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      // Move the queue forward\n      var _this$_queue$next2 = this._queue.next(),\n          name = _this$_queue$next2.value,\n          done = _this$_queue$next2.done;\n\n      this._done = done;\n      this._paused = false; // The queue has reached the end\n\n      if (done) {\n        // Start the queue over\n        if (wrap) {\n          return this.play(this._playCallbacks.onFinish, this._playCallbacks.onError, this._playCallbacks.onCancel, onNext);\n        } // Stop the queue\n        else {\n          this._promises.finish.resolve();\n\n          return this._promises.finish;\n        }\n      } // Signal the next animation is starting\n\n\n      if (typeof onNext === \'function\') {\n        var lastName = QueueState_toConsumableArray(this._states.keys())[this._states.size - 1];\n\n        var isQueueEnd = name === lastName;\n        onNext({\n          name: name,\n          canAdvance: this.getState(name).loopCount !== Infinity && !isQueueEnd,\n          isQueueEnd: isQueueEnd\n        });\n      } // Start the next animation\n\n\n      this.playAnimation(name, this._transitionTime, this._easingFn, function () {\n        if (!_this2._paused && !_this2.isTransitioning) {\n          _this2.next(onNext);\n        }\n      }, this._playCallbacks.onError);\n      return this._promises.finish;\n    }\n  }, {\n    key: "play",\n    value: function play(onFinish, onError, onCancel, onNext) {\n      var _this3 = this;\n\n      var name = this._reset();\n\n      QueueState_get(QueueState_getPrototypeOf(QueueState.prototype), "play", this).call(this, onFinish, onError, onCancel);\n\n      if (this._done) {\n        this._promises.finish.resolve();\n      } else {\n        // Signal the next animation is starting\n        if (name !== this.currentAnimation && typeof onNext === \'function\') {\n          var lastName = QueueState_toConsumableArray(this._states.keys())[this._states.size - 1];\n\n          var isQueueEnd = name === lastName;\n          onNext({\n            name: name,\n            canAdvance: name ? this.getState(name).loopCount !== Infinity && !isQueueEnd : true,\n            isQueueEnd: !name || isQueueEnd\n          });\n        } // Start the next animation\n\n\n        this.playAnimation(name, this._currentState ? this._transitionTime : 0, this._easingFn, function () {\n          if (!_this3._paused && !_this3.isTransitioning) {\n            _this3.next(onNext);\n          }\n        }, onError);\n      }\n\n      return this._promises.finish;\n    }\n  }, {\n    key: "pause",\n    value: function pause() {\n      var paused = QueueState_get(QueueState_getPrototypeOf(QueueState.prototype), "pause", this).call(this);\n\n      this.pauseAnimation();\n      return paused;\n    }\n  }, {\n    key: "resume",\n    value: function resume(onFinish, onError, onCancel, onNext) {\n      var _this4 = this;\n\n      if (this._done) {\n        return this.play(onFinish, onError, onCancel, onNext);\n      } else {\n        QueueState_get(QueueState_getPrototypeOf(QueueState.prototype), "resume", this).call(this, onFinish, onError, onCancel);\n\n        this.resumeAnimation(this._currentState.name, this._transitionTime, this._easingFn, function () {\n          if (!_this4._paused && !_this4.isTransitioning) {\n            _this4.next(onNext);\n          }\n        }, onError);\n        return this._promises.finish;\n      }\n    }\n  }, {\n    key: "cancel",\n    value: function cancel() {\n      var canceled = QueueState_get(QueueState_getPrototypeOf(QueueState.prototype), "cancel", this).call(this);\n\n      if (this._currentState) {\n        this._currentState.cancel();\n      }\n\n      return canceled;\n    }\n  }, {\n    key: "stop",\n    value: function stop() {\n      var stopped = QueueState_get(QueueState_getPrototypeOf(QueueState.prototype), "stop", this).call(this);\n\n      this.stopAnimation();\n      this._done = true;\n      return stopped;\n    }\n  }, {\n    key: "discard",\n    value: function discard() {\n      QueueState_get(QueueState_getPrototypeOf(QueueState.prototype), "discard", this).call(this);\n\n      this.discardStates();\n    }\n  }]);\n\n  return QueueState;\n}(animpack_AnimationPlayerInterface.Mixin(state_StateContainerInterface.Mixin(state_AbstractState)));\n\n/* harmony default export */ const state_QueueState = (QueueState);\n;// CONCATENATED MODULE: ./src/core/animpack/state/AbstractBlendState.js\nfunction AbstractBlendState_typeof(obj) { "@babel/helpers - typeof"; return AbstractBlendState_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, AbstractBlendState_typeof(obj); }\n\nfunction AbstractBlendState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AbstractBlendState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AbstractBlendState_createClass(Constructor, protoProps, staticProps) { if (protoProps) AbstractBlendState_defineProperties(Constructor.prototype, protoProps); if (staticProps) AbstractBlendState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction AbstractBlendState_get() { if (typeof Reflect !== "undefined" && Reflect.get) { AbstractBlendState_get = Reflect.get; } else { AbstractBlendState_get = function _get(target, property, receiver) { var base = AbstractBlendState_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return AbstractBlendState_get.apply(this, arguments); }\n\nfunction AbstractBlendState_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = AbstractBlendState_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction AbstractBlendState_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) AbstractBlendState_setPrototypeOf(subClass, superClass); }\n\nfunction AbstractBlendState_setPrototypeOf(o, p) { AbstractBlendState_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return AbstractBlendState_setPrototypeOf(o, p); }\n\nfunction AbstractBlendState_createSuper(Derived) { var hasNativeReflectConstruct = AbstractBlendState_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = AbstractBlendState_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = AbstractBlendState_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return AbstractBlendState_possibleConstructorReturn(this, result); }; }\n\nfunction AbstractBlendState_possibleConstructorReturn(self, call) { if (call && (AbstractBlendState_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return AbstractBlendState_assertThisInitialized(self); }\n\nfunction AbstractBlendState_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction AbstractBlendState_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction AbstractBlendState_getPrototypeOf(o) { AbstractBlendState_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return AbstractBlendState_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n/**\n * Base class for a state that blends a collection of {@link AbstractState}.\n *\n * @abstract\n * @implements StateContainerInterface\n */\n\nvar AbstractBlendState = /*#__PURE__*/function (_StateContainerInterf) {\n  AbstractBlendState_inherits(AbstractBlendState, _StateContainerInterf);\n\n  var _super = AbstractBlendState_createSuper(AbstractBlendState);\n\n  function AbstractBlendState() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var blendStates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    AbstractBlendState_classCallCheck(this, AbstractBlendState);\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this, options].concat(args));\n    blendStates.forEach(function (state) {\n      _this.addState(state);\n    });\n    return _this;\n  }\n  /**\n   * Gets the sum of internal weights of the sub-states.\n   *\n   * @readonly\n   * @type {number}\n   */\n\n\n  AbstractBlendState_createClass(AbstractBlendState, [{\n    key: "internalWeight",\n    get: function get() {\n      var blendWeights = 0;\n\n      this._states.forEach(function (state) {\n        blendWeights += state.internalWeight;\n      });\n\n      return blendWeights;\n    }\n    /**\n     * Returns the weight of a state controlled by the container.\n     *\n     * @param {string} name - Name of the state to return the weight from.\n     *\n     * @returns {number} - Weight of the state.\n     */\n\n  }, {\n    key: "getBlendWeight",\n    value: function getBlendWeight(name) {\n      // Make sure the name is valid\n      var state = this.getState(name);\n\n      if (state === undefined) {\n        throw new Error("Cannot get weight of state ".concat(name, " from BlendState ").concat(this.name, ". No state exists with this name."));\n      }\n\n      return state.weight;\n    }\n    /**\n     * Sets the weight of a state controlled by the container.\n     *\n     * @param {string} name - Name of the state to set the weight of.\n     * @param {number} weight - Weight value to set on the state.\n     *\n     * @returns {Deferred}\n     */\n\n  }, {\n    key: "setBlendWeight",\n    value: function setBlendWeight(name, weight) {\n      var seconds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var easingFn = arguments.length > 3 ? arguments[3] : undefined;\n      // Make sure the name is valid\n      var state = this.getState(name);\n\n      if (state === undefined) {\n        throw new Error("Cannot set weight of state ".concat(name, " from BlendState ").concat(this.name, ". No state exists with this name."));\n      }\n\n      weight = core_MathUtils.clamp(weight);\n      return state.setWeight(weight, seconds, easingFn);\n    }\n    /**\n     * Multiplies the weight of each sub-state by a factor to determine the internal weight.\n     *\n     * @param {number} factor - 0-1 multiplier to apply to the user weight.\n     */\n\n  }, {\n    key: "updateInternalWeight",\n    value: function updateInternalWeight(factor) {\n      var _this2 = this;\n\n      AbstractBlendState_get(AbstractBlendState_getPrototypeOf(AbstractBlendState.prototype), "updateInternalWeight", this).call(this, factor);\n\n      this._states.forEach(function (state) {\n        state.updateInternalWeight(_this2._internalWeight);\n      });\n    }\n    /**\n     * Update any values of the sub-states that need to be evaluated every frame.\n     *\n     * @param {number} deltaTime - Time in milliseconds since the last update.\n     */\n\n  }, {\n    key: "update",\n    value: function update(deltaTime) {\n      AbstractBlendState_get(AbstractBlendState_getPrototypeOf(AbstractBlendState.prototype), "update", this).call(this, deltaTime);\n\n      this._states.forEach(function (state) {\n        state.update(deltaTime);\n      });\n    }\n    /**\n     * Start playback of the sub-states from the beginning.\n     *\n     * @param {Function=} onFinish - Function to execute when the state finishes.\n     * @param {Function=} onError - Function to execute if the state encounters\n     * an error during playback.\n     * @param {Function=} onCancel - Function to execute if playback is canceled.\n     *\n     * @returns {Deferred}\n     */\n\n  }, {\n    key: "play",\n    value: function play(onFinish, onError, onCancel) {\n      var promises = [AbstractBlendState_get(AbstractBlendState_getPrototypeOf(AbstractBlendState.prototype), "play", this).call(this)];\n\n      this._states.forEach(function (state) {\n        promises.push(state.play());\n      });\n\n      return core_Deferred.all(promises, onFinish, onError, onCancel);\n    }\n    /**\n     * Pause playback of the sub-states. This prevents pending promises from being executed.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "pause",\n    value: function pause() {\n      this._states.forEach(function (state) {\n        state.pause();\n      });\n\n      return AbstractBlendState_get(AbstractBlendState_getPrototypeOf(AbstractBlendState.prototype), "pause", this).call(this);\n    }\n    /**\n     * Resume playback of the sub-states.\n     *\n     * @param {Function=} onFinish - Function to execute when the state finishes.\n     * @param {Function=} onError - Function to execute if the state encounters\n     * an error during playback.\n     * @param {Function=} onCancel - Function to execute if playback is canceled.\n     *\n     * @returns {Deferred}\n     */\n\n  }, {\n    key: "resume",\n    value: function resume(onFinish, onError, onCancel) {\n      var promises = [AbstractBlendState_get(AbstractBlendState_getPrototypeOf(AbstractBlendState.prototype), "resume", this).call(this)];\n\n      this._states.forEach(function (state) {\n        promises.push(state.resume());\n      });\n\n      return core_Deferred.all(promises, onFinish, onError, onCancel);\n    }\n    /**\n     * Cancel playback of the sub-states and cancel any pending promises.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "cancel",\n    value: function cancel() {\n      this._states.forEach(function (state) {\n        state.cancel();\n      });\n\n      return AbstractBlendState_get(AbstractBlendState_getPrototypeOf(AbstractBlendState.prototype), "cancel", this).call(this);\n    }\n    /**\n     * Stop playback of the sub-states and resolve any pending promises.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "stop",\n    value: function stop() {\n      this._states.forEach(function (state) {\n        state.stop();\n      });\n\n      return AbstractBlendState_get(AbstractBlendState_getPrototypeOf(AbstractBlendState.prototype), "stop", this).call(this);\n    }\n    /**\n     * Discards all sub-state resources.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "discard",\n    value: function discard() {\n      AbstractBlendState_get(AbstractBlendState_getPrototypeOf(AbstractBlendState.prototype), "discard", this).call(this);\n\n      this.discardStates();\n    }\n  }]);\n\n  return AbstractBlendState;\n}(state_StateContainerInterface.Mixin(state_AbstractState));\n\n/* harmony default export */ const state_AbstractBlendState = (AbstractBlendState);\n;// CONCATENATED MODULE: ./src/core/animpack/state/FreeBlendState.js\nfunction FreeBlendState_typeof(obj) { "@babel/helpers - typeof"; return FreeBlendState_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, FreeBlendState_typeof(obj); }\n\nfunction FreeBlendState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction FreeBlendState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction FreeBlendState_createClass(Constructor, protoProps, staticProps) { if (protoProps) FreeBlendState_defineProperties(Constructor.prototype, protoProps); if (staticProps) FreeBlendState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction FreeBlendState_get() { if (typeof Reflect !== "undefined" && Reflect.get) { FreeBlendState_get = Reflect.get; } else { FreeBlendState_get = function _get(target, property, receiver) { var base = FreeBlendState_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return FreeBlendState_get.apply(this, arguments); }\n\nfunction FreeBlendState_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = FreeBlendState_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction FreeBlendState_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) FreeBlendState_setPrototypeOf(subClass, superClass); }\n\nfunction FreeBlendState_setPrototypeOf(o, p) { FreeBlendState_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return FreeBlendState_setPrototypeOf(o, p); }\n\nfunction FreeBlendState_createSuper(Derived) { var hasNativeReflectConstruct = FreeBlendState_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = FreeBlendState_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = FreeBlendState_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return FreeBlendState_possibleConstructorReturn(this, result); }; }\n\nfunction FreeBlendState_possibleConstructorReturn(self, call) { if (call && (FreeBlendState_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return FreeBlendState_assertThisInitialized(self); }\n\nfunction FreeBlendState_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction FreeBlendState_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction FreeBlendState_getPrototypeOf(o) { FreeBlendState_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return FreeBlendState_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\n * Class for blending N number of blend states.\n *\n * @extends AbstractBlendState\n */\n\nvar FreeBlendState = /*#__PURE__*/function (_AbstractBlendState) {\n  FreeBlendState_inherits(FreeBlendState, _AbstractBlendState);\n\n  var _super = FreeBlendState_createSuper(FreeBlendState);\n\n  /**\n   * @constructor\n   *\n   * @param {Object} [options={}] - Options for the container state.\n   * @param {Array.<AbstractState>} [blendStates=[]] - Blend states to be controlled by\n   * this container.\n   */\n  function FreeBlendState() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var blendStates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    FreeBlendState_classCallCheck(this, FreeBlendState);\n\n    return _super.call(this, options, blendStates);\n  }\n\n  FreeBlendState_createClass(FreeBlendState, [{\n    key: "updateInternalWeight",\n    value: function updateInternalWeight(factor) {\n      var _this = this;\n\n      FreeBlendState_get(FreeBlendState_getPrototypeOf(FreeBlendState.prototype), "updateInternalWeight", this).call(this, factor); // Determine the total active weight of blend states\n\n\n      var sumWeights = 0;\n\n      this._states.forEach(function (state) {\n        sumWeights += state.weight;\n      }); // Ensure the sum of blend state internal weights does not exceed container internal weight\n\n\n      factor /= Math.max(sumWeights, 1); // Sum of blend state internal weights should not exceed container internal weight\n\n      this._states.forEach(function (state) {\n        state.updateInternalWeight(factor * _this._weight);\n      });\n    }\n  }]);\n\n  return FreeBlendState;\n}(state_AbstractBlendState);\n\n/* harmony default export */ const state_FreeBlendState = (FreeBlendState);\n;// CONCATENATED MODULE: ./src/core/animpack/state/Blend1dState.js\nfunction Blend1dState_typeof(obj) { "@babel/helpers - typeof"; return Blend1dState_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, Blend1dState_typeof(obj); }\n\nfunction Blend1dState_toConsumableArray(arr) { return Blend1dState_arrayWithoutHoles(arr) || Blend1dState_iterableToArray(arr) || Blend1dState_unsupportedIterableToArray(arr) || Blend1dState_nonIterableSpread(); }\n\nfunction Blend1dState_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Blend1dState_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Blend1dState_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Blend1dState_arrayLikeToArray(o, minLen); }\n\nfunction Blend1dState_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction Blend1dState_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return Blend1dState_arrayLikeToArray(arr); }\n\nfunction Blend1dState_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Blend1dState_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction Blend1dState_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? Blend1dState_ownKeys(Object(source), !0).forEach(function (key) { Blend1dState_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : Blend1dState_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction Blend1dState_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Blend1dState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Blend1dState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Blend1dState_createClass(Constructor, protoProps, staticProps) { if (protoProps) Blend1dState_defineProperties(Constructor.prototype, protoProps); if (staticProps) Blend1dState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction Blend1dState_get() { if (typeof Reflect !== "undefined" && Reflect.get) { Blend1dState_get = Reflect.get; } else { Blend1dState_get = function _get(target, property, receiver) { var base = Blend1dState_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return Blend1dState_get.apply(this, arguments); }\n\nfunction Blend1dState_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Blend1dState_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Blend1dState_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) Blend1dState_setPrototypeOf(subClass, superClass); }\n\nfunction Blend1dState_setPrototypeOf(o, p) { Blend1dState_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Blend1dState_setPrototypeOf(o, p); }\n\nfunction Blend1dState_createSuper(Derived) { var hasNativeReflectConstruct = Blend1dState_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Blend1dState_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Blend1dState_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Blend1dState_possibleConstructorReturn(this, result); }; }\n\nfunction Blend1dState_possibleConstructorReturn(self, call) { if (call && (Blend1dState_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return Blend1dState_assertThisInitialized(self); }\n\nfunction Blend1dState_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Blend1dState_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction Blend1dState_getPrototypeOf(o) { Blend1dState_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Blend1dState_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n/**\n * Class for blending N number of blend states based on a single\n * parameter.\n *\n * @extends AbstractBlendState\n */\n\nvar Blend1dState = /*#__PURE__*/function (_AbstractBlendState) {\n  Blend1dState_inherits(Blend1dState, _AbstractBlendState);\n\n  var _super = Blend1dState_createSuper(Blend1dState);\n\n  /**\n   * @constructor\n   *\n   * @param {Object} [options] - Options for the container state\n   * @param {Array.<AbstractBlendState>} [blendStates=[]] - Blend states to be\n   * controlled by this container.\n   * @param {Array.<number>} [blendThresholds=[]] - Threshold values for activating\n   * each blend state.\n   * @param {Array.<boolean>} [phaseMatches=[]] - Booleans indicating whether or not\n   * each blend state should be phase matched.\n   */\n  function Blend1dState() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var blendStates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var blendThresholds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var phaseMatches = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n    Blend1dState_classCallCheck(this, Blend1dState);\n\n    _this = _super.call(this, options, blendStates);\n    _this._blendValue = 0;\n    _this._promises = Blend1dState_objectSpread(Blend1dState_objectSpread({}, _this._promises), {}, {\n      blendValue: core_Deferred.resolve()\n    }); // Validate there are no duplicate thresholds\n\n    var nonZeroDifferentSize = blendStates.length !== 0 && blendStates.length !== blendThresholds.length;\n\n    if (nonZeroDifferentSize) {\n      throw new Error("Cannot create Blend1dState with blendThresholds ".concat(blendThresholds, ". BlendThresholds count does not match blendStates count."));\n    }\n\n    var containsDuplicates = new Set(blendThresholds).size !== blendThresholds.length;\n\n    if (containsDuplicates) {\n      throw new Error("Cannot create Blend1dState with blendThresholds ".concat(blendThresholds, ". BlendThresholds contains duplicate values"));\n    } // Initialize the thresholds map\n\n\n    _this._thresholds = [];\n\n    Blend1dState_toConsumableArray(_this._states.values()).forEach(function (state, index) {\n      _this._thresholds.push({\n        value: blendThresholds[index],\n        name: state.name,\n        phaseMatch: phaseMatches[index] || false\n      });\n    });\n\n    _this._sortThresholds();\n\n    _this._forceNoThresholdDupes = true;\n    _this._phaseLeadState = null;\n\n    _this._updateBlendWeights();\n\n    return _this;\n  }\n  /**\n   * Gets and sets the blend parameter value.\n   */\n\n\n  Blend1dState_createClass(Blend1dState, [{\n    key: "blendValue",\n    get: function get() {\n      return this._blendValue;\n    },\n    set: function set(value) {\n      this._blendValue = value;\n    }\n    /**\n     * Gets whether or not the blend value is currently being animated.\n     */\n\n  }, {\n    key: "blendValuePending",\n    get: function get() {\n      return this._promises.blendValue && this._promises.blendValue.pending;\n    }\n    /**\n     * Updates the user defined weight over time.\n     *\n     * @param {null} name - Unused parameter.\n     * @param {number} weight - The target weight value.\n     * @param {number} [seconds=0] - The amount of time it will take to reach the\n     * target weight.\n     * @param {Function=} easingFn - The easing function to use for interpolation.\n     *\n     * @returns {Deferred}\n     */\n\n  }, {\n    key: "setBlendWeight",\n    value: function setBlendWeight(name, value) {\n      var _this2 = this;\n\n      var seconds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var easingFn = arguments.length > 3 ? arguments[3] : undefined;\n\n      this._promises.blendValue.cancel();\n\n      this._promises.blendValue = animpack_AnimationUtils.interpolateProperty(this, \'blendValue\', value, {\n        seconds: seconds,\n        easingFn: easingFn,\n        onProgress: function onProgress() {\n          _this2._updateBlendWeights();\n        },\n        onFinish: function onFinish() {\n          _this2._updateBlendWeights();\n        }\n      });\n      return this._promises.blendValue;\n    }\n    /**\n     * Gets the user defined weight.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: "getBlendWeight",\n    value: function getBlendWeight() {\n      return this.blendValue;\n    }\n  }, {\n    key: "addState",\n    value: function addState(state) {\n      var thresholdValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var phaseMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      this._thresholds = this._thresholds || []; // Make sure there is not already a state with this threshold\n\n      var sameValue = this._thresholds.find(function (threshold) {\n        return threshold.value === thresholdValue;\n      });\n\n      if (this._forceNoThresholdDupes && sameValue !== undefined) {\n        throw new Error("Cannot set blend threshold of ".concat(thresholdValue, " for state ").concat(state.name, " on ").concat(this.name, ". A state already exists with that threshold."));\n      }\n\n      Blend1dState_get(Blend1dState_getPrototypeOf(Blend1dState.prototype), "addState", this).call(this, state);\n\n      this._thresholds.push({\n        value: thresholdValue,\n        name: state.name,\n        phaseMatch: phaseMatch || false\n      });\n\n      this._sortThresholds();\n\n      return state.name;\n    }\n  }, {\n    key: "removeState",\n    value: function removeState(name) {\n      var removed = Blend1dState_get(Blend1dState_getPrototypeOf(Blend1dState.prototype), "removeState", this).call(this, name);\n\n      if (removed) {\n        var index = this._thresholds.findIndex(function (threshold) {\n          return threshold.name === name;\n        });\n\n        this._thresholds.splice(index, 1);\n      }\n\n      return removed;\n    }\n  }, {\n    key: "renameState",\n    value: function renameState(currentName, newName) {\n      newName = Blend1dState_get(Blend1dState_getPrototypeOf(Blend1dState.prototype), "renameState", this).call(this, currentName, newName);\n\n      var threshold = this._thresholds.find(function (threshold) {\n        return threshold.name === currentName;\n      });\n\n      threshold.name = newName;\n      return newName;\n    }\n    /**\n     * Gets the threshold value of a blend with the corresponding name.\n     *\n     * @param {string} name - Name of the blend to get the threshold of.\n     *\n     * @returns {number} Threhold value.\n     */\n\n  }, {\n    key: "getBlendThreshold",\n    value: function getBlendThreshold(name) {\n      var threshold = this._thresholds.find(function (threshold) {\n        return threshold.name === name;\n      });\n\n      if (threshold === undefined) {\n        throw new Error("Cannot get blend threshold of state ".concat(name, " on ").concat(this.name, ". No state exists with that name."));\n      }\n\n      return threshold.value;\n    }\n    /**\n     * Sets the threshold value of a blend with the corresponding name.\n     *\n     * @param {string} name - Name of the blend to set the threshold.\n     * @param {number} value - Value of the threshold to set.\n     *\n     * @returns {number} Set threshold value.\n     */\n\n  }, {\n    key: "setBlendThreshold",\n    value: function setBlendThreshold(name, value) {\n      // Make sure there is not already a state with this threshold\n      var sameValue = this._thresholds.find(function (threshold) {\n        return threshold.value === value;\n      });\n\n      if (sameValue !== undefined) {\n        throw new Error("Cannot set blend threshold of ".concat(value, " for state ").concat(name, " on ").concat(this.name, ". A state already exists with that threshold."));\n      }\n\n      var threshold = this._thresholds.find(function (threshold) {\n        return threshold.name === name;\n      });\n\n      if (threshold === undefined) {\n        throw new Error("Cannot set blend threshold of state ".concat(name, " on ").concat(this.name, ". No state exists with that name."));\n      }\n\n      threshold.value = value;\n\n      this._sortThresholds();\n\n      return threshold.value;\n    }\n  }, {\n    key: "updateInternalWeight",\n    value: function updateInternalWeight(factor) {\n      var _this3 = this;\n\n      Blend1dState_get(Blend1dState_getPrototypeOf(Blend1dState.prototype), "updateInternalWeight", this).call(this, factor);\n\n      if (this._phaseLeadState) {\n        this._states.forEach(function (state) {\n          if (state.weight !== 0) {\n            state.normalizedTime = _this3._phaseLeadState.normalizedTime;\n          }\n        });\n      }\n    }\n    /**\n     * Updates the blend weights based on their corresponding threshold values\n     * and the current blendValue. Additionally, sets a lead phase state if the\n     * conditions for phase-matching have been satisfied.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_updateBlendWeights",\n    value: function _updateBlendWeights() {\n      var _this4 = this;\n\n      if (this._thresholds.length === 0) return;\n\n      if (this._thresholds.length === 1) {\n        var state = this._states.get(this._thresholds[0].name);\n\n        state.setWeight(1);\n        return;\n      } // Initially set all sub-state weights to zero\n\n\n      this._states.forEach(function (state) {\n        state.setWeight(0);\n      });\n\n      this._phaseLeadState = null; // Find the first threshold that is greater than or equal to the parameter value\n\n      var targetIndex = this._thresholds.findIndex(function (threshold) {\n        return threshold.value >= _this4._blendValue;\n      });\n\n      if (targetIndex === 0 || targetIndex === -1) {\n        // Give one state full influence\n        targetIndex = targetIndex === -1 ? this._thresholds.length - 1 : 0;\n\n        var _state = this._states.get(this._thresholds[targetIndex].name);\n\n        _state.setWeight(1);\n      } else {\n        // Linear interpolate influence between two states\n        var thresholdA = this._thresholds[targetIndex - 1];\n        var thresholdB = this._thresholds[targetIndex];\n        var factorB = (this.blendValue - thresholdA.value) / (thresholdB.value - thresholdA.value);\n        var factorA = 1 - factorB;\n\n        var stateA = this._states.get(thresholdA.name);\n\n        var stateB = this._states.get(thresholdB.name);\n\n        stateA.setWeight(factorA);\n        stateB.setWeight(factorB); // Set phase-matching if needed\n\n        if (thresholdA.phaseMatch && thresholdB.phaseMatch) {\n          this._phaseLeadState = factorA > factorB ? stateA : stateB;\n        }\n      }\n    }\n    /**\n     * Sorts the thresholds from low to high based on value.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_sortThresholds",\n    value: function _sortThresholds() {\n      this._thresholds.sort(function (a, b) {\n        return a.value - b.value;\n      });\n    }\n  }]);\n\n  return Blend1dState;\n}(state_AbstractBlendState);\n\n/* harmony default export */ const state_Blend1dState = (Blend1dState);\n;// CONCATENATED MODULE: ./src/core/animpack/state/Blend2dState.js\nfunction Blend2dState_typeof(obj) { "@babel/helpers - typeof"; return Blend2dState_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, Blend2dState_typeof(obj); }\n\nfunction Blend2dState_toConsumableArray(arr) { return Blend2dState_arrayWithoutHoles(arr) || Blend2dState_iterableToArray(arr) || Blend2dState_unsupportedIterableToArray(arr) || Blend2dState_nonIterableSpread(); }\n\nfunction Blend2dState_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Blend2dState_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Blend2dState_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Blend2dState_arrayLikeToArray(o, minLen); }\n\nfunction Blend2dState_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction Blend2dState_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return Blend2dState_arrayLikeToArray(arr); }\n\nfunction Blend2dState_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Blend2dState_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction Blend2dState_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? Blend2dState_ownKeys(Object(source), !0).forEach(function (key) { Blend2dState_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : Blend2dState_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction Blend2dState_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Blend2dState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Blend2dState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Blend2dState_createClass(Constructor, protoProps, staticProps) { if (protoProps) Blend2dState_defineProperties(Constructor.prototype, protoProps); if (staticProps) Blend2dState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction Blend2dState_get() { if (typeof Reflect !== "undefined" && Reflect.get) { Blend2dState_get = Reflect.get; } else { Blend2dState_get = function _get(target, property, receiver) { var base = Blend2dState_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return Blend2dState_get.apply(this, arguments); }\n\nfunction Blend2dState_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Blend2dState_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Blend2dState_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) Blend2dState_setPrototypeOf(subClass, superClass); }\n\nfunction Blend2dState_setPrototypeOf(o, p) { Blend2dState_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Blend2dState_setPrototypeOf(o, p); }\n\nfunction Blend2dState_createSuper(Derived) { var hasNativeReflectConstruct = Blend2dState_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Blend2dState_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Blend2dState_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Blend2dState_possibleConstructorReturn(this, result); }; }\n\nfunction Blend2dState_possibleConstructorReturn(self, call) { if (call && (Blend2dState_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return Blend2dState_assertThisInitialized(self); }\n\nfunction Blend2dState_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Blend2dState_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction Blend2dState_getPrototypeOf(o) { Blend2dState_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Blend2dState_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable no-underscore-dangle */\n\n\n\n\n/**\n * Class for blending N number of blend states based on two\n * paramters.\n *\n * @extends AbstractBlendState\n */\n\nvar Blend2dState = /*#__PURE__*/function (_AbstractBlendState) {\n  Blend2dState_inherits(Blend2dState, _AbstractBlendState);\n\n  var _super = Blend2dState_createSuper(Blend2dState);\n\n  /**\n   * @constructor\n   *\n   * @param {Object} [options] - Options for the container state\n   * @param {Array.<AbstractBlendState>} [blendStates=[]] - Blend states to be\n   * controlled by this container.\n   * @param {Array.<Array.<number>>} [blendThresholds=[]] - Threshold values for activating\n   * each blend state.\n   * @param {Array.<boolean>} [phaseMatches=[]] - Booleans indicating whether or not\n   * each blend state should be phase matched.\n   */\n  function Blend2dState() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var blendStates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var blendThresholds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var phaseMatches = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n    Blend2dState_classCallCheck(this, Blend2dState);\n\n    _this = _super.call(this, options, blendStates);\n\n    if (blendStates.length !== blendThresholds.length) {\n      throw new Error("Cannot create Blend2dState with blendStates ".concat(blendStates, " and blendThresholds ").concat(blendThresholds, ". Count of blendStates must match count of blendThresholds."));\n    }\n\n    blendThresholds.slice(0, blendThresholds.length - 1).forEach(function (threshold, index) {\n      blendThresholds.slice(index + 1).forEach(function (otherThreshold) {\n        if (threshold[0] === otherThreshold[0] && threshold[1] === otherThreshold[1]) {\n          throw new Error("Cannot create Blend2dState with blendThresholds ".concat(blendThresholds, ". No duplicate values allowed in blendThresholds."));\n        }\n      });\n    });\n    _this._blendValueX = 0;\n    _this._blendValueY = 0;\n    _this._promises = Blend2dState_objectSpread(Blend2dState_objectSpread({}, _this._promises), {}, {\n      blendValueX: core_Deferred.resolve(),\n      blendValueY: core_Deferred.resolve()\n    });\n    _this._thresholds = [];\n\n    Blend2dState_toConsumableArray(_this._states.values()).forEach(function (state, index) {\n      _this._thresholds.push({\n        name: state.name,\n        phaseMatch: phaseMatches[index] || false\n      });\n    });\n\n    _this._vertices = blendThresholds;\n\n    if (_this._vertices.length >= 3) {\n      _this._triangles = core_MathUtils.getDelaunayTriangulation(_this._vertices);\n    }\n\n    _this._phaseLeadState = null;\n\n    _this._updateBlendWeights();\n\n    return _this;\n  }\n  /**\n   * Updates the user defined weight over time.\n   *\n   * @param {string} name - Name of blend weight to update.\n   * @param {number} weight - Target weight value.\n   * @param {number} [seconds=0] - The amount of time it will take to reach the\n   * target value.\n   * @param {Function=} easingFn - The easing function to use for interpolation.\n   *\n   * @returns {Deferred}\n   */\n\n\n  Blend2dState_createClass(Blend2dState, [{\n    key: "setBlendWeight",\n    value: function setBlendWeight(name, value) {\n      var _this2 = this;\n\n      var seconds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var easingFn = arguments.length > 3 ? arguments[3] : undefined;\n      var property = "blendValue".concat(name.toUpperCase());\n\n      if (property !== \'blendValueX\' && property !== \'blendValueY\') {\n        throw new Error("Cannot set blend weight for ".concat(name, " on ").concat(this.name, ". Blend2dState only accepts \'X\' or \'Y\' for setBlendWeight"));\n      }\n\n      this._promises[property].cancel();\n\n      this._promises[property] = animpack_AnimationUtils.interpolateProperty(this, property, value, {\n        seconds: seconds,\n        easingFn: easingFn,\n        onProgress: function onProgress() {\n          _this2._updateBlendWeights();\n        },\n        onFinish: function onFinish() {\n          _this2._updateBlendWeights();\n        }\n      });\n      return this._promises[property];\n    }\n    /**\n     * Gets the user defined weight.\n     *\n     * @param {string} name - Name of blend weight.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: "getBlendWeight",\n    value: function getBlendWeight(name) {\n      var property = name.toUpperCase();\n\n      if (property !== \'X\' && property !== \'Y\') {\n        throw new Error("Cannot get blend weight for ".concat(name, " on ").concat(this.name, ". Blend2dState only accepts \'X\' or \'Y\' for getBlendWeight"));\n      }\n\n      return property === \'X\' ? this._blendValueX : this._blendValueY;\n    }\n    /**\n     * Gets and sets the x blend weight.\n     */\n\n  }, {\n    key: "blendValueX",\n    get: function get() {\n      return this._blendValueX;\n    },\n    set: function set(value) {\n      this._blendValueX = value;\n    }\n    /**\n     * Gets and sets the y blend weight.\n     */\n\n  }, {\n    key: "blendValueY",\n    get: function get() {\n      return this._blendValueY;\n    },\n    set: function set(value) {\n      this._blendValueY = value;\n    }\n    /**\n     * Gets whether or not the x blend value is currently being animated.\n     */\n\n  }, {\n    key: "blendValueXPending",\n    get: function get() {\n      return this._promises.blendValueX && this._promises.blendValueX.pending;\n    }\n    /**\n     * Gets whether or not the y blend value is currently being animated.\n     */\n\n  }, {\n    key: "blendValueYPending",\n    get: function get() {\n      return this._promises.blendValueY && this._promises.blendValueY.pending;\n    }\n  }, {\n    key: "updateInternalWeight",\n    value: function updateInternalWeight(factor) {\n      var _this3 = this;\n\n      Blend2dState_get(Blend2dState_getPrototypeOf(Blend2dState.prototype), "updateInternalWeight", this).call(this, factor);\n\n      if (this._phaseLeadState) {\n        Blend2dState_toConsumableArray(this._states.values()).forEach(function (state, index) {\n          if (state.weight !== 0 && _this3._thresholds[index].phaseMatch) {\n            state.normalizedTime = _this3._phaseLeadState.normalizedTime;\n          }\n        });\n      }\n    }\n    /**\n     * Updates the blend weights based on their corresponding threshold values\n     * and the current [x,y] blendValue. Additionally, sets a lead phase state if the\n     * conditions for phase-matching have been satisfied.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_updateBlendWeights",\n    value: function _updateBlendWeights() {\n      var _this4 = this;\n\n      if (!this._vertices || this._vertices.length === 0) return;\n\n      if (this._vertices.length === 1) {\n        Blend2dState_toConsumableArray(this._states.values())[0].weight = 1;\n        return;\n      } // Initially set all sub-state weights to zero\n\n\n      this._states.forEach(function (state) {\n        state.setWeight(0);\n      });\n\n      this._phaseLeadState = null;\n      var p = [this._blendValueX, this._blendValueY];\n\n      if (this._vertices.length === 2) {\n        this._setInfluenceClosestPointOnLine(p);\n      } else {\n        var triangle = this._triangles.find(function (triangle) {\n          return core_MathUtils.isPointInTriangle(_this4._vertices[triangle[0]], _this4._vertices[triangle[1]], _this4._vertices[triangle[2]], p);\n        });\n\n        if (triangle) {\n          this._setInfluenceTriangle(triangle, p);\n        } else {\n          this._setInfluenceClosestPointInTriangles(p);\n        }\n      }\n    }\n    /**\n     * Sets blend weights for states corresponding to a\n     * triangle of thresholds and a given [x,y] blendValues.\n     *\n     * @param {Array.<Array.<number>>} triangle - Set of triangluated indices\n     * that correspond to blend thresholds.\n     * @param {Array.<number>} p - Given [x,y] blendValue.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_setInfluenceTriangle",\n    value: function _setInfluenceTriangle(triangle, p) {\n      var areaA = core_MathUtils.triangleArea(this._vertices[triangle[1]], this._vertices[triangle[2]], p);\n      var areaB = core_MathUtils.triangleArea(this._vertices[triangle[0]], this._vertices[triangle[2]], p);\n      var areaC = core_MathUtils.triangleArea(this._vertices[triangle[0]], this._vertices[triangle[1]], p);\n      var totalArea = areaA + areaB + areaC;\n      var weightA = areaA / totalArea;\n      var weightB = areaB / totalArea;\n      var weightC = areaC / totalArea;\n      var thresholdA = this._thresholds[triangle[0]];\n      var thresholdB = this._thresholds[triangle[1]];\n      var thresholdC = this._thresholds[triangle[2]];\n\n      var stateA = this._states.get(thresholdA.name);\n\n      var stateB = this._states.get(thresholdB.name);\n\n      var stateC = this._states.get(thresholdC.name);\n\n      stateA.setWeight(weightA);\n      stateB.setWeight(weightB);\n      stateC.setWeight(weightC);\n\n      this._setPhaseLeadState([stateA, stateB, stateC], [thresholdA.phaseMatch, thresholdB.phaseMatch, thresholdC.phaseMatch]);\n    }\n    /**\n     * Determines the closest point within a triangle of\n     * thresholds based on the current [x,y] blendValues and\n     * then sets blend weights for the corresponding states.\n     *\n     * @param {Array.<number>} p - Given [x,y] blendValue.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_setInfluenceClosestPointInTriangles",\n    value: function _setInfluenceClosestPointInTriangles(p) {\n      var _this5 = this;\n\n      var globalClosestPoint = null;\n      var globalMinDist = Number.POSITIVE_INFINITY;\n      var closestTriangle = -1;\n\n      this._triangles.forEach(function (triangle, index) {\n        var pointA = core_MathUtils.closestPointOnLine(_this5._vertices[triangle[0]], _this5._vertices[triangle[1]], p);\n        var pointB = core_MathUtils.closestPointOnLine(_this5._vertices[triangle[1]], _this5._vertices[triangle[2]], p);\n        var pointC = core_MathUtils.closestPointOnLine(_this5._vertices[triangle[2]], _this5._vertices[triangle[0]], p);\n        var distA = core_MathUtils.distanceSquared(pointA, p);\n        var distB = core_MathUtils.distanceSquared(pointB, p);\n        var distC = core_MathUtils.distanceSquared(pointC, p);\n        var localClosestPoint = pointC;\n        var localMinDist = distC;\n\n        if (distA < localMinDist) {\n          localClosestPoint = pointA;\n          localMinDist = distA;\n        }\n\n        if (distB < localMinDist) {\n          localClosestPoint = pointB;\n          localMinDist = distB;\n        }\n\n        if (localMinDist < globalMinDist) {\n          globalMinDist = localMinDist;\n          globalClosestPoint = Blend2dState_toConsumableArray(localClosestPoint);\n          closestTriangle = index;\n        }\n      });\n\n      this._setInfluenceTriangle(this._triangles[closestTriangle], globalClosestPoint);\n    }\n    /**\n     * Determines the closest point on the line formed between the\n     * two blend thresholds based on the current [x,y] blendValues and\n     * then sets blend weights for the corresponding states.\n     *\n     * @param {Array.<number>} p - Given [x,y] blendValue.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_setInfluenceClosestPointOnLine",\n    value: function _setInfluenceClosestPointOnLine(p) {\n      var closestPoint = core_MathUtils.closestPointOnLine(this._vertices[[0]], this._vertices[[1]], p);\n      var distA = core_MathUtils.distanceSquared(this._vertices[0], closestPoint);\n      var distB = core_MathUtils.distanceSquared(this._vertices[1], closestPoint);\n      var weightA = distB / (distA + distB);\n      var weightB = distA / (distA + distB);\n      var thresholdA = this._thresholds[0];\n      var thresholdB = this._thresholds[1];\n\n      var stateA = this._states.get(thresholdA.name);\n\n      var stateB = this._states.get(thresholdB.name);\n\n      stateA.setWeight(weightA);\n      stateB.setWeight(weightB);\n\n      this._setPhaseLeadState([stateA, stateB], [thresholdA.phaseMatch, thresholdB.phaseMatch]);\n    }\n    /**\n     * Sets a lead phase state if the conditions\n     * for phase-matching are satisfied.\n     *\n     * @param {Array.<AbstractBlendState>} states - States to\n     * check phase-matching criteria.\n     * @param {Array.<boolean>} phaseMatched - List of phase-match booleans.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_setPhaseLeadState",\n    value: function _setPhaseLeadState(states, phaseMatched) {\n      var _this6 = this;\n\n      var max = 0;\n      states.forEach(function (state, index) {\n        if (phaseMatched[index] && state.weight > max) {\n          _this6._phaseLeadState = state;\n          max = state.weight;\n        }\n      });\n    }\n  }]);\n\n  return Blend2dState;\n}(state_AbstractBlendState);\n\n/* harmony default export */ const state_Blend2dState = (Blend2dState);\n;// CONCATENATED MODULE: ./src/core/animpack/AnimationLayer.js\nfunction AnimationLayer_typeof(obj) { "@babel/helpers - typeof"; return AnimationLayer_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, AnimationLayer_typeof(obj); }\n\nfunction AnimationLayer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AnimationLayer_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AnimationLayer_createClass(Constructor, protoProps, staticProps) { if (protoProps) AnimationLayer_defineProperties(Constructor.prototype, protoProps); if (staticProps) AnimationLayer_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction AnimationLayer_get() { if (typeof Reflect !== "undefined" && Reflect.get) { AnimationLayer_get = Reflect.get; } else { AnimationLayer_get = function _get(target, property, receiver) { var base = AnimationLayer_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return AnimationLayer_get.apply(this, arguments); }\n\nfunction AnimationLayer_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = AnimationLayer_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction AnimationLayer_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) AnimationLayer_setPrototypeOf(subClass, superClass); }\n\nfunction AnimationLayer_setPrototypeOf(o, p) { AnimationLayer_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return AnimationLayer_setPrototypeOf(o, p); }\n\nfunction AnimationLayer_createSuper(Derived) { var hasNativeReflectConstruct = AnimationLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = AnimationLayer_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = AnimationLayer_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return AnimationLayer_possibleConstructorReturn(this, result); }; }\n\nfunction AnimationLayer_possibleConstructorReturn(self, call) { if (call && (AnimationLayer_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return AnimationLayer_assertThisInitialized(self); }\n\nfunction AnimationLayer_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction AnimationLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction AnimationLayer_getPrototypeOf(o) { AnimationLayer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return AnimationLayer_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n\n\n/**\n * Enum for types of {@link AnimationLayer} blending.\n *\n * @readonly\n * @enum {string}\n */\n\nvar LayerBlendModes = {\n  Override: \'Override\',\n  Additive: \'Additive\'\n};\n/**\n * The default blending mode {@link AnimationLayer}.\n *\n * @readonly\n * @type {string}\n */\n\nvar DefaultLayerBlendMode = \'Override\';\n/**\n * Checks if a given blendMode is present in the values of {@link LayerBlendModes}.\n * If it is, return the original value, otherwise return {@link DefaultLayerBlendMode}.\n *\n * @param {string} blendMode - The name of the type of blending.\n *\n * @returns {(string|DefaultLayerBlendMode)}\n */\n\nfunction validateBlendMode(blendMode) {\n  if (Array.from(Object.values(LayerBlendModes)).includes(blendMode)) {\n    return blendMode;\n  } else {\n    return DefaultLayerBlendMode;\n  }\n}\n/**\n * Class for managing a set of animations where only one state can be active at\n * any given time.\n *\n * @implements AnimationPlayerInterface\n * @implements StateContainerInterface\n */\n\nvar AnimationLayer = /*#__PURE__*/function (_AnimationPlayerInter) {\n  AnimationLayer_inherits(AnimationLayer, _AnimationPlayerInter);\n\n  var _super = AnimationLayer_createSuper(AnimationLayer);\n\n  /**\n   * @constructor\n   *\n   * @param {Object=} options -  Options for the animation layer.\n   * @param {string} options.name - Name of the layer. Names must be unique to the\n   * animation feature that contains the layer.\n   * @param {LayerBlendModes} [options.blendMode=DefaultLayerBlendMode] -\n   * Type of blending to use for all states controlled by the layer.\n   * @param {number} [options.weight=1] - The amount of influence the layer\'s current\n   * animation has over the result for the host.\n   * @param {number} [options.transitionTime=0] - The default amount of time to use when\n   * playing and resuming animations.\n   * @param {Function=} options.easingFn - The default easing function to use when\n   * transitioning between animations and setting layer weight.\n   */\n  function AnimationLayer() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    AnimationLayer_classCallCheck(this, AnimationLayer);\n\n    _this = _super.call(this, options);\n    _this.name = options.name === undefined ? \'AnimationLayer\' : options.name;\n    _this._blendMode = Array.from(Object.values(LayerBlendModes)).includes(options.blendMode) ? options.blendMode : DefaultLayerBlendMode;\n    _this._promises = {\n      weight: core_Deferred.resolve()\n    };\n    _this._weightPaused = false;\n    _this.weight = typeof options.weight === \'number\' ? options.weight : 1;\n    _this._internalWeight = _this._weight;\n    return _this;\n  }\n  /**\n   * Gets the type of blending used for states controlled by the layer.\n   *\n   * @readonly\n   * @type {string}\n   */\n\n\n  AnimationLayer_createClass(AnimationLayer, [{\n    key: "blendMode",\n    get: function get() {\n      return this._blendMode;\n    }\n    /**\n     * Gets and sets the amount of influence the layer\'s current animation has over\n     * the result for the host.\n     *\n     * @type {number}\n     */\n\n  }, {\n    key: "weight",\n    get: function get() {\n      return this._weight;\n    }\n    /**\n     * Gets whether or not the layer\'s weight value is currently being animated.\n     *\n     * @readonly\n     * @type {boolean}\n     */\n    ,\n    set: function set(weight) {\n      this._weight = core_MathUtils.clamp(weight, 0, 1);\n    }\n  }, {\n    key: "weightPending",\n    get: function get() {\n      return this._promises.weight && this._promises.weight.pending;\n    }\n    /**\n     * Pause the current animation state and any interpolation happening on the layer\'s\n     * weight property.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "pause",\n    value: function pause() {\n      this._paused = true;\n      this._weightPaused = true;\n      return this.pauseAnimation() || this.weightPending;\n    }\n    /**\n     * Resume the current animation state and any interpolation happening on the layer\'s\n     * weight property.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "resume",\n    value: function resume() {\n      this._paused = false;\n      this._weightPaused = false;\n      var isWeightActive = this.weightPending;\n\n      if (this._currentState) {\n        return this.resumeAnimation() || isWeightActive;\n      } else {\n        return isWeightActive;\n      }\n    }\n    /**\n     * Updates the user defined weight over time.\n     *\n     * @param {number} weight - The target weight value.\n     * @param {number} [seconds=0] - The amount of time it will take to reach the\n     * target weight.\n     * @param {Function=} easingFn - The easing function to use for interpolation.\n     *\n     * @returns {Deferred}\n     */\n\n  }, {\n    key: "setWeight",\n    value: function setWeight(weight) {\n      var seconds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var easingFn = arguments.length > 2 ? arguments[2] : undefined;\n\n      if (this.weightPending) {\n        this._promises.weight.cancel();\n      }\n\n      weight = core_MathUtils.clamp(weight);\n      this._promises.weight = animpack_AnimationUtils.interpolateProperty(this, \'weight\', weight, {\n        seconds: seconds,\n        easingFn: easingFn !== undefined ? easingFn : this._easingFn\n      });\n      return this._promises.weight;\n    }\n    /**\n     * Pause any interpolation happening on the layer\'s weight property.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "pauseWeight",\n    value: function pauseWeight() {\n      this._weightPaused = true;\n      return this.weightPending;\n    }\n    /**\n     * Resume any interpolation happening on the layer\'s weight property.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "resumeWeight",\n    value: function resumeWeight() {\n      this._weightPaused = false;\n      return this.weightPending;\n    }\n    /**\n     * Multiplies the user weight by a factor to determine the internal weight.\n     *\n     * @param {number} factor - 0-1 multiplier to apply to the user weight.\n     */\n\n  }, {\n    key: "updateInternalWeight",\n    value: function updateInternalWeight(factor) {\n      this._internalWeight = this._weight * factor;\n\n      if (this._currentState) {\n        this._currentState.updateInternalWeight(this._internalWeight);\n      }\n    }\n    /**\n     * Returns the names of blend states in an animation.\n     *\n     * @param {string} animationName - Name of the animation.\n     *\n     * @returns {Array.<string>} - Names of blend states.\n     */\n\n  }, {\n    key: "getAnimationBlendNames",\n    value: function getAnimationBlendNames(animationName) {\n      var state = this.getState(animationName);\n\n      if (state === undefined) {\n        throw new Error("Cannot get blend names of animation ".concat(animationName, " on layer ").concat(this.name, ". No animation exists with this name."));\n      }\n\n      if (state instanceof state_AbstractBlendState) {\n        return state.getStateNames();\n      }\n\n      throw new Error("Cannot get blend names of animation ".concat(animationName, " on layer ").concat(this.name, ". Animation is not an instance of AbstractBlendState."));\n    }\n    /**\n     * Update the weight for a blend state of an animation.\n     *\n     * @param {string} animationName - Name of the animation containing the blend state\n     * to update.\n     * @param {string} blendName - Name of the blend state to update.\n     * @param {number} weight - Weight value to set on the animation. This number shoudld be\n     * in the 0-1 range.\n     * @param {number=} seconds - Number of seconds it should take to reach the new weight.\n     * Default is zero and will set immediately.\n     * @param {Function=} easingFn - Easing function to use while interpolating the new\n     * weight. Default is Easing.Linear.InOut.\n     *\n     * @returns {Deferred} - Promise that will resolve once the animation\'s weight reaches\n     * the target value.\n     */\n\n  }, {\n    key: "setAnimationBlendWeight",\n    value: function setAnimationBlendWeight(animationName, blendName, weight) {\n      var seconds = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var easingFn = arguments.length > 4 ? arguments[4] : undefined;\n      var state = this.getState(animationName);\n\n      if (state === undefined) {\n        throw new Error("Cannot set blend weight of animation ".concat(animationName, " on layer ").concat(this.name, ". No animation exists with this name."));\n      }\n\n      if (state instanceof state_AbstractBlendState) {\n        return state.setBlendWeight(blendName, weight, seconds, easingFn);\n      }\n\n      throw new Error("Cannot set blend weight of animation ".concat(animationName, " on layer ").concat(this.name, ". Animation is not an instance of AbstractBlendState."));\n    }\n    /**\n     * Returns the weight for a blend state of an animation.\n     *\n     * @param {string} animationName - Name of the animation containing the blend state\n     * to update.\n     * @param {string} blendName - Name of the blend state to retrieve the weight of.\n     *\n     * @returns {number} - Weight of the blend state.\n     */\n\n  }, {\n    key: "getAnimationBlendWeight",\n    value: function getAnimationBlendWeight(animationName, blendName) {\n      var state = this.getState(animationName);\n\n      if (state === undefined) {\n        throw new Error("Cannot get blend weight of animation ".concat(animationName, " on layer ").concat(this.name, ". No animation exists with this name."));\n      }\n\n      if (state instanceof state_AbstractBlendState) {\n        return state.getBlendWeight(blendName);\n      }\n\n      throw new Error("Cannot get blend weight of animation ".concat(animationName, " on layer ").concat(this.name, ". Animation is not an instance of AbstractBlendState."));\n    }\n    /**\n     * Update any weight interpolators and the current animation.\n     *\n     * @param {number} deltaTime - Time in milliseconds since the last update.\n     */\n\n  }, {\n    key: "update",\n    value: function update(deltaTime) {\n      AnimationLayer_get(AnimationLayer_getPrototypeOf(AnimationLayer.prototype), "update", this).call(this, deltaTime);\n\n      if (!this._paused && !this._weightPaused) {\n        this._promises.weight.execute(deltaTime);\n      }\n    }\n    /**\n     * Cancel any pending promises and discard states controlled by the layer.\n     */\n\n  }, {\n    key: "discard",\n    value: function discard() {\n      AnimationLayer_get(AnimationLayer_getPrototypeOf(AnimationLayer.prototype), "discard", this).call(this);\n\n      this.discardStates();\n\n      this._promises.weight.cancel();\n\n      delete this._promises;\n    }\n  }]);\n\n  return AnimationLayer;\n}(animpack_AnimationPlayerInterface.Mixin(state_StateContainerInterface.Mixin()));\n\n/* harmony default export */ const animpack_AnimationLayer = (AnimationLayer);\n;// CONCATENATED MODULE: ./src/core/animpack/state/SingleState.js\nfunction SingleState_typeof(obj) { "@babel/helpers - typeof"; return SingleState_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, SingleState_typeof(obj); }\n\nfunction SingleState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction SingleState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction SingleState_createClass(Constructor, protoProps, staticProps) { if (protoProps) SingleState_defineProperties(Constructor.prototype, protoProps); if (staticProps) SingleState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction SingleState_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) SingleState_setPrototypeOf(subClass, superClass); }\n\nfunction SingleState_setPrototypeOf(o, p) { SingleState_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return SingleState_setPrototypeOf(o, p); }\n\nfunction SingleState_createSuper(Derived) { var hasNativeReflectConstruct = SingleState_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = SingleState_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = SingleState_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return SingleState_possibleConstructorReturn(this, result); }; }\n\nfunction SingleState_possibleConstructorReturn(self, call) { if (call && (SingleState_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return SingleState_assertThisInitialized(self); }\n\nfunction SingleState_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction SingleState_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction SingleState_getPrototypeOf(o) { SingleState_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return SingleState_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n/**\n * Class for playing a single animation clip.\n *\n * @extends AbstractState\n * @alias core/SingleState\n */\n\nvar SingleState = /*#__PURE__*/function (_AbstractState) {\n  SingleState_inherits(SingleState, _AbstractState);\n\n  var _super = SingleState_createSuper(SingleState);\n\n  /**\n   * @constructor\n   *\n   * @param {Object=} options - Options for the animation state.\n   * @param {string=} options.name - Name for the animation state. Names must be\n   * unique for the layer the state is applied to.\n   * @param {weight} [options.weight=0] - The 0-1 amount of influence the state will have.\n   * @param {timeScale} [options.timeScale=1] - Factor to scale the playback speed of the\n   * animation.\n   * @param {number} [options.loopCount=Infinity] - Number of times the animation should\n   * repeat before finishing.\n   * @param {string} [options.blendMode=DefaultLayerBlendMode] - Type of\n   * blending the animation should use.\n   */\n  function SingleState() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    SingleState_classCallCheck(this, SingleState);\n\n    _this = _super.call(this, options);\n    _this._timeScale = options.timeScale !== undefined ? options.timeScale : 1;\n    _this._promises.timeScale = core_Deferred.resolve();\n    _this._loopCount = options.loopCount !== undefined ? options.loopCount : Infinity;\n    _this._blendMode = validateBlendMode(options.blendMode);\n    return _this;\n  }\n  /**\n   * Gets and sets the normalized playing time of the current animation\n   *\n   * @type {number}\n   */\n\n\n  SingleState_createClass(SingleState, [{\n    key: "normalizedTime",\n    get: function get() {\n      return 0;\n    }\n    /**\n     * Gets and sets the a factor to scale animation playback speed with.\n     *\n     * @type {number}\n     */\n\n  }, {\n    key: "timeScale",\n    get: function get() {\n      return this._timeScale;\n    },\n    set: function set(timeScale) {\n      this._timeScale = timeScale;\n    }\n    /**\n     * Gets whether or not the timeScale is currently being animated.\n     *\n     * @readonly\n     * @type {boolean}\n     */\n\n  }, {\n    key: "timeScalePending",\n    get: function get() {\n      return this._promises.timeScale.pending;\n    }\n    /**\n     * Updates the timeScale value over time.\n     *\n     * @param {number} weight - The target timeScale value.\n     * @param {number} [seconds=0] - The amount of time it will take to reach the\n     * target timeScale.\n     * @param {Function=} easingFn - The easing function to use for interpolation.\n     *\n     * @returns {Deferred}\n     */\n\n  }, {\n    key: "setTimeScale",\n    value: function setTimeScale(timeScale) {\n      var seconds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var easingFn = arguments.length > 2 ? arguments[2] : undefined;\n\n      this._promises.timeScale.cancel();\n\n      this._promises.timeScale = animpack_AnimationUtils.interpolateProperty(this, \'timeScale\', timeScale, {\n        seconds: seconds,\n        easingFn: easingFn\n      });\n      return this._promises.timeScale;\n    }\n    /**\n     * Gets and sets the number of times the animation will repeat before finishing.\n     *\n     * @type {number}\n     */\n\n  }, {\n    key: "loopCount",\n    get: function get() {\n      return this._loopCount;\n    },\n    set: function set(loopCount) {\n      this._loopCount = loopCount;\n    }\n    /**\n     * Gets the type of blending used for the animation.\n     *\n     * @readonly\n     * @type {string}\n     */\n\n  }, {\n    key: "blendMode",\n    get: function get() {\n      return this._blendMode;\n    }\n  }]);\n\n  return SingleState;\n}(state_AbstractState);\n\n/* harmony default export */ const state_SingleState = (SingleState);\n;// CONCATENATED MODULE: ./src/core/animpack/state/RandomAnimationState.js\nfunction RandomAnimationState_typeof(obj) { "@babel/helpers - typeof"; return RandomAnimationState_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, RandomAnimationState_typeof(obj); }\n\nfunction RandomAnimationState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction RandomAnimationState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction RandomAnimationState_createClass(Constructor, protoProps, staticProps) { if (protoProps) RandomAnimationState_defineProperties(Constructor.prototype, protoProps); if (staticProps) RandomAnimationState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction RandomAnimationState_get() { if (typeof Reflect !== "undefined" && Reflect.get) { RandomAnimationState_get = Reflect.get; } else { RandomAnimationState_get = function _get(target, property, receiver) { var base = RandomAnimationState_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return RandomAnimationState_get.apply(this, arguments); }\n\nfunction RandomAnimationState_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = RandomAnimationState_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction RandomAnimationState_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) RandomAnimationState_setPrototypeOf(subClass, superClass); }\n\nfunction RandomAnimationState_setPrototypeOf(o, p) { RandomAnimationState_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return RandomAnimationState_setPrototypeOf(o, p); }\n\nfunction RandomAnimationState_createSuper(Derived) { var hasNativeReflectConstruct = RandomAnimationState_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = RandomAnimationState_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = RandomAnimationState_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return RandomAnimationState_possibleConstructorReturn(this, result); }; }\n\nfunction RandomAnimationState_possibleConstructorReturn(self, call) { if (call && (RandomAnimationState_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return RandomAnimationState_assertThisInitialized(self); }\n\nfunction RandomAnimationState_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction RandomAnimationState_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction RandomAnimationState_getPrototypeOf(o) { RandomAnimationState_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return RandomAnimationState_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n/**\n * Class for playing random animations at random intervals within this state.\n *\n * @extends AbstractState\n * @implements AnimationPlayerInterface\n * @implements StateContainerInterface\n */\n\nvar RandomAnimationState = /*#__PURE__*/function (_AnimationPlayerInter) {\n  RandomAnimationState_inherits(RandomAnimationState, _AnimationPlayerInter);\n\n  var _super = RandomAnimationState_createSuper(RandomAnimationState);\n\n  /**\n   * @constructor\n   *\n   * @param {Object} [options={}] - Options for the container state.\n   * @param {number} [options.playInterval=3] - The base animation playback interval.\n   * @param {Array.<AbstractState>} [subStates=[]] - states to be randomly picked to play\n   */\n  function RandomAnimationState() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var subStates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    RandomAnimationState_classCallCheck(this, RandomAnimationState);\n\n    _this = _super.call(this, options);\n    _this._playInterval = options.playInterval ? options.playInterval : 3;\n    subStates.forEach(function (state) {\n      _this.addState(state);\n    });\n    return _this;\n  }\n  /**\n   * Gets and sets the base animation play interval\n   *\n   * @type {float}\n   */\n\n\n  RandomAnimationState_createClass(RandomAnimationState, [{\n    key: "playInterval",\n    get: function get() {\n      return this._playInterval;\n    },\n    set: function set(playInterval) {\n      this._playInterval = playInterval;\n    }\n    /**\n     * Reset the internal timer for animation play interval\n     *\n     * @private\n     */\n\n  }, {\n    key: "_resetTimer",\n    value: function _resetTimer() {\n      var _this2 = this;\n\n      var playTimer = core_Utils.getRandomFloat(this._playInterval / 4, this._playInterval * 2);\n\n      var onFinish = function onFinish() {\n        _this2.playRandomAnimation(_this2._playCallbacks.onError);\n      };\n\n      this._promises.timer = core_Utils.wait(playTimer, {\n        onFinish: onFinish\n      });\n    }\n  }, {\n    key: "updateInternalWeight",\n    value: function updateInternalWeight(factor) {\n      RandomAnimationState_get(RandomAnimationState_getPrototypeOf(RandomAnimationState.prototype), "updateInternalWeight", this).call(this, factor);\n\n      if (this._currentState) {\n        this._currentState.updateInternalWeight(this._internalWeight);\n      }\n    }\n    /**\n     * Pick a random animation and utilize AnimationPlayerInterface to play that animation\n     *\n     * @param {Function=} onError - Function to execute if the state encounters\n     * an error during playback.\n     */\n\n  }, {\n    key: "playRandomAnimation",\n    value: function playRandomAnimation(onError) {\n      this._resetTimer();\n\n      var states = this.getStateNames();\n\n      if (this._currentState) {\n        states.splice(states.indexOf(this._currentState.name), 1);\n      }\n\n      var randomState = states[core_Utils.getRandomInt(0, states.length)];\n      this.playAnimation(randomState, this._transitionTime, this._easingFn, undefined, onError, undefined);\n    }\n  }, {\n    key: "play",\n    value: function play(onFinish, onError, onCancel) {\n      this.playRandomAnimation(onError);\n      return RandomAnimationState_get(RandomAnimationState_getPrototypeOf(RandomAnimationState.prototype), "play", this).call(this, onFinish, onError, onCancel);\n    }\n  }, {\n    key: "pause",\n    value: function pause() {\n      return RandomAnimationState_get(RandomAnimationState_getPrototypeOf(RandomAnimationState.prototype), "pause", this).call(this) && this.pauseAnimation();\n    }\n  }, {\n    key: "resume",\n    value: function resume(onFinish, onError, onCancel) {\n      if (this._currentState) {\n        this.resumeAnimation(this._currentState.name, this._transitionTime, this._easingFn, undefined, onError, undefined);\n      }\n\n      return RandomAnimationState_get(RandomAnimationState_getPrototypeOf(RandomAnimationState.prototype), "resume", this).call(this, onFinish, onError, onCancel);\n    }\n  }, {\n    key: "cancel",\n    value: function cancel() {\n      return RandomAnimationState_get(RandomAnimationState_getPrototypeOf(RandomAnimationState.prototype), "cancel", this).call(this) && this.cancelAnimation();\n    }\n  }, {\n    key: "stop",\n    value: function stop() {\n      return RandomAnimationState_get(RandomAnimationState_getPrototypeOf(RandomAnimationState.prototype), "stop", this).call(this) && this.stopAnimation();\n    }\n  }, {\n    key: "discard",\n    value: function discard() {\n      RandomAnimationState_get(RandomAnimationState_getPrototypeOf(RandomAnimationState.prototype), "discard", this).call(this);\n\n      this.discardStates();\n    }\n  }]);\n\n  return RandomAnimationState;\n}(animpack_AnimationPlayerInterface.Mixin(state_StateContainerInterface.Mixin(state_AbstractState)));\n\n/* harmony default export */ const state_RandomAnimationState = (RandomAnimationState);\n;// CONCATENATED MODULE: ./src/core/animpack/AnimationFeature.js\nfunction AnimationFeature_typeof(obj) { "@babel/helpers - typeof"; return AnimationFeature_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, AnimationFeature_typeof(obj); }\n\nfunction AnimationFeature_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction AnimationFeature_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? AnimationFeature_ownKeys(Object(source), !0).forEach(function (key) { AnimationFeature_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : AnimationFeature_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction AnimationFeature_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction AnimationFeature_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AnimationFeature_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AnimationFeature_createClass(Constructor, protoProps, staticProps) { if (protoProps) AnimationFeature_defineProperties(Constructor.prototype, protoProps); if (staticProps) AnimationFeature_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction AnimationFeature_get() { if (typeof Reflect !== "undefined" && Reflect.get) { AnimationFeature_get = Reflect.get; } else { AnimationFeature_get = function _get(target, property, receiver) { var base = AnimationFeature_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return AnimationFeature_get.apply(this, arguments); }\n\nfunction AnimationFeature_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = AnimationFeature_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction AnimationFeature_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) AnimationFeature_setPrototypeOf(subClass, superClass); }\n\nfunction AnimationFeature_setPrototypeOf(o, p) { AnimationFeature_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return AnimationFeature_setPrototypeOf(o, p); }\n\nfunction AnimationFeature_createSuper(Derived) { var hasNativeReflectConstruct = AnimationFeature_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = AnimationFeature_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = AnimationFeature_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return AnimationFeature_possibleConstructorReturn(this, result); }; }\n\nfunction AnimationFeature_possibleConstructorReturn(self, call) { if (call && (AnimationFeature_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return AnimationFeature_assertThisInitialized(self); }\n\nfunction AnimationFeature_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction AnimationFeature_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction AnimationFeature_getPrototypeOf(o) { AnimationFeature_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return AnimationFeature_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n\n\n\n\n\n\n/**\n * Enum for animation state classes.\n *\n * @readonly\n * @enum {Class}\n */\n\nvar AnimationTypes = {\n  single: state_SingleState,\n  freeBlend: state_FreeBlendState,\n  queue: state_QueueState,\n  randomAnimation: state_RandomAnimationState,\n  blend1d: state_Blend1dState,\n  blend2d: state_Blend2dState\n};\n/**\n * Feature for managing animations on an object.\n *\n * @extends AbstractHostFeature\n * @alias core/AnimationFeature\n *\n * @property {Object} EVENTS - Built-in messages that the feature emits. When the\n * feature is added to a {@link core/HostObject}, event names will be prefixed by the\n * name of the feature class + \'.\'.\n * @property {string} [EVENTS.addLayer=onAddLayerEvent] - Message that is emitted after\n * [addLayer]{@link core/AnimationFeature#addLayer} has been successfully executed.\n * An object representing the name of the layer that was added and its index in\n * the layer stack with the signature {name: string, index: number} is supplied\n * as an argument to listener functions.\n * @property {string} [EVENTS.removeLayer=onRemoveLayerEvent] - Message that is\n * emitted after [removeLayer]{@link core/AnimationFeature#removeLayer} has been\n * successfully executed. An object representing the name of the layer that was\n * removed and its index in the layer stack with the signature {name: string, index: number}\n * is supplied as an argument to listener functions.\n * @property {string} [EVENTS.renameLayer=onRenameLayerEvent] - Message that is\n * emitted after [renameLayer]{@link core/AnimationFeature#renameLayer} has been\n * successfully executed. An object representing the original name of the layer\n * that was renamed and its updated name with the signature {oldName: string, newName: string}\n * is supplied as an argument to listener functions.\n * @property {string} [EVENTS.addAnimation=onAddAnimationEvent] - Message that is\n * emitted after [addAnimation]{@link core/AnimationFeature#addAnimation} has been\n * successfully executed. An object representing the name of the layer that the\n * animation was added to and the name of the animation that was added with the\n * signature {layerName: string, animationName: string} is supplied as an argument\n * to listener functions.\n * @property {string} [EVENTS.removeAnimation=onRemovedAnimationEvent] - Message\n * that is emitted after [removeAnimation]{@link core/AnimationFeature#removeAnimation}\n * has been successfully executed. An object representing the name of the layer\n * that the animation was removed from and the name of the animation that was removed\n * with the signature {layerName: string, animationName: string} is supplied as\n * an argument to listener functions.\n * @property {string} [EVENTS.renameAnimation=onRenameAnimationEvent] - Message\n * that is emitted after [renameAnimation]{@link core/AnimationFeature#renameAnimation}\n * has been successfully executed. An object representing the name of the layer\n * that contains the animation that was renamed, the original name of the animation\n * that was renamed and its updated name with the signature {layerName: string, oldName: string, newName: string}\n * is supplied as an argument to listener functions.\n * @property {string} [EVENTS.play=onPlayEvent] - Message that is emitted after\n * each call to [play]{@link core/AnimationFeature#playAnimation}. An object representing\n * the name of the layer contains the animation that was played and the name of\n * the animation that was played with the signature {layerName: string, animationName: string}\n * is supplied as an argument to listener functions.\n * @property {string} [EVENTS.pause=onPauseEvent] - Message that is emitted after\n * each call to [pause]{@link core/AnimationFeature#pauseAnimation}. An object representing\n * the name of the layer contains the animation that was paused and the name of\n * the animation that was paused with the signature {layerName: string, animationName: string}\n * is supplied as an argument to listener functions.\n * @property {string} [EVENTS.resume=onResumeEvent] - Message that is emitted after\n * each call to [resume]{@link core/AnimationFeature#resumeAnimation}. An object representing\n * the name of the layer contains the animation that was resumed and the name of\n * the animation that was resumed with the signature {layerName: string, animationName: string}\n * is supplied as an argument to listener functions.\n * @property {string} [EVENTS.interrupt=onInterruptEvent] - Message that is emitted\n * if there is a current speech in progress and [play]{@link core/AnimationFeature#playAnimation}\n * or [resume]{@link core/AnimationFeature#resumeAnimation} are executed for a new speech.\n * An object representing the name of the layer contains the animation that was\n * interrupted and the name of the animation that was interrupted with the signature\n * {layerName: string, animationName: string} is supplied as an argument to listener\n * functions.\n * @property {string} [EVENTS.stop=onStopEvent] - Message that is emitted after\n * each call to [stop]{@link core/AnimationFeature#stopAnimation} and when a speech reaches\n * the end of playback. An object representing\n * the name of the layer contains the animation that was stopped and the name of\n * the animation that was stopped with the signature {layerName: string, animationName: string}\n * is supplied as an argument to listener functions.\n */\n\nvar AnimationFeature = /*#__PURE__*/function (_AbstractHostFeature) {\n  AnimationFeature_inherits(AnimationFeature, _AbstractHostFeature);\n\n  var _super = AnimationFeature_createSuper(AnimationFeature);\n\n  /**\n   * @constructor\n   *\n   * @param {core/HostObject} host - Host object that owns the feature.\n   */\n  function AnimationFeature(host) {\n    var _this;\n\n    AnimationFeature_classCallCheck(this, AnimationFeature);\n\n    _this = _super.call(this, host);\n    _this._layers = [];\n    _this._layerMap = {};\n    _this._paused = false;\n    return _this;\n  }\n  /**\n   * Make sure a supplied layer index is within the range of layers.\n   *\n   * @private\n   *\n   * @param {number} index\n   * @param {boolean} [existing=true] - Whether the index represents and existing\n   * layer or a new layer to be added.\n   *\n   * @returns {number=}\n   */\n\n\n  AnimationFeature_createClass(AnimationFeature, [{\n    key: "_validateIndex",\n    value: function _validateIndex(index) {\n      var existing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      // Index is invalid if there are no layers and we\'re checking for an existing layer index\n      if (this._layers.length === 0 && existing) {\n        return undefined;\n      }\n\n      var lastIndex = existing ? this._layers.length - 1 : this._layers.length; // Count from the end of the array for negative indices\n\n      if (index < 0) {\n        index = lastIndex + index + 1;\n      }\n\n      if (index < 0 || index > lastIndex) {\n        return undefined;\n      } else {\n        return index;\n      }\n    }\n    /**\n     * Re-evaluate internal weight values of layers starting from the top of the\n     * stack. Override layers\' weights affect the values of all layers lower in the\n     * stack.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_updateInternalWeights",\n    value: function _updateInternalWeights() {\n      var numLayers = this._layers.length;\n      var weightMultiplier = 1; // Update internal weight values on layers in reverse order\n\n      for (var i = numLayers - 1; i >= 0; i--) {\n        var layer = this._layers[i];\n        layer.updateInternalWeight(weightMultiplier); // If the layer is override, update the multiplier with the remainder of the full weight\n\n        if (layer.blendMode === LayerBlendModes.Override && layer.currentState) {\n          weightMultiplier *= 1 - layer.currentState.internalWeight;\n        }\n      }\n    }\n    /**\n     * Return a new instance of a SingleState.\n     *\n     * @private\n     *\n     * @param {Object} options - Options to pass to the SingleState constructor.\n     * @param {string=} options.name - Name for the animation state. Names must be\n     * unique for the layer the state is applied to.\n     * @param {weight} [options.weight=0] - The 0-1 amount of influence the state will have.\n     * @param {timeScale} [options.timeScale=1] - Factor to scale the playback speed of the\n     * animation.\n     * @param {number} [options.loopCount=Infinity] - Number of times the animation should\n     * repeat before finishing.\n     * @param {string} [options.blendMode=LayerBlendModes[DefaultLayerBlendMode]] - Type of\n     * blending the animation should use.\n     *\n     * @returns {core/SingleState}\n     */\n\n  }, {\n    key: "_createSingleState",\n    value: function _createSingleState(options) {\n      return new state_SingleState(options);\n    }\n    /**\n     * Return a new instance of a FreeBlendState.\n     *\n     * @private\n     *\n     * @param {Object} options - Options to pass to the FreeBlendState constructor.\n     * @param {string=} options.name - Name for the animation state. Names must be\n     * unique for the layer the state is applied to.\n     * @param {weight} [options.weight=0] - The 0-1 amount of influence the state will have.\n     * @param {timeScale} [options.timeScale=1] - Factor to scale the playback speed of the\n     * animation.\n     * @param {number} [options.loopCount=Infinity] - Number of times the animation should\n     * repeat before finishing.\n     * @param {string} [options.blendMode=LayerBlendModes[DefaultLayerBlendMode]] - Type of\n     * blending the animation should use.\n     * @param {Array.<Object>} [options.blendStateOptions] - Array of options used to create the\n     * blend states for this container.\n     *\n     * @returns {FreeBlendState}\n     */\n\n  }, {\n    key: "_createFreeBlendState",\n    value: function _createFreeBlendState(options) {\n      var _this2 = this;\n\n      var _options$blendStateOp = options.blendStateOptions,\n          blendStateOptions = _options$blendStateOp === void 0 ? [] : _options$blendStateOp;\n      var blendStates = [];\n      blendStateOptions.forEach(function (blendOptions) {\n        blendStates.push(_this2._createSingleState(AnimationFeature_objectSpread(AnimationFeature_objectSpread({}, blendOptions), {}, {\n          blendMode: options.blendMode\n        })));\n      });\n      return new state_FreeBlendState(options, blendStates);\n    }\n    /**\n     * Return a new instance of a QueueState.\n     *\n     * @private\n     *\n     * @param {Object} options - Options to pass to the QueueState constructor.\n     * @param {string=} options.name - Name for the animation state. Names must be\n     * unique for the layer the state is applied to.\n     * @param {number} [options.weight=0] - The 0-1 amount of influence the state will have.\n     * @param {number=} options.transitionTime - The amount of time it takes to transition\n     * between queued states.\n     * @param {string} [options.blendMode=LayerBlendModes[DefaultLayerBlendMode]] - Type of\n     * blending the animation should use.\n     * @param {Array.<Object>} [options.queueOptions] - Array of options used to create the\n     * queue states for this container.\n     *\n     * @returns {QueueState}\n     */\n\n  }, {\n    key: "_createQueueState",\n    value: function _createQueueState(options) {\n      var _this3 = this;\n\n      var _options$queueOptions = options.queueOptions,\n          queueOptions = _options$queueOptions === void 0 ? [] : _options$queueOptions;\n      var queueStates = queueOptions.map(function (queueOption) {\n        return _this3._createSingleState(AnimationFeature_objectSpread(AnimationFeature_objectSpread({\n          transitionTime: options.transitionTime\n        }, queueOption), {}, {\n          blendMode: options.blendMode\n        }));\n      });\n      return new state_QueueState(options, queueStates);\n    }\n    /**\n     * Return a new instance of a Blend1dState.\n     *\n     * @private\n     *\n     * @param {Object} options - Options to pass to the Blend1dState constructor.\n     * @param {string=} options.name - Name for the animation state. Names must be\n     * unique for the layer the state is applied to.\n     * @param {weight} [options.weight=0] - The 0-1 amount of influence the state will have.\n     * @param {timeScale} [options.timeScale=1] - Factor to scale the playback speed of the\n     * animation.\n     * @param {number} [options.loopCount=Infinity] - Number of times the animation should\n     * repeat before finishing.\n     * @param {string} [options.blendMode=LayerBlendModes[DefaultLayerBlendMode]] - Type of\n     * blending the animation should use.\n     * @param {Array.<Object>} [options.blendStateOptions] - Array of options used to create the\n     * blend states for this container.\n     * @param {Array.<number>} [options.blendThresholds] - Array of numbers used to set the\n     * thresholds for each blend state in this container.\n     * @param {Array.<boolean>} [options.blendMatchPhases=[]] - Optional array of booleans used to\n     * set whether or not each blend state in this container will match phases.\n     *\n     * @returns {Blend1dState}\n     */\n\n  }, {\n    key: "_createBlend1dState",\n    value: function _createBlend1dState(options) {\n      var _this4 = this;\n\n      var _options$blendStateOp2 = options.blendStateOptions,\n          blendStateOptions = _options$blendStateOp2 === void 0 ? [] : _options$blendStateOp2;\n      var _options$blendThresho = options.blendThresholds,\n          blendThresholds = _options$blendThresho === void 0 ? [] : _options$blendThresho;\n      var _options$blendMatchPh = options.blendMatchPhases,\n          blendMatchPhases = _options$blendMatchPh === void 0 ? [] : _options$blendMatchPh;\n      var blendStates = [];\n      blendStateOptions.forEach(function (blendOptions) {\n        blendStates.push(_this4._createSingleState(AnimationFeature_objectSpread(AnimationFeature_objectSpread({}, blendOptions), {}, {\n          blendMode: options.blendMode\n        })));\n      });\n      return new state_Blend1dState(options, blendStates, blendThresholds, blendMatchPhases);\n    }\n    /**\n     * Return a new instance of a Blend2dState.\n     *\n     * @private\n     *\n     * @param {Object} options - Options to pass to the Blend1dState constructor.\n     * @param {string=} options.name - Name for the animation state. Names must be\n     * unique for the layer the state is applied to.\n     * @param {weight} [options.weight=0] - The 0-1 amount of influence the state will have.\n     * @param {timeScale} [options.timeScale=1] - Factor to scale the playback speed of the\n     * animation.\n     * @param {number} [options.loopCount=Infinity] - Number of times the animation should\n     * repeat before finishing.\n     * @param {string} [options.blendMode=LayerBlendModes[DefaultLayerBlendMode]] - Type of\n     * blending the animation should use.\n     * @param {Array.<Object>} [options.blendStateOptions] - Array of options used to create the\n     * blend states for this container.\n     * @param {Array.<Array.<number>>} [options.blendThresholds] - Array of Array of numbers used to set the\n     * thresholds for each blend state in this container.\n     * @param {Array.<boolean>} [options.blendMatchPhases=[]] - Optional array of booleans used to\n     * set whether or not each blend state in this container will match phases.\n     *\n     * @returns {Blend1dState}\n     */\n\n  }, {\n    key: "_createBlend2dState",\n    value: function _createBlend2dState(options) {\n      var _this5 = this;\n\n      var _options$blendStateOp3 = options.blendStateOptions,\n          blendStateOptions = _options$blendStateOp3 === void 0 ? [] : _options$blendStateOp3;\n      var _options$blendThresho2 = options.blendThresholds,\n          blendThresholds = _options$blendThresho2 === void 0 ? [] : _options$blendThresho2;\n      var _options$blendMatchPh2 = options.blendMatchPhases,\n          blendMatchPhases = _options$blendMatchPh2 === void 0 ? [] : _options$blendMatchPh2;\n      var blendStates = [];\n      blendStateOptions.forEach(function (blendOptions) {\n        blendStates.push(_this5._createSingleState(AnimationFeature_objectSpread(AnimationFeature_objectSpread({}, blendOptions), {}, {\n          blendMode: options.blendMode\n        })));\n      });\n      return new state_Blend2dState(options, blendStates, blendThresholds, blendMatchPhases);\n    }\n    /**\n     * Return a new instance of a RandomAnimationState.\n     *\n     * @private\n     *\n     * @param {Object} options - Options to pass to the RandomAnimationState constructor.\n     * @param {string=} options.name - Name for the animation state. Names must be\n     * unique for the layer the state is applied to.\n     * @param {number} [options.playInterval=3] - The base animation playback interval.\n     * @param {Array.<Object>} [options.subStateOptions] - Array of options used to create the\n     * sub states for this container.\n     *\n     * @returns {RandomAnimationState}\n     */\n\n  }, {\n    key: "_createRandomAnimationState",\n    value: function _createRandomAnimationState(options) {\n      var _this6 = this;\n\n      var _options$subStateOpti = options.subStateOptions,\n          subStateOptions = _options$subStateOpti === void 0 ? [] : _options$subStateOpti;\n      var subStates = [];\n      subStateOptions.forEach(function (subStateOptions) {\n        subStates.push(_this6._createSingleState(AnimationFeature_objectSpread(AnimationFeature_objectSpread({}, subStateOptions), {}, {\n          blendMode: options.blendMode\n        })));\n      });\n      return new state_RandomAnimationState(options, subStates);\n    }\n    /**\n     * Make sure the layer with the given name exists and return a unique version\n     * of the animation name supplied for that layer.\n     *\n     * @private\n     *\n     * @param {string} layerName - Name of the layer to check against.\n     * @param {string} animationName - Name of the animation to validate.\n     *\n     * @returns {string} Validated animation name.\n     */\n\n  }, {\n    key: "_validateNewAnimation",\n    value: function _validateNewAnimation(layerName, animationName) {\n      // Make sure the layerName is valid\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Cannot add animation to layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      } // Make sure the animationName is unique\n\n\n      var name = core_Utils.getUniqueName(animationName, layer.getStateNames());\n\n      if (name !== animationName) {\n        console.warn("Animation name ".concat(animationName, " is not unique for layer ").concat(layer.name, ". Animation will be renamed to ").concat(name, "."));\n      }\n\n      return name;\n    }\n    /**\n     * Gets whether or not all animations are paused.\n     *\n     * @readonly\n     * @type {boolean}\n     */\n\n  }, {\n    key: "paused",\n    get: function get() {\n      return this._paused;\n    }\n    /**\n     * Gets an array of names of animation layers.\n     *\n     * @readonly\n     * @type {Array.<string>}\n     */\n\n  }, {\n    key: "layers",\n    get: function get() {\n      return this._layers.map(function (layer) {\n        return layer.name;\n      });\n    }\n    /**\n     * Create and store a new animation layer.\n     *\n     * @param {string} [name=\'NewLayer\'] - Name for the layer.\n     * @param {Object} [options={}] - Options to pass to {@link AnimationLayer#constructor}\n     * @param {index=} index - Index to insert the new layer at. If none is provided\n     * it will be added to the end of the stack.\n     *\n     * @returns {number} Index of the new layer.\n     */\n\n  }, {\n    key: "addLayer",\n    value: function addLayer() {\n      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \'NewLayer\';\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var index = arguments.length > 2 ? arguments[2] : undefined;\n      var numLayers = this._layers.length;\n      var layerIndex = index; // Make sure the given index is within the range of layers\n\n      if (index === undefined || index === -1) {\n        layerIndex = this._layers.length;\n      } else {\n        layerIndex = this._validateIndex(index, false);\n\n        if (layerIndex === undefined) {\n          // Insert at the beginning if the user passed in a negative index\n          if (index < 0) {\n            layerIndex = 0;\n          } // Otherwise append to the end\n          else {\n            layerIndex = this._layers.length;\n          }\n\n          console.warn("Index ".concat(index, " is invalid for host ").concat(this._host.id, ". New layer will be added at the closest valid index: ").concat(layerIndex, "."));\n        }\n      } // Make sure the layer name is unique\n\n\n      var layerName = core_Utils.getUniqueName(name, Object.keys(this._layerMap));\n\n      if (name !== layerName) {\n        console.warn("Layer name ".concat(name, " is not unique. New layer will be added with the name ").concat(layerName, "."));\n      }\n\n      var layer = new animpack_AnimationLayer(AnimationFeature_objectSpread(AnimationFeature_objectSpread({}, options), {}, {\n        name: layerName\n      }));\n      this._layerMap[layerName] = layer;\n\n      if (layerIndex === numLayers) {\n        this._layers.push(layer);\n      } else {\n        this._layers.splice(layerIndex, 0, layer);\n      } // Notify that a layer has been added to the feature\n\n\n      var eventData = {\n        name: layerName,\n        index: layerIndex\n      };\n      this.emit(this.constructor.EVENTS.addLayer, eventData);\n      return eventData;\n    }\n    /**\n     * Remove an animation layer from the stack. Animations on this layer will no\n     * longer be evaluated.\n     *\n     * @param {string} name - Name for the layer to remove.\n     *\n     * @returns {boolean} Whether or not removal was successful.\n     */\n\n  }, {\n    key: "removeLayer",\n    value: function removeLayer(name) {\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        console.warn("Did not remove layer ".concat(name, " from host ").concat(this._host.id, ". No layer exists with this name."));\n        return false;\n      }\n\n      layer.discard();\n\n      var index = this._layers.indexOf(layer);\n\n      this._layers.splice(index, 1);\n\n      delete this._layerMap[name]; // Notify that a layer has been removed from the feature\n\n      this.emit(this.constructor.EVENTS.removeLayer, {\n        name: name,\n        index: index\n      });\n      return true;\n    }\n    /**\n     * Re-order the layer stack so that the layer with the given name is positioned\n     * at the given index.\n     *\n     * @param {string} name - Name of the layer to move.\n     * @param {number} index - New index to position the layer at.\n     *\n     * @returns {number} The new index of the layer\n     */\n\n  }, {\n    key: "moveLayer",\n    value: function moveLayer(name, index) {\n      // Make sure the name is valid\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        throw new Error("Cannot move layer ".concat(name, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      } // Make sure the index falls in the range of existing layers\n\n\n      var layerIndex = this._validateIndex(index, true);\n\n      var lastIndex = this._layers.length - 1;\n\n      if (layerIndex === undefined) {\n        throw new Error("Cannot move layer ".concat(name, " from host ").concat(this._host.id, " to index ").concat(index, ". Index must be in the 0 - ").concat(lastIndex, " range."));\n      }\n\n      var currentIndex = this._layers.indexOf(layer);\n\n      if (currentIndex === layerIndex) {\n        return;\n      } // Remove from the current position\n\n\n      this._layers.splice(currentIndex, 1); // Insert at the new position\n\n\n      if (layerIndex === lastIndex) {\n        this._layers.push(layer);\n      } else {\n        this._layers.splice(layerIndex, 0, layer);\n      }\n\n      return layerIndex;\n    }\n    /**\n     * Update the name of a layer. Names must be unique, if the new name is not\n     * unique it will have trailing numbers appended until it is unique.\n     *\n     * @param {string} currentName - Current name of the layer.\n     * @param {string} newName - New name to set on the layer.\n     *\n     * @returns {string} The new name of the layer\n     */\n\n  }, {\n    key: "renameLayer",\n    value: function renameLayer(currentName, newName) {\n      // Make sure the name is valid\n      var layer = this._layerMap[currentName];\n\n      if (layer === undefined) {\n        throw new Error("Cannot rename layer ".concat(currentName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      } // Make sure the layer name is unique\n\n\n      var name = core_Utils.getUniqueName(newName, Object.keys(this._layerMap));\n\n      if (name !== newName) {\n        console.warn("Layer name ".concat(newName, " is not unique. Layer will be renamed to ").concat(name, "."));\n      }\n\n      delete this._layerMap[currentName];\n      this._layerMap[name] = layer;\n      layer.name = name; // Notify that a layer has been renamed on the feature\n\n      this.emit(this.constructor.EVENTS.renameLayer, {\n        oldName: currentName,\n        newName: name\n      });\n      return name;\n    }\n    /**\n     * Return the weight of an animation layer.\n     *\n     * @param {string} name - Name of the layer to return weight from.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: "getLayerWeight",\n    value: function getLayerWeight(name) {\n      // Make sure the name is valid\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        throw new Error("Cannot get weight on layer ".concat(name, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      return layer.weight;\n    }\n    /**\n     * Update the weight of an animation layer.\n     *\n     * @param {string} name - The name of the layer to update.\n     * @param {number} weight - The weight value to set on the layer. This number\n     * should be in the 0-1 range.\n     * @param {number=} seconds - The number of seconds it should take to reach the\n     * new weight. Default is zero and will set immediately.\n     * @param {Function=} easingFn - The easing function to use while interpolating\n     * the weight. Default is Easing.Linear.InOut.\n     *\n     * @returns {Deferred} A promise that will resolve once the layer\'s weight reaches\n     * the target value.\n     */\n\n  }, {\n    key: "setLayerWeight",\n    value: function setLayerWeight(name, weight, seconds, easingFn) {\n      // Make sure the name is valid\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        var e = "Cannot set weight on layer ".concat(name, " from host ").concat(this._host.id, ". No layer exists with this name.");\n        return core_Deferred.reject(e);\n      }\n\n      return layer.setWeight(weight, seconds, easingFn);\n    }\n    /**\n     * Returns the names of blend states in an animation in a layer.\n     *\n     * @param {string} layerName - Name of the layer containing the animation containing\n     * the blend state to update.\n     * @param {string} animationName - Name of the animation containing the blend state\n     * to update.\n     *\n     * @returns {Array.<string>} - Names of blend states.\n     */\n\n  }, {\n    key: "getAnimationBlendNames",\n    value: function getAnimationBlendNames(layerName, animationName) {\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Cannot get blend names on layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      return layer.getAnimationBlendNames(animationName);\n    }\n    /**\n     * Update the weight for a blend state in an animation in a layer.\n     *\n     * @param {string} layerName - Name of the layer containing the animation containing\n     * the blend state to update.\n     * @param {string} animationName - Name of the animation containing the blend state\n     * to update.\n     * @param {string} blendName - Name of the blend state to update.\n     * @param {number} weight - Weight value to set on the animation. This number shoudld be\n     * in the 0-1 range.\n     * @param {number=} seconds - Number of seconds it should take to reach the new weight.\n     * Default is zero and will set immediately.\n     * @param {Function=} easingFn - Easing function to use while interpolating the new\n     * weight. Default is Easing.Linear.InOut.\n     *\n     * @returns {Deferred} - Promise that will resolve once the animation\'s weight reaches\n     * the target value.\n     */\n\n  }, {\n    key: "setAnimationBlendWeight",\n    value: function setAnimationBlendWeight(layerName, animationName, blendName, weight, seconds, easingFn) {\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        var e = "Cannot set blend weight on layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name.");\n        return core_Deferred.reject(e);\n      }\n\n      return layer.setAnimationBlendWeight(animationName, blendName, weight, seconds, easingFn);\n    }\n    /**\n     * Returns the weight for a blend state in an animation in a layer.\n     *\n     * @param {string} layerName - Name of the layer containing the animation containing\n     * the blend state to update.\n     * @param {string} animationName - Name of the animation containing the blend state\n     * to update.\n     * @param {string} blendName - Name of the blend state to update.\n     *\n     * @returns {number} - Weight of the blend state.\n     */\n\n  }, {\n    key: "getAnimationBlendWeight",\n    value: function getAnimationBlendWeight(layerName, animationName, blendName) {\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Cannot get blend weight on layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      return layer.getAnimationBlendWeight(animationName, blendName);\n    }\n    /**\n     * Pause weight interpolation animation on a layer with the given name.\n     *\n     * @param {string} name - Name of the layer to pause.\n     *\n     * @returns {boolean} - Whether or not there was an existing interpolation to pause.\n     */\n\n  }, {\n    key: "pauseLayerWeight",\n    value: function pauseLayerWeight(name) {\n      // Make sure the name is valid\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        throw new Error("Cannot pause weight interpolation on layer ".concat(name, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      return layer.pauseWeight();\n    }\n    /**\n     * Resume weight interpolation animation on a layer with the given name.\n     *\n     * @param {string} name - Name of the layer to resume.\n     *\n     * @returns {Deferred} - Resolves once the layer\'s weight reaches its target value.\n     */\n\n  }, {\n    key: "resumeLayerWeight",\n    value: function resumeLayerWeight(name) {\n      // Make sure the name is valid\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        var e = "Cannot resume weight interpolation on layer ".concat(name, " from host ").concat(this._host.id, ". No layer exists with this name.");\n        return core_Deferred.reject(e);\n      }\n\n      return layer.resumeWeight();\n    }\n    /**\n     * Pause current animation and weight interpolation animation on a layer with\n     * the given name.\n     *\n     * @param {string} name - Name of the layer to pause.\n     *\n     * @returns {boolean} - Whether or not there was an existing interpolation or\n     * current animation to pause.\n     */\n\n  }, {\n    key: "pauseLayer",\n    value: function pauseLayer(name) {\n      // Make sure the name is valid\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        throw new Error("Cannot pause layer ".concat(name, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      return layer.pause();\n    }\n    /**\n     * Resume current animation and weight interpolation animation on a layer with\n     * the given name.\n     *\n     * @param {string} name - Name of the layer to resume.\n     *\n     * @returns {Deferred} - Resolves once the layer\'s weight reaches its target value\n     * and it\'s current animation finishes playing.\n     */\n\n  }, {\n    key: "resumeLayer",\n    value: function resumeLayer(name) {\n      // Make sure the name is valid\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        var e = "Cannot resume layer ".concat(name, " from host ").concat(this._host.id, ". No layer exists with this name.");\n        return core_Deferred.reject(e);\n      }\n\n      return layer.resume();\n    }\n    /**\n     * Return whether or not the animation layer with the given name is currently\n     * transitioning between animations.\n     *\n     * @param {string} layerName - Name of the layer to check.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "getTransitioning",\n    value: function getTransitioning(layerName) {\n      // Make sure the layerName is valid\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Get transitioning on layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      return layer.isTransitioning;\n    }\n    /**\n     * Return an array of the names of all states the layer with the given name controls.\n     *\n     * @param {string} layerName - Name of the layer to search.\n     *\n     * @returns {Array.<string>}\n     */\n\n  }, {\n    key: "getAnimations",\n    value: function getAnimations(layerName) {\n      // Make sure the layerName is valid\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Get animations on layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      return layer.getStateNames();\n    }\n    /**\n     * Return the name of the state currently active on the layer with the given name.\n     * Return null if there is no current animation for the layer.\n     *\n     * @param {string} layerName - Name of the layer.\n     *\n     * @returns {(string|null)}\n     */\n\n  }, {\n    key: "getCurrentAnimation",\n    value: function getCurrentAnimation(layerName) {\n      // Make sure the layerName is valid\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Get current animation on layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      return layer.currentAnimation;\n    }\n    /**\n     * Return whether or not a layer with the given name is currently playing an\n     * animation and that animation is paused.\n     *\n     * @param {string} layerName - Name of the layer.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "getPaused",\n    value: function getPaused(layerName) {\n      // Make sure the layerName is valid\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Get paused on layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      return layer.currentState && layer.currentState.paused;\n    }\n    /**\n     * Return the type name of the given animation. @see AnimationTypes.\n     *\n     * @param {string} layerName - Name of the layer that contains the animation.\n     * @param {string} animationName - Name of the animation to check.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: "getAnimationType",\n    value: function getAnimationType(layerName, animationName) {\n      // Make sure the layerName is valid\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Get animation type on layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      var state = layer.getState(animationName);\n\n      if (state === undefined) {\n        throw new Error("Get animation type for animation ".concat(animationName, " on layer ").concat(layerName, " from host ").concat(this._host.id, ". No animation exists with this name."));\n      }\n\n      var constructor = state.constructor;\n      return Object.keys(AnimationTypes).find(function (typeName) {\n        return AnimationTypes[typeName] === constructor;\n      });\n    }\n    /**\n     * Add a new animation to an animation layer.\n     *\n     * @param {string} layerName - Name of the layer to add the animation to.\n     * @param {string} animationName - Name to use when calling the animation.\n     * @param {Object=} options - Options to pass to the constructor for the new\n     * SingleState animation.\n     *\n     * @returns {string} - The name of the animation that was added\n     */\n\n  }, {\n    key: "addAnimation",\n    value: function addAnimation(layerName, animationName) {\n      var animationType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : AnimationTypes.single;\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      options.name = this._validateNewAnimation(layerName, animationName); // Make sure the animation type is valid\n\n      if (!Object.values(AnimationTypes).includes(animationType)) {\n        throw new Error("Cannot add animation ".concat(animationName, " to layer ").concat(layerName, " on host ").concat(this._host.id, ". Invalid animation type."));\n      }\n\n      var layer = this._layerMap[layerName];\n      options.blendMode = layer.blendMode;\n      options.transitionTime = layer.transitionTime;\n      var state = this["_create".concat(animationType.name)](options);\n      var name = layer.addState(state); // Notify that an animation has been added to the feature\n\n      this.emit(this.constructor.EVENTS.addAnimation, {\n        layerName: layerName,\n        animationName: name\n      });\n      return name;\n    }\n    /**\n     * Remove an animation from an animation layer.\n     *\n     * @param {string} layerName - Name of the layer to remove the animation from.\n     * @param {string} name - Name of the animation to remove.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "removeAnimation",\n    value: function removeAnimation(layerName, animationName) {\n      // Make sure the name is valid\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Cannot remove animation from layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      var removed = layer.removeState(animationName); // Notify that an animation has been removed from the feature\n\n      if (removed === true) {\n        this.emit(this.constructor.EVENTS.removeAnimation, {\n          layerName: layerName,\n          animationName: animationName\n        });\n      }\n\n      return removed;\n    }\n    /**\n     * Update the name of an animation. Names must be unique on each layer, if the new\n     * name is not unique it will have trailing numbers appended until it is unique.\n     *\n     * @param {string} layerName - Name of the layer that contains the animation that\n     * will be renamed,\n     * @param {string} currentAnimationName - Current name of the animation.\n     * @param {string} newAnimationName - New name to set on the animation.\n     *\n     * @returns {string} - The new name of the animation\n     */\n\n  }, {\n    key: "renameAnimation",\n    value: function renameAnimation(layerName, currentAnimationName, newAnimationName) {\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Cannot rename animation ".concat(currentAnimationName, " on layer ").concat(layerName, " for host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      var name = layer.renameState(currentAnimationName, newAnimationName); // Notify that an animation has been renamed on the feature\n\n      this.emit(this.constructor.EVENTS.renameAnimation, {\n        layerName: layerName,\n        oldName: currentAnimationName,\n        newName: name\n      });\n      return name;\n    }\n    /**\n     * Pause the currently playing animation and play a new animation from the beginning.\n     *\n     * @param {string} layerName - Name of the layer that contains the animation.\n     * @param {string} animationName - Name of the animation state to play.\n     * @param {number=} seconds - The number of seconds it should take to transition\n     * to the new animation. Default is zero and will set immediately.\n     * @param {Function=} easingFn - The easing function to use while transitioning\n     * between animations. Default is Easing.Linear.InOut.\n     *\n     * @returns {Deferred} - Resolves once the animation reaches the end of its\n     * timeline. Looping animations can only resolve if they are interrupted or\n     * manually stopped.\n     */\n\n  }, {\n    key: "playAnimation",\n    value: function playAnimation(layerName, animationName, seconds, easingFn) {\n      var _this7 = this;\n\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        var e = "Cannot play animation ".concat(animationName, " on layer ").concat(layerName, " for host ").concat(this._host.id, ". No layer exists with this name.");\n        return core_Deferred.reject(e);\n      } // Notify that a new animation has begun\n\n\n      this.emit(this.constructor.EVENTS.playAnimation, {\n        layerName: layerName,\n        animationName: animationName\n      });\n      return layer.playAnimation(animationName, seconds, easingFn, function () {\n        // Notify that an animation has stopped\n        _this7.emit(_this7.constructor.EVENTS.stopAnimation, {\n          layerName: layerName,\n          animationName: animationName\n        });\n      }, undefined, function () {\n        // Notify that an animation has been interrupted\n        _this7.emit(_this7.constructor.EVENTS.interruptAnimation, {\n          layerName: layerName,\n          animationName: animationName\n        });\n      }, function (_ref) {\n        var name = _ref.name,\n            canAdvance = _ref.canAdvance,\n            isQueueEnd = _ref.isQueueEnd;\n\n        if (layer.currentAnimation === animationName) {\n          // Notify that a new animation has begun\n          _this7.emit(_this7.constructor.EVENTS.playNextAnimation, {\n            layerName: layerName,\n            animationName: animationName,\n            nextQueuedAnimation: name,\n            canAdvance: canAdvance,\n            isQueueEnd: isQueueEnd\n          });\n        }\n      });\n    }\n    /**\n     * Play the next animation in the queue of a QueueState animation.\n     *\n     * @param {string} layerName - Name of the layer that contains the queue animation.\n     * @param {string=} animationName - Name of the animation queue animation. Defaults\n     * to the name of the current animation for the layer.\n     * @param {number=} seconds - The number of seconds it should take to transition\n     * to the queue animation if it\'s not already currently playing. Default is zero\n     * and will set immediately.\n     * @param {Function=} easingFn - The easing function to use while transitioning\n     * to the queue animation if it isn\'t already playing. Default is Easing.Linear.InOut.\n     *\n     * @returns {Deferred} - Resolves once the last animation in the queue finishes\n     * playing.\n     */\n\n  }, {\n    key: "playNextAnimation",\n    value: function playNextAnimation(layerName, animationName, transitionTime, easingFn) {\n      var _this8 = this;\n\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        var e = "Cannot play next animation on layer ".concat(layerName, " for host ").concat(this._host.id, ". No layer exists with this name.");\n        return core_Deferred.reject(e);\n      }\n\n      if (animationName === undefined) {\n        animationName = layer.currentAnimation;\n      }\n\n      var animation = layer.getState(layer.currentAnimation);\n\n      if (animation === null) {\n        var _e = "Cannot play next animation on layer ".concat(layerName, " for host ").concat(this._host.id, ". No animation exists with name ").concat(animationName, ".");\n\n        return core_Deferred.reject(_e);\n      } else if (this.getAnimationType(layerName, animationName) !== \'queue\') {\n        var _e2 = "Cannot play next animation on layer ".concat(layerName, " for host ").concat(this._host.id, ". ").concat(animationName, " is not a queue state.");\n\n        return core_Deferred.reject(_e2);\n      }\n\n      var onNext = function onNext(_ref2) {\n        var name = _ref2.name,\n            canAdvance = _ref2.canAdvance,\n            isQueueEnd = _ref2.isQueueEnd;\n\n        if (layer.currentAnimation === animationName) {\n          // Notify that a new animation has begun\n          _this8.emit(_this8.constructor.EVENTS.playNextAnimation, {\n            layerName: layerName,\n            animationName: animationName,\n            nextQueuedAnimation: name,\n            canAdvance: canAdvance,\n            isQueueEnd: isQueueEnd\n          });\n        }\n      }; // Make the queue animation current if it wasn\'t already\n\n\n      if (layer.currentAnimation === null) {\n        layer.resumeAnimation(animation.name, transitionTime, easingFn, undefined, undefined, undefined, onNext);\n      }\n\n      return animation.next(onNext, true);\n    }\n    /**\n     * Pause the current animation on a layer.\n     *\n     * @param {string} name - Name of the layer to pause.\n     *\n     * @returns {boolean} Whether or not an animation was successfully paused.\n     */\n\n  }, {\n    key: "pauseAnimation",\n    value: function pauseAnimation(name) {\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        console.warn("Did not pause animation on layer ".concat(name, " for host ").concat(this._host.id, ". No layer exists with this name."));\n        return false;\n      }\n\n      var paused = layer.pauseAnimation(); // Notify that an animation was paused\n\n      if (paused) {\n        var animationName = layer.currentAnimation;\n        this.emit(this.constructor.EVENTS.pauseAnimation, {\n          layerName: name,\n          animationName: animationName\n        });\n      }\n\n      return paused;\n    }\n    /**\n     * Pause the currently playing animation and play a new animation from where it\n     * last left off.\n     *\n     * @param {string} layerName - Name of the layer that contains the animation.\n     * @param {string=} animationName - Name of the animation state to resume. Defaults\n     * to the name of the current animation for the layer.\n     * @param {number=} seconds - The number of seconds it should take to transition\n     * to the new animation. Default is zero and will set immediately.\n     * @param {Function=} easingFn - The easing function to use while transitioning\n     * between animations. Default is Easing.Linear.InOut.\n     *\n     * @returns {Deferred} - Resolves once the animation reaches the end of its\n     * timeline. Looping animations can only resolve if they are interrupted or\n     * manually stopped.\n     */\n\n  }, {\n    key: "resumeAnimation",\n    value: function resumeAnimation(layerName, animationName, seconds, easingFn) {\n      var _this9 = this;\n\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        var e = "Cannot resume animation ".concat(animationName, " on layer ").concat(layerName, " for host ").concat(this._host.id, ". No layer exists with this name.");\n        return core_Deferred.reject(e);\n      } // Notify that an animation was resumed\n\n\n      this.emit(this.constructor.EVENTS.resumeAnimation, {\n        layerName: layerName,\n        animationName: animationName\n      });\n      return layer.resumeAnimation(animationName, seconds, easingFn, function () {\n        // Notify that an animation has stopped\n        _this9.emit(_this9.constructor.EVENTS.stopAnimation, {\n          layerName: layerName,\n          animationName: animationName\n        });\n      }, undefined, function () {\n        // Notify that an animation has been interrupted\n        _this9.emit(_this9.constructor.EVENTS.interruptAnimation, {\n          layerName: layerName,\n          animationName: animationName\n        });\n      }, function (_ref3) {\n        var name = _ref3.name,\n            canAdvance = _ref3.canAdvance,\n            isQueueEnd = _ref3.isQueueEnd;\n\n        if (layer.currentAnimation === animationName) {\n          // Notify that a new animation has begun\n          _this9.emit(_this9.constructor.EVENTS.playNextAnimation, {\n            layerName: layerName,\n            animationName: animationName,\n            nextQueuedAnimation: name,\n            canAdvance: canAdvance,\n            isQueueEnd: isQueueEnd\n          });\n        }\n      });\n    }\n    /**\n     * Stop the current animation on a layer. Stop rewinds the animation to the\n     * beginning and prevents it from progressing forward.\n     *\n     * @param {string} name - Name of the layer that contains the animation.\n     *\n     * @returns {boolean} Whether or not an animation was successfully stopped.\n     */\n\n  }, {\n    key: "stopAnimation",\n    value: function stopAnimation(name) {\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        console.warn("Did not stop animation on layer ".concat(name, " for host ").concat(this._host.id, ". No layer exists with this name."));\n        return false;\n      }\n\n      return layer.stopAnimation();\n    }\n    /**\n     * Pause current animation and weight interpolation animation on all layers.\n      * @returns {boolean} - Whether or not there was an existing interpolation or\n     * current animations to pause.\n     */\n\n  }, {\n    key: "pause",\n    value: function pause() {\n      this._paused = true;\n      var paused = false;\n\n      this._layers.forEach(function (l) {\n        if (l.pause()) {\n          paused = true;\n        }\n      });\n\n      return paused;\n    }\n    /**\n     * Resume current animation and weight interpolation animation on all layers.\n      * @returns {boolean} - Whether or not there was an existing interpolation or\n     * current animations to resume.\n     */\n\n  }, {\n    key: "resume",\n    value: function resume() {\n      this._paused = false;\n      var resumed = false;\n\n      this._layers.forEach(function (l) {\n        if (l.resume()) {\n          resumed = true;\n        }\n      });\n\n      return resumed;\n    }\n    /**\n     * Adds a namespace to the host with the name of the feature to contain properties\n     * and methods from the feature that users of the host need access to.\n     *\n     * @see AnimationFeature\n     */\n\n  }, {\n    key: "installApi",\n    value: function installApi() {\n      var _this10 = this;\n\n      /**\n       * @inner\n       * @namespace AnimationFeature\n       */\n      var api = AnimationFeature_get(AnimationFeature_getPrototypeOf(AnimationFeature.prototype), "installApi", this).call(this);\n\n      Object.defineProperties(api, {\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @see core/AnimationFeature#paused\n         */\n        paused: {\n          get: function get() {\n            return _this10.paused;\n          }\n        },\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @see core/AnimationFeature#layers\n         */\n        layers: {\n          get: function get() {\n            return _this10.layers;\n          }\n        }\n      });\n      Object.assign(api, {\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#addLayer\n         */\n        addLayer: this.addLayer.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#removeLayer\n         */\n        removeLayer: this.removeLayer.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#moveLayer\n         */\n        moveLayer: this.moveLayer.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#renameLayer\n         */\n        renameLayer: this.renameLayer.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#getLayerWeight\n         */\n        getLayerWeight: this.getLayerWeight.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#setLayerWeight\n         */\n        setLayerWeight: this.setLayerWeight.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#pauseLayerWeight\n         */\n        pauseLayerWeight: this.pauseLayerWeight.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#resumeLayerWeight\n         */\n        resumeLayerWeight: this.resumeLayerWeight.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#pauseLayer\n         */\n        pauseLayer: this.pauseLayer.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#resumeLayer\n         */\n        resumeLayer: this.resumeLayer.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#getTransitioning\n         */\n        getTransitioning: this.getTransitioning.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#getAnimations\n         */\n        getAnimations: this.getAnimations.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#getCurrentAnimation\n         */\n        getCurrentAnimation: this.getCurrentAnimation.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#getPaused\n         */\n        getPaused: this.getPaused.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#getAnimationType\n         */\n        getAnimationType: this.getAnimationType.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#addAnimation\n         */\n        addAnimation: this.addAnimation.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#removeAnimation\n         */\n        removeAnimation: this.removeAnimation.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#renameAnimation\n         */\n        renameAnimation: this.renameAnimation.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#getAnimationBlendNames\n         */\n        getAnimationBlendNames: this.getAnimationBlendNames.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#getAnimationBlendWeight\n         */\n        getAnimationBlendWeight: this.getAnimationBlendWeight.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#setAnimationBlendWeight\n         */\n        setAnimationBlendWeight: this.setAnimationBlendWeight.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#playAnimation\n         */\n        playAnimation: this.playAnimation.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#playNextAnimation\n         */\n        playNextAnimation: this.playNextAnimation.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#pauseAnimation\n         */\n        pauseAnimation: this.pauseAnimation.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#resumeAnimation\n         */\n        resumeAnimation: this.resumeAnimation.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#stopAnimation\n         */\n        stopAnimation: this.stopAnimation.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#pause\n         */\n        pause: this.pause.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#resume\n         */\n        resume: this.resume.bind(this)\n      });\n    }\n    /**\n     * Update each animation layer.\n     *\n     * @param {number} deltaTime - Time since the last update.\n     */\n\n  }, {\n    key: "update",\n    value: function update(deltaTime) {\n      if (!this._layers.length) {\n        return;\n      }\n\n      if (this._paused) {\n        deltaTime = 0;\n      } // Re-evaluate internal weights for layers\n\n\n      this._updateInternalWeights(); // Update layers\n\n\n      this._layers.forEach(function (layer) {\n        layer.update(deltaTime);\n      });\n\n      AnimationFeature_get(AnimationFeature_getPrototypeOf(AnimationFeature.prototype), "update", this).call(this, deltaTime);\n    }\n  }, {\n    key: "discard",\n    value: function discard() {\n      this._layers.forEach(function (layer) {\n        layer.discard();\n      });\n\n      delete this._layers;\n      delete this._layerMap;\n\n      AnimationFeature_get(AnimationFeature_getPrototypeOf(AnimationFeature.prototype), "discard", this).call(this);\n    }\n  }]);\n\n  return AnimationFeature;\n}(core_AbstractHostFeature);\n\nObject.defineProperty(AnimationFeature, \'EVENTS\', {\n  value: AnimationFeature_objectSpread(AnimationFeature_objectSpread({}, Object.getPrototypeOf(core_AbstractHostFeature).EVENTS), {}, {\n    addLayer: \'onAddLayerEvent\',\n    removeLayer: \'onRemoveLayerEvent\',\n    renameLayer: \'onRenameLayerEvent\',\n    addAnimation: \'onAddAnimationEvent\',\n    removeAnimation: \'onRemovedAnimationEvent\',\n    renameAnimation: \'onRenameAnimationEvent\',\n    playAnimation: \'onPlayEvent\',\n    playNextAnimation: \'onNextEvent\',\n    pauseAnimation: \'onPauseEvent\',\n    resumeAnimation: \'onResumeEvent\',\n    interruptAnimation: \'onInterruptEvent\',\n    stopAnimation: \'onStopEvent\'\n  })\n});\n/* harmony default export */ const animpack_AnimationFeature = (AnimationFeature);\n;// CONCATENATED MODULE: ./src/core/PointOfInterestFeature.js\nfunction PointOfInterestFeature_typeof(obj) { "@babel/helpers - typeof"; return PointOfInterestFeature_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, PointOfInterestFeature_typeof(obj); }\n\nfunction PointOfInterestFeature_slicedToArray(arr, i) { return PointOfInterestFeature_arrayWithHoles(arr) || PointOfInterestFeature_iterableToArrayLimit(arr, i) || PointOfInterestFeature_unsupportedIterableToArray(arr, i) || PointOfInterestFeature_nonIterableRest(); }\n\nfunction PointOfInterestFeature_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction PointOfInterestFeature_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction PointOfInterestFeature_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction PointOfInterestFeature_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction PointOfInterestFeature_toConsumableArray(arr) { return PointOfInterestFeature_arrayWithoutHoles(arr) || PointOfInterestFeature_iterableToArray(arr) || PointOfInterestFeature_unsupportedIterableToArray(arr) || PointOfInterestFeature_nonIterableSpread(); }\n\nfunction PointOfInterestFeature_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction PointOfInterestFeature_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return PointOfInterestFeature_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return PointOfInterestFeature_arrayLikeToArray(o, minLen); }\n\nfunction PointOfInterestFeature_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction PointOfInterestFeature_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return PointOfInterestFeature_arrayLikeToArray(arr); }\n\nfunction PointOfInterestFeature_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction PointOfInterestFeature_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction PointOfInterestFeature_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction PointOfInterestFeature_createClass(Constructor, protoProps, staticProps) { if (protoProps) PointOfInterestFeature_defineProperties(Constructor.prototype, protoProps); if (staticProps) PointOfInterestFeature_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction PointOfInterestFeature_get() { if (typeof Reflect !== "undefined" && Reflect.get) { PointOfInterestFeature_get = Reflect.get; } else { PointOfInterestFeature_get = function _get(target, property, receiver) { var base = PointOfInterestFeature_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return PointOfInterestFeature_get.apply(this, arguments); }\n\nfunction PointOfInterestFeature_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = PointOfInterestFeature_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction PointOfInterestFeature_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) PointOfInterestFeature_setPrototypeOf(subClass, superClass); }\n\nfunction PointOfInterestFeature_setPrototypeOf(o, p) { PointOfInterestFeature_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return PointOfInterestFeature_setPrototypeOf(o, p); }\n\nfunction PointOfInterestFeature_createSuper(Derived) { var hasNativeReflectConstruct = PointOfInterestFeature_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = PointOfInterestFeature_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = PointOfInterestFeature_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return PointOfInterestFeature_possibleConstructorReturn(this, result); }; }\n\nfunction PointOfInterestFeature_possibleConstructorReturn(self, call) { if (call && (PointOfInterestFeature_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return PointOfInterestFeature_assertThisInitialized(self); }\n\nfunction PointOfInterestFeature_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction PointOfInterestFeature_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction PointOfInterestFeature_getPrototypeOf(o) { PointOfInterestFeature_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return PointOfInterestFeature_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable no-underscore-dangle */\n\n/* eslint-disable no-unused-vars */\n\n\n\n\n\n\n\n/**\n * Enum for axis directions.\n *\n * @readonly\n * @enum {Class}\n */\n\nvar AxisMap = {\n  PositiveX: [1, 0, 0],\n  NegativeX: [-1, 0, 0],\n  PositiveY: [0, 1, 0],\n  NegativeY: [0, -1, 0],\n  PositiveZ: [0, 0, 1],\n  NegativeZ: [0, 0, -1]\n};\nvar FaceTargetTypes = {\n  EyeCenter: 0,\n  EyeLeft: 1,\n  EyeRight: 2,\n  Mouth: 3\n}; // Average distance between pupils is .064m, golden ratio says that the distance\n// from center of the pupils to the center of the mouth should be about the same.\n\nvar FaceVectors = [[0, 0, 0], [-0.032, 0, 0], [0.032, 0, 0], [0, -0.064, 0]]; // Time ranges to use when choosing a new random wait time between saccades\n\nvar MicroSaccadeWaitRanges = {\n  "default": [0.8, 1.75],\n  postMacro: [0.6, 1.3125]\n};\nvar MacroSaccadeWaitRanges = {\n  "default": [5.0, 8.0],\n  mouthTarget: [0.2, 0.75],\n  // Look away from a mouth target the fastest\n  eyeTarget: [1.5, 4.0]\n}; // Minimum angle in degrees the eye direction must change to trigger a blink animation\n\nvar BlinkThreshold = 35; // Maximum number of milliseconds to use for calculating look speed\n\nvar MaxDelta = 100 / 3;\n/**\n * PointOfInterest controls the gaze direction of the host. Given one or more\n * animations of type Blend2dState, it calculates the angles between the lookTracker\n * object (generally a joint in the host\'s skeleton) and the lookTarget (the object\n * the host should look at) and drives the managed Blend2dStates\' X and Y blend\n * values using the result. You can optionally add saccadic movement to any managed\n * animation to help make the host\'s eyes appear alive when focused on the same\n * point for exteded periods of time. If blink animations are specified, a blink\n * will be played during large changes in gaze direction.\n *\n * @extends AbstractHostFeature\n * @alias core/PointOfInterestFeature\n * @implements SSMLSpeechmarkInterface\n * @implements ManagedAnimationLayerInterface\n */\n\nvar PointOfInterestFeature = /*#__PURE__*/function (_AbstractHostFeature$) {\n  PointOfInterestFeature_inherits(PointOfInterestFeature, _AbstractHostFeature$);\n\n  var _super = PointOfInterestFeature_createSuper(PointOfInterestFeature);\n\n  /**\n   * @constructor\n   *\n   * @param {core/HostObject} host - Host that owns the feature.\n   * @param {Object=} options - Options for the feature.\n   * @param {Object=} target - 3D transformation node that the host should try to\n   * look at.\n   * @param {Object} options.lookTracker - 3D transformation node that represents\n   * the direction the host is currently looking during animation.\n   * @param {Object=} options.scene - Engine-specific scene object that contains\n   * the host. This object must be defined if using \'setTargetByName\' or \'SetTargetById\'\n   * methods.\n   * @param {Object=} lookOptions - Options for the look animation layers.\n   * @param {number} [lookOptions.blendTime=0.1] - Default amount of time it will\n   * take to manipulate the weights of the look layers.\n   * @param {number} [lookOptions.easingFn=Quadratic.InOut] - Default easing function\n   * to use when manipulating look layer weights.\n   * @param {Array.<Object>} [lookOptions.layers=[]] - An array of layer options\n   * objects to register as look layers.\n   * @param {Object=} blinkOptions - Options for the blink animation layers.\n   * @param {number} [blinkOptions.blendTime=0.075] - Default amount of time it\n   * will take to manipulate the weights of the blink layers.\n   * @param {number} [blinkOptions.easingFn=Quadratic.InOut] - Default easing function\n   * to use when manipulating blink layer weights.\n   * @param {Array.<Object>} [blinkOptions.layers=[]] - An array of layer options\n   * objects to register as blink layers.\n   */\n  function PointOfInterestFeature(host) {\n    var _this;\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        target = _ref.target,\n        lookTracker = _ref.lookTracker,\n        scene = _ref.scene;\n\n    var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref2$blendTime = _ref2.blendTime,\n        lookBlendTime = _ref2$blendTime === void 0 ? 0.1 : _ref2$blendTime,\n        _ref2$easingFn = _ref2.easingFn,\n        lookEasingFn = _ref2$easingFn === void 0 ? Quadratic.InOut : _ref2$easingFn,\n        _ref2$layers = _ref2.layers,\n        lookLayers = _ref2$layers === void 0 ? [] : _ref2$layers;\n\n    var _ref3 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n        _ref3$blendTime = _ref3.blendTime,\n        blinkBlendTime = _ref3$blendTime === void 0 ? 0.075 : _ref3$blendTime,\n        _ref3$easingFn = _ref3.easingFn,\n        blinkEasingFn = _ref3$easingFn === void 0 ? Quadratic.InOut : _ref3$easingFn,\n        _ref3$layers = _ref3.layers,\n        blinkLayers = _ref3$layers === void 0 ? [] : _ref3$layers;\n\n    PointOfInterestFeature_classCallCheck(this, PointOfInterestFeature);\n\n    _this = _super.call(this, host);\n\n    if (!_this.constructor._validateTransformObject(lookTracker)) {\n      throw new Error("Cannot initialize PointOfInterestFeature on host ".concat(_this._host.id, ". LookTracker must be defined as a valid transformation object."));\n    }\n\n    _this._lookTracker = lookTracker;\n    _this._scene = scene;\n    _this._target = target || null;\n    _this._prevTargetPos = [0, 0, 0];\n    _this._isTargetMoving = false;\n    _this._lookLayers = _this._lookLayers || {};\n    _this._trackingConfigs = _this._trackingConfigs || [];\n    _this._blinkLayers = _this._blinkLayers || {}; // Register the look layers\n\n    lookLayers.forEach(function (_ref4) {\n      var name = _ref4.name,\n          animation = _ref4.animation,\n          maxSpeed = _ref4.maxSpeed,\n          reference = _ref4.reference,\n          forwardAxis = _ref4.forwardAxis,\n          hasSaccade = _ref4.hasSaccade,\n          blendTime = _ref4.blendTime,\n          easingFn = _ref4.easingFn;\n\n      _this.registerLookLayer(name, {\n        animation: animation,\n        maxSpeed: maxSpeed,\n        reference: reference,\n        forwardAxis: forwardAxis,\n        hasSaccade: hasSaccade,\n        blendTime: blendTime !== undefined ? blendTime : lookBlendTime,\n        easingFn: easingFn !== undefined ? easingFn : lookEasingFn\n      });\n    }); // Register the blink layers\n\n    blinkLayers.forEach(function (_ref5) {\n      var name = _ref5.name,\n          animation = _ref5.animation,\n          blendTime = _ref5.blendTime,\n          easingFn = _ref5.easingFn;\n\n      _this.registerBlinkLayer(name, {\n        animation: animation,\n        blendTime: blendTime !== undefined ? blendTime : blinkBlendTime,\n        easingFn: easingFn !== undefined ? easingFn : blinkEasingFn\n      });\n    });\n    return _this;\n  }\n  /**\n   * Gets and sets the target object the host should look at.\n   *\n   * @type {Object|null}\n   */\n\n\n  PointOfInterestFeature_createClass(PointOfInterestFeature, [{\n    key: "target",\n    get: function get() {\n      return this._target;\n    },\n    set: function set(target) {\n      this._target = target || null;\n    }\n    /**\n     * Return a vector representing the global position of an object. Should be\n     * overloaded for each rendering engine implementation.\n     *\n     * @private\n     *\n     * @param {any} _obj - Engine-specific 3D transform object.\n     *\n     * @returns {Array.<number>} - An array consisting of three numbers representing\n     * x, y and z coordinates.\n     */\n\n  }, {\n    key: "_onLayerAdded",\n    value: function _onLayerAdded(_ref6) {\n      var name = _ref6.name;\n      this._lookLayers = this._lookLayers || {};\n      this._blinkLayers = this._blinkLayers || {};\n\n      PointOfInterestFeature_get(PointOfInterestFeature_getPrototypeOf(PointOfInterestFeature.prototype), "_onLayerAdded", this).call(this, {\n        name: name\n      }); // Validate the look animation\n\n\n      if (this._lookLayers[name] !== undefined) {\n        this._registerLookAnimation(name, this._lookLayers[name]);\n      }\n    }\n  }, {\n    key: "_onAnimationAdded",\n    value: function _onAnimationAdded(_ref7) {\n      var layerName = _ref7.layerName,\n          animationName = _ref7.animationName;\n      this._lookLayers = this._lookLayers || {};\n      this._blinkLayers = this._blinkLayers || {};\n\n      PointOfInterestFeature_get(PointOfInterestFeature_getPrototypeOf(PointOfInterestFeature.prototype), "_onAnimationAdded", this).call(this, {\n        layerName: layerName\n      }); // Validate the look animation\n\n\n      if (this._lookLayers[layerName] === animationName) {\n        this._registerLookAnimation(layerName, animationName);\n      }\n    }\n    /**\n     * Ensure that registered look animations are Blend2dStates.\n     *\n     * @private\n     *\n     * @param {string} layerName - Name of the layer that contains the look animation.\n     * @param {string} animationName - Name of the animation.\n     */\n\n  }, {\n    key: "_registerLookAnimation",\n    value: function _registerLookAnimation(layerName, animationName) {\n      if (this._managedLayers[layerName].animations[animationName].isActive) {\n        if (AnimationTypes[this._host.AnimationFeature.getAnimationType(layerName, animationName)] !== AnimationTypes.blend2d) {\n          // Warn and deactivate if the registered state is not blend2d\n          console.warn("Cannot register Point of Interest look animation ".concat(animationName, " on layer ").concat(layerName, " for host ").concat(this._host.id, ". Look animations must be of type \'blend2d\'."));\n          this._managedLayers[layerName].animations[animationName].isActive = false;\n        }\n      }\n    }\n    /**\n     * Check if the given object is not of an engine-specific type. Should\n     * be overloaded for each rendering engine implementation.\n     *\n     * @private\n     *\n     * @param {any} obj - Object to validate.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "_addTrackingConfig",\n    value:\n    /**\n     * Check if the given configuration object has already been stored as a tracking\n     * config. If it has, return the stored configuration. Otherwise, store and\n     * return it.\n     *\n     * @private\n     *\n     * @param {Object} config - Object containing tracker, reference and forwardAxis\n     * properties.\n     *\n     * @returns {Object}\n     */\n    function _addTrackingConfig(config) {\n      var trackingConfig = this._trackingConfigs.find(function (c) {\n        return c.reference === config.reference && c.forwardAxis === config.forwardAxis;\n      });\n\n      if (trackingConfig) {\n        return trackingConfig;\n      } else {\n        config.angles = {\n          h: 0,\n          v: 0\n        };\n        config.prevAngles = {\n          h: 0,\n          v: 0\n        };\n\n        this._trackingConfigs.push(config);\n\n        return config;\n      }\n    }\n    /**\n     * Return the distance between the look tracker and the look target.\n     *\n     * @private\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: "_getTargetDistance",\n    value: function _getTargetDistance() {\n      // Find the vector between the global positions of tracker and target\n      var sourcePosition = this.constructor._getWorldPosition(this._lookTracker);\n\n      var targetPosition = this.constructor._getWorldPosition(this._target);\n\n      var lookVector = [targetPosition[0] - sourcePosition[0], targetPosition[1] - sourcePosition[1], targetPosition[2] - sourcePosition[2]];\n      return core_MathUtils.getVectorMagnitude(lookVector);\n    }\n    /**\n     * Reset all stored tracking angles to 0.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_resetLookAngles",\n    value: function _resetLookAngles() {\n      this._trackingConfigs.forEach(function (_ref8) {\n        var angles = _ref8.angles;\n        angles.h = 0;\n        angles.v = 0;\n      });\n    }\n    /**\n     * Store the difference in horizontal and vertical rotation for the tracker\'s\n     * reference rotation and the direction of the target from the tracker.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_setLookAngles",\n    value: function _setLookAngles() {\n      var _this2 = this;\n\n      // Get the current positions of the tracker and target objects\n      var targetPos = this.constructor._getWorldPosition(this._target);\n\n      var trackerPos = this.constructor._getWorldPosition(this._lookTracker); // Check if the target has moved\n\n\n      this._isTargetMoving = core_MathUtils.getVectorMagnitude([targetPos[0] - this._prevTargetPos[0], targetPos[1] - this._prevTargetPos[1], targetPos[2] - this._prevTargetPos[2]]) > 0;\n      Object.assign(this._prevTargetPos, targetPos); // Calculate the horizontal and vertical angles to rotate to the target\n\n      var targetSpherical = core_MathUtils.cartesianToSpherical(targetPos[0] - trackerPos[0], targetPos[1] - trackerPos[1], targetPos[2] - trackerPos[2]);\n\n      var targetAngles = this.constructor._sphericalToBlendValue(targetSpherical[1], targetSpherical[2]); // Calculate angles relative to the reference objects\n\n\n      this._trackingConfigs.forEach(function (_ref9) {\n        var reference = _ref9.reference,\n            forwardAxis = _ref9.forwardAxis,\n            angles = _ref9.angles;\n\n        // Calculate the horizontal and vertical angles to rotate to the direction of the tracker\n        var refDirection = _this2.constructor._getObjectDirection(reference, forwardAxis);\n\n        var refSpherical = core_MathUtils.cartesianToSpherical.apply(core_MathUtils, PointOfInterestFeature_toConsumableArray(refDirection));\n\n        var refAngles = _this2.constructor._sphericalToBlendValue(refSpherical[1], refSpherical[2]); // Store the difference\n\n\n        angles.h = targetAngles.h - refAngles.h;\n        angles.v = targetAngles.v - refAngles.v;\n      });\n    }\n    /**\n     * Return the horizontal and vertical angles it would require to simulate looking\n     * at the given type of face target\n     *\n     * @private\n     *\n     * @param {number} targetType - Integer representing the FaceTargetType.\n     *\n     * @returns {Object}- An object with signature {r: number, h: number, v: number}\n     * where \'r\' represents radius, h represents the horizontal/azimuthal angle and\n     * v represents the vertical/polar angle.\n     */\n\n  }, {\n    key: "_getFaceTargetAngles",\n    value: function _getFaceTargetAngles(targetType) {\n      // No offset when the target is the center of the eyes\n      if (targetType === 0) {\n        return {\n          h: 0,\n          v: 0\n        };\n      } // Build a vector to the face target type using the current distance to the target\n\n\n      var distance = this._getTargetDistance(this._lookTracker);\n\n      var faceVector = PointOfInterestFeature_toConsumableArray(FaceVectors[targetType]);\n\n      faceVector[2] = distance;\n      var spherical = core_MathUtils.cartesianToSpherical.apply(core_MathUtils, PointOfInterestFeature_toConsumableArray(faceVector)); // Make sure values are clamped within the range of motion of the human eye, in case the target is very close\n\n      var blendValues = this.constructor._sphericalToBlendValue(spherical[1], spherical[2]);\n\n      blendValues.h = core_MathUtils.clamp(blendValues.h, -35, 35);\n      blendValues.v = core_MathUtils.clamp(blendValues.v, -25, 30);\n      return blendValues;\n    }\n    /**\n     * Updated the stored speed and duration variables for a layer based on the\n     * change in horizontal and vertical angles of the tracker.\n     *\n     * @private\n     *\n     * @param {string} layerName - Name of the layer to store values on.\n     * @param {number} h - Change in horizontal angle, in degrees.\n     * @param {number} v - Change in vertical angle, in degrees.\n     */\n\n  }, {\n    key: "_updateLayerSpeed",\n    value: function _updateLayerSpeed(layerName, h, v) {\n      var layer = this._managedLayers[layerName]; // From "Realistic Avatar and head Animation Using a Neurobiological Model of Visual Attention", Itti, Dhavale, Pighin\n\n      layer.maxHSpeed = 473 * (1 - Math.exp(-h / 7.8));\n      layer.maxVSpeed = 473 * (1 - Math.exp(-v / 7.8)); // From "Eyes Alive", Lee, Badler\n\n      var D0 = 0.025;\n      var d = 0.00235;\n      layer.hDuration = D0 + d * h;\n      layer.vDuration = D0 + d * v;\n    }\n    /**\n     * Set the microSaccade object with new randomized values.\n     *\n     * @private\n     *\n     * @param {string} layerName - Name of the layer that owns the saccade motion.\n     */\n\n  }, {\n    key: "_setMicroSaccade",\n    value: function _setMicroSaccade(layerName) {\n      var layer = this._managedLayers[layerName];\n      var microSaccade = layer.microSaccade;\n\n      if (this._target) {\n        // Micro movements should be smaller when focused on a target\n        microSaccade.h = core_Utils.getRandomFloat(0.01, 0.15);\n        microSaccade.v = core_Utils.getRandomFloat(0.01, 0.15);\n      } else {\n        // Microsaccades. Encyclopedia of Neuroscience. (2009) Springer, Berlin, Heidelberg. https://doi.org/10.1007/978-3-540-29678-2_3492\n        microSaccade.h = core_Utils.getRandomFloat(0.01, 0.3);\n        microSaccade.v = core_Utils.getRandomFloat(0.01, 0.3);\n      }\n\n      this._updateLayerSpeed(layerName, microSaccade.h, microSaccade.v); // Restart the timer\n\n\n      this._initializeMicroTimer.apply(this, [layerName].concat(PointOfInterestFeature_toConsumableArray(MicroSaccadeWaitRanges["default"])));\n    }\n    /**\n     * Set the macroSaccade object with new randomized values.\n     *\n     * @private\n     *\n     * @param {string} layerName - Name of the layer that owns the saccade motion.\n     */\n\n  }, {\n    key: "_setMacroSaccade",\n    value: function _setMacroSaccade(layerName) {\n      var layer = this._managedLayers[layerName];\n      var macroSaccade = layer.macroSaccade;\n      var macroSaccadeWaitRange; // Increase random value range when not focused on a target\n\n      if (!this._target) {\n        macroSaccadeWaitRange = MacroSaccadeWaitRanges["default"]; // Normal human horizontal eye rotation limit is about 35 degrees\n\n        var hLimit = core_Utils.getRandomFloat(0.143, 0.286);\n        var hFactor = core_Utils.getRandomFloat(-hLimit, hLimit);\n        macroSaccade.h = hFactor * 35; // Normal human vertical eye rotation limit is about 25 degrees upward and 30 degrees downward\n\n        var vLimit = core_Utils.getRandomFloat(0.093, 0.186);\n        var vFactor = core_Utils.getRandomFloat(-vLimit, vLimit);\n        macroSaccade.v = vFactor > 0 ? vFactor * 25 : vFactor * 30;\n      } // Pick a new face target\n      else {\n        // Social triangle - saccade between eyes and mouth, weighted to look at eyes more often\n        switch (layer.saccadeTarget) {\n          case 1:\n            macroSaccadeWaitRange = MacroSaccadeWaitRanges.eyeTarget;\n            layer.saccadeTarget = Math.random() < 0.75 ? FaceTargetTypes.EyeRight : FaceTargetTypes.Mouth;\n            break;\n\n          case 2:\n            macroSaccadeWaitRange = MacroSaccadeWaitRanges.eyeTarget;\n            layer.saccadeTarget = Math.random() < 0.75 ? FaceTargetTypes.EyeLeft : FaceTargetTypes.Mouth;\n            break;\n\n          case 3:\n            macroSaccadeWaitRange = MacroSaccadeWaitRanges.mouthTarget;\n            layer.saccadeTarget = Math.random() < 0.5 ? FaceTargetTypes.EyeLeft : FaceTargetTypes.EyeRight;\n            break;\n\n          case 0:\n          default:\n            macroSaccadeWaitRange = MacroSaccadeWaitRanges.eyeTarget;\n            layer.saccadeTarget = Math.random() < 0.5 ? FaceTargetTypes.EyeLeft : FaceTargetTypes.EyeRight;\n            break;\n        }\n\n        var _this$_getFaceTargetA = this._getFaceTargetAngles(layer.saccadeTarget),\n            h = _this$_getFaceTargetA.h,\n            v = _this$_getFaceTargetA.v;\n\n        macroSaccade.h = h;\n        macroSaccade.v = v;\n      }\n\n      this._updateLayerSpeed(layerName, macroSaccade.h, macroSaccade.v); // Restart the timers\n\n\n      this._initializeMicroTimer.apply(this, [layerName].concat(PointOfInterestFeature_toConsumableArray(MicroSaccadeWaitRanges.postMacro)));\n\n      this._initializeMacroTimer.apply(this, [layerName].concat(PointOfInterestFeature_toConsumableArray(macroSaccadeWaitRange)));\n    }\n    /**\n     * Start a new wait timer that will set a new micro saccade movement when it\n     * resolves.\n     *\n     * @private\n     *\n     * @param {string} layerName - Name of the layer that owns the saccade motion.\n     * @param {number} minWaitTime - Minimum number of seconds before a new saccade\n     * will be triggered.\n     * @param {number} maxWaitTime - Maximum number of seconds before a new saccade\n     * will be triggered.\n     */\n\n  }, {\n    key: "_initializeMicroTimer",\n    value: function _initializeMicroTimer(layerName, minWaitTime, maxWaitTime) {\n      var _this3 = this;\n\n      var layer = this._managedLayers[layerName];\n      var waitTime = core_Utils.getRandomFloat(minWaitTime, maxWaitTime);\n\n      if (layer.microSaccadeTimer) {\n        layer.microSaccadeTimer.cancel();\n      }\n\n      layer.microSaccadeTimer = core_Utils.wait(waitTime, {\n        onFinish: function onFinish() {\n          _this3._setMicroSaccade(layerName);\n        }\n      });\n    }\n    /**\n     * Start a new wait timer that will set a new macro saccade movement when it\n     * resolves.\n     *\n     * @private\n     *\n     * @param {string} layerName - Name of the layer that owns the saccade motion.\n     * @param {number} minWaitTime - Minimum number of seconds before a new saccade\n     * will be triggered.\n     * @param {number} maxWaitTime - Maximum number of seconds before a new saccade\n     * will be triggered.\n     */\n\n  }, {\n    key: "_initializeMacroTimer",\n    value: function _initializeMacroTimer(layerName, minWaitTime, maxWaitTime) {\n      var _this4 = this;\n\n      var layer = this._managedLayers[layerName];\n      var waitTime = core_Utils.getRandomFloat(minWaitTime, maxWaitTime);\n\n      if (layer.macroSaccadeTimer) {\n        layer.macroSaccadeTimer.cancel();\n      }\n\n      layer.macroSaccadeTimer = core_Utils.wait(waitTime, {\n        onFinish: function onFinish() {\n          _this4._setMacroSaccade(layerName);\n        }\n      });\n    }\n    /**\n     * Sets a new target to look at.\n     *\n     * @param {Object|null} target - The new target to look at.\n     */\n\n  }, {\n    key: "setTarget",\n    value: function setTarget(target) {\n      this.target = target;\n    }\n    /**\n     * Finds an object given its name and sets it as the new target to look at.\n     * Should be overloaded for each rendering engine implementation.\n     *\n     * @param {string} target - Name to search for.\n     */\n\n  }, {\n    key: "setTargetByName",\n    value: function setTargetByName(name) {\n      if (!name) {\n        this._target = null;\n      }\n\n      if (!this._scene) {\n        throw new Error("Cannot set PointOfInterestFeature target using name ".concat(name, " on host ").concat(this._host.id, ". Scene must be defined."));\n      }\n    }\n    /**\n     * Finds an object given its id and sets it as the new target to look at.\n     * Should be overloaded for each rendering engine implementation.\n     *\n     * @param {string|number} target - Id to search for.\n     */\n\n  }, {\n    key: "setTargetById",\n    value: function setTargetById(id) {\n      if (!id) {\n        this._target = null;\n      }\n\n      if (!this._scene) {\n        throw new Error("Cannot set PointOfInterestFeature target using id ".concat(id, " on host ").concat(this._host.id, ". Scene must be defined."));\n      }\n    }\n    /**\n     * Start keeping track of an animation layer that owns a blend2d animation with\n     * blendWeights corresponding to horizontal and vertical look angles.\n     *\n     * @param {string} layerName - Name of the layer to keep track of.\n     * @param {Object=} options - Options for the layer.\n     * @param {string} [options.animation = \'look\'] - Name of the animation on the\n     * layer whose blendWeights will be driven based on the angle between the lookTracker\n     * and the lookTarget. This animation must be of type blend2d.\n     * @param {number} [options.maxSpeed = 25] - The maximum speed at which the blend2d\n     * blendWeights can be manipulated.\n     * @param {string} [options.forwardAxis = \'PositiveZ\'] - Axis pointing from the\n     * front of the lookReference object. Valid options are \'PositiveX\', \'NegativeX\',\n     * \'PositiveY\', \'NegativeY\', \'PositiveZ\', \'NegativeZ\'.\n     * @param {Object=} options.lookReference - 3D transformation node that the lookTracker\n     * rotation limits should be calculated relative to. Defaults to the host owner.\n     * @param {number} [options.hasSaccade = false] - Whether or not to include\n     * saccadic motion onto the blendWeight animation. This should only be set to\n     * true for blend2d animations representing eye animation.\n     * @param {number=} [options.blendTime=[PointOfInterestFeature.DEFAULT_LAYER_OPTIONS.blendTime]{@link PointOfInterestFeature#DEFAULT_LAYER_OPTIONS#blendTime}] -\n     * Default amount of time to use when manipulating layer weight.\n     * @param {Function=} options.easingFn - Default easing function to use when\n     * manipulating layer weight.\n     */\n\n  }, {\n    key: "registerLookLayer",\n    value: function registerLookLayer(layerName) {\n      var _ref10 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref10$animation = _ref10.animation,\n          animation = _ref10$animation === void 0 ? \'look\' : _ref10$animation,\n          _ref10$maxSpeed = _ref10.maxSpeed,\n          maxSpeed = _ref10$maxSpeed === void 0 ? 25 : _ref10$maxSpeed,\n          reference = _ref10.reference,\n          _ref10$forwardAxis = _ref10.forwardAxis,\n          forwardAxis = _ref10$forwardAxis === void 0 ? \'PositiveZ\' : _ref10$forwardAxis,\n          _ref10$hasSaccade = _ref10.hasSaccade,\n          hasSaccade = _ref10$hasSaccade === void 0 ? false : _ref10$hasSaccade,\n          _ref10$blendTime = _ref10.blendTime,\n          blendTime = _ref10$blendTime === void 0 ? PointOfInterestFeature.DEFAULT_LAYER_OPTIONS.blendTime : _ref10$blendTime,\n          easingFn = _ref10.easingFn;\n\n      // Validate reference object\n      reference = reference || this._host.owner;\n\n      if (!this.constructor._validateTransformObject(reference)) {\n        throw new Error("Cannot initialize register look layer ".concat(layerName, " for PointOfInterestFeature on host ").concat(this._host.id, ". Reference must be defined as a valid transformation object."));\n      } // Find vector associated with axis string\n\n\n      forwardAxis = AxisMap[forwardAxis] !== undefined ? AxisMap[forwardAxis] : AxisMap.PositiveZ; // Store tracking configuration\n\n      var trackingConfig = this._addTrackingConfig({\n        reference: reference,\n        forwardAxis: forwardAxis\n      }); // Register the layer and animation\n\n\n      this.registerLayer(layerName, {\n        trackingConfig: trackingConfig,\n        maxSpeed: maxSpeed,\n        maxHSpeed: undefined,\n        maxVSpeed: undefined,\n        hDuration: undefined,\n        vDuration: undefined,\n        hVelocity: [0, 0],\n        vVelocity: [0, 0],\n        hasSaccade: hasSaccade,\n        blendTime: blendTime,\n        easingFn: easingFn,\n        microSaccade: {\n          h: 0,\n          v: 0\n        },\n        macroSaccade: {\n          h: 0,\n          v: 0\n        },\n        saccadeTarget: FaceTargetTypes.EyeCenter,\n        animations: PointOfInterestFeature_defineProperty({}, animation, {})\n      });\n      this._lookLayers[layerName] = animation; // Validate the look animation\n\n      this._registerLookAnimation(layerName, animation); // Initialize saccade timers\n\n\n      if (hasSaccade) {\n        var macroSaccadeWaitRange = this._target ? MacroSaccadeWaitRanges.eyeTarget : MacroSaccadeWaitRanges["default"];\n\n        this._initializeMicroTimer.apply(this, [layerName].concat(PointOfInterestFeature_toConsumableArray(MicroSaccadeWaitRanges["default"])));\n\n        this._initializeMacroTimer.apply(this, [layerName].concat(PointOfInterestFeature_toConsumableArray(macroSaccadeWaitRange)));\n      }\n    }\n    /**\n     * Start keeping track of an animation layer that owns a blink animation. Blink\n     * animations can be of any type, but if it is of type randomAnimation then a\n     * it will be randomized each time a blink is called.\n     *\n     * @param {string} layerName - Name of the layer to keep track of.\n     * @param {Object=} options - Options for the layer.\n     * @param {string} [options.animation = \'blink\'] - Name of the blink animation\n     * on the layer.\n     * @param {number} [options.blendTime=[PointOfInterestFeature.DEFAULT_LAYER_OPTIONS.blendTime]{@link PointOfInterestFeature#DEFAULT_LAYER_OPTIONS#blendTime}] -\n     * Default amount of time to use when manipulating the layer\'s weight.\n     * @param {Function=} options.easingFn - Default easing function to use when\n     * manipulating the layer\'s weight.\n     */\n\n  }, {\n    key: "registerBlinkLayer",\n    value: function registerBlinkLayer(layerName) {\n      var _ref11 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref11$animation = _ref11.animation,\n          animation = _ref11$animation === void 0 ? \'blink\' : _ref11$animation,\n          _ref11$blendTime = _ref11.blendTime,\n          blendTime = _ref11$blendTime === void 0 ? PointOfInterestFeature.DEFAULT_LAYER_OPTIONS.blendTime : _ref11$blendTime,\n          easingFn = _ref11.easingFn;\n\n      // Register the layer and animation\n      this.registerLayer(layerName, {\n        blendTime: blendTime,\n        easingFn: easingFn,\n        animations: PointOfInterestFeature_defineProperty({}, animation, {})\n      });\n      this._blinkLayers[layerName] = animation;\n    }\n  }, {\n    key: "update",\n    value: function update(deltaTime) {\n      var _this5 = this;\n\n      PointOfInterestFeature_get(PointOfInterestFeature_getPrototypeOf(PointOfInterestFeature.prototype), "update", this).call(this, deltaTime); // Update the look angles\n\n\n      if (this._target) {\n        this._setLookAngles();\n      } else {\n        this._resetLookAngles();\n      }\n\n      var deltaSeconds = Math.min(deltaTime, MaxDelta) / 1000;\n      var triggerBlink = false; // Set look blend values\n\n      Object.entries(this._lookLayers).forEach(function (_ref12) {\n        var _ref13 = PointOfInterestFeature_slicedToArray(_ref12, 2),\n            layerName = _ref13[0],\n            animName = _ref13[1];\n\n        var options = _this5._managedLayers[layerName]; // Increment the saccade timers\n\n        if (options.isActive && options.hasSaccade) {\n          options.microSaccadeTimer.execute(deltaTime);\n          options.macroSaccadeTimer.execute(deltaTime);\n        } // Set the blend values\n\n\n        if (options.animations[animName].isActive) {\n          var currentH = _this5._host.AnimationFeature.getAnimationBlendWeight(layerName, animName, \'X\');\n\n          var currentV = _this5._host.AnimationFeature.getAnimationBlendWeight(layerName, animName, \'Y\');\n\n          var targetH = options.trackingConfig.angles.h;\n          var targetV = options.trackingConfig.angles.v; // Check if the look angle has changed enough to trigger a blink\n\n          if (_this5._isTargetMoving && !triggerBlink) {\n            var prevTargetH = options.trackingConfig.prevAngles.h;\n            var prevTargetV = options.trackingConfig.prevAngles.v;\n            var changeAmount = core_MathUtils.toDegrees(core_MathUtils.getAngleBetween([prevTargetH, prevTargetV], [targetH, targetV]));\n\n            if (changeAmount >= BlinkThreshold) {\n              triggerBlink = true;\n            }\n          }\n\n          options.trackingConfig.prevAngles.h = targetH;\n          options.trackingConfig.prevAngles.v = targetV; // Add in the saccade movement\n\n          if (options.hasSaccade) {\n            core_MathUtils.dampValue(0, options.macroSaccade.h + options.macroSaccade.h, options.hVelocity, options.hDuration, options.maxHSpeed);\n            targetH += options.hVelocity[0];\n            core_MathUtils.dampValue(0, options.macroSaccade.v + options.macroSaccade.v, options.vVelocity, options.vDuration, options.maxVSpeed);\n            targetV += options.vVelocity[0];\n          } // Clamp to max speed\n\n\n          var factor = core_MathUtils.clamp(deltaSeconds * options.maxSpeed, 0, 1);\n          targetH = core_MathUtils.lerp(currentH, targetH, factor);\n          targetV = core_MathUtils.lerp(currentV, targetV, factor); // Update the blend values\n\n          _this5._host.AnimationFeature.setAnimationBlendWeight(layerName, animName, \'X\', targetH);\n\n          _this5._host.AnimationFeature.setAnimationBlendWeight(layerName, animName, \'Y\', targetV);\n        }\n      });\n\n      if (!triggerBlink || !this._isTargetMoving) {\n        return;\n      } // Execute blink\n\n\n      Object.entries(this._blinkLayers).forEach(function (_ref14) {\n        var _ref15 = PointOfInterestFeature_slicedToArray(_ref14, 2),\n            layerName = _ref15[0],\n            animName = _ref15[1];\n\n        var animation = _this5._managedLayers[layerName].animations[animName];\n\n        if (animation.isActive) {\n          _this5._host.AnimationFeature.playAnimation(layerName, animName);\n        }\n      });\n    }\n  }, {\n    key: "installApi",\n    value: function installApi() {\n      var _this6 = this;\n\n      /**\n       * @inner\n       * @namespace PointOfInterestFeature\n       */\n      var api = PointOfInterestFeature_get(PointOfInterestFeature_getPrototypeOf(PointOfInterestFeature.prototype), "installApi", this).call(this);\n\n      Object.defineProperties(api, {\n        /**\n         * @memberof PointOfInterestFeature\n         * @instance\n         * @see core/PointOfInterestFeature#target\n         */\n        target: {\n          get: function get() {\n            return _this6.target;\n          },\n          set: function set(target) {\n            _this6.target = target;\n          }\n        }\n      });\n      Object.assign(api, {\n        /**\n         * @memberof PointOfInterestFeature\n         * @instance\n         * @method\n         * @see core/PointOfInterestFeature#registerLookLayer\n         */\n        registerLookLayer: this.registerLookLayer.bind(this),\n\n        /**\n         * @memberof PointOfInterestFeature\n         * @instance\n         * @method\n         * @see core/PointOfInterestFeature#registerBlinkLayer\n         */\n        registerBlinkLayer: this.registerBlinkLayer.bind(this),\n\n        /**\n         * @memberof PointOfInterestFeature\n         * @instance\n         * @method\n         * @see core/PointOfInterestFeature#setTarget\n         */\n        setTarget: this.setTarget.bind(this),\n\n        /**\n         * @memberof PointOfInterestFeature\n         * @instance\n         * @method\n         * @see core/PointOfInterestFeature#setTargetByName\n         */\n        setTargetByName: this.setTargetByName.bind(this),\n\n        /**\n         * @memberof PointOfInterestFeature\n         * @instance\n         * @method\n         * @see core/PointOfInterestFeature#setTargetById\n         */\n        setTargetById: this.setTargetById.bind(this)\n      });\n      return api;\n    }\n  }], [{\n    key: "_getWorldPosition",\n    value: function _getWorldPosition(obj) {\n      return [0, 0, 0];\n    }\n    /**\n     * Return a matrix representing the global transformation matrix of an object.\n     * Should be overloaded for each rendering engine implementation.\n     *\n     * @private\n     *\n     * @param {any} obj - Engine-specific 3D transform object.\n     *\n     * @returns {Array.<number>} - An array consisting of 16 numbers representing\n     * the 3d transformation.\n     */\n\n  }, {\n    key: "_getWorldMatrix",\n    value: function _getWorldMatrix(obj) {\n      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n    }\n    /**\n     * Rotate the given local direction vector by the object\'s world rotation matrix.\n     *\n     * @private\n     *\n     * @param {any} obj - Engine-specific 3D transform object.\n     * @param {Array.<number>} forwardVector - Unit vector representing the local\n     * forward direction of the object.\n     *\n     * @returns {Array.<number>}\n     */\n\n  }, {\n    key: "_getObjectDirection",\n    value: function _getObjectDirection(obj) {\n      var forwardVector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AxisMap.PositiveZ;\n      var rotation = core_MathUtils.getRotationMatrix(this._getWorldMatrix(obj));\n      return core_MathUtils.rotateVector(forwardVector, rotation);\n    }\n    /**\n     * Calculate horizontal and vertical look angles in degrees given spherical theta\n     * and phi angles in radians.\n     *\n     * @param {number} theta - Vertical/polar angle in radians where 0 points directly\n     * along positive Y axis.\n     * @param {number} phi - Horizontal/azimuthal angle in radians.\n     *\n     * @returns {Object} - An object with the signature {h: number, v: number} where\n     * h represents horizontal rotation in degrees and v represents vertical rotation\n     * in degrees.\n     */\n\n  }, {\n    key: "_sphericalToBlendValue",\n    value: function _sphericalToBlendValue(theta, phi) {\n      var h = core_MathUtils.toDegrees(phi); // Offset the vertical angle so 0 is pointing forward instead of up\n\n      var v = core_MathUtils.toDegrees(theta) - 90; // Convert vertical angle to -180, 180 range\n\n      return {\n        h: h,\n        v: v\n      };\n    }\n  }, {\n    key: "_validateTransformObject",\n    value: function _validateTransformObject(obj) {\n      return obj instanceof Object;\n    }\n  }]);\n\n  return PointOfInterestFeature;\n}(core_AbstractHostFeature.mix(awspack_SSMLSpeechmarkInterface.Mixin, animpack_ManagedAnimationLayerInterface.Mixin));\n\n/* harmony default export */ const core_PointOfInterestFeature = (PointOfInterestFeature);\n\n;// CONCATENATED MODULE: ./src/core/animpack/index.js\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\n * @module core/animpack\n */\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @namespace\n */\n\nvar Easing = {\n  /**\n   * @see Linear\n   */\n  Linear: Linear,\n\n  /**\n   * @see Quadratic\n   */\n  Quadratic: Quadratic,\n\n  /**\n   * @see Cubic\n   */\n  Cubic: Cubic,\n\n  /**\n   * @see Quartic\n   */\n  Quartic: Quartic,\n\n  /**\n   * @see Quintic\n   */\n  Quintic: Quintic,\n\n  /**\n   * @see Sinusoidal\n   */\n  Sinusoidal: Sinusoidal,\n\n  /**\n   * @see Exponential\n   */\n  Exponential: Exponential,\n\n  /**\n   * @see Circular\n   */\n  Circular: Circular,\n\n  /**\n   * @see Elastic\n   */\n  Elastic: Elastic,\n\n  /**\n   * @see Back\n   */\n  Back: Back,\n\n  /**\n   * @see Bounce\n   */\n  Bounce: Bounce\n};\n/* harmony default export */ const animpack = ({\n  /**\n   * @see core/AnimationFeature\n   */\n  AnimationFeature: animpack_AnimationFeature,\n\n  /**\n   * @see AnimationLayer\n   */\n  AnimationLayer: animpack_AnimationLayer,\n\n  /**\n   * @see core/SingleState\n   */\n  SingleState: state_SingleState,\n\n  /**\n   * @see TransitionState\n   */\n  TransitionState: state_TransitionState,\n\n  /**\n   * @see FreeBlendState\n   */\n  FreeBlendState: state_FreeBlendState,\n\n  /**\n   * @see QueueState\n   */\n  QueueState: state_QueueState,\n\n  /**\n   * @see RandomAnimationState\n   */\n  RandomAnimationState: state_RandomAnimationState,\n\n  /**\n   * @see Blend1dState\n   */\n  Blend1dState: state_Blend1dState,\n\n  /**\n   * @see Blend2dState\n   */\n  Blend2dState: state_Blend2dState,\n\n  /**\n   * @see AnimationUtils\n   */\n  AnimationUtils: animpack_AnimationUtils,\n  Easing: Easing,\n\n  /**\n   * @see LayerBlendModes\n   */\n  LayerBlendModes: LayerBlendModes,\n\n  /**\n   * @see DefaultLayerBlendMode\n   */\n  DefaultLayerBlendMode: DefaultLayerBlendMode,\n\n  /**\n   * @see AnimationTypes\n   */\n  AnimationTypes: AnimationTypes\n});\n;// CONCATENATED MODULE: ./src/core/awspack/TextToSpeechUtils.js\nfunction TextToSpeechUtils_toConsumableArray(arr) { return TextToSpeechUtils_arrayWithoutHoles(arr) || TextToSpeechUtils_iterableToArray(arr) || TextToSpeechUtils_unsupportedIterableToArray(arr) || TextToSpeechUtils_nonIterableSpread(); }\n\nfunction TextToSpeechUtils_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction TextToSpeechUtils_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction TextToSpeechUtils_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return TextToSpeechUtils_arrayLikeToArray(arr); }\n\nfunction TextToSpeechUtils_slicedToArray(arr, i) { return TextToSpeechUtils_arrayWithHoles(arr) || TextToSpeechUtils_iterableToArrayLimit(arr, i) || TextToSpeechUtils_unsupportedIterableToArray(arr, i) || TextToSpeechUtils_nonIterableRest(); }\n\nfunction TextToSpeechUtils_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction TextToSpeechUtils_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return TextToSpeechUtils_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return TextToSpeechUtils_arrayLikeToArray(o, minLen); }\n\nfunction TextToSpeechUtils_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction TextToSpeechUtils_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction TextToSpeechUtils_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction TextToSpeechUtils_typeof(obj) { "@babel/helpers - typeof"; return TextToSpeechUtils_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, TextToSpeechUtils_typeof(obj); }\n\nfunction TextToSpeechUtils_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction TextToSpeechUtils_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction TextToSpeechUtils_createClass(Constructor, protoProps, staticProps) { if (protoProps) TextToSpeechUtils_defineProperties(Constructor.prototype, protoProps); if (staticProps) TextToSpeechUtils_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\n * A collection of useful text-to-speech functions.\n *\n * @hideconstructor\n */\n\nvar TextToSpeechUtils = /*#__PURE__*/function () {\n  function TextToSpeechUtils() {\n    TextToSpeechUtils_classCallCheck(this, TextToSpeechUtils);\n  }\n\n  TextToSpeechUtils_createClass(TextToSpeechUtils, null, [{\n    key: "autoGenerateSSMLMarks",\n    value:\n    /**\n     * Returns a new string with SSML marks inserted based on\n     * matches between the input string and the input map. The\n     * word matches are case-insensitive. Words within existing\n     * SSML tags will not be affected. Input text will be surrounded\n     * by <speak></speak> tags if needed.\n     *\n     * @param {string} text - Input string.\n     * @param {object} map - Input object that maps mark keys\n     * to arrays of words. Example:\n     *\n     *  {\n     *    \'mark:sad\' : [\'sad\', \'blue\', \'down\'],\n     *    \'mark:happy\' : [\'joy\', \'glad\', \'great\'],\n     *    \'mark:no\' : [\'no\', \'nah\', \'nay\', \'sure\']\n     *  }\n     * @param {Array.<string>} [randomMarks = []] - If there are sentences that don\'t\n     * match any words from the map object, marks from this array will be randomly\n     * chosen and inserted.\n     *\n     * @returns {string} - Updated input string.\n     */\n    function autoGenerateSSMLMarks(text, map) {\n      var _this = this;\n\n      var randomMarks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n      if (TextToSpeechUtils_typeof(map) !== \'object\' || map === null) {\n        throw new Error("Cannot generate SSML marks for text \\"".concat(text, "\\" because map is not an object."));\n      } // process the input map into an internal format\n\n\n      var internalMap = this._processInputMap(map);\n\n      var speakTags = [\'<speak>\', \'</speak>\'];\n      var ssmlMarkRegex = /<mark name=(?:"|\')(.*?)(?:"|\')\\/>/;\n      var ssmlTagRegex = /<[^>]*>/g; // Identify any existing SSML tags\n\n      var existingTags = [];\n      var result = ssmlTagRegex.exec(text);\n\n      while (result !== null) {\n        existingTags.push({\n          start: result.index,\n          end: result.index + result[0].length,\n          text: result[0]\n        });\n        result = ssmlTagRegex.exec(text);\n      }\n\n      var chunks = [];\n      var index = 0;\n      var ssmlMarkResult;\n      var duplicateMarkToCheck = [];\n      existingTags.forEach(function (existingTag) {\n        var substr = text.slice(index, existingTag.start);\n\n        if (substr !== \'\') {\n          // auto-mark non-tag text\n          chunks.push(_this._insertMarks(substr, internalMap, duplicateMarkToCheck));\n          duplicateMarkToCheck = [];\n        }\n\n        ssmlMarkResult = ssmlMarkRegex.exec(existingTag.text);\n\n        if (ssmlMarkResult !== null) {\n          var markText = ssmlMarkResult[1];\n          duplicateMarkToCheck.push(markText);\n        } else if (!speakTags.includes(existingTag.text)) {\n          chunks.push(existingTag.text);\n        } // advance the index\n\n\n        index = existingTag.end;\n      });\n      chunks.push(this._insertMarks(text.slice(index), internalMap, duplicateMarkToCheck));\n      var markedText = chunks.join(\'\');\n\n      if (randomMarks && randomMarks.length > 0) {\n        // add random marks to any unmarked sentences\n        markedText = this.addMarksToUnmarkedSentences(markedText, randomMarks);\n      }\n\n      return TextToSpeechUtils.validateText(markedText);\n    }\n    /**\n     * Returns a new string with a random SSML mark inserted at each sentence that\n     * does not already contain an SSML mark.\n     *\n     * @param {string} text - Input string.\n     * @param {Array.<string>} marks - Any array of random SSML marks to choose from\n     * when modifying the text.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: "addMarksToUnmarkedSentences",\n    value: function addMarksToUnmarkedSentences(text, marks) {\n      if (!marks || marks.length === 0) return text;\n      var ssmlMarkRegex = /<mark name=(?:"|\')(.*?)(?:"|\')\\/>/g;\n      var ssmlTagRegex = /<[^>]*>/g; // Find the indices of any marks in the text\n\n      var markIndices = [];\n      var markResult = ssmlMarkRegex.exec(text);\n\n      while (markResult !== null) {\n        markIndices.push(markResult.index);\n        markResult = ssmlMarkRegex.exec(text);\n      } // Find all SSML tags in the text\n\n\n      var existingTags = [];\n      var ssmlResult = ssmlTagRegex.exec(text);\n\n      while (ssmlResult !== null) {\n        existingTags.push({\n          start: ssmlResult.index,\n          end: ssmlResult.index + ssmlResult[0].length,\n          text: ssmlResult[0]\n        });\n        ssmlResult = ssmlTagRegex.exec(text);\n      } // Create a copy of the text with all SSML marks replaces with whitespace\n\n\n      var cleanedText = text.slice();\n      existingTags.forEach(function (existingSsml) {\n        var whitespace = new Array(existingSsml.text.length + 1).join(\' \');\n        cleanedText = [cleanedText.slice(0, existingSsml.start), whitespace, cleanedText.slice(existingSsml.end)].join(\'\');\n      });\n\n      var sentenceEndIndices = this._getSentenceEnds(cleanedText); // Only insert random marks into sentences that don\'t already have any\n\n\n      var prevIndex = 0;\n      var targetIndices = sentenceEndIndices.filter(function (index) {\n        var containsMark = markIndices.findIndex(function (markIndex) {\n          return prevIndex <= markIndex && index > markIndex;\n        }) !== -1;\n        prevIndex = index;\n        return !containsMark;\n      });\n\n      var randomMarkedText = this._insertRandomMarksAt(text, targetIndices, marks);\n\n      return randomMarkedText;\n    }\n    /**\n     * Generate a version of given text that is enclosed by Polly ssml speak tags.\n     *\n     * @param {string} text - The text to validate.\n     *\n     * @returns {string} - Updated input string.\n     */\n\n  }, {\n    key: "validateText",\n    value: function validateText(text) {\n      if (!text) {\n        text = \'<speak></speak>\';\n      } else {\n        text = text.replace(/(^\\s*<\\s*speak\\s*)>\\s*|(^\\s*)/, \'<speak>\').replace(/(\\s*<\\s*\\/\\s*speak\\s*>\\s*$|\\s*$)/, \'</speak>\');\n      }\n\n      return text;\n    }\n    /**\n     * Parse an input string and insert SSML marks based on\n     * word matches in a map.\n     *\n     * @private\n     *\n     * @param {string} text - Input string.\n     * @param {Array.<number>} [indices = []] - An array of indices in the text input\n     * where random marks should be inserted.\n     * @param {Array.<string>} [marks = []] - An array of mark strings to choose\n     * from when inserting random marks.\n     *\n     * @returns {string} - Updated input string.\n     */\n\n  }, {\n    key: "_insertRandomMarksAt",\n    value: function _insertRandomMarksAt(text) {\n      var indices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var marks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n      if (!marks || marks.length === 0 || !indices || indices.length === 0) {\n        return text;\n      }\n\n      var offset = 0;\n      indices.forEach(function (index) {\n        var randomMark = "<mark name=\'".concat(marks[core_Utils.getRandomInt(0, marks.length)], "\'/>");\n        text = [text.slice(0, index + offset), randomMark, text.slice(index + offset)].join(\'\');\n        offset += randomMark.length;\n      });\n      return text;\n    }\n    /**\n     * Parses a string of text and returns an array containing the indices\n     * of the last character in a sentence that is not in the following list:\n     *  (\'.\', \'?\', \'!\')\n     *\n     * @private\n     *\n     * @param {string} text - Text to process for end of sentence\n     * indices.\n     *\n     * @returns {Array.<number>} - Array of end of sentence indices.\n     */\n\n  }, {\n    key: "_getSentenceEnds",\n    value: function _getSentenceEnds(text) {\n      var sentenceRegex = /[^.!?]+[.!?]+/g;\n      var endSentenceRegex = /[.!?]+/;\n      var result = sentenceRegex.exec(text);\n      var sentenceEnds = [];\n\n      while (result !== null) {\n        // find the last non-punctuation character\n        var punctResult = endSentenceRegex.exec(result[0]);\n        sentenceEnds.push(result.index + result[0].length - punctResult[0].length);\n        result = sentenceRegex.exec(text);\n      }\n\n      return sentenceEnds;\n    }\n    /**\n     * Parse an input string and insert SSML marks based on\n     * word matches in a map.\n     *\n     * @private\n     *\n     * @param {string} text - Input string.\n     * @param {Map} map - Mapping of words to mark values that\n     * will be inserted as the value for a mark\'s \'name\' attribute.\n     * @param {Array} duplicatesToCheck - A list of mark values to check for duplicate against the first word\n     *\n     * @returns {string} - Updated input string.\n     */\n\n  }, {\n    key: "_insertMarks",\n    value: function _insertMarks(text, map, duplicatesToCheck) {\n      if (text === \'\') return text;\n      var wordRegex = /\\w+|\\s+|[^\\s\\w]+/g;\n      var lowerCaseWord;\n      var checkDuplicate = true;\n      var markedWords = text.match(wordRegex).map(function (word) {\n        lowerCaseWord = word.toLowerCase();\n\n        if (map.has(lowerCaseWord)) {\n          var marks = map.get(lowerCaseWord).map(function (mark) {\n            if (checkDuplicate) {\n              checkDuplicate = false;\n              return duplicatesToCheck.includes(mark) ? \'\' : "<mark name=\'".concat(mark, "\'/>");\n            } else {\n              return "<mark name=\'".concat(mark, "\'/>");\n            }\n          });\n          return "".concat(marks.join(\'\')).concat(word);\n        } else {\n          checkDuplicate = false;\n          return word;\n        }\n      });\n      var existingMarks = duplicatesToCheck.map(function (mark) {\n        return "<mark name=\'".concat(mark, "\'/>");\n      });\n      return "".concat(existingMarks.join(\'\')).concat(markedWords.join(\'\'));\n    }\n    /**\n     * Processes an input object for mapping an array\n     * of words to specific mark keys. Converts the input\n     * map into a Map with a more efficient format for\n     * performing mark injection.\n     *\n     * @private\n     *\n     * @param {object} map - Input object that maps mark keys\n     * to arrays of words.\n     *\n     * @returns {Map} - Map for internal use.\n     */\n\n  }, {\n    key: "_processInputMap",\n    value: function _processInputMap(map) {\n      var internalMap = new Map();\n      var list = [];\n      Object.entries(map).forEach(function (_ref) {\n        var _ref2 = TextToSpeechUtils_slicedToArray(_ref, 2),\n            key = _ref2[0],\n            value = _ref2[1];\n\n        if (!Array.isArray(value)) {\n          throw new Error("Cannot generate SSML marks from map \\"".concat(map, "\\" because value for key \'").concat(key, "\' is not an array."));\n        }\n\n        value.forEach(function (word) {\n          var lowerCaseWord = word.toLowerCase();\n          list = internalMap.get(lowerCaseWord);\n\n          if (list !== undefined && !list.includes(key)) {\n            internalMap.set(lowerCaseWord, [].concat(TextToSpeechUtils_toConsumableArray(list), [key]));\n          } else {\n            internalMap.set(lowerCaseWord, [key]);\n          }\n        });\n      });\n      return internalMap;\n    }\n  }]);\n\n  return TextToSpeechUtils;\n}();\n\n/* harmony default export */ const awspack_TextToSpeechUtils = (TextToSpeechUtils);\n;// CONCATENATED MODULE: ./src/core/awspack/AbstractSpeech.js\nfunction AbstractSpeech_toConsumableArray(arr) { return AbstractSpeech_arrayWithoutHoles(arr) || AbstractSpeech_iterableToArray(arr) || AbstractSpeech_unsupportedIterableToArray(arr) || AbstractSpeech_nonIterableSpread(); }\n\nfunction AbstractSpeech_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction AbstractSpeech_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return AbstractSpeech_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return AbstractSpeech_arrayLikeToArray(o, minLen); }\n\nfunction AbstractSpeech_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction AbstractSpeech_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return AbstractSpeech_arrayLikeToArray(arr); }\n\nfunction AbstractSpeech_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction AbstractSpeech_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AbstractSpeech_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AbstractSpeech_createClass(Constructor, protoProps, staticProps) { if (protoProps) AbstractSpeech_defineProperties(Constructor.prototype, protoProps); if (staticProps) AbstractSpeech_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\n * Class that can play back audio generated by AWS Polly and synchronized emit\n * speechmark messages.\n *\n * @abstract\n */\n\nvar AbstractSpeech = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   *\n   * @param {core/TextToSpeechFeature} speaker - The feature that owns the Speech and\n   * will emit speechmark messages.\n   * @param {string} text - The text of the speech.\n   * @param {Array.<Object>} [speechmarks=[]] - An array of speechmark objects representing\n   * the text and timing of the speech.\n   */\n  function AbstractSpeech(speaker, text) {\n    var speechmarks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n    AbstractSpeech_classCallCheck(this, AbstractSpeech);\n\n    this._speaker = speaker;\n    this._text = text;\n    this._speechmarks = speechmarks;\n    this._speechmarkOffset = 0;\n\n    this._reset();\n  }\n  /**\n   * Reset tracking properties.\n   *\n   * @private\n   *\n   * @param {number} [currentTime=0] - Time to use for _startTime.\n   */\n\n\n  AbstractSpeech_createClass(AbstractSpeech, [{\n    key: "_reset",\n    value: function _reset() {\n      var currentTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      this._startTime = currentTime;\n      this._localTime = 0;\n      this._pauseTime = 0;\n      this._playing = false;\n      this._markIter = this._speechmarks.values();\n\n      var _this$_markIter$next = this._markIter.next(),\n          value = _this$_markIter$next.value,\n          done = _this$_markIter$next.done;\n\n      this._currentMark = value;\n      this._endTime = this._speechmarks.length ? this._speechmarks[this._speechmarks.length - 1].time : 0;\n      this._done = done;\n      this._promise = null;\n    }\n    /**\n     * Create a new promise that will stop playback and emit messages for this speech.\n     *\n     * @param {Function=} onFinish - Funciton to execute once the speech stops.\n     * @param {onError=} onError - Function to execute if the speech encounters an\n     * error.\n     * @param {Function=} onInterrupt - Function to execute if the speech is canceled.\n     *\n     * @returns {Deferred}\n     *\n     * @private\n     */\n\n  }, {\n    key: "_createPromise",\n    value: function _createPromise(onFinish, onError, onInterrupt) {\n      var _this = this;\n\n      var onResolve = function onResolve(value) {\n        _this._playing = false;\n\n        _this._speaker.emit(_this._speaker.constructor.EVENTS.stop, _this);\n\n        _this._speaker.constructor.emit(_this._speaker.constructor.EVENTS.stop, _this);\n\n        if (typeof onFinish === \'function\') {\n          onFinish(value);\n        }\n      };\n\n      var onReject = function onReject(e) {\n        _this._playing = false;\n\n        _this._speaker.emit(_this._speaker.constructor.EVENTS.stop, _this);\n\n        _this._speaker.constructor.emit(_this._speaker.constructor.EVENTS.stop, _this);\n\n        console.error("".concat(_this.constructor.name, " encountered an unexpected error: ").concat(e));\n\n        if (typeof onError === \'function\') {\n          onError(e);\n        }\n      };\n\n      var onCancel = function onCancel(value) {\n        _this._playing = false;\n\n        _this._speaker.emit(_this._speaker.constructor.EVENTS.interrupt, _this);\n\n        _this._speaker.constructor.emit(_this._speaker.constructor.EVENTS.interrupt, _this);\n\n        if (typeof onInterrupt === \'function\') {\n          onInterrupt(value);\n        }\n      };\n\n      this._promise = new core_Deferred(undefined, onResolve, onReject, onCancel);\n      return this._promise;\n    }\n    /**\n     * Return whether or not the speech has reached it\'s end.\n     *\n     * @private\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "_checkFinished",\n    value: function _checkFinished() {\n      return this._done && this._localTime >= this._endTime;\n    }\n    /**\n     * Gets the playback state of the audio.\n     *\n     * @readonly\n     * @type {boolean}\n     */\n\n  }, {\n    key: "playing",\n    get: function get() {\n      return this._playing;\n    }\n    /**\n     * Gets the text of the speech.\n     *\n     * @readonly\n     * @type {string}\n     */\n\n  }, {\n    key: "text",\n    get: function get() {\n      return this._text;\n    }\n    /**\n     * Gets a shallow copy of the speechmarks array for the speech.\n     *\n     * @readonly\n     * @type {Array.<Object>}\n     */\n\n  }, {\n    key: "speechmarks",\n    get: function get() {\n      return AbstractSpeech_toConsumableArray(this._speechmarks);\n    }\n    /**\n     * Gets and sets the number of seconds to offset speechmark emission.\n     * @type {number}\n     */\n\n  }, {\n    key: "speechmarkOffset",\n    get: function get() {\n      return this._speechmarkOffset / 1000;\n    },\n    set: function set(offset) {\n      this._speechmarkOffset = offset * 1000; // Store as milliseconds\n    }\n    /**\n     * Emit speechmark messages as they are encountered in sync with audio.\n     *\n     * @param {number} currentTime - Current global time when update was called.\n     */\n\n  }, {\n    key: "update",\n    value: function update(currentTime) {\n      if (!this._playing) {\n        return;\n      } // Update local audio time\n\n\n      this._localTime = currentTime - this._startTime;\n\n      if (!this._done) {\n        // Emit speechmark messages for marks up to the current time\n        while (!this._done && this._currentMark.time + this._speechmarkOffset <= this._localTime) {\n          this._speaker.emit(this._speaker.constructor.EVENTS[this._currentMark.type], {\n            speech: this,\n            mark: this._currentMark\n          });\n\n          var _this$_markIter$next2 = this._markIter.next(),\n              value = _this$_markIter$next2.value,\n              done = _this$_markIter$next2.done;\n\n          this._currentMark = value;\n          this._done = done;\n        }\n      } // End playback\n\n\n      if (this._checkFinished()) {\n        this.stop();\n\n        this._reset();\n      }\n    }\n    /**\n     * Play the speech from the beginning.\n     *\n     * @param {number} currentTime - Current global time when play was called.\n     * @param {Function=} onFinish - Optional function to execute once the speech\n     * promise resolves.\n     * @param {Function=} onError - Optional function to execute if the speech\n     * encounters and error during playback.\n     * @param {Function=} onInterrupt - Optional function to execute if the speech\n     * is canceled.\n     *\n     * @returns {Deferred} Resolves once the speech reaches the end of playback.\n     */\n\n  }, {\n    key: "play",\n    value: function play(currentTime, onFinish, onError, onInterrupt) {\n      this._reset(currentTime);\n\n      this._playing = true;\n\n      this._speaker.emit(this._speaker.constructor.EVENTS.play, this);\n\n      this._speaker.constructor.emit(this._speaker.constructor.EVENTS.play, this);\n\n      return this._createPromise(onFinish, onError, onInterrupt);\n    }\n    /**\n     * Pause the speech at the current time.\n     *\n     * @param {number} currentTime - Current global time when pause was called.\n     */\n\n  }, {\n    key: "pause",\n    value: function pause(currentTime) {\n      this._playing = false;\n      this._pauseTime = currentTime;\n\n      this._speaker.emit(this._speaker.constructor.EVENTS.pause, this);\n\n      this._speaker.constructor.emit(this._speaker.constructor.EVENTS.pause, this);\n    }\n    /**\n     * Resume the speech at the current time.\n     *\n     * @param {number} currentTime - Current global time when resume was called.\n     * @param {Function=} onFinish - Optional function to execute once the speech\n     * promise resolves.\n     * @param {Function=} onError - Optional function to execute if the speech\n     * encounters and error during playback.\n     * @param {Function=} onInterrupt - Optional function to execute if the speech\n     * is canceled.\n     *\n     * @returns {Deferred} Resolves once the speech reaches the end of playback.\n     */\n\n  }, {\n    key: "resume",\n    value: function resume(currentTime, onFinish, onError, onInterrupt) {\n      // Play from the beginning if the speech hasn\'t played yet\n      if (!this._promise) {\n        this._reset(currentTime);\n\n        this._createPromise(onFinish, onError, onInterrupt);\n      }\n\n      this._playing = true;\n      this._startTime += currentTime - this._pauseTime;\n\n      this._speaker.emit(this._speaker.constructor.EVENTS.resume, this);\n\n      this._speaker.constructor.emit(this._speaker.constructor.EVENTS.resume, this);\n\n      return this._promise;\n    }\n    /**\n     * Cancels playback of the speech at the current time. Cancel the speech promise.\n     */\n\n  }, {\n    key: "cancel",\n    value: function cancel() {\n      if (this._promise) {\n        this._promise.cancel();\n\n        this._promise = null;\n      }\n\n      this._playing = false;\n    }\n    /**\n     * Stop the speech and reset time to the beginning. Resolve the speech promise.\n     */\n\n  }, {\n    key: "stop",\n    value: function stop() {\n      if (this._promise) {\n        this._promise.resolve();\n\n        this._promise = null;\n      }\n\n      this._playing = false;\n    }\n  }]);\n\n  return AbstractSpeech;\n}();\n\n/* harmony default export */ const awspack_AbstractSpeech = (AbstractSpeech);\n;// CONCATENATED MODULE: ./src/core/awspack/Speech.js\nfunction Speech_typeof(obj) { "@babel/helpers - typeof"; return Speech_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, Speech_typeof(obj); }\n\nfunction Speech_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Speech_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Speech_createClass(Constructor, protoProps, staticProps) { if (protoProps) Speech_defineProperties(Constructor.prototype, protoProps); if (staticProps) Speech_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction Speech_get() { if (typeof Reflect !== "undefined" && Reflect.get) { Speech_get = Reflect.get; } else { Speech_get = function _get(target, property, receiver) { var base = Speech_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return Speech_get.apply(this, arguments); }\n\nfunction Speech_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Speech_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Speech_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) Speech_setPrototypeOf(subClass, superClass); }\n\nfunction Speech_setPrototypeOf(o, p) { Speech_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Speech_setPrototypeOf(o, p); }\n\nfunction Speech_createSuper(Derived) { var hasNativeReflectConstruct = Speech_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Speech_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Speech_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Speech_possibleConstructorReturn(this, result); }; }\n\nfunction Speech_possibleConstructorReturn(self, call) { if (call && (Speech_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return Speech_assertThisInitialized(self); }\n\nfunction Speech_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Speech_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction Speech_getPrototypeOf(o) { Speech_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Speech_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\n * The built-in class for asynchronous Promises.\n * @external Audio\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLAudioElement/Audio\n */\n\n/**\n * @extends AbstractSpeech\n * @alias core/Speech\n */\n\nvar Speech = /*#__PURE__*/function (_AbstractSpeech) {\n  Speech_inherits(Speech, _AbstractSpeech);\n\n  var _super = Speech_createSuper(Speech);\n\n  /**\n   * @constructor\n   *\n   * @param {TextToSpeech} speaker - The owner of the Speech that will emit speechmark\n   * messages.\n   * @param {string} text - The text of the speech.\n   * @param {Array.<Object>} [speechmarks=[]] - An array of speechmark objects representing\n   * the text and timing of the speech.\n   * @param {Object} audioConfig - Object containing audio and url.\n   * @param {external:Audio} audioConfig.audio - Playable audio object.\n   */\n  function Speech(speaker, text) {\n    var _this;\n\n    var speechmarks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var audioConfig = arguments.length > 3 ? arguments[3] : undefined;\n\n    Speech_classCallCheck(this, Speech);\n\n    _this = _super.call(this, speaker, text, speechmarks);\n    _this._audio = audioConfig.audio; // Keep track of whether the audio has finished playing through\n\n    _this._audio.onended = function () {\n      _this._audioFinished = true;\n    };\n\n    _this._audioFinished = true;\n    return _this;\n  }\n\n  Speech_createClass(Speech, [{\n    key: "_checkFinished",\n    value: function _checkFinished() {\n      return this._audioFinished && Speech_get(Speech_getPrototypeOf(Speech.prototype), "_checkFinished", this).call(this);\n    }\n    /**\n     * Gets the playable audio for the speech.\n     *\n     * @readonly\n     * @type {external:Audio}\n     */\n\n  }, {\n    key: "audio",\n    get: function get() {\n      return this._audio;\n    }\n    /**\n     * Gets the audio volume for the speech.\n     *\n     * @type {number}\n     */\n\n  }, {\n    key: "volume",\n    get: function get() {\n      return this._audio.volume;\n    }\n    /**\n     * Sets the audio volume for the speech.\n     */\n    ,\n    set: function set(volume) {\n      this._audio.volume = volume;\n    }\n    /**\n     * Set the audio\'s current local time and play it.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_playAudio",\n    value: function _playAudio() {\n      var _this2 = this;\n\n      if (this._speechmarkOffset < 0) {\n        this._audio.currentTime = this._speechmarkOffset;\n        setTimeout(function () {\n          if (_this2._playing) {\n            _this2._audio.currentTime = (_this2._localTime + _this2._speechmarkOffset) / 1000;\n\n            _this2._audio.play();\n          }\n        }, -this._speechmarkOffset);\n      } else {\n        this._audio.currentTime = 0;\n\n        this._audio.play();\n      }\n    }\n    /**\n     * Pause the audio once it is playable.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_pauseAudio",\n    value: function _pauseAudio() {\n      var _this3 = this;\n\n      this._audio.play().then(function () {\n        if (!_this3._playing) {\n          _this3._audio.pause();\n        }\n      });\n    }\n  }, {\n    key: "play",\n    value: function play(currentTime, onFinish, onError, onInterrupt) {\n      this._audioFinished = false;\n\n      this._playAudio();\n\n      return Speech_get(Speech_getPrototypeOf(Speech.prototype), "play", this).call(this, currentTime, onFinish, onError, onInterrupt);\n    }\n  }, {\n    key: "pause",\n    value: function pause(currentTime) {\n      this._pauseAudio();\n\n      Speech_get(Speech_getPrototypeOf(Speech.prototype), "pause", this).call(this, currentTime);\n    }\n  }, {\n    key: "resume",\n    value: function resume(currentTime, onFinish, onError, onInterrupt) {\n      this._audioFinished = false;\n\n      this._audio.play();\n\n      return Speech_get(Speech_getPrototypeOf(Speech.prototype), "resume", this).call(this, currentTime, onFinish, onError, onInterrupt);\n    }\n  }, {\n    key: "cancel",\n    value: function cancel() {\n      this._pauseAudio();\n\n      Speech_get(Speech_getPrototypeOf(Speech.prototype), "cancel", this).call(this);\n    }\n  }, {\n    key: "stop",\n    value: function stop() {\n      this._pauseAudio();\n\n      this._audio.currentTime = 0;\n\n      Speech_get(Speech_getPrototypeOf(Speech.prototype), "stop", this).call(this);\n    }\n  }]);\n\n  return Speech;\n}(awspack_AbstractSpeech);\n\n/* harmony default export */ const awspack_Speech = (Speech);\n;// CONCATENATED MODULE: ./src/core/awspack/AbstractTextToSpeechFeature.js\nfunction AbstractTextToSpeechFeature_typeof(obj) { "@babel/helpers - typeof"; return AbstractTextToSpeechFeature_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, AbstractTextToSpeechFeature_typeof(obj); }\n\nfunction AbstractTextToSpeechFeature_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction AbstractTextToSpeechFeature_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? AbstractTextToSpeechFeature_ownKeys(Object(source), !0).forEach(function (key) { AbstractTextToSpeechFeature_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : AbstractTextToSpeechFeature_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction AbstractTextToSpeechFeature_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction AbstractTextToSpeechFeature_slicedToArray(arr, i) { return AbstractTextToSpeechFeature_arrayWithHoles(arr) || AbstractTextToSpeechFeature_iterableToArrayLimit(arr, i) || AbstractTextToSpeechFeature_unsupportedIterableToArray(arr, i) || AbstractTextToSpeechFeature_nonIterableRest(); }\n\nfunction AbstractTextToSpeechFeature_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction AbstractTextToSpeechFeature_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction AbstractTextToSpeechFeature_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction AbstractTextToSpeechFeature_toConsumableArray(arr) { return AbstractTextToSpeechFeature_arrayWithoutHoles(arr) || AbstractTextToSpeechFeature_iterableToArray(arr) || AbstractTextToSpeechFeature_unsupportedIterableToArray(arr) || AbstractTextToSpeechFeature_nonIterableSpread(); }\n\nfunction AbstractTextToSpeechFeature_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction AbstractTextToSpeechFeature_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return AbstractTextToSpeechFeature_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return AbstractTextToSpeechFeature_arrayLikeToArray(o, minLen); }\n\nfunction AbstractTextToSpeechFeature_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction AbstractTextToSpeechFeature_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return AbstractTextToSpeechFeature_arrayLikeToArray(arr); }\n\nfunction AbstractTextToSpeechFeature_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction AbstractTextToSpeechFeature_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AbstractTextToSpeechFeature_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AbstractTextToSpeechFeature_createClass(Constructor, protoProps, staticProps) { if (protoProps) AbstractTextToSpeechFeature_defineProperties(Constructor.prototype, protoProps); if (staticProps) AbstractTextToSpeechFeature_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction AbstractTextToSpeechFeature_get() { if (typeof Reflect !== "undefined" && Reflect.get) { AbstractTextToSpeechFeature_get = Reflect.get; } else { AbstractTextToSpeechFeature_get = function _get(target, property, receiver) { var base = AbstractTextToSpeechFeature_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return AbstractTextToSpeechFeature_get.apply(this, arguments); }\n\nfunction AbstractTextToSpeechFeature_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = AbstractTextToSpeechFeature_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction AbstractTextToSpeechFeature_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) AbstractTextToSpeechFeature_setPrototypeOf(subClass, superClass); }\n\nfunction AbstractTextToSpeechFeature_setPrototypeOf(o, p) { AbstractTextToSpeechFeature_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return AbstractTextToSpeechFeature_setPrototypeOf(o, p); }\n\nfunction AbstractTextToSpeechFeature_createSuper(Derived) { var hasNativeReflectConstruct = AbstractTextToSpeechFeature_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = AbstractTextToSpeechFeature_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = AbstractTextToSpeechFeature_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return AbstractTextToSpeechFeature_possibleConstructorReturn(this, result); }; }\n\nfunction AbstractTextToSpeechFeature_possibleConstructorReturn(self, call) { if (call && (AbstractTextToSpeechFeature_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return AbstractTextToSpeechFeature_assertThisInitialized(self); }\n\nfunction AbstractTextToSpeechFeature_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction AbstractTextToSpeechFeature_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction AbstractTextToSpeechFeature_getPrototypeOf(o) { AbstractTextToSpeechFeature_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return AbstractTextToSpeechFeature_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n\n\n/**\n * The Amazon Polly service object.\n * @external Polly\n * @see https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/Polly.html\n */\n\n/**\n * The presigner object that can be used to generate presigned urls for the Polly service.\n * @external Presigner\n * @see https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/Polly/Presigner.html\n */\n// Available options for Polly\n\nvar engines = [\'standard\', \'neural\'];\nvar audioFormats = [\'mp3\', \'ogg_vorbis\', \'pcm\'];\nvar speechmarkTypes = [\'sentence\', \'ssml\', \'viseme\', \'word\'];\nvar sampleRates = {\n  mp3: {\n    rates: [\'8000\', \'16000\', \'22050\', \'24000\'],\n    defaults: {\n      standard: \'2050\',\n      neural: \'2400\'\n    }\n  },\n  pcm: {\n    rates: [\'8000\', \'16000\'],\n    defaults: {\n      standard: \'1600\',\n      neural: \'1600\'\n    }\n  }\n};\nsampleRates.ogg_vorbis = sampleRates.mp3;\nvar awsVersion;\n/**\n * Base class for turning text input into playable audio. There should be one instance\n * per speaker, each instance can play only one piece of text at a time.\n *\n * @extends AbstractHostFeature\n * @abstract\n *\n * @property {(number|undefined)} AWS_VERSION - Gets the version of AWS SDK being\n * used. Will be undefined until [initializeService]{@link AbstractTextToSpeechFeature.initializeService}\n * has been successfully executed.\n * @property {string} [POLLY_MIN_NEURAL_VERSION=\'2.503\'] - Gets the minimum version\n * of the AWS SDK that is necessary to use neural voices with AWS Polly.\n * @property {Object} POLLY_DEFAULTS - Default values to use with calls to {@link external:Polly}.\n * @property {string} [POLLY_DEFAULTS.Engine=\'standard\']\n * @property {Array.<string>} [POLLY_DEFAULTS.LexiconNames=[]]\n * @property {string} [POLLY_DEFAULTS.OutputFormat=\'mp3\']\n * @property {string} [POLLY_DEFAULTS.SampleRate=\'22050\']\n * @property {string} [POLLY_DEFAULTS.Text=\'\']\n * @property {string} [POLLY_DEFAULTS.TextType=\'ssml\']\n * @property {string} [POLLY_DEFAULTS.VoiceId=\'Amy\']\n * @property {string} [POLLY_DEFAULTS.LanguageCode=\'en-GB\']\n * @property {string} [POLLY_DEFAULTS.LanguageName=\'British English\']\n * @property {Array.<string>} [POLLY_VOICES=[]] - An array of voices available in\n * Polly. Will be empty until [initializeService]{@link AbstractTextToSpeechFeature.initializeService}\n * has been successfully executed. See [Polly Documentation]{@link https://docs.aws.amazon.com/polly/latest/dg/voicelist.html}\n * for a full list of available voices.\n * @property {Object} [POLLY_LANGUAGES={}] - An object that maps language names\n * to language codes that are available in Polly. Will be empty until\n * [initializeService]{@link AbstractTextToSpeechFeature.initializeService}\n * has been successfully executed. See [Polly Documentation]{@link https://docs.aws.amazon.com/polly/latest/dg/SupportedLanguage.html}\n * for a full list of available languages and corresponding codes.\n * @property {Object} [POLLY_LANGUAGE_CODES={}] - An object that maps language codes\n * to language names that are available in Polly. Will be empty until\n * [initializeService]{@link AbstractTextToSpeechFeature.initializeService}\n * has been successfully executed. See [Polly Documentation]{@link https://docs.aws.amazon.com/polly/latest/dg/SupportedLanguage.html}\n * for a full list of available languages and corresponding codes.\n * @property {Object} EVENTS - Built-in messages that the feature emits. When the\n * feature is added to a {@link core/HostObject}, event names will be prefixed by the\n * name of the feature class + \'.\'.\n * @property {string} [EVENTS.ready=onReadyEvent] - Message that is emitted after\n * [initializeService]{@link AbstractTextToSpeechFeature.initializeService} has been\n * successfully executed.\n * @property {string} [EVENTS.play=onPlayEvent] - Message that is emitted after\n * each call to [play]{@link AbstractTextToSpeechFeature#play}. The speech that was played\n * is supplied as an argument to listener functions.\n * @property {string} [EVENTS.pause=onPauseEvent] - Message that is emitted after\n * each call to [pause]{@link AbstractTextToSpeechFeature#pause}. The speech that was paused\n * is supplied as an argument to listener functions.\n * @property {string} [EVENTS.resume=onResumeEvent] - Message that is emitted after\n * each call to [resume]{@link AbstractTextToSpeechFeature#resume}. The speech that was\n * resumed is supplied as an argument to listener functions.\n * @property {string} [EVENTS.interrupt=onInterruptEvent] - Message that is emitted\n * if there is a current speech in progress and [play]{@link AbstractTextToSpeechFeature#play}\n * or [resume]{@link AbstractTextToSpeechFeature#resume} are executed for a new speech.\n * The speech that was interrupted is supplied as an argument to listener functions.\n * @property {string} [EVENTS.stop=onStopEvent] - Message that is emitted after\n * each call to [stop]{@link AbstractTextToSpeechFeature#stop} and when a speech reaches\n * the end of playback. The speech that was stopped is supplied as an argument\n * to listener functions.\n * @property {string} [EVENTS.sentence=onSentenceEvent] - Message that is emitted\n * each time a sentence speechmark is encountered whose timestamp matches up with\n * the speech audio\'s current time. The sentence speechmark object is supplied as\n * an argument to listener functions.\n * @property {string} [EVENTS.word=onWordEvent] - Message that is emitted\n * each time a word speechmark is encountered whose timestamp matches up with\n * the speech audio\'s current time. The word speechmark object is supplied as\n * an argument to listener functions.\n * @property {string} [EVENTS.viseme=onVisemeEvent] - Message that is emitted\n * each time a viseme speechmark is encountered whose timestamp matches up with\n * the speech audio\'s current time. The viseme speechmark object is supplied as\n * an argument to listener functions.\n * @property {string} [EVENTS.ssml=onSsmlEvent] - Message that is emitted\n * each time a ssml speechmark is encountered whose timestamp matches up with\n * the speech audio\'s current time. The ssml speechmark object is supplied as\n * an argument to listener functions.\n * @property {Object} SERVICES - AWS services that are necessary for the feature\n * to function.\n * @property {external:Polly} SERVICES.polly - The Polly service that is used\n * to synthesize speechmarks. Will be undefined until [initializeService]{@link AbstractTextToSpeechFeature.initializeService}\n * has been successfully executed\n * @property {external:Presigner} SERVICES.presigner - The Polly Presigner\n * object that is used to synthesize speech audio. Will be undefined until\n * [initializeService]{@link AbstractTextToSpeechFeature.initializeService}\n * has been successfully executed.\n */\n\nvar AbstractTextToSpeechFeature = /*#__PURE__*/function (_AbstractHostFeature) {\n  AbstractTextToSpeechFeature_inherits(AbstractTextToSpeechFeature, _AbstractHostFeature);\n\n  var _super = AbstractTextToSpeechFeature_createSuper(AbstractTextToSpeechFeature);\n\n  /**\n   * @constructor\n   *\n   * @param {core/HostObject} host - Host object managing the feature.\n   * @param {Object=} options - Options that will be sent to Polly for each speech.\n   * @param {string=} options.voice - The name of the Polly voice to use for all speech.\n   * @param {string=} options.engine - The name of the Polly engine to use for all speech.\n   * @param {string=} options.language - The name of the language to use for all speech.\n   * @param {audioFormat} [options.audioFormat=\'mp3\'] - The format to use for generated\n   * audio for all speeches.\n   * @param {string=} options.sampleRate - The sample rate for audio files for all\n   * speeches.\n   * @param {number} [options.speechmarkOffset=0] - Amount of time in seconds to\n   * offset speechmark event emission from the audio.\n   * @param {number} [options.minEndMarkDuration=.05] - The minimum amount of time\n   * in seconds that the last speechmark of each type in a speech can have its\n   * duration property set to.\n   * @param {number} [options.volume=1] - The default volume to play speech audio\n   * with.\n   * @param {boolean} [options.isGlobal=false] - Whether the audio source should default\n   * to global regardless of whether or not it is attached to an object.\n   */\n  function AbstractTextToSpeechFeature(host) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      voice: undefined,\n      engine: undefined,\n      language: undefined,\n      audioFormat: \'mp3\',\n      sampleRate: undefined,\n      speechmarkOffset: 0,\n      minEndMarkDuration: 0.05,\n      volume: 1,\n      isGlobal: false\n    };\n\n    AbstractTextToSpeechFeature_classCallCheck(this, AbstractTextToSpeechFeature);\n\n    _this = _super.call(this, host);\n    _this._speechCache = {};\n    _this._currentSpeech = null;\n    _this._currentPromise = null;\n    _this._isValidated = false;\n    _this.speechmarkOffset = Number.isNaN(Number(options.speechmarkOffset)) ? 0 : Number(options.speechmarkOffset);\n    _this.minEndMarkDuration = Number.isNaN(Number(options.minEndMarkDuration)) ? 0 : Number(options.minEndMarkDuration);\n    _this.volume = Number.isNaN(Number(options.volume)) ? 1 : Number(options.volume);\n    _this._isGlobal = options.isGlobal || false;\n    _this._promises = {\n      volume: core_Deferred.resolve()\n    };\n    _this._volumePaused = false; // Set default options for each speech\n\n    _this._voice = options.voice || _this.constructor.POLLY_DEFAULTS.VoiceId;\n    _this._language = options.language || _this.constructor.POLLY_DEFAULTS.LanguageName;\n    _this._engine = engines.includes(options.engine) ? options.engine : _this.constructor.POLLY_DEFAULTS.Engine;\n    _this._audioFormat = audioFormats.includes(options.audioFormat) ? options.audioFormat : _this.constructor.POLLY_DEFAULTS.OutputFormat;\n    _this._sampleRate = sampleRates[_this._audioFormat].rates.includes(options.sampleRate) ? options.sampleRate : _this.constructor.POLLY_DEFAULTS.SampleRate;\n    return _this;\n  }\n  /**\n   * Store Polly, Presigner and AWS SDK Version for use across all instances.\n   *\n   * @param {external:Polly} polly - Polly instance to use to generate speechmarks.\n   * @param {external:Presigner} presigner - Presigner instance to use to generate\n   * audio URLs.\n   * @param {string} version - Version of the AWS SDK to use to validate voice options.\n   */\n\n\n  AbstractTextToSpeechFeature_createClass(AbstractTextToSpeechFeature, [{\n    key: "currentSpeech",\n    get:\n    /**\n     * Gets the text of the currently playing speech.\n     *\n     * @readonly\n     * @type {string}\n     */\n    function get() {\n      if (this._currentSpeech) {\n        return this._currentSpeech.text;\n      } else {\n        return null;\n      }\n    }\n    /**\n     * Gets and sets the number of seconds to offset speechmark emission.\n     *\n     * @type {number}\n     */\n\n  }, {\n    key: "speechmarkOffset",\n    get: function get() {\n      return this._speechmarkOffset;\n    },\n    set: function set(offset) {\n      this._speechmarkOffset = offset;\n\n      if (this._currentSpeech) {\n        this._currentSpeech.speechmarkOffset = offset;\n      }\n    }\n    /**\n     * Gets and sets the The minimum amount of time in seconds that the last\n     * speechmark of each type in a speech can have its duration property set to.\n     *\n     * @type number\n     */\n\n  }, {\n    key: "minEndMarkDuration",\n    get: function get() {\n      return this._minEndMarkDuration / 1000;\n    },\n    set: function set(duration) {\n      this._minEndMarkDuration = duration * 1000;\n    }\n    /**\n     * Appends the Sumerian Hosts custom user-agent to a string if it is not\n     * already present.\n     *\n     * @private\n     *\n     * @param {string} currentUserAgent - String to append to if needed.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: "_validateEngine",\n    value:\n    /**\n     * Checks if a given engine type is compatible with the AWS SDK version. If it\n     * is, return the original value. Otherwise return a default.\n     *\n     * @private\n     *\n     * @param {string} engine - The type of Polly voice engine to validate.\n     *\n     * @returns {string}\n     */\n    function _validateEngine(engine) {\n      // Default to the standard engine if neural is not available for this version\n      if (engine === undefined || this.constructor.AWS_VERSION < this.constructor.POLLY_MIN_NEURAL_VERSION) {\n        engine = this.constructor.POLLY_DEFAULTS.Engine;\n      }\n\n      return engine;\n    }\n    /**\n     * Checks if a given audio format type is compatible with Polly. If it is, return\n     * the original value. Otherwise return a default.\n     *\n     * @private\n     *\n     * @param {string} engine - The type of Polly voice engine to validate.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: "_validateFormat",\n    value: function _validateFormat(format) {\n      if (format === undefined || !audioFormats.includes(format)) {\n        format = this.constructor.POLLY_DEFAULTS.OutputFormat;\n      }\n\n      return format;\n    }\n    /**\n     * Checks if a given audio sampling rate is compatible with the current audio\n     * format. If it is, return the original value. Otherwise return a default.\n     *\n     * @private\n     *\n     * @param {string} engine - The type of Polly voice engine to validate.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: "_validateRate",\n    value: function _validateRate(rate) {\n      // Use default if specified sample rate is not valid for the audio format\n      if (rate === undefined || !sampleRates[this._audioFormat].rates.includes(rate)) {\n        rate = sampleRates[this._audioFormat].defaults[this._engine];\n      }\n\n      return rate;\n    }\n    /**\n     * Checks if a given Polly voice id is compatible with the current Polly engine.\n     * If it is, return the original value. Otherwise return a default.\n     *\n     * @private\n     *\n     * @param {string} engine - The type of Polly voice engine to validate.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: "_validateVoice",\n    value: function _validateVoice(voiceId) {\n      var voice = this.constructor.POLLY_VOICES.find(function (v) {\n        return v.Id === voiceId;\n      }); // Use the default voice if the voice isn\'t supported by the engine\n\n      if (voice === undefined || !voice.SupportedEngines.includes(this._engine)) {\n        voiceId = this.constructor.POLLY_DEFAULTS.VoiceId;\n      }\n\n      return voiceId;\n    }\n    /**\n     * Checks if a given Polly language is compatible with the current Polly voice.\n     * If it is, return the original value. Otherwise return a default.\n     *\n     * @private\n     *\n     * @param {string} engine - The type of Polly voice engine to validate.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: "_validateLanguage",\n    value: function _validateLanguage(language) {\n      var _this2 = this;\n\n      var voice = this.constructor.POLLY_VOICES.find(function (v) {\n        return v.Id === _this2._voice;\n      });\n      var languageCode = this.constructor.POLLY_LANGUAGES[language]; // Find the languages available for the current voice\n\n      var availableCodes = [voice.LanguageCode];\n\n      if (voice.AdditionalLanguageCodes) {\n        availableCodes.push.apply(availableCodes, AbstractTextToSpeechFeature_toConsumableArray(voice.AdditionalLanguageCodes));\n      } // If the current voice doesn\'t support the language, use its default\n\n\n      if (!availableCodes.includes(languageCode)) {\n        language = this.constructor.POLLY_LANGUAGE_CODES[voice.LanguageCode];\n      }\n\n      return language;\n    }\n    /**\n     * Validate the current Polly options to make sure they are compatible with each\n     * other.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_validate",\n    value: function _validate() {\n      // Validate speech parameters\n      this._engine = this._validateEngine(this._engine);\n      this._audioFormat = this._validateFormat(this._audioFormat);\n      this._sampleRate = this._validateRate(this._sampleRate);\n      this._voice = this._validateVoice(this._voice);\n      this._language = this._validateLanguage(this._language);\n      this._isValidated = true;\n    }\n    /**\n     * Return an object containing parameters compatible with Polly.synthesizeSpeech.\n     *\n     * @private\n     *\n     * @returns {Object}\n     */\n\n  }, {\n    key: "_getConfig",\n    value: function _getConfig() {\n      // Make sure parameters have been validated\n      if (this.constructor.isReady && !this._isValidated) {\n        this._validate();\n      } // Create a config object compatible with Polly\n\n\n      return {\n        Engine: this._engine,\n        OutputFormat: this._audioFormat,\n        SampleRate: this._sampleRate,\n        VoiceId: this._voice,\n        LanguageCode: this.constructor.POLLY_LANGUAGES[this._language]\n      };\n    }\n    /**\n     * Update Polly parameters with options from a given config. All stored speeches\n     * will be updated to use the new parameters, unless the speech text is contained\n     * in the \'skipSpeeches\' parameter.\n     *\n     * @private\n     *\n     * @param {Object} config - Polly parameter options to overwrite.\n     * @param {Array.<string>} skipSpeeches - Text of any speeches that should not\n     * have parameters updated.\n     *\n     * @returns {Object}\n     */\n\n  }, {\n    key: "_updateConfig",\n    value: function _updateConfig(config) {\n      var _this3 = this;\n\n      var skipSpeeches = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n      var currentConfig = this._getConfig();\n\n      if (!config) {\n        return currentConfig;\n      }\n\n      this._isValidated = false;\n      var currentConfigStr = JSON.stringify(currentConfig); // Update options\n\n      if (config.Engine) {\n        this._engine = config.Engine;\n      }\n\n      if (config.audioFormat) {\n        this._audioFormat = config.audioFormat;\n      }\n\n      if (config.SampleRate) {\n        this._sampleRate = config.SampleRate;\n      }\n\n      if (config.VoiceId) {\n        this._voice = config.VoiceId;\n      }\n\n      if (config.Language) {\n        this._language = config.Language;\n      } // Validate the config\n\n\n      var validConfig = this._getConfig(); // Exit if nothing has changed\n\n\n      var configStr = JSON.stringify(validConfig);\n\n      if (currentConfigStr === configStr) {\n        this._isValidated = true;\n        return validConfig;\n      } // Update all cached configs\n\n\n      Object.entries(this._speechCache).forEach(function (_ref) {\n        var _ref2 = AbstractTextToSpeechFeature_slicedToArray(_ref, 2),\n            text = _ref2[0],\n            speech = _ref2[1];\n\n        // Check if this is a skipped speech\n        if (skipSpeeches.includes(text)) {\n          return;\n        }\n\n        var speechConfigStr = JSON.stringify(speech.config); // Update the speech with new parameters\n\n        if (speechConfigStr !== configStr) {\n          _this3._updateSpeech(text, validConfig);\n        }\n      });\n      return validConfig;\n    }\n    /**\n     * Update an existing speech, or add a new speech with new Polly parameters with\n     * options from a given config.\n     *\n     * @private\n     *\n     * @param {string} text - The text of the speech to update.\n     * @param {Object} config - Polly parameter options to update.\n     * @param {boolean} [force=false] - Whether to force the speech to be updated\n     * if no parameters have changes.\n     *\n     * @returns {AbstractSpeech}\n     */\n\n  }, {\n    key: "_updateSpeech",\n    value: function _updateSpeech(text, config) {\n      var _this4 = this;\n\n      var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var speech = this._speechCache[text] || {}; // Exit if nothing has changed and force is false\n\n      if (!force && config !== undefined && speech.config && JSON.stringify(config) === JSON.stringify(speech.config)) {\n        return speech;\n      } // Create separate parameters for audio and speechmark generation\n\n\n      var audioParams = AbstractTextToSpeechFeature_objectSpread(AbstractTextToSpeechFeature_objectSpread({}, config), {}, {\n        Text: text,\n        TextType: \'ssml\'\n      });\n\n      var speechmarkParams = AbstractTextToSpeechFeature_objectSpread(AbstractTextToSpeechFeature_objectSpread({}, audioParams), {}, {\n        OutputFormat: \'json\',\n        SpeechMarkTypes: speechmarkTypes\n      }); // Generate audio and speechmarks\n\n\n      speech.config = config;\n      speech.promise = Promise.all([this._synthesizeSpeechmarks(speechmarkParams), this._synthesizeAudio(audioParams)]).then(function (results) {\n        return _this4._createSpeech.apply(_this4, [text].concat(AbstractTextToSpeechFeature_toConsumableArray(results)));\n      });\n      this._speechCache[text] = speech;\n      return speech;\n    }\n    /**\n     * Create a new Speech object for the speaker.\n     *\n     * @private\n     *\n     * @param {TextToSpeech} speaker - The TextToSpeech instance that will own the speech.\n     * @param {string} text - Text of the speech.\n     * @param {Object} speechmarks - Speechmarks for the speech.\n     * @param {Object} audioConfig - Audio for the speech.\n     *\n     * @returns {AbstractSpeech}\n     */\n\n  }, {\n    key: "_createSpeech",\n    value: function _createSpeech(text, speechmarks, audioConfig) {\n      return new awspack_AbstractSpeech(this, text, speechmarks, audioConfig);\n    }\n    /**\n     * Create presigned URL of speech audio for the given speech text.\n     *\n     * @private\n     *\n     * @param {Object} params - Parameters object compatible with Polly.synthesizeSpeech.\n     *\n     * @returns {Deferred} Resolves with an object containing the audio URL.\n     */\n\n  }, {\n    key: "_synthesizeAudio",\n    value: function _synthesizeAudio(params) {\n      var _this5 = this;\n\n      return new core_Deferred(function (resolve, reject) {\n        _this5.constructor.SERVICES.presigner.getSynthesizeSpeechUrl(params, function (error, url) {\n          if (!error) {\n            resolve({\n              url: url\n            });\n          } else {\n            reject(error);\n          }\n        });\n      });\n    }\n    /**\n     * Retrieves and parses speechmarks for the given speech text.\n     *\n     * @private\n     *\n     * @param {Object} params - Parameters object compatible with Polly.synthesizeSpeech.\n     *\n     * @returns {Deferred} Resolves with an array of speechmark objects\n     */\n\n  }, {\n    key: "_synthesizeSpeechmarks",\n    value: function _synthesizeSpeechmarks(params) {\n      var _this6 = this;\n\n      return this.constructor.SERVICES.polly.synthesizeSpeech(params).promise().then(function (result) {\n        // Convert charcodes to string\n        var jsonString = JSON.stringify(result.AudioStream);\n        var json = JSON.parse(jsonString);\n        var dataStr = json.data.map(function (c) {\n          return String.fromCharCode(c);\n        }).join(\'\');\n        var markTypes = {\n          sentence: [],\n          word: [],\n          viseme: [],\n          ssml: []\n        };\n        var endMarkTypes = {\n          sentence: null,\n          word: null,\n          viseme: null,\n          ssml: null\n        }; // Split by enclosing {} to create speechmark objects\n\n        var speechMarks = AbstractTextToSpeechFeature_toConsumableArray(dataStr.matchAll(/\\{.*?\\}(?=\\n|$)/gm)).map(function (match) {\n          var mark = JSON.parse(match[0]); // Set the duration of the last speechmark stored matching this one\'s type\n\n          var numMarks = markTypes[mark.type].length;\n\n          if (numMarks > 0) {\n            var lastMark = markTypes[mark.type][numMarks - 1];\n            lastMark.duration = mark.time - lastMark.time;\n          }\n\n          markTypes[mark.type].push(mark);\n          endMarkTypes[mark.type] = mark;\n          return mark;\n        }); // Find the time of the latest speechmark\n\n\n        var endTimes = [];\n\n        if (endMarkTypes.sentence) {\n          endTimes.push(endMarkTypes.sentence.time);\n        }\n\n        if (endMarkTypes.word) {\n          endTimes.push(endMarkTypes.word.time);\n        }\n\n        if (endMarkTypes.viseme) {\n          endTimes.push(endMarkTypes.viseme.time);\n        }\n\n        if (endMarkTypes.ssml) {\n          endTimes.push(endMarkTypes.ssml.time);\n        }\n\n        var endTime = Math.max.apply(Math, endTimes); // Calculate duration for the ending speechMarks of each type\n\n        if (endMarkTypes.sentence) {\n          endMarkTypes.sentence.duration = Math.max(_this6._minEndMarkDuration, endTime - endMarkTypes.sentence.time);\n        }\n\n        if (endMarkTypes.word) {\n          endMarkTypes.word.duration = Math.max(_this6._minEndMarkDuration, endTime - endMarkTypes.word.time);\n        }\n\n        if (endMarkTypes.viseme) {\n          endMarkTypes.viseme.duration = Math.max(_this6._minEndMarkDuration, endTime - endMarkTypes.viseme.time);\n        }\n\n        if (endMarkTypes.ssml) {\n          endMarkTypes.ssml.duration = Math.max(_this6._minEndMarkDuration, endTime - endMarkTypes.ssml.time);\n        }\n\n        return speechMarks;\n      });\n    }\n    /**\n     * Returns a Speech object that has the given text.\n     *\n     * @private\n     *\n     * @param {string} text - The text content of the Speech.\n     * @param {Object=} config - Options to update the Speech with.\n     *\n     * @returns {Deferred} Resolves with Speech or null;\n     */\n\n  }, {\n    key: "_getSpeech",\n    value: function _getSpeech(text, config) {\n      // Make sure AWS services exist\n      if (!this.constructor.isReady) {\n        var e = \'AWS services have not been initialized.\';\n        return core_Deferred.reject(e);\n      } // Make sure its possible to generate speeches\n\n\n      if (!text) {\n        var _e2 = \'Cannot play a speech with no text.\';\n        return core_Deferred.reject(_e2);\n      } // Update the speech with options\n\n\n      text = awspack_TextToSpeechUtils.validateText(text);\n      config = this._updateConfig(config, text);\n      return this._updateSpeech(text, config).promise;\n    }\n    /**\n     * Adds a namespace to the host with the name of the feature to contain properties\n     * and methods from the feature that users of the host need access to.\n     *\n     * @see TextToSpeechFeature\n     */\n\n  }, {\n    key: "installApi",\n    value: function installApi() {\n      var _this7 = this;\n\n      /**\n       * @inner\n       * @namespace TextToSpeechFeature\n       */\n      var api = AbstractTextToSpeechFeature_get(AbstractTextToSpeechFeature_getPrototypeOf(AbstractTextToSpeechFeature.prototype), "installApi", this).call(this);\n\n      Object.assign(api, {\n        /**\n         * @memberof TextToSpeechFeature\n         * @instance\n         * @method\n         * @see AbstractTextToSpeechFeature#play\n         */\n        play: this.play.bind(this),\n\n        /**\n         * @memberof TextToSpeechFeature\n         * @instance\n         * @method\n         * @see AbstractTextToSpeechFeature#pause\n         */\n        pause: this.pause.bind(this),\n\n        /**\n         * @memberof TextToSpeechFeature\n         * @instance\n         * @method\n         * @see AbstractTextToSpeechFeature#resume\n         */\n        resume: this.resume.bind(this),\n\n        /**\n         * @memberof TextToSpeechFeature\n         * @instance\n         * @method\n         * @see AbstractTextToSpeechFeature#stop\n         */\n        stop: this.stop.bind(this),\n\n        /**\n         * @memberof TextToSpeechFeature\n         * @instance\n         * @method\n         * @see AbstractTextToSpeechFeature#getVolume\n         */\n        getVolume: this.getVolume.bind(this),\n\n        /**\n         * @memberof TextToSpeechFeature\n         * @instance\n         * @method\n         * @see AbstractTextToSpeechFeature#setVolume\n         */\n        setVolume: this.setVolume.bind(this),\n\n        /**\n         * @memberof TextToSpeechFeature\n         * @instance\n         * @method\n         * @see AbstractTextToSpeechFeature#pauseVolume\n         */\n        pauseVolume: this.pauseVolume.bind(this),\n\n        /**\n         * @memberof TextToSpeechFeature\n         * @instance\n         * @method\n         * @see AbstractTextToSpeechFeature#resumeVolume\n         */\n        resumeVolume: this.resumeVolume.bind(this)\n      });\n      Object.defineProperties(api, {\n        /**\n         * @memberof TextToSpeechFeature\n         * @instance\n         * @see AbstractTextToSpeechFeature#speechmarkOffset\n         */\n        speechmarkOffset: {\n          get: function get() {\n            return _this7.speechmarkOffset;\n          },\n          set: function set(offset) {\n            _this7.speechmarkOffset = offset;\n          }\n        }\n      });\n      return api;\n    }\n    /**\n     * Gets and sets the volume used for all audio clips played by the speaker.\n     *\n     * @type {number}\n     */\n\n  }, {\n    key: "volume",\n    get: function get() {\n      return this._volume;\n    }\n    /**\n     * Gets whether or not the speaker\'s volume value is currently being tweened.\n     *\n     * @readonly\n     * @type {boolean}\n     */\n    ,\n    set: function set(volume) {\n      this._volume = core_MathUtils.clamp(volume);\n    }\n  }, {\n    key: "volumePending",\n    get: function get() {\n      return this._promises.volume && this._promises.volume.pending;\n    }\n    /**\n     * Gets the volume used for all audio clips played by the speaker.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: "getVolume",\n    value: function getVolume() {\n      return this.volume;\n    }\n    /**\n     * Updates the volume used for all audio clips played by the speaker over time.\n     *\n     * @param {number} volume - Target volume value.\n     * @param {number} [seconds=0] - Amount of time it will take to reach the target\n     * volume.\n     * @param {Function=} easingFn - Easing function used for interpolation.\n     *\n     * @returns {Deferred}\n     */\n\n  }, {\n    key: "setVolume",\n    value: function setVolume(volume) {\n      var seconds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var easingFn = arguments.length > 2 ? arguments[2] : undefined;\n\n      if (this.volumePending) {\n        this._promises.volume.cancel();\n      }\n\n      volume = core_MathUtils.clamp(volume);\n      this._promises.volume = animpack_AnimationUtils.interpolateProperty(this, \'volume\', volume, {\n        seconds: seconds,\n        easingFn: easingFn\n      });\n      return this._promises.volume;\n    }\n    /**\n     * Pause interpolation happening on the speaker\'s volume property.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "pauseVolume",\n    value: function pauseVolume() {\n      this._volumePaused = true;\n      return this.volumePending;\n    }\n    /**\n     * Resume any interpolation happening on the speaker\'s volume property.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "resumeVolume",\n    value: function resumeVolume() {\n      this._volumePaused = false;\n      return this.volumePending;\n    }\n    /**\n     * Update the currently playing speech.\n     *\n     * @param {number} deltaTime - Time since the last update.\n     */\n\n  }, {\n    key: "update",\n    value: function update(deltaTime) {\n      if (!this._volumePaused) {\n        this._promises.volume.execute(deltaTime);\n      }\n\n      if (this._currentSpeech && this._currentSpeech.playing) {\n        this._currentSpeech.volume = this._volume;\n\n        this._currentSpeech.update(this._host.now);\n\n        AbstractTextToSpeechFeature_get(AbstractTextToSpeechFeature_getPrototypeOf(AbstractTextToSpeechFeature.prototype), "update", this).call(this, deltaTime);\n      }\n    }\n    /**\n     * Set the current speech to a new asset and update the speech\'s speechmark\n     * offset value to match that of the feature.\n     *\n     * @private\n     *\n     * @param {AbstractSpeech} speech - Speech to set as current.\n     */\n\n  }, {\n    key: "_setCurrentSpeech",\n    value: function _setCurrentSpeech(speech) {\n      speech.speechmarkOffset = this._speechmarkOffset;\n      this._currentSpeech = speech;\n    }\n    /**\n     * Create a promise that will play/resume a speech with the given text after\n     * the audio context attempts to resume and speech audio is retrieved from Polly.\n     *\n     * @private\n     *\n     * @param {string} text - The text of the new speech to play.\n     * @param {Object=} config - Optional parameters for the speech.\n     * @param {string} [playMethod = \'play\'] - Method to execute on the resulting\n     * Speech object. Valid options are \'play\' and \'resume\'.\n     */\n\n  }, {\n    key: "_startSpeech",\n    value: function _startSpeech(text, config) {\n      var _this8 = this;\n\n      var playMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \'play\';\n\n      // If no text is provided, try to use the current speech\n      if (text === undefined && playMethod === \'resume\' && this._currentSpeech) {\n        text = this._currentSpeech.text;\n      }\n\n      var currentPromise = this._currentPromise || {\n        play: new core_Deferred(undefined, function () {\n          currentPromise.speech.cancel();\n        }, function () {\n          currentPromise.speech.cancel();\n        }, function () {\n          currentPromise.speech.cancel();\n        }),\n        speech: new core_Deferred()\n      };\n      this._currentPromise = currentPromise;\n\n      this._getSpeech(text, config).then(function (speech) {\n        // Exit if the promise is no longer pending because of user interaction\n        if (!currentPromise.play.pending) {\n          return;\n        } else if (_this8._currentPromise !== currentPromise) {\n          // Cancel if another call to play has already been made\n          currentPromise.play.cancel();\n          return;\n        } // Reset current speech when the speech ends\n\n\n        var onFinish = function onFinish() {\n          _this8._currentSpeech = null;\n          _this8._currentPromise = null;\n        }; // Cancel the currently playing speech\n\n\n        if (_this8._currentSpeech && _this8._currentSpeech.playing) {\n          if (playMethod === \'play\') {\n            _this8._currentSpeech.cancel();\n          } else if (playMethod === \'resume\' && _this8._currentSpeech.audio !== speech.audio) {\n            _this8._currentSpeech.cancel();\n          }\n        }\n\n        _this8._setCurrentSpeech(speech); // Play the speech\n\n\n        currentPromise.speech = speech[playMethod](_this8._host.now, onFinish, onFinish, onFinish);\n        currentPromise.speech.then(function () {\n          if (currentPromise.speech.resolved) {\n            currentPromise.play.resolve();\n          } else {\n            currentPromise.play.cancel();\n          }\n        })["catch"](function (error) {\n          currentPromise.play.reject(error);\n        });\n      })["catch"](function (e) {\n        e = "Cannot ".concat(playMethod, " speech ").concat(text, " on host ").concat(_this8.host.id, ". ").concat(e);\n        currentPromise.play.reject(e);\n      });\n\n      return currentPromise.play;\n    }\n    /**\n     * Stop any speeches currently playing and play a new speech from the beginning.\n     *\n     * @param {string} text - The text of the new speech to play.\n     * @param {Object=} config - Optional parameters for the speech.\n     *\n     * @returns {Deferred}\n     */\n\n  }, {\n    key: "play",\n    value: function play(text, config) {\n      return this._startSpeech(text, config, \'play\');\n    }\n    /**\n     * If a speech is currently playing, pause it at the current time.\n     */\n\n  }, {\n    key: "pause",\n    value: function pause() {\n      if (this._currentSpeech && this._currentSpeech.playing) {\n        this._currentSpeech.pause(this._host.now);\n      } else {\n        console.warn("Cannot pause speech on host ".concat(this.host.id, ". No speech is currently playing"));\n      }\n    }\n    /**\n     * Stop any speeches currently playing and resume a new speech from the current\n     * time.\n     *\n     * @param {string=} text - The text of the new speech to play. If undefined and\n     * there is a current speech that is paused, the current speech will be resumed.\n     * @param {Object=} config - Optional parameters for the speech.\n     *\n     * @returns {Deferred}\n     */\n\n  }, {\n    key: "resume",\n    value: function resume(text, config) {\n      return this._startSpeech(text, config, \'resume\');\n    }\n    /**\n     * If a speech is currently playing, stop playback and reset time.\n     */\n\n  }, {\n    key: "stop",\n    value: function stop() {\n      if (this._currentSpeech && this._currentSpeech.playing) {\n        this._currentSpeech.stop();\n\n        this._currentSpeech = null;\n      } else {\n        console.warn("Cannot stop speech on host ".concat(this.host.id, ". No speech is currently playing."));\n      }\n    }\n  }, {\n    key: "discard",\n    value: function discard() {\n      if (this._currentSpeech && this._currentSpeech.playing) {\n        this._currentSpeech.stop();\n      }\n\n      delete this._speechCache;\n\n      AbstractTextToSpeechFeature_get(AbstractTextToSpeechFeature_getPrototypeOf(AbstractTextToSpeechFeature.prototype), "discard", this).call(this);\n    }\n  }], [{\n    key: "initializeService",\n    value: function initializeService(polly, presigner, version) {\n      var _this9 = this;\n\n      // Make sure all were defined\n      if (polly === undefined || presigner === undefined || version === undefined) {\n        throw new Error(\'Cannot initialize TextToSpeech feature. All arguments must be defined.\');\n      } // Add sumerian hosts user-agent\n\n\n      if (polly.config) {\n        polly.config.customUserAgent = this._withCustomUserAgent(polly.config.customUserAgent);\n      }\n\n      if (presigner.service && presigner.service.config) {\n        presigner.service.config.customUserAgent = this._withCustomUserAgent(presigner.service.config.customUserAgent);\n      }\n\n      this._isReady = false; // Store parameters\n\n      this.SERVICES.polly = polly;\n      this.SERVICES.presigner = presigner;\n      awsVersion = version; // Clear the current polly objects\n\n      var availableVoices = this.POLLY_VOICES;\n      availableVoices.length = 0;\n      var availableLanguages = this.POLLY_LANGUAGES;\n      Object.keys(availableLanguages).forEach(function (name) {\n        delete availableLanguages[name];\n      });\n      var availableLanguageCodes = this.POLLY_LANGUAGE_CODES;\n      Object.keys(availableLanguageCodes).forEach(function (name) {\n        delete availableLanguageCodes[name];\n      }); // Re-populate according to version\n\n      var minNeuralSdk = this.POLLY_MIN_NEURAL_VERSION;\n      return this.SERVICES.polly.describeVoices().promise().then(function (response) {\n        var allCodes = {};\n        response.Voices.forEach(function (voice) {\n          if (voice.SupportedEngines.includes(\'standard\') || version >= minNeuralSdk) {\n            availableVoices.push(voice);\n          }\n\n          availableVoices.forEach(function (voice) {\n            availableLanguages[voice.LanguageName] = voice.LanguageCode;\n            allCodes[voice.LanguageCode] = voice.LanguageName;\n          });\n        });\n        Object.entries(availableLanguages).forEach(function (_ref3) {\n          var _ref4 = AbstractTextToSpeechFeature_slicedToArray(_ref3, 2),\n              name = _ref4[0],\n              code = _ref4[1];\n\n          availableLanguageCodes[code] = name;\n        }); // Notify that we\'re ready to generate speeches\n\n        _this9._isReady = true;\n\n        _this9.emit(_this9.EVENTS.ready);\n      });\n    }\n    /**\n     * Indicates whether or not the class is capable of generating speech audio. Polly,\n     * Presigner and AWS SDK version number must have been defined using\n     * [initializeService]{@link AbstractTextToSpeechFeature.initializeService}.\n     *\n     * @readonly\n     * @type {boolean}\n     */\n\n  }, {\n    key: "isReady",\n    get: function get() {\n      return this._isReady;\n    }\n  }, {\n    key: "_withCustomUserAgent",\n    value: function _withCustomUserAgent(currentUserAgent) {\n      var sumerianHostsUserAgent = \'request-source/SumerianHosts\';\n\n      if (currentUserAgent == null) {\n        return sumerianHostsUserAgent;\n      }\n\n      if (currentUserAgent.indexOf(sumerianHostsUserAgent) !== -1) {\n        return currentUserAgent;\n      }\n\n      return currentUserAgent.concat(\' \', sumerianHostsUserAgent);\n    }\n  }]);\n\n  return AbstractTextToSpeechFeature;\n}(core_AbstractHostFeature);\n\nObject.defineProperties(AbstractTextToSpeechFeature, {\n  AWS_VERSION: {\n    get: function get() {\n      return awsVersion;\n    }\n  },\n  POLLY_MIN_NEURAL_VERSION: {\n    value: \'2.503\',\n    writable: false\n  },\n  POLLY_DEFAULTS: {\n    value: {\n      Engine: \'standard\',\n      LexiconNames: [],\n      OutputFormat: \'mp3\',\n      SampleRate: \'22050\',\n      Text: \'\',\n      TextType: \'ssml\',\n      VoiceId: \'Amy\',\n      LanguageCode: \'en-GB\',\n      LanguageName: \'British English\'\n    },\n    writable: false\n  },\n  POLLY_VOICES: {\n    value: [],\n    writable: false\n  },\n  POLLY_LANGUAGES: {\n    value: {},\n    writable: false\n  },\n  POLLY_LANGUAGE_CODES: {\n    value: {},\n    writable: false\n  },\n  _isReady: {\n    value: false,\n    writable: true\n  },\n  EVENTS: {\n    value: AbstractTextToSpeechFeature_objectSpread(AbstractTextToSpeechFeature_objectSpread({}, Object.getPrototypeOf(AbstractTextToSpeechFeature).EVENTS), {}, {\n      ready: \'onReadyEvent\',\n      play: \'onPlayEvent\',\n      pause: \'onPauseEvent\',\n      resume: \'onResumeEvent\',\n      interrupt: \'onInterruptEvent\',\n      stop: \'onStopEvent\',\n      sentence: \'onSentenceEvent\',\n      word: \'onWordEvent\',\n      viseme: \'onVisemeEvent\',\n      ssml: \'onSsmlEvent\'\n    })\n  },\n  SERVICES: {\n    value: AbstractTextToSpeechFeature_objectSpread(AbstractTextToSpeechFeature_objectSpread({}, Object.getPrototypeOf(AbstractTextToSpeechFeature).SERVICES), {}, {\n      polly: undefined,\n      presigner: undefined\n    })\n  }\n});\n/* harmony default export */ const awspack_AbstractTextToSpeechFeature = (AbstractTextToSpeechFeature);\n;// CONCATENATED MODULE: ./src/core/awspack/TextToSpeechFeature.js\nfunction TextToSpeechFeature_typeof(obj) { "@babel/helpers - typeof"; return TextToSpeechFeature_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, TextToSpeechFeature_typeof(obj); }\n\nfunction TextToSpeechFeature_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction TextToSpeechFeature_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction TextToSpeechFeature_createClass(Constructor, protoProps, staticProps) { if (protoProps) TextToSpeechFeature_defineProperties(Constructor.prototype, protoProps); if (staticProps) TextToSpeechFeature_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction TextToSpeechFeature_get() { if (typeof Reflect !== "undefined" && Reflect.get) { TextToSpeechFeature_get = Reflect.get; } else { TextToSpeechFeature_get = function _get(target, property, receiver) { var base = TextToSpeechFeature_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return TextToSpeechFeature_get.apply(this, arguments); }\n\nfunction TextToSpeechFeature_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = TextToSpeechFeature_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction TextToSpeechFeature_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) TextToSpeechFeature_setPrototypeOf(subClass, superClass); }\n\nfunction TextToSpeechFeature_setPrototypeOf(o, p) { TextToSpeechFeature_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return TextToSpeechFeature_setPrototypeOf(o, p); }\n\nfunction TextToSpeechFeature_createSuper(Derived) { var hasNativeReflectConstruct = TextToSpeechFeature_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = TextToSpeechFeature_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = TextToSpeechFeature_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return TextToSpeechFeature_possibleConstructorReturn(this, result); }; }\n\nfunction TextToSpeechFeature_possibleConstructorReturn(self, call) { if (call && (TextToSpeechFeature_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return TextToSpeechFeature_assertThisInitialized(self); }\n\nfunction TextToSpeechFeature_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction TextToSpeechFeature_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction TextToSpeechFeature_getPrototypeOf(o) { TextToSpeechFeature_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return TextToSpeechFeature_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n/**\n * @extends AbstractTextToSpeechFeature\n * @alias core/TextToSpeechFeature\n */\n\nvar TextToSpeechFeature = /*#__PURE__*/function (_AbstractTextToSpeech) {\n  TextToSpeechFeature_inherits(TextToSpeechFeature, _AbstractTextToSpeech);\n\n  var _super = TextToSpeechFeature_createSuper(TextToSpeechFeature);\n\n  function TextToSpeechFeature() {\n    var _this;\n\n    TextToSpeechFeature_classCallCheck(this, TextToSpeechFeature);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this._enabled = false;\n\n    _this._setAudioContext();\n\n    _this._observeAudioContext();\n\n    return _this;\n  }\n  /**\n   * Store the audio context that will be used to ensure audio can be played.\n   *\n   * @private\n   */\n\n\n  TextToSpeechFeature_createClass(TextToSpeechFeature, [{\n    key: "_setAudioContext",\n    value: function _setAudioContext() {\n      this._audioContext = new AudioContext();\n    }\n    /**\n     * Listen for state changes on the audio context to determine whether the feature\n     * is enabled.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_observeAudioContext",\n    value: function _observeAudioContext() {\n      var _this2 = this;\n\n      if (this._audioContext) {\n        this._audioContext.onstatechange = function () {\n          if (_this2._audioContext.state === \'running\') {\n            _this2._enabled = true;\n          } else {\n            _this2._enabled = false;\n            console.warn(\'The audio context is not running. Speech will not be able to be played until it is resumed. Use the "TextToSpeechFeature.resumeAudio" method to try to resume it after a user gesture.\');\n          }\n        };\n\n        this._audioContext.onstatechange();\n      }\n    }\n    /**\n     * Create an Audio object of speech audio for the given speech text.\n     *\n     * @private\n     *\n     * @param {Object} params - Parameters object compatible with Polly.synthesizeSpeech.\n     *\n     * @returns {Promise} Resolves with an object containing the audio URL and Audio\n     * object.\n     */\n\n  }, {\n    key: "_synthesizeAudio",\n    value: function _synthesizeAudio(params) {\n      var _this3 = this;\n\n      return TextToSpeechFeature_get(TextToSpeechFeature_getPrototypeOf(TextToSpeechFeature.prototype), "_synthesizeAudio", this).call(this, params).then(function (result) {\n        var url = result.url; // Create an Audio object that points to the presigned url\n\n        var audio = new Audio(url);\n        audio.loop = _this3.loop;\n        audio.crossOrigin = \'anonymous\';\n        audio.preload = \'auto\';\n        result.audio = audio;\n        return new Promise(function (resolve) {\n          // Resolve once the minimum amount is loaded\n          audio.addEventListener(\'canplaythrough\', function () {\n            resolve(result);\n          }); // Start loading the audio\n\n          document.body.appendChild(audio);\n          audio.load();\n        });\n      });\n    }\n    /**\n     * Create a new Speech object for the speaker.\n     *\n     * @private\n     *\n     * @param {TextToSpeech} speaker - The TextToSpeech instance that will own the speech.\n     * @param {string} text - Text of the speech.\n     * @param {Object} speechmarks - Speechmarks for the speech.\n     * @param {Object} audioConfig - Audio for the speech.\n     *\n     * @returns {AbstractSpeech}\n     */\n\n  }, {\n    key: "_createSpeech",\n    value: function _createSpeech(text, speechmarks, audioConfig) {\n      return new awspack_Speech(this, text, speechmarks, audioConfig);\n    }\n    /**\n     * Gets whether or not the audio context is running and speech can be played.\n     *\n     * @readonly\n     * @type {boolean}\n     */\n\n  }, {\n    key: "enabled",\n    get: function get() {\n      return this._enabled;\n    }\n    /**\n     * Try to resume the audio context. This will be automatically executed each time\n     * speech is played or resumed. If using manually, it should be called after a\n     * user interaction occurs.\n     *\n     * @returns {Deferred} - Resolves once the audio context has resumed.\n     */\n\n  }, {\n    key: "resumeAudio",\n    value: function resumeAudio() {\n      var _this4 = this;\n\n      var promise = new core_Deferred(function (resolve, reject) {\n        _this4._audioContext.resume().then(function () {\n          _this4._enabled = true;\n          resolve();\n        })["catch"](function (e) {\n          _this4._enabled = false;\n          reject(e);\n        });\n      });\n      return promise;\n    }\n  }, {\n    key: "_startSpeech",\n    value: function _startSpeech(text, config) {\n      var _this5 = this;\n\n      var playMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \'play\';\n      var currentPromise = {\n        play: new core_Deferred(undefined, function () {\n          currentPromise.speech.cancel();\n        }, function () {\n          currentPromise.speech.cancel();\n        }, function () {\n          currentPromise.speech.cancel();\n        }),\n        speech: new core_Deferred()\n      };\n      this._currentPromise = currentPromise; // Try to start the audio context\n\n      this.resumeAudio().then(function () {\n        // Exit if the promise is no longer pending because of user interaction\n        if (!currentPromise.play.pending) {\n          return;\n        } // Cancel if another call to play has already been made\n        else if (_this5._currentPromise !== currentPromise) {\n          currentPromise.play.cancel();\n          return;\n        } // The audio context is running so the speech can be played\n\n\n        if (_this5._enabled) {\n          TextToSpeechFeature_get(TextToSpeechFeature_getPrototypeOf(TextToSpeechFeature.prototype), "_startSpeech", _this5).call(_this5, text, config, playMethod);\n        } // Reject if the audio context is not running\n        else {\n          currentPromise.reject(new Error("Cannot ".concat(playMethod, " speech on host ").concat(_this5._host.id, ". The audio context is not running. Use the \\"TextToSpeechFeature.resumeAudio\\" method to try to resume it after a user gesture.")));\n        }\n      });\n      return currentPromise.play;\n    }\n  }, {\n    key: "play",\n    value: function play(text, config) {\n      return this._startSpeech(text, config, \'play\');\n    }\n  }, {\n    key: "resume",\n    value: function resume(text, config) {\n      return this._startSpeech(text, config, \'resume\');\n    }\n  }, {\n    key: "installApi",\n    value: function installApi() {\n      var _this6 = this;\n\n      var api = TextToSpeechFeature_get(TextToSpeechFeature_getPrototypeOf(TextToSpeechFeature.prototype), "installApi", this).call(this);\n\n      Object.defineProperties(api, {\n        /**\n         * @memberof TextToSpeechFeature\n         * @instance\n         * @see core/TextToSpeechFeature#enabled\n         */\n        enabled: {\n          get: function get() {\n            return _this6._enabled;\n          }\n        }\n      });\n      return api;\n    }\n  }]);\n\n  return TextToSpeechFeature;\n}(awspack_AbstractTextToSpeechFeature);\n\n/* harmony default export */ const awspack_TextToSpeechFeature = (TextToSpeechFeature);\n;// CONCATENATED MODULE: ./src/core/awspack/index.js\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n\n/**\n * @module core/awspack\n */\n\n/* harmony default export */ const awspack = ({\n  /**\n   * @see AbstractTextToSpeechFeature\n   */\n  AbstractTextToSpeechFeature: awspack_AbstractTextToSpeechFeature,\n\n  /**\n   * @see core/TextToSpeechFeature\n   */\n  TextToSpeechFeature: awspack_TextToSpeechFeature,\n\n  /**\n   * @see TextToSpeechUtils\n   */\n  TextToSpeechUtils: awspack_TextToSpeechUtils,\n\n  /**\n   * @see AbstractSpeech\n   */\n  AbstractSpeech: awspack_AbstractSpeech,\n\n  /**\n   * @see core/Speech\n   */\n  Speech: awspack_Speech\n});\n;// CONCATENATED MODULE: ./src/core/index.js\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\n * @module core/HOST\n */\n\n\n\n\n\n\n\n\n\n\n\nvar core_Easing = animpack.Easing,\n    core_AnimationFeature = animpack.AnimationFeature,\n    core_AnimationTypes = animpack.AnimationTypes,\n    core_AnimationLayer = animpack.AnimationLayer,\n    core_LayerBlendModes = animpack.LayerBlendModes,\n    core_DefaultLayerBlendMode = animpack.DefaultLayerBlendMode,\n    core_SingleState = animpack.SingleState,\n    core_TransitionState = animpack.TransitionState,\n    core_FreeBlendState = animpack.FreeBlendState,\n    core_QueueState = animpack.QueueState,\n    core_RandomAnimationState = animpack.RandomAnimationState,\n    core_Blend1dState = animpack.Blend1dState,\n    core_Blend2dState = animpack.Blend2dState,\n    core_AnimationUtils = animpack.AnimationUtils;\nvar core_AbstractTextToSpeechFeature = awspack.AbstractTextToSpeechFeature,\n    core_TextToSpeechFeature = awspack.TextToSpeechFeature,\n    core_TextToSpeechUtils = awspack.TextToSpeechUtils,\n    core_AbstractSpeech = awspack.AbstractSpeech,\n    core_Speech = awspack.Speech;\n/* harmony default export */ const core = ({\n  /**\n   * @see env\n   */\n  env: env,\n\n  /**\n   * @see Utils\n   */\n  Utils: core_Utils,\n\n  /**\n   * @see MathUtils\n   */\n  MathUtils: core_MathUtils,\n\n  /**\n   * @see Deferred\n   */\n  Deferred: core_Deferred,\n\n  /**\n   * @see core/Messenger\n   */\n  Messenger: core_Messenger,\n\n  /**\n   * @see core/HostObject\n   */\n  HostObject: core_HostObject,\n\n  /**\n   * @see core/LipsyncFeature\n   */\n  LipsyncFeature: core_LipsyncFeature,\n\n  /**\n   * @see core/GestureFeature\n   */\n  GestureFeature: core_GestureFeature,\n\n  /**\n   * @see core/PointOfInterestFeature\n   */\n  PointOfInterestFeature: core_PointOfInterestFeature,\n\n  /**\n   * @see DefaultVisemeMap\n   */\n  DefaultVisemeMap: DefaultVisemeMap,\n\n  /**\n   * @see DefaultGestureWords\n   */\n  DefaultGestureWords: DefaultGestureWords,\n\n  /**\n   * @see AxisMap\n   */\n  AxisMap: AxisMap,\n  // Amnimpack\n\n  /**\n   * @see module:core/animpack.Easing\n   */\n  Easing: core_Easing,\n\n  /**\n   * @see module:core/animpack.AnimationFeature\n   */\n  AnimationFeature: core_AnimationFeature,\n\n  /**\n   * @see module:core/animpack.AnimationLayer\n   */\n  AnimationLayer: core_AnimationLayer,\n\n  /**\n   * @see module:core/animpack.SingleState\n   */\n  SingleState: core_SingleState,\n\n  /**\n   * @see module:core/animpack.TransitionState\n   */\n  TransitionState: core_TransitionState,\n\n  /**\n   * @see module:core/animpack.FreeBlendState\n   */\n  FreeBlendState: core_FreeBlendState,\n\n  /**\n   * @see module:core/animpack.QueueState\n   */\n  QueueState: core_QueueState,\n\n  /**\n   * @see module:core/animpack.RandomAnimationState\n   */\n  RandomAnimationState: core_RandomAnimationState,\n\n  /**\n   * @see module:core/animpack.Blend1dState\n   */\n  Blend1dState: core_Blend1dState,\n\n  /**\n   * @see module:core/animpack.Blend2dState\n   */\n  Blend2dState: core_Blend2dState,\n\n  /**\n   * @see module:core/animpack.AnimationUtils\n   */\n  AnimationUtils: core_AnimationUtils,\n\n  /**\n   * @see module:core/animpack.LayerBlendModes\n   */\n  LayerBlendModes: core_LayerBlendModes,\n\n  /**\n   * @see module:core/animpack.DefaultLayerBlendMode\n   */\n  DefaultLayerBlendMode: core_DefaultLayerBlendMode,\n\n  /**\n   * @see module:core/animpack.AnimationTypes\n   */\n  AnimationTypes: core_AnimationTypes,\n  // AWS Pack\n\n  /**\n   * @see module:core/awspack.AbstractTextToSpeechFeature\n   */\n  AbstractTextToSpeechFeature: core_AbstractTextToSpeechFeature,\n\n  /**\n   * @see module:core/awspack.TextToSpeechFeature\n   */\n  TextToSpeechFeature: core_TextToSpeechFeature,\n\n  /**\n   * @see module:core/awspack.TextToSpeechUtils\n   */\n  TextToSpeechUtils: core_TextToSpeechUtils,\n\n  /**\n   * @see module:core/awspack.AbstractSpeech\n   */\n  AbstractSpeech: core_AbstractSpeech,\n\n  /**\n   * @see module:core/awspack.Speech\n   */\n  Speech: core_Speech\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ZSxFQUFmQSxvQkFsR2E7O0FBbUdiO0FBQ0Y7QUFDQTtBQUNFRyxFQUFBQSxxQkFBcUIsRUFBckJBLDBCQXRHYTs7QUF1R2I7QUFDRjtBQUNBO0FBQ0UwQixFQUFBQSxjQUFjLEVBQWRBLG1CQTFHYTtBQTRHYjs7QUFDQTtBQUNGO0FBQ0E7QUFDRTRRLEVBQUFBLDJCQUEyQixFQUEzQkEsZ0NBaEhhOztBQWlIYjtBQUNGO0FBQ0E7QUFDRTNpQixFQUFBQSxtQkFBbUIsRUFBbkJBLHdCQXBIYTs7QUFxSGI7QUFDRjtBQUNBO0FBQ0UwYyxFQUFBQSxpQkFBaUIsRUFBakJBLHNCQXhIYTs7QUF5SGI7QUFDRjtBQUNBO0FBQ0VxRCxFQUFBQSxjQUFjLEVBQWRBLG1CQTVIYTs7QUE2SGI7QUFDRjtBQUNBO0FBQ0VzQixFQUFBQSxNQUFNLEVBQU5BLFdBQU1BO0FBaElPLENBQWYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9IT1NULy4vc3JjL2NvcmUvRGVmZXJyZWQuanM/Njg4ZSIsIndlYnBhY2s6Ly9IT1NULy4vc3JjL2NvcmUvVXRpbHMuanM/YmYyNCIsIndlYnBhY2s6Ly9IT1NULy4vc3JjL2NvcmUvTWF0aFV0aWxzLmpzPzgxZTciLCJ3ZWJwYWNrOi8vSE9TVC8uL3NyYy9jb3JlL0hvc3RFbnZpcm9ubWVudC5qcz8xNTFkIiwid2VicGFjazovL0hPU1QvLi9zcmMvY29yZS9NZXNzZW5nZXIuanM/ZDAwNiIsIndlYnBhY2s6Ly9IT1NULy4vc3JjL2NvcmUvQWJzdHJhY3RIb3N0RmVhdHVyZS5qcz8yMzZlIiwid2VicGFjazovL0hPU1QvLi9zcmMvY29yZS9Ib3N0T2JqZWN0LmpzPzc1ZTciLCJ3ZWJwYWNrOi8vSE9TVC8uL3NyYy9jb3JlL2FuaW1wYWNrL0Vhc2luZy5qcz81ODZjIiwid2VicGFjazovL0hPU1QvLi9zcmMvY29yZS9GZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlLmpzPzA2YmIiLCJ3ZWJwYWNrOi8vSE9TVC8uL3NyYy9jb3JlL2FuaW1wYWNrL0FuaW1hdGlvbkZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UuanM/NmU2MyIsIndlYnBhY2s6Ly9IT1NULy4vc3JjL2NvcmUvYW5pbXBhY2svTWFuYWdlZEFuaW1hdGlvbkxheWVySW50ZXJmYWNlLmpzPzQ3ZDUiLCJ3ZWJwYWNrOi8vSE9TVC8uL3NyYy9jb3JlL2F3c3BhY2svVGV4dFRvU3BlZWNoRmVhdHVyZURlcGVuZGVudEludGVyZmFjZS5qcz9iY2FkIiwid2VicGFjazovL0hPU1QvLi9zcmMvY29yZS9MaXBzeW5jRmVhdHVyZS5qcz84ZDNhIiwid2VicGFjazovL0hPU1QvLi9zcmMvY29yZS9hd3NwYWNrL1NTTUxTcGVlY2htYXJrSW50ZXJmYWNlLmpzP2NhNzQiLCJ3ZWJwYWNrOi8vSE9TVC8uL3NyYy9jb3JlL0dlc3R1cmVGZWF0dXJlLmpzP2RiMzkiLCJ3ZWJwYWNrOi8vSE9TVC8uL3NyYy9jb3JlL2FuaW1wYWNrL0FuaW1hdGlvblV0aWxzLmpzPzExNDgiLCJ3ZWJwYWNrOi8vSE9TVC8uL3NyYy9jb3JlL2FuaW1wYWNrL3N0YXRlL0Fic3RyYWN0U3RhdGUuanM/MmY4NyIsIndlYnBhY2s6Ly9IT1NULy4vc3JjL2NvcmUvYW5pbXBhY2svc3RhdGUvVHJhbnNpdGlvblN0YXRlLmpzPzllNzciLCJ3ZWJwYWNrOi8vSE9TVC8uL3NyYy9jb3JlL2FuaW1wYWNrL0FuaW1hdGlvblBsYXllckludGVyZmFjZS5qcz83MzNlIiwid2VicGFjazovL0hPU1QvLi9zcmMvY29yZS9hbmltcGFjay9zdGF0ZS9TdGF0ZUNvbnRhaW5lckludGVyZmFjZS5qcz8yNjU5Iiwid2VicGFjazovL0hPU1QvLi9zcmMvY29yZS9hbmltcGFjay9zdGF0ZS9RdWV1ZVN0YXRlLmpzPzBjNGEiLCJ3ZWJwYWNrOi8vSE9TVC8uL3NyYy9jb3JlL2FuaW1wYWNrL3N0YXRlL0Fic3RyYWN0QmxlbmRTdGF0ZS5qcz82Njk3Iiwid2VicGFjazovL0hPU1QvLi9zcmMvY29yZS9hbmltcGFjay9zdGF0ZS9GcmVlQmxlbmRTdGF0ZS5qcz9kNjc1Iiwid2VicGFjazovL0hPU1QvLi9zcmMvY29yZS9hbmltcGFjay9zdGF0ZS9CbGVuZDFkU3RhdGUuanM/YTc0MiIsIndlYnBhY2s6Ly9IT1NULy4vc3JjL2NvcmUvYW5pbXBhY2svc3RhdGUvQmxlbmQyZFN0YXRlLmpzPzgxNjMiLCJ3ZWJwYWNrOi8vSE9TVC8uL3NyYy9jb3JlL2FuaW1wYWNrL0FuaW1hdGlvbkxheWVyLmpzP2JlZWMiLCJ3ZWJwYWNrOi8vSE9TVC8uL3NyYy9jb3JlL2FuaW1wYWNrL3N0YXRlL1NpbmdsZVN0YXRlLmpzPzRmMTQiLCJ3ZWJwYWNrOi8vSE9TVC8uL3NyYy9jb3JlL2FuaW1wYWNrL3N0YXRlL1JhbmRvbUFuaW1hdGlvblN0YXRlLmpzPzQ0OTMiLCJ3ZWJwYWNrOi8vSE9TVC8uL3NyYy9jb3JlL2FuaW1wYWNrL0FuaW1hdGlvbkZlYXR1cmUuanM/ZWJkZSIsIndlYnBhY2s6Ly9IT1NULy4vc3JjL2NvcmUvUG9pbnRPZkludGVyZXN0RmVhdHVyZS5qcz9kZWU1Iiwid2VicGFjazovL0hPU1QvLi9zcmMvY29yZS9hbmltcGFjay9pbmRleC5qcz85YTEyIiwid2VicGFjazovL0hPU1QvLi9zcmMvY29yZS9hd3NwYWNrL1RleHRUb1NwZWVjaFV0aWxzLmpzPzc1NWQiLCJ3ZWJwYWNrOi8vSE9TVC8uL3NyYy9jb3JlL2F3c3BhY2svQWJzdHJhY3RTcGVlY2guanM/N2YxYyIsIndlYnBhY2s6Ly9IT1NULy4vc3JjL2NvcmUvYXdzcGFjay9TcGVlY2guanM/MmE0MSIsIndlYnBhY2s6Ly9IT1NULy4vc3JjL2NvcmUvYXdzcGFjay9BYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUuanM/MzQxZiIsIndlYnBhY2s6Ly9IT1NULy4vc3JjL2NvcmUvYXdzcGFjay9UZXh0VG9TcGVlY2hGZWF0dXJlLmpzPzVhODUiLCJ3ZWJwYWNrOi8vSE9TVC8uL3NyYy9jb3JlL2F3c3BhY2svaW5kZXguanM/M2FlMCIsIndlYnBhY2s6Ly9IT1NULy4vc3JjL2NvcmUvaW5kZXguanM/YzdiMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxuXG4vKipcbiAqIFRoZSBidWlsdC1pbiBjbGFzcyBmb3IgYXN5bmNocm9ub3VzIFByb21pc2VzLlxuICogQGV4dGVybmFsIFByb21pc2VcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJvbWlzZVxuICovXG5cbi8qKlxuICogQSBQcm9taXNlIG9iamVjdCB0aGF0IGNhbiBiZSByZXNvbHZlZCwgcmVqZWN0ZWQgb3IgY2FuY2VsZWQgYXQgYW55IHRpbWUgYnkgdGhlXG4gKiB1c2VyLlxuICpcbiAqIEBleHRlbmRzIGV4dGVybmFsOlByb21pc2VcbiAqL1xuY2xhc3MgRGVmZXJyZWQgZXh0ZW5kcyBQcm9taXNlIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXhlY3V0YWJsZT0oKSA9PiB7fV0gLSBUaGUgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgYnkgdGhlXG4gICAqIGNvbnN0cnVjdG9yLCBkdXJpbmcgdGhlIHByb2Nlc3Mgb2YgY29uc3RydWN0aW5nIHRoZSBwcm9taXNlLiBUaGUgc2lnbmF0dXJlXG4gICAqIG9mIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmU6IGV4ZWN1dGFibGUoICByZXNvbHV0aW9uRnVuYywgcmVqZWN0aW9uRnVuYywgY2FuY2VsbGF0aW9uRnVuYyApLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25SZXNvbHZlIC0gT3B0aW9uYWwgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbmNlIHRoZSBwcm9taXNlXG4gICAqIGlzIHJlc29sdmVkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25SZWplY3QgLSBPcHRpb25hbCBmdW5jdGlvbiB0byBleGVjdXRlIG9uY2UgdGhlIHByb21pc2VcbiAgICogaXMgcmVqZWN0ZWQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkNhbmNlbCAtIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgaWYgdGhlIHVzZXIgY2FuY2Vsc1xuICAgKiB0aGUgcHJvbWlzZS4gQ2FuY2VsaW5nIHJlc3VsdHMgaW4gdGhlIHByb21pc2UgaGF2aW5nIGEgc3RhdHVzIG9mICdyZXNvbHZlZCcuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihleGVjdXRhYmxlID0gKCkgPT4ge30sIG9uUmVzb2x2ZSwgb25SZWplY3QsIG9uQ2FuY2VsKSB7XG4gICAgaWYgKHR5cGVvZiBleGVjdXRhYmxlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgY3JlYXRlIG5ldyBEZWZlcnJlZC4gRXhlY3V0YWJsZSBtdXN0IGJlIGEgZnVuY3Rpb24uYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9uUmVzb2x2ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG9uUmVzb2x2ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGNyZWF0ZSBuZXcgRGVmZXJyZWQuIE9uUmVzb2x2ZSBtdXN0IGJlIGEgZnVuY3Rpb24uYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9uUmVqZWN0ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygb25SZWplY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBjcmVhdGUgbmV3IERlZmVycmVkLiBPblJlamVjdCBtdXN0IGJlIGEgZnVuY3Rpb24uYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9uQ2FuY2VsICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygb25DYW5jZWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBjcmVhdGUgbmV3IERlZmVycmVkLiBPbkNhbmNlbCBtdXN0IGJlIGEgZnVuY3Rpb24uYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgcmVzO1xuICAgIGxldCByZWo7XG4gICAgbGV0IGNhbmNlbDtcbiAgICBjb25zdCBzdGF0dXMgPSB7XG4gICAgICByZXNvbHZlZDogZmFsc2UsXG4gICAgICByZWplY3RlZDogZmFsc2UsXG4gICAgICBjYW5jZWxlZDogZmFsc2UsXG4gICAgICBwZW5kaW5nOiB0cnVlLFxuICAgIH07XG5cbiAgICBzdXBlcigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAvLyBTdG9yZSB0aGUgcmVzb2x2ZXJcbiAgICAgIHJlcyA9IHZhbHVlID0+IHtcbiAgICAgICAgaWYgKHN0YXR1cy5wZW5kaW5nKSB7XG4gICAgICAgICAgc3RhdHVzLnJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICBzdGF0dXMucGVuZGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBvblJlc29sdmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gb25SZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIFN0b3JlIHRoZSByZWplY3RlclxuICAgICAgcmVqID0gdmFsdWUgPT4ge1xuICAgICAgICBpZiAoc3RhdHVzLnBlbmRpbmcpIHtcbiAgICAgICAgICBzdGF0dXMucmVqZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIHN0YXR1cy5wZW5kaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIG9uUmVqZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG9uUmVqZWN0KHZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmVqZWN0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gU3RvcmUgdGhlIGNhbmNlbGVyXG4gICAgICBjYW5jZWwgPSB2YWx1ZSA9PiB7XG4gICAgICAgIGlmIChzdGF0dXMucGVuZGluZykge1xuICAgICAgICAgIHN0YXR1cy5jYW5jZWxlZCA9IHRydWU7XG4gICAgICAgICAgc3RhdHVzLnBlbmRpbmcgPSBmYWxzZTtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygb25DYW5jZWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gb25DYW5jZWwodmFsdWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gUnVuIHRoZSBleGVjdXRhYmxlIHdpdGggY3VzdG9tIHJlc29sdmVyIGFuZCByZWplY3RlclxuICAgICAgZXhlY3V0YWJsZShyZXMsIHJlaiwgY2FuY2VsKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3N0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLl9yZXNvbHZlID0gcmVzO1xuICAgIHRoaXMuX3JlamVjdCA9IHJlajtcbiAgICB0aGlzLl9jYW5jZWwgPSBjYW5jZWw7XG4gICAgdGhpcy5fZXhlY3V0YWJsZSA9IGV4ZWN1dGFibGU7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgcmVzb2x2ZWQgc3RhdGUgb2YgdGhlIHByb21pc2UuXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHJlc29sdmVkKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0dXMucmVzb2x2ZWQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgcmVqZWN0ZWQgc3RhdGUgb2YgdGhlIHByb21pc2UuXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHJlamVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0dXMucmVqZWN0ZWQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY2FuY2VsZWQgc3RhdGUgb2YgdGhlIHByb21pc2UuXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGNhbmNlbGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0dXMuY2FuY2VsZWQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgcGVuZGluZyBzdGF0ZSBvZiB0aGUgcHJvbWlzZS5cbiAgICpcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcGVuZGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdHVzLnBlbmRpbmc7XG4gIH1cblxuICAvKipcbiAgICogRm9yY2UgdGhlIHByb21pc2UgdG8gcmVzb2x2ZS5cbiAgICpcbiAgICogQHBhcmFtIHthbnk9fSB2YWx1ZSAtIFZhbHVlIHRvIHBhc3MgdG8gdGhlIHJlc29sdmVyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7YW55fSAtIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHJlc29sdmVyIGZ1bmN0aW9uLlxuICAgKi9cbiAgcmVzb2x2ZSh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjZSB0aGUgcHJvbWlzZSB0byByZWplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7YW55PX0gdmFsdWUgLSBWYWx1ZSB0byBwYXNzIHRvIHRoZSByZWplY3Rlci5cbiAgICpcbiAgICogQHJldHVybnMge2FueX0gLSBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSByZWplY3RlciBmdW5jdGlvbi5cbiAgICovXG4gIHJlamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9yZWplY3QodmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNlIHRoZSBwcm9taXNlIHRvIHJlc29sdmUgYW5kIHNldCB0aGUgY2FuY2VsZWQgc3RhdGUgdG8gdHJ1ZS5cbiAgICpcbiAgICogQHBhcmFtIHthbnk9fSB2YWx1ZSAtIFZhbHVlIHRvIHBhc3MgdG8gdGhlIGNhbmNlbGxlci5cbiAgICpcbiAgICogQHJldHVybnMge2FueX0gLSBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBjYW5jZWxsZXIgZnVuY3Rpb24uXG4gICAqL1xuICBjYW5jZWwodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FuY2VsKHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gdGhlIHByb21pc2UgZnVuY3Rpb24gdG8gdHJ5IHRvIHJlc29sdmUgdGhlIHByb21pc2UuIFByb21pc2UgbXVzdCBiZVxuICAgKiBwZW5kaW5nLlxuICAgKlxuICAgKiBAcGFyYW0gey4uLmFueX0gYXJncyAtIE9wdGlvbmFsIGFyZ3VtZW50cyB0byBwYXNzIGFmdGVyIHJlc29sdmUgYW5kIHJlamVjdC5cbiAgICovXG4gIGV4ZWN1dGUoLi4uYXJncykge1xuICAgIGlmICh0aGlzLnBlbmRpbmcpIHtcbiAgICAgIHRoaXMuX2V4ZWN1dGFibGUodGhpcy5fcmVzb2x2ZSwgdGhpcy5fcmVqZWN0LCB0aGlzLl9jYW5jZWwsIC4uLmFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBjYW5jZWxlZCBkZWZlcnJlZCBwcm9taXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge2FueT19IHZhbHVlIC0gVmFsdWUgdG8gY2FuY2VsIHRoZSBwcm9taXNlIHdpdGguXG4gICAqXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH1cbiAgICovXG4gIHN0YXRpYyBjYW5jZWwodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IERlZmVycmVkKChfcmVzb2x2ZSwgX3JlamVjdCwgY2FuY2VsKSA9PiB7XG4gICAgICBjYW5jZWwodmFsdWUpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIG5ldyBEZWZlcnJlZCBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIG9yIHJlamVjdCBvbmNlIGFsbCBwcm9taXNlc1xuICAgKiBpbiB0aGUgaW5wdXQgYXJyYXkgaGF2ZSBiZWVuIHJlc29sdmVkIG9yIG9uZSBwcm9taXNlIGlzIGNhbmNlbGVkIG9yIHJlamVjdGVkLlxuICAgKiBQcm9taXNlcyBpbiB0aGUgYXJyYXkgdGhhdCBhcmUgRGVmZXJyZWQgcHJvbWlzZXMgd2lsbCBiZSBtYW51YWxseSByZXNvbHZlZCxcbiAgICogcmVqZWN0ZWQgb3IgY2FuY2VsZWQgd2hlbiBjYWxsaW5nIHJlc29sdmUsIHJlamVjdCBvciBjYW5jZWwgb24gdGhlIHJldHVybiBwcm9taXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5Ljxhbnk+fSBpdGVyYWJsZSAtIEFuIGl0ZXJhYmxlIHN1Y2ggYXMgYW4gYXJyYXkuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvblJlc29sdmUgLSBPcHRpb25hbCBmdW5jdGlvbiB0byBleGVjdXRlIG9uY2UgdGhlIHByb21pc2VcbiAgICogaXMgcmVzb2x2ZWQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvblJlamVjdCAtIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb25jZSB0aGUgcHJvbWlzZVxuICAgKiBpcyByZWplY3RlZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uQ2FuY2VsIC0gT3B0aW9uYWwgZnVuY3Rpb24gdG8gZXhlY3V0ZSBpZiB0aGUgdXNlciBjYW5jZWxzXG4gICAqIHRoZSBwcm9taXNlLiBDYW5jZWxpbmcgcmVzdWx0cyBpbiB0aGUgcHJvbWlzZSBoYXZpbmcgYSBzdGF0dXMgb2YgJ2NhbmNlbGVkJy5cbiAgICpcbiAgICogQHJldHVybnMgRGVmZXJyZWRcbiAgICovXG4gIHN0YXRpYyBhbGwoaXRlcmFibGUsIG9uUmVzb2x2ZSwgb25SZWplY3QsIG9uQ2FuY2VsKSB7XG4gICAgaWYgKGl0ZXJhYmxlID09IG51bGwgfHwgdHlwZW9mIGl0ZXJhYmxlW1N5bWJvbC5pdGVyYXRvcl0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGxldCBlID0gYENhbm5vdCBleGVjdXRlIERlZmVycmVkLmFsbC4gRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBpdGVyYWJsZS5gO1xuXG4gICAgICBpZiAodHlwZW9mIG9uUmVqZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGUgPSBvblJlamVjdChlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIERlZmVycmVkLnJlamVjdChlKTtcbiAgICB9XG5cbiAgICBjb25zdCBhcnJheSA9IFsuLi5pdGVyYWJsZV07XG4gICAgY29uc3QgZGVmZXJyZWQgPSBhcnJheS5maWx0ZXIoaXRlbSA9PiBpdGVtIGluc3RhbmNlb2YgRGVmZXJyZWQpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IERlZmVycmVkKFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgcmVzb2x2ZVZhbHVlID0+IHtcbiAgICAgICAgZGVmZXJyZWQuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICBpdGVtLnJlc29sdmUocmVzb2x2ZVZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZmVycmVkLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvblJlc29sdmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gb25SZXNvbHZlKHJlc29sdmVWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmVWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGVycm9yID0+IHtcbiAgICAgICAgZGVmZXJyZWQuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICBpdGVtLnJlamVjdChlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWZlcnJlZC5sZW5ndGggPSAwO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb25SZWplY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gb25SZWplY3QoZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbmNlbFZhbHVlID0+IHtcbiAgICAgICAgZGVmZXJyZWQuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICBpdGVtLmNhbmNlbChjYW5jZWxWYWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWZlcnJlZC5sZW5ndGggPSAwO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb25DYW5jZWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gb25DYW5jZWwoY2FuY2VsVmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBjYW5jZWxWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG5cbiAgICBjb25zdCBudW1JdGVtcyA9IGFycmF5Lmxlbmd0aDtcbiAgICBjb25zdCBpdGVtVHJhY2tlciA9IHtcbiAgICAgIGZhaWxlZDogZmFsc2UsXG4gICAgICBudW1SZXNvbHZlZDogMCxcbiAgICAgIHJlc29sdXRpb25zOiBbXSxcbiAgICB9O1xuXG4gICAgYXJyYXkuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChpdGVtVHJhY2tlci5mYWlsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgICBpdGVtVHJhY2tlci5yZXNvbHV0aW9uc1tpbmRleF0gPSBpdGVtO1xuICAgICAgICBpdGVtVHJhY2tlci5udW1SZXNvbHZlZCArPSAxO1xuXG4gICAgICAgIGlmIChpdGVtVHJhY2tlci5udW1SZXNvbHZlZCA9PT0gbnVtSXRlbXMpIHtcbiAgICAgICAgICByZXN1bHQucmVzb2x2ZShpdGVtVHJhY2tlci5yZXNvbHV0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpdGVtLnRoZW4oXG4gICAgICAgIHZhbHVlID0+IHtcbiAgICAgICAgICBpZiAoIWl0ZW1UcmFja2VyLmZhaWxlZCAmJiAhaXRlbS5jYW5jZWxlZCkge1xuICAgICAgICAgICAgaXRlbVRyYWNrZXIucmVzb2x1dGlvbnNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICBpdGVtVHJhY2tlci5udW1SZXNvbHZlZCArPSAxO1xuXG4gICAgICAgICAgICBpZiAoaXRlbVRyYWNrZXIubnVtUmVzb2x2ZWQgPT09IG51bUl0ZW1zKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5yZXNvbHZlKGl0ZW1UcmFja2VyLnJlc29sdXRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKCFpdGVtVHJhY2tlci5mYWlsZWQpIHtcbiAgICAgICAgICAgIGl0ZW1UcmFja2VyLmZhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICByZXN1bHQuY2FuY2VsKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yID0+IHtcbiAgICAgICAgICBpZiAoIWl0ZW1UcmFja2VyLmZhaWxlZCkge1xuICAgICAgICAgICAgaXRlbVRyYWNrZXIuZmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc3VsdC5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGVmZXJyZWQ7XG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxuaW1wb3J0IERlZmVycmVkIGZyb20gJ2NvcmUvRGVmZXJyZWQnO1xuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiB1c2VmdWwgZ2VuZXJpYyBmdW5jdGlvbnMuXG4gKlxuICogQGhpZGVjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBVdGlscyB7XG4gIC8qKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEdlbmVyYXRlIGEgdW5pcXVlIGlkXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlSWQoKSB7XG4gICAgcmV0dXJuICd4eHh4eHh4eHh4eHg0eHh4eXh4eHh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBjID0+IHtcbiAgICAgIGNvbnN0IHJhbmRvbU51bWJlciA9IE1hdGguZmxvb3IoKERhdGUubm93KCkgKyBNYXRoLnJhbmRvbSgpICogMTYpICUgMTYpO1xuICAgICAgaWYgKGMgPT09ICd4Jykge1xuICAgICAgICByZXR1cm4gcmFuZG9tTnVtYmVyLnRvU3RyaW5nKDE2KTtcbiAgICAgIH1cbiAgICAgIC8vIFNldCBiaXQgNiBhbmQgNyB0byAwIGFuZCAxXG4gICAgICByZXR1cm4gKChyYW5kb21OdW1iZXIgJiAweDMpIHwgMHg4KS50b1N0cmluZygxNik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBDaGVjayBhIG5hbWUgc3RyaW5nIGFnYWluc3QgYW4gYXJyYXkgb2Ygc3RyaW5ncyB0byBkZXRlcm1pbmUgaWYgaXQgaXMgdW5pcXVlLlxuICAgKiBJZiBpdCBpc24ndCwgYXBwZW5kIGluY3JlbWVudGVkIHRyYWlsaW5nIGludGVnZXJzIHRvIHRoZSBlbmQgb2YgdGhlIG5hbWVcbiAgICogdW50aWwgaXQgaXMgdW5pcXVlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFN0cmluZyBuYW1lIHRvIG1ha2UgdW5pcXVlLlxuICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+PX0gbmFtZUFycmF5IC0gQXJyYXkgb2Ygc3RyaW5nIG5hbWVzIHRvIGNoZWNrIGFnYWlucy5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXRVbmlxdWVOYW1lKG5hbWUsIG5hbWVBcnJheSA9IFtdKSB7XG4gICAgLy8gSWYgdGhlIG5hbWUgaXNuJ3QgaW4gdGhlIGFycmF5IHJldHVybiBpdCByaWdodCBhd2F5XG4gICAgaWYgKCFuYW1lQXJyYXkuaW5jbHVkZXMobmFtZSkpIHtcbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cblxuICAgIGNvbnN0IG5hbWVTZXQgPSBuZXcgU2V0KG5hbWVBcnJheSk7XG5cbiAgICAvLyBTZXBhcmF0ZSB0aGUgbmFtZSBpbnRvIHN0cmluZyBhbmQgdHJhaWxpbmcgbnVtYmVyc1xuICAgIGNvbnN0IG1hdGNoR3JvdXAgPSBuYW1lLm1hdGNoKC9cXGQqJC8pO1xuICAgIGNvbnN0IHtpbmRleH0gPSBtYXRjaEdyb3VwO1xuICAgIGNvbnN0IGJhc2VOYW1lID0gbmFtZS5zbGljZSgwLCBpbmRleCk7XG4gICAgbGV0IGluY3JlbWVudCA9IE51bWJlcihtYXRjaEdyb3VwWzBdKTtcblxuICAgIC8vIEZpbmQgdGhlIGhpZ2hlc3QgdHJhaWxpbmcgbnVtYmVyIHZhbHVlIGZvciB0aGUgYmFzZSBvZiB0aGUgbmFtZVxuICAgIG5hbWVTZXQuZm9yRWFjaChzZXROYW1lID0+IHtcbiAgICAgIGNvbnN0IHNldE1hdGNoR3JvdXAgPSBzZXROYW1lLm1hdGNoKC9cXGQqJC8pO1xuXG4gICAgICBpZiAoc2V0TmFtZS5zbGljZSgwLCBzZXRNYXRjaEdyb3VwLmluZGV4KSA9PT0gYmFzZU5hbWUpIHtcbiAgICAgICAgY29uc3Qgc2V0SW5jcmVtZW50ID0gTnVtYmVyKHNldE1hdGNoR3JvdXBbMF0pO1xuXG4gICAgICAgIGlmIChzZXRJbmNyZW1lbnQgPiBpbmNyZW1lbnQpIHtcbiAgICAgICAgICBpbmNyZW1lbnQgPSBzZXRJbmNyZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEluY3JlbWVudCB0aGUgaGlnaGVzdCB0cmFpbGluZyBudW1iZXIgYW5kIGFwcGVuZCB0byB0aGUgbmFtZVxuICAgIHJldHVybiBgJHtiYXNlTmFtZX0ke2luY3JlbWVudCArIDF9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBkZWZlcnJlZCBwcm9taXNlIHRoYXQgd2lsbCB3YWl0IGEgZ2l2ZW4gbnVtYmVyIG9mIHNlY29uZHMgYmVmb3JlXG4gICAqIHJlc29sdmluZy4gUGFzcyBkZWx0YSB0aW1lIGluIG1pbGxpc2Vjb25kcyB0byB0aGUgZGVmZXJyZWQgcHJvbWlzZSdzIGV4ZWN1dGVcbiAgICogbWV0aG9kIGluIGFuIHVwZGF0ZSBsb29wIHRvIHByb2dyZXNzIHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2Vjb25kcz0wXSAtIE51bWJlciBvZiBzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHJlc29sdmluZy5cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIC0gT3B0aW9uYWwgb3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMub25GaW5pc2hdIC0gQ2FsbGJhY2sgdG8gZXhlY3V0ZSBvbmNlIHRoZSB3YWl0IHRpbWVcbiAgICogaXMgbWV0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb3B0aW9ucy5vblByb2dyZXNzIC0gQ2FsbGJhY2sgdG8gZXhlY3V0ZSBlYWNoIHRpbWUgdGhlIHdhaXRcbiAgICogdGltZSBwcm9ncmVzc2VzIHRvd2FyZHMgdGhlIHRhcmdldCBudW1iZXIgb2Ygc2Vjb25kcy4gVGhlIGFtb3VudCBvZiBwcm9ncmVzc1xuICAgKiBhcyBhIDAtMSBwZXJjZW50YWdlIGlzIHBhc3NlZCBhcyBhbiBhcmd1bWVudC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9wdGlvbnMub25DYW5jZWwgLSBDYWxsYmFjayB0byBleGVjdXRlIGlmIHRoZSB1c2VyIGNhbmNlbHNcbiAgICogdGhlIHdhaXQgYmVmb3JlIGNvbXBsZXRpb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvcHRpb25zLm9uRXJyb3IgLSBDYWxsYmFjayB0byBleGVjdXRlIGlmIHRoZSB3YWl0IHN0b3BzXG4gICAqIGJlY2F1c2UgYW4gZXJyb3IgaXMgZW5jb3VudGVyZWQuIFRoZSBlcnJvciBtZXNzYWdlIGlzIHBhc3NlZCBhcyBhIHBhcmFtZXRlci5cbiAgICpcbiAgICogQHJldHVybnMge0RlZmVycmVkfVxuICAgKi9cbiAgc3RhdGljIHdhaXQoc2Vjb25kcyA9IDAsIHtvbkZpbmlzaCwgb25Qcm9ncmVzcywgb25DYW5jZWwsIG9uRXJyb3J9ID0ge30pIHtcbiAgICAvLyBNYWtlIHN1cmUgc2Vjb25kcyBpcyBudW1lcmljXG4gICAgaWYgKHR5cGVvZiBzZWNvbmRzICE9PSAnbnVtYmVyJykge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgSW52YWxpZCBzZWNvbmRzIHZhbHVlICR7c2Vjb25kc30gZm9yIHdhaXQuIERlZmF1bHRpbmcgdG8gMC5gXG4gICAgICApO1xuXG4gICAgICBzZWNvbmRzID0gMDtcbiAgICB9XG5cbiAgICAvLyBSZXNvbHZlIGltbWVkaWF0ZWx5IGlmIHRoZSB3YWl0IHRpbWUgaXMgbm90IGdyZWF0ZXIgdGhhbiAwXG4gICAgaWYgKHNlY29uZHMgPD0gMCkge1xuICAgICAgaWYgKHR5cGVvZiBvbkZpbmlzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvbkZpbmlzaCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gRGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIGxldCBjdXJyZW50VGltZSA9IDA7XG4gICAgY29uc3QgdG90YWxUaW1lID0gc2Vjb25kcyAqIDEwMDA7IC8vIGNvbnZlcnQgdG8gbWlsbGlzZWNvbmRzXG5cbiAgICAvLyBFeGVjdXRhYmxlIHRvIHBhc3MgdG8gRGVmZXJyZWQsIG1lYW50IHRvIGJlIHJ1biBpbiBhbiB1cGRhdGUgbG9vcFxuICAgIGNvbnN0IG9uVXBkYXRlID0gKHJlc29sdmUsIHJlamVjdCwgX2NhbmNlbCwgZGVsdGFUaW1lID0gMCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBkZWx0YVRpbWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbnN0IGUgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgYEludmFsaWQgcHJvcGVydHkgd2FpdCBkZWx0YVRpbWUuIERlbHRhVGltZSBtdXN0IGJlIGEgbnVtYmVyLmBcbiAgICAgICAgKTtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIE1ha2Ugc3VyZSB0aW1lIGhhcyBwYXNzZWRcbiAgICAgIGlmIChkZWx0YVRpbWUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBTaWduYWwgcHJvZ3Jlc3NcbiAgICAgIGN1cnJlbnRUaW1lICs9IGRlbHRhVGltZTtcbiAgICAgIGlmIChjdXJyZW50VGltZSA8IDApIHtcbiAgICAgICAgY3VycmVudFRpbWUgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIG9uUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb25Qcm9ncmVzcyhNYXRoLm1pbihjdXJyZW50VGltZSAvIHRvdGFsVGltZSwgMSkpO1xuICAgICAgfVxuXG4gICAgICAvLyBTaWduYWwgY29tcGxldGlvbiBvbmNlIHRpbWUgaXMgdXBcbiAgICAgIGlmIChjdXJyZW50VGltZSA+PSB0b3RhbFRpbWUpIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gbmV3IERlZmVycmVkKG9uVXBkYXRlLCBvbkZpbmlzaCwgb25FcnJvciwgb25DYW5jZWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHJhbmRvbSBmbG9hdCBudW1iZXIgYmV0d2VlbiBhIG1pbiAoaW5jbHVzaXZlKSBhbmQgbWF4IChleGNsdXNpdmUpIHZhbHVlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gbWluaW11bSB2YWx1ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IG1heGltdW0gdmFsdWVcbiAgICogQHJldHVybnMge2Zsb2F0fVxuICAgKi9cbiAgc3RhdGljIGdldFJhbmRvbUZsb2F0KG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSByYW5kb20gaW50ZWdlciBudW1iZXIgYmV0d2VlbiBhIG1pbiAoaW5jbHVzaXZlKSBhbmQgbWF4IChleGNsdXNpdmUpIHZhbHVlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gbWluaW11bSB2YWx1ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IG1heGltdW0gdmFsdWVcbiAgICogQHJldHVybnMge2ludGVnZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0UmFuZG9tSW50KG1pbiwgbWF4KSB7XG4gICAgbWluID0gTWF0aC5jZWlsKG1pbik7XG4gICAgbWF4ID0gTWF0aC5mbG9vcihtYXgpO1xuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSkgKyBtaW47XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVXRpbHM7XG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxuY29uc3QgUmFkaWFuVG9EZWdyZWUgPSAxODAgLyBNYXRoLlBJO1xuY29uc3QgRGVncmVlVG9SYWRpYW4gPSBNYXRoLlBJIC8gMTgwO1xuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiB1c2VmdWwgbWF0aCBmdW5jdGlvbnMuXG4gKlxuICogQGhpZGVjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBNYXRoVXRpbHMge1xuICAvKipcbiAgICogQ29udmVydCB0aGUgZ2l2ZW4gYW5nbGUgZnJvbSByYWRpYW5zIHRvIGRlZ3JlZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpYW5zIC0gQW5nbGUgaW4gcmFkaWFucy5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlcn0gLSBBbmdsZSBpbiBkZWdyZWVzLlxuICAgKi9cbiAgc3RhdGljIHRvRGVncmVlcyhyYWRpYW5zKSB7XG4gICAgcmV0dXJuIHJhZGlhbnMgKiBSYWRpYW5Ub0RlZ3JlZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHRoZSBnaXZlbiBhbmdsZSBmcm9tIGRlZ3JlZXMgdG8gcmFkaWFucy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlZ3JlZXMgLSBBbmdsZSBpbiBkZWdyZWVzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIEFuZ2xlIGluIHJhZGlhbnMuXG4gICAqL1xuICBzdGF0aWMgdG9SYWRpYW5zKGRlZ3JlZXMpIHtcbiAgICByZXR1cm4gZGVncmVlcyAqIERlZ3JlZVRvUmFkaWFuO1xuICB9XG5cbiAgLyoqXG4gICAqIExpbmVhcmx5IGludGVycG9sYXRlIGJldHdlZW4gdHdvIHZhbHVlcy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb20gLSBTdGFydCB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHRvIC0gVGFyZ2V0IHZhbHVlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZmFjdG9yIC0gMC0xIGFtb3VudCB0byBpbnRlcnBvbGF0ZSBiZXR3ZWVuIGZyb20gYW5kIHRvLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgc3RhdGljIGxlcnAoZnJvbSwgdG8sIGZhY3Rvcikge1xuICAgIHJldHVybiBmcm9tICsgKHRvIC0gZnJvbSkgKiBmYWN0b3I7XG4gIH1cblxuICAvKipcbiAgICogQ2xhbXAgYSBudW1iZXIgYmV0d2VlbiAyIHZhbHVlcy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVmFsdWUgdG8gY2xhbXAuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWluPTBdIC0gTWludW11bSB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFttYXg9MV0gLSBNYXhpbXVtIHZhbHVlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgc3RhdGljIGNsYW1wKHZhbHVlLCBtaW4gPSAwLCBtYXggPSAxKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4odmFsdWUsIG1heCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGNsb3Nlc3QgcG9pbnQgb24gYSBnaXZlbiAyRCBsaW5lIHNlZ2VtZW50XG4gICAqIGZyb20gYSBnaXZlbiAyRCBwb2ludC5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYSAtIEZpcnN0IHBvaW50IG9uIGxpbmUgc2VnbWVudC5cbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYiAtIFNlY29uZCBwb2ludCBvbiBsaW5lIHNlZ21lbnQuXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHAgLSAyRCBwb2ludC5cbiAgICpcbiAgICogQHJldHVybnMge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgc3RhdGljIGNsb3Nlc3RQb2ludE9uTGluZShhLCBiLCBwKSB7XG4gICAgY29uc3QgZGlzdFNxciA9IE1hdGhVdGlscy5kaXN0YW5jZVNxdWFyZWQoYSwgYik7XG5cbiAgICAvLyBMaW5lIHNlZ21lbnQgaXMgYSBzaW5nbGUgcG9pbnRcbiAgICBpZiAoZGlzdFNxciA9PT0gMCkge1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgY29uc3QgdCA9XG4gICAgICAoKHBbMF0gLSBhWzBdKSAqIChiWzBdIC0gYVswXSkgKyAocFsxXSAtIGFbMV0pICogKGJbMV0gLSBhWzFdKSkgLyBkaXN0U3FyO1xuXG4gICAgbGV0IHBvaW50ID0gWy4uLmFdO1xuICAgIGlmICh0ID4gMSkge1xuICAgICAgcG9pbnQgPSBbLi4uYl07XG4gICAgfSBlbHNlIGlmICh0ID4gMCkge1xuICAgICAgcG9pbnQgPSBbYVswXSArIHQgKiAoYlswXSAtIGFbMF0pLCBhWzFdICsgdCAqIChiWzFdIC0gYVsxXSldO1xuICAgIH1cblxuICAgIHJldHVybiBwb2ludDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBkaXN0YW5jZSBzcXVhcmVkIGZvciB0d28gMkQgcG9pbnRzLlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBhIC0gMkQgcG9pbnQuXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGIgLSAyRCBwb2ludC5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIHN0YXRpYyBkaXN0YW5jZVNxdWFyZWQoYSwgYikge1xuICAgIHJldHVybiAoYVswXSAtIGJbMF0pICogKGFbMF0gLSBiWzBdKSArIChhWzFdIC0gYlsxXSkgKiAoYVsxXSAtIGJbMV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyaWFuZ3VsYXRlcyBhIHNldCBvZiAyRCBwb2ludHMgdXNpbmcgYW4gaW1wbGVtZW50YXRpb25cbiAgICogb2YgdGhlIEJvd3llci1XYXRzb24gaW5jcmVtZW50YWwgRGVsYXVuYXkgdHJpYW5ndWxhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSB2ZXJ0aWNlcyAtIEFycmF5IG9mIDJEIHBvaW50cy5cbiAgICpcbiAgICogQHJldHVybnMge0FycmF5LjxBcnJheTxudW1iZXI+Pn0gLSBBcnJheSBvZiB0cmlhbmdsZSBpbmRpY2VzLlxuICAgKi9cbiAgc3RhdGljIGdldERlbGF1bmF5VHJpYW5ndWxhdGlvbih2ZXJ0aWNlcykge1xuICAgIGlmICghdmVydGljZXMgfHwgdmVydGljZXMubGVuZ3RoIDwgMykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGdldCBkZWxhdW5heSB0cmlhbmd1bGF0aW9uIGZvciBwb2ludHMgJHt2ZXJ0aWNlc30uIElucHV0IG11c3QgY29udGFpbiBhdCBsZWFzdCB0aHJlZSBwb2ludHMuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgbWluWCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgbWluWSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgbWF4WCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICBsZXQgbWF4WSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcblxuICAgIHZlcnRpY2VzLmZvckVhY2godiA9PiB7XG4gICAgICBtaW5YID0gdlswXSA8IG1pblggPyB2WzBdIDogbWluWDtcbiAgICAgIG1pblkgPSB2WzFdIDwgbWluWSA/IHZbMV0gOiBtaW5ZO1xuICAgICAgbWF4WCA9IHZbMF0gPiBtYXhYID8gdlswXSA6IG1heFg7XG4gICAgICBtYXhZID0gdlsxXSA+IG1heFkgPyB2WzFdIDogbWF4WTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGRYID0gbWF4WCAtIG1pblg7XG4gICAgY29uc3QgZFkgPSBtYXhZIC0gbWluWTtcbiAgICBjb25zdCBtaWRYID0gKG1pblggKyBtYXhYKSAvIDI7XG4gICAgY29uc3QgbWlkWSA9IChtaW5ZICsgbWF4WSkgLyAyO1xuICAgIGNvbnN0IGRNYXggPSBkWCA+IGRZID8gZFggOiBkWTtcblxuICAgIGNvbnN0IHN1cGVySW5kaWNlcyA9IFtcbiAgICAgIHZlcnRpY2VzLmxlbmd0aCxcbiAgICAgIHZlcnRpY2VzLmxlbmd0aCArIDEsXG4gICAgICB2ZXJ0aWNlcy5sZW5ndGggKyAyLFxuICAgIF07XG5cbiAgICBjb25zdCB2ZXJ0c1dpdGhTdXBlciA9IFtcbiAgICAgIC4uLnZlcnRpY2VzLFxuICAgICAgW21pZFggLSAyMCAqIGRNYXgsIG1pZFkgLSBkTWF4XSxcbiAgICAgIFttaWRYLCBtaWRZICsgMjAgKiBkTWF4XSxcbiAgICAgIFttaWRYICsgMjAgKiBkTWF4LCBtaWRZIC0gZE1heF0sXG4gICAgXTtcblxuICAgIGNvbnN0IHN1cGVyU29ydGVkSW5kaWNlcyA9IE1hdGhVdGlscy5zb3J0UG9pbnRzQ0NXKFxuICAgICAgc3VwZXJJbmRpY2VzLFxuICAgICAgdmVydHNXaXRoU3VwZXJcbiAgICApO1xuXG4gICAgY29uc3Qgc3VwZXJUcmlhbmdsZSA9IHtcbiAgICAgIGluZGljZXM6IHN1cGVyU29ydGVkSW5kaWNlcyxcbiAgICAgIGVkZ2VzOiBbXG4gICAgICAgIFtzdXBlclNvcnRlZEluZGljZXNbMF0sIHN1cGVyU29ydGVkSW5kaWNlc1sxXV0sXG4gICAgICAgIFtzdXBlclNvcnRlZEluZGljZXNbMV0sIHN1cGVyU29ydGVkSW5kaWNlc1syXV0sXG4gICAgICAgIFtzdXBlclNvcnRlZEluZGljZXNbMl0sIHN1cGVyU29ydGVkSW5kaWNlc1swXV0sXG4gICAgICBdLFxuICAgIH07XG5cbiAgICBjb25zdCB0cmlhbmdsZXMgPSBbc3VwZXJUcmlhbmdsZV07XG5cbiAgICB2ZXJ0c1dpdGhTdXBlci5mb3JFYWNoKChuZXdWZXJ0LCBuZXdJbmRleCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZFRyaWFuZ2xlcyA9IFtdO1xuICAgICAgdHJpYW5nbGVzLmZvckVhY2godHJpYW5nbGUgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgTWF0aFV0aWxzLmlzUG9pbnRJbkNpcmN1bUNpcmNsZShcbiAgICAgICAgICAgIHZlcnRzV2l0aFN1cGVyW3RyaWFuZ2xlLmluZGljZXNbMF1dLFxuICAgICAgICAgICAgdmVydHNXaXRoU3VwZXJbdHJpYW5nbGUuaW5kaWNlc1sxXV0sXG4gICAgICAgICAgICB2ZXJ0c1dpdGhTdXBlclt0cmlhbmdsZS5pbmRpY2VzWzJdXSxcbiAgICAgICAgICAgIG5ld1ZlcnRcbiAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgIGludmFsaWRUcmlhbmdsZXMucHVzaCh0cmlhbmdsZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBib3VuZGluZ1BvbHkgPSBbXTtcbiAgICAgIGludmFsaWRUcmlhbmdsZXMuZm9yRWFjaCh0cmlhbmdsZSA9PiB7XG4gICAgICAgIHRyaWFuZ2xlLmVkZ2VzLmZvckVhY2goZWRnZSA9PiB7XG4gICAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgICBpbnZhbGlkVHJpYW5nbGVzLmZvckVhY2gob3RoZXJUcmlhbmdsZSA9PiB7XG4gICAgICAgICAgICBpZiAodHJpYW5nbGUgIT09IG90aGVyVHJpYW5nbGUpIHtcbiAgICAgICAgICAgICAgb3RoZXJUcmlhbmdsZS5lZGdlcy5mb3JFYWNoKG90aGVyRWRnZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgKGVkZ2VbMF0gPT09IG90aGVyRWRnZVswXSAmJiBlZGdlWzFdID09PSBvdGhlckVkZ2VbMV0pIHx8XG4gICAgICAgICAgICAgICAgICAoZWRnZVsxXSA9PT0gb3RoZXJFZGdlWzBdICYmIGVkZ2VbMF0gPT09IG90aGVyRWRnZVsxXSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoY291bnQgPT09IDApIGJvdW5kaW5nUG9seS5wdXNoKGVkZ2UpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpbnZhbGlkVHJpYW5nbGVzLmZvckVhY2godHJpYW5nbGUgPT4ge1xuICAgICAgICB0cmlhbmdsZXMuc3BsaWNlKHRyaWFuZ2xlcy5pbmRleE9mKHRyaWFuZ2xlKSwgMSk7XG4gICAgICB9KTtcblxuICAgICAgYm91bmRpbmdQb2x5LmZvckVhY2goZWRnZSA9PiB7XG4gICAgICAgIGNvbnN0IHNvcnRlZEluZGljZXMgPSBNYXRoVXRpbHMuc29ydFBvaW50c0NDVyhcbiAgICAgICAgICBbZWRnZVswXSwgZWRnZVsxXSwgbmV3SW5kZXhdLFxuICAgICAgICAgIHZlcnRzV2l0aFN1cGVyXG4gICAgICAgICk7XG5cbiAgICAgICAgdHJpYW5nbGVzLnB1c2goe1xuICAgICAgICAgIGluZGljZXM6IHNvcnRlZEluZGljZXMsXG4gICAgICAgICAgZWRnZXM6IFtcbiAgICAgICAgICAgIFtzb3J0ZWRJbmRpY2VzWzBdLCBzb3J0ZWRJbmRpY2VzWzFdXSxcbiAgICAgICAgICAgIFtzb3J0ZWRJbmRpY2VzWzFdLCBzb3J0ZWRJbmRpY2VzWzJdXSxcbiAgICAgICAgICAgIFtzb3J0ZWRJbmRpY2VzWzJdLCBzb3J0ZWRJbmRpY2VzWzBdXSxcbiAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgY29uc3QgdHJpYW5nbGVzVG9SZW1vdmUgPSBbXTtcbiAgICB0cmlhbmdsZXMuZm9yRWFjaCh0cmlhbmdsZSA9PiB7XG4gICAgICB0cmlhbmdsZS5pbmRpY2VzLmZvckVhY2goaW5kZXggPT4ge1xuICAgICAgICBpZiAoc3VwZXJJbmRpY2VzLmluY2x1ZGVzKGluZGV4KSkge1xuICAgICAgICAgIHRyaWFuZ2xlc1RvUmVtb3ZlLnB1c2godHJpYW5nbGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRyaWFuZ2xlc1RvUmVtb3ZlLmZvckVhY2godHJpYW5nbGUgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSB0cmlhbmdsZXMuaW5kZXhPZih0cmlhbmdsZSk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRyaWFuZ2xlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRyaWFuZ2xlcy5tYXAodHJpYW5nbGUgPT4gdHJpYW5nbGUuaW5kaWNlcyk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIDJEIHBvaW50IGlzIHdpdGhpbiB0aGUgY2ljcnVtY2lyY2xlXG4gICAqIGRlZmluZWQgYnkgdGhyZWUgMkQgcG9pbnRzLiBUaGUgdHJpYW5nbGUgcG9pbnRzIG11c3QgYmUgaW5cbiAgICogY291bnRlci1jbG9ja3dpc2Ugb3JkZXIgYSAtPiBiIC0+IGMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGEgLSBGaXJzdCB0cmlhbmdsZSBwb2ludC5cbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYiAtIFNlY29uZCB0cmlhbmdsZSBwb2ludC5cbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYyAtIFRoaXJkIHRyaWFuZ2xlIHBvaW50LlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBwIC0gMkQgcG9pbnQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzUG9pbnRJbkNpcmN1bUNpcmNsZShhLCBiLCBjLCBwKSB7XG4gICAgY29uc3QgYXggPSBhWzBdIC0gcFswXTtcbiAgICBjb25zdCBheSA9IGFbMV0gLSBwWzFdO1xuICAgIGNvbnN0IGJ4ID0gYlswXSAtIHBbMF07XG4gICAgY29uc3QgYnkgPSBiWzFdIC0gcFsxXTtcbiAgICBjb25zdCBjeCA9IGNbMF0gLSBwWzBdO1xuICAgIGNvbnN0IGN5ID0gY1sxXSAtIHBbMV07XG5cbiAgICByZXR1cm4gKFxuICAgICAgKGF4ICogYXggKyBheSAqIGF5KSAqIChieCAqIGN5IC0gY3ggKiBieSkgLVxuICAgICAgICAoYnggKiBieCArIGJ5ICogYnkpICogKGF4ICogY3kgLSBjeCAqIGF5KSArXG4gICAgICAgIChjeCAqIGN4ICsgY3kgKiBjeSkgKiAoYXggKiBieSAtIGJ4ICogYXkpID5cbiAgICAgIDBcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgYSBnaXZlbiAyRCBwb2ludCBpcyB3aXRoaW4gYSBnaXZlbiB0cmlhbmdsZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYSAtIEZpcnN0IHRyaWFuZ2xlIHBvaW50LlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBiIC0gU2Vjb25kIHRyaWFuZ2xlIHBvaW50LlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBjIC0gVGhpcmQgdHJpYW5nbGUgcG9pbnQuXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHAgLSAyRCBwb2ludC5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNQb2ludEluVHJpYW5nbGUoYSwgYiwgYywgcCkge1xuICAgIGNvbnN0IGRlbm9tID0gKGJbMV0gLSBjWzFdKSAqIChhWzBdIC0gY1swXSkgKyAoY1swXSAtIGJbMF0pICogKGFbMV0gLSBjWzFdKTtcbiAgICBjb25zdCBhVmFsID1cbiAgICAgICgoYlsxXSAtIGNbMV0pICogKHBbMF0gLSBjWzBdKSArIChjWzBdIC0gYlswXSkgKiAocFsxXSAtIGNbMV0pKSAvIGRlbm9tO1xuICAgIGNvbnN0IGJWYWwgPVxuICAgICAgKChjWzFdIC0gYVsxXSkgKiAocFswXSAtIGNbMF0pICsgKGFbMF0gLSBjWzBdKSAqIChwWzFdIC0gY1sxXSkpIC8gZGVub207XG4gICAgY29uc3QgY1ZhbCA9IDEgLSBhVmFsIC0gYlZhbDtcblxuICAgIHJldHVybiAoXG4gICAgICBhVmFsID49IDAgJiYgYVZhbCA8PSAxICYmIGJWYWwgPj0gMCAmJiBiVmFsIDw9IDEgJiYgY1ZhbCA+PSAwICYmIGNWYWwgPD0gMVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc29ydGVkIGluZGljZXMgb2YgYSBnaXZlbiBzZXQgb2YgMkQgcG9pbnRzIGluXG4gICAqIGNvdW50ZXItY2xvY2t3aXNlIG9yZGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBpbmRpY2VzIC0gTGlzdCBvZiBpbmRpY2VzLlxuICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IHZlcnRpY2VzIC0gTGlzdCBvZiAyRCBwb2ludHMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSAtIExpc3Qgb2Ygc29ydGVkIGluZGljZXMuXG4gICAqL1xuICBzdGF0aWMgc29ydFBvaW50c0NDVyhpbmRpY2VzLCB2ZXJ0aWNlcykge1xuICAgIGNvbnN0IGNlbnRyb2lkID0gWzAsIDBdO1xuICAgIGluZGljZXMuZm9yRWFjaChpbmRleCA9PiB7XG4gICAgICBjZW50cm9pZFswXSArPSB2ZXJ0aWNlc1tpbmRleF1bMF07XG4gICAgICBjZW50cm9pZFsxXSArPSB2ZXJ0aWNlc1tpbmRleF1bMV07XG4gICAgfSk7XG4gICAgY2VudHJvaWRbMF0gLz0gaW5kaWNlcy5sZW5ndGg7XG4gICAgY2VudHJvaWRbMV0gLz0gaW5kaWNlcy5sZW5ndGg7XG5cbiAgICBpbmRpY2VzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IGJWYWwgPSBNYXRoLmF0YW4yKFxuICAgICAgICB2ZXJ0aWNlc1tiXVsxXSAtIGNlbnRyb2lkWzFdLFxuICAgICAgICB2ZXJ0aWNlc1tiXVswXSAtIGNlbnRyb2lkWzBdXG4gICAgICApO1xuICAgICAgY29uc3QgYVZhbCA9IE1hdGguYXRhbjIoXG4gICAgICAgIHZlcnRpY2VzW2FdWzFdIC0gY2VudHJvaWRbMV0sXG4gICAgICAgIHZlcnRpY2VzW2FdWzBdIC0gY2VudHJvaWRbMF1cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBhVmFsIC0gYlZhbDtcbiAgICB9KTtcblxuICAgIHJldHVybiBpbmRpY2VzO1xuICB9XG5cbiAgLyoqXG4gICAqIENhY2x1YXRlcyB0aGUgYXJlYSBvZiBhIHRyaWFuZ2xlXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGEgLSBGaXJzdCB0cmlhbmdsZSBwb2ludC5cbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYiAtIFNlY29uZCB0cmlhbmdsZSBwb2ludC5cbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYyAtIFRoaXJkIHRyaWFuZ2xlIHBvaW50LlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgc3RhdGljIHRyaWFuZ2xlQXJlYShhLCBiLCBjKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKFxuICAgICAgKGFbMF0gKiAoYlsxXSAtIGNbMV0pICsgYlswXSAqIChjWzFdIC0gYVsxXSkgKyBjWzBdICogKGFbMV0gLSBiWzFdKSkgKiAwLjVcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbWFnbml0dWRlIG9mIGEgZ2l2ZW4gdmVjdG9yIGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2ZWN0b3IgLSBBcnJheSBjb25zaXN0aW5nIG9mIG51bWJlcnMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0VmVjdG9yTWFnbml0dWRlKHZlY3Rvcikge1xuICAgIGlmICghKHZlY3RvciBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGdldCBtYWduaXR1ZGUgZm9yIHZlY3RvciAke3ZlY3Rvcn0uIElucHV0IG11c3QgYmUgYW4gQXJyYXkgbnVtYmVycy5gXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHJlZHVjZXIgPSAoYWNjdW11bGF0b3IsIGN1cnJlbnRWYWx1ZSkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBjdXJyZW50VmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQ2Fubm90IGdldCBtYWduaXR1ZGUgZm9yIHZlY3RvciAke3ZlY3Rvcn0uIEFsbCBpdGVtcyBpbiB0aGUgaW5wdXQgQXJyYXkgbXVzdCBiZSBudW1iZXJzLmBcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yICsgY3VycmVudFZhbHVlICoqIDI7XG4gICAgfTtcblxuICAgIHJldHVybiBNYXRoLnNxcnQodmVjdG9yLnJlZHVjZShyZWR1Y2VyLCAwKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBkb3QgcHJvZHVjdCBiZXR3ZWVuIHR3byB2ZWN0b3JzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2ZWN0b3JBIC0gQXJyYXkgY29uc2lzdGluZyBvZiBudW1iZXJzLlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2ZWN0b3JCIC0gQXJyYXkgY29uc2lzdGluZyBvZiBudW1iZXJzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgc3RhdGljIGdldERvdFByb2R1Y3QodmVjdG9yQSwgdmVjdG9yQikge1xuICAgIGlmIChcbiAgICAgICEodmVjdG9yQSBpbnN0YW5jZW9mIEFycmF5KSB8fFxuICAgICAgISh2ZWN0b3JCIGluc3RhbmNlb2YgQXJyYXkpIHx8XG4gICAgICB2ZWN0b3JBLmxlbmd0aCAhPT0gdmVjdG9yQi5sZW5ndGhcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBnZXQgZG90IHByb2R1Y3QgYmV0d2VlbiAke3ZlY3RvckF9IGFuZCAke3ZlY3RvckJ9LiBJbnB1dHMgbXVzdCBiZSB2ZWN0b3JzIG9mIHRoZSBzYW1lIGxlbmd0aC5gXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCByZXN1bHQgPSAwO1xuICAgIHZlY3RvckEuZm9yRWFjaCgodmFsdWVBLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgdmFsdWVCID0gdmVjdG9yQltpbmRleF07XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWVBICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgdmFsdWVCICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYENhbm5vdCBnZXQgZG90IHByb2R1Y3QgYmV0d2VlbiAke3ZlY3RvckF9IGFuZCAke3ZlY3RvckJ9LiBWZWN0b3JzIG11c3Qgb25seSBjb25zaXN0IG9mIG51bWVyaWMgdmFsdWVzLmBcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0ICs9IHZhbHVlQSAqIHZhbHVlQjtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBhbmdsZSBpbiByYWRpYW5zIGJldHdlZW4gdmVjdG9yQSBhbmQgdmVjdG9yQi5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdmVjdG9yQSAtIEFycmF5IGNvbnNpc3Rpbmcgb2YgbnVtYmVycy5cbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdmVjdG9yQiAtIEFycmF5IGNvbnNpc3Rpbmcgb2YgbnVtYmVycy5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIHN0YXRpYyBnZXRBbmdsZUJldHdlZW4odmVjdG9yQSwgdmVjdG9yQikge1xuICAgIGNvbnN0IG5vcm1hbEEgPSB0aGlzLm5vcm1hbGl6ZVZlY3RvcihbLi4udmVjdG9yQV0pO1xuICAgIGNvbnN0IG5vcm1hbEIgPSB0aGlzLm5vcm1hbGl6ZVZlY3RvcihbLi4udmVjdG9yQl0pO1xuICAgIGNvbnN0IGRvdCA9IHRoaXMuZ2V0RG90UHJvZHVjdChub3JtYWxBLCBub3JtYWxCKTtcblxuICAgIHJldHVybiBNYXRoLmFjb3ModGhpcy5jbGFtcChkb3QsIC0xLCAxKSk7XG4gIH1cblxuICAvKipcbiAgICogTXVsdGlwbHkgYSAzeDMgcm90YXRpb24gbWF0cml4IHdpdGggYSB2ZWN0b3IzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2ZWN0b3IzIC0gQXJyYXkgY29uc2lzdGluZyBvZiAzIG51bWJlcnMgcmVwcmVzZW50aW5nXG4gICAqIGEgZGlyZWN0aW9uIHZlY3Rvci5cbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF0cml4MyAtIEFuIGFycmF5IG9mIDkgbnVtYmVycyByZXByZXNlbnRpbmcgYSByb3dcbiAgICogbWFqb3Igcm90YXRpb24gbWF0cml4LlxuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59IC0gQW4gYXJyYXkgb2YgMyBudW1iZXJzIHJlcHJlc2VudGluZyB0aGUgbmV3IGRpcmVjdGlvblxuICAgKiBvZiB0aGUgdmVjdG9yLlxuICAgKi9cbiAgc3RhdGljIHJvdGF0ZVZlY3Rvcih2ZWN0b3IzLCBtYXRyaXgzKSB7XG4gICAgaWYgKFxuICAgICAgISh2ZWN0b3IzIGluc3RhbmNlb2YgQXJyYXkpIHx8XG4gICAgICB2ZWN0b3IzLmxlbmd0aCAhPT0gMyB8fFxuICAgICAgIXZlY3RvcjMuZXZlcnkodiA9PiB0eXBlb2YgdiA9PT0gJ251bWJlcicpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3Qgcm90YXRlIHZlY3RvciAke3ZlY3RvcjN9IGJ5IHJvdGF0aW9uIG1hdHJpeCAke21hdHJpeDN9LiBJbnB1dCB2ZWN0b3IgbXVzdCBiZSBhbiBhcnJheSBvZiAzIG51bWJlcnMuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAhKG1hdHJpeDMgaW5zdGFuY2VvZiBBcnJheSkgfHxcbiAgICAgIG1hdHJpeDMubGVuZ3RoICE9PSA5IHx8XG4gICAgICAhbWF0cml4My5ldmVyeSh2ID0+IHR5cGVvZiB2ID09PSAnbnVtYmVyJylcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCByb3RhdGUgdmVjdG9yICR7dmVjdG9yM30gYnkgcm90YXRpb24gbWF0cml4ICR7bWF0cml4M30uIElucHV0IG1hdHJpeDMgbXVzdCBiZSBhbiBhcnJheSBvZiA5IG51bWJlcnMuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCB4ID1cbiAgICAgIG1hdHJpeDNbMF0gKiB2ZWN0b3IzWzBdICtcbiAgICAgIG1hdHJpeDNbM10gKiB2ZWN0b3IzWzFdICtcbiAgICAgIG1hdHJpeDNbNl0gKiB2ZWN0b3IzWzJdO1xuICAgIGNvbnN0IHkgPVxuICAgICAgbWF0cml4M1sxXSAqIHZlY3RvcjNbMF0gK1xuICAgICAgbWF0cml4M1s0XSAqIHZlY3RvcjNbMV0gK1xuICAgICAgbWF0cml4M1s3XSAqIHZlY3RvcjNbMl07XG4gICAgY29uc3QgeiA9XG4gICAgICBtYXRyaXgzWzJdICogdmVjdG9yM1swXSArXG4gICAgICBtYXRyaXgzWzVdICogdmVjdG9yM1sxXSArXG4gICAgICBtYXRyaXgzWzhdICogdmVjdG9yM1syXTtcblxuICAgIHJldHVybiBbeCwgeSwgel07XG4gIH1cblxuICAvKipcbiAgICogTm9ybWFsaXplIGEgZ2l2ZW4gdmVjdG9yIGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2ZWN0b3IgLSBBcnJheSBjb25zaXN0aW5nIG9mIG51bWJlcnMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheS48bnVtYmVyPn0gVGhlIG9yaWdpbmFsIHZlY3RvciB3aXRoIG5vcm1hbGl6ZWQgdmFsdWVzLCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBzdGF0aWMgbm9ybWFsaXplVmVjdG9yKHZlY3Rvcikge1xuICAgIGNvbnN0IG1hZ25pdHVkZSA9IHRoaXMuZ2V0VmVjdG9yTWFnbml0dWRlKHZlY3Rvcik7XG5cbiAgICBpZiAobWFnbml0dWRlID09PSAwKSB7XG4gICAgICB2ZWN0b3IuZmlsbCgwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmVjdG9yLmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICB2ZWN0b3JbaW5kZXhdID0gdmFsdWUgLyBtYWduaXR1ZGU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmVjdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgdGhlIDN4MyByb3RhdGlvbiBtYXRyaXggZnJvbSBhIGdpdmVuIDR4NCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1hdHJpeDQgLSBBbiBhcnJheSBvZiAxNiBudW1iZXJzIHJlcHJlc2VudGluZyBhIHJvd1xuICAgKiBtYWpvciB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheS48bnVtYmVyPn0gLSBBbiBhcnJheSBvZiA5IG51bWJlcnMgcmVwcmVzZW50aW5nIGEgcm93IG1ham9yXG4gICAqIHJvdGF0aW9uIG1hdHJpeC5cbiAgICovXG4gIHN0YXRpYyBnZXRSb3RhdGlvbk1hdHJpeChtYXRyaXg0KSB7XG4gICAgaWYgKFxuICAgICAgIShtYXRyaXg0IGluc3RhbmNlb2YgQXJyYXkpIHx8XG4gICAgICBtYXRyaXg0Lmxlbmd0aCAhPT0gMTYgfHxcbiAgICAgICFtYXRyaXg0LmV2ZXJ5KHYgPT4gdHlwZW9mIHYgPT09ICdudW1iZXInKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGNvbnZlcnQgbWF0cml4ICR7bWF0cml4NH0gdG8gYSByb3RhdGlvbiBtYXRyaXguIElucHV0IG1hdHJpeCBtdXN0IGJlIGFuIGFycmF5IG9mIDE2IG51bWJlcnMuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBFeHRyYWN0IHNjYWxlXG4gICAgY29uc3Qgc2NhbGVYID0gMSAvICh0aGlzLmdldFZlY3Rvck1hZ25pdHVkZShtYXRyaXg0LnNsaWNlKDAsIDQpKSB8fCAxKTtcbiAgICBjb25zdCBzY2FsZVkgPSAxIC8gKHRoaXMuZ2V0VmVjdG9yTWFnbml0dWRlKG1hdHJpeDQuc2xpY2UoNCwgOCkpIHx8IDEpO1xuICAgIGNvbnN0IHNjYWxlWiA9IDEgLyAodGhpcy5nZXRWZWN0b3JNYWduaXR1ZGUobWF0cml4NC5zbGljZSg4LCAxMikpIHx8IDEpO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIG1hdHJpeDRbMF0gKiBzY2FsZVgsXG4gICAgICBtYXRyaXg0WzFdICogc2NhbGVYLFxuICAgICAgbWF0cml4NFsyXSAqIHNjYWxlWCxcbiAgICAgIG1hdHJpeDRbNF0gKiBzY2FsZVksXG4gICAgICBtYXRyaXg0WzVdICogc2NhbGVZLFxuICAgICAgbWF0cml4NFs2XSAqIHNjYWxlWSxcbiAgICAgIG1hdHJpeDRbOF0gKiBzY2FsZVosXG4gICAgICBtYXRyaXg0WzldICogc2NhbGVaLFxuICAgICAgbWF0cml4NFsxMF0gKiBzY2FsZVosXG4gICAgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyB0aGUgc3BoZXJpY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSBnaXZlbiBjYXJ0ZXNpYW5cbiAgICogeHl6IGNvb3JkaW5hdGVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFBvc2l0aW9uIGFsb25nIHRoZSB4IGF4aXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gUG9zaXRpb24gYWxvbmcgdGhlIHkgYXhpcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHogLSBQb3NpdGlvbiBhbG9uZyB0aGUgeiBheGlzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59IC0gQW4gYXJyYXkgY29uc2lzdGluZyBvZiB0aHJlZSBudW1iZXJlcyB3aGVyZSBpbmRleFxuICAgKiAwIHJlcHJlc2VudHMgdGhlIHJhZGl1cywgaW5kZXggMSByZXByZXNlbnRzIHRoZSB2ZXJ0aWNhbC9wb2xhciBhbmdsZSBpbiByYWRpYW5zXG4gICAqIGFuZCBpbmRleCAyIHJlcHJlc2VudHMgdGhlIGhvcml6b250YWwvYXppbXV0aGFsIGFuZ2xlIGluIHJhZGlhbnMuXG4gICAqL1xuICBzdGF0aWMgY2FydGVzaWFuVG9TcGhlcmljYWwoeCwgeSwgeikge1xuICAgIGNvbnN0IHIgPSB0aGlzLmdldFZlY3Rvck1hZ25pdHVkZShbeCwgeSwgel0pO1xuXG4gICAgLy8gUmV0dXJuIGlkZW50aXR5IGlmIHRoZSB2ZWN0b3IgaGFzIG5vIGxlbmd0aFxuICAgIGlmIChyID09PSAwKSB7XG4gICAgICByZXR1cm4gWzAsIDAsIDBdO1xuICAgIH1cblxuICAgIHJldHVybiBbciwgTWF0aC5hY29zKHRoaXMuY2xhbXAoeSAvIHIsIC0xLCAxKSksIE1hdGguYXRhbjIoeCwgeildO1xuICB9XG5cbiAgLyoqXG4gICAqIEdyYWR1YWxseSBjaGFuZ2UgYSB2YWx1ZSBvZiBhIG51bWVyaWMgcHJvcGVydHkgdG93YXJkcyBhIGdvYWwgb3ZlciB0aW1lIHVzaW5nXG4gICAqIGEgY3JpdGljYWxseSBkYW1wZWQgc3ByaW5nIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY3VycmVudFZhbHVlIC0gVGhlIHN0YXJ0aW5nIHZhbHVlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0VmFsdWUtIFRoZSBnb2FsIHZhbHVlLlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBbdmFsdWVTdG9yZSA9IFswLCAwXV0gLSBBbiBBcnJheSBjb25zaXN0aW5nIG9mIHR3b1xuICAgKiBudW1iZXJzIHdoZXJlIHRoZSBmaXJzdCBudW1iZXIgaG9sZHMgdGhlIHJlc3VsdCB2YWx1ZSBhbmQgdGhlIHNlY29uZCBob2xkc1xuICAgKiB0aGUgdmVsb2NpdHkgdGhhdCByZXN1bHRlZCBpbiB0aGF0IHZhbHVlLiBUaGUgc2FtZSBhcnJheSBzaG91bGQgYmUgcHJvdmlkZWRcbiAgICogd2l0aCBlYWNoIGNhbGwgdG8gdGhpcyBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWx0YVRpbWUgPSAxZS03XSAtIFRoZSB0aW1lIHNpbmNlIHRoZSBsYXN0IGNhbGwgdG8gdGhpcyBmdW5jdGlvblxuICAgKiBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3Ntb290aFRpbWUgPSAwLjNdIC0gVGhlIGFwcHJveGltYXRlIGFtb3VudCBvZiB0aW1lIGluIHNlY29uZHNcbiAgICogaXQgc2hvdWxkIHRha2UgdG8gcmVhY2ggdGhlIHRhcmdldCB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFttYXhTcGVlZCA9IDFlN10gLSBBIGNsYW1waW5nIHZhbHVlIGZvciB0aGUgbWF4aW11bSBzcGVlZCB0aGVcbiAgICogdmFsdWUgY2FuIGNoYW5nZS5cbiAgICpcbiAgICogQHJldHVybnMge0FycmF5LjxudW1iZXI+fSAtIFRoZSB2YWx1ZVN0b3JlIGFycmF5LlxuICAgKi9cbiAgc3RhdGljIGRhbXBWYWx1ZShcbiAgICBjdXJyZW50VmFsdWUsXG4gICAgdGFyZ2V0VmFsdWUsXG4gICAgdmFsdWVTdG9yZSA9IFswLCAwXSxcbiAgICBkZWx0YVRpbWUgPSAxZS03LFxuICAgIHNtb290aFRpbWUgPSAwLjMsXG4gICAgbWF4U3BlZWQgPSAxZTdcbiAgKSB7XG4gICAgc21vb3RoVGltZSA9IE1hdGgubWF4KDAuMDAwMSwgc21vb3RoVGltZSk7XG4gICAgZGVsdGFUaW1lID0gTWF0aC5tYXgoMWUtNywgZGVsdGFUaW1lKTtcblxuICAgIC8vIEZpbmQgdGhlIGRlbHRhIGJldHdlZW4gdmFsdWVzIGFuZCB1c2UgaXQgdG8gZXN0aW1hdGUgdGhlIHByZXZpb3VzIHZhbHVlXG4gICAgY29uc3QgY2xhbXBUaW1lID0gbWF4U3BlZWQgKiBzbW9vdGhUaW1lO1xuICAgIGNvbnN0IGRlbHRhVmFsdWUgPSBjdXJyZW50VmFsdWUgLSB0YXJnZXRWYWx1ZTtcbiAgICBjb25zdCBjbGFtcERlbHRhVmFsdWUgPSB0aGlzLmNsYW1wKGRlbHRhVmFsdWUsIC1jbGFtcFRpbWUsIGNsYW1wVGltZSk7XG4gICAgY29uc3QgbGFzdFZhbHVlID0gY3VycmVudFZhbHVlIC0gY2xhbXBEZWx0YVZhbHVlO1xuXG4gICAgLy8gQ2FsY3VsYXRlIGRhbXBpbmcgZmFjdG9yc1xuICAgIGNvbnN0IGQxID0gMiAvIHNtb290aFRpbWU7XG4gICAgY29uc3QgZDIgPSBkMSAqIGRlbHRhVGltZTtcbiAgICBjb25zdCBkMyA9IDEgLyAoMSArIGQyICsgMC41ICogZDIgKiogMiArIDAuMjUgKiBkMiAqKiAzKTtcbiAgICBjb25zdCBkNCA9ICh2YWx1ZVN0b3JlWzFdICsgZDEgKiBjbGFtcERlbHRhVmFsdWUpICogZGVsdGFUaW1lO1xuXG4gICAgLy8gRGFtcCB0aGUgdGFyZ2V0IHZhbHVlIGFuZCB1cGRhdGUgdGhlIHZlbG9jaXR5XG4gICAgdmFsdWVTdG9yZVswXSA9IGxhc3RWYWx1ZSArIChjbGFtcERlbHRhVmFsdWUgKyBkNCkgKiBkMztcbiAgICB2YWx1ZVN0b3JlWzFdID0gKHZhbHVlU3RvcmVbMV0gLSBkMSAqIGQ0KSAqIGQzO1xuXG4gICAgLy8gUHJldmVudCBvdmVyc2hvb3RpbmdcbiAgICBpZiAodGFyZ2V0VmFsdWUgLSBjdXJyZW50VmFsdWUgPiAwID09PSB2YWx1ZVN0b3JlWzBdID4gdGFyZ2V0VmFsdWUpIHtcbiAgICAgIHZhbHVlU3RvcmVbMF0gPSB0YXJnZXRWYWx1ZTtcbiAgICAgIHZhbHVlU3RvcmVbMV0gPSAodmFsdWVTdG9yZVswXSAtIHRhcmdldFZhbHVlKSAvIGRlbHRhVGltZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVTdG9yZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNYXRoVXRpbHM7XG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxuLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L3ByZWZlci1kZWZhdWx0LWV4cG9ydCAqL1xuXG4vKipcbiAqIEluZGljYXRlcyB0aGUgdHlwZSBvZiBob3N0IGJ1aWxkLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmNvbnN0IGVudiA9ICdjb3JlJztcblxuZXhwb3J0IHtlbnZ9O1xuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVyc2NvcmUtZGFuZ2xlICovXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi9VdGlscyc7XG5cbi8qKlxuICogQ2xhc3MgdGhhdCBjYW4gZXhlY3V0ZSBmdW5jdGlvbnMgd2hlbiBsb2NhbCBtZXNzYWdlcyBhcmUgcmVjZWl2ZWQuIExvY2FsIG1lc3NhZ2VzXG4gKiBhcmUgcHJlZml4ZWQgd2l0aCB0aGUgaW5zdGFuY2UncyBpZC5cbiAqXG4gKiBAYWxpYXMgY29yZS9NZXNzZW5nZXJcbiAqXG4gKiBAcHJvcGVydHkge2NvcmUvTWVzc2VuZ2VyfSBHbG9iYWxNZXNzZW5nZXIgLSBBIG1lc3NlbmdlciB0aGF0IGNhbiBiZSB1c2VkIGZvclxuICogZ2xvYmFsIG1lc3NhZ2luZy4gV2hlbiB1c2luZyBzdGF0aWMgbGlzdGVuIGFuZCBlbWl0IG1ldGhvZHMgdGhleSBhcmUgZXhlY3V0ZWRcbiAqIG9uIHRoaXMgbWVzc2VuZ2VyLlxuICogQHByb3BlcnR5IHtPYmplY3R9IEVWRU5UUyAtIEJ1aWx0LWluIGV2ZW50cyB0aGF0IHRoZSBNZXNzZW5nZXIgZW1pdHMuXG4gKi9cbmNsYXNzIE1lc3NlbmdlciB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtIHthbnk9fSBpZCAtIElkIGZvciB0aGUgb2JqZWN0LiBJZiBub25lIGlzIHByb3ZpZGVkIGEgbmV3IGlkIHdpbGxcbiAgICogYmUgY3JlYXRlZC4gSWQgc2hvdWxkIGJlIGFibGUgdG8gYmUgcmVwcmVzZW50ZWQgYXMgYSBzdHJpbmcuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihpZCkge1xuICAgIHRoaXMuX2lkID0gaWQgIT09IHVuZGVmaW5lZCA/IGlkIDogVXRpbHMuY3JlYXRlSWQoKTtcbiAgICB0aGlzLl9kaXNwYXRjaGVyID0gd2luZG93O1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJzID0ge307XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc3RyaW5nIGlkIG9mIHRoZSBvYmplY3QuXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiB0aGlzLl9pZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVmaXggYSBtZXNzYWdlIHdpdGggdGhlIGluc3RhbmNlIGlkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgX2NyZWF0ZUxvY2FsTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuaWR9LiR7bWVzc2FnZX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBjYWxsIGEgY2FsbGJhY2sgZnVuY3Rpb24gYW5kIHN1cHBseSB0aGUgZXZlbnQnc1xuICAgKiBkZXRhaWwgcHJvcGVydHkgYXMgYW4gYXJndW1lbnQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAgICovXG4gIF9jcmVhdGVMaXN0ZW5lcihjYWxsYmFjaykge1xuICAgIHJldHVybiBlID0+IHtcbiAgICAgIGxldCB2YWx1ZTtcblxuICAgICAgaWYgKGUuZGV0YWlsICE9PSBudWxsKSB7XG4gICAgICAgIHZhbHVlID0gZS5kZXRhaWw7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKHZhbHVlKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBldmVudCBvYmplY3QgYW5kIHNlbmQgaXQgdG8gbGlzdGVuZXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIEV2ZW50IHR5cGUgbmFtZS5cbiAgICogQHBhcmFtIHthbnk9fSB2YWx1ZSAtIFZhbHVlIHRvIHNlbmQgdG8gbGlzdGVuZXJzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q3VzdG9tRXZlbnR9XG4gICAqL1xuICBfY3JlYXRlRXZlbnQobWVzc2FnZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IEN1c3RvbUV2ZW50KG1lc3NhZ2UsIHtkZXRhaWw6IHZhbHVlfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYW4gZXZlbnQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gRXZlbnQgdHlwZSBuYW1lLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciAtIEEgbGlzdGVuZXIgZnVuY3Rpb24gZ2VuZXJhdGVkIHVzaW5nIF9jcmVhdGVMaXN0ZW5lci5cbiAgICovXG4gIF9hZGRMaXN0ZW5lcihtZXNzYWdlLCBsaXN0ZW5lcikge1xuICAgIHRoaXMuX2Rpc3BhdGNoZXIuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIHRoaXMuX2NyZWF0ZUxvY2FsTWVzc2FnZShtZXNzYWdlKSxcbiAgICAgIGxpc3RlbmVyXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnJlZ2lzdGVyIGFuIGV2ZW50LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIEV2ZW50IHR5cGUgbmFtZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgLSBBIGxpc3RlbmVyIGZ1bmN0aW9uIGdlbmVyYXRlZCB1c2luZyBfY3JlYXRlTGlzdGVuZXIuXG4gICAqL1xuICBfcmVtb3ZlTGlzdGVuZXIobWVzc2FnZSwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLl9kaXNwYXRjaGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICB0aGlzLl9jcmVhdGVMb2NhbE1lc3NhZ2UobWVzc2FnZSksXG4gICAgICBsaXN0ZW5lclxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSBhIGZ1bmN0aW9uIHdoZW4gYSBtZXNzYWdlIGlzIHJlY2VpdmVkIGZvciB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0byBsaXN0ZW4gZm9yLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgb25jZSB0aGUgbWVzc2FnZSBpcyByZWNlaXZlZC5cbiAgICovXG4gIGxpc3RlblRvKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGFkZCBsaXN0ZW5lciBmb3IgJHttZXNzYWdlfSBvbiAke3RoaXMuaWR9LiBDYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24uYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY2FsbGJhY2tzW21lc3NhZ2VdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX2NhbGxiYWNrc1ttZXNzYWdlXSA9IFtdO1xuICAgICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnNbbWVzc2FnZV0gPSBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBsaXN0ZW5lciA9IHRoaXMuX2NyZWF0ZUxpc3RlbmVyKGNhbGxiYWNrKTtcbiAgICB0aGlzLl9jYWxsYmFja3NbbWVzc2FnZV0ucHVzaChjYWxsYmFjayk7XG4gICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnNbbWVzc2FnZV0ucHVzaChsaXN0ZW5lcik7XG5cbiAgICB0aGlzLl9hZGRMaXN0ZW5lcihtZXNzYWdlLCBsaXN0ZW5lcik7XG4gIH1cblxuICAvKipcbiAgICogUHJldmVudCBhIGZ1bmN0aW9uIGZyb20gYmVpbmcgZXhlY3V0ZWQgd2hlbiBhIG1lc3NhZ2UgaXMgcmVjZWl2ZWQgZm9yIHRoaXNcbiAgICogb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIFRoZSBtZXNzYWdlIHRvIHN0b3AgbGlzdGVuaW5nIGZvci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGNhbGxiYWNrIC0gT3B0aW9uYWwgY2FsbGJhY2sgdG8gcmVtb3ZlLiBJZiBub25lIGlzIGRlZmluZWQsXG4gICAqIHJlbW92ZSBhbGwgY2FsbGJhY2tzIGZvciB0aGUgbWVzc2FnZS5cbiAgICovXG4gIHN0b3BMaXN0ZW5pbmcobWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5fY2FsbGJhY2tzW21lc3NhZ2VdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIElmIG5vIGNhbGxiYWNrIHdhcyBkZWZpbmVkLCBjYWxsIHN0b3BMaXN0ZW5pbmcgb24gYWxsIGNhbGxiYWNrcyBmb3IgdGhlIG1lc3NhZ2VcbiAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9jYWxsYmFja3NbbWVzc2FnZV0ubGVuZ3RoIC0gMTsgaSA+IC0xOyBpLS0pIHtcbiAgICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nKG1lc3NhZ2UsIHRoaXMuX2NhbGxiYWNrc1ttZXNzYWdlXVtpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiBhIGNhbGxiYWNrIHdhcyBkZWZpbmVkLCBtYWtlIHN1cmUgaXQncyBhIGxpc3RlbmVyXG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9jYWxsYmFja3NbbWVzc2FnZV0uaW5kZXhPZihjYWxsYmFjayk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGxpc3RlbmVyID0gdGhpcy5fZXZlbnRMaXN0ZW5lcnNbbWVzc2FnZV1baW5kZXhdO1xuICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVyKG1lc3NhZ2UsIGxpc3RlbmVyKTtcblxuICAgIHRoaXMuX2NhbGxiYWNrc1ttZXNzYWdlXS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJzW21lc3NhZ2VdLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICBpZiAodGhpcy5fY2FsbGJhY2tzW21lc3NhZ2VdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1ttZXNzYWdlXTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudExpc3RlbmVyc1ttZXNzYWdlXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGUtcmVnaXN0ZXIgY2FsbGJhY2socykgZnJvbSBiZWluZyBleGVjdXRlZCB3aGVuIG1lc3NhZ2VzIG1hdGNoaW5nIHRoZSBnaXZlblxuICAgKiByZWd1bGFyIGV4cHJlc3Npb24gYXJlIHJlY2VpdmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlZ2V4cH0gcmVnZXhwIC0gcmVnZXhwIC0gVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBmaWx0ZXIgbWVzc2FnZXMgd2l0aC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGNhbGxiYWNrIC0gT3B0aW9uYWwgY2FsbGJhY2sgdG8gcmVtb3ZlLiBJZiBub25lIGlzIGRlZmluZWQsXG4gICAqIHJlbW92ZSBhbGwgY2FsbGJhY2tzIGZvciBtZXNzYWdlcyBtYXRjaGluZyB0aGUgcmVndWxhciBleHByZXNzaW9uLlxuICAgKi9cbiAgc3RvcExpc3RlbmluZ0J5UmVnZXhwKHJlZ2V4cCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBtZXNzYWdlcyA9IE9iamVjdC5rZXlzKHRoaXMuX2NhbGxiYWNrcykuZmlsdGVyKG1lc3NhZ2UgPT5cbiAgICAgIHJlZ2V4cC50ZXN0KG1lc3NhZ2UpXG4gICAgKTtcblxuICAgIG1lc3NhZ2VzLmZvckVhY2gobWVzc2FnZSA9PiB7XG4gICAgICB0aGlzLnN0b3BMaXN0ZW5pbmcobWVzc2FnZSwgY2FsbGJhY2spO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXZlbnQgYW55IGZ1bmN0aW9ucyBmcm9tIGJlaW5nIGV4ZWN1dGVkIHdoZW4gYW55IG1lc3NhZ2UgaXMgcmVjZWl2ZWQgZm9yXG4gICAqIHRoaXMgb2JqZWN0LlxuICAgKi9cbiAgc3RvcExpc3RlbmluZ1RvQWxsKCkge1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gT2JqZWN0LmtleXModGhpcy5fY2FsbGJhY2tzKTtcblxuICAgIGZvciAobGV0IGkgPSBtZXNzYWdlcy5sZW5ndGggLSAxOyBpID4gLTE7IGktLSkge1xuICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nKG1lc3NhZ2VzW2ldKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIG1lc3NhZ2UsIGNhdXNpbmcgbGlzdGVuZXIgZnVuY3Rpb25zIGZvciB0aGUgbWVzc2FnZSBvbiB0aGlzIG9iamVjdFxuICAgKiB0byBiZSBleGVjdXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0byBlbWl0LlxuICAgKiBAcGFyYW0ge2FueT19IHZhbHVlIC0gT3B0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBsaXN0ZW5lciBjYWxsYmFja3MuXG4gICAqL1xuICBlbWl0KG1lc3NhZ2UsIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2NhbGxiYWNrc1ttZXNzYWdlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbWVzc2FnZSA9IHRoaXMuX2NyZWF0ZUxvY2FsTWVzc2FnZShtZXNzYWdlKTtcbiAgICBjb25zdCBldmVudCA9IHRoaXMuX2NyZWF0ZUV2ZW50KG1lc3NhZ2UsIHZhbHVlKTtcbiAgICB0aGlzLl9kaXNwYXRjaGVyLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBmdW5jdGlvbiB3aGVuIGEgbWVzc2FnZSBpcyByZWNlaXZlZCBmb3IgdGhlIGdsb2JhbCBNZXNzZW5nZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0byBsaXN0ZW4gZm9yLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgb25jZSB0aGUgbWVzc2FnZSBpcyByZWNlaXZlZC5cbiAgICovXG4gIHN0YXRpYyBsaXN0ZW5UbyhtZXNzYWdlLCBjYWxsYmFjaywgbWVzc2VuZ2VyKSB7XG4gICAgdGhpcy5HbG9iYWxNZXNzZW5nZXIubGlzdGVuVG8obWVzc2FnZSwgY2FsbGJhY2ssIG1lc3Nlbmdlcik7XG4gIH1cblxuICAvKipcbiAgICogUHJldmVudCBhIGZ1bmN0aW9uIGZyb20gYmVpbmcgZXhlY3V0ZWQgd2hlbiBhIG1lc3NhZ2UgaXMgcmVjZWl2ZWQgZm9yIHRoZVxuICAgKiBnbG9iYWwgTWVzc2VuZ2VyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gVGhlIG1lc3NhZ2UgdG8gc3RvcCBsaXN0ZW5pbmcgZm9yLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gY2FsbGJhY2sgLSBPcHRpb25hbCBjYWxsYmFjayB0byByZW1vdmUuIElmIG5vbmUgaXMgZGVmaW5lZCxcbiAgICogcmVtb3ZlIGFsbCBjYWxsYmFja3MgZm9yIHRoZSBtZXNzYWdlLlxuICAgKi9cbiAgc3RhdGljIHN0b3BMaXN0ZW5pbmcobWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLkdsb2JhbE1lc3Nlbmdlci5zdG9wTGlzdGVuaW5nKG1lc3NhZ2UsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZS1yZWdpc3RlciBjYWxsYmFjayhzKSBmcm9tIGJlaW5nIGV4ZWN1dGVkIG9uIHRoZSBnbG9iYWwgbWVzc2VuZ2VyciBpbnN0YW5jZVxuICAgKiB3aGVuIG1lc3NhZ2VzIG1hdGNoaW5nIHRoZSBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb24gYXJlIHJlY2VpdmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlZ2V4cH0gcmVnZXhwIC0gcmVnZXhwIC0gVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBmaWx0ZXIgbWVzc2FnZXMgd2l0aC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGNhbGxiYWNrIC0gT3B0aW9uYWwgY2FsbGJhY2sgdG8gcmVtb3ZlLiBJZiBub25lIGlzIGRlZmluZWQsXG4gICAqIHJlbW92ZSBhbGwgY2FsbGJhY2tzIGZvciBtZXNzYWdlcyBtYXRjaGluZyB0aGUgcmVndWxhciBleHByZXNzaW9uLlxuICAgKi9cbiAgc3RhdGljIHN0b3BMaXN0ZW5pbmdCeVJlZ2V4cChyZWdleHAsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgbWVzc2FnZXMgPSBPYmplY3Qua2V5cyhcbiAgICAgIHRoaXMuR2xvYmFsTWVzc2VuZ2VyLl9jYWxsYmFja3NcbiAgICApLmZpbHRlcihtZXNzYWdlID0+IHJlZ2V4cC50ZXN0KG1lc3NhZ2UpKTtcblxuICAgIG1lc3NhZ2VzLmZvckVhY2gobWVzc2FnZSA9PiB7XG4gICAgICB0aGlzLnN0b3BMaXN0ZW5pbmcobWVzc2FnZSwgY2FsbGJhY2spO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXZlbnQgYW55IGZ1bmN0aW9ucyBmcm9tIGJlaW5nIGV4ZWN1dGVkIHdoZW4gYW55IG1lc3NhZ2UgaXMgcmVjZWl2ZWQgZm9yXG4gICAqIHRoZSBnbG9iYWwgTWVzc2VuZ2VyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqL1xuICBzdGF0aWMgc3RvcExpc3RlbmluZ1RvQWxsKCkge1xuICAgIHRoaXMuR2xvYmFsTWVzc2VuZ2VyLnN0b3BMaXN0ZW5pbmdUb0FsbCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBtZXNzYWdlLCBjYXVzaW5nIGxpc3RlbmVyIGZ1bmN0aW9ucyBmb3IgdGhlIG1lc3NhZ2Ugb24gdGhlIGdsb2JhbCBNZXNzZW5nZXJcbiAgICogaW5zdGFuY2UgdG8gYmUgZXhlY3V0ZWQuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0byBlbWl0LlxuICAgKiBAcGFyYW0ge2FueT19IHZhbHVlIC0gT3B0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBsaXN0ZW5lciBjYWxsYmFja3MuXG4gICAqL1xuICBzdGF0aWMgZW1pdChtZXNzYWdlLCB2YWx1ZSkge1xuICAgIHRoaXMuR2xvYmFsTWVzc2VuZ2VyLmVtaXQobWVzc2FnZSwgdmFsdWUpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE1lc3Nlbmdlciwge1xuICBHbG9iYWxNZXNzZW5nZXI6IHtcbiAgICB2YWx1ZTogbmV3IE1lc3NlbmdlcigpLFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgfSxcbiAgRVZFTlRTOiB7XG4gICAgdmFsdWU6IHt9LFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgfSxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBNZXNzZW5nZXI7XG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxuaW1wb3J0IE1lc3NlbmdlciBmcm9tICdjb3JlL01lc3Nlbmdlcic7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIGhvc3QgZmVhdHVyZXMuIEtlZXBzIGEgcmVmZXJlbmNlIHRvIHRoZSBob3N0IG9iamVjdCBtYW5hZ2luZ1xuICogdGhlIGZlYXR1cmUuXG4gKlxuICogQGFic3RyYWN0XG4gKlxuICogQHByb3BlcnR5IHtPYmplY3R9IEVWRU5UUyAtIEJ1aWx0LWluIG1lc3NhZ2VzIHRoYXQgdGhlIGZlYXR1cmUgZW1pdHMuIFdoZW4gdGhlXG4gKiBmZWF0dXJlIGlzIGFkZGVkIHRvIGEge0BsaW5rIGNvcmUvSG9zdE9iamVjdH0sIGV2ZW50IG5hbWVzIHdpbGwgYmUgcHJlZml4ZWQgYnkgdGhlXG4gKiBuYW1lIG9mIHRoZSBmZWF0dXJlIGNsYXNzICsgJy4nLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVFMudXBkYXRlPW9uVXBkYXRlXSAtIE1lc3NhZ2UgdGhhdCBpcyBlbWl0dGVkIGFmdGVyXG4gKiBlYWNoIGNhbGwgdG8gW3VwZGF0ZV17QGxpbmsgQWJzdHJhY3RIb3N0RmVhdHVyZSN1cGRhdGV9LlxuICogQHByb3BlcnR5IHtPYmplY3R9IFNFUlZJQ0VTIC0gQW55IEFXUyBzZXJ2aWNlcyB0aGF0IGFyZSBuZWNlc3NhcnkgZm9yIHRoZVxuICogZmVhdHVyZSB0byBmdW5jdGlvbi5cbiAqL1xuY2xhc3MgQWJzdHJhY3RIb3N0RmVhdHVyZSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtIHtjb3JlL0hvc3RPYmplY3R9IGhvc3QgLSBUaGUgSG9zdE9iamVjdCBtYW5hZ2luZyB0aGUgZmVhdHVyZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGhvc3QpIHtcbiAgICB0aGlzLl9ob3N0ID0gaG9zdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgbmFtZXNwYWNlIHRvIHRoZSBob3N0IHdpdGggdGhlIG5hbWUgb2YgdGhlIGZlYXR1cmUgdG8gY29udGFpbiBwcm9wZXJ0aWVzXG4gICAqIGFuZCBtZXRob2RzIGZyb20gdGhlIGZlYXR1cmUgdGhhdCB1c2VycyBvZiB0aGUgaG9zdCBuZWVkIGFjY2VzcyB0by5cbiAgICovXG4gIGluc3RhbGxBcGkoKSB7XG4gICAgY29uc3QgZXZlbnRzID0ge307XG4gICAgY29uc3QgYXBpID0ge0VWRU5UUzogZXZlbnRzfTtcblxuICAgIC8vIEFkZCB0aGUgY2xhc3MgbmFtZSB0byBldmVudCBuYW1lc1xuICAgIE9iamVjdC5lbnRyaWVzKHRoaXMuY29uc3RydWN0b3IuRVZFTlRTKS5mb3JFYWNoKChbbmFtZSwgdmFsdWVdKSA9PiB7XG4gICAgICBldmVudHNbbmFtZV0gPSBgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9LiR7dmFsdWV9YDtcbiAgICB9KTtcblxuICAgIHRoaXMuX2hvc3RbdGhpcy5jb25zdHJ1Y3Rvci5uYW1lXSA9IGFwaTtcblxuICAgIHJldHVybiBhcGk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgaG9zdCB0aGF0IG1hbmFnZXMgdGhlIGZlYXR1cmUuXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGhvc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hvc3Q7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgZW5naW5lIG93bmVyIG9iamVjdCBvZiB0aGUgaG9zdC5cbiAgICpcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgb3duZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hvc3Qub3duZXI7XG4gIH1cblxuICAvKipcbiAgICogTGlzdGVuIHRvIGEgZmVhdHVyZSBtZXNzYWdlIGZyb20gdGhlIGhvc3Qgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIE1lc3NhZ2UgdG8gbGlzdGVuIGZvci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHRoZSBtZXNzYWdlIGlzIHJlY2VpdmVkLlxuICAgKi9cbiAgbGlzdGVuVG8obWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl9ob3N0Lmxpc3RlblRvKG1lc3NhZ2UsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gYSBmZWF0dXJlIG1lc3NhZ2UgZnJvbSB0aGUgZ2xvYmFsIG1lc3Nlbmdlci4gRmVhdHVyZSBtZXNzYWdlcyB3aWxsXG4gICAqIGJlIHByZWZpeGVkIHdpdGggdGhlIGNsYXNzIG5hbWUgb2YgdGhlIGZlYXR1cmUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gTWVzc2FnZSB0byBsaXN0ZW4gZm9yLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gdGhlIG1lc3NhZ2UgaXMgcmVjZWl2ZWQuXG4gICAqL1xuICBzdGF0aWMgbGlzdGVuVG8obWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICBtZXNzYWdlID0gYCR7dGhpcy5uYW1lfS4ke21lc3NhZ2V9YDtcbiAgICBNZXNzZW5nZXIubGlzdGVuVG8obWVzc2FnZSwgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgbGlzdGVuaW5nIHRvIGEgbWVzc2FnZSBmcm9tIHRoZSBob3N0IG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBNZXNzYWdlIHRvIHN0b3AgbGlzdGVuaW5nIGZvci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGNhbGxiYWNrIC0gT3B0aW9uYWwgY2FsbGJhY2sgdG8gcmVtb3ZlLiBJZiBub25lIGlzIGRlZmluZWQsXG4gICAqIHJlbW92ZSBhbGwgY2FsbGJhY2tzIGZvciB0aGUgbWVzc2FnZS5cbiAgICovXG4gIHN0b3BMaXN0ZW5pbmcobWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl9ob3N0LnN0b3BMaXN0ZW5pbmcobWVzc2FnZSwgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgbGlzdGVuaW5nIHRvIGEgbWVzc2FnZSBmcm9tIHRoZSBnbG9iYWwgbWVzc2VuZ2VyLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIE1lc3NhZ2UgdG8gc3RvcCBsaXN0ZW5pbmcgZm9yLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gY2FsbGJhY2sgLSBPcHRpb25hbCBjYWxsYmFjayB0byByZW1vdmUuIElmIG5vbmUgaXMgZGVmaW5lZCxcbiAgICogcmVtb3ZlIGFsbCBjYWxsYmFja3MgZm9yIHRoZSBtZXNzYWdlLlxuICAgKi9cbiAgc3RhdGljIHN0b3BMaXN0ZW5pbmcobWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICBtZXNzYWdlID0gYCR7dGhpcy5uYW1lfS4ke21lc3NhZ2V9YDtcbiAgICBNZXNzZW5nZXIuc3RvcExpc3RlbmluZyhtZXNzYWdlLCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCBsaXN0ZW5pbmcgdG8gYSBtZXNzYWdlIG1hdGNoaW5nIHRoZSBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb24gZnJvbSB0aGVcbiAgICogaG9zdCBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVnZXhwfSByZWdleHAgLSBUaGUgcmVndWxhciBleHByZXNzaW9uIHRvIHN0b3AgbGlzdGVuaW5nIGZvci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGNhbGxiYWNrIC0gT3B0aW9uYWwgY2FsbGJhY2sgdG8gcmVtb3ZlLiBJZiBub25lIGlzIGRlZmluZWQsXG4gICAqIHJlbW92ZSBhbGwgY2FsbGJhY2tzIGZvciB0aGUgbWVzc2FnZS5cbiAgICovXG4gIHN0b3BMaXN0ZW5pbmdCeVJlZ2V4cChyZWdleHAsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5faG9zdC5zdG9wTGlzdGVuaW5nQnlSZWdleHAocmVnZXhwLCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCBsaXN0ZW5pbmcgdG8gYSBtZXNzYWdlIG1hdGNoaW5nIHRoZSBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb24gZnJvbSB0aGVcbiAgICogZ2xvYmFsIG1lc3Nlbmdlci5cbiAgICpcbiAgICogQHBhcmFtIHtSZWdleHB9IHJlZ2V4cCAtIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gdG8gc3RvcCBsaXN0ZW5pbmcgZm9yLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gY2FsbGJhY2sgLSBPcHRpb25hbCBjYWxsYmFjayB0byByZW1vdmUuIElmIG5vbmUgaXMgZGVmaW5lZCxcbiAgICogcmVtb3ZlIGFsbCBjYWxsYmFja3MgZm9yIHRoZSBtZXNzYWdlLlxuICAgKi9cbiAgc3RhdGljIHN0b3BMaXN0ZW5pbmdCeVJlZ2V4cChyZWdleHAsIGNhbGxiYWNrKSB7XG4gICAgcmVnZXhwID0gbmV3IFJlZ0V4cChgXiR7dGhpcy5uYW1lfS4ke3JlZ2V4cC5zb3VyY2UucmVwbGFjZSgvXFxeLywgJycpfWApO1xuICAgIE1lc3Nlbmdlci5zdG9wTGlzdGVuaW5nQnlSZWdleHAocmVnZXhwLCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCBsaXN0ZW5pbmcgdG8gYWxsIG1lc3NhZ2VzLlxuICAgKi9cbiAgc3RvcExpc3RlbmluZ1RvQWxsKCkge1xuICAgIHRoaXMuX2hvc3Quc3RvcExpc3RlbmluZ1RvQWxsKCk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCBsaXN0ZW5pbmcgdG8gYWxsIGZlYXR1cmUgbWVzc2FnZXMuXG4gICAqL1xuICBzdGF0aWMgc3RvcExpc3RlbmluZ1RvQWxsKCkge1xuICAgIE1lc3Nlbmdlci5zdG9wTGlzdGVuaW5nQnlSZWdleHAobmV3IFJlZ0V4cChgXiR7dGhpcy5uYW1lfS5gKSk7XG4gIH1cblxuICAvKipcbiAgICogRW1pdCBmZWF0dXJlIG1lc3NhZ2VzIGZyb20gdGhlIGhvc3QuIEZlYXR1cmUgbWVzc2FnZXMgd2lsbCBiZSBwcmVmaXhlZCB3aXRoXG4gICAqIHRoZSBjbGFzcyBuYW1lIG9mIHRoZSBmZWF0dXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIFRoZSBtZXNzYWdlIHRvIGVtaXQuXG4gICAqIEBwYXJhbSB7YW55PX0gdmFsdWUgLSBPcHRpb25hbCBwYXJhbWV0ZXIgdG8gcGFzcyB0byBsaXN0ZW5lciBjYWxsYmFja3MuXG4gICAqL1xuICBlbWl0KG1lc3NhZ2UsIHZhbHVlKSB7XG4gICAgbWVzc2FnZSA9IGAke3RoaXMuY29uc3RydWN0b3IubmFtZX0uJHttZXNzYWdlfWA7XG4gICAgdGhpcy5faG9zdC5lbWl0KG1lc3NhZ2UsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0IGZlYXR1cmUgbWVzc2FnZXMgZnJvbSB0aGUgZ2xvYmFsIG1lc3Nlbmdlci4gRmVhdHVyZSBtZXNzYWdlcyB3aWxsIGJlIHByZWZpeGVkXG4gICAqIHdpdGggdGhlIGNsYXNzIG5hbWUgb2YgdGhlIGZlYXR1cmUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gVGhlIG1lc3NhZ2UgdG8gZW1pdC5cbiAgICogQHBhcmFtIHthbnk9fSB2YWx1ZSAtIE9wdGlvbmFsIHBhcmFtZXRlciB0byBwYXNzIHRvIGxpc3RlbmVyIGNhbGxiYWNrcy5cbiAgICovXG4gIHN0YXRpYyBlbWl0KG1lc3NhZ2UsIHZhbHVlKSB7XG4gICAgbWVzc2FnZSA9IGAke3RoaXMubmFtZX0uJHttZXNzYWdlfWA7XG4gICAgTWVzc2VuZ2VyLmVtaXQobWVzc2FnZSwgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGVhY2ggdGltZSB0aGUgaG9zdCBpcyB1cGRhdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFUaW1lIC0gQW1vdW50IG9mIHRpbWUgc2luY2UgdGhlIGxhc3QgaG9zdCB1cGRhdGUgd2FzXG4gICAqIGNhbGxlZC5cbiAgICovXG4gIHVwZGF0ZShkZWx0YVRpbWUpIHtcbiAgICB0aGlzLmVtaXQodGhpcy5jb25zdHJ1Y3Rvci5FVkVOVFMudXBkYXRlLCBkZWx0YVRpbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwIG9uY2UgdGhlIGZlYXR1cmUgaXMgbm8gbG9uZ2VyIGluIHVzZS4gUmVtb3ZlIHRoZSBmZWF0dXJlIG5hbWVzcGFjZVxuICAgKiBmcm9tIHRoZSBob3N0IGFuZCByZW1vdmUgcmVmZXJlbmNlIHRvIHRoZSBob3N0LlxuICAgKi9cbiAgZGlzY2FyZCgpIHtcbiAgICBPYmplY3Qua2V5cyh0aGlzLl9ob3N0W3RoaXMuY29uc3RydWN0b3IubmFtZV0pLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICBkZWxldGUgdGhpcy5faG9zdFt0aGlzLmNvbnN0cnVjdG9yLm5hbWVdW25hbWVdO1xuICAgIH0pO1xuXG4gICAgZGVsZXRlIHRoaXMuX2hvc3RbdGhpcy5jb25zdHJ1Y3Rvci5uYW1lXTtcbiAgICBkZWxldGUgdGhpcy5faG9zdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIGEgc2VxdWVuY2Ugb2YgbWl4aW4gY2xhc3MgZmFjdG9yeSBmdW5jdGlvbnMgdG8gdGhpcyBjbGFzcyBhbmRcbiAgICogcmV0dXJucyB0aGUgcmVzdWx0LiBFYWNoIGZ1bmN0aW9uIGlzIGV4cGVjdGVkIHRvIHJldHVybiBhIGNsYXNzIHRoYXRcbiAgICogZXh0ZW5kcyB0aGUgY2xhc3MgaXQgd2FzIGdpdmVuLiBUaGUgZnVuY3Rpb25zIGFyZSBhcHBsaWVkIGluIHRoZSBvcmRlclxuICAgKiB0aGF0IHBhcmFtZXRlcnMgYXJlIGdpdmVuLCBtZWFuaW5nIHRoYXQgdGhlIGZpcnN0IGZhY3Rvcnkgd2lsbFxuICAgKiBleHRlbmQgdGhpcyBiYXNlIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBtaXhpbkNsYXNzRmFjdG9yaWVzIENsYXNzIGZhY3RvcnkgZnVuY3Rpb25zIHRoYXQgd2lsbFxuICAgKiBiZSBhcHBsaWVkLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q2xhc3N9IEEgY2xhc3MgdGhhdCBpcyB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZSBmYWN0b3J5IGZ1bmN0aW9ucy5cbiAgICogVGhlIHJlc3VsdGluZyBjbGFzcyB3aWxsIGFsd2F5cyBpbmhlcml0IGZyb20gQWJzdHJhY3RIb3N0RmVhdHVyZS5cbiAgICovXG4gIHN0YXRpYyBtaXgoLi4ubWl4aW5DbGFzc0ZhY3Rvcmllcykge1xuICAgIGxldCBSZXN1bHRDbGFzcyA9IHRoaXM7XG5cbiAgICBtaXhpbkNsYXNzRmFjdG9yaWVzLmZvckVhY2gobWl4aW5DbGFzc0ZhY3RvcnkgPT4ge1xuICAgICAgUmVzdWx0Q2xhc3MgPSBtaXhpbkNsYXNzRmFjdG9yeShSZXN1bHRDbGFzcyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gUmVzdWx0Q2xhc3M7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQWJzdHJhY3RIb3N0RmVhdHVyZSwge1xuICBFVkVOVFM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgdXBkYXRlOiAnb25VcGRhdGUnLFxuICAgIH0sXG4gICAgd3JpdGFibGU6IGZhbHNlLFxuICB9LFxuICBTRVJWSUNFUzoge1xuICAgIHZhbHVlOiB7fSxcbiAgICB3cml0YWJsZTogZmFsc2UsXG4gIH0sXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQWJzdHJhY3RIb3N0RmVhdHVyZTtcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXG5pbXBvcnQgTWVzc2VuZ2VyIGZyb20gJ2NvcmUvTWVzc2VuZ2VyJztcbmltcG9ydCBBYnN0cmFjdEhvc3RGZWF0dXJlIGZyb20gJy4vQWJzdHJhY3RIb3N0RmVhdHVyZSc7XG5pbXBvcnQgVXRpbHMgZnJvbSAnLi9VdGlscyc7XG5cbi8qKlxuICogT2JqZWN0IHRoYXQgbWFuYWdlcyBhY2Nlc3MgdG8gYWxsIEhvc3QgZmVhdHVyZXMuIENvbnRhaW5zIGEgcmVmZXJlbmNlIHRvXG4gKiBlbmdpbmUtc3BlY2lmaWMgdmlzdWFscyBpZiBhcHBsaWNhYmxlLlxuICpcbiAqIEBleHRlbmRzIGNvcmUvTWVzc2VuZ2VyXG4gKiBAYWxpYXMgY29yZS9Ib3N0T2JqZWN0XG4gKlxuICogQHByb3BlcnR5IHtPYmplY3R9IEVWRU5UUyAtIEJ1aWx0LWluIG1lc3NhZ2VzIHRoYXQgdGhlIE1lc3NlbmdlciBlbWl0cy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLnVwZGF0ZT0nb25VcGRhdGUnXSAtIE1lc3NhZ2UgdGhhdCBpcyBlbWl0dGVkIGFmdGVyXG4gKiBlYWNoIGNhbGwgdG8gW3VwZGF0ZV17QGxpbmsgY29yZS9Ib3N0T2JqZWN0I3VwZGF0ZX0uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UUy5hZGRGZWF0dXJlPSdvbkFkZEZlYXR1cmUnXSAtIE1lc3NhZ2UgdGhhdCBpcyBlbWl0dGVkXG4gKiBhZnRlciBlYWNoIGNhbGwgdG8gW2FkZEZlYXR1cmVde0BsaW5rIGNvcmUvSG9zdE9iamVjdCNhZGRGZWF0dXJlfS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLnJlbW92ZUZlYXR1cmU9J29uUmVtb3ZlRmVhdHVyZSddIC0gTWVzc2FnZSB0aGF0IGlzIGVtaXR0ZWRcbiAqIGFmdGVyIGVhY2ggY2FsbCB0byBbcmVtb3ZlRmVhdHVyZV17QGxpbmsgY29yZS9Ib3N0T2JqZWN0I3JlbW92ZUZlYXR1cmV9LlxuICovXG5jbGFzcyBIb3N0T2JqZWN0IGV4dGVuZHMgTWVzc2VuZ2VyIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgaG9zdC5cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zLm93bmVyIC0gT3B0aW9uYWwgZW5naW5lLXNwZWNpZmljIG93bmVyIG9mIHRoZSBob3N0LlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe293bmVyID0ge319ID0ge30pIHtcbiAgICAvLyBJZiBhbiBvd25lciBpcyBzcGVjaWZpZWQsIHVzZSBpdHMgaWQgZm9yIG1lc3NhZ2luZ1xuICAgIHN1cGVyKG93bmVyLmlkKTtcblxuICAgIHRoaXMuX293bmVyID0gb3duZXI7XG4gICAgdGhpcy5fZmVhdHVyZXMgPSB7fTtcbiAgICB0aGlzLl93YWl0cyA9IFtdO1xuICAgIHRoaXMuX2xhc3RVcGRhdGUgPSB0aGlzLm5vdztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBlbmdpbmUgb3duZXIgb2JqZWN0IG9mIHRoZSBob3N0LlxuICAgKlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGdldCBvd25lcigpIHtcbiAgICByZXR1cm4gdGhpcy5fb3duZXI7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCB0aW1lIGluIG1pbGxpc2Vjb25kcy5cbiAgICpcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbm93KCkge1xuICAgIHJldHVybiBEYXRlLm5vdygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGFtb3VudCBvZiB0aW1lIGluIG1pbGxpc2Vjb25kcyBzaW5jZSB1cGRhdGUgd2FzIGxhc3QgY2FsbGVkLlxuICAgKlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBkZWx0YVRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubm93IC0gdGhpcy5fbGFzdFVwZGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgaW4gdGhlIGVuZ2luZSdzIHJlbmRlciBsb29wLiBFeGVjdXRlcyB1cGRhdGVcbiAgICogbG9vcHMgZm9yIGFsbCBmZWF0dXJlcy5cbiAgICovXG4gIHVwZGF0ZSgpIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IHRoaXMubm93O1xuICAgIGNvbnN0IGR0ID0gdGhpcy5kZWx0YVRpbWU7XG5cbiAgICAvLyBQcm9ncmVzcyBzdG9yZWQgd2FpdHNcbiAgICB0aGlzLl93YWl0cy5mb3JFYWNoKHdhaXQgPT4ge1xuICAgICAgd2FpdC5leGVjdXRlKGR0KTtcbiAgICB9KTtcblxuICAgIC8vIFVwZGF0ZSBhbGwgZmVhdHVyZXNcbiAgICBPYmplY3QudmFsdWVzKHRoaXMuX2ZlYXR1cmVzKS5mb3JFYWNoKGZlYXR1cmUgPT4ge1xuICAgICAgZmVhdHVyZS51cGRhdGUoZHQpO1xuICAgIH0pO1xuXG4gICAgLy8gTm90aWZ5IGxpc3RlbmVycyBhbiB1cGRhdGUgb2NjdXJlZFxuICAgIHRoaXMuZW1pdCh0aGlzLmNvbnN0cnVjdG9yLkVWRU5UUy51cGRhdGUsIGR0KTtcblxuICAgIHRoaXMuX2xhc3RVcGRhdGUgPSBjdXJyZW50VGltZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBkZWZlcnJlZCBwcm9taXNlIHRoYXQgd2lsbCB3YWl0IGEgZ2l2ZW4gbnVtYmVyIG9mIHNlY29uZHMgYmVmb3JlXG4gICAqIHJlc29sdmluZy4gVGhlIGhvc3Qgd2lsbCBjb250aW51b3VzbHkgdXBkYXRlIHRoZSB3YWl0IHByb21pc2UgZHVyaW5nIHRoZVxuICAgKiB1cGRhdGUgbG9vcCB1bnRpbCBpdCByZXNvbHZlcy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzZWNvbmRzPTBdIC0gTnVtYmVyIG9mIHNlY29uZHMgdG8gd2FpdCBiZWZvcmUgcmVzb2x2aW5nLlxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgLSBPcHRpb25hbCBvcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbkZpbmlzaF0gLSBDYWxsYmFjayB0byBleGVjdXRlIG9uY2UgdGhlIHdhaXQgdGltZVxuICAgKiBpcyBtZXQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvcHRpb25zLm9uUHJvZ3Jlc3MgLSBDYWxsYmFjayB0byBleGVjdXRlIGVhY2ggdGltZSB0aGUgd2FpdFxuICAgKiB0aW1lIHByb2dyZXNzZXMgdG93YXJkcyB0aGUgdGFyZ2V0IG51bWJlciBvZiBzZWNvbmRzLiBUaGUgYW1vdW50IG9mIHByb2dyZXNzXG4gICAqIGFzIGEgMC0xIHBlcmNlbnRhZ2UgaXMgcGFzc2VkIGFzIGFuIGFyZ3VtZW50LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb3B0aW9ucy5vbkNhbmNlbCAtIENhbGxiYWNrIHRvIGV4ZWN1dGUgaWYgdGhlIHVzZXIgY2FuY2Vsc1xuICAgKiB0aGUgd2FpdCBiZWZvcmUgY29tcGxldGlvbi5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9wdGlvbnMub25FcnJvciAtIENhbGxiYWNrIHRvIGV4ZWN1dGUgaWYgdGhlIHdhaXQgc3RvcHNcbiAgICogYmVjYXVzZSBhbiBlcnJvciBpcyBlbmNvdW50ZXJlZC4gVGhlIGVycm9yIG1lc3NhZ2UgaXMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9XG4gICAqL1xuICB3YWl0KHNlY29uZHMsIHtvbkZpbmlzaCwgb25Qcm9ncmVzcywgb25DYW5jZWwsIG9uRXJyb3J9ID0ge30pIHtcbiAgICBjb25zdCB3YWl0ID0gVXRpbHMud2FpdChzZWNvbmRzLCB7b25GaW5pc2gsIG9uUHJvZ3Jlc3MsIG9uQ2FuY2VsLCBvbkVycm9yfSk7XG4gICAgdGhpcy5fd2FpdHMucHVzaCh3YWl0KTtcblxuICAgIC8vIE9uY2UgdGhlIHdhaXQgcHJvbWlzZSBpcyBubyBsb25nZXIgcGVuZGluZyByZW1vdmUgaXQgZnJvbSB0aGUgd2FpdHMgYXJyYXlcbiAgICBjb25zdCBvbkNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgdGhpcy5fd2FpdHMuc3BsaWNlKHRoaXMuX3dhaXRzLmluZGV4T2Yod2FpdCksIDEpO1xuICAgIH07XG4gICAgd2FpdC50aGVuKG9uQ29tcGxldGUsIG9uQ29tcGxldGUpO1xuXG4gICAgcmV0dXJuIHdhaXQ7XG4gIH1cblxuICAvKipcbiAgICogSW5zdGFudGlhdGUgYSBuZXcgSG9zdCBmZWF0dXJlIGFuZCBzdG9yZSBpdC4gRmVhdHVyZXMgbXVzdCBpbmhlcml0IGZyb21cbiAgICogQWJzdHJhY3RIb3N0RmVhdHVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtDbGFzc30gRmVhdHVyZUNsYXNzIC0gQ2xhc3MgdGhhdCB3aWxsIGluc3RhbnRpYXRlIHRoZSBmZWF0dXJlLiBNdXN0XG4gICAqIGV4dGVuZCB7QGxpbmsgQWJzdHJhY3RIb3N0RmVhdHVyZX0uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlPWZhbHNlXSAtIFdoZXRoZXIgb3Igbm90IHRvIG92ZXJ3cml0ZSBhbiBleGlzdGluZ1xuICAgKiBmZWF0dXJlIGlmIG9uZSBvZiB0aGlzIHR5cGUgYWxyZWFkeSBleGlzdHMgb24gdGhlIG9iamVjdC5cbiAgICogQHBhcmFtICB7Li4uYW55fSBhcmdzIC0gQWRkaXRpb25hbCBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgRmVhdHVyZUNsYXNzXG4gICAqIGNvbnN0cnVjdG9yLiBUaGUgSG9zdE9iamVjdCB3aWxsIGFsd2F5cyBiZSBwYXNzZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBXaGV0aGVyIG9yIG5vdCBhIGZlYXR1cmUgd2FzIHN1Y2Nlc3NmdWxseSBhZGRlZC5cbiAgICovXG4gIGFkZEZlYXR1cmUoRmVhdHVyZUNsYXNzLCBmb3JjZSA9IGZhbHNlLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgaW5wdXRUeXBlID0gdHlwZW9mIEZlYXR1cmVDbGFzcztcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgRmVhdHVyZUNsYXNzIGNhbiBiZSBleGVjdXRlZFxuICAgIGlmIChpbnB1dFR5cGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBhZGQgZmVhdHVyZSB0byBob3N0ICR7dGhpcy5pZH0uIEZlYXR1cmVDbGFzcyBtdXN0IGJlIGEgY2xhc3MuYFxuICAgICAgKTtcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBmZWF0dXJlIGlzIGEgaG9zdCBmZWF0dXJlXG4gICAgZWxzZSBpZiAoIShGZWF0dXJlQ2xhc3MucHJvdG90eXBlIGluc3RhbmNlb2YgQWJzdHJhY3RIb3N0RmVhdHVyZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBhZGQgZmVhdHVyZSAke0ZlYXR1cmVDbGFzcy5uYW1lfSB0byBob3N0ICR7dGhpcy5pZH0uIEZlYXR1cmVDbGFzcyBtdXN0IGV4dGVuZCBBYnN0cmFjdEhvc3RGZWF0dXJlLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIEZlYXR1cmVDbGFzcyBhbHJlYWR5IGV4aXN0cyBvbiB0aGlzIG9iamVjdFxuICAgIGlmICh0aGlzLl9mZWF0dXJlc1tGZWF0dXJlQ2xhc3MubmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgRmVhdHVyZSAke0ZlYXR1cmVDbGFzcy5uYW1lfSBhbHJlYWR5IGV4aXN0cyBvbiBob3N0ICR7dGhpcy5pZH0uIEV4aXN0aW5nIGZlYXR1cmUgd2lsbCBiZSBvdmVyd3JpdHRlbi5gXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEZlYXR1cmUgJHtGZWF0dXJlQ2xhc3MubmFtZX0gYWxyZWFkeSBleGlzdHMgb24gaG9zdCAke3RoaXMuaWR9LiBVc2UgJ2ZvcmNlJyBhcmd1bWVudCB0byBvdmVyd3JpdGUgdGhlIGZlYXR1cmUuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgdGhlIGZlYXR1cmVcbiAgICBjb25zdCBmZWF0dXJlID0gbmV3IEZlYXR1cmVDbGFzcyh0aGlzLCAuLi5hcmdzKTtcbiAgICBmZWF0dXJlLmluc3RhbGxBcGkoKTtcblxuICAgIHRoaXMuX2ZlYXR1cmVzW0ZlYXR1cmVDbGFzcy5uYW1lXSA9IGZlYXR1cmU7XG4gICAgdGhpcy5lbWl0KHRoaXMuY29uc3RydWN0b3IuRVZFTlRTLmFkZEZlYXR1cmUsIEZlYXR1cmVDbGFzcy5uYW1lKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGZlYXR1cmUgZnJvbSB0aGUgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZU5hbWUgLSBOYW1lIG9mIHRoZSB0eXBlIG9mIGZlYXR1cmUgdG8gcmVtb3ZlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBXaGV0aGVyIG9yIG5vdCBhIGZlYXR1cmUgd2FzIHN1Y2Nlc3NmdWxseSByZW1vdmVkLlxuICAgKi9cbiAgcmVtb3ZlRmVhdHVyZSh0eXBlTmFtZSkge1xuICAgIGlmICh0aGlzLl9mZWF0dXJlc1t0eXBlTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgRmVhdHVyZSBvZiB0eXBlICR7dHlwZU5hbWV9IGRvZXMgbm90IGV4aXN0IG9uIGhvc3QgJHt0aGlzLmlkfS4gTm8gZmVhdHVyZSB3aWxsIGJlIHJlbW92ZWQuYFxuICAgICAgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVtb3ZlIHRoZSBmZWF0dXJlXG4gICAgICB0aGlzLmVtaXQodGhpcy5jb25zdHJ1Y3Rvci5FVkVOVFMucmVtb3ZlRmVhdHVyZSwgdHlwZU5hbWUpO1xuICAgICAgdGhpcy5fZmVhdHVyZXNbdHlwZU5hbWVdLmRpc2NhcmQoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9mZWF0dXJlc1t0eXBlTmFtZV07XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZSB3aGV0aGVyIGEgc3BlY2lmaWVkIGZlYXR1cmUgaXMgaW5zdGFsbGVkIG9uIHRoZSBob3N0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZU5hbWUgLSBOYW1lIG9mIHRoZSB0eXBlIG9mIGZlYXR1cmUgdG8gbG9vayBmb3IuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaGFzRmVhdHVyZSh0eXBlTmFtZSkge1xuICAgIHJldHVybiAhIXRoaXMuX2ZlYXR1cmVzW3R5cGVOYW1lXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0IHRoZSBuYW1lcyBvZiB0aGUgZmVhdHVyZXMgaW5zdGFsbGVkIG9uIHRoZSBob3N0LlxuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZz59XG4gICAqL1xuICBsaXN0RmVhdHVyZXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2ZlYXR1cmVzKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSG9zdE9iamVjdCwgJ0VWRU5UUycsIHtcbiAgdmFsdWU6IHtcbiAgICAuLi5PYmplY3QuZ2V0UHJvdG90eXBlT2YoSG9zdE9iamVjdCkuRVZFTlRTLFxuICAgIHVwZGF0ZTogJ29uVXBkYXRlJyxcbiAgICBhZGRGZWF0dXJlOiAnb25BZGRGZWF0dXJlJyxcbiAgICByZW1vdmVGZWF0dXJlOiAnb25SZW1vdmVGZWF0dXJlJyxcbiAgfSxcbiAgd3JpdGFibGU6IGZhbHNlLFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEhvc3RPYmplY3Q7XG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBFYXNpbmdPYmplY3QgT2JqZWN0IGNvbnRhaW5pbmcgZWFzaW5nIGZ1bmN0aW9uc1xuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gSW4gLSBFYXNpbmcgJ0luJyBmdW5jdGlvbi4gU2hvdWxkIHVzZSB0aGUgc2lnbmF0dXJlIChrOm51bWJlcik6bnVtYmVyLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gT3V0IC0gRWFzaW5nICdPdXQnIGZ1bmN0aW9uLiBTaG91bGQgdXNlIHRoZSBzaWduYXR1cmUgKGs6bnVtYmVyKTpudW1iZXIuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBJbk91dCAtIEVhc2luZyAnSW5PdXQnIGZ1bmN0aW9uLiBTaG91bGQgdXNlIHRoZSBzaWduYXR1cmUgKGs6bnVtYmVyKTpudW1iZXIuXG4gKi9cblxuLyoqXG4gKiBMaW5lYXIgRWFzaW5nXG4gKiBAdHlwZSB7RWFzaW5nT2JqZWN0fVxuICovXG5leHBvcnQgY29uc3QgTGluZWFyID0ge1xuICBOb25lKGspIHtcbiAgICByZXR1cm4gaztcbiAgfSxcbiAgSW4oaykge1xuICAgIHJldHVybiBrO1xuICB9LFxuICBPdXQoaykge1xuICAgIHJldHVybiBrO1xuICB9LFxuICBJbk91dChrKSB7XG4gICAgcmV0dXJuIGs7XG4gIH0sXG59O1xuXG4vKipcbiAqIFF1YWRyYXRpYyBFYXNpbmdcbiAqIEB0eXBlIHtFYXNpbmdPYmplY3R9XG4gKi9cbmV4cG9ydCBjb25zdCBRdWFkcmF0aWMgPSB7XG4gIEluKGspIHtcbiAgICByZXR1cm4gayAqIGs7XG4gIH0sXG4gIE91dChrKSB7XG4gICAgcmV0dXJuIGsgKiAoMiAtIGspO1xuICB9LFxuICBJbk91dChrKSB7XG4gICAgayAqPSAyO1xuICAgIGlmIChrIDwgMSkge1xuICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrO1xuICAgIH1cbiAgICByZXR1cm4gLTAuNSAqICgtLWsgKiAoayAtIDIpIC0gMSk7XG4gIH0sXG59O1xuXG4vKipcbiAqIEN1YmljIEVhc2luZ1xuICogQHR5cGUge0Vhc2luZ09iamVjdH1cbiAqL1xuZXhwb3J0IGNvbnN0IEN1YmljID0ge1xuICBJbihrKSB7XG4gICAgcmV0dXJuIGsgKiBrICogaztcbiAgfSxcbiAgT3V0KGspIHtcbiAgICByZXR1cm4gLS1rICogayAqIGsgKyAxO1xuICB9LFxuICBJbk91dChrKSB7XG4gICAgayAqPSAyO1xuICAgIGlmIChrIDwgMSkge1xuICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogaztcbiAgICB9XG5cbiAgICBrIC09IDI7XG4gICAgcmV0dXJuIDAuNSAqIChrICogayAqIGsgKyAyKTtcbiAgfSxcbn07XG5cbi8qKlxuICogUXVhcnRpYyBFYXNpbmdcbiAqIEB0eXBlIHtFYXNpbmdPYmplY3R9XG4gKi9cbmV4cG9ydCBjb25zdCBRdWFydGljID0ge1xuICBJbihrKSB7XG4gICAgcmV0dXJuIGsgKiBrICogayAqIGs7XG4gIH0sXG4gIE91dChrKSB7XG4gICAgcmV0dXJuIDEgLSAtLWsgKiBrICogayAqIGs7XG4gIH0sXG4gIEluT3V0KGspIHtcbiAgICBrICo9IDI7XG4gICAgaWYgKGsgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrICogaztcbiAgICB9XG5cbiAgICBrIC09IDI7XG4gICAgcmV0dXJuIC0wLjUgKiAoayAqIGsgKiBrICogayAtIDIpO1xuICB9LFxufTtcblxuLyoqXG4gKiBRdWludGljIEVhc2luZ1xuICogQHR5cGUge0Vhc2luZ09iamVjdH1cbiAqL1xuZXhwb3J0IGNvbnN0IFF1aW50aWMgPSB7XG4gIEluKGspIHtcbiAgICByZXR1cm4gayAqIGsgKiBrICogayAqIGs7XG4gIH0sXG4gIE91dChrKSB7XG4gICAgcmV0dXJuIC0tayAqIGsgKiBrICogayAqIGsgKyAxO1xuICB9LFxuICBJbk91dChrKSB7XG4gICAgayAqPSAyO1xuICAgIGlmIChrIDwgMSkge1xuICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogayAqIGsgKiBrO1xuICAgIH1cblxuICAgIGsgLT0gMjtcbiAgICByZXR1cm4gMC41ICogKGsgKiBrICogayAqIGsgKiBrICsgMik7XG4gIH0sXG59O1xuXG4vKipcbiAqIFNpbnVzb2lkYWwgRWFzaW5nXG4gKiBAdHlwZSB7RWFzaW5nT2JqZWN0fVxuICovXG5leHBvcnQgY29uc3QgU2ludXNvaWRhbCA9IHtcbiAgSW4oaykge1xuICAgIHJldHVybiAxIC0gTWF0aC5jb3MoKGsgKiBNYXRoLlBJKSAvIDIpO1xuICB9LFxuICBPdXQoaykge1xuICAgIHJldHVybiBNYXRoLnNpbigoayAqIE1hdGguUEkpIC8gMik7XG4gIH0sXG4gIEluT3V0KGspIHtcbiAgICByZXR1cm4gMC41ICogKDEgLSBNYXRoLmNvcyhNYXRoLlBJICogaykpO1xuICB9LFxufTtcblxuLyoqXG4gKiBFeHBvbmVudGlhbCBFYXNpbmdcbiAqIEB0eXBlIHtFYXNpbmdPYmplY3R9XG4gKi9cbmV4cG9ydCBjb25zdCBFeHBvbmVudGlhbCA9IHtcbiAgSW4oaykge1xuICAgIHJldHVybiBrID09PSAwID8gMCA6IDEwMjQgKiogKGsgLSAxKTtcbiAgfSxcbiAgT3V0KGspIHtcbiAgICByZXR1cm4gayA9PT0gMSA/IDEgOiAxIC0gMiAqKiAoLTEwICogayk7XG4gIH0sXG4gIEluT3V0KGspIHtcbiAgICBpZiAoayA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmIChrID09PSAxKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBrICo9IDI7XG4gICAgaWYgKGsgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogMTAyNCAqKiAoayAtIDEpO1xuICAgIH1cbiAgICByZXR1cm4gMC41ICogKC0oMiAqKiAoLTEwICogKGsgLSAxKSkpICsgMik7XG4gIH0sXG59O1xuXG4vKipcbiAqIENpcmN1bGFyIEVhc2luZ1xuICogQHR5cGUge0Vhc2luZ09iamVjdH1cbiAqL1xuZXhwb3J0IGNvbnN0IENpcmN1bGFyID0ge1xuICBJbihrKSB7XG4gICAgcmV0dXJuIDEgLSBNYXRoLnNxcnQoMSAtIGsgKiBrKTtcbiAgfSxcbiAgT3V0KGspIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KDEgLSAtLWsgKiBrKTtcbiAgfSxcbiAgSW5PdXQoaykge1xuICAgIGsgKj0gMjtcbiAgICBpZiAoayA8IDEpIHtcbiAgICAgIHJldHVybiAtMC41ICogKE1hdGguc3FydCgxIC0gayAqIGspIC0gMSk7XG4gICAgfVxuXG4gICAgayAtPSAyO1xuICAgIHJldHVybiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSBrICogaykgKyAxKTtcbiAgfSxcbn07XG5cbi8qKlxuICogRWxhc3RpYyBFYXNpbmdcbiAqIEB0eXBlIHtFYXNpbmdPYmplY3R9XG4gKi9cbmV4cG9ydCBjb25zdCBFbGFzdGljID0ge1xuICBJbihrKSB7XG4gICAgbGV0IHM7XG4gICAgbGV0IGEgPSAwLjE7XG4gICAgY29uc3QgcCA9IDAuNDtcblxuICAgIGlmIChrID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAoayA9PT0gMSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgaWYgKCFhIHx8IGEgPCAxKSB7XG4gICAgICBhID0gMTtcbiAgICAgIHMgPSBwIC8gNDtcbiAgICB9IGVsc2Uge1xuICAgICAgcyA9IChwICogTWF0aC5hc2luKDEgLyBhKSkgLyAoMiAqIE1hdGguUEkpO1xuICAgIH1cblxuICAgIGsgLT0gMTtcbiAgICByZXR1cm4gLShhICogMiAqKiAoMTAgKiBrKSAqIE1hdGguc2luKCgoayAtIHMpICogKDIgKiBNYXRoLlBJKSkgLyBwKSk7XG4gIH0sXG4gIE91dChrKSB7XG4gICAgbGV0IHM7XG4gICAgbGV0IGEgPSAwLjE7XG4gICAgY29uc3QgcCA9IDAuNDtcblxuICAgIGlmIChrID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAoayA9PT0gMSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgaWYgKCFhIHx8IGEgPCAxKSB7XG4gICAgICBhID0gMTtcbiAgICAgIHMgPSBwIC8gNDtcbiAgICB9IGVsc2Uge1xuICAgICAgcyA9IChwICogTWF0aC5hc2luKDEgLyBhKSkgLyAoMiAqIE1hdGguUEkpO1xuICAgIH1cblxuICAgIHJldHVybiBhICogMiAqKiAoLTEwICogaykgKiBNYXRoLnNpbigoKGsgLSBzKSAqICgyICogTWF0aC5QSSkpIC8gcCkgKyAxO1xuICB9LFxuICBJbk91dChrKSB7XG4gICAgbGV0IHM7XG4gICAgbGV0IGEgPSAwLjE7XG4gICAgY29uc3QgcCA9IDAuNDtcblxuICAgIGlmIChrID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAoayA9PT0gMSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgaWYgKCFhIHx8IGEgPCAxKSB7XG4gICAgICBhID0gMTtcbiAgICAgIHMgPSBwIC8gNDtcbiAgICB9IGVsc2Uge1xuICAgICAgcyA9IChwICogTWF0aC5hc2luKDEgLyBhKSkgLyAoMiAqIE1hdGguUEkpO1xuICAgIH1cblxuICAgIGsgKj0gMjtcbiAgICBpZiAoayA8IDEpIHtcbiAgICAgIGsgLT0gMTtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIC0wLjUgKiAoYSAqIDIgKiogKDEwICogaykgKiBNYXRoLnNpbigoKGsgLSBzKSAqICgyICogTWF0aC5QSSkpIC8gcCkpXG4gICAgICApO1xuICAgIH1cblxuICAgIGsgLT0gMTtcbiAgICByZXR1cm4gKFxuICAgICAgYSAqIDIgKiogKC0xMCAqIGspICogTWF0aC5zaW4oKChrIC0gcykgKiAoMiAqIE1hdGguUEkpKSAvIHApICogMC41ICsgMVxuICAgICk7XG4gIH0sXG59O1xuXG4vKipcbiAqIEJhY2sgRWFzaW5nXG4gKiBAdHlwZSB7RWFzaW5nT2JqZWN0fVxuICovXG5leHBvcnQgY29uc3QgQmFjayA9IHtcbiAgSW4oaykge1xuICAgIGNvbnN0IHMgPSAxLjcwMTU4O1xuICAgIHJldHVybiBrICogayAqICgocyArIDEpICogayAtIHMpO1xuICB9LFxuICBPdXQoaykge1xuICAgIGNvbnN0IHMgPSAxLjcwMTU4O1xuICAgIHJldHVybiAtLWsgKiBrICogKChzICsgMSkgKiBrICsgcykgKyAxO1xuICB9LFxuICBJbk91dChrKSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTggKiAxLjUyNTtcbiAgICBrICo9IDI7XG4gICAgaWYgKGsgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogKGsgKiBrICogKChzICsgMSkgKiBrIC0gcykpO1xuICAgIH1cblxuICAgIGsgLT0gMjtcbiAgICByZXR1cm4gMC41ICogKGsgKiBrICogKChzICsgMSkgKiBrICsgcykgKyAyKTtcbiAgfSxcbn07XG5cbi8qKlxuICogQm91bmNlIEVhc2luZ1xuICogQHR5cGUge0Vhc2luZ09iamVjdH1cbiAqL1xuZXhwb3J0IGNvbnN0IEJvdW5jZSA9IHtcbiAgSW4oaykge1xuICAgIHJldHVybiAxIC0gQm91bmNlLk91dCgxIC0gayk7XG4gIH0sXG4gIE91dChrKSB7XG4gICAgaWYgKGsgPCAxIC8gMi43NSkge1xuICAgICAgcmV0dXJuIDcuNTYyNSAqIGsgKiBrO1xuICAgIH0gZWxzZSBpZiAoayA8IDIgLyAyLjc1KSB7XG4gICAgICBrIC09IDEuNTtcbiAgICAgIHJldHVybiA3LjU2MjUgKiAoayAvIDIuNzUpICogayArIDAuNzU7XG4gICAgfSBlbHNlIGlmIChrIDwgMi41IC8gMi43NSkge1xuICAgICAgayAtPSAyLjI1O1xuICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC8gMi43NSkgKiBrICsgMC45Mzc1O1xuICAgIH1cbiAgICBrIC09IDIuNjI1O1xuICAgIHJldHVybiA3LjU2MjUgKiAoayAvIDIuNzUpICogayArIDAuOTg0Mzc1O1xuICB9LFxuICBJbk91dChrKSB7XG4gICAgaWYgKGsgPCAwLjUpIHtcbiAgICAgIHJldHVybiBCb3VuY2UuSW4oayAqIDIpICogMC41O1xuICAgIH1cbiAgICByZXR1cm4gQm91bmNlLk91dChrICogMiAtIDEpICogMC41ICsgMC41O1xuICB9LFxufTtcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtY2xhc3Nlcy1wZXItZmlsZSAqL1xuaW1wb3J0IEhvc3RPYmplY3QgZnJvbSAnY29yZS9Ib3N0T2JqZWN0JztcblxuLyoqXG4gKiBDbGFzcyBmYWN0b3J5IGludGVyZmFjZSBmb3IgZmVhdHVyZXMgdGhhdCBhcmUgZGVwZW5kZW50IG9uIG90aGVyIGZlYXR1cmVzIGJlaW5nXG4gKiBwcmVzZW50IG9uIHRoZSBob3N0LiBFdmVudCBkZXBlbmRlbmNpZXMgd2lsbCBiZSBsaXN0ZW5lZCBmb3Igd2hlbiBhIGZlYXR1cmUgb2ZcbiAqIG1hdGNoaW5nIHR5cGUgaXMgYWRkZWQgdG8gdGhlIGhvc3QgYW5kIHdpbGwgc3RvcCBiZWluZyBsaXN0ZW5lZCBmb3Igd2hlbiBvbmVcbiAqIGlzIHJlbW92ZWQuIElmIHRoZSBmZWF0dXJlIGlzIGFscmVhZHkgcHJlc2VudCB3aGVuIGNvbnN0cnVjdGVkLCBldmVudHMgd2lsbFxuICogYmUgbGlzdGVuZWQgZm9yIHJpZ2h0IGF3YXkuXG4gKlxuICogQGludGVyZmFjZVxuICpcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBFVkVOVF9ERVBFTkRFTkNJRVMgLSBFdmVudHMgdGhhdCB0aGUgZmVhdHVyZSBzaG91bGQgc3RhcnQvc3RvcFxuICogbGlzdGVuaW5nIGZvciB3aGVuIGEgZmVhdHVyZSBvZiB0eXBlIEZlYXR1cmVOYW1lIGlzIGFkZGVkL3JlbW92ZWQgZnJvbSB0aGUgaG9zdC5cbiAqIEV2ZW50IGRlcGVuZGVuY2llcyBzaG91bGQgZm9sbG93IHRoZSBzaWduYXR1cmU6XG4gKiAgeyBGZWF0dXJlTmFtZTogeyBldmVudE5hbWU6IGNhbGxiYWNrTmFtZSwgLi4uIH0sIC4uLiB9XG4gKi9cbmNsYXNzIEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2Uge1xuICAvKipcbiAgICogU3RhcnQgbGlzdGVuaW5nIGZvciBldmVudCBkZXBlbmRlbmNpZXMgdGhhdCBtYXRjaCB0aGUgZ2l2ZW4gZmVhdHVyZSB0eXBlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZU5hbWUgLSB0eXBlIG9mIGZlYXR1cmUgdG8gbGlzdGVuIGZvci5cbiAgICovXG4gIF9vbkZlYXR1cmVBZGRlZCh0eXBlTmFtZSkge31cblxuICAvKipcbiAgICogU3RvcCBsaXN0ZW5pbmcgZm9yIGV2ZW50IGRlcGVuZGVuY2llcyB0aGF0IG1hdGNoIHRoZSBnaXZlbiBmZWF0dXJlIHR5cGUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlTmFtZSAtIHR5cGUgb2YgZmVhdHVyZSB0byBzdG9wIGxpc3RlbmluZyBmb3IuXG4gICAqL1xuICBfb25GZWF0dXJlUmVtb3ZlZCh0eXBlTmFtZSkge31cblxuICAvKipcbiAgICogQGF1Z21lbnRzIHtAbGluayBBYnN0cmFjdEhvc3RGZWF0dXJlI2Rpc2NhcmR9XG4gICAqL1xuICBkaXNjYXJkKCkge31cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNsYXNzIHRoYXQgaW1wbGVtZW50cyB7QGxpbmsgRmVhdHVyZURlcGVuZGVudEludGVyZmFjZX0gYW5kIGV4dGVuZHNcbiAgICogYSBzcGVjaWZpZWQgYmFzZSBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtDbGFzc30gQmFzZUNsYXNzIC0gVGhlIGNsYXNzIHRvIGV4dGVuZC5cbiAgICpcbiAgICogQHJldHVybiB7Q2xhc3N9IEEgY2xhc3MgdGhhdCBleHRlbmRzIGBCYXNlQ2xhc3NgIGFuZCBpbXBsZW1lbnRzIHtAbGluayBGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlfS5cbiAgICovXG4gIHN0YXRpYyBNaXhpbihCYXNlQ2xhc3MpIHtcbiAgICBjb25zdCBGZWF0dXJlRGVwZW5kZW50TWl4aW4gPSBjbGFzcyBleHRlbmRzIEJhc2VDbGFzcyB7XG4gICAgICBjb25zdHJ1Y3Rvcihob3N0KSB7XG4gICAgICAgIHN1cGVyKGhvc3QpO1xuICAgICAgICB0aGlzLl9ob3N0ID0gaG9zdDtcblxuICAgICAgICAvLyBObyBuZWVkIHRvIGxpc3RlbiBmb3IgZXZlbnRzIGlmIHRoZSBtaXhpbiBpcyBpbiB0aGUgcHJvdG90eXBlIGNoYWluIG11bHRpcGxlIHRpbWVzXG4gICAgICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG5cbiAgICAgICAgICAvLyBTdGFydCBsaXN0ZW5pbmcgZm9yIGZlYXR1cmUgZXZlbnRzXG4gICAgICAgICAgdGhpcy5fb25GZWF0dXJlQWRkZWQgPSB0aGlzLl9vbkZlYXR1cmVBZGRlZC5iaW5kKHRoaXMpO1xuICAgICAgICAgIHRoaXMuX29uRmVhdHVyZVJlbW92ZWQgPSB0aGlzLl9vbkZlYXR1cmVSZW1vdmVkLmJpbmQodGhpcyk7XG5cbiAgICAgICAgICB0aGlzLl9ob3N0Lmxpc3RlblRvKFxuICAgICAgICAgICAgSG9zdE9iamVjdC5FVkVOVFMuYWRkRmVhdHVyZSxcbiAgICAgICAgICAgIHRoaXMuX29uRmVhdHVyZUFkZGVkXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLl9ob3N0Lmxpc3RlblRvKFxuICAgICAgICAgICAgSG9zdE9iamVjdC5FVkVOVFMucmVtb3ZlRmVhdHVyZSxcbiAgICAgICAgICAgIHRoaXMuX29uRmVhdHVyZVJlbW92ZWRcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gUmVnaXN0ZXIgZmVhdHVyZXMgdGhhdCBhbHJlYWR5IGV4aXN0XG4gICAgICAgICAgT2JqZWN0LmtleXModGhpcy5jb25zdHJ1Y3Rvci5FVkVOVF9ERVBFTkRFTkNJRVMpLmZvckVhY2godHlwZU5hbWUgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2hvc3RbdHlwZU5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5fb25GZWF0dXJlQWRkZWQodHlwZU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9vbkZlYXR1cmVBZGRlZCh0eXBlTmFtZSkge1xuICAgICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5FVkVOVF9ERVBFTkRFTkNJRVNbdHlwZU5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zdCBldmVudHMgPSB0aGlzLmNvbnN0cnVjdG9yLkVWRU5UX0RFUEVOREVOQ0lFU1t0eXBlTmFtZV07XG5cbiAgICAgICAgICBPYmplY3QuZW50cmllcyhldmVudHMpLmZvckVhY2goKFtldmVudE5hbWUsIGNhbGxiYWNrXSkgPT4ge1xuICAgICAgICAgICAgdGhpc1tjYWxsYmFja10gPSB0aGlzW2NhbGxiYWNrXS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5faG9zdC5saXN0ZW5UbyhcbiAgICAgICAgICAgICAgdGhpcy5faG9zdFt0eXBlTmFtZV0uRVZFTlRTW2V2ZW50TmFtZV0sXG4gICAgICAgICAgICAgIHRoaXNbY2FsbGJhY2tdXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9vbkZlYXR1cmVSZW1vdmVkKHR5cGVOYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLkVWRU5UX0RFUEVOREVOQ0lFU1t0eXBlTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMuY29uc3RydWN0b3IuRVZFTlRfREVQRU5ERU5DSUVTW3R5cGVOYW1lXTtcblxuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGV2ZW50cykuZm9yRWFjaCgoW2V2ZW50TmFtZSwgY2FsbGJhY2tdKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9ob3N0LnN0b3BMaXN0ZW5pbmcoXG4gICAgICAgICAgICAgIHRoaXMuX2hvc3RbdHlwZU5hbWVdLkVWRU5UU1tldmVudE5hbWVdLFxuICAgICAgICAgICAgICB0aGlzW2NhbGxiYWNrXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkaXNjYXJkKCkge1xuICAgICAgICAvLyBTdG9wIGxpc3RlbmluZyBmb3IgZmVhdHVyZSBldmVudHNcbiAgICAgICAgdGhpcy5faG9zdC5zdG9wTGlzdGVuaW5nKFxuICAgICAgICAgIEhvc3RPYmplY3QuRVZFTlRTLmFkZEZlYXR1cmUsXG4gICAgICAgICAgdGhpcy5fb25GZWF0dXJlQWRkZWRcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5faG9zdC5zdG9wTGlzdGVuaW5nKFxuICAgICAgICAgIEhvc3RPYmplY3QuRVZFTlRTLnJlbW92ZUZlYXR1cmUsXG4gICAgICAgICAgdGhpcy5fb25GZWF0dXJlUmVtb3ZlZFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFN0b3AgbGlzdGVuaW5nIHRvIGZlYXR1cmUtc3BlY2lmaWMgZXZlbnRzXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuY29uc3RydWN0b3IuRVZFTlRfREVQRU5ERU5DSUVTKS5mb3JFYWNoKHR5cGVOYW1lID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5faG9zdFt0eXBlTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fb25GZWF0dXJlUmVtb3ZlZCh0eXBlTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBzdXBlci5kaXNjYXJkKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IEVWRU5UX0RFUEVOREVOQ0lFUyA9IEJhc2VDbGFzcy5FVkVOVF9ERVBFTkRFTkNJRVMgfHwge307XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhGZWF0dXJlRGVwZW5kZW50TWl4aW4sIHtcbiAgICAgIEVWRU5UX0RFUEVOREVOQ0lFUzoge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIC4uLkVWRU5UX0RFUEVOREVOQ0lFUyxcbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIHJldHVybiBGZWF0dXJlRGVwZW5kZW50TWl4aW47XG4gIH1cbn1cblxuLyoqXG4gKiBFdmVudCBkZXBlbmRlbmNpZXMgc2hvdWxkIGZvbGxvdyB0aGUgc2lnbmF0dXJlOlxuICoge1xuICogIEZlYXR1cmVOYW1lOiB7XG4gKiAgICAvLyBFdmVudHMgdGhhdCB0aGUgZmVhdHVyZSBzaG91bGQgc3RhcnQvc3RvcCBsaXN0ZW5pbmcgZm9yIHdoZW4gYSBmZWF0dXJlXG4gKiAgICAvLyBvZiB0eXBlIEZlYXR1cmVOYW1lIGlzIGFkZGVkL3JlbW92ZWQgZnJvbSB0aGUgaG9zdFxuICogICAge1xuICogICAgICBldmVudE5hbWU6IGNhbGxiYWNrTmFtZSxcbiAqICAgICAgLi4uXG4gKiAgICB9LFxuICogIH1cbiAqIH1cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRmVhdHVyZURlcGVuZGVudEludGVyZmFjZSwge1xuICBFVkVOVF9ERVBFTkRFTkNJRVM6IHtcbiAgICB2YWx1ZToge30sXG4gICAgd3JpdGFibGU6IGZhbHNlLFxuICB9LFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2U7XG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWNsYXNzZXMtcGVyLWZpbGUgKi9cbmltcG9ydCBGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlIGZyb20gJ2NvcmUvRmVhdHVyZURlcGVuZGVudEludGVyZmFjZSc7XG5cbi8qKlxuICogQ2xhc3MgZmFjdG9yeSBpbnRlcmZhY2UgZm9yIGZlYXR1cmVzIHRoYXQgYXJlIGRlcGVuZGVudCBvbiB0aGUgQW5pbWF0aW9uRmVhdHVyZVxuICogYmVpbmcgcHJlc2VudCBvbiB0aGUgaG9zdC4gTGF5ZXIgYW5kIGFuaW1hdGlvbiBldmVudHMgd2lsbCBhdXRvbWF0aWNhbGx5IGJlXG4gKiBsaXN0ZW5lZCBmb3Igb25jZSBhIEFuaW1hdGlvbkZlYXR1cmUgaXMgYWRkZWQgdG8gdGhlIGhvc3QgYW5kIHN0b3BwZWQgb25jZSBpdFxuICogaXMgcmVtb3ZlZC5cbiAqXG4gKiBAaW50ZXJmYWNlXG4gKiBAZXh0ZW5kcyBGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlXG4gKlxuICogQHByb3BlcnR5IHtPYmplY3R9IEVWRU5UX0RFUEVOREVOQ0lFUyAtIEV2ZW50cyB0aGF0IHRoZSBmZWF0dXJlIHNob3VsZCBzdGFydC9zdG9wXG4gKiBsaXN0ZW5pbmcgZm9yIHdoZW4gYSBmZWF0dXJlIG9mIHR5cGUgRmVhdHVyZU5hbWUgaXMgYWRkZWQvcmVtb3ZlZCBmcm9tIHRoZSBob3N0LlxuICogQHByb3BlcnR5IHtPYmplY3R9IEVWRU5UX0RFUEVOREVOQ0lFUy5BbmltYXRpb25GZWF0dXJlIC0gRXZlbnRzIHRoYXQgYXJlXG4gKiBzcGVjaWZpYyB0byB0aGUgQW5pbWF0aW9uRmVhdHVyZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRfREVQRU5ERU5DSUVTLkFuaW1hdGlvbkZlYXR1cmUuYWRkTGF5ZXI9J19vbkxheWVyQWRkZWQnXSAtXG4gKiBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIEFuaW1hdGlvbkZlYXR1cmUgYWRkTGF5ZXJcbiAqIGV2ZW50cyBhcmUgZW1pdHRlZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRfREVQRU5ERU5DSUVTLkFuaW1hdGlvbkZlYXR1cmUucmVtb3ZlTGF5ZXI9J19vbkxheWVyUmVtb3ZlZCddIC1cbiAqIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gQW5pbWF0aW9uRmVhdHVyZSByZW1vdmVMYXllclxuICogZXZlbnRzIGFyZSBlbWl0dGVkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVF9ERVBFTkRFTkNJRVMuQW5pbWF0aW9uRmVhdHVyZS5yZW5hbWVMYXllcj0nX29uTGF5ZXJSZW5hbWVkJ10gLVxuICogVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBBbmltYXRpb25GZWF0dXJlIHJlbmFtZUxheWVyXG4gKiBldmVudHMgYXJlIGVtaXR0ZWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UX0RFUEVOREVOQ0lFUy5BbmltYXRpb25GZWF0dXJlLmFkZEFuaW1hdGlvbj0nX29uQW5pbWF0aW9uQWRkZWQnXSAtXG4gKiBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIEFuaW1hdGlvbkZlYXR1cmUgYWRkQW5pbWF0aW9uXG4gKiBldmVudHMgYXJlIGVtaXR0ZWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UX0RFUEVOREVOQ0lFUy5BbmltYXRpb25GZWF0dXJlLnJlbW92ZUFuaW1hdGlvbj0nX29uQW5pbWF0aW9uUmVtb3ZlZCddIC1cbiAqIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gQW5pbWF0aW9uRmVhdHVyZSByZW1vdmVBbmltYXRpb25cbiAqIGV2ZW50cyBhcmUgZW1pdHRlZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRfREVQRU5ERU5DSUVTLkFuaW1hdGlvbkZlYXR1cmUucmVuYW1lQW5pbWF0aW9uPSdfb25BbmltYXRpb25SZW5hbWVkJ10gLVxuICogVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBBbmltYXRpb25GZWF0dXJlIHJlbmFtZUFuaW1hdGlvblxuICogZXZlbnRzIGFyZSBlbWl0dGVkLlxuICovXG5jbGFzcyBBbmltYXRpb25GZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlIGV4dGVuZHMgRmVhdHVyZURlcGVuZGVudEludGVyZmFjZSB7XG4gIC8qKlxuICAgKiBFeGVjdXRlZCB3aGVuIGFuaW1hdGlvbiBsYXllciBhZGRlZCBldmVudHMgYXJlIGNhdWdodC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0aGF0IHdhcyBhZGRlZC5cbiAgICovXG4gIF9vbkxheWVyQWRkZWQoe25hbWV9KSB7fVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlZCB3aGVuIGFuaW1hdGlvbiBsYXllciByZW1vdmVkIGV2ZW50cyBhcmUgY2F1Z2h0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRoYXQgd2FzIHJlbW92ZWQuXG4gICAqL1xuICBfb25MYXllclJlbW92ZWQoe25hbWV9KSB7fVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlZCB3aGVuIGFuaW1hdGlvbiBsYXllciByZW5hbWVkIGV2ZW50cyBhcmUgY2F1Z2h0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb2xkTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRoYXQgd2FzIHJlbmFtZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdOYW1lIC0gTmV3IG5hbWUgb2YgdGhlIGxheWVyLlxuICAgKi9cbiAgX29uTGF5ZXJSZW5hbWVkKHtvbGROYW1lLCBuZXdOYW1lfSkge31cblxuICAvKipcbiAgICogRXhlY3V0ZWQgd2hlbiBhbmltYXRpb24gYWRkZWQgZXZlbnRzIGFyZSBjYXVnaHQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0aGF0IGFuIGFuaW1hdGlvbiB3YXMgYWRkZWQgdG8uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbmltYXRpb25OYW1lIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRoYXQgd2FzIGFkZGVkLlxuICAgKi9cbiAgX29uQW5pbWF0aW9uQWRkZWQoe2xheWVyTmFtZSwgYW5pbWF0aW9uTmFtZX0pIHt9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVkIHdoZW4gYW5pbWF0aW9uIHJlbW92ZWQgZXZlbnRzIGFyZSBjYXVnaHQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0aGF0IGFuIGFuaW1hdGlvbiB3YXMgcmVtb3ZlZCBmcm9tLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYW5pbWF0aW9uTmFtZSAtIE5hbWUgb2YgdGhlIGFuaW1hdGlvbiB0aGF0IHdhcyByZW1vdmVkLlxuICAgKi9cbiAgX29uQW5pbWF0aW9uUmVtb3ZlZCh7bGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lfSkge31cblxuICAvKipcbiAgICogRXhlY3V0ZWQgd2hlbiBhbmltYXRpb24gcmVuYW1lZCBldmVudHMgYXJlIGNhdWdodC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRoYXQgYW4gYW5pbWF0aW9uIGJlbG9uZ3MgdG8uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvbGROYW1lIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRoYXQgd2FzIHJlbmFtZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdOYW1lIC0gTmV3IG5hbWUgb2YgdGhlIGFuaW1hdGlvbi5cbiAgICovXG4gIF9vbkFuaW1hdGlvblJlbmFtZWQoe2xheWVyTmFtZSwgb2xkTmFtZSwgbmV3TmFtZX0pIHt9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjbGFzcyB0aGF0IGltcGxlbWVudHMge0BsaW5rIEFuaW1hdGlvbkZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2V9XG4gICAqIGFuZCBleHRlbmRzIGEgc3BlY2lmaWVkIGJhc2UgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2xhc3N9IEJhc2VDbGFzcyAtIFRoZSBjbGFzcyB0byBleHRlbmQuXG4gICAqXG4gICAqIEByZXR1cm4ge0NsYXNzfSBBIGNsYXNzIHRoYXQgZXh0ZW5kcyBgQmFzZUNsYXNzYCBhbmQgaW1wbGVtZW50cyB7QGxpbmsgQW5pbWF0aW9uRmVhdHVyZURlcGVuZGVudEludGVyZmFjZX0uXG4gICAqL1xuICBzdGF0aWMgTWl4aW4oQmFzZUNsYXNzKSB7XG4gICAgY29uc3QgUGFyZW50Q2xhc3MgPSBGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlLk1peGluKEJhc2VDbGFzcyk7XG4gICAgY29uc3QgQW5pbWF0aW9uRmVhdHVyZURlcGVuZGVudE1peGluID0gY2xhc3MgZXh0ZW5kcyBQYXJlbnRDbGFzcyB7XG4gICAgICBfb25MYXllckFkZGVkKHtuYW1lfSkge31cblxuICAgICAgX29uTGF5ZXJSZW1vdmVkKHtuYW1lfSkge31cblxuICAgICAgX29uTGF5ZXJSZW5hbWVkKHtvbGROYW1lLCBuZXdOYW1lfSkge31cblxuICAgICAgX29uQW5pbWF0aW9uQWRkZWQoe2xheWVyTmFtZSwgYW5pbWF0aW9uTmFtZX0pIHt9XG5cbiAgICAgIF9vbkFuaW1hdGlvblJlbW92ZWQoe2xheWVyTmFtZSwgYW5pbWF0aW9uTmFtZX0pIHt9XG5cbiAgICAgIF9vbkFuaW1hdGlvblJlbmFtZWQoe2xheWVyTmFtZSwgb2xkTmFtZSwgbmV3TmFtZX0pIHt9XG4gICAgfTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEFuaW1hdGlvbkZlYXR1cmVEZXBlbmRlbnRNaXhpbiwge1xuICAgICAgRVZFTlRfREVQRU5ERU5DSUVTOiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgLi4uUGFyZW50Q2xhc3MuRVZFTlRfREVQRU5ERU5DSUVTLFxuICAgICAgICAgIC4uLkFuaW1hdGlvbkZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UuRVZFTlRfREVQRU5ERU5DSUVTLFxuICAgICAgICB9LFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIEFuaW1hdGlvbkZlYXR1cmVEZXBlbmRlbnRNaXhpbjtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhBbmltYXRpb25GZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlLCB7XG4gIEVWRU5UX0RFUEVOREVOQ0lFUzoge1xuICAgIHZhbHVlOiB7XG4gICAgICBBbmltYXRpb25GZWF0dXJlOiB7XG4gICAgICAgIGFkZExheWVyOiAnX29uTGF5ZXJBZGRlZCcsXG4gICAgICAgIHJlbW92ZUxheWVyOiAnX29uTGF5ZXJSZW1vdmVkJyxcbiAgICAgICAgcmVuYW1lTGF5ZXI6ICdfb25MYXllclJlbmFtZWQnLFxuICAgICAgICBhZGRBbmltYXRpb246ICdfb25BbmltYXRpb25BZGRlZCcsXG4gICAgICAgIHJlbW92ZUFuaW1hdGlvbjogJ19vbkFuaW1hdGlvblJlbW92ZWQnLFxuICAgICAgICByZW5hbWVBbmltYXRpb246ICdfb25BbmltYXRpb25SZW5hbWVkJyxcbiAgICAgIH0sXG4gICAgfSxcbiAgICB3cml0YWJsZTogZmFsc2UsXG4gIH0sXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQW5pbWF0aW9uRmVhdHVyZURlcGVuZGVudEludGVyZmFjZTtcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtY2xhc3Nlcy1wZXItZmlsZSAqL1xuaW1wb3J0IEFuaW1hdGlvbkZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UgZnJvbSAnY29yZS9hbmltcGFjay9BbmltYXRpb25GZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlJztcblxuLyoqXG4gKiBDbGFzcyBmYWN0b3J5IGludGVyZmFjZSBmb3IgdGhhdCBrZWVwcyB0cmFjayBvZiBsYXllcnMgYW5kIGFuaW1hdGlvbnMgb24gYSBob3N0LlxuICogVHJhY2tlZCBhc3NldHMgYXJlIG1hcmtlZCBhcyBpbmFjdGl2ZSB1bnRpbCBsYXllcnMgYW5kIGFuaW1hdGlvbnMgd2l0aCBtYXRjaGluZ1xuICogbmFtZXMgYXJlIGRldGVjdGVkIGFzIHByZXNlbnQgb24gdGhlIGhvc3QuXG4gKlxuICogQGludGVyZmFjZVxuICogQGV4dGVuZHMgQW5pbWF0aW9uRmVhdHVyZURlcGVuZGVudEludGVyZmFjZVxuICpcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBERUZBVUxUX0xBWUVSX09QVElPTlMgLSBEZWZhdWx0IG9wdGlvbnMgdG8gdXNlIHdoZW4gZXhlY3V0aW5nXG4gKiB7QGxpbmsgQW5pbWF0aW9uTGF5ZXJ9IG1ldGhvZHMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW0RFRkFVTFRfTEFZRVJfT1BUSU9OUy5ibGVuZFRpbWU9MC41XSAtIERlZmF1bHQgdGltZSBpbiBzZWNvbmRzXG4gKiB0byB1c2Ugd2hlbiBleGVjdXRpbmcge0BsaW5rIEFuaW1hdGlvbkxheWVyLnNldEJsZW5kV2VpZ2h0fS5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbREVGQVVMVF9MQVlFUl9PUFRJT05TLmFuaW1hdGlvbnM9e31dIC0gTWFwcyBhbmltYXRpb24gbmFtZXNcbiAqIHRvIGRlZmF1bHQgb3B0aW9ucyBvYmplY3RzIHRvIHVzZSBmb3IgbWFuYWdlZCBhbmltYXRpb25zLlxuICovXG5jbGFzcyBNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2UgZXh0ZW5kcyBBbmltYXRpb25GZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlIHtcbiAgLyoqXG4gICAqIFN0YXJ0IHRyYWNraW5nIGtlZXBpbmcgdHJhY2sgb2Ygd2hldGhlciBhIGxheWVyIHdpdGggdGhlIGdpdmVuIG5hbWUgaXMgcHJlc2VudFxuICAgKiBvbiB0aGUgaG9zdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0byBrZWVwIHRyYWNrIG9mLlxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgbGF5ZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0aW9ucy5ibGVuZFRpbWUgLSBEZWZhdWx0IGFtb3VudCBvZiB0aW1lIHRvIHVzZSB3aGVuXG4gICAqIG1hbmlwdWxhdGluZyBsYXllciB3ZWlnaHRzIG9uIHRoaXMgbGF5ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvcHRpb25zLmVhc2luZ0ZuIC0gRGVmYXVsdCBlYXNpbmcgZnVuY3Rpb24gdG8gdXNlIHdoZW5cbiAgICogbWFuaXB1bGF0aW5nIGxheWVyIHdlaWdodHMgb24gdGhpcyBsYXllci5cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zLmFuaW1hdGlvbnMgLSBBbmltYXRpb25zIHRvIGtlZXAgdHJhY2sgb2Ygb24gdGhlIGxheWVyLlxuICAgKiBBbmltYXRpb25zIGFyZSByZXByZXNlbnRlZCBhcyBrZXkvdmFsdWUgcGFpcnMgb2YgYW5pbWF0aW9uIG5hbWVzIGFuZCB0aGVpclxuICAgKiBvcHRpb25zLlxuICAgKi9cbiAgcmVnaXN0ZXJMYXllcihuYW1lLCBvcHRpb25zID0ge30pIHt9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHRyYWNraW5nIGtlZXBpbmcgdHJhY2sgb2Ygd2hldGhlciBhbiBhbmltYXRpb24gd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpc1xuICAgKiBwcmVzZW50IG9uIHRoZSBob3N0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCB3aWxsIG93biB0aGUgYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYW5pbWF0aW9uTmFtZSAtIE5hbWUgb2YgdGhlIGFuaW1hdGlvbiB0byBrZWVwIHRyYWNrIG9mLlxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgYW5pbWF0aW9uLlxuICAgKi9cbiAgcmVnaXN0ZXJBbmltYXRpb24obGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lLCBvcHRpb25zID0ge30pIHt9XG5cbiAgLyoqXG4gICAqIFNldCBsYXllciB3ZWlnaHRzIG9uIHRyYWNrZWQgbGF5ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gbmFtZUZpbHRlciAtIFByZWRpY2F0ZSBmdW5jdGlvbiB0byB0ZXN0IGVhY2ggdHJhY2tlZCBsYXllclxuICAgKiB3aXRoLiBCeSBkZWZhdWx0IGFsbCBsYXllcnMgd2lsbCBwYXNzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gd2VpZ2h0IC0gV2VpZ2h0IHZhbHVlIHRvIHNldCBvbiBsYXllcnMuXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gc2Vjb25kcyAtIE51bWJlciBvZiBzZWNvbmRzIGl0IHdpbGwgdGFrZSB0byByZWFjaCB0aGUgd2VpZ2h0XG4gICAqIG9uIGVhY2ggbGF5ZXIuIElmIHVuZGVmaW5lZCwgZWFjaCBsYXllcnMnIGJsZW5kVGltZSBvcHRpb24gaXMgdXNlZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGVhc2luZ0ZuIC0gRWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSB3aGVuIHNldHRpbmcgd2VpZ2h0XG4gICAqIG9uIGVhY2ggbGF5ZXIuIElmIHVuZGVmaW5lZCwgZWFjaCBsYXllcnMnIGVhc2luZ0ZuIG9wdGlvbiBpcyB1c2VkLlxuICAgKi9cbiAgc2V0TGF5ZXJXZWlnaHRzKG5hbWVGaWx0ZXIgPSAoKSA9PiB0cnVlLCB3ZWlnaHQsIHNlY29uZHMsIGVhc2luZ0ZuKSB7fVxuXG4gIC8qKlxuICAgKiBTZXQgYWxsIHRyYWNrZWQgbGF5ZXJzJyB3ZWlnaHRzIHRvIDEuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gc2Vjb25kcyAtIE51bWJlciBvZiBzZWNvbmRzIGl0IHdpbGwgdGFrZSB0byByZWFjaCB0aGUgd2VpZ2h0XG4gICAqIG9uIGVhY2ggbGF5ZXIuIElmIHVuZGVmaW5lZCwgZWFjaCBsYXllcnMnIGJsZW5kVGltZSBvcHRpb24gaXMgdXNlZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGVhc2luZ0ZuIC0gRWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSB3aGVuIHNldHRpbmcgd2VpZ2h0XG4gICAqIG9uIGVhY2ggbGF5ZXIuIElmIHVuZGVmaW5lZCwgZWFjaCBsYXllcnMnIGVhc2luZ0ZuIG9wdGlvbiBpcyB1c2VkLlxuICAgKi9cbiAgZW5hYmxlKHNlY29uZHMsIGVhc2luZ0ZuKSB7fVxuXG4gIC8qKlxuICAgKiBTZXQgYWxsIHRyYWNrZWQgbGF5ZXJzJyB3ZWlnaHRzIHRvIDAuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gc2Vjb25kcyAtIE51bWJlciBvZiBzZWNvbmRzIGl0IHdpbGwgdGFrZSB0byByZWFjaCB0aGUgd2VpZ2h0XG4gICAqIG9uIGVhY2ggbGF5ZXIuIElmIHVuZGVmaW5lZCwgZWFjaCBsYXllcnMnIGJsZW5kVGltZSBvcHRpb24gaXMgdXNlZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGVhc2luZ0ZuIC0gRWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSB3aGVuIHNldHRpbmcgd2VpZ2h0XG4gICAqIG9uIGVhY2ggbGF5ZXIuIElmIHVuZGVmaW5lZCwgZWFjaCBsYXllcnMnIGVhc2luZ0ZuIG9wdGlvbiBpcyB1c2VkLlxuICAgKi9cbiAgZGlzYWJsZShzZWNvbmRzLCBlYXNpbmdGbikge31cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNsYXNzIHRoYXQgaW1wbGVtZW50cyB7QGxpbmsgTWFuYWdlZEFuaW1hdGlvbkxheWVySW50ZXJmYWNlfVxuICAgKiBhbmQgZXh0ZW5kcyBhIHNwZWNpZmllZCBiYXNlIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge0NsYXNzfSBCYXNlQ2xhc3MgLSBUaGUgY2xhc3MgdG8gZXh0ZW5kLlxuICAgKlxuICAgKiBAcmV0dXJuIHtDbGFzc30gQSBjbGFzcyB0aGF0IGV4dGVuZHMgYEJhc2VDbGFzc2AgYW5kIGltcGxlbWVudHMge0BsaW5rIE1hbmFnZWRBbmltYXRpb25MYXllckludGVyZmFjZX0uXG4gICAqL1xuICBzdGF0aWMgTWl4aW4oQmFzZUNsYXNzKSB7XG4gICAgY29uc3QgUGFyZW50Q2xhc3MgPSBBbmltYXRpb25GZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlLk1peGluKEJhc2VDbGFzcyk7XG4gICAgY29uc3QgTWFuYWdlZEFuaW1hdGlvbkxheWVyTWl4aW4gPSBjbGFzcyBleHRlbmRzIFBhcmVudENsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG5cbiAgICAgICAgdGhpcy5fbWFuYWdlZExheWVycyA9IHt9O1xuICAgICAgfVxuXG4gICAgICBfb25GZWF0dXJlQWRkZWQodHlwZU5hbWUpIHtcbiAgICAgICAgc3VwZXIuX29uRmVhdHVyZUFkZGVkKHR5cGVOYW1lKTtcblxuICAgICAgICBpZiAodHlwZU5hbWUgIT09ICdBbmltYXRpb25GZWF0dXJlJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21hbmFnZWRMYXllcnMgPSB0aGlzLl9tYW5hZ2VkTGF5ZXJzIHx8IHt9O1xuXG4gICAgICAgIC8vIERldGVjdCBuZXcgbGF5ZXJzXG4gICAgICAgIHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5sYXllcnMuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgICB0aGlzLl9vbkxheWVyQWRkZWQoe25hbWV9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIF9vbkZlYXR1cmVSZW1vdmVkKHR5cGVOYW1lKSB7XG4gICAgICAgIHN1cGVyLl9vbkZlYXR1cmVSZW1vdmVkKHR5cGVOYW1lKTtcblxuICAgICAgICBpZiAodHlwZU5hbWUgIT09ICdBbmltYXRpb25GZWF0dXJlJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21hbmFnZWRMYXllcnMgPSB0aGlzLl9tYW5hZ2VkTGF5ZXJzIHx8IHt9O1xuXG4gICAgICAgIC8vIERlYWN0aXZhdGUgdGhlIGxheWVyc1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9tYW5hZ2VkTGF5ZXJzKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICAgIHRoaXMuX29uTGF5ZXJSZW1vdmVkKHtuYW1lfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBfb25MYXllckFkZGVkKHtuYW1lfSkge1xuICAgICAgICAvLyBNYXJrIHRoZSBsYXllciBhcyBhY3RpdmUgaWYgaXQgaXMgbWFuYWdlZFxuICAgICAgICBpZiAodGhpcy5fbWFuYWdlZExheWVyc1tuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5fbWFuYWdlZExheWVyc1tuYW1lXS5pc0FjdGl2ZSA9IHRydWU7XG5cbiAgICAgICAgICAvLyBEZXRlY3QgbmV3IGFuaW1hdGlvbnNcbiAgICAgICAgICB0aGlzLl9ob3N0LkFuaW1hdGlvbkZlYXR1cmUuZ2V0QW5pbWF0aW9ucyhuYW1lKS5mb3JFYWNoKGFuaW1OYW1lID0+IHtcbiAgICAgICAgICAgIHRoaXMuX29uQW5pbWF0aW9uQWRkZWQoe2xheWVyTmFtZTogbmFtZSwgYW5pbWF0aW9uTmFtZTogYW5pbU5hbWV9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfb25MYXllclJlbW92ZWQoe25hbWV9KSB7XG4gICAgICAgIC8vIERlYWN0aXZhdGUgdGhlIGxheWVyIGlmIGl0IGlzIG1hbmFnZWRcbiAgICAgICAgaWYgKHRoaXMuX21hbmFnZWRMYXllcnNbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuX21hbmFnZWRMYXllcnNbbmFtZV0uaXNBY3RpdmUgPSBmYWxzZTtcblxuICAgICAgICAgIC8vIERlYWN0aXZhdGUgdGhlIGFuaW1hdGlvbnNcbiAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9tYW5hZ2VkTGF5ZXJzW25hbWVdLmFuaW1hdGlvbnMpLmZvckVhY2goXG4gICAgICAgICAgICBhbmltTmFtZSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuX29uQW5pbWF0aW9uUmVtb3ZlZCh7XG4gICAgICAgICAgICAgICAgbGF5ZXJOYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbk5hbWU6IGFuaW1OYW1lLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9vbkxheWVyUmVuYW1lZCh7b2xkTmFtZSwgbmV3TmFtZX0pIHtcbiAgICAgICAgY29uc3QgbGF5ZXJPcHRpb25zID0gdGhpcy5fbWFuYWdlZExheWVyc1tvbGROYW1lXTtcblxuICAgICAgICAvLyBSZXBsYWNlIHRoZSBsYXllciBrZXkgd2l0aCB0aGUgbmV3IG5hbWVcbiAgICAgICAgaWYgKGxheWVyT3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX21hbmFnZWRMYXllcnNbb2xkTmFtZV07XG4gICAgICAgICAgdGhpcy5fbWFuYWdlZExheWVyc1tuZXdOYW1lXSA9IGxheWVyT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfb25BbmltYXRpb25BZGRlZCh7bGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lfSkge1xuICAgICAgICAvLyBNYXJrIHRoZSBhbmltYXRpb24gYXMgYWN0aXZlIGlmIGl0IGlzIG1hbmFnZWRcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdLmFuaW1hdGlvbnNbYW5pbWF0aW9uTmFtZV0gIT09IHVuZGVmaW5lZFxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0uYW5pbWF0aW9uc1tcbiAgICAgICAgICAgIGFuaW1hdGlvbk5hbWVcbiAgICAgICAgICBdLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfb25BbmltYXRpb25SZW1vdmVkKHtsYXllck5hbWUsIGFuaW1hdGlvbk5hbWV9KSB7XG4gICAgICAgIC8vIERlYWN0aXZhdGUgdGhlIGFuaW1hdGlvbiBpZiBpdCBpcyBtYW5hZ2VkXG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgIHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXS5hbmltYXRpb25zW2FuaW1hdGlvbk5hbWVdICE9PSB1bmRlZmluZWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdLmFuaW1hdGlvbnNbXG4gICAgICAgICAgICBhbmltYXRpb25OYW1lXG4gICAgICAgICAgXS5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9vbkFuaW1hdGlvblJlbmFtZWQoe2xheWVyTmFtZSwgb2xkTmFtZSwgbmV3TmFtZX0pIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdLmFuaW1hdGlvbnNbb2xkTmFtZV0gIT09IHVuZGVmaW5lZFxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBSZXBsYWNlIHRoZSBhbmltYXRpb24ga2V5IHdpdGggdGhlIG5ldyBuYW1lXG4gICAgICAgICAgY29uc3QgYW5pbU9wdGlvbnMgPSB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0uYW5pbWF0aW9uc1tcbiAgICAgICAgICAgIG9sZE5hbWVcbiAgICAgICAgICBdO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0uYW5pbWF0aW9uc1tvbGROYW1lXTtcbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0uYW5pbWF0aW9uc1tuZXdOYW1lXSA9IGFuaW1PcHRpb25zO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlZ2lzdGVyTGF5ZXIobmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIC8vIFN0YXJ0IHdpdGggZGVmYXVsdCBvcHRpb25zIGZvciBlYWNoIG5ldyBsYXllclxuICAgICAgICBpZiAodGhpcy5fbWFuYWdlZExheWVyc1tuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5fbWFuYWdlZExheWVyc1tuYW1lXSA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuY29uc3RydWN0b3IuREVGQVVMVF9MQVlFUl9PUFRJT05TLFxuICAgICAgICAgICAgYW5pbWF0aW9uczoge30sXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBhbGwgb3B0aW9ucyBleGNlcHQgYW5pbWF0aW9uc1xuICAgICAgICBjb25zdCBsYXllck9wdGlvbnMgPSB0aGlzLl9tYW5hZ2VkTGF5ZXJzW25hbWVdO1xuICAgICAgICBvcHRpb25zID0gey4uLm9wdGlvbnN9O1xuICAgICAgICBjb25zdCBhbmltYXRpb25PcHRpb25zID0gb3B0aW9ucy5hbmltYXRpb25zIHx8IHt9O1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5hbmltYXRpb25zO1xuICAgICAgICBPYmplY3QuYXNzaWduKGxheWVyT3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgbGF5ZXIgY2FuIGJlIG1hbmlwdWxhdGVkIG5vd1xuICAgICAgICBsYXllck9wdGlvbnMuaXNBY3RpdmUgPVxuICAgICAgICAgIHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlLmxheWVycy5pbmNsdWRlcyhuYW1lKTtcblxuICAgICAgICAvLyBSZWdpc3RlciB0aGUgYW5pbWF0aW9uc1xuICAgICAgICBPYmplY3QuZW50cmllcyhhbmltYXRpb25PcHRpb25zKS5mb3JFYWNoKChbYW5pbU5hbWUsIGFuaW1PcHRpb25zXSkgPT4ge1xuICAgICAgICAgIHRoaXMucmVnaXN0ZXJBbmltYXRpb24obmFtZSwgYW5pbU5hbWUsIGFuaW1PcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJlZ2lzdGVyQW5pbWF0aW9uKGxheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIC8vIFJlZ2lzdGVyIHRoZSBsYXllciBpZiBpdCBoYXNuJ3QgYmVlbiByZWdpc3RlcmVkIHlldFxuICAgICAgICBpZiAodGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnJlZ2lzdGVyTGF5ZXIobGF5ZXJOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBhbmltYXRpb24gb3B0aW9uc1xuICAgICAgICBjb25zdCBhbmltT3B0aW9ucyA9XG4gICAgICAgICAgdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdLmFuaW1hdGlvbnNbYW5pbWF0aW9uTmFtZV0gfHwge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYW5pbU9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0uYW5pbWF0aW9uc1thbmltYXRpb25OYW1lXSA9IGFuaW1PcHRpb25zO1xuXG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGFuaW1hdGlvbiBjYW4gYmUgbWFuaXB1bGF0ZWQgbm93XG4gICAgICAgIHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXS5hbmltYXRpb25zW2FuaW1hdGlvbk5hbWVdLmlzQWN0aXZlID1cbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0uaXNBY3RpdmUgJiZcbiAgICAgICAgICB0aGlzLl9ob3N0LkFuaW1hdGlvbkZlYXR1cmUuZ2V0QW5pbWF0aW9ucyhsYXllck5hbWUpLmluY2x1ZGVzKFxuICAgICAgICAgICAgYW5pbWF0aW9uTmFtZVxuICAgICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHNldExheWVyV2VpZ2h0cyhuYW1lRmlsdGVyID0gKCkgPT4gdHJ1ZSwgd2VpZ2h0LCBzZWNvbmRzLCBlYXNpbmdGbikge1xuICAgICAgICBjb25zdCBsYXllck5hbWVzID0gT2JqZWN0LmtleXModGhpcy5fbWFuYWdlZExheWVycykuZmlsdGVyKG5hbWVGaWx0ZXIpO1xuXG4gICAgICAgIGxheWVyTmFtZXMuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgICBjb25zdCBsYXllck9wdGlvbnMgPSB0aGlzLl9tYW5hZ2VkTGF5ZXJzW25hbWVdO1xuXG4gICAgICAgICAgaWYgKGxheWVyT3B0aW9ucy5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlLnNldExheWVyV2VpZ2h0KFxuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICB3ZWlnaHQsXG4gICAgICAgICAgICAgIHNlY29uZHMgIT09IHVuZGVmaW5lZCA/IHNlY29uZHMgOiBsYXllck9wdGlvbnMuYmxlbmRUaW1lLFxuICAgICAgICAgICAgICBlYXNpbmdGbiB8fCBsYXllck9wdGlvbnMuZWFzaW5nRm5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZW5hYmxlKHNlY29uZHMsIGVhc2luZ0ZuKSB7XG4gICAgICAgIHRoaXMuc2V0TGF5ZXJXZWlnaHRzKHVuZGVmaW5lZCwgMSwgc2Vjb25kcywgZWFzaW5nRm4pO1xuICAgICAgfVxuXG4gICAgICBkaXNhYmxlKHNlY29uZHMsIGVhc2luZ0ZuKSB7XG4gICAgICAgIHRoaXMuc2V0TGF5ZXJXZWlnaHRzKHVuZGVmaW5lZCwgMCwgc2Vjb25kcywgZWFzaW5nRm4pO1xuICAgICAgfVxuXG4gICAgICBpbnN0YWxsQXBpKCkge1xuICAgICAgICBjb25zdCBhcGkgPSBzdXBlci5pbnN0YWxsQXBpKCk7XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihhcGksIHtcbiAgICAgICAgICByZWdpc3RlckxheWVyOiB0aGlzLnJlZ2lzdGVyTGF5ZXIuYmluZCh0aGlzKSxcbiAgICAgICAgICByZWdpc3RlckFuaW1hdGlvbjogdGhpcy5yZWdpc3RlckFuaW1hdGlvbi5iaW5kKHRoaXMpLFxuICAgICAgICAgIHNldExheWVyV2VpZ2h0czogdGhpcy5zZXRMYXllcldlaWdodHMuYmluZCh0aGlzKSxcbiAgICAgICAgICBlbmFibGU6IHRoaXMuZW5hYmxlLmJpbmQodGhpcyksXG4gICAgICAgICAgZGlzYWJsZTogdGhpcy5kaXNhYmxlLmJpbmQodGhpcyksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBhcGk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE1hbmFnZWRBbmltYXRpb25MYXllck1peGluLCB7XG4gICAgICBERUZBVUxUX0xBWUVSX09QVElPTlM6IHtcbiAgICAgICAgdmFsdWU6IE1hbmFnZWRBbmltYXRpb25MYXllckludGVyZmFjZS5ERUZBVUxUX0xBWUVSX09QVElPTlMsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICByZXR1cm4gTWFuYWdlZEFuaW1hdGlvbkxheWVyTWl4aW47XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTWFuYWdlZEFuaW1hdGlvbkxheWVySW50ZXJmYWNlLCB7XG4gIERFRkFVTFRfTEFZRVJfT1BUSU9OUzoge1xuICAgIHZhbHVlOiB7YmxlbmRUaW1lOiAwLjUsIGFuaW1hdGlvbnM6IHt9fSxcbiAgICB3cml0YWJsZTogZmFsc2UsXG4gIH0sXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgTWFuYWdlZEFuaW1hdGlvbkxheWVySW50ZXJmYWNlO1xuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWNsYXNzZXMtcGVyLWZpbGUgKi9cbmltcG9ydCBGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlIGZyb20gJ2NvcmUvRmVhdHVyZURlcGVuZGVudEludGVyZmFjZSc7XG5cbi8qKlxuICogQ2xhc3MgZmFjdG9yeSBpbnRlcmZhY2UgZm9yIGZlYXR1cmVzIHRoYXQgYXJlIGRlcGVuZGVudCBvbiB0aGUgVGV4dFRvU3BlZWNoRmVhdHVyZVxuICogYmVpbmcgcHJlc2VudCBvbiB0aGUgaG9zdC4gU3BlZWNoIGV2ZW50cyB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgbGlzdGVuZWQgZm9yIG9uY2UgYVxuICogVGV4dFRvU3BlZWNoRmVhdHVyZSBpcyBhZGRlZCB0byB0aGUgaG9zdCBhbmQgc3RvcHBlZCBvbmNlIGl0IGlzIHJlbW92ZWQuXG4gKlxuICogQGludGVyZmFjZVxuICogQGV4dGVuZHMgRmVhdHVyZURlcGVuZGVudEludGVyZmFjZVxuICpcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBFVkVOVF9ERVBFTkRFTkNJRVMgLSBFdmVudHMgdGhhdCB0aGUgZmVhdHVyZSBzaG91bGQgc3RhcnQvc3RvcFxuICogbGlzdGVuaW5nIGZvciB3aGVuIGEgZmVhdHVyZSBvZiB0eXBlIEZlYXR1cmVOYW1lIGlzIGFkZGVkL3JlbW92ZWQgZnJvbSB0aGUgaG9zdC5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBFVkVOVF9ERVBFTkRFTkNJRVMuVGV4dFRvU3BlZWNoRmVhdHVyZSAtIEV2ZW50cyB0aGF0IGFyZVxuICogc3BlY2lmaWMgdG8gdGhlIFRleHRUb1NwZWVjaEZlYXR1cmUuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UX0RFUEVOREVOQ0lFUy5UZXh0VG9TcGVlY2hGZWF0dXJlLnBsYXk9J19vblBsYXknXSAtXG4gKiBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIFRleHRUb1NwZWVjaEZlYXR1cmUgcGxheVxuICogZXZlbnRzIGFyZSBlbWl0dGVkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVF9ERVBFTkRFTkNJRVMuVGV4dFRvU3BlZWNoRmVhdHVyZS5wYXVzZT0nX29uUGF1c2UnXSAtXG4gKiBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIFRleHRUb1NwZWVjaEZlYXR1cmUgcGF1c2VcbiAqIGV2ZW50cyBhcmUgZW1pdHRlZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRfREVQRU5ERU5DSUVTLlRleHRUb1NwZWVjaEZlYXR1cmUucmVzdW1lPSdfb25SZXN1bWUnXSAtXG4gKiBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIFRleHRUb1NwZWVjaEZlYXR1cmUgcmVzdW1lXG4gKiBldmVudHMgYXJlIGVtaXR0ZWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UX0RFUEVOREVOQ0lFUy5UZXh0VG9TcGVlY2hGZWF0dXJlLnN0b3A9J19vblN0b3AnXSAtXG4gKiBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIFRleHRUb1NwZWVjaEZlYXR1cmUgc3RvcFxuICogZXZlbnRzIGFyZSBlbWl0dGVkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVF9ERVBFTkRFTkNJRVMuVGV4dFRvU3BlZWNoRmVhdHVyZS5zZW50ZW5jZT0nX29uU2VudGVuY2UnXSAtXG4gKiBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIFRleHRUb1NwZWVjaEZlYXR1cmUgc2VudGVuY2VcbiAqIGV2ZW50cyBhcmUgZW1pdHRlZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRfREVQRU5ERU5DSUVTLlRleHRUb1NwZWVjaEZlYXR1cmUud29yZD0nX29uV29yZCddIC1cbiAqIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gVGV4dFRvU3BlZWNoRmVhdHVyZSB3b3JkXG4gKiBldmVudHMgYXJlIGVtaXR0ZWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UX0RFUEVOREVOQ0lFUy5UZXh0VG9TcGVlY2hGZWF0dXJlLnZpc2VtZT0nX29uVmlzZW1lJ10gLVxuICogVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBUZXh0VG9TcGVlY2hGZWF0dXJlIHZpc2VtZVxuICogZXZlbnRzIGFyZSBlbWl0dGVkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVF9ERVBFTkRFTkNJRVMuVGV4dFRvU3BlZWNoRmVhdHVyZS5zc21sPSdfb25Tc21sJ10gLVxuICogVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBUZXh0VG9TcGVlY2hGZWF0dXJlIHNzbWxcbiAqIGV2ZW50cyBhcmUgZW1pdHRlZC5cbiAqL1xuY2xhc3MgVGV4dFRvU3BlZWNoRmVhdHVyZURlcGVuZGVudEludGVyZmFjZSBleHRlbmRzIEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2Uge1xuICAvKipcbiAgICogRXhlY3V0ZWQgd2hlbiBzcGVlY2ggcGxheSBldmVudHMgYXJlIGNhdWdodC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblBsYXkoKSB7fVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlZCB3aGVuIHNwZWVjaCBwYXVzZSBldmVudHMgYXJlIGNhdWdodC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblBhdXNlKCkge31cblxuICAvKipcbiAgICogRXhlY3V0ZWQgd2hlbiBzcGVlY2ggcmVzdW1lIGV2ZW50cyBhcmUgY2F1Z2h0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uUmVzdW1lKCkge31cblxuICAvKipcbiAgICogRXhlY3V0ZWQgd2hlbiBzcGVlY2ggc3RvcCBldmVudHMgYXJlIGNhdWdodC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblN0b3AoKSB7fVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlZCB3aGVuIHNwZWVjaCBzZW50ZW5jZSBldmVudHMgYXJlIGNhdWdodC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblNlbnRlbmNlKCkge31cblxuICAvKipcbiAgICogRXhlY3V0ZWQgd2hlbiBzcGVlY2ggd29yZCBldmVudHMgYXJlIGNhdWdodC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbldvcmQoKSB7fVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlZCB3aGVuIHNwZWVjaCB2aXNlbWUgZXZlbnRzIGFyZSBjYXVnaHQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25WaXNlbWUoKSB7fVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlZCB3aGVuIHNwZWVjaCBzc21sIGV2ZW50cyBhcmUgY2F1Z2h0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uU3NtbCgpIHt9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjbGFzcyB0aGF0IGltcGxlbWVudHMge0BsaW5rIFRleHRUb1NwZWVjaEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2V9XG4gICAqIGFuZCBleHRlbmRzIGEgc3BlY2lmaWVkIGJhc2UgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2xhc3N9IEJhc2VDbGFzcyAtIFRoZSBjbGFzcyB0byBleHRlbmQuXG4gICAqXG4gICAqIEByZXR1cm4ge0NsYXNzfSBBIGNsYXNzIHRoYXQgZXh0ZW5kcyBgQmFzZUNsYXNzYCBhbmQgaW1wbGVtZW50cyB7QGxpbmsgVGV4dFRvU3BlZWNoRmVhdHVyZURlcGVuZGVudEludGVyZmFjZX0uXG4gICAqL1xuICBzdGF0aWMgTWl4aW4oQmFzZUNsYXNzKSB7XG4gICAgY29uc3QgUGFyZW50Q2xhc3MgPSBGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlLk1peGluKEJhc2VDbGFzcyk7XG4gICAgY29uc3QgVGV4dFRvU3BlZWNoRmVhdHVyZURlcGVuZGVudE1peGluID0gY2xhc3MgZXh0ZW5kcyBQYXJlbnRDbGFzcyB7XG4gICAgICBfb25QbGF5KCkge31cblxuICAgICAgX29uUGF1c2UoKSB7fVxuXG4gICAgICBfb25SZXN1bWUoKSB7fVxuXG4gICAgICBfb25TdG9wKCkge31cblxuICAgICAgX29uU2VudGVuY2UoKSB7fVxuXG4gICAgICBfb25Xb3JkKCkge31cblxuICAgICAgX29uVmlzZW1lKCkge31cblxuICAgICAgX29uU3NtbCgpIHt9XG4gICAgfTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFRleHRUb1NwZWVjaEZlYXR1cmVEZXBlbmRlbnRNaXhpbiwge1xuICAgICAgRVZFTlRfREVQRU5ERU5DSUVTOiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgLi4uUGFyZW50Q2xhc3MuRVZFTlRfREVQRU5ERU5DSUVTLFxuICAgICAgICAgIC4uLlRleHRUb1NwZWVjaEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UuRVZFTlRfREVQRU5ERU5DSUVTLFxuICAgICAgICB9LFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIFRleHRUb1NwZWVjaEZlYXR1cmVEZXBlbmRlbnRNaXhpbjtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhUZXh0VG9TcGVlY2hGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlLCB7XG4gIEVWRU5UX0RFUEVOREVOQ0lFUzoge1xuICAgIHZhbHVlOiB7XG4gICAgICBUZXh0VG9TcGVlY2hGZWF0dXJlOiB7XG4gICAgICAgIHBsYXk6ICdfb25QbGF5JyxcbiAgICAgICAgcGF1c2U6ICdfb25QYXVzZScsXG4gICAgICAgIHJlc3VtZTogJ19vblJlc3VtZScsXG4gICAgICAgIHN0b3A6ICdfb25TdG9wJyxcbiAgICAgICAgc2VudGVuY2U6ICdfb25TZW50ZW5jZScsXG4gICAgICAgIHdvcmQ6ICdfb25Xb3JkJyxcbiAgICAgICAgdmlzZW1lOiAnX29uVmlzZW1lJyxcbiAgICAgICAgc3NtbDogJ19vblNzbWwnLFxuICAgICAgfSxcbiAgICB9LFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgfSxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBUZXh0VG9TcGVlY2hGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlO1xuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSAnLi9NYXRoVXRpbHMnO1xuaW1wb3J0IHtRdWFkcmF0aWN9IGZyb20gJy4vYW5pbXBhY2svRWFzaW5nJztcbmltcG9ydCBNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2UgZnJvbSAnLi9hbmltcGFjay9NYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2UnO1xuaW1wb3J0IFRleHRUb1NwZWVjaEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UgZnJvbSAnLi9hd3NwYWNrL1RleHRUb1NwZWVjaEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UnO1xuaW1wb3J0IEFic3RyYWN0SG9zdEZlYXR1cmUgZnJvbSAnLi9BYnN0cmFjdEhvc3RGZWF0dXJlJztcblxuLyoqXG4gKiBEZWZhdWx0IG1hcHBpbmcgb2YgUG9sbHkgdmlzZW1lIG5hbWVzIHRvIGFuaW1hdGlvbiBvcHRpb25zIG9iamVjdHMuXG4gKlxuICogQHByb3BlcnR5IHtPYmplY3R9IFtzaWw9e25hbWU6ICdzaWwnfV1cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbcD17bmFtZTogJ3AnLCBvdmVycmlkZVdlaWdodDogMC45fV1cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbdD17bmFtZTogJ3QnLCBibGVuZFRpbWU6IDAuMn1dXG4gKiBAcHJvcGVydHkge09iamVjdH0gW1M9e25hbWU6ICdTJ31dXG4gKiBAcHJvcGVydHkge09iamVjdH0gW1Q9e25hbWU6ICdUJ31dXG4gKiBAcHJvcGVydHkge09iamVjdH0gW2Y9e25hbWU6ICdmJywgb3ZlcnJpZGVXZWlnaHQ6IDAuNzV9XVxuICogQHByb3BlcnR5IHtPYmplY3R9IFtrPXtuYW1lOiAnayd9XVxuICogQHByb3BlcnR5IHtPYmplY3R9IFtpPXtuYW1lOiAnaSd9XVxuICogQHByb3BlcnR5IHtPYmplY3R9IFtyPXtuYW1lOiAncid9XVxuICogQHByb3BlcnR5IHtPYmplY3R9IFtzPXtuYW1lOiAncycsIGJsZW5kVGltZTogMC4yNX1dXG4gKiBAcHJvcGVydHkge09iamVjdH0gW3U9e25hbWU6ICd1J31dXG4gKiBAcHJvcGVydHkge09iamVjdH0gW0A9e25hbWU6ICdAJ31dXG4gKiBAcHJvcGVydHkge09iamVjdH0gW2E9e25hbWU6ICdhJ31dXG4gKiBAcHJvcGVydHkge09iamVjdH0gW2U9e25hbWU6ICdlJywgYmxlbmRUaW1lOiAwLjJ9XVxuICogQHByb3BlcnR5IHtPYmplY3R9IFtFPXtuYW1lOiAnRSd9XVxuICogQHByb3BlcnR5IHtPYmplY3R9IFtvPXtuYW1lOiAnbyd9XVxuICogQHByb3BlcnR5IHtPYmplY3R9IFtPPXtuYW1lOiAnTyd9XVxuICovXG5jb25zdCBEZWZhdWx0VmlzZW1lTWFwID0ge1xuICBzaWw6IHtuYW1lOiAnc2lsJ30sXG4gIHA6IHtuYW1lOiAncCcsIG92ZXJyaWRlV2VpZ2h0OiAwLjl9LFxuICB0OiB7bmFtZTogJ3QnLCBibGVuZFRpbWU6IDAuMn0sXG4gIFM6IHtuYW1lOiAnUyd9LFxuICBUOiB7bmFtZTogJ1QnfSxcbiAgZjoge25hbWU6ICdmJywgb3ZlcnJpZGVXZWlnaHQ6IDAuNzV9LFxuICBrOiB7bmFtZTogJ2snfSxcbiAgaToge25hbWU6ICdpJ30sXG4gIHI6IHtuYW1lOiAncid9LFxuICBzOiB7bmFtZTogJ3MnLCBibGVuZFRpbWU6IDAuMjV9LFxuICB1OiB7bmFtZTogJ3UnfSxcbiAgJ0AnOiB7bmFtZTogJ0AnfSxcbiAgYToge25hbWU6ICdhJ30sXG4gIGU6IHtuYW1lOiAnZScsIGJsZW5kVGltZTogMC4yfSxcbiAgRToge25hbWU6ICdFJ30sXG4gIG86IHtuYW1lOiAnbyd9LFxuICBPOiB7bmFtZTogJ08nfSxcbn07XG5cbi8qKlxuICogTGlwc3luYyBjb250cm9scyB0d28gdHlwZXMgb2YgbW92ZW1lbnQ6IGlkbGUgYW5pbWF0aW9uIHRoYXQgc2hvdWxkIHBsYXkgd2hpbGVcbiAqIHNwZWVjaCBpcyBwbGF5aW5nIGFuZCB2aXNlbWUgYW5pbWF0aW9ucyBjb3JyZXNwb25kaW5nIHRvIFBvbGx5IHZpc2VtZXMgd2hvc2VcbiAqIHdlaWdodHMgc2hvdWxkIGJlIHR1cm5lZCBvbiBhbmQgb2ZmIGFzIHRoZXkgYXJlIGVuY291bnRlcmVkIGluIHRoZSBQb2xseSBTU01MXG4gKiB0cmFuc2NyaXB0LiBMYXllcnMgb3duZWQgYnkgdGhpcyBmZWF0dXJlIHdpbGwgYmUgZW5hYmxlZCB3aGlsZSBzcGVlY2ggaXMgcGxheWluZ1xuICogYW5kIGRpc2FibGVkIG9uY2UgaXQgc3RvcHMuXG4gKlxuICogQGV4dGVuZHMgQWJzdHJhY3RIb3N0RmVhdHVyZVxuICogQGFsaWFzIGNvcmUvTGlwc3luY0ZlYXR1cmVcbiAqIEBpbXBsZW1lbnRzIFRleHRUb1NwZWVjaEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2VcbiAqIEBpbXBsZW1lbnRzIE1hbmFnZWRBbmltYXRpb25MYXllckludGVyZmFjZVxuICovXG5jbGFzcyBMaXBzeW5jRmVhdHVyZSBleHRlbmRzIEFic3RyYWN0SG9zdEZlYXR1cmUubWl4KFxuICBUZXh0VG9TcGVlY2hGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlLk1peGluLFxuICBNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2UuTWl4aW5cbikge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7Y29yZS9Ib3N0T2JqZWN0fSBob3N0IC0gSG9zdCB0aGF0IG93bnMgdGhlIGZlYXR1cmUuXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gdmlzZW1lT3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSB2aXNlbWUgbGF5ZXJzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3Zpc2VtZU9wdGlvbnMuYmxlbmRUaW1lPTAuMTVdIC0gRGVmYXVsdCBhbW91bnQgb2YgdGltZSBpdFxuICAgKiB3aWxsIHRha2UgdG8gbWFuaXB1bGF0ZSBlYWNoIGZyZWVCbGVuZCB3ZWlnaHQgb24gdGhlIHZpc2VtZSBzdGF0ZXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbdmlzZW1lT3B0aW9ucy5kZWNheVJhdGU9e2Ftb3VudDogLjUsIHNlY29uZHM6IC41fV0gLSBBbiBvYmplY3RcbiAgICogZGVzY3JpYmluZyB0aGUgMC0xIGZhY3RvciB2aXNlbWUgd2VpZ2h0IHdpbGwgZGVjYXkgaWYgdGhlIHZpc2VtZSBkdXJhdGlvbiBpc1xuICAgKiBsb25nZXIgdGhhbiB0aGUgYmxlbmRUaW1lIGFuZCB0aGUgbnVtYmVyIG9mIHNlY29uZHMgaXQgd291bGQgdGFrZSB0byBkZWNheVxuICAgKiBieSB0aGF0IGZhY3Rvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFt2aXNlbWVPcHRpb25zLmVhc2luZ0ZuPVF1YWRyYXRpYy5Jbk91dF0gLSBEZWZhdWx0IGVhc2luZyBmdW5jdGlvblxuICAgKiB0byB1c2Ugd2hlbiBtYW5pcHVsYXRpbmcgdmlzZW1lIGZyZWVCbGVuZCB3ZWlnaHRzLlxuICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBbdmlzZW1lT3B0aW9ucy4ubGF5ZXJzPVtdXSAtIEFuIGFycmF5IG9mIGxheWVyIG9wdGlvbnNcbiAgICogb2JqZWN0cyB0byByZWdpc3RlciBhcyB2aXNlbWUgbGF5ZXJzLlxuICAgKiBAcGFyYW0ge09iamVjdD19IHRhbGtpbmdPcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIHRhbGtpbmcgbGF5ZXJzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3RhbGtpbmdPcHRpb25zLmJsZW5kVGltZT0wLjc1XSAtIERlZmF1bHQgYW1vdW50IG9mIHRpbWUgdG9cbiAgICogZW5hYmxlIGFuZCBkaXNhYmxlIHRoZSB0YWxraW5nIGlkbGUgbGF5ZXJzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdGFsa2luZ09wdGlvbnMuZWFzaW5nRm49UXVhZHJhdGljLkluT3V0XSAtIERlZmF1bHQgZWFzaW5nXG4gICAqIGZ1bmN0aW9uIHRvIHVzZSB3aGVuIG1hbmlwdWxhdGluZyB3ZWlnaHRzIG9uIHRoZSB0YWxraW5nIGlkbGUgbGF5ZXJzLlxuICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBbdGFsa2luZ09wdGlvbnMubGF5ZXJzPVtdXSAtIEFuIGFycmF5IG9mIGxheWVyIG9wdGlvbnNcbiAgICogb2JqZWN0cyB0byByZWdpc3RlciBhcyB0YWxraW5nIGxheWVycy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFt2aXNlbWVMZWFkVGltZT0uMDY3XSAtIFRoZSBhbW91bnQgb2YgdGltZSB0byBpbnN0cnVjdCB0aGVcbiAgICogVGV4dFRvU3BlZWNoRmVhdHVyZSB0byBlbWl0IHNwZWVjaG1hcmtzIGJlZm9yZSBlYWNoIG9uZSdzIGFjdHVhbCB0aW1lc3RhbXBcbiAgICogaXMgcmVhY2hlZC4gVGhpcyB3aWxsIHNldCB0aGUgJ3NwZWVjaE1hcmtPZmZzZXQnIHZhcmlhYmxlIG9uIHRoZSBUZXh0VG9TcGVlY2hGZWF0dXJlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgaG9zdCxcbiAgICB7XG4gICAgICBibGVuZFRpbWU6IHZpc2VtZUJsZW5kVGltZSA9IDAuMTUsXG4gICAgICBkZWNheVJhdGU6IHthbW91bnQgPSAwLjUsIHNlY29uZHMgPSAwLjV9ID0ge30sXG4gICAgICBlYXNpbmdGbjogdmlzZW1lRWFzaW5nRm4gPSBRdWFkcmF0aWMuSW5PdXQsXG4gICAgICBsYXllcnM6IHZpc2VtZUxheWVycyA9IFtdLFxuICAgIH0gPSB7fSxcbiAgICB7XG4gICAgICBibGVuZFRpbWU6IHRhbGtpbmdCbGVuZFRpbWUgPSAwLjc1LFxuICAgICAgZWFzaW5nRm46IHRhbGtpbmdFYXNpbmdGbiA9IFF1YWRyYXRpYy5Jbk91dCxcbiAgICAgIGxheWVyczogdGFsa2luZ0xheWVycyA9IFtdLFxuICAgIH0gPSB7fSxcbiAgICB2aXNlbWVMZWFkVGltZSA9IDAuMDY3XG4gICkge1xuICAgIHN1cGVyKGhvc3QpO1xuXG4gICAgdGhpcy5fdmlzZW1lTGF5ZXJzID0ge307XG4gICAgdGhpcy5fdGFsa2luZ0xheWVycyA9IHt9O1xuICAgIHRoaXMudmlzZW1lTGVhZFRpbWUgPSB2aXNlbWVMZWFkVGltZTtcblxuICAgIC8vIFJlZ2lzdGVyIHRoZSB2aXNlbWUgbGF5ZXJzXG4gICAgdmlzZW1lTGF5ZXJzLmZvckVhY2goKHtuYW1lLCBhbmltYXRpb24sIHZpc2VtZU1hcCA9IERlZmF1bHRWaXNlbWVNYXB9KSA9PiB7XG4gICAgICB0aGlzLnJlZ2lzdGVyVmlzZW1lTGF5ZXIobmFtZSwge1xuICAgICAgICBhbmltYXRpb24sXG4gICAgICAgIHZpc2VtZU1hcCxcbiAgICAgICAgZGVjYXlSYXRlOiB7YW1vdW50LCBzZWNvbmRzfSxcbiAgICAgICAgYmxlbmRUaW1lOiB2aXNlbWVCbGVuZFRpbWUsXG4gICAgICAgIGVhc2luZ0ZuOiB2aXNlbWVFYXNpbmdGbixcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gUmVnaXN0ZXIgdGhlIHRhbGtpbmcgbGF5ZXJzXG4gICAgdGFsa2luZ0xheWVycy5mb3JFYWNoKCh7bmFtZSwgYW5pbWF0aW9ufSkgPT4ge1xuICAgICAgdGhpcy5yZWdpc3RlclRhbGtpbmdMYXllcihuYW1lLCB7XG4gICAgICAgIGFuaW1hdGlvbixcbiAgICAgICAgYmxlbmRUaW1lOiB0YWxraW5nQmxlbmRUaW1lLFxuICAgICAgICBlYXNpbmdGbjogdGFsa2luZ0Vhc2luZ0ZuLFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRW5zdXJlIHRoYXQgcmVnaXN0ZXJlZCB2aXNlbWUgYW5pbWF0aW9ucyBhcmUgRnJlZUJsZW5kU3RhdGVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCBjb250YWlucyB0aGUgdmlzZW1lIGFuaW1hdGlvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFuaW1hdGlvbk5hbWUgLSBOYW1lIG9mIHRoZSBhbmltYXRpb24uXG4gICAqL1xuICBfcmVnaXN0ZXJWaXNlbWVBbmltYXRpb24obGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lKSB7XG4gICAgaWYgKHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXS5hbmltYXRpb25zW2FuaW1hdGlvbk5hbWVdLmlzQWN0aXZlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5nZXRBbmltYXRpb25UeXBlKFxuICAgICAgICAgIGxheWVyTmFtZSxcbiAgICAgICAgICBhbmltYXRpb25OYW1lXG4gICAgICAgICkgIT09ICdmcmVlQmxlbmQnXG4gICAgICApIHtcbiAgICAgICAgLy8gV2FybiBhbmQgZGVhY3RpdmF0ZSBpZiB0aGUgcmVnaXN0ZXJlZCBzdGF0ZSBpcyBub3QgZnJlZUJsZW5kXG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgQ2Fubm90IHJlZ2lzdGVyIExpcHN5bmMgdmlzZW1lIGFuaW1hdGlvbiAke2FuaW1hdGlvbk5hbWV9IG9uIGxheWVyICR7bGF5ZXJOYW1lfSBmb3IgaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBWaXNlbWUgYW5pbWF0aW9ucyBtdXN0IGJlIG9mIHR5cGUgJ2ZyZWVCbGVuZCcuYFxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0uYW5pbWF0aW9uc1tcbiAgICAgICAgICBhbmltYXRpb25OYW1lXG4gICAgICAgIF0uaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBibGVuZFdlaWdodHMgY2FuIGJlIG1hbmlwdWxhdGVkIG5vd1xuICAgICAgICBjb25zdCB3ZWlnaHROYW1lcyA9IHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5nZXRBbmltYXRpb25CbGVuZE5hbWVzKFxuICAgICAgICAgIGxheWVyTmFtZSxcbiAgICAgICAgICBhbmltYXRpb25OYW1lXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHt2aXNlbWVNYXB9ID0gdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdLmFuaW1hdGlvbnNbXG4gICAgICAgICAgYW5pbWF0aW9uTmFtZVxuICAgICAgICBdO1xuXG4gICAgICAgIE9iamVjdC52YWx1ZXModmlzZW1lTWFwKS5mb3JFYWNoKHZpc2VtZU9wdGlvbnMgPT4ge1xuICAgICAgICAgIHZpc2VtZU9wdGlvbnMuaXNBY3RpdmUgPSB3ZWlnaHROYW1lcy5pbmNsdWRlcyh2aXNlbWVPcHRpb25zLm5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSWYgdGhlIGFkZGVkIGZlYXR1cmUgaXMgVGV4dFRvU3BlZWNoLCB1cGRhdGUgaXRzIHNwZWVjaE1hcmtPZmZzZXQgdmFyaWFibGUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlTmFtZSAtIE5hbWUgb2YgdGhlIHR5cGUgb2YgZmVhdHVyZSB0aGF0IHdhcyBhZGRlZC5cbiAgICovXG4gIF9vbkZlYXR1cmVBZGRlZCh0eXBlTmFtZSkge1xuICAgIHRoaXMuX3Zpc2VtZUxheWVycyA9IHRoaXMuX3Zpc2VtZUxheWVycyB8fCB7fTtcbiAgICB0aGlzLl90YWxraW5nTGF5ZXJzID0gdGhpcy5fdGFsa2luZ0xheWVycyB8fCB7fTtcblxuICAgIHN1cGVyLl9vbkZlYXR1cmVBZGRlZCh0eXBlTmFtZSk7XG5cbiAgICBpZiAodHlwZU5hbWUgPT09ICdUZXh0VG9TcGVlY2hGZWF0dXJlJykge1xuICAgICAgdGhpcy5faG9zdC5UZXh0VG9TcGVlY2hGZWF0dXJlLnNwZWVjaG1hcmtPZmZzZXQgPVxuICAgICAgICAtdGhpcy5fdmlzZW1lTGVhZFRpbWUgfHwgMDtcbiAgICB9XG4gIH1cblxuICBfb25MYXllckFkZGVkKHtuYW1lfSkge1xuICAgIHN1cGVyLl9vbkxheWVyQWRkZWQoe25hbWV9KTtcblxuICAgIC8vIFZhbGlkYXRlIHRoZSB2aXNlbWUgYW5pbWF0aW9uXG4gICAgaWYgKHRoaXMuX3Zpc2VtZUxheWVyc1tuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9yZWdpc3RlclZpc2VtZUFuaW1hdGlvbihuYW1lLCB0aGlzLl92aXNlbWVMYXllcnNbbmFtZV0pO1xuICAgIH1cbiAgfVxuXG4gIF9vbkFuaW1hdGlvbkFkZGVkKHtsYXllck5hbWUsIGFuaW1hdGlvbk5hbWV9KSB7XG4gICAgc3VwZXIuX29uQW5pbWF0aW9uQWRkZWQoe2xheWVyTmFtZX0pO1xuXG4gICAgLy8gVmFsaWRhdGUgdGhlIHZpc2VtZSBhbmltYXRpb25cbiAgICBpZiAodGhpcy5fdmlzZW1lTGF5ZXJzW2xheWVyTmFtZV0gPT09IGFuaW1hdGlvbk5hbWUpIHtcbiAgICAgIHRoaXMuX3JlZ2lzdGVyVmlzZW1lQW5pbWF0aW9uKGxheWVyTmFtZSwgdGhpcy5fdmlzZW1lTGF5ZXJzW2xheWVyTmFtZV0pO1xuICAgIH1cbiAgfVxuXG4gIF9vblBsYXkoKSB7XG4gICAgLy8gVHVybiBvbiB0aGUgbGF5ZXIgd2VpZ2h0c1xuICAgIHRoaXMuZW5hYmxlKCk7XG5cbiAgICAvLyBTZXQgdGhlIGN1cnJlbnQgYW5pbWF0aW9uc1xuICAgIFt0aGlzLl92aXNlbWVMYXllcnMsIHRoaXMuX3RhbGtpbmdMYXllcnNdLmZvckVhY2gobGF5ZXJzID0+IHtcbiAgICAgIE9iamVjdC5lbnRyaWVzKGxheWVycykuZm9yRWFjaCgoW2xheWVyTmFtZSwgYW5pbWF0aW9uTmFtZV0pID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXS5hbmltYXRpb25zW2FuaW1hdGlvbk5hbWVdLmlzQWN0aXZlKSB7XG4gICAgICAgICAgdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlLnJlc3VtZUFuaW1hdGlvbihsYXllck5hbWUsIGFuaW1hdGlvbk5hbWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIF9vblBhdXNlKCkge1xuICAgIHRoaXMuX29uU3RvcCgpO1xuICB9XG5cbiAgX29uUmVzdW1lKCkge1xuICAgIHRoaXMuX29uUGxheSgpO1xuICB9XG5cbiAgX29uU3RvcCgpIHtcbiAgICAvLyBUdXJuIG9mZiB0aGUgbGF5ZXIgd2VpZ2h0c1xuICAgIHRoaXMuZGlzYWJsZSgpO1xuXG4gICAgLy8gUGF1c2UgdGhlIGN1cnJlbnQgYW5pbWF0aW9uc1xuICAgIFt0aGlzLl92aXNlbWVMYXllcnMsIHRoaXMuX3RhbGtpbmdMYXllcnNdLmZvckVhY2gobGF5ZXJzID0+IHtcbiAgICAgIE9iamVjdC5lbnRyaWVzKGxheWVycykuZm9yRWFjaCgoW2xheWVyTmFtZSwgYW5pbWF0aW9uTmFtZV0pID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXS5hbmltYXRpb25zW2FuaW1hdGlvbk5hbWVdLmlzQWN0aXZlKSB7XG4gICAgICAgICAgdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlLnBhdXNlQW5pbWF0aW9uKGxheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gdmlzZW1lIGV2ZW50cyBhcmUgY2F1Z2h0LCB0dXJuIG9uIHdlaWdodCBvZiB0aGUgbmV3IHZpc2VtZSBmb3IgdGhlIGR1cmF0aW9uXG4gICAqIG9mIHRoZSBzcGVlY2ggbWFyaywgdGhlbiB0dXJuIHdlaWdodCBiYWNrIG9mZi5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gRXZlbnQgZGF0YSBwYXNzZWQgZnJvbSB0aGUgc3BlZWNoLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQubWFyayAtIFNwZWVjaG1hcmsgb2JqZWN0LlxuICAgKi9cbiAgYXN5bmMgX29uVmlzZW1lKHttYXJrfSkge1xuICAgIE9iamVjdC5lbnRyaWVzKHRoaXMuX3Zpc2VtZUxheWVycykuZm9yRWFjaCgoW2xheWVyTmFtZSwgYW5pbU5hbWVdKSA9PiB7XG4gICAgICAvLyBNYWtlIHN1cmUgdGhlIGxheWVyIGNhbiBiZSBtYW5pcHVsYXRlZFxuICAgICAgY29uc3Qge2lzQWN0aXZlLCB2aXNlbWVNYXB9ID0gdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdLmFuaW1hdGlvbnNbXG4gICAgICAgIGFuaW1OYW1lXG4gICAgICBdO1xuXG4gICAgICBpZiAoIWlzQWN0aXZlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVGFrZSB2YXJpYWJsZXMgZnJvbSB0aGUgdmlzZW1lIGlmIHRoZXkgZXhpc3QgYW5kIGRlZmF1bHQgdG8gdGhlIGxheWVyXG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWU6IHZpc2VtZSxcbiAgICAgICAgaXNBY3RpdmU6IGlzVmlzZW1lQWN0aXZlLFxuICAgICAgICBkZWNheVJhdGUsXG4gICAgICAgIGJsZW5kVGltZSxcbiAgICAgICAgZWFzaW5nRm4sXG4gICAgICAgIG92ZXJyaWRlV2VpZ2h0LFxuICAgICAgfSA9IHtcbiAgICAgICAgLi4udGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdLFxuICAgICAgICAuLi52aXNlbWVNYXBbbWFyay52YWx1ZV0sXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB2aXNlbWVOYW1lcyA9IHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5nZXRBbmltYXRpb25CbGVuZE5hbWVzKFxuICAgICAgICBsYXllck5hbWUsXG4gICAgICAgIGFuaW1OYW1lXG4gICAgICApO1xuXG4gICAgICAvLyBNYWtlIHN1cmUgdGhlIG5ldyB2aXNlbWUgaGFzIGFuIGFjdGl2ZSBmcmVlQmxlbmQgd2VpZ2h0XG4gICAgICBpZiAoIWlzVmlzZW1lQWN0aXZlIHx8ICF2aXNlbWVOYW1lcy5pbmNsdWRlcyh2aXNlbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gRmluZCB0aGUgcGVhayB3ZWlnaHQgZm9yIHRoZSB2aXNlbWUgYW5kIHRoZSBhbW91bnQgb2YgdGltZSBpdCBzaG91bGRcbiAgICAgIC8vIHRha2UgdG8gcmVhY2ggaXRcbiAgICAgIGxldCB3ZWlnaHQgPSAxO1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBtYXJrLmR1cmF0aW9uIC8gMTAwMDtcbiAgICAgIGlmIChkdXJhdGlvbiA8IGJsZW5kVGltZSkge1xuICAgICAgICBjb25zdCBsZXJwRmFjdG9yID0gYmxlbmRUaW1lID4gMCA/IGR1cmF0aW9uIC8gYmxlbmRUaW1lIDogMTtcbiAgICAgICAgd2VpZ2h0ID1cbiAgICAgICAgICBvdmVycmlkZVdlaWdodCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IG92ZXJyaWRlV2VpZ2h0XG4gICAgICAgICAgICA6IE1hdGhVdGlscy5sZXJwKDAsIDEsIGxlcnBGYWN0b3IpO1xuICAgICAgfVxuICAgICAgY29uc3QgYmxlbmRJblRpbWUgPSBNYXRoLm1pbihkdXJhdGlvbiwgYmxlbmRUaW1lKTtcblxuICAgICAgLy8gRmluZCB0aGUgYW1vdW50IGFuZCB0aW1lIHZpc2VtZSB3aWxsIGJlIGhlbGQgZm9yXG4gICAgICBjb25zdCBob2xkVGltZSA9IGR1cmF0aW9uIC0gYmxlbmRUaW1lO1xuXG4gICAgICBpZiAoaG9sZFRpbWUgPCAwKSB7XG4gICAgICAgIC8vIFBlcmZvcm0gaW4gLT4gb3V0IGFuaW1hdGlvblxuICAgICAgICB0aGlzLl9hbmltYXRlU2ltcGxlVmlzZW1lKFxuICAgICAgICAgIGxheWVyTmFtZSxcbiAgICAgICAgICBhbmltTmFtZSxcbiAgICAgICAgICB2aXNlbWUsXG4gICAgICAgICAgd2VpZ2h0LFxuICAgICAgICAgIGJsZW5kSW5UaW1lLFxuICAgICAgICAgIGJsZW5kVGltZSxcbiAgICAgICAgICBlYXNpbmdGblxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbGVycEZhY3RvciA9XG4gICAgICAgICAgZGVjYXlSYXRlLnNlY29uZHMgPiAwID8gaG9sZFRpbWUgLyBkZWNheVJhdGUuc2Vjb25kcyA6IDE7XG4gICAgICAgIC8vIFBlcmZvcm0gaW4gLT4gaG9sZCAtPiBvdXQgYW5pbWF0aW9uXG4gICAgICAgIGNvbnN0IGRlY2F5V2VpZ2h0ID0gTWF0aFV0aWxzLmxlcnAoXG4gICAgICAgICAgd2VpZ2h0LFxuICAgICAgICAgIHdlaWdodCAqIGRlY2F5UmF0ZS5hbW91bnQsXG4gICAgICAgICAgTWF0aC5taW4oMSwgbGVycEZhY3RvcilcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5fYW5pbWF0ZUhlbGRWaXNlbWUoXG4gICAgICAgICAgbGF5ZXJOYW1lLFxuICAgICAgICAgIGFuaW1OYW1lLFxuICAgICAgICAgIHZpc2VtZSxcbiAgICAgICAgICB3ZWlnaHQsXG4gICAgICAgICAgZGVjYXlXZWlnaHQsXG4gICAgICAgICAgYmxlbmRJblRpbWUsXG4gICAgICAgICAgaG9sZFRpbWUsXG4gICAgICAgICAgYmxlbmRUaW1lLFxuICAgICAgICAgIGVhc2luZ0ZuXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQW5pbWF0ZSBhIHZpc2VtZSBibGVuZCB3ZWlnaHQgdG93YXJkcyBhIHZhbHVlIGFuZCB0aGVuIGJhY2sgdG8gemVyby5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRoYXQgY29udGFpbnMgdGhlIHZpc2VtZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFuaW1OYW1lIC0gTmFtZSBvZiB0aGUgZnJlZWJsZW5kIGFuaW1hdGlvbiB0aGF0IGNvbnRhaW5zXG4gICAqIHRoZSB2aXNlbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2aXNlbWVOYW1lIC0gTmFtZSBvZiB0aGUgYmxlbmQgd2VpZ2h0IHRvIG1hbmlwdWxhdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3ZWlnaHQgLSBQZWFrIHdlaWdodCB0byBhbmltYXRlIHRvd2FyZHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBibGVuZEluVGltZSAtIEFtb3VudCBvZiB0aW1lIGl0IHNob3VsZCB0YWtlIHRvIHJlYWNoIHRoZVxuICAgKiBwZWFrIHdlaWdodC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGJsZW5kT3V0VGltZSAtIEFtb3VudCBvZiB0aW1lIGl0IHNob3VsZCB0YWtlIHRvIGFuaW1hdGUgYmFja1xuICAgKiB0byB6ZXJvIGFmdGVyIHJlYWNoaW5nIHRoZSBwZWFrIHdlaWdodC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFzaW5nRm4gLSBFYXNpbmcgZnVuY3Rpb24gdG8gdXNlIGR1cmluZyBhbmltYXRpb24uXG4gICAqL1xuICBfYW5pbWF0ZVNpbXBsZVZpc2VtZShcbiAgICBsYXllck5hbWUsXG4gICAgYW5pbU5hbWUsXG4gICAgdmlzZW1lTmFtZSxcbiAgICBwZWFrV2VpZ2h0LFxuICAgIGJsZW5kSW5UaW1lLFxuICAgIGJsZW5kT3V0VGltZSxcbiAgICBlYXNpbmdGblxuICApIHtcbiAgICAvLyBBbmltYXRlIHRvd2FyZHMgdGhlIHBlYWsgdmFsdWVcbiAgICBjb25zdCB3ZWlnaHRQcm9taXNlID0gdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlLnNldEFuaW1hdGlvbkJsZW5kV2VpZ2h0KFxuICAgICAgbGF5ZXJOYW1lLFxuICAgICAgYW5pbU5hbWUsXG4gICAgICB2aXNlbWVOYW1lLFxuICAgICAgcGVha1dlaWdodCxcbiAgICAgIGJsZW5kSW5UaW1lLFxuICAgICAgZWFzaW5nRm5cbiAgICApO1xuXG4gICAgLy8gQW5pbWF0ZSBiYWNrIHRvIHplcm8gaWYgdGhlcmUgd2FzIG5vIHdlaWdodCBpbnRlcnJ1cHRpb25cbiAgICB3ZWlnaHRQcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKCF3ZWlnaHRQcm9taXNlLmNhbmNlbGVkKSB7XG4gICAgICAgIHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5zZXRBbmltYXRpb25CbGVuZFdlaWdodChcbiAgICAgICAgICBsYXllck5hbWUsXG4gICAgICAgICAgYW5pbU5hbWUsXG4gICAgICAgICAgdmlzZW1lTmFtZSxcbiAgICAgICAgICAwLFxuICAgICAgICAgIGJsZW5kT3V0VGltZSxcbiAgICAgICAgICBlYXNpbmdGblxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuaW1hdGUgYSB2aXNlbWUgYmxlbmQgd2VpZ2h0IHRvd2FyZHMgYSB2YWx1ZSBhbmQgdGhlbiBiYWNrIHRvIHplcm8uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0aGF0IGNvbnRhaW5zIHRoZSB2aXNlbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbmltTmFtZSAtIE5hbWUgb2YgdGhlIGZyZWVibGVuZCBhbmltYXRpb24gdGhhdCBjb250YWluc1xuICAgKiB0aGUgdmlzZW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlzZW1lTmFtZSAtIE5hbWUgb2YgdGhlIGJsZW5kIHdlaWdodCB0byBtYW5pcHVsYXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGVha1dlaWdodCAtIFBlYWsgd2VpZ2h0IHRvIGFuaW1hdGUgdG93YXJkcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlY2F5V2VpZ2h0IC0gV2VpZ2h0IHRvIGFuaW1hdGUgdG93YXJkcyBhZnRlciByZWFjaGluZyB0aGVcbiAgICogcGVhayB3ZWlnaHQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBibGVuZEluVGltZSAtIEFtb3VudCBvZiB0aW1lIGl0IHNob3VsZCB0YWtlIHRvIHJlYWNoIHRoZVxuICAgKiBwZWFrIHdlaWdodC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhvbGRUaW1lIC0gQW1vdW50IG9mIHRpbWUgaXQgc2hvdWxkIHRha2UgdG8gcmVhY2ggdGhlIGRlY2F5XG4gICAqIHdlaWdodCBhZnRlciB0aGUgcGVhayB3ZWlnaHQgaGFzIGJlZW4gcmVhY2hlZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGJsZW5kT3V0VGltZSAtIEFtb3VudCBvZiB0aW1lIGl0IHNob3VsZCB0YWtlIHRvIGFuaW1hdGUgYmFja1xuICAgKiB0byB6ZXJvIGFmdGVyIHJlYWNoaW5nIHRoZSBkZWNheSB3ZWlnaHQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhc2luZ0ZuIC0gRWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSBkdXJpbmcgYW5pbWF0aW9uLlxuICAgKi9cbiAgYXN5bmMgX2FuaW1hdGVIZWxkVmlzZW1lKFxuICAgIGxheWVyTmFtZSxcbiAgICBhbmltTmFtZSxcbiAgICB2aXNlbWVOYW1lLFxuICAgIHBlYWtXZWlnaHQsXG4gICAgZGVjYXlXZWlnaHQsXG4gICAgYmxlbmRJblRpbWUsXG4gICAgaG9sZFRpbWUsXG4gICAgYmxlbmRPdXRUaW1lLFxuICAgIGVhc2luZ0ZuXG4gICkge1xuICAgIC8vIEFuaW1hdGUgdG93YXJkcyB0aGUgcGVhayB2YWx1ZVxuICAgIGNvbnN0IHN0YXJ0UHJvbWlzZSA9IHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5zZXRBbmltYXRpb25CbGVuZFdlaWdodChcbiAgICAgIGxheWVyTmFtZSxcbiAgICAgIGFuaW1OYW1lLFxuICAgICAgdmlzZW1lTmFtZSxcbiAgICAgIHBlYWtXZWlnaHQsXG4gICAgICBibGVuZEluVGltZSxcbiAgICAgIGVhc2luZ0ZuXG4gICAgKTtcblxuICAgIGF3YWl0IHN0YXJ0UHJvbWlzZTtcblxuICAgIGlmICghc3RhcnRQcm9taXNlLmNhbmNlbGVkKSB7XG4gICAgICAvLyBBbmltYXRlIHRvd2FyZHMgdGhlIGRlY2F5IHZhbHVlIGlmIHRoZXJlIHdhcyBubyB3ZWlnaHQgaW50ZXJydXB0aW9uXG4gICAgICBjb25zdCBob2xkUHJvbWlzZSA9IHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5zZXRBbmltYXRpb25CbGVuZFdlaWdodChcbiAgICAgICAgbGF5ZXJOYW1lLFxuICAgICAgICBhbmltTmFtZSxcbiAgICAgICAgdmlzZW1lTmFtZSxcbiAgICAgICAgZGVjYXlXZWlnaHQsXG4gICAgICAgIGhvbGRUaW1lLFxuICAgICAgICBlYXNpbmdGblxuICAgICAgKTtcblxuICAgICAgYXdhaXQgaG9sZFByb21pc2U7XG5cbiAgICAgIGlmICghaG9sZFByb21pc2UuY2FuY2VsZWQpIHtcbiAgICAgICAgLy8gQW5pbWF0ZSBiYWNrIHRvIHplcm8gaWYgdGhlcmUgd2FzIG5vIHdlaWdodCBpbnRlcnJ1cHRpb25cbiAgICAgICAgdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlLnNldEFuaW1hdGlvbkJsZW5kV2VpZ2h0KFxuICAgICAgICAgIGxheWVyTmFtZSxcbiAgICAgICAgICBhbmltTmFtZSxcbiAgICAgICAgICB2aXNlbWVOYW1lLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgYmxlbmRPdXRUaW1lLFxuICAgICAgICAgIGVhc2luZ0ZuXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW5kIHNldHMgdGhlIGFtb3VudCBvZiB0aW1lIGluIHNlY29uZHMgdG8gbmVnYXRpdmVseSBvZmZzZXQgc3BlZWNobWFya1xuICAgKiBlbWlzc2lvbiBieS5cbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB2aXNlbWVMZWFkVGltZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlzZW1lTGVhZFRpbWU7XG4gIH1cblxuICBzZXQgdmlzZW1lTGVhZFRpbWUoc2Vjb25kcykge1xuICAgIHRoaXMuX3Zpc2VtZUxlYWRUaW1lID0gc2Vjb25kcztcblxuICAgIGlmICh0aGlzLl9ob3N0LlRleHRUb1NwZWVjaEZlYXR1cmUpIHtcbiAgICAgIHRoaXMuX2hvc3QuVGV4dFRvU3BlZWNoRmVhdHVyZS5zcGVlY2htYXJrT2Zmc2V0ID0gLXNlY29uZHM7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGtlZXBpbmcgdHJhY2sgb2YgYW4gYW5pbWF0aW9uIGxheWVyIHRoYXQgb3ducyBhIGZyZWVCbGVuZCBhbmltYXRpb25cbiAgICogd2l0aCBibGVuZFdlaWdodHMgY29ycmVzcG9uZGluZyB0byB2aXNlbWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdG8ga2VlcCB0cmFjayBvZi5cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGxheWVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uPSd2aXNlbWVzJ10gLSBOYW1lIG9mIHRoZSBhbmltYXRpb24gb24gdGhlXG4gICAqIGxheWVyIHRoYXQgd2lsbCBiZSBwbGF5ZWQgZHVyaW5nIHNwZWVjaC4gVGhpcyBhbmltYXRpb24gbXVzdCBiZSBvZiB0eXBlXG4gICAqIGZyZWVCbGVuZC5cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBkZWNheVJhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWNheVJhdGUuYW1vdW50PTAuNV0gLSBUaGUgcGVyY2VudGFnZSB0byBkZWNyZWFzZSB0aGUgdmlzZW1lJ3NcbiAgICogcGVhayB2YWx1ZSBieSBvdmVyIHRpbWUgb25jZSB0aGUgcGVhayB2YWx1ZSBoYXMgYmVlbiByZWFjaGVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RlY2F5UmF0ZS5zZWNvbmRzPTAuNV0gLSBUaGUgYW1vdW50IG9mIHRpbWUgaW4gc2Vjb25kcyB0b1xuICAgKiBkZWNyZWFzZSB0aGUgdmlzZW1lJ3Mgd2VpZ2h0IG9uY2UgaXQgaGFzIHJlYWNoZWQgaXRzIHBlYWsgdmFsdWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gW29wdGlvbnMuYmxlbmRUaW1lPVtMaXBzeW5jRmVhdHVyZS5ERUZBVUxUX0xBWUVSX09QVElPTlMuYmxlbmRUaW1lXXtAbGluayBMaXBzeW5jRmVhdHVyZSNERUZBVUxUX0xBWUVSX09QVElPTlMjYmxlbmRUaW1lfV0gLVxuICAgKiBEZWZhdWx0IGFtb3VudCBvZiB0aW1lIHRvIHVzZSB3aGVuIG1hbmlwdWxhdGluZyBhbmltYXRpb24gYmxlbmRXZWlnaHRzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb3B0aW9ucy5lYXNpbmdGbiAtIERlZmF1bHQgZWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSB3aGVuXG4gICAqIG1hbmlwdWxhdGluZyBhbmltYXRpb24gYmxlbmRXZWlnaHRzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMudmlzZW1lTWFwPURlZmF1bHRWaXNlbWVNYXBdIC0gT2JqZWN0IGNvbnRhaW5pbmcga2V5L3ZhbHVlIHBhaXJzIG9mXG4gICAqIFBvbGx5IHZpc2VtZSBuYW1lcyBtYXBwZWQgdG8gb2JqZWN0cyBjb250YWluaW5nIHRoZSBuYW1lIG9mIHRoZSBjb3JyZXNwb25kaW5nXG4gICAqIGFuaW1hdGlvbiBibGVuZFdlaWdodCBhbmQgYW55IG90aGVyIGFuaW1hdGlvbiBvcHRpb25zIHRvIHVzZSBzdWNoIGFzIHZpc2VtZVxuICAgKiBzcGVjaWZpYyBibGVuZCB0aW1lcyBhbmQgZWFzaW5nIGZ1bmN0aW9ucy5cbiAgICovXG4gIHJlZ2lzdGVyVmlzZW1lTGF5ZXIoXG4gICAgbGF5ZXJOYW1lLFxuICAgIHtcbiAgICAgIGFuaW1hdGlvbiA9ICd2aXNlbWVzJyxcbiAgICAgIGRlY2F5UmF0ZSA9IHthbW91bnQ6IDAuNSwgc2Vjb25kczogMC41fSxcbiAgICAgIGJsZW5kVGltZSA9IExpcHN5bmNGZWF0dXJlLkRFRkFVTFRfTEFZRVJfT1BUSU9OUy5ibGVuZFRpbWUsXG4gICAgICBlYXNpbmdGbixcbiAgICAgIHZpc2VtZU1hcCA9IERlZmF1bHRWaXNlbWVNYXAsXG4gICAgfSA9IHt9XG4gICkge1xuICAgIC8vIFJlZ2lzdGVyIHRoZSBsYXllciBhbmQgYW5pbWF0aW9uXG4gICAgdGhpcy5yZWdpc3RlckxheWVyKGxheWVyTmFtZSwge1xuICAgICAgZGVjYXlSYXRlLFxuICAgICAgYmxlbmRUaW1lLFxuICAgICAgZWFzaW5nRm4sXG4gICAgICBhbmltYXRpb25zOiB7W2FuaW1hdGlvbl06IHt2aXNlbWVNYXB9fSxcbiAgICB9KTtcbiAgICB0aGlzLl92aXNlbWVMYXllcnNbbGF5ZXJOYW1lXSA9IGFuaW1hdGlvbjtcblxuICAgIC8vIFZhbGlkYXRlIHRoZSB2aXNlbWUgYW5pbWF0aW9uXG4gICAgdGhpcy5fcmVnaXN0ZXJWaXNlbWVBbmltYXRpb24obGF5ZXJOYW1lLCBhbmltYXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGtlZXBpbmcgdHJhY2sgb2YgYW4gYW5pbWF0aW9uIGxheWVyIHRoYXQgY29udGFpbnMgYSBsb29waW5nIGFuaW1hdGlvblxuICAgKiB0byBiZSBwbGF5ZWQgZHVyaW5nIHNwZWVjaC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRvIGtlZXAgdHJhY2sgb2YuXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBsYXllci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbj0nc3RhbmRfdGFsayddIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uIG9uIHRoZVxuICAgKiBsYXllciB0aGF0IHdpbGwgYmUgcGxheWVkIGR1cmluZyBzcGVlY2guXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5ibGVuZFRpbWU9W0xpcHN5bmNGZWF0dXJlLkRFRkFVTFRfTEFZRVJfT1BUSU9OUy5ibGVuZFRpbWVde0BsaW5rIExpcHN5bmNGZWF0dXJlI0RFRkFVTFRfTEFZRVJfT1BUSU9OUyNibGVuZFRpbWV9XSAtXG4gICAqIERlZmF1bHQgYW1vdW50IG9mIHRpbWUgdG8gdXNlIHdoZW4gbWFuaXB1bGF0aW5nIHRoZSBsYXllcidzIHdlaWdodHMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvcHRpb25zLmVhc2luZ0ZuIC0gRGVmYXVsdCBlYXNpbmcgZnVuY3Rpb24gdG8gdXNlIHdoZW5cbiAgICogbWFuaXB1bGF0aW5nIHRoZSBsYXllcidzIHdlaWdodHMuXG4gICAqL1xuICByZWdpc3RlclRhbGtpbmdMYXllcihcbiAgICBsYXllck5hbWUsXG4gICAge1xuICAgICAgYW5pbWF0aW9uID0gJ3N0YW5kX3RhbGsnLFxuICAgICAgYmxlbmRUaW1lID0gTGlwc3luY0ZlYXR1cmUuREVGQVVMVF9MQVlFUl9PUFRJT05TLmJsZW5kVGltZSxcbiAgICAgIGVhc2luZ0ZuLFxuICAgIH0gPSB7fVxuICApIHtcbiAgICAvLyBSZWdpc3RlciB0aGUgbGF5ZXIgYW5kIGFuaW1hdGlvblxuICAgIHRoaXMucmVnaXN0ZXJMYXllcihsYXllck5hbWUsIHtcbiAgICAgIGJsZW5kVGltZSxcbiAgICAgIGVhc2luZ0ZuLFxuICAgICAgYW5pbWF0aW9uczoge1thbmltYXRpb25dOiB7fX0sXG4gICAgfSk7XG4gICAgdGhpcy5fdGFsa2luZ0xheWVyc1tsYXllck5hbWVdID0gYW5pbWF0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBuYW1lc3BhY2UgdG8gdGhlIGhvc3Qgd2l0aCB0aGUgbmFtZSBvZiB0aGUgZmVhdHVyZSB0byBjb250YWluIHByb3BlcnRpZXNcbiAgICogYW5kIG1ldGhvZHMgZnJvbSB0aGUgZmVhdHVyZSB0aGF0IHVzZXJzIG9mIHRoZSBob3N0IG5lZWQgYWNjZXNzIHRvLlxuICAgKlxuICAgKiBAc2VlIExpcHN5bmNGZWF0dXJlXG4gICAqL1xuICBpbnN0YWxsQXBpKCkge1xuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqIEBuYW1lc3BhY2UgTGlwc3luY0ZlYXR1cmVcbiAgICAgKi9cbiAgICBjb25zdCBhcGkgPSBzdXBlci5pbnN0YWxsQXBpKCk7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgTGlwc3luY0ZlYXR1cmVcbiAgICAgKiBAbmFtZSByZWdpc3RlckxheWVyXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBzZWUgTWFuYWdlZEFuaW1hdGlvbkxheWVySW50ZXJmYWNlI3JlZ2lzdGVyTGF5ZXJcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBMaXBzeW5jRmVhdHVyZVxuICAgICAqIEBuYW1lIHJlZ2lzdGVyQW5pbWF0aW9uXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBzZWUgTWFuYWdlZEFuaW1hdGlvbkxheWVySW50ZXJmYWNlI3JlZ2lzdGVyQW5pbWF0aW9uXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgTGlwc3luY0ZlYXR1cmVcbiAgICAgKiBAbmFtZSBzZXRMYXllcldlaWdodHNcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHNlZSBNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2Ujc2V0TGF5ZXJXZWlnaHRzXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgTGlwc3luY0ZlYXR1cmVcbiAgICAgKiBAbmFtZSBlbmFibGVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHNlZSBNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2UjZW5hYmxlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgTGlwc3luY0ZlYXR1cmVcbiAgICAgKiBAbmFtZSBkaXNhYmxlXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBzZWUgTWFuYWdlZEFuaW1hdGlvbkxheWVySW50ZXJmYWNlI2Rpc2FibGVcbiAgICAgKi9cblxuICAgIE9iamVjdC5hc3NpZ24oYXBpLCB7XG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBMaXBzeW5jRmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAc2VlIGNvcmUvTGlwc3luY0ZlYXR1cmUjcmVnaXN0ZXJWaXNlbWVMYXllclxuICAgICAgICovXG4gICAgICByZWdpc3RlclZpc2VtZUxheWVyOiB0aGlzLnJlZ2lzdGVyVmlzZW1lTGF5ZXIuYmluZCh0aGlzKSxcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlcm9mIExpcHN5bmNGZWF0dXJlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEBtZXRob2RcbiAgICAgICAqIEBzZWUgY29yZS9MaXBzeW5jRmVhdHVyZSNyZWdpc3RlclRhbGtpbmdMYXllclxuICAgICAgICovXG4gICAgICByZWdpc3RlclRhbGtpbmdMYXllcjogdGhpcy5yZWdpc3RlclRhbGtpbmdMYXllci5iaW5kKHRoaXMpLFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIExpcHN5bmNGZWF0dXJlXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG5hbWUgdmlzZW1lTGVhZFRpbWVcbiAgICAgKiBAc2VlIGNvcmUvTGlwc3luY0ZlYXR1cmUjdmlzZW1lTGVhZFRpbWVcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBpLCAndmlzZW1lTGVhZFRpbWUnLCB7XG4gICAgICBnZXQ6ICgpID0+IHRoaXMudmlzZW1lTGVhZFRpbWUsXG4gICAgICBzZXQ6IHNlY29uZHMgPT4ge1xuICAgICAgICB0aGlzLnZpc2VtZUxlYWRUaW1lID0gc2Vjb25kcztcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXBpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExpcHN5bmNGZWF0dXJlO1xuZXhwb3J0IHtEZWZhdWx0VmlzZW1lTWFwfTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4vLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtY2xhc3Nlcy1wZXItZmlsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHkgKi9cbmltcG9ydCBUZXh0VG9TcGVlY2hGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlIGZyb20gJ2NvcmUvYXdzcGFjay9UZXh0VG9TcGVlY2hGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlJztcblxuLyoqXG4gKiBDbGFzcyBmYWN0b3J5IGludGVyZmFjZSBmb3IgdGhhdCByZWdpc3RlcnMgY2FsbGJhY2sgbWV0aG9kIHdoZW4gYSBzc21sIHNwZWVjaG1hcmsgZXZlbnQgaXMgZW1pdHRlZC5cbiAqXG4gKiBAaW50ZXJmYWNlXG4gKiBAZXh0ZW5kcyBUZXh0VG9TcGVlY2hGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlXG4gKi9cbmNsYXNzIFNTTUxTcGVlY2htYXJrSW50ZXJmYWNlIGV4dGVuZHMgVGV4dFRvU3BlZWNoRmVhdHVyZURlcGVuZGVudEludGVyZmFjZSB7XG4gIC8qKlxuICAgKiBXaGVuIHNzbWwgZXZlbnRzIGFyZSBjYXVnaHQsIHRoaXMgd2lsbCB0cnkgdG8gcGFyc2UgdGhlIHNwZWVjaCBtYXJrIHZhbHVlIGFuZCBleGVjdXRlIGFueSBmdW5jdGlvbiB3aGljaCBtZWV0cyBjcml0ZXJpYSBkZWZpbmVkIGluIHRoZSB2YWx1ZS5cbiAgICogU3BlZWNoIG1hcmsgdmFsdWUgd2lsbCBiZSB0cmVhdGVkIGFzIHN0cmluZ2lmaWVkIGpzb24gZm9ybWF0IGNvbnRhaW5pbmcgcmVxdWlyZWQgZmVhdHVyZSBuYW1lLCBmdW5jdGlvbiBuYW1lIGFuZCBhcmd1bWVudCBhcnJheSB0byBwYXNzIGluLlxuICAgKiBFeGFtcGxlIHNwZWVjaCBtYXJrIHZhbHVlIG1pZ2h0IGxvb2sgbGlrZTogJ3tcImZlYXR1cmVcIjpcIkdlc3R1cmVGZWF0dXJlXCIsIFwibWV0aG9kXCI6XCJzd2l0Y2hUb0dlc3R1cmVcIiwgXCJhcmdzXCI6W1wiZ2VucmljQVwiLCAwLjVdfSdcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gRXZlbnQgZGF0YSBwYXNzZWQgZnJvbSB0aGUgc3BlZWNoLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQubWFyayAtIFNwZWVjaG1hcmsgb2JqZWN0LlxuICAgKi9cbiAgX29uU3NtbCh7bWFya30pIHt9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjbGFzcyB0aGF0IGltcGxlbWVudHMge0BsaW5rIFNTTUxTcGVlY2htYXJrSW50ZXJmYWNlfVxuICAgKiBhbmQgZXh0ZW5kcyBhIHNwZWNpZmllZCBiYXNlIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge0NsYXNzfSBCYXNlQ2xhc3MgLSBUaGUgY2xhc3MgdG8gZXh0ZW5kLlxuICAgKlxuICAgKiBAcmV0dXJuIHtDbGFzc30gQSBjbGFzcyB0aGF0IGV4dGVuZHMgYEJhc2VDbGFzc2AgYW5kIGltcGxlbWVudHMge0BsaW5rIFNTTUxTcGVlY2htYXJrSW50ZXJmYWNlfS5cbiAgICovXG4gIHN0YXRpYyBNaXhpbihCYXNlQ2xhc3MpIHtcbiAgICBjb25zdCBQYXJlbnRDbGFzcyA9IFRleHRUb1NwZWVjaEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UuTWl4aW4oQmFzZUNsYXNzKTtcbiAgICBjb25zdCBTU01MU3BlZWNoTWFya01peGluID0gY2xhc3MgZXh0ZW5kcyBQYXJlbnRDbGFzcyB7XG4gICAgICBfb25Tc21sKHttYXJrfSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHtmZWF0dXJlLCBtZXRob2QsIGFyZ3N9ID0gSlNPTi5wYXJzZShtYXJrLnZhbHVlKTtcbiAgICAgICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5uYW1lID09PSBmZWF0dXJlKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHRoaXNbbWV0aG9kXTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayAmJiB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgYEZ1bmN0aW9uICR7bWV0aG9kfSBkb2VzIG5vdCBleGlzdCB3aXRoaW4gZmVhdHVyZSAke2ZlYXR1cmV9YFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFNTTUxTcGVlY2hNYXJrTWl4aW47XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU1NNTFNwZWVjaG1hcmtJbnRlcmZhY2U7XG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxuaW1wb3J0IE1hbmFnZWRBbmltYXRpb25MYXllckludGVyZmFjZSBmcm9tICcuL2FuaW1wYWNrL01hbmFnZWRBbmltYXRpb25MYXllckludGVyZmFjZSc7XG5pbXBvcnQgU1NNTFNwZWVjaG1hcmtJbnRlcmZhY2UgZnJvbSAnLi9hd3NwYWNrL1NTTUxTcGVlY2htYXJrSW50ZXJmYWNlJztcbmltcG9ydCBBYnN0cmFjdEhvc3RGZWF0dXJlIGZyb20gJy4vQWJzdHJhY3RIb3N0RmVhdHVyZSc7XG5pbXBvcnQgRGVmZXJyZWQgZnJvbSAnLi9EZWZlcnJlZCc7XG5pbXBvcnQgVXRpbHMgZnJvbSAnLi9VdGlscyc7XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKi9cbmNvbnN0IERlZmF1bHRHZXN0dXJlV29yZHMgPSB7XG4gIGJpZzogW1xuICAgICdhZGQnLFxuICAgICdhYm92ZScsXG4gICAgJ2F1dGhvcml0eScsXG4gICAgJ2JpZycsXG4gICAgJ2NvdmVyJyxcbiAgICAnZnVsbCcsXG4gICAgJ2ZseScsXG4gICAgJ2dyb3cnLFxuICAgICdncm93dGgnLFxuICAgICdoaWdoJyxcbiAgICAnaHVnZScsXG4gICAgJ2luY3JlYXNlJyxcbiAgICAnbWFqb3InLFxuICAgICdtYWpvcml0eScsXG4gICAgJ2xhcmdlJyxcbiAgICAnbGVhZGVyJyxcbiAgICAnbG90JyxcbiAgICAncmFpc2UnLFxuICAgICdyaXNlJyxcbiAgICAndGFsbCcsXG4gIF0sXG4gIGhlYXJ0OiBbXG4gICAgJ2FjY2VwdCcsXG4gICAgJ2FkbWl0JyxcbiAgICAnYmVsaWV2ZScsXG4gICAgJ2NhcmUnLFxuICAgICdmZWVsaW5nJyxcbiAgICAnZmVlbCcsXG4gICAgJ2ZyaWVuZCcsXG4gICAgJ2dyYXRlZnVsJyxcbiAgICAnaGFwcHknLFxuICAgICdoZWFydCcsXG4gICAgJ2h1bWFuJyxcbiAgICAncGFpbicsXG4gICAgJ3NhdmUnLFxuICAgICdzYWZlJyxcbiAgICAna2luZCcsXG4gICAgJ2xvdmUnLFxuICBdLFxuICBpbjogW1xuICAgICdpbmNsdWRlJyxcbiAgICAnaW5jbHVkaW5nJyxcbiAgICAnaW5zaWRlJyxcbiAgICAnaW50bycsXG4gICAgJ25vdycsXG4gICAgJ25lYXInLFxuICAgICduZWFyZXN0JyxcbiAgICAnY2xvc2VzdCcsXG4gICAgJ3RoZXJlaW4nLFxuICAgICd3aXRoaW4nLFxuICBdLFxuICBtYW55OiBbXG4gICAgJ2FsbCcsXG4gICAgJ2Fsd2F5cycsXG4gICAgJ2FueScsXG4gICAgJ2FueW9uZScsXG4gICAgJ2Ftb25nJyxcbiAgICAnYXJlYScsXG4gICAgJ2Fyb3VuZCcsXG4gICAgJ2JlYXV0aWZ1bCcsXG4gICAgJ2VudGlyZScsXG4gICAgJ2Vudmlyb25tZW50JyxcbiAgICAnZW52aXJvbm1lbnRzJyxcbiAgICAnZW52aXJvbm1lbnRhbCcsXG4gICAgJ2V2ZXJ5Ym9keScsXG4gICAgJ2V2ZXJ5b25lJyxcbiAgICAnZXZlcnl0aGluZycsXG4gICAgJ2F1ZGllbmNlJyxcbiAgICAndG90YWwnLFxuICAgICdncm91cCcsXG4gICAgJ2dyb3VwcycsXG4gICAgJ21pbGxpb24nLFxuICAgICdtaWxsaW9ucycsXG4gICAgJ290aGVycycsXG4gICAgJ2JpbGxpb24nLFxuICAgICdiaWxsaW9ucycsXG4gICAgJ2h1bmRyZWQnLFxuICAgICdodW5kcmVkcycsXG4gICAgJ21hbnknLFxuICAgICd0aG91c2FuZCcsXG4gICAgJ3Rob3VzYW5kcycsXG4gICAgJ3dvcmxkJyxcbiAgICAnd29ybGRzJyxcbiAgICAnb3V0c2lkZScsXG4gICAgJ3JldmVhbCcsXG4gIF0sXG4gIG1vdmVtZW50OiBbXG4gICAgJ2F3YXknLFxuICAgICdhY3Jvc3MnLFxuICAgICdhaGVhZCcsXG4gICAgJ2Fsb25nJyxcbiAgICAnZmFyJyxcbiAgICAnZmFzdCcsXG4gICAgJ2ZvbGxvdycsXG4gICAgJ2dvJyxcbiAgICAnbGVhdmUnLFxuICAgICdtb3ZlJyxcbiAgICAnbW92ZW1lbnQnLFxuICAgICd0aHJvdWdoJyxcbiAgICAndGhyb3VnaG91dCcsXG4gICAgJ3Rvd2FyZCcsXG4gICAgJ3RyYXZlbCcsXG4gICAgJ3R1cm5lZCcsXG4gICAgJ3Bhc3NlZCcsXG4gIF0sXG4gIG9uZTogW1xuICAgICdzaW5nbGUnLFxuICAgICdvbmUnLFxuICAgICdvbmNlJyxcbiAgICAnZmlyc3QnLFxuICAgICdmaXJzdGx5JyxcbiAgICAnb25seScsXG4gICAgJ3NvbG8nLFxuICAgICd3YXJuZWQnLFxuICAgICd0cnVseScsXG4gICAgJ3VwJyxcbiAgICAnYWxvbmUnLFxuICBdLFxuICBhZ2dyZXNzaXZlOiBbXG4gICAgJ3Bvd2VyJyxcbiAgICAncG93ZXJzJyxcbiAgICAncG93ZXJmdWwnLFxuICAgICdhc3NlcnQnLFxuICAgICdhc3NlcnRpdmUnLFxuICAgICdzdHJvbmcnLFxuICAgICdzdHJvbmdlcicsXG4gICAgJ3N0cm9uZ2VzdCcsXG4gICAgJ3N0cmVuZ3RoJyxcbiAgICAnZmxleCcsXG4gICAgJ2RhbmcnLFxuICAgICdkYW1uJyxcbiAgICAnZGFtbml0JyxcbiAgICAnZGFybicsXG4gICAgJ3NodWNrcycsXG4gICAgJ2RvaCcsXG4gICAgJ2RyYXQnLFxuICAgICdhbmdyeScsXG4gICAgJ2FuZ3JpZXInLFxuICAgICdhbmdyaWVzdCcsXG4gICAgJ2FnZ3Jlc3NpdmUnLFxuICAgICdhbm5veWVkJyxcbiAgICAnYW5ub3lpbmcnLFxuICAgICdhdHRhY2snLFxuICAgICdhdHRhY2tpbmcnLFxuICAgICdvZmZlbnNlJyxcbiAgICAnb2ZmZW5zaXZlJyxcbiAgICAnYmF0dGxlJyxcbiAgXSxcbiAgeW91OiBbJ3lvdScsICd5YWxsJywgXCJ5J2FsbFwiLCAneW91cicsICd5b3VycycsICd0aG91JywgJ3RoeSddLFxuICBkZWZlbnNlOiBbXG4gICAgJ2RlZmVuc2UnLFxuICAgICdmZWFyJyxcbiAgICAncmVwdWxzZWQnLFxuICAgICdzY2FyZWQnLFxuICAgICdzY2FyeScsXG4gICAgJ3NjYXJpZXInLFxuICAgICdzY2FyaWVzdCcsXG4gICAgJ2ZlYXJmdWwnLFxuICAgICdhZnJhaWQnLFxuICAgICdjb3dlcicsXG4gICAgJ2Nvd2VycycsXG4gICAgJ2Nvd2VyaW5nJyxcbiAgICAnaGlkZW91cycsXG4gICAgJ2Rvb21lZCcsXG4gICAgJ3RlcnJpZmllZCcsXG4gICAgJ3RlcnJpZnknLFxuICAgICd0ZXJyaWZ5aW5nJyxcbiAgICAndGVycmlmaWVzJyxcbiAgICAnc3Bvb2t5JyxcbiAgICAnc3Bvb2tpZXInLFxuICAgICdzcG9va2llc3QnLFxuICBdLFxuICB3YXZlOiBbXG4gICAgJ2hlbGxvJyxcbiAgICAnaGknLFxuICAgICdoaXlhJyxcbiAgICAnaG93ZHknLFxuICAgICd3ZWxjb21lJyxcbiAgICAnYWxvaGEnLFxuICAgICdoZXlhJyxcbiAgICAnaGV5JyxcbiAgICAnYnllJyxcbiAgICAnZ29vZGJ5ZScsXG4gICAgJ2hvbGEnLFxuICAgICdhZGlvcycsXG4gICAgJ2NoYW8nLFxuICBdLFxuICBzZWxmOiBbJ215JywgJ0knLCAnbXlzZWxmJywgJ3NlbGYnLCBcIkkndmVcIiwgJ0l2ZScsICdtZScsICdtaW5lJywgJ293biddLFxufTtcblxuLyoqXG4gKiBHZXN0dXJlIGFsbG93cyB5b3UgdG8gcGxheSBhbmltYXRpb25zIG9uIGRlbWFuZCBvbiBvbmUgb3IgbW9yZSBsYXllcnMgZnJvbSBzY3JpcHRcbiAqIG9yIHNzbWwuIElmIGdlc3R1cmUgaXMgcGxheWVkIHRoYXQgaXMgYSBRdWV1ZVN0YXRlLCB0aGUgcXVldWUgd2lsbCBhdXRvbWF0aWNhbGx5XG4gKiBiZSBwcm9ncmVzc2VkIGFmdGVyIGEgZ2l2ZW4gaG9sZCB0aW1lIGlmIGEgbG9vcGluZyBxdWV1ZWQgc3RhdGUgaXMgcmVhY2hlZC4gR2VzdHVyZVxuICogbGF5ZXJzIGNhbiBvcHRpb25hbGx5IGJlIGF1dG9tYXRpY2FsbHkgZGlzYWJsZWQgd2hlbiBubyBnZXN0dXJlIGFuaW1hdGlvbiBpc1xuICogaW4gcHJvZ3Jlc3MuXG4gKlxuICogQGV4dGVuZHMgQWJzdHJhY3RIb3N0RmVhdHVyZVxuICogQGFsaWFzIGNvcmUvR2VzdHVyZUZlYXR1cmVcbiAqIEBpbXBsZW1lbnRzIFNTTUxTcGVlY2htYXJrSW50ZXJmYWNlXG4gKiBAaW1wbGVtZW50cyBNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2VcbiAqL1xuY2xhc3MgR2VzdHVyZUZlYXR1cmUgZXh0ZW5kcyBBYnN0cmFjdEhvc3RGZWF0dXJlLm1peChcbiAgU1NNTFNwZWVjaG1hcmtJbnRlcmZhY2UuTWl4aW4sXG4gIE1hbmFnZWRBbmltYXRpb25MYXllckludGVyZmFjZS5NaXhpblxuKSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtIHtjb3JlL0hvc3RPYmplY3R9IGhvc3QgLSBIb3N0IG9iamVjdCB0aGF0IG93bnMgdGhlIGZlYXR1cmUuXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyAtIE9wdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSBmZWF0dXJlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaG9sZFRpbWUgPSAzXSAtIEFtb3VudCBvZiB0aW1lIGluIHNlY29uZHMgdGhhdCBtdXN0XG4gICAqIGVsYXBzZSBiZWZvcmUgYWR2YW5jaW5nIGEgZ2VzdHVyZSB0aGF0J3MgYSB7QGxpbmsgUXVldWVTdGF0ZX0gd2hlbiB0aGUgY3VycmVudFxuICAgKiBzdGF0ZSBpbiB0aGUgcXVldWUgaXMgc2V0IHRvIGxvb3AgaW5maW5pdGVseS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1pbmltdW1JbnRlcnZhbCA9IDAuMjVdIC0gVGhlIG1pbmltdW0gYW1vdW50IG9mIHRpbWVcbiAgICogaW4gc2Vjb25kcyB0aGF0IG11c3QgZWxhcHNlIGJlZm9yZSBhbm90aGVyIGdlc3R1cmUgY2FuIGJlIHBsYXllZC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBsYXllcnMgLSBBbiBvYmplY3QgdGhhdCBtYXBzIGxheWVyIG5hbWVzIHRvIGxheWVyIG9wdGlvbnMuXG4gICAqIFRoZXNlIGFyZSB0aGUgbGF5ZXJzIHRoYXQgd2lsbCBiZSByZWdpc3RlcmVkIGFzIHRyYWNrZWQgZ2VzdHVyZSBsYXllcnMuIFNlZVxuICAgKiB7QGxpbmsgTWFuYWdlZEFuaW1hdGlvbkxheWVySW50ZXJmYWNlI3JlZ2lzdGVyTGF5ZXJ9IGZvciBtb3JlIGluZm9ybWF0aW9uXG4gICAqIG9uIGV4cGVjdGVkIGZvcm1hdCBmb3IgZWFjaCBsYXllciBvcHRpb25zIG9iamVjdC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGhvc3QsIHtob2xkVGltZSA9IDMsIG1pbmltdW1JbnRlcnZhbCA9IDEsIGxheWVycyA9IHt9fSA9IHt9KSB7XG4gICAgc3VwZXIoaG9zdCk7XG5cbiAgICB0aGlzLmhvbGRUaW1lID0gaG9sZFRpbWU7XG4gICAgdGhpcy5taW5pbXVtSW50ZXJ2YWwgPSBtaW5pbXVtSW50ZXJ2YWw7XG5cbiAgICAvLyBSZWdpc3RlciB0aGUgZ2VzdHVyZSBsYXllcnNcbiAgICBPYmplY3QuZW50cmllcyhsYXllcnMpLmZvckVhY2goKFtuYW1lLCBvcHRpb25zID0ge31dKSA9PiB7XG4gICAgICB0aGlzLnJlZ2lzdGVyTGF5ZXIobmFtZSwgb3B0aW9ucyk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgdmFsaWQgaG9sZCB0aW1lIHZhbHVlLiBJZiBob2xkIHRpbWUgaXNuJ3QgZGVmaW5lZCBmb3IgdGhlIGFuaW1hdGlvbixcbiAgICogdHJ5IHRvIHVzZSB0aGUgaG9sZCB0aW1lIGZvciB0aGUgbGF5ZXIuIElmIHRoYXQncyBub3QgZGVmaW5lZCwgZmFsbCBiYWNrIHRvXG4gICAqIHRoZSBob2xkIHRpbWUgZm9yIHRoZSBmZWF0dXJlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbGF5ZXIgLSBNYW5hZ2VkIGxheWVyIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gYW5pbWF0aW9uIC0gTWFuYWdlZCBhbmltYXRpb24gb3B0aW9ucyBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBfZ2V0SG9sZFRpbWUobGF5ZXIsIGFuaW1hdGlvbikge1xuICAgIGNvbnN0IGxheWVySG9sZFRpbWUgPVxuICAgICAgbGF5ZXIuaG9sZFRpbWUgIT09IHVuZGVmaW5lZCA/IGxheWVyLmhvbGRUaW1lIDogdGhpcy5ob2xkVGltZTtcblxuICAgIHJldHVybiBhbmltYXRpb24uaG9sZFRpbWUgIT09IHVuZGVmaW5lZFxuICAgICAgPyBhbmltYXRpb24uaG9sZFRpbWVcbiAgICAgIDogbGF5ZXJIb2xkVGltZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSB2YWxpZCBtaW5pbXVtIGludGVydmFsIHZhbHVlLiBJZiBtaW5pbXVtIGludGVydmFsIGlzbid0IGRlZmluZWQgZm9yXG4gICAqIHRoZSBhbmltYXRpb24sIHRyeSB0byB1c2UgdGhlIG1pbmltdW0gaW50ZXJ2YWwgZm9yIHRoZSBsYXllci4gSWYgdGhhdCdzIG5vdFxuICAgKiBkZWZpbmVkLCBmYWxsIGJhY2sgdG8gdGhlIG1pbmltdW0gaW50ZXJ2YWwgZm9yIHRoZSBmZWF0dXJlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbGF5ZXIgLSBNYW5hZ2VkIGxheWVyIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gYW5pbWF0aW9uIC0gTWFuYWdlZCBhbmltYXRpb24gb3B0aW9ucyBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBfZ2V0TWluaW11bUludGVydmFsKGxheWVyLCBhbmltYXRpb24pIHtcbiAgICBjb25zdCBsYXllck1pbmltdW1JbnRlcnZhbCA9XG4gICAgICBsYXllci5taW5pbXVtSW50ZXJ2YWwgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IGxheWVyLm1pbmltdW1JbnRlcnZhbFxuICAgICAgICA6IHRoaXMubWluaW11bUludGVydmFsO1xuXG4gICAgcmV0dXJuIGFuaW1hdGlvbi5taW5pbXVtSW50ZXJ2YWwgIT09IHVuZGVmaW5lZFxuICAgICAgPyBhbmltYXRpb24ubWluaW11bUludGVydmFsXG4gICAgICA6IGxheWVyTWluaW11bUludGVydmFsO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZvciB7QGxpbmsgY29yZS9BbmltYXRpb25GZWF0dXJlI3BsYXlOZXh0QW5pbWF0aW9ufSBldmVudC4gSWYgdGhlXG4gICAqIGV2ZW50IGlzIGVtaXR0ZWQgZm9yIGEgbWFuYWdlZCBhbmltYXRpb24gYW5kIHRoZSBuZXcgcXVldWVkIHN0YXRlIGNhbm5vdFxuICAgKiBhZHZhbmNlIG9uIGl0cyBvd24sIHN0YXJ0IGEgbmV3IHRpbWVyIHByb21pc2UgdGhhdCB3aWxsIGFkdmFuY2UgdGhlIHF1ZXVlXG4gICAqIG9uY2UgaXQgcmVzb2x2ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyBvYmplY3QgcGFzc2VkIGZyb20gcGxheU5leHRBbmltYXRpb24gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0aGF0IG93bnMgdGhlIHF1ZXVlIHN0YXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYW5pbWF0aW9uTmFtZSAtIE5hbWUgb2YgdGhlIHF1ZXVlIHN0YXRlIGFuaW1hdGlvbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBjYW5BZHZhbmNlIC0gV2hldGhlciBvciBub3QgdGhlIGN1cnJlbnQgc3RhdGUgaW4gdGhlIHF1ZXVlXG4gICAqIGNhbiBhZHZhbmNlIG9uIGl0cyBvd24uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNRdWV1ZUVuZCAtIFdoZXRoZXIgdGhlIGN1cnJlbnQgc3RhdGUgaW4gdGhlIHF1ZXVlIGlzIHRoZSBsYXN0XG4gICAqIHN0YXRlIGluIHRoZSBxdWV1ZS5cbiAgICovXG4gIF9vbk5leHQoe2xheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSwgY2FuQWR2YW5jZSwgaXNRdWV1ZUVuZH0pIHtcbiAgICAvLyBFeGl0IGlmIHRoaXMgaXNuJ3QgYSBtYW5hZ2VkIGxheWVyXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV07XG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBFeGl0IGlmIGl0IGlzbid0IGEgbWFuYWdlZCBhbmltYXRpb25cbiAgICBjb25zdCBhbmltYXRpb24gPSBsYXllci5hbmltYXRpb25zW2FuaW1hdGlvbk5hbWVdO1xuICAgIGlmIChhbmltYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFN0YXJ0IGEgbmV3IHRpbWVyIGZvciBsb29waW5nIHN0YXRlcyB0aGF0IGFyZW4ndCB0aGUgZW5kIG9mIHRoZSBxdWV1ZVxuICAgIGlmICghY2FuQWR2YW5jZSAmJiAhaXNRdWV1ZUVuZCAmJiBsYXllci5jdXJyZW50R2VzdHVyZSA9PT0gYW5pbWF0aW9uTmFtZSkge1xuICAgICAgY29uc3QgaG9sZFRpbWUgPSB0aGlzLl9nZXRIb2xkVGltZShsYXllciwgYW5pbWF0aW9uKTtcbiAgICAgIGxheWVyLmhvbGRUaW1lci5jYW5jZWwoKTtcblxuICAgICAgLy8gU2tpcCB0byB0aGUgbmV4dCBhbmltYXRpb24gcmlnaHQgYXdheSBpZiBob2xkIHRpbWUgaXMgemVyb1xuICAgICAgaWYgKGhvbGRUaW1lIDw9IDApIHtcbiAgICAgICAgdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlLnBsYXlOZXh0QW5pbWF0aW9uKGxheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdhaXQgZm9yIHRoZSBnaXZlbiBob2xkIHRpbWUgYmVmb3JlIHByb2dyZXNzaW5nXG4gICAgICBlbHNlIHtcbiAgICAgICAgbGF5ZXIuaG9sZFRpbWVyID0gVXRpbHMud2FpdChob2xkVGltZSwge1xuICAgICAgICAgIG9uRmluaXNoOiAoKSA9PiB7XG4gICAgICAgICAgICAvLyBBZHZhbmNlIHRoZSBxdWV1ZSB0byB0aGUgbmV4dCBzdGF0ZVxuICAgICAgICAgICAgaWYgKGxheWVyLmN1cnJlbnRHZXN0dXJlID09PSBhbmltYXRpb25OYW1lKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5wbGF5TmV4dEFuaW1hdGlvbihcbiAgICAgICAgICAgICAgICBsYXllck5hbWUsXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uTmFtZVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmb3Ige0BsaW5rIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNzdG9wQW5pbWF0aW9ufSBldmVudC4gSWYgdGhlXG4gICAqIGV2ZW50IGlzIGVtaXR0ZWQgZm9yIGEgbWFuYWdlZCBhbmltYXRpb24gY2FuY2VsIHRoZSBsYXllcidzIHN0b3JlZCB0aW1lcnMuXG4gICAqIElmIHRoZSBsYXllciBpcyBzZXQgdG8gYXV0by1kaXNhYmxlIHNldCBpdHMgd2VpZ2h0IHRvIDAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyBvYmplY3QgcGFzc2VkIGZyb20gcGxheU5leHRBbmltYXRpb24gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0aGF0IG93bnMgdGhlIHN0b3BwZWQgYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYW5pbWF0aW9uTmFtZSAtIE5hbWUgb2YgdGhlIGFuaW1hdGlvbiB0aGF0IHdhcyBzdG9wcGVkLlxuICAgKi9cbiAgX29uU3RvcCh7bGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lfSkge1xuICAgIC8vIE1ha2Ugc3VyZSB0aGUgbGF5ZXIgaXMgbWFuYWdlZFxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdO1xuICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBhbmltYXRpb24gaXMgbWFuYWdlZFxuICAgIGNvbnN0IGFuaW1hdGlvbiA9IGxheWVyLmFuaW1hdGlvbnNbYW5pbWF0aW9uTmFtZV07XG4gICAgaWYgKGFuaW1hdGlvbiAhPT0gdW5kZWZpbmVkICYmIGFuaW1hdGlvbk5hbWUgPT09IGxheWVyLmN1cnJlbnRHZXN0dXJlKSB7XG4gICAgICBsYXllci5jdXJyZW50R2VzdHVyZSA9IG51bGw7XG4gICAgICBsYXllci5wbGF5VGltZXIgPSBudWxsO1xuICAgICAgbGF5ZXIuaG9sZFRpbWVyLmNhbmNlbCgpO1xuXG4gICAgICAvLyBUdXJuIG9mZiBsYXllciB3ZWlnaHRcbiAgICAgIGlmIChsYXllci5hdXRvRGlzYWJsZSkge1xuICAgICAgICB0aGlzLnNldExheWVyV2VpZ2h0cyhuYW1lID0+IG5hbWUgPT09IGxheWVyTmFtZSwgMCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX29uQW5pbWF0aW9uQWRkZWQoe2xheWVyTmFtZSwgYW5pbWF0aW9uTmFtZX0pIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXTtcblxuICAgIGlmIChsYXllciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBhbmltYXRpb24gPSBsYXllci5hbmltYXRpb25zW2FuaW1hdGlvbk5hbWVdO1xuXG4gICAgICAvLyBSZWdpc3RlciB0aGUgYW5pbWF0aW9uIGFzIGFjdGl2ZSBpZiBpdCBpcyB1bm1hbmFnZWRcbiAgICAgIGlmIChhbmltYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyQW5pbWF0aW9uKGxheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSk7XG4gICAgICB9XG4gICAgICAvLyBNYXJrIHRoZSBhbmltYXRpb24gYXMgYWN0aXZlIGlmIGl0IGlzIG1hbmFnZWRcbiAgICAgIGVsc2Uge1xuICAgICAgICBhbmltYXRpb24uaXNBY3RpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJlZ2lzdGVyTGF5ZXIobmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIucmVnaXN0ZXJMYXllcihuYW1lLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaG9sZFRpbWVyOiBEZWZlcnJlZC5yZXNvbHZlKCksXG4gICAgICBwbGF5VGltZXI6IG51bGwsXG4gICAgICBjdXJyZW50R2VzdHVyZTogbnVsbCxcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLl9tYW5hZ2VkTGF5ZXJzW25hbWVdLmlzQWN0aXZlKSB7XG4gICAgICB0aGlzLl9ob3N0LkFuaW1hdGlvbkZlYXR1cmUuZ2V0QW5pbWF0aW9ucyhuYW1lKS5mb3JFYWNoKGFuaW0gPT4ge1xuICAgICAgICAvLyBBdXRvbWF0aWNhbGx5IHJlZ2lzdGVyIGFsbCBhbmltYXRpb25zIG9uIHRoZSBsYXllclxuICAgICAgICBpZiAodGhpcy5fbWFuYWdlZExheWVyc1tuYW1lXS5hbmltYXRpb25zW2FuaW1dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnJlZ2lzdGVyQW5pbWF0aW9uKFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGFuaW0sXG4gICAgICAgICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzW25hbWVdLmFuaW1hdGlvbnNbYW5pbV1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZWdpc3RlckFuaW1hdGlvbihsYXllck5hbWUsIGFuaW1hdGlvbk5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIC8vIFRyeSB0byBmYWxsIGJhY2sgdG8gYSBkZWZhdWx0IHdvcmQgYXJyYXlcbiAgICBpZiAoIShvcHRpb25zLndvcmRzIGluc3RhbmNlb2YgQXJyYXkpICYmICEob3B0aW9ucy53b3JkcyBpbnN0YW5jZW9mIFNldCkpIHtcbiAgICAgIG9wdGlvbnMud29yZHMgPSBEZWZhdWx0R2VzdHVyZVdvcmRzW2FuaW1hdGlvbk5hbWVdIHx8IFtdO1xuICAgIH1cblxuICAgIHN1cGVyLnJlZ2lzdGVyQW5pbWF0aW9uKGxheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIG9iamVjdCB0aGF0IG1hcHMgc3NtbCBtYXJrIHN5bnRheCByZXF1aXJlZCB0byBwbGF5IGVhY2ggZ2VzdHVyZSB0b1xuICAgKiB0aGUgd29yZHMgYXJyYXkgYXNzb2NpYXRlZCB3aXRoIGVhY2ggZ2VzdHVyZS4gV29yZHMgYXJyYXlzIGFyZSBkZWZpbmVkIGF0IHdoZW5cbiAgICogdGhlIGdlc3R1cmUgYW5pbWF0aW9uIGlzIHJlZ2lzdGVyZWQuIEdlc3R1cmVzIHdpdGhvdXQgYXNzb2NpYXRlZCB3b3JkcyB3aWxsXG4gICAqIGJlIGV4Y2x1ZGVkIGZyb20gdGhlIHJlc3VsdC4gVGhlIHJlc3VsdGluZyBvYmplY3QgY2FuIGJlIHVzZWQgYXMgYW4gaW5wdXRcbiAgICogZm9yIHtAbGluayBUZXh0VG9TcGVlY2hVdGlscy5hdXRvR2VuZXJhdGVTU01MTWFya3N9IHRvIHVwZGF0ZSBhIHNwZWVjaCBzdHJpbmdcbiAgICogd2l0aCB0aGUgbWFya3VwIHJlcXVpcmVkIHRvIHBsYXkgZ2VzdHVyZXMgdGltZWQgd2l0aCB0aGVpciBhc3NvY2lhdGVkIHdvcmRzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKi9cbiAgY3JlYXRlR2VzdHVyZU1hcCgpIHtcbiAgICBjb25zdCBnZXN0dXJlTWFwID0ge307XG5cbiAgICBPYmplY3QuZW50cmllcyh0aGlzLl9tYW5hZ2VkTGF5ZXJzKS5mb3JFYWNoKChbbGF5ZXJOYW1lLCB7YW5pbWF0aW9uc31dKSA9PiB7XG4gICAgICBPYmplY3QuZW50cmllcyhhbmltYXRpb25zKS5mb3JFYWNoKFxuICAgICAgICAoW1xuICAgICAgICAgIGFuaW1hdGlvbk5hbWUsXG4gICAgICAgICAge2hvbGRUaW1lLCBtaW5pbXVtSW50ZXJ2YWwsIHdvcmRzLCB0cmFuc2l0aW9uVGltZX0sXG4gICAgICAgIF0pID0+IHtcbiAgICAgICAgICAvLyBPbmx5IHN0b3JlIGdlc3R1cmVzIHRoYXQgaGF2ZSBhbnkgYXNzb2NpYXRlZCB3b3Jkc1xuICAgICAgICAgIGlmICh3b3Jkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgIC4uLihob2xkVGltZSAmJiB7aG9sZFRpbWV9KSxcbiAgICAgICAgICAgICAgLi4uKG1pbmltdW1JbnRlcnZhbCAmJiB7bWluaW11bUludGVydmFsfSksXG4gICAgICAgICAgICAgIC4uLih0cmFuc2l0aW9uVGltZSAmJiB7dHJhbnNpdGlvblRpbWV9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB7XG4gICAgICAgICAgICAgIGZlYXR1cmU6IHRoaXMuY29uc3RydWN0b3IubmFtZSxcbiAgICAgICAgICAgICAgbWV0aG9kOiAncGxheUdlc3R1cmUnLFxuICAgICAgICAgICAgICBhcmdzOiBbbGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lLCBvcHRpb25zXSxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGdlc3R1cmVNYXBbSlNPTi5zdHJpbmdpZnkoa2V5KV0gPSB3b3JkcztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZ2VzdHVyZU1hcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gYXJyYXkgdGhhdCBjb250YWlucyBzc21sIG1hcmsgc3ludGF4IHJlcXVpcmVkIHRvIHBsYXkgZWFjaCBnZXN0dXJlXG4gICAqIHRoYXQgZG9lcyBub3QgaGF2ZSBhbnkgYXNzb2NpYXRlZCB3b3Jkcy4gVGhlIHJlc3VsdGluZyBhcnJheSBjYW4gYmUgdXNlZCBhc1xuICAgKiBhbiBpbnB1dCBmb3Ige0BsaW5rIFRleHRUb1NwZWVjaFV0aWxzLmF1dG9HZW5lcmF0ZVNTTUxNYXJrc30gb3JcbiAgICoge0BsaW5rIFRleHRUb1NwZWVjaFV0aWxzLmFkZE1hcmtzVG9Vbm1hcmtlZFNlbnRlbmNlc30gdG8gdXBkYXRlIGEgc3BlZWNoXG4gICAqIHN0cmluZyB3aXRoIHRoZSBtYXJrdXAgcmVxdWlyZWQgdG8gcGxheSByYW5kb20gZ2VzdHVyZXMgYXQgZWFjaCB1bm1hcmtlZFxuICAgKiBzZW50ZW5jZSBpbiB0aGUgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+PX0gbGF5ZXJzIC0gQW4gYXJyYXkgb2YgbmFtZXMgb2YgbWFuYWdlZCBsYXllcnMgdG8gZ2VuZXJhdGVcbiAgICogbWFya3MgZm9yLiBJZiB1bmRlZmluZWQsIHVzZSBhbGwgbWFuYWdlZCBsYXllcnMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheS48c3RyaW5nPn1cbiAgICovXG4gIGNyZWF0ZUdlbmVyaWNHZXN0dXJlQXJyYXkobGF5ZXJzKSB7XG4gICAgY29uc3QgZ2VuZXJpY0dlc3R1cmVzID0gW107XG4gICAgbGF5ZXJzID0gbGF5ZXJzIHx8IE9iamVjdC5rZXlzKHRoaXMuX21hbmFnZWRMYXllcnMpO1xuXG4gICAgbGF5ZXJzLmZvckVhY2gobGF5ZXJOYW1lID0+IHtcbiAgICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdO1xuXG4gICAgICAvLyBNYWtlIHN1cmUgdGhlIGxheWVyIGlzIG1hbmFnZWRcbiAgICAgIGlmICghbGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuZW50cmllcyhsYXllci5hbmltYXRpb25zKS5mb3JFYWNoKFxuICAgICAgICAoW1xuICAgICAgICAgIGFuaW1hdGlvbk5hbWUsXG4gICAgICAgICAge2hvbGRUaW1lLCBtaW5pbXVtSW50ZXJ2YWwsIHdvcmRzLCB0cmFuc2l0aW9uVGltZX0sXG4gICAgICAgIF0pID0+IHtcbiAgICAgICAgICAvLyBPbmx5IHN0b3JlIGdlc3R1cmVzIHRoYXQgZG9uJ3QgaGF2ZSBhbnkgYXNzb2NpYXRlZCB3b3Jkc1xuICAgICAgICAgIGlmICghd29yZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAuLi4oaG9sZFRpbWUgJiYge2hvbGRUaW1lfSksXG4gICAgICAgICAgICAgIC4uLihtaW5pbXVtSW50ZXJ2YWwgJiYge21pbmltdW1JbnRlcnZhbH0pLFxuICAgICAgICAgICAgICAuLi4odHJhbnNpdGlvblRpbWUgJiYge3RyYW5zaXRpb25UaW1lfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICBmZWF0dXJlOiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUsXG4gICAgICAgICAgICAgIG1ldGhvZDogJ3BsYXlHZXN0dXJlJyxcbiAgICAgICAgICAgICAgYXJnczogW2xheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSwgb3B0aW9uc10sXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFnZW5lcmljR2VzdHVyZXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICBnZW5lcmljR2VzdHVyZXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBnZW5lcmljR2VzdHVyZXM7XG4gIH1cblxuICAvKipcbiAgICogUGxheSBhIG1hbmFnZWQgZ2VzdHVyZSBhbmltYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCBjb250YWlucyB0aGUgZ2VzdHVyZVxuICAgKiBhbmltYXRpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbmltYXRpb25OYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGdlc3R1cmUgYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgLSBPcHRpb25hbCBnZXN0dXJlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0aW9ucy5ob2xkVGltZSAtIFRoaXMgb3B0aW9uIG9ubHkgYXBwbGllcyB0byB7QGxpbmsgUXVldWVTdGF0ZX1cbiAgICogZ2VzdHVyZXMuIFdoZW4gYSBRdWV1ZVN0YXRlIGdlc3R1cmUgcHJvZ3Jlc3NlcyB0byBhIGxvb3Bpbmcgc3RhdGUsIHRoaXMgb3B0aW9uXG4gICAqIGRlZmluZXMgaG93IG1hbnkgc2Vjb25kcyBzaG91bGQgZWxhcHNlIGJlZm9yZSBtb3ZpbmcgdGhlIHF1ZXVlIGZvcndhcmQuIElmXG4gICAqIHVuZGVmaW5lZCwgaXQgd2lsbCBmYWxsIGJhY2sgZmlyc3QgdG8gdGhlIGhvbGRUaW1lIGRlZmluZWQgaW4gdGhlIG9wdGlvbnMgd2hlblxuICAgKiB0aGUgZ2VzdHVyZSBhbmltYXRpb24gd2FzIHJlZ2lzdGVyZWQgYW5kIHRoZW4gdG8gdGhlIGhvbGRUaW1lIGRlZmluZWQgb24gdGhlXG4gICAqIGZlYXR1cmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0aW9ucy5taW5pbXVtSW50ZXJ2YWwgLSBUaGUgbWluaW11bSBhbW91bnQgb2YgdGltZSB0aGF0XG4gICAqIG11c3QgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgYSBnZXN0dXJlIHdhcyBwbGF5ZWQuXG4gICAqL1xuICBwbGF5R2VzdHVyZShcbiAgICBsYXllck5hbWUsXG4gICAgYW5pbWF0aW9uTmFtZSxcbiAgICB7aG9sZFRpbWUsIG1pbmltdW1JbnRlcnZhbCwgdHJhbnNpdGlvblRpbWUsIGZvcmNlID0gZmFsc2V9ID0ge31cbiAgKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBhbmltYXRpb24gaXMgcmVnaXN0ZXJlZFxuICAgIGlmIChcbiAgICAgIHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0uYW5pbWF0aW9uc1thbmltYXRpb25OYW1lXSA9PT0gdW5kZWZpbmVkXG4gICAgKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyQW5pbWF0aW9uKGxheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSwge1xuICAgICAgICBob2xkVGltZSxcbiAgICAgICAgbWluaW11bUludGVydmFsLFxuICAgICAgICB0cmFuc2l0aW9uVGltZSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdO1xuICAgIGNvbnN0IGFuaW1hdGlvbiA9IGxheWVyLmFuaW1hdGlvbnNbYW5pbWF0aW9uTmFtZV07XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlIGFuaW1hdGlvbiBpcyBhY3RpdmVcbiAgICBpZiAoIWFuaW1hdGlvbi5pc0FjdGl2ZSkge1xuICAgICAgLy8gQ3JlYXRlIHdhcm5pbmcgbWVzc2FnZSBiYXNlZCBvbiB3aGljaCBvYmplY3QgZG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIGNvbnN0IHR5cGVOYW1lID0gbGF5ZXIuaXNBY3RpdmUgPyAnYW5pbWF0aW9uJyA6ICdsYXllcic7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYFNraXBwaW5nIGdlc3R1cmUgJHthbmltYXRpb25OYW1lfSBvbiBsYXllciAke2xheWVyTmFtZX0gZm9yIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTm8gJHt0eXBlTmFtZX0gZXhpc3RzIHdpdGggdGhpcyBuYW1lIHlldC5gO1xuXG4gICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgICByZXR1cm4gRGVmZXJyZWQuY2FuY2VsKHtyZWFzb246ICdpbmFjdGl2ZScsIHZhbHVlOiB0eXBlTmFtZX0pO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRoZSBnZXN0dXJlIGlzIGFscmVhZHkgcGxheWluZ1xuICAgIGNvbnN0IHtjdXJyZW50R2VzdHVyZX0gPSBsYXllcjtcbiAgICBpZiAoY3VycmVudEdlc3R1cmUgPT09IGFuaW1hdGlvbk5hbWUgJiYgIWZvcmNlKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYFNraXBwaW5nIGdlc3R1cmUgJHthbmltYXRpb25OYW1lfSBvbiBsYXllciAke2xheWVyTmFtZX0gZm9yIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gVGhlIGdlc3R1cmUgaXMgYWxyZWFkeSBwbGF5aW5nLiBVc2Ugb3B0aW9ucy5mb3JjZSB0byBmb3JjZSB0aGUgZ2VzdHVyZSByZXBsYXksIHdoaWNoIG1heSByZXN1bHQgaW4gYSBoYXJkIHRyYW5zaXRpb24uYDtcblxuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgICAgcmV0dXJuIERlZmVycmVkLmNhbmNlbCh7cmVhc29uOiAncGxheWluZycsIHZhbHVlOiBhbmltYXRpb25OYW1lfSk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIGFuaW1hdGlvbiBvcHRpb25zXG4gICAgaWYgKGhvbGRUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGFuaW1hdGlvbi5ob2xkVGltZSA9IGhvbGRUaW1lO1xuICAgIH1cblxuICAgIGlmIChtaW5pbXVtSW50ZXJ2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYW5pbWF0aW9uLm1pbmltdW1JbnRlcnZhbCA9IG1pbmltdW1JbnRlcnZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgbWluaW11bUludGVydmFsID0gdGhpcy5fZ2V0TWluaW11bUludGVydmFsKGxheWVyLCBhbmltYXRpb24pO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHRoZSBpbnRlcnZhbFxuICAgIGlmIChcbiAgICAgICFmb3JjZSAmJlxuICAgICAgbGF5ZXIucGxheVRpbWVyICE9PSBudWxsICYmXG4gICAgICBsYXllci5wbGF5VGltZXIgPCBtaW5pbXVtSW50ZXJ2YWxcbiAgICApIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYFNraXBwaW5nIGdlc3R1cmUgJHthbmltYXRpb25OYW1lfSBvbiBsYXllciAke2xheWVyTmFtZX0gZm9yIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTWluaW11bSBpbnRlcnZhbCAke21pbmltdW1JbnRlcnZhbH0gaGFzIG5vdCBiZWVuIG1ldC5gXG4gICAgICApO1xuICAgICAgcmV0dXJuIERlZmVycmVkLmNhbmNlbCh7XG4gICAgICAgIHJlYXNvbjogJ21pbmltdW1JbnRlcnZhbCcsXG4gICAgICAgIHZhbHVlOiBtaW5pbXVtSW50ZXJ2YWwgLSBsYXllci5wbGF5VGltZXIsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBQbGF5IHRoZSBhbmltYXRpb25cbiAgICBsYXllci5jdXJyZW50R2VzdHVyZSA9IGFuaW1hdGlvbk5hbWU7XG4gICAgbGF5ZXIucGxheVRpbWVyID0gMDtcbiAgICBsYXllci5ob2xkVGltZXIuY2FuY2VsKCk7XG4gICAgaWYgKGxheWVyLmF1dG9EaXNhYmxlKSB7XG4gICAgICB0aGlzLnNldExheWVyV2VpZ2h0cyhuYW1lID0+IG5hbWUgPT09IGxheWVyTmFtZSwgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5wbGF5QW5pbWF0aW9uKFxuICAgICAgbGF5ZXJOYW1lLFxuICAgICAgYW5pbWF0aW9uTmFtZSxcbiAgICAgIHRyYW5zaXRpb25UaW1lXG4gICAgKTtcbiAgfVxuXG4gIHVwZGF0ZShkZWx0YVRpbWUpIHtcbiAgICBzdXBlci51cGRhdGUoZGVsdGFUaW1lKTtcblxuICAgIC8vIEluY3JlbWVudCB0aGUgdGltZXJzXG4gICAgT2JqZWN0LmVudHJpZXModGhpcy5fbWFuYWdlZExheWVycykuZm9yRWFjaCgoW25hbWUsIG9wdGlvbnNdKSA9PiB7XG4gICAgICBpZiAob3B0aW9ucy5pc0FjdGl2ZSAmJiAhdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlLmdldFBhdXNlZChuYW1lKSkge1xuICAgICAgICBvcHRpb25zLmhvbGRUaW1lci5leGVjdXRlKGRlbHRhVGltZSk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMucGxheVRpbWVyICE9PSBudWxsKSB7XG4gICAgICAgICAgb3B0aW9ucy5wbGF5VGltZXIgKz0gZGVsdGFUaW1lIC8gMTAwMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaW5zdGFsbEFwaSgpIHtcbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKiBAbmFtZXNwYWNlIEdlc3R1cmVGZWF0dXJlXG4gICAgICovXG4gICAgY29uc3QgYXBpID0gc3VwZXIuaW5zdGFsbEFwaSgpO1xuXG4gICAgT2JqZWN0LmFzc2lnbihhcGksIHtcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlcm9mIEdlc3R1cmVGZWF0dXJlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEBtZXRob2RcbiAgICAgICAqIEBzZWUgR2VzdHVyZUZlYXR1cmUjY3JlYXRlR2VzdHVyZU1hcFxuICAgICAgICovXG4gICAgICBjcmVhdGVHZXN0dXJlTWFwOiB0aGlzLmNyZWF0ZUdlc3R1cmVNYXAuYmluZCh0aGlzKSxcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlcm9mIEdlc3R1cmVGZWF0dXJlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEBtZXRob2RcbiAgICAgICAqIEBzZWUgR2VzdHVyZUZlYXR1cmUjY3JlYXRlR2VuZXJpY0dlc3R1cmVBcnJheVxuICAgICAgICovXG4gICAgICBjcmVhdGVHZW5lcmljR2VzdHVyZUFycmF5OiB0aGlzLmNyZWF0ZUdlbmVyaWNHZXN0dXJlQXJyYXkuYmluZCh0aGlzKSxcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlcm9mIEdlc3R1cmVGZWF0dXJlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEBtZXRob2RcbiAgICAgICAqIEBzZWUgR2VzdHVyZUZlYXR1cmUjcGxheUdlc3R1cmVcbiAgICAgICAqL1xuICAgICAgcGxheUdlc3R1cmU6IHRoaXMucGxheUdlc3R1cmUuYmluZCh0aGlzKSxcbiAgICB9KTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhHZXN0dXJlRmVhdHVyZSwge1xuICBERUZBVUxUX0xBWUVSX09QVElPTlM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgLi4uR2VzdHVyZUZlYXR1cmUuREVGQVVMVF9MQVlFUl9PUFRJT05TLFxuICAgICAgYXV0b0Rpc2FibGU6IHRydWUsXG4gICAgfSxcbiAgICB3cml0YWJsZTogZmFsc2UsXG4gIH0sXG4gIEVWRU5UX0RFUEVOREVOQ0lFUzoge1xuICAgIHZhbHVlOiB7XG4gICAgICAuLi5HZXN0dXJlRmVhdHVyZS5FVkVOVF9ERVBFTkRFTkNJRVMsXG4gICAgICBBbmltYXRpb25GZWF0dXJlOiB7XG4gICAgICAgIC4uLkdlc3R1cmVGZWF0dXJlLkVWRU5UX0RFUEVOREVOQ0lFUy5BbmltYXRpb25GZWF0dXJlLFxuICAgICAgICBwbGF5TmV4dEFuaW1hdGlvbjogJ19vbk5leHQnLFxuICAgICAgICBzdG9wQW5pbWF0aW9uOiAnX29uU3RvcCcsXG4gICAgICAgIGludGVycnVwdEFuaW1hdGlvbjogJ19vblN0b3AnLFxuICAgICAgfSxcbiAgICB9LFxuICB9LFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEdlc3R1cmVGZWF0dXJlO1xuZXhwb3J0IHtEZWZhdWx0R2VzdHVyZVdvcmRzfTtcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXG5pbXBvcnQgRGVmZXJyZWQgZnJvbSAnY29yZS9EZWZlcnJlZCc7XG5pbXBvcnQgVXRpbHMgZnJvbSAnY29yZS9VdGlscyc7XG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gJ2NvcmUvTWF0aFV0aWxzJztcbmltcG9ydCB7TGluZWFyfSBmcm9tICcuL0Vhc2luZyc7XG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIHVzZWZ1bCBhbmltYXRpb24gZnVuY3Rpb25zLlxuICpcbiAqIEBoaWRlY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgQW5pbWF0aW9uVXRpbHMge1xuICBzdGF0aWMgbGVycChmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYEFuaW1hdGlvblV0aWxzLmxlcnAgaXMgYmVpbmcgZGVwcmVjYXRlZC4gVXNlIE1hdGhVdGlscy5sZXJwIGluc3RlYWQuYFxuICAgICk7XG5cbiAgICByZXR1cm4gTWF0aFV0aWxzLmxlcnAoZnJvbSwgdG8sIGZhY3Rvcik7XG4gIH1cblxuICAvKipcbiAgICogQ2xhbXAgYSBudW1iZXIgYmV0d2VlbiAyIHZhbHVlcy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVmFsdWUgdG8gY2xhbXAuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWluPTBdIC0gTWludW11bSB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFttYXg9MV0gLSBNYXhpbXVtIHZhbHVlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgc3RhdGljIGNsYW1wKHZhbHVlLCBtaW4gPSAwLCBtYXggPSAxKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYEFuaW1hdGlvblV0aWxzLmNsYW1wIGlzIGJlaW5nIGRlcHJlY2F0ZWQuIFVzZSBNYXRoVXRpbHMuY2xhbXAgaW5zdGVhZC5gXG4gICAgKTtcblxuICAgIHJldHVybiBNYXRoVXRpbHMuY2xhbXAodmFsdWUsIG1pbiwgbWF4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBkZWZlcnJlZCBwcm9taXNlIHRoYXQgY2FuIGJlIHVzZWQgdG8gdXBkYXRlIHRoZSB2YWx1ZSBvZiBhIG51bWVyaWNcbiAgICogcHJvcGVydHkgb2YgdGhpcyBvYmplY3Qgb3ZlciB0aW1lLiBQYXNzIGRlbHRhIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHRvIHRoZVxuICAgKiBkZWZlcnJlZCBwcm9taXNlJ3MgZXhlY3V0ZSBtZXRob2QgaW4gYW4gdXBkYXRlIGxvb3AgdG8gYW5pbWF0ZSB0aGUgcHJvcGVydHlcbiAgICogdG93YXJkcyB0aGUgdGFyZ2V0IHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydHlPd25lciAtIE9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBwcm9wZXJ0eSB0byBhbmltYXRpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWUgLSBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBhbmltYXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0VmFsdWUgLSBUYXJnZXQgdmFsdWUgdG8gcmVhY2guXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyAtIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zZWNvbmRzPTBdIC0gTnVtYmVyIG9mIHNlY29uZHMgaXQgd2lsbCB0YWtlIHRvIHJlYWNoXG4gICAqIHRoZSB0YXJnZXQgdmFsdWUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmVhc2luZ0ZuPUxpbmVhci5Jbk91dF0gLSBFYXNpbmcgZnVuY3Rpb24gdG8gdXNlIGZvciBhbmltYXRpb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uRmluaXNoXSAtIENhbGxiYWNrIHRvIGV4ZWN1dGUgb25jZSB0aGUgYW5pbWF0aW9uIGNvbXBsZXRlcy5cbiAgICogVGhlIHRhcmdldCB2YWx1ZSBpcyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvcHRpb25zLm9uUHJvZ3Jlc3MgLSBDYWxsYmFjayB0byBleGVjdXRlIGVhY2ggdGltZSB0aGUgYW5pbWF0aW9uXG4gICAqIHByb3BlcnR5IGlzIHVwZGF0ZWQgZHVyaW5nIHRoZSBhbmltYXRpb24uIFRoZSBwcm9wZXJ0eSdzIHZhbHVlIGF0IHRoZSB0aW1lIG9mXG4gICAqIHRoZSB1cGRhdGUgaXMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb3B0aW9ucy5vbkNhbmNlbCAtIENhbGxiYWNrIHRvIGV4ZWN1dGUgaWYgdGhlIHVzZXIgY2FuY2VscyB0aGVcbiAgICogYW5pbWF0aW9uIGJlZm9yZSBjb21wbGV0aW9uLiBUaGUgYW5pbWF0aW9uIHByb3BlcnR5J3MgdmFsdWUgYXQgdGhlIHRpbWUgb2ZcbiAgICogY2FuY2VsIGlzIHBhc3NlZCBhcyBhIHBhcmFtZXRlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9wdGlvbnMub25FcnJvciAtIENhbGxiYWNrIHRvIGV4ZWN1dGUgaWYgdGhlIGFuaW1hdGlvbiBzdG9wc1xuICAgKiBiZWNhdXNlIGFuIGVycm9yIGlzIGVuY291bnRlcmVkLiBUaGUgZXJyb3IgbWVzc2FnZSBpcyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH0gUmVzb2x2ZXMgd2l0aCB0aGUgcHJvcGVydHkncyB2YWx1ZSBvbmNlIGl0IHJlYWNoZXMgdGhlXG4gICAqIHRhcmdldCB2YWx1ZS5cbiAgICovXG4gIHN0YXRpYyBpbnRlcnBvbGF0ZVByb3BlcnR5KFxuICAgIHByb3BlcnR5T3duZXIsXG4gICAgcHJvcGVydHlOYW1lLFxuICAgIHRhcmdldFZhbHVlLFxuICAgIHtzZWNvbmRzID0gMCwgZWFzaW5nRm4sIG9uRmluaXNoLCBvblByb2dyZXNzLCBvbkNhbmNlbCwgb25FcnJvcn0gPSB7fVxuICApIHtcbiAgICAvLyBNYWtlIHN1cmUgcHJvcGVydHkgaXMgYW4gb2JqZWN0XG4gICAgaWYgKCEocHJvcGVydHlPd25lciBpbnN0YW5jZW9mIE9iamVjdCkpIHtcbiAgICAgIGNvbnN0IGUgPSBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgaW50ZXJwb2xhdGUgcHJvcGVydHkgJHtwcm9wZXJ0eU5hbWV9LiBQcm9wZXJ0eSBvd25lciBtdXN0IGJlIGFuIG9iamVjdC5gXG4gICAgICApO1xuXG4gICAgICBpZiAodHlwZW9mIG9uRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb25FcnJvcihlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIERlZmVycmVkLnJlamVjdChlKTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgcHJvcGVydHkgaXMgbnVtZXJpY1xuICAgIGlmIChOdW1iZXIuaXNOYU4oTnVtYmVyKHByb3BlcnR5T3duZXJbcHJvcGVydHlOYW1lXSkpKSB7XG4gICAgICBjb25zdCBlID0gbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGludGVycG9sYXRlIHByb3BlcnR5ICR7cHJvcGVydHlOYW1lfS4gUHJvcGVydHkgbXVzdCBiZSBudW1lcmljLmBcbiAgICAgICk7XG5cbiAgICAgIGlmICh0eXBlb2Ygb25FcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvbkVycm9yKGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gRGVmZXJyZWQucmVqZWN0KGUpO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgdGFyZ2V0IHZhbHVlIGlzIG51bWVyaWNcbiAgICBpZiAoTnVtYmVyLmlzTmFOKE51bWJlcih0YXJnZXRWYWx1ZSkpKSB7XG4gICAgICBjb25zdCBlID0gbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGludGVycG9sYXRlIHByb3BlcnR5ICR7cHJvcGVydHlOYW1lfSB0byB2YWx1ZSAke3RhcmdldFZhbHVlfS4gVGFyZ2V0IHZhbHVlIG11c3QgYmUgbnVtZXJpYy5gXG4gICAgICApO1xuXG4gICAgICBpZiAodHlwZW9mIG9uRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb25FcnJvcihlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIERlZmVycmVkLnJlamVjdChlKTtcbiAgICB9XG5cbiAgICAvLyBSZXNvbHZlIGltbWVkaWF0ZWx5IGlmIHRoZSB0YXJnZXQgaGFzIGFscmVhZHkgYmVlbiByZWFjaGVkXG4gICAgY29uc3Qgc3RhcnRWYWx1ZSA9IHByb3BlcnR5T3duZXJbcHJvcGVydHlOYW1lXTtcblxuICAgIGlmIChzdGFydFZhbHVlID09PSB0YXJnZXRWYWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiBvbkZpbmlzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvbkZpbmlzaCh0YXJnZXRWYWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBEZWZlcnJlZC5yZXNvbHZlKHRhcmdldFZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IHRvIGxpbmVhciBpbnRlcnBvbGF0aW9uXG4gICAgaWYgKHR5cGVvZiBlYXNpbmdGbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGVhc2luZ0ZuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBJbnZhbGlkIHByb3BlcnR5IGludGVycG9sYXRpb24gZWFzaW5nRm4uIERlZmF1bHRpbmcgdG8gbGluZWFyIGludGVycG9sYXRpb24uYFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBlYXNpbmdGbiA9IExpbmVhci5Jbk91dDtcbiAgICB9XG5cbiAgICBjb25zdCBpbnRlcnBvbGF0b3IgPSBVdGlscy53YWl0KHNlY29uZHMsIHtcbiAgICAgIG9uRmluaXNoOiAoKSA9PiB7XG4gICAgICAgIHByb3BlcnR5T3duZXJbcHJvcGVydHlOYW1lXSA9IHRhcmdldFZhbHVlO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb25GaW5pc2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBvbkZpbmlzaCh0YXJnZXRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkNhbmNlbDogKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIG9uQ2FuY2VsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgb25DYW5jZWwocHJvcGVydHlPd25lcltwcm9wZXJ0eU5hbWVdKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uUHJvZ3Jlc3M6IHByb2dyZXNzID0+IHtcbiAgICAgICAgaWYgKHByb3BlcnR5T3duZXJbcHJvcGVydHlOYW1lXSAhPT0gdGFyZ2V0VmFsdWUpIHtcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGxlcnAgZmFjdG9yXG4gICAgICAgICAgY29uc3QgZWFzZUZhY3RvciA9IGVhc2luZ0ZuKHByb2dyZXNzKTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgZWFzZUZhY3RvciAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGNvbnN0IGUgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIHByb3BlcnR5IGludGVycG9sYXRpb24gZWFzaW5nRm4uIEVhc2luZ0ZuIG11c3QgcmV0dXJuIGEgbnVtYmVyLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpbnRlcnBvbGF0b3IucmVqZWN0KGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgdmFsdWVcbiAgICAgICAgICBwcm9wZXJ0eU93bmVyW3Byb3BlcnR5TmFtZV0gPSBNYXRoVXRpbHMubGVycChcbiAgICAgICAgICAgIHN0YXJ0VmFsdWUsXG4gICAgICAgICAgICB0YXJnZXRWYWx1ZSxcbiAgICAgICAgICAgIGVhc2VGYWN0b3JcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2lnbmFsIHByb2dyZXNzXG4gICAgICAgIGlmICh0eXBlb2Ygb25Qcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG9uUHJvZ3Jlc3MocHJvcGVydHlPd25lcltwcm9wZXJ0eU5hbWVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNpZ25hbCBjb21wbGV0aW9uIG9uY2UgdGltZSBpcyB1cFxuICAgICAgICBpZiAocHJvZ3Jlc3MgPT09IDEpIHtcbiAgICAgICAgICBwcm9wZXJ0eU93bmVyW3Byb3BlcnR5TmFtZV0gPSB0YXJnZXRWYWx1ZTtcbiAgICAgICAgICBpbnRlcnBvbGF0b3IucmVzb2x2ZSh0YXJnZXRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkVycm9yLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGludGVycG9sYXRvcjtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBbmltYXRpb25VdGlscztcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXG5pbXBvcnQgRGVmZXJyZWQgZnJvbSAnY29yZS9EZWZlcnJlZCc7XG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gJ2NvcmUvTWF0aFV0aWxzJztcbmltcG9ydCBBbmltYXRpb25VdGlscyBmcm9tICcuLi9BbmltYXRpb25VdGlscyc7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYSBzdGF0ZSBpbiBvdXIgYW5pbWF0aW9uIHN5c3RlbS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqL1xuY2xhc3MgQWJzdHJhY3RTdGF0ZSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGFuaW1hdGlvbiBzdGF0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRpb25zLm5hbWUgLSBOYW1lIGZvciB0aGUgYW5pbWF0aW9uIHN0YXRlLiBOYW1lcyBtdXN0IGJlXG4gICAqIHVuaXF1ZSBmb3IgdGhlIGNvbnRhaW5lciB0aGUgc3RhdGUgaXMgYXBwbGllZCB0byBhbmQgc2hvdWxkIGJlIHZhbGlkYXRlZCBhdFxuICAgKiB0aGUgY29udGFpbmVyIGxldmVsLiBJZiBubyBuYW1lIGlzIGdpdmVuIGl0IHdpbGwgZGVmYXVsdCB0byB0aGUgY29uc3RydWN0b3JcbiAgICogbmFtZS5cbiAgICogQHBhcmFtIHt3ZWlnaHR9IFtvcHRpb25zLndlaWdodD0wXSAtIFRoZSAwLTEgYW1vdW50IG9mIGluZmx1ZW5jZSB0aGUgc3RhdGUgd2lsbCBoYXZlLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5uYW1lID1cbiAgICAgIG9wdGlvbnMubmFtZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uYW1lIDogdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIHRoaXMuX3dlaWdodCA9XG4gICAgICBvcHRpb25zLndlaWdodCAhPT0gdW5kZWZpbmVkID8gTWF0aFV0aWxzLmNsYW1wKG9wdGlvbnMud2VpZ2h0LCAwLCAxKSA6IDA7XG4gICAgdGhpcy5faW50ZXJuYWxXZWlnaHQgPSB0aGlzLl93ZWlnaHQ7XG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG5cbiAgICB0aGlzLl9wcm9taXNlcyA9IHtcbiAgICAgIGZpbmlzaDogRGVmZXJyZWQucmVzb2x2ZSgpLFxuICAgICAgd2VpZ2h0OiBEZWZlcnJlZC5yZXNvbHZlKCksXG4gICAgICBwbGF5OiBEZWZlcnJlZC5yZXNvbHZlKCksXG4gICAgfTtcblxuICAgIHRoaXMuX3BsYXlDYWxsYmFja3MgPSB7XG4gICAgICBvbkZpbmlzaDogdW5kZWZpbmVkLFxuICAgICAgb25FcnJvcjogdW5kZWZpbmVkLFxuICAgICAgb25DYW5jZWw6IHVuZGVmaW5lZCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgd2hldGhlciBvciBub3QgdGhlIHN0YXRlIGlzIGN1cnJlbnRseSBwYXVzZWQuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgcGF1c2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXVzZWQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbmQgc2V0cyB0aGUgdXNlciBkZWZpbmVkIHdlaWdodC5cbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB3ZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlaWdodDtcbiAgfVxuXG4gIHNldCB3ZWlnaHQod2VpZ2h0KSB7XG4gICAgdGhpcy5fd2VpZ2h0ID0gTWF0aFV0aWxzLmNsYW1wKHdlaWdodCwgMCwgMSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgd2VpZ2h0IGlzIGN1cnJlbnRseSBiZWluZyBhbmltYXRlZC5cbiAgICpcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IHdlaWdodFBlbmRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VzLndlaWdodCAmJiB0aGlzLl9wcm9taXNlcy53ZWlnaHQucGVuZGluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB1c2VyIGRlZmluZWQgd2VpZ2h0IG92ZXIgdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHdlaWdodCAtIFRoZSB0YXJnZXQgd2VpZ2h0IHZhbHVlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NlY29uZHM9MF0gLSBUaGUgYW1vdW50IG9mIHRpbWUgaXQgd2lsbCB0YWtlIHRvIHJlYWNoIHRoZVxuICAgKiB0YXJnZXQgd2VpZ2h0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gZWFzaW5nRm4gLSBUaGUgZWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSBmb3IgaW50ZXJwb2xhdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMge0RlZmVycmVkfVxuICAgKi9cbiAgc2V0V2VpZ2h0KHdlaWdodCwgc2Vjb25kcyA9IDAsIGVhc2luZ0ZuKSB7XG4gICAgdGhpcy5fcHJvbWlzZXMud2VpZ2h0LmNhbmNlbCgpO1xuICAgIHdlaWdodCA9IE1hdGhVdGlscy5jbGFtcCh3ZWlnaHQpO1xuXG4gICAgdGhpcy5fcHJvbWlzZXMud2VpZ2h0ID0gQW5pbWF0aW9uVXRpbHMuaW50ZXJwb2xhdGVQcm9wZXJ0eShcbiAgICAgIHRoaXMsXG4gICAgICAnd2VpZ2h0JyxcbiAgICAgIHdlaWdodCxcbiAgICAgIHtzZWNvbmRzLCBlYXNpbmdGbn1cbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VzLndlaWdodDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBpbnRlcm5hbCB3ZWlnaHQuXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGludGVybmFsV2VpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbFdlaWdodDtcbiAgfVxuXG4gIC8qKlxuICAgKiBNdWx0aXBsaWVzIHRoZSB1c2VyIHdlaWdodCBieSBhIGZhY3RvciB0byBkZXRlcm1pbmUgdGhlIGludGVybmFsIHdlaWdodC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZhY3RvciAtIDAtMSBtdWx0aXBsaWVyIHRvIGFwcGx5IHRvIHRoZSB1c2VyIHdlaWdodC5cbiAgICovXG4gIHVwZGF0ZUludGVybmFsV2VpZ2h0KGZhY3Rvcikge1xuICAgIHRoaXMuX2ludGVybmFsV2VpZ2h0ID0gdGhpcy5fd2VpZ2h0ICogZmFjdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhbnkgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSBldmFsdWF0ZWQgZXZlcnkgZnJhbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVRpbWUgLSBUaW1lIGluIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgbGFzdCB1cGRhdGUuXG4gICAqL1xuICB1cGRhdGUoZGVsdGFUaW1lKSB7XG4gICAgaWYgKCF0aGlzLl9wYXVzZWQpIHtcbiAgICAgIE9iamVjdC52YWx1ZXModGhpcy5fcHJvbWlzZXMpLmZvckVhY2gocHJvbWlzZSA9PiB7XG4gICAgICAgIHByb21pc2UuZXhlY3V0ZShkZWx0YVRpbWUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHBsYXliYWNrIG9mIHRoZSBzdGF0ZSBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkZpbmlzaCAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgc3RhdGUgZmluaXNoZXMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkVycm9yIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBpZiB0aGUgc3RhdGUgZW5jb3VudGVyc1xuICAgKiBhbiBlcnJvciBkdXJpbmcgcGxheWJhY2suXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkNhbmNlbCAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgaWYgcGxheWJhY2sgaXMgY2FuY2VsZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH1cbiAgICovXG4gIHBsYXkob25GaW5pc2gsIG9uRXJyb3IsIG9uQ2FuY2VsKSB7XG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gICAgdGhpcy5fcGxheUNhbGxiYWNrcy5vbkZpbmlzaCA9IG9uRmluaXNoO1xuICAgIHRoaXMuX3BsYXlDYWxsYmFja3Mub25FcnJvciA9IG9uRXJyb3I7XG4gICAgdGhpcy5fcGxheUNhbGxiYWNrcy5vbkNhbmNlbCA9IG9uQ2FuY2VsO1xuXG4gICAgdGhpcy5fcHJvbWlzZXMucGxheSA9IG5ldyBEZWZlcnJlZCh1bmRlZmluZWQsIG9uRmluaXNoLCBvbkVycm9yLCBvbkNhbmNlbCk7XG4gICAgdGhpcy5fcHJvbWlzZXMuZmluaXNoID0gRGVmZXJyZWQuYWxsKFtcbiAgICAgIHRoaXMuX3Byb21pc2VzLnBsYXksXG4gICAgICB0aGlzLl9wcm9taXNlcy53ZWlnaHQsXG4gICAgXSk7XG5cbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZXMuZmluaXNoO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdXNlIHBsYXliYWNrIG9mIHRoZSBzdGF0ZS4gVGhpcyBwcmV2ZW50cyBwZW5kaW5nIHByb21pc2VzIGZyb20gYmVpbmcgZXhlY3V0ZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgcGF1c2UoKSB7XG4gICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN1bWUgcGxheWJhY2sgb2YgdGhlIHN0YXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25GaW5pc2ggLSBGdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIHN0YXRlIGZpbmlzaGVzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25FcnJvciAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgaWYgdGhlIHN0YXRlIGVuY291bnRlcnNcbiAgICogYW4gZXJyb3IgZHVyaW5nIHBsYXliYWNrLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25DYW5jZWwgLSBGdW5jdGlvbiB0byBleGVjdXRlIGlmIHBsYXliYWNrIGlzIGNhbmNlbGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9XG4gICAqL1xuICByZXN1bWUob25GaW5pc2gsIG9uRXJyb3IsIG9uQ2FuY2VsKSB7XG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG5cbiAgICBpZiAoIXRoaXMuX3Byb21pc2VzLnBsYXkucGVuZGluZykge1xuICAgICAgdGhpcy5fcGxheUNhbGxiYWNrcy5vbkZpbmlzaCA9IG9uRmluaXNoIHx8IHRoaXMuX3BsYXlDYWxsYmFja3Mub25GaW5pc2g7XG4gICAgICB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uRXJyb3IgPSBvbkVycm9yIHx8IHRoaXMuX3BsYXlDYWxsYmFja3Mub25FcnJvcjtcbiAgICAgIHRoaXMuX3BsYXlDYWxsYmFja3Mub25DYW5jZWwgPSBvbkNhbmNlbCB8fCB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uQ2FuY2VsO1xuXG4gICAgICB0aGlzLl9wcm9taXNlcy5wbGF5ID0gbmV3IERlZmVycmVkKFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHRoaXMuX3BsYXlDYWxsYmFja3Mub25GaW5pc2gsXG4gICAgICAgIHRoaXMuX3BsYXlDYWxsYmFja3Mub25FcnJvcixcbiAgICAgICAgdGhpcy5fcGxheUNhbGxiYWNrcy5vbkNhbmNlbFxuICAgICAgKTtcbiAgICAgIHRoaXMuX3Byb21pc2VzLmZpbmlzaCA9IERlZmVycmVkLmFsbChbXG4gICAgICAgIHRoaXMuX3Byb21pc2VzLnBsYXksXG4gICAgICAgIHRoaXMuX3Byb21pc2VzLndlaWdodCxcbiAgICAgIF0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9wcm9taXNlcy5maW5pc2g7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VsIHBsYXliYWNrIG9mIHRoZSBzdGF0ZSBhbmQgY2FuY2VsIGFueSBwZW5kaW5nIHByb21pc2VzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGNhbmNlbCgpIHtcbiAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuXG4gICAgT2JqZWN0LnZhbHVlcyh0aGlzLl9wcm9taXNlcykuZm9yRWFjaChwcm9taXNlID0+IHtcbiAgICAgIHByb21pc2UuY2FuY2VsKCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIHBsYXliYWNrIG9mIHRoZSBzdGF0ZSBhbmQgcmVzb2x2ZSBhbnkgcGVuZGluZyBwcm9taXNlcy5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdG9wKCkge1xuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG5cbiAgICBPYmplY3QudmFsdWVzKHRoaXMuX3Byb21pc2VzKS5mb3JFYWNoKHByb21pc2UgPT4ge1xuICAgICAgcHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWwgYW55IHBlbmRpbmcgcHJvbWlzZXMgYW5kIHJlbW92ZSByZWZlcmVuY2UgdG8gdGhlbS5cbiAgICovXG4gIGRpc2NhcmQoKSB7XG4gICAgdGhpcy5jYW5jZWwoKTtcblxuICAgIGRlbGV0ZSB0aGlzLl9wcm9taXNlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjZSB0aGUgaW50ZXJuYWwgd2VpZ2h0IHRvIDAuIFNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIHN3aXRjaGluZyBvciB0cmFuc2l0aW9uaW5nXG4gICAqIHRvIGEgbmV3IHN0YXRlLlxuICAgKi9cbiAgZGVhY3RpdmF0ZSgpIHtcbiAgICB0aGlzLnVwZGF0ZUludGVybmFsV2VpZ2h0KDApO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEFic3RyYWN0U3RhdGU7XG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxuaW1wb3J0IERlZmVycmVkIGZyb20gJ2NvcmUvRGVmZXJyZWQnO1xuaW1wb3J0IEFic3RyYWN0U3RhdGUgZnJvbSAnLi9BYnN0cmFjdFN0YXRlJztcblxuLyoqXG4gKiBDbGFzcyBmb3Igc21vb3RoIHRyYW5zaXRpb25pbmcgYmV0d2VlbiBzdGF0ZXMgb24gYW4gYW5pbWF0aW9uIGxheWVyLlxuICpcbiAqIEBleHRlbmRzIEFic3RyYWN0U3RhdGVcbiAqL1xuY2xhc3MgVHJhbnNpdGlvblN0YXRlIGV4dGVuZHMgQWJzdHJhY3RTdGF0ZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuXG4gICAgdGhpcy5fdG8gPSBudWxsO1xuICAgIHRoaXMuX2Zyb20gPSBbXTtcbiAgICB0aGlzLl93ZWlnaHRQcm9taXNlID0gRGVmZXJyZWQucmVzb2x2ZSgpO1xuICB9XG5cbiAgZ2V0IGludGVybmFsV2VpZ2h0KCkge1xuICAgIC8vIEZpbmQgdGhlIGNvbWJpbmVkIHdlaWdodCBvZiBhbGwgc3ViLXN0YXRlc1xuICAgIGxldCB0b3RhbFdlaWdodCA9IDA7XG5cbiAgICBpZiAodGhpcy5fdG8pIHtcbiAgICAgIHRvdGFsV2VpZ2h0ICs9IHRoaXMuX3RvLndlaWdodDtcbiAgICB9XG5cbiAgICB0aGlzLl9mcm9tLmZvckVhY2goc3RhdGUgPT4ge1xuICAgICAgdG90YWxXZWlnaHQgKz0gc3RhdGUud2VpZ2h0O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRvdGFsV2VpZ2h0ICogdGhpcy5faW50ZXJuYWxXZWlnaHQ7XG4gIH1cblxuICB1cGRhdGVJbnRlcm5hbFdlaWdodChmYWN0b3IpIHtcbiAgICBzdXBlci51cGRhdGVJbnRlcm5hbFdlaWdodChmYWN0b3IpO1xuXG4gICAgdGhpcy5fZnJvbS5mb3JFYWNoKHN0YXRlID0+IHtcbiAgICAgIHN0YXRlLnVwZGF0ZUludGVybmFsV2VpZ2h0KHRoaXMuX2ludGVybmFsV2VpZ2h0KTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLl90bykge1xuICAgICAgdGhpcy5fdG8udXBkYXRlSW50ZXJuYWxXZWlnaHQodGhpcy5faW50ZXJuYWxXZWlnaHQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgc3ViLXN0YXRlcyB0aGUgdHJhbnNpdGlvbiBpcyBjb250cm9sbGluZyBhbmQgc3RhcnQgbmV3IHdlaWdodFxuICAgKiBhbmltYXRpb25zIG9uIGVhY2ggb25lLiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgZWFjaCB0aW1lIHRoZSBjdXJyZW50IHN0YXRlIG9mXG4gICAqIGFuIGFuaW1hdGlvbiBsYXllciBnZXRzIHVwZGF0ZWQgdG8gYSBuZXcgdmFsdWUgYW5kIGEgdHJhbnNpdGlvbiB0aW1lIGdyZWF0ZXJcbiAgICogdGhhdCB6ZXJvIGlzIHNwZWNpZmllZC5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheS48QWJzdHJhY3RTdGF0ZT59IFtjdXJyZW50U3RhdGVzPVtdXSAtIFN0YXRlcyB3aG9zZSB3ZWlnaHQgdmFsdWVzXG4gICAqIHdpbGwgYmUgYW5pbWF0ZWQgdG8gMC5cbiAgICogQHBhcmFtIHtBYnN0cmFjdFN0YXRlPX0gdGFyZ2V0U3RhdGUgLSBTdGF0ZSB3aG9zZSB3ZWlnaHQgd2lsbCBiZSBhbmltYXRlZFxuICAgKiB0byAxLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdHJhbnNpdGlvblRpbWUgLSBBbW91bnQgb2YgdGltZSBpdCB3aWxsIGluIHNlY29uZHMgdGFrZSBmb3JcbiAgICogd2VpZ2h0IGFuaW1hdGlvbnMgdG8gY29tcGxldGUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBlYXNpbmdGbiAtIEVhc2luZyBmdW5jdGlvbiB0byB1c2UgZm9yIHdlaWdodCBhbmltYXRpb25zLlxuICAgKiBEZWZhdWx0IGlzIEVhc2luZy5MaW5lYXIuSW5PdXQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkNvbXBsZXRlIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBvbmNlIGFsbCB3ZWlnaHQgYW5pbWF0aW9uc1xuICAgKiBjb21wbGV0ZS5cbiAgICovXG4gIGNvbmZpZ3VyZShcbiAgICBjdXJyZW50U3RhdGVzID0gW10sXG4gICAgdGFyZ2V0U3RhdGUsXG4gICAgdHJhbnNpdGlvblRpbWUsXG4gICAgZWFzaW5nRm4sXG4gICAgb25Db21wbGV0ZVxuICApIHtcbiAgICAvLyBEZWFjdGl2YXRlIGFueSBzdGF0ZXMgdGhhdCBhcmVuJ3QgaW4gdGhlIG5ldyBjb25maWd1cmF0aW9uXG4gICAgaWYgKHRoaXMuX3RvID09PSB0YXJnZXRTdGF0ZSB8fCBjdXJyZW50U3RhdGVzLmluY2x1ZGVzKHRoaXMuX3RvKSkge1xuICAgICAgdGhpcy5fdG8gPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLl9mcm9tID0gdGhpcy5fZnJvbS5maWx0ZXIoXG4gICAgICBzdGF0ZSA9PiBzdGF0ZSAhPT0gdGFyZ2V0U3RhdGUgJiYgIWN1cnJlbnRTdGF0ZXMuaW5jbHVkZXMoc3RhdGUpXG4gICAgKTtcbiAgICB0aGlzLmRlYWN0aXZhdGUoKTtcblxuICAgIHRoaXMuX2Zyb20gPSBjdXJyZW50U3RhdGVzO1xuICAgIHRoaXMuX3RvID0gdGFyZ2V0U3RhdGU7XG4gICAgdGhpcy5yZXNldCh0cmFuc2l0aW9uVGltZSwgZWFzaW5nRm4sIG9uQ29tcGxldGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IG5ldyB3ZWlnaHQgYW5pbWF0aW9ucyBzdGF0ZSB0aGUgdHJhbnNpdGlvbiBjb250cm9scy4gVGhpcyBzaG91bGQgYmUgY2FsbGVkXG4gICAqIGlmIGFuIGFuaW1hdGlvbiBpcyBwbGF5ZWQgd2l0aCBhIHRyYW5zaXRpb24gdGltZSBncmVhdGVyIHRoYW4gemVybyBhbmQgYSB0cmFuc3Rpb25cbiAgICogdG8gdGhhdCBhbmltYXRpb24gd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0cmFuc2l0aW9uVGltZSAtIEFtb3VudCBvZiB0aW1lIGl0IHdpbGwgaW4gc2Vjb25kcyB0YWtlIGZvclxuICAgKiB3ZWlnaHQgYW5pbWF0aW9ucyB0byBjb21wbGV0ZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGVhc2luZ0ZuIC0gRWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSBmb3Igd2VpZ2h0IGFuaW1hdGlvbnMuXG4gICAqIERlZmF1bHQgaXMgRWFzaW5nLkxpbmVhci5Jbk91dC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uQ29tcGxldGUgLSBGdW5jdGlvbiB0byBleGVjdXRlIG9uY2UgYWxsIHdlaWdodCBhbmltYXRpb25zXG4gICAqIGNvbXBsZXRlLlxuICAgKi9cbiAgcmVzZXQodHJhbnNpdGlvblRpbWUsIGVhc2luZ0ZuLCBvbkNvbXBsZXRlKSB7XG4gICAgLy8gU3RvcCBhbnkgcGVuZGluZyBwcm9taXNlc1xuICAgIHRoaXMuX3dlaWdodFByb21pc2UuY2FuY2VsKCk7XG5cbiAgICAvLyBTdGFydCB0d2VlbmluZyB3ZWlnaHQgdG8gMCBmb3IgdGhlIGN1cnJlbnQgc3RhdGVzXG4gICAgY29uc3Qgd2VpZ2h0UHJvbWlzZXMgPSB0aGlzLl9mcm9tLm1hcChzdGF0ZSA9PlxuICAgICAgc3RhdGUuc2V0V2VpZ2h0KDAsIHRyYW5zaXRpb25UaW1lLCBlYXNpbmdGbilcbiAgICApO1xuXG4gICAgLy8gU3RhcnQgdHdlZW5pbmcgd2VpZ2h0IHRvIDEgZm9yIHRoZSB0YXJnZXQgc3RhdGVcbiAgICBpZiAodGhpcy5fdG8pIHtcbiAgICAgIHdlaWdodFByb21pc2VzLnB1c2godGhpcy5fdG8uc2V0V2VpZ2h0KDEsIHRyYW5zaXRpb25UaW1lLCBlYXNpbmdGbikpO1xuICAgICAgdGhpcy5uYW1lID0gdGhpcy5fdG8ubmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5uYW1lID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLl93ZWlnaHRQcm9taXNlID0gRGVmZXJyZWQuYWxsKHdlaWdodFByb21pc2VzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9mcm9tLmZvckVhY2goc3RhdGUgPT4ge1xuICAgICAgICBzdGF0ZS5jYW5jZWwoKTtcbiAgICAgICAgc3RhdGUuZGVhY3RpdmF0ZSgpO1xuICAgICAgfSk7XG4gICAgICBpZiAodHlwZW9mIG9uQ29tcGxldGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcGxheShvbkZpbmlzaCwgb25FcnJvciwgb25DYW5jZWwsIG9uTmV4dCkge1xuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BsYXlDYWxsYmFja3Mub25GaW5pc2ggPSBvbkZpbmlzaDtcbiAgICB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uRXJyb3IgPSBvbkVycm9yO1xuICAgIHRoaXMuX3BsYXlDYWxsYmFja3Mub25DYW5jZWwgPSBvbkNhbmNlbDtcblxuICAgIGNvbnN0IHByb21pc2VzID0gW3RoaXMuX3dlaWdodFByb21pc2VdO1xuXG4gICAgdGhpcy5fZnJvbS5mb3JFYWNoKHN0YXRlID0+IHtcbiAgICAgIHN0YXRlLnJlc3VtZSgpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuX3RvKSB7XG4gICAgICB0aGlzLl9wcm9taXNlcy5wbGF5ID0gdGhpcy5fdG8ucGxheShcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgb25OZXh0XG4gICAgICApO1xuICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLl9wcm9taXNlcy5wbGF5KTtcbiAgICB9XG5cbiAgICB0aGlzLl9wcm9taXNlcy5maW5pc2ggPSBEZWZlcnJlZC5hbGwocHJvbWlzZXMsIG9uRmluaXNoLCBvbkVycm9yLCBvbkNhbmNlbCk7XG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VzLmZpbmlzaDtcbiAgfVxuXG4gIHBhdXNlKCkge1xuICAgIHRoaXMuX2Zyb20uZm9yRWFjaChzdGF0ZSA9PiB7XG4gICAgICBzdGF0ZS5wYXVzZSgpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuX3RvKSB7XG4gICAgICB0aGlzLl90by5wYXVzZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5wYXVzZSgpO1xuICB9XG5cbiAgcmVzdW1lKG9uRmluaXNoLCBvbkVycm9yLCBvbkNhbmNlbCwgb25OZXh0KSB7XG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG5cbiAgICBpZiAoIXRoaXMuX3Byb21pc2VzLnBsYXkucGVuZGluZykge1xuICAgICAgdGhpcy5fcGxheUNhbGxiYWNrcy5vbkZpbmlzaCA9IG9uRmluaXNoIHx8IHRoaXMuX3BsYXlDYWxsYmFja3Mub25GaW5pc2g7XG4gICAgICB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uRXJyb3IgPSBvbkVycm9yIHx8IHRoaXMuX3BsYXlDYWxsYmFja3Mub25FcnJvcjtcbiAgICAgIHRoaXMuX3BsYXlDYWxsYmFja3Mub25DYW5jZWwgPSBvbkNhbmNlbCB8fCB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uQ2FuY2VsO1xuICAgIH1cblxuICAgIGNvbnN0IHByb21pc2VzID0gW3RoaXMuX3dlaWdodFByb21pc2VdO1xuXG4gICAgdGhpcy5fZnJvbS5mb3JFYWNoKHN0YXRlID0+IHtcbiAgICAgIHN0YXRlLnJlc3VtZSgpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuX3RvKSB7XG4gICAgICB0aGlzLl9wcm9taXNlcy5wbGF5ID0gdGhpcy5fdG8ucmVzdW1lKFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICBvbk5leHRcbiAgICAgICk7XG4gICAgICBwcm9taXNlcy5wdXNoKHRoaXMuX3Byb21pc2VzLnBsYXkpO1xuICAgIH1cblxuICAgIHRoaXMuX3Byb21pc2VzLmZpbmlzaCA9IERlZmVycmVkLmFsbChcbiAgICAgIHByb21pc2VzLFxuICAgICAgdGhpcy5fcGxheUNhbGxiYWNrcy5vbkZpbmlzaCxcbiAgICAgIHRoaXMuX3BsYXlDYWxsYmFja3Mub25FcnJvcixcbiAgICAgIHRoaXMuX3BsYXlDYWxsYmFja3Mub25DYW5jZWxcbiAgICApO1xuICAgIHJldHVybiB0aGlzLl9wcm9taXNlcy5maW5pc2g7XG4gIH1cblxuICBjYW5jZWwoKSB7XG4gICAgdGhpcy5fZnJvbS5mb3JFYWNoKHN0YXRlID0+IHtcbiAgICAgIHN0YXRlLnBhdXNlKCk7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5fdG8pIHtcbiAgICAgIHRoaXMuX3RvLmNhbmNlbCgpO1xuICAgIH1cblxuICAgIHRoaXMuX3dlaWdodFByb21pc2UuY2FuY2VsKCk7XG5cbiAgICByZXR1cm4gc3VwZXIuY2FuY2VsKCk7XG4gIH1cblxuICBzdG9wKCkge1xuICAgIHRoaXMuX2Zyb20uZm9yRWFjaChzdGF0ZSA9PiB7XG4gICAgICBzdGF0ZS5wYXVzZSgpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuX3RvKSB7XG4gICAgICB0aGlzLl90by5zdG9wKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLnN0b3AoKTtcbiAgfVxuXG4gIHVwZGF0ZShkZWx0YVRpbWUpIHtcbiAgICBzdXBlci51cGRhdGUoZGVsdGFUaW1lKTtcblxuICAgIHRoaXMuX2Zyb20uZm9yRWFjaChzdGF0ZSA9PiB7XG4gICAgICBzdGF0ZS51cGRhdGUoZGVsdGFUaW1lKTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLl90bykge1xuICAgICAgdGhpcy5fdG8udXBkYXRlKGRlbHRhVGltZSk7XG4gICAgfVxuICB9XG5cbiAgZGlzY2FyZCgpIHtcbiAgICBzdXBlci5kaXNjYXJkKCk7XG5cbiAgICB0aGlzLl93ZWlnaHRQcm9taXNlLmNhbmNlbCgpO1xuICAgIGRlbGV0ZSB0aGlzLl93ZWlnaHRQcm9taXNlO1xuICAgIHRoaXMuX3RvID0gbnVsbDtcbiAgICB0aGlzLl9mcm9tLmxlbmd0aCA9IDA7XG4gIH1cblxuICBkZWFjdGl2YXRlKCkge1xuICAgIGlmICh0aGlzLl90bykge1xuICAgICAgdGhpcy5fdG8uZGVhY3RpdmF0ZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2Zyb20uZm9yRWFjaChzdGF0ZSA9PiB7XG4gICAgICBzdGF0ZS5kZWFjdGl2YXRlKCk7XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVHJhbnNpdGlvblN0YXRlO1xuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcbi8qIGVzbGludC1kaXNhYmxlIG1heC1jbGFzc2VzLXBlci1maWxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHktZnVuY3Rpb24gKi9cbi8qIGVzbGludC1kaXNhYmxlIGdldHRlci1yZXR1cm4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVzZWxlc3MtY29uc3RydWN0b3IgKi9cbmltcG9ydCBUcmFuc2l0aW9uU3RhdGUgZnJvbSAnLi9zdGF0ZS9UcmFuc2l0aW9uU3RhdGUnO1xuaW1wb3J0IERlZmVycmVkIGZyb20gJy4uL0RlZmVycmVkJztcblxuLyoqXG4gKiBDbGFzcyBmYWN0b3J5IGludGVyZmFjZSBmb3IgY29udHJvbGxpbmcgcGxheWJhY2sgb2YgYSBjb2xsZWN0aW9uIG9mIGFuaW1hdGlvbnMuXG4gKiBPbmUgYW5pbWF0aW9uIGNhbiBiZSBwbGF5ZWQgYXQgYW55IGdpdmVuIHRpbWUsIGNyb3NzZmFkaW5nIGJldHdlZW4gYW5pbWF0aW9uc1xuICogd2lsbCByZXN1bHQgaW4gcGxheWluZyBhIHtAbGluayBUcmFuc2l0aW9uU3RhdGV9LlxuICpcbiAqIEBpbnRlcmZhY2VcbiAqL1xuY2xhc3MgQW5pbWF0aW9uUGxheWVySW50ZXJmYWNlIHtcbiAgLyoqXG4gICAqIEdldHMgd2hldGhlciBvciBub3QgdGhlIHBsYXllciBpcyB1cGRhdGluZyBzdGF0ZXMuXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBwYXVzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhdXNlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuZCBzZXRzIHRoZSBkZWZhdWx0IG51bWJlciBvZiBzZWNvbmRzIGl0IHRha2VzIHRvIHRyYW5zaXRpb24gdG8gYSBuZXdcbiAgICogYW5pbWF0aW9uLlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHRyYW5zaXRpb25UaW1lKCkge31cblxuICBzZXQgdHJhbnNpdGlvblRpbWUoc2Vjb25kcykge31cblxuICAvKipcbiAgICogR2V0cyBhbmQgc2V0cyB0aGUgZGVmYXVsdCBlYXNpbmcgZnVuY3Rpb24gdG8gdXNlIHdoZW4gdHJhbnNpdGlvbmluZyBhbmRcbiAgICogc2V0dGluZyB3ZWlnaHRzLlxuICAgKlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICBnZXQgZWFzaW5nRm4oKSB7fVxuXG4gIHNldCBlYXNpbmdGbihmbikge31cblxuICAvKipcbiAgICogR2V0cyB0aGUgc3RhdGUgdGhlIGxheWVyIGlzIGN1cnJlbnRseSBpbiBjb250cm9sIG9mLlxuICAgKlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0Fic3RyYWN0U3RhdGV9XG4gICAqL1xuICBnZXQgY3VycmVudFN0YXRlKCkge31cblxuICAvKipcbiAgICogR2V0cyB0aGUgbmFtZSBvZiB0aGUgc3RhdGUgdGhlIGxheWVyIGlzIGN1cnJlbnRseSBpbiBjb250cm9sIG9mLlxuICAgKlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBjdXJyZW50QW5pbWF0aW9uKCkge31cblxuICAvKipcbiAgICogR2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgbGF5ZXIgaXMgY3VycmVudGx5IHRyYW5zaXRpb25pbmcgdG8gYSBuZXcgYW5pbWF0aW9uLlxuICAgKlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNUcmFuc2l0aW9uaW5nKCkge31cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBsYXllcidzIGN1cnJlbnQgc3RhdGUgdG8gYSBuZXcgdmFsdWUuIElmIHRyYW5zaXRpb25UaW1lIGlzIGRlZmluZWRcbiAgICogYW5kIGdyZWF0ZXIgdGhhbiB6ZXJvLCBwZXJmb3JtIGEgc21vb3RoIGJsZW5kIGJldHdlZW4gYW55IHN0YXRlcyB0aGF0IGN1cnJlbnRseVxuICAgKiBoYXZlIG5vbi16ZXJvIHdlaWdodCB2YWx1ZXMgYW5kIHRoZSBuZXcgc3RhdGUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7KHN0cmluZ3xudWxsKX0gbmFtZSAtIE5hbWUgb2YgdGhlIHN0YXRlIHRvIHRyYW5zaXRpb24gdG8uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwbGF5TWV0aG9kIC0gTmFtZSBvZiB0aGUgb3BlcmF0aW9uIGJlaW5nIHByZXBhcmVkIGZvciwgdG8gYmVcbiAgICogdXNlZCBpbiBlcnJvciBtZXNzYWdpbmcuXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gdHJhbnNpdGlvblRpbWUgLSBBbW91bnQgb2YgdGltZSBpbiBzZWNvbmRzIGl0IHdpbGwgdGFrZSB0b1xuICAgKiBzd2l0Y2ggdG8gdGhlIG5ldyBzdGF0ZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGVhc2luZ0ZuIC0gRWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSB3aGVuIHRyYW5zaXRpb25pbmcgdG8gYVxuICAgKiBuZXcgc3RhdGUgb3ZlciB0aW1lLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25FcnJvciAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgaWYgYW4gZXJyb3IgaXMgZW5jb3VudGVyZWQuXG4gICAqL1xuICBfcHJlcGFyZUN1cnJlbnRTdGF0ZShuYW1lLCBwbGF5TWV0aG9kLCB0cmFuc2l0aW9uVGltZSwgZWFzaW5nRm4sIG9uRXJyb3IpIHt9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHBsYXliYWNrIGFuIGFuaW1hdGlvbiBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRvIHBsYXkuXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gdHJhbnNpdGlvblRpbWUgLSBBbW91bnQgb2YgdGltZSBpdCB3aWxsIHRha2UgYmVmb3JlIHRoZVxuICAgKiBuZXcgc3RhdGUgaGFzIGZ1bGwgaW5mbHVlbmNlIGZvciB0aGUgbGF5ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBlYXNpbmdGbiAtIEVhc2luZyBmdW5jdGlvbiB0byB1c2UgZm9yIGJsZW5kaW5nIGlmIHRyYW5zaXRpb25UaW1lXG4gICAqIGlzIGdyZWF0ZXIgdGhhbiB6ZXJvLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25GaW5pc2ggLSBGdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIGFuaW1hdGlvbiBmaW5pc2hlcy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uRXJyb3IgLSBGdW5jdGlvbiB0byBleGVjdXRlIGlmIHRoZSBhbmltYXRpb24gZW5jb3VudGVyc1xuICAgKiBhbiBlcnJvciBkdXJpbmcgcGxheWJhY2suXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkNhbmNlbCAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgaWYgcGxheWJhY2sgaXMgY2FuY2VsZWQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbk5leHQgLSBGdW5jdGlvbiB0byBleGVjdXRlIGlmIGFuIGFuaW1hdGlvbiBxdWV1ZSBpc1xuICAgKiBwbGF5ZWQgYW5kIGl0IGFkdmFuY2VzIHRvIHRoZSBuZXh0IGFuaW1hdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMge0RlZmVycmVkfVxuICAgKi9cbiAgcGxheUFuaW1hdGlvbihcbiAgICBuYW1lLFxuICAgIHRyYW5zaXRpb25UaW1lLFxuICAgIGVhc2luZ0ZuLFxuICAgIG9uRmluaXNoLFxuICAgIG9uRXJyb3IsXG4gICAgb25DYW5jZWwsXG4gICAgb25OZXh0XG4gICkge31cblxuICAvKipcbiAgICogQ2FuY2VsIHBsYXliYWNrIG9mIHRoZSBjdXJyZW50IGFuaW1hdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBjYW5jZWxBbmltYXRpb24oKSB7fVxuXG4gIC8qKlxuICAgKiBQYXVzZSBwbGF5YmFjayBvZiB0aGUgY3VycmVudCBhbmltYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgcGF1c2VBbmltYXRpb24oKSB7fVxuXG4gIC8qKlxuICAgKiBSZXN1bWUgcGxheWJhY2sgb2YgYW4gYW5pbWF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG5hbWUgLSBOYW1lIG9mIHRoZSBhbmltYXRpb24gdG8gcmVzdW1lIHBsYXliYWNrIGZvci4gRGVmYXVsdFxuICAgKiBpcyB0aGUgbGF5ZXIncyBjdXJyZW50IGFuaW1hdGlvbiBuYW1lLlxuICAgKiBAcGFyYW0ge251bWJlcj19IHRyYW5zaXRpb25UaW1lIC0gQW1vdW50IG9mIHRpbWUgaXQgd2lsbCB0YWtlIGJlZm9yZSB0aGVcbiAgICogbmV3IHN0YXRlIGhhcyBmdWxsIGluZmx1ZW5jZSBmb3IgdGhlIGxheWVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25GaW5pc2ggLSBGdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIHN0YXRlIGZpbmlzaGVzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25FcnJvciAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgaWYgdGhlIHN0YXRlIGVuY291bnRlcnNcbiAgICogYW4gZXJyb3IgZHVyaW5nIHBsYXliYWNrLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25DYW5jZWwgLSBGdW5jdGlvbiB0byBleGVjdXRlIGlmIHBsYXliYWNrIGlzIGNhbmNlbGVkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25OZXh0IC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBpZiBhbiBhbmltYXRpb24gcXVldWUgaXNcbiAgICogcGxheWVkIGFuZCBpdCBhZHZhbmNlcyB0byB0aGUgbmV4dCBhbmltYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH1cbiAgICovXG4gIHJlc3VtZUFuaW1hdGlvbihcbiAgICBuYW1lLFxuICAgIHRyYW5zaXRpb25UaW1lLFxuICAgIGVhc2luZ0ZuLFxuICAgIG9uRmluaXNoLFxuICAgIG9uRXJyb3IsXG4gICAgb25DYW5jZWwsXG4gICAgb25OZXh0XG4gICkge31cblxuICAvKipcbiAgICogU3RvcCBwbGF5YmFjayBvZiB0aGUgY3VycmVudCBhbmltYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RvcEFuaW1hdGlvbigpIHt9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgY3VycmVudCBhbmltYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVRpbWUgLSBUaW1lIGluIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgbGFzdCB1cGRhdGUuXG4gICAqL1xuICB1cGRhdGUoZGVsdGFUaW1lKSB7fVxuXG4gIC8qKlxuICAgKiBEaXNjYXJkIHRoZSB0cmFuc2l0aW9uIHN0YXRlLlxuICAgKi9cbiAgZGlzY2FyZCgpIHt9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjbGFzcyB0aGF0IGltcGxlbWVudHMge0BsaW5rIEFuaW1hdGlvblBsYXllckludGVyZmFjZX0gYW5kIGV4dGVuZHNcbiAgICogYSBzcGVjaWZpZWQgYmFzZSBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtDbGFzc30gW0Jhc2VDbGFzcyA9IGNsYXNze31dIC0gVGhlIGNsYXNzIHRvIGV4dGVuZC5cbiAgICpcbiAgICogQHJldHVybiB7Q2xhc3N9IEEgY2xhc3MgdGhhdCBleHRlbmRzIGBCYXNlQ2xhc3NgIGFuZCBpbXBsZW1lbnRzIHtAbGluayBBbmltYXRpb25QbGF5ZXJJbnRlcmZhY2V9LlxuICAgKi9cbiAgc3RhdGljIE1peGluKEJhc2VDbGFzcyA9IGNsYXNzIHt9KSB7XG4gICAgY29uc3QgQW5pbWF0aW9uUGxheWVyTWl4aW4gPSBjbGFzcyBleHRlbmRzIEJhc2VDbGFzcyB7XG4gICAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30sIC4uLmFyZ3MpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucywgLi4uYXJncyk7XG5cbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvblN0YXRlID0gbmV3IFRyYW5zaXRpb25TdGF0ZSgpO1xuICAgICAgICB0aGlzLl9zdGF0ZXMgPSB0aGlzLl9zdGF0ZXMgIT09IHVuZGVmaW5lZCA/IHRoaXMuX3N0YXRlcyA6IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fY3VycmVudFN0YXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvblRpbWUgPVxuICAgICAgICAgIE51bWJlcihvcHRpb25zLnRyYW5zaXRpb25UaW1lKSA+PSAwXG4gICAgICAgICAgICA/IE51bWJlcihvcHRpb25zLnRyYW5zaXRpb25UaW1lKVxuICAgICAgICAgICAgOiAwO1xuXG4gICAgICAgIHRoaXMuX2Vhc2luZ0ZuID1cbiAgICAgICAgICB0eXBlb2Ygb3B0aW9ucy5lYXNpbmdGbiA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMuZWFzaW5nRm4gOiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGdldCBwYXVzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXVzZWQ7XG4gICAgICB9XG5cbiAgICAgIGdldCB0cmFuc2l0aW9uVGltZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zaXRpb25UaW1lO1xuICAgICAgfVxuXG4gICAgICBzZXQgdHJhbnNpdGlvblRpbWUoc2Vjb25kcykge1xuICAgICAgICBzZWNvbmRzID0gTnVtYmVyKHNlY29uZHMpO1xuXG4gICAgICAgIGlmICghKHNlY29uZHMgPj0gMCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQ2Fubm90IHNldCB0cmFuc2l0aW9uIHRpbWUgZm9yICR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSB0byAke3NlY29uZHN9LiBTZWNvbmRzIG11c3QgYmUgYSBudW1lcmljIHZhbHVlIGdyZWF0aGVyIHRoYW4gb3IgZXF1YWwgdG8gemVyby5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25UaW1lID0gc2Vjb25kcztcbiAgICAgIH1cblxuICAgICAgZ2V0IGVhc2luZ0ZuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWFzaW5nRm47XG4gICAgICB9XG5cbiAgICAgIHNldCBlYXNpbmdGbihmbikge1xuICAgICAgICB0aGlzLl9lYXNpbmdGbiA9IGZuO1xuICAgICAgfVxuXG4gICAgICBnZXQgY3VycmVudFN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFN0YXRlO1xuICAgICAgfVxuXG4gICAgICBnZXQgY3VycmVudEFuaW1hdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRTdGF0ZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50U3RhdGUubmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBnZXQgaXNUcmFuc2l0aW9uaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFN0YXRlID09PSB0aGlzLl90cmFuc2l0aW9uU3RhdGU7XG4gICAgICB9XG5cbiAgICAgIF9wcmVwYXJlQ3VycmVudFN0YXRlKFxuICAgICAgICBuYW1lLFxuICAgICAgICBwbGF5TWV0aG9kLFxuICAgICAgICB0cmFuc2l0aW9uVGltZSxcbiAgICAgICAgZWFzaW5nRm4sXG4gICAgICAgIG9uRXJyb3JcbiAgICAgICkge1xuICAgICAgICBpZiAobmFtZSAhPT0gbnVsbCAmJiAhdGhpcy5fc3RhdGVzLmhhcyhuYW1lKSkge1xuICAgICAgICAgIGNvbnN0IGUgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQ2Fubm90ICR7cGxheU1ldGhvZH0gYW5pbWF0aW9uICR7bmFtZX0uIE5vIGFuaW1hdGlvbiBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIG9uRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9uRXJyb3IoZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRhcmdldFN0YXRlID0gbmFtZSAhPT0gbnVsbCA/IHRoaXMuX3N0YXRlcy5nZXQobmFtZSkgOiBudWxsO1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgbmV3IHN0YXRlIGlzbid0IGFscmVhZHkgcGxheWluZ1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50QW5pbWF0aW9uICE9PSBuYW1lKSB7XG4gICAgICAgICAgLy8gU3dpdGNoIHRvIHRoZSBuZXcgc3RhdGUgaW1tZWRpYXRlbHlcbiAgICAgICAgICBpZiAodHJhbnNpdGlvblRpbWUgPD0gMCkge1xuICAgICAgICAgICAgLy8gQ2FuY2VsIHRoZSBjdXJyZW50IHN0YXRlIGFuZCBzZXQgaXRzIHdlaWdodCB0byAwXG4gICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudFN0YXRlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZS5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFN0YXRlLndlaWdodCA9IDA7XG4gICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZS5kZWFjdGl2YXRlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZSA9IHRhcmdldFN0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBCbGVuZCB0byB0aGUgbmV3IHN0YXRlIG92ZXIgdGltZVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRvIHRyYW5zaXRpb24gb3V0IG9mIGFueSBzdGF0ZXMgd2l0aCBub24temVybyB3ZWlnaHRcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZXMgPSBbLi4udGhpcy5fc3RhdGVzLnZhbHVlcygpXS5maWx0ZXIoXG4gICAgICAgICAgICAgIHMgPT4gcyAhPT0gdGFyZ2V0U3RhdGUgJiYgKHMud2VpZ2h0IHx8IHMud2VpZ2h0UGVuZGluZylcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgdHJhbnNpdGlvbiBzdGF0ZSB3aXRoIG5ldyBpbnB1dHNcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25TdGF0ZS5jb25maWd1cmUoXG4gICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZXMsXG4gICAgICAgICAgICAgIHRhcmdldFN0YXRlLFxuICAgICAgICAgICAgICB0cmFuc2l0aW9uVGltZSxcbiAgICAgICAgICAgICAgZWFzaW5nRm4sXG4gICAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50U3RhdGUgPSB0YXJnZXRTdGF0ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uU3RhdGUud2VpZ2h0ID0gMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdGhpcy5fY3VycmVudFN0YXRlID0gdGhpcy5fdHJhbnNpdGlvblN0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwbGF5TWV0aG9kID09PSAncGxheScpIHtcbiAgICAgICAgICB0aGlzLl9jdXJyZW50U3RhdGUuY2FuY2VsKCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5fY3VycmVudFN0YXRlID09PSB0aGlzLl90cmFuc2l0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25TdGF0ZS5yZXNldCh0cmFuc2l0aW9uVGltZSwgZWFzaW5nRm4sICgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFN0YXRlID0gdGFyZ2V0U3RhdGU7XG4gICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25TdGF0ZS53ZWlnaHQgPSAwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIHdlaWdodCBmb3IgdGhlIG5ldyBjdXJyZW50IHN0YXRlIHNvIGl0IGhhcyBmdWxsIGluZmx1ZW5jZSBmb3IgdGhlIHBsYXllclxuICAgICAgICB0aGlzLl9jdXJyZW50U3RhdGUud2VpZ2h0ID0gMTtcbiAgICAgICAgdGhpcy5fY3VycmVudFN0YXRlLnVwZGF0ZUludGVybmFsV2VpZ2h0KHRoaXMuX2ludGVybmFsV2VpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgcGxheUFuaW1hdGlvbihcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdHJhbnNpdGlvblRpbWUsXG4gICAgICAgIGVhc2luZ0ZuLFxuICAgICAgICBvbkZpbmlzaCxcbiAgICAgICAgb25FcnJvcixcbiAgICAgICAgb25DYW5jZWwsXG4gICAgICAgIG9uTmV4dFxuICAgICAgKSB7XG4gICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgbGV0IHJlamVjdCA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuX3ByZXBhcmVDdXJyZW50U3RhdGUoXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgJ3BsYXknLFxuICAgICAgICAgICAgdHJhbnNpdGlvblRpbWUgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/IHRyYW5zaXRpb25UaW1lXG4gICAgICAgICAgICAgIDogdGhpcy5fdHJhbnNpdGlvblRpbWUsXG4gICAgICAgICAgICBlYXNpbmdGbiAhPT0gdW5kZWZpbmVkID8gZWFzaW5nRm4gOiB0aGlzLl9lYXNpbmdGbixcbiAgICAgICAgICAgIG9uRXJyb3JcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZXJyb3IgPSBlO1xuICAgICAgICAgIHJlamVjdCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIERlZmVycmVkLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFN0YXRlLnBsYXkob25GaW5pc2gsIG9uRXJyb3IsIG9uQ2FuY2VsLCBvbk5leHQpO1xuICAgICAgfVxuXG4gICAgICBwYXVzZUFuaW1hdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRTdGF0ZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50U3RhdGUucGF1c2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzdW1lQW5pbWF0aW9uKFxuICAgICAgICBuYW1lLFxuICAgICAgICB0cmFuc2l0aW9uVGltZSxcbiAgICAgICAgZWFzaW5nRm4sXG4gICAgICAgIG9uRmluaXNoLFxuICAgICAgICBvbkVycm9yLFxuICAgICAgICBvbkNhbmNlbCxcbiAgICAgICAgb25OZXh0XG4gICAgICApIHtcbiAgICAgICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9jdXJyZW50U3RhdGUpIHtcbiAgICAgICAgICBuYW1lID0gdGhpcy5fY3VycmVudFN0YXRlLm5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZXJyb3I7XG4gICAgICAgIGxldCByZWplY3QgPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLl9wcmVwYXJlQ3VycmVudFN0YXRlKFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICdyZXN1bWUnLFxuICAgICAgICAgICAgdHJhbnNpdGlvblRpbWUgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/IHRyYW5zaXRpb25UaW1lXG4gICAgICAgICAgICAgIDogdGhpcy5fdHJhbnNpdGlvblRpbWUsXG4gICAgICAgICAgICBlYXNpbmdGbiAhPT0gdW5kZWZpbmVkID8gZWFzaW5nRm4gOiB0aGlzLl9lYXNpbmdGbixcbiAgICAgICAgICAgIG9uRXJyb3JcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZXJyb3IgPSBlO1xuICAgICAgICAgIHJlamVjdCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIERlZmVycmVkLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFN0YXRlLnJlc3VtZShvbkZpbmlzaCwgb25FcnJvciwgb25DYW5jZWwsIG9uTmV4dCk7XG4gICAgICB9XG5cbiAgICAgIGNhbmNlbEFuaW1hdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRTdGF0ZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50U3RhdGUuY2FuY2VsKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0b3BBbmltYXRpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50U3RhdGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFN0YXRlLnN0b3AoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdXBkYXRlKGRlbHRhVGltZSkge1xuICAgICAgICBpZiAoc3VwZXIudXBkYXRlKSB7XG4gICAgICAgICAgc3VwZXIudXBkYXRlKGRlbHRhVGltZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fY3VycmVudFN0YXRlKSB7XG4gICAgICAgICAgdGhpcy5fY3VycmVudFN0YXRlLnVwZGF0ZShkZWx0YVRpbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRpc2NhcmQoKSB7XG4gICAgICAgIGlmIChzdXBlci5kaXNjYXJkKSB7XG4gICAgICAgICAgc3VwZXIuZGlzY2FyZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvblN0YXRlLmRpc2NhcmQoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3RyYW5zaXRpb25TdGF0ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIEFuaW1hdGlvblBsYXllck1peGluO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEFuaW1hdGlvblBsYXllckludGVyZmFjZTtcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtY2xhc3Nlcy1wZXItZmlsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLWVtcHR5LWZ1bmN0aW9uICovXG4vKiBlc2xpbnQtZGlzYWJsZSBnZXR0ZXItcmV0dXJuICovXG5cbmltcG9ydCBVdGlscyBmcm9tICcuLi8uLi9VdGlscyc7XG5cbi8qKlxuICogQ2xhc3MgZmFjdG9yeSBpbnRlcmZhY2UgZm9yIG1hbmlwdWxhdGluZyBhIGNvbGxlY3Rpb24gb2Yge0BsaW5rIEFic3RyYWN0U3RhdGV9LlxuICpcbiAqIEBpbnRlcmZhY2VcbiAqL1xuY2xhc3MgU3RhdGVDb250YWluZXJJbnRlcmZhY2Uge1xuICAvKipcbiAgICogUmV0dXJuIHRoZSBzdGF0ZSB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIHN0YXRlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7QWJzdHJhY3RTdGF0ZX1cbiAgICovXG4gIGdldFN0YXRlKG5hbWUpIHt9XG5cbiAgLyoqXG4gICAqIEdldHMgYW4gYXJyYXkgb2YgdGhlIG5hbWVzIG9mIGFsbCBzdGF0ZXMgaW4gdGhlIGNvbnRhaW5lci5cbiAgICpcbiAgICogQHR5cGUge0FycmF5LjxzdHJpbmc+fVxuICAgKi9cbiAgZ2V0U3RhdGVOYW1lcygpIHt9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyBzdGF0ZSB0byBiZSBjb250cm9sbGVkIGJ5IHRoZSBjb250YWluZXIuIFN0YXRlcyBhcmUgc3RvcmVkIGtleWVkXG4gICAqIGJ5IHRoZWlyIG5hbWUgcHJvcGVydHksIHdoaWNoIG11c3QgYmUgdW5pcXVlLiBJZiBpdCBpc24ndCwgYSBudW1iZXIgd2lsbFxuICAgKiBiZSBhZGRlZCBvciBpbmNyZW1lbnRlZCB1bnRpbCBhIHVuaXF1ZSBrZXkgaXMgZ2VuZXJhdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0Fic3RyYWN0U3RhdGV9IHN0YXRlIC0gU3RhdGUgdG8gYWRkIHRvIHRoZSBjb250YWluZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVW5pcXVlIG5hbWUgb2YgdGhlIHN0YXRlLlxuICAgKi9cbiAgYWRkU3RhdGUoc3RhdGUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBzdGF0ZSB3aXRoIHRoZSBnaXZlbiBuYW1lIGZyb20gdGhlIGNvbnRhaW5lci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBzdGF0ZSB0byByZW1vdmUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAtIFdoZXRoZXIgb3Igbm90IGEgc3RhdGUgd2FzIHJlbW92ZWQuXG4gICAqL1xuICByZW1vdmVTdGF0ZShuYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZW5hbWVzIGEgc3RhdGUgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpbiB0aGUgY29udGFpbmVyLiBOYW1lIG11c3QgYmUgdW5pcXVlXG4gICAqIHRvIHRoZSBjb250YWluZXIsIGlmIGl0IGlzbid0IHRoZSBuYW1lIHdpbGwgYmUgaW5jcmVtZW50ZWQgdW50aWwgaXQgaXMgdW5pcXVlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY3VycmVudE5hbWUgLSBOYW1lIG9mIHRoZSBzdGF0ZSB0byByZW5hbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdOYW1lIC0gTmFtZSB0byB1cGRhdGUgdGhlIHN0YXRlIHdpdGguXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVXBkYXRlZCBuYW1lIGZvciB0aGUgc3RhdGUuXG4gICAqL1xuICByZW5hbWVTdGF0ZShjdXJyZW50TmFtZSwgbmV3TmFtZSkge31cblxuICAvKipcbiAgICogRGlzY2FyZHMgYWxsIHN0YXRlcy5cbiAgICovXG4gIGRpc2NhcmRTdGF0ZXMoKSB7fVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY2xhc3MgdGhhdCBpbXBsZW1lbnRzIHtAbGluayBTdGF0ZUNvbnRhaW5lckludGVyZmFjZX0gYW5kIGV4dGVuZHNcbiAgICogYSBzcGVjaWZpZWQgYmFzZSBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtDbGFzc30gW0Jhc2VDbGFzcyA9IGNsYXNze31dIC0gVGhlIGNsYXNzIHRvIGV4dGVuZC5cbiAgICpcbiAgICogQHJldHVybiB7Q2xhc3N9IEEgY2xhc3MgdGhhdCBleHRlbmRzIGBCYXNlQ2xhc3NgIGFuZCBpbXBsZW1lbnRzIHtAbGluayBTdGF0ZUNvbnRhaW5lckludGVyZmFjZX0uXG4gICAqL1xuICBzdGF0aWMgTWl4aW4oQmFzZUNsYXNzID0gY2xhc3Mge30pIHtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1peGluIGFkZHMgZnVuY3Rpb25hbGl0eSBmb3IgbWFuaXB1bGF0aW5nIHVuaXF1ZWx5LW5hbWVkIGFuaW1hdGlvbiBzdGF0ZXMgaW5cbiAgICAgKiBhIG1hcC5cbiAgICAgKi9cbiAgICBjb25zdCBTdGF0ZUNvbnRhaW5lck1peGluID0gY2xhc3MgZXh0ZW5kcyBCYXNlQ2xhc3Mge1xuICAgICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9LCAuLi5hcmdzKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMsIC4uLmFyZ3MpO1xuXG4gICAgICAgIHRoaXMuX3N0YXRlcyA9IHRoaXMuX3N0YXRlcyAhPT0gdW5kZWZpbmVkID8gdGhpcy5fc3RhdGVzIDogbmV3IE1hcCgpO1xuICAgICAgfVxuXG4gICAgICBnZXRTdGF0ZShuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZXMuZ2V0KG5hbWUpO1xuICAgICAgfVxuXG4gICAgICBnZXRTdGF0ZU5hbWVzKCkge1xuICAgICAgICByZXR1cm4gWy4uLnRoaXMuX3N0YXRlcy5rZXlzKCldO1xuICAgICAgfVxuXG4gICAgICBhZGRTdGF0ZShzdGF0ZSkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHN0YXRlIGlzIG5vdCBhbHJlYWR5IGluIHRoaXMgY29udGFpbmVyXG4gICAgICAgIGlmIChbLi4udGhpcy5fc3RhdGVzLnZhbHVlcygpXS5pbmNsdWRlcyhzdGF0ZSkpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBgQ2Fubm90IGFkZCBhbmltYXRpb24gdG8gc3RhdGUgJHt0aGlzLm5hbWV9LiBBbmltYXRpb24gd2FzIGFscmVhZHkgYWRkZWQuYFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLm5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHN0YXRlIG5hbWUgaXMgdW5pcXVlXG4gICAgICAgIGNvbnN0IHVuaXF1ZU5hbWUgPSBVdGlscy5nZXRVbmlxdWVOYW1lKHN0YXRlLm5hbWUsIFtcbiAgICAgICAgICAuLi50aGlzLl9zdGF0ZXMua2V5cygpLFxuICAgICAgICBdKTtcblxuICAgICAgICBpZiAoc3RhdGUubmFtZSAhPT0gdW5pcXVlTmFtZSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIGBBbmltYXRpb24gbmFtZSAke3N0YXRlLm5hbWV9IGlzIG5vdCB1bmlxdWUgZm9yIHN0YXRlICR7dGhpcy5uYW1lfS4gTmV3IGFuaW1hdGlvbiB3aWxsIGJlIGFkZGVkIHdpdGggbmFtZSAke3VuaXF1ZU5hbWV9LmBcbiAgICAgICAgICApO1xuICAgICAgICAgIHN0YXRlLm5hbWUgPSB1bmlxdWVOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc3RhdGVzLnNldChzdGF0ZS5uYW1lLCBzdGF0ZSk7XG5cbiAgICAgICAgcmV0dXJuIHN0YXRlLm5hbWU7XG4gICAgICB9XG5cbiAgICAgIHJlbW92ZVN0YXRlKG5hbWUpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHN0YXRlIGlzIGluIHRoaXMgY29udGFpbmVyXG4gICAgICAgIGlmICghdGhpcy5fc3RhdGVzIHx8ICF0aGlzLl9zdGF0ZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgYERpZCBub3QgcmVtb3ZlIGFuaW1hdGlvbiAke25hbWV9IGZyb20gc3RhdGUgJHt0aGlzLm5hbWV9LiBObyBhbmltYXRpb24gZXhpc3RzIHdpdGggdGhpcyBuYW1lLmBcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3N0YXRlcy5nZXQobmFtZSkuZGlzY2FyZCgpO1xuICAgICAgICB0aGlzLl9zdGF0ZXMuZGVsZXRlKG5hbWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmVuYW1lU3RhdGUoY3VycmVudE5hbWUsIG5ld05hbWUpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBzdGF0ZSBpcyBpbiB0aGlzIGNvbnRhaW5lclxuICAgICAgICBpZiAoIXRoaXMuX3N0YXRlcyB8fCAhdGhpcy5fc3RhdGVzLmhhcyhjdXJyZW50TmFtZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQ2Fubm90IHJlbmFtZSBhbmltYXRpb24gJHtjdXJyZW50TmFtZX0gaW4gJHt0aGlzLm5hbWV9LiBObyBhbmltYXRpb24gZXhpc3RzIHdpdGggdGhpcyBuYW1lLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZXMuZ2V0KGN1cnJlbnROYW1lKTtcblxuICAgICAgICAvLyBFeGl0IGlmIHRoZSBuYW1lcyBhcmUgdGhlIHNhbWVcbiAgICAgICAgaWYgKGN1cnJlbnROYW1lID09PSBuZXdOYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnROYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBuYW1lIGlzIHVuaXF1ZVxuICAgICAgICBjb25zdCB1bmlxdWVOYW1lID0gVXRpbHMuZ2V0VW5pcXVlTmFtZShcbiAgICAgICAgICBuZXdOYW1lLFxuICAgICAgICAgIFsuLi50aGlzLl9zdGF0ZXMua2V5cygpXS5maWx0ZXIocyA9PiBzLm5hbWUgIT09IGN1cnJlbnROYW1lKVxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChuZXdOYW1lICE9PSB1bmlxdWVOYW1lKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgYEFuaW1hdGlvbiBuYW1lICR7bmV3TmFtZX0gaXMgbm90IHVuaXF1ZSBpbiBzdGF0ZSAke3RoaXMubmFtZX0uIEFuaW1hdGlvbiB3aWxsIGJlIHJlbmFtZWQgdG8gJHt1bmlxdWVOYW1lfS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgICBuZXdOYW1lID0gdW5pcXVlTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLm5hbWUgPSBuZXdOYW1lO1xuICAgICAgICB0aGlzLl9zdGF0ZXMuZGVsZXRlKGN1cnJlbnROYW1lKTtcbiAgICAgICAgdGhpcy5fc3RhdGVzLnNldChzdGF0ZS5uYW1lLCBzdGF0ZSk7XG5cbiAgICAgICAgcmV0dXJuIHN0YXRlLm5hbWU7XG4gICAgICB9XG5cbiAgICAgIGRpc2NhcmRTdGF0ZXMoKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlcy5mb3JFYWNoKHN0YXRlID0+IHtcbiAgICAgICAgICBzdGF0ZS5kaXNjYXJkKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zdGF0ZXM7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGVDb250YWluZXJNaXhpbjtcbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgU3RhdGVDb250YWluZXJJbnRlcmZhY2U7XG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxuaW1wb3J0IEFic3RyYWN0U3RhdGUgZnJvbSAnLi9BYnN0cmFjdFN0YXRlJztcbmltcG9ydCBBbmltYXRpb25QbGF5ZXJJbnRlcmZhY2UgZnJvbSAnLi4vQW5pbWF0aW9uUGxheWVySW50ZXJmYWNlJztcbmltcG9ydCBTdGF0ZUNvbnRhaW5lckludGVyZmFjZSBmcm9tICcuL1N0YXRlQ29udGFpbmVySW50ZXJmYWNlJztcblxuLyoqXG4gKiBDbGFzcyBmb3IgcGxheWluZyBhbiBvcmRlcmVkIGFycmF5IG9mIGFuaW1hdGlvbiBzdGF0ZXMgaW4gc2VxdWVuY2UuXG4gKlxuICogQGV4dGVuZHMgQWJzdHJhY3RTdGF0ZVxuICogQGltcGxlbWVudHMgQEFuaW1hdGlvblBsYXllckludGVyZmFjZVxuICovXG5jbGFzcyBRdWV1ZVN0YXRlIGV4dGVuZHMgQW5pbWF0aW9uUGxheWVySW50ZXJmYWNlLk1peGluKFxuICBTdGF0ZUNvbnRhaW5lckludGVyZmFjZS5NaXhpbihBYnN0cmFjdFN0YXRlKVxuKSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSAtIE9wdGlvbnMgZm9yIHRoZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hdXRvQWR2YW5jZT10cnVlXSAtIFdoZXRoZXIgdG8gYXV0bWF0aWNhbGx5IGFkdmFuY2VcbiAgICogdG8gdGhlIG5leHQgc3RhdGUgaW4gdGhlIHF1ZXVlIGFzIGVhY2ggc3RhdGUgY29tcGxldGVzLlxuICAgKiBAcGFyYW0ge0FycmF5LjxBYnN0cmFjdFN0YXRlPn0gW3F1ZXVlU3RhdGVzPVtdXSAtIEFycmF5IG9mIHN0YXRlcyB0byBiZSBwbGF5ZWRcbiAgICogaW4gb3JkZXIuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30sIHF1ZXVlU3RhdGVzID0gW10pIHtcbiAgICBzdXBlcihvcHRpb25zKTtcblxuICAgIHF1ZXVlU3RhdGVzLmZvckVhY2goc3RhdGUgPT4ge1xuICAgICAgdGhpcy5hZGRTdGF0ZShzdGF0ZSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9xdWV1ZSA9IHRoaXMuX3N0YXRlcy5rZXlzKCk7XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB3aGV0aGVyIHRoZSBhbmltYXRpb24gcXVldWUgaGFzIHJlYWNoZWQgdGhlIGVuZC5cbiAgICovXG4gIGdldCBkb25lKCkge1xuICAgIHJldHVybiB0aGlzLl9kb25lO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGludGVybmFsIHdlaWdodC5cbiAgICpcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgaW50ZXJuYWxXZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRTdGF0ZVxuICAgICAgPyB0aGlzLl9jdXJyZW50U3RhdGUuaW50ZXJuYWxXZWlnaHQgKiB0aGlzLl9pbnRlcm5hbFdlaWdodFxuICAgICAgOiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc3RhcnQgdGhlIHF1ZXVlIGl0ZXJhdG9yLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Jlc2V0KCkge1xuICAgIHRoaXMuX3F1ZXVlID0gdGhpcy5fc3RhdGVzLmtleXMoKTtcbiAgICBjb25zdCB7dmFsdWUsIGRvbmV9ID0gdGhpcy5fcXVldWUubmV4dCgpO1xuICAgIHRoaXMuX2RvbmUgPSBkb25lO1xuXG4gICAgcmV0dXJuIHZhbHVlIHx8IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogTXVsdGlwbGllcyB0aGUgdXNlciB3ZWlnaHQgYnkgYSBmYWN0b3IgdG8gZGV0ZXJtaW5lIHRoZSBpbnRlcm5hbCB3ZWlnaHQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmYWN0b3IgLSAwLTEgbXVsdGlwbGllciB0byBhcHBseSB0byB0aGUgdXNlciB3ZWlnaHQuXG4gICAqL1xuICB1cGRhdGVJbnRlcm5hbFdlaWdodChmYWN0b3IpIHtcbiAgICBzdXBlci51cGRhdGVJbnRlcm5hbFdlaWdodChmYWN0b3IpO1xuXG4gICAgaWYgKHRoaXMuX2N1cnJlbnRTdGF0ZSkge1xuICAgICAgdGhpcy5fY3VycmVudFN0YXRlLnVwZGF0ZUludGVybmFsV2VpZ2h0KHRoaXMuX2ludGVybmFsV2VpZ2h0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgdGhlIG5leHQgYW5pbWF0aW9uIGluIHRoZSBxdWV1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uTmV4dCAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgZWFjaCB0aW1lIGFuIGFuaW1hdGlvbiBjb21wbGV0ZXNcbiAgICogYW5kIHRoZSBxdWV1ZSBtb3ZlcyB0byB0aGUgbmV4dCBhbmltYXRpb24uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3dyYXA9ZmFsc2VdIC0gV2hldGhlciBvciBub3QgdG8gc3RhcnQgdGhlIHF1ZXVlIGZyb20gdGhlXG4gICAqIGJlZ2lubmluZyBhZ2FpbiBpZiB0aGUgZW5kIGhhcyBiZWVuIHJlYWNoZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH1cbiAgICovXG4gIG5leHQob25OZXh0LCB3cmFwID0gZmFsc2UpIHtcbiAgICAvLyBNb3ZlIHRoZSBxdWV1ZSBmb3J3YXJkXG4gICAgY29uc3Qge3ZhbHVlOiBuYW1lLCBkb25lfSA9IHRoaXMuX3F1ZXVlLm5leHQoKTtcbiAgICB0aGlzLl9kb25lID0gZG9uZTtcbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcblxuICAgIC8vIFRoZSBxdWV1ZSBoYXMgcmVhY2hlZCB0aGUgZW5kXG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIC8vIFN0YXJ0IHRoZSBxdWV1ZSBvdmVyXG4gICAgICBpZiAod3JhcCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wbGF5KFxuICAgICAgICAgIHRoaXMuX3BsYXlDYWxsYmFja3Mub25GaW5pc2gsXG4gICAgICAgICAgdGhpcy5fcGxheUNhbGxiYWNrcy5vbkVycm9yLFxuICAgICAgICAgIHRoaXMuX3BsYXlDYWxsYmFja3Mub25DYW5jZWwsXG4gICAgICAgICAgb25OZXh0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICAvLyBTdG9wIHRoZSBxdWV1ZVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX3Byb21pc2VzLmZpbmlzaC5yZXNvbHZlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9taXNlcy5maW5pc2g7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2lnbmFsIHRoZSBuZXh0IGFuaW1hdGlvbiBpcyBzdGFydGluZ1xuICAgIGlmICh0eXBlb2Ygb25OZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCBsYXN0TmFtZSA9IFsuLi50aGlzLl9zdGF0ZXMua2V5cygpXVt0aGlzLl9zdGF0ZXMuc2l6ZSAtIDFdO1xuICAgICAgY29uc3QgaXNRdWV1ZUVuZCA9IG5hbWUgPT09IGxhc3ROYW1lO1xuICAgICAgb25OZXh0KHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgY2FuQWR2YW5jZTogdGhpcy5nZXRTdGF0ZShuYW1lKS5sb29wQ291bnQgIT09IEluZmluaXR5ICYmICFpc1F1ZXVlRW5kLFxuICAgICAgICBpc1F1ZXVlRW5kLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gU3RhcnQgdGhlIG5leHQgYW5pbWF0aW9uXG4gICAgdGhpcy5wbGF5QW5pbWF0aW9uKFxuICAgICAgbmFtZSxcbiAgICAgIHRoaXMuX3RyYW5zaXRpb25UaW1lLFxuICAgICAgdGhpcy5fZWFzaW5nRm4sXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5fcGF1c2VkICYmICF0aGlzLmlzVHJhbnNpdGlvbmluZykge1xuICAgICAgICAgIHRoaXMubmV4dChvbk5leHQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdGhpcy5fcGxheUNhbGxiYWNrcy5vbkVycm9yXG4gICAgKTtcblxuICAgIHJldHVybiB0aGlzLl9wcm9taXNlcy5maW5pc2g7XG4gIH1cblxuICBwbGF5KG9uRmluaXNoLCBvbkVycm9yLCBvbkNhbmNlbCwgb25OZXh0KSB7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMuX3Jlc2V0KCk7XG4gICAgc3VwZXIucGxheShvbkZpbmlzaCwgb25FcnJvciwgb25DYW5jZWwpO1xuXG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHRoaXMuX3Byb21pc2VzLmZpbmlzaC5yZXNvbHZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNpZ25hbCB0aGUgbmV4dCBhbmltYXRpb24gaXMgc3RhcnRpbmdcbiAgICAgIGlmIChuYW1lICE9PSB0aGlzLmN1cnJlbnRBbmltYXRpb24gJiYgdHlwZW9mIG9uTmV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCBsYXN0TmFtZSA9IFsuLi50aGlzLl9zdGF0ZXMua2V5cygpXVt0aGlzLl9zdGF0ZXMuc2l6ZSAtIDFdO1xuICAgICAgICBjb25zdCBpc1F1ZXVlRW5kID0gbmFtZSA9PT0gbGFzdE5hbWU7XG4gICAgICAgIG9uTmV4dCh7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBjYW5BZHZhbmNlOiBuYW1lXG4gICAgICAgICAgICA/IHRoaXMuZ2V0U3RhdGUobmFtZSkubG9vcENvdW50ICE9PSBJbmZpbml0eSAmJiAhaXNRdWV1ZUVuZFxuICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgIGlzUXVldWVFbmQ6ICFuYW1lIHx8IGlzUXVldWVFbmQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBTdGFydCB0aGUgbmV4dCBhbmltYXRpb25cbiAgICAgIHRoaXMucGxheUFuaW1hdGlvbihcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdGhpcy5fY3VycmVudFN0YXRlID8gdGhpcy5fdHJhbnNpdGlvblRpbWUgOiAwLFxuICAgICAgICB0aGlzLl9lYXNpbmdGbixcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIGlmICghdGhpcy5fcGF1c2VkICYmICF0aGlzLmlzVHJhbnNpdGlvbmluZykge1xuICAgICAgICAgICAgdGhpcy5uZXh0KG9uTmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkVycm9yXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9wcm9taXNlcy5maW5pc2g7XG4gIH1cblxuICBwYXVzZSgpIHtcbiAgICBjb25zdCBwYXVzZWQgPSBzdXBlci5wYXVzZSgpO1xuICAgIHRoaXMucGF1c2VBbmltYXRpb24oKTtcblxuICAgIHJldHVybiBwYXVzZWQ7XG4gIH1cblxuICByZXN1bWUob25GaW5pc2gsIG9uRXJyb3IsIG9uQ2FuY2VsLCBvbk5leHQpIHtcbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGxheShvbkZpbmlzaCwgb25FcnJvciwgb25DYW5jZWwsIG9uTmV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLnJlc3VtZShvbkZpbmlzaCwgb25FcnJvciwgb25DYW5jZWwpO1xuXG4gICAgICB0aGlzLnJlc3VtZUFuaW1hdGlvbihcbiAgICAgICAgdGhpcy5fY3VycmVudFN0YXRlLm5hbWUsXG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25UaW1lLFxuICAgICAgICB0aGlzLl9lYXNpbmdGbixcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIGlmICghdGhpcy5fcGF1c2VkICYmICF0aGlzLmlzVHJhbnNpdGlvbmluZykge1xuICAgICAgICAgICAgdGhpcy5uZXh0KG9uTmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkVycm9yXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gdGhpcy5fcHJvbWlzZXMuZmluaXNoO1xuICAgIH1cbiAgfVxuXG4gIGNhbmNlbCgpIHtcbiAgICBjb25zdCBjYW5jZWxlZCA9IHN1cGVyLmNhbmNlbCgpO1xuXG4gICAgaWYgKHRoaXMuX2N1cnJlbnRTdGF0ZSkge1xuICAgICAgdGhpcy5fY3VycmVudFN0YXRlLmNhbmNlbCgpO1xuICAgIH1cblxuICAgIHJldHVybiBjYW5jZWxlZDtcbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgY29uc3Qgc3RvcHBlZCA9IHN1cGVyLnN0b3AoKTtcbiAgICB0aGlzLnN0b3BBbmltYXRpb24oKTtcbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcblxuICAgIHJldHVybiBzdG9wcGVkO1xuICB9XG5cbiAgZGlzY2FyZCgpIHtcbiAgICBzdXBlci5kaXNjYXJkKCk7XG5cbiAgICB0aGlzLmRpc2NhcmRTdGF0ZXMoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBRdWV1ZVN0YXRlO1xuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcbmltcG9ydCBEZWZlcnJlZCBmcm9tICdjb3JlL0RlZmVycmVkJztcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSAnY29yZS9NYXRoVXRpbHMnO1xuaW1wb3J0IEFic3RyYWN0U3RhdGUgZnJvbSAnLi9BYnN0cmFjdFN0YXRlJztcbmltcG9ydCBTdGF0ZUNvbnRhaW5lckludGVyZmFjZSBmcm9tICcuL1N0YXRlQ29udGFpbmVySW50ZXJmYWNlJztcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBhIHN0YXRlIHRoYXQgYmxlbmRzIGEgY29sbGVjdGlvbiBvZiB7QGxpbmsgQWJzdHJhY3RTdGF0ZX0uXG4gKlxuICogQGFic3RyYWN0XG4gKiBAaW1wbGVtZW50cyBTdGF0ZUNvbnRhaW5lckludGVyZmFjZVxuICovXG5jbGFzcyBBYnN0cmFjdEJsZW5kU3RhdGUgZXh0ZW5kcyBTdGF0ZUNvbnRhaW5lckludGVyZmFjZS5NaXhpbihBYnN0cmFjdFN0YXRlKSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSwgYmxlbmRTdGF0ZXMgPSBbXSwgLi4uYXJncykge1xuICAgIHN1cGVyKG9wdGlvbnMsIC4uLmFyZ3MpO1xuICAgIGJsZW5kU3RhdGVzLmZvckVhY2goc3RhdGUgPT4ge1xuICAgICAgdGhpcy5hZGRTdGF0ZShzdGF0ZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc3VtIG9mIGludGVybmFsIHdlaWdodHMgb2YgdGhlIHN1Yi1zdGF0ZXMuXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGludGVybmFsV2VpZ2h0KCkge1xuICAgIGxldCBibGVuZFdlaWdodHMgPSAwO1xuICAgIHRoaXMuX3N0YXRlcy5mb3JFYWNoKHN0YXRlID0+IHtcbiAgICAgIGJsZW5kV2VpZ2h0cyArPSBzdGF0ZS5pbnRlcm5hbFdlaWdodDtcbiAgICB9KTtcbiAgICByZXR1cm4gYmxlbmRXZWlnaHRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHdlaWdodCBvZiBhIHN0YXRlIGNvbnRyb2xsZWQgYnkgdGhlIGNvbnRhaW5lci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBzdGF0ZSB0byByZXR1cm4gdGhlIHdlaWdodCBmcm9tLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIFdlaWdodCBvZiB0aGUgc3RhdGUuXG4gICAqL1xuICBnZXRCbGVuZFdlaWdodChuYW1lKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBuYW1lIGlzIHZhbGlkXG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFN0YXRlKG5hbWUpO1xuICAgIGlmIChzdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgZ2V0IHdlaWdodCBvZiBzdGF0ZSAke25hbWV9IGZyb20gQmxlbmRTdGF0ZSAke3RoaXMubmFtZX0uIE5vIHN0YXRlIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZS53ZWlnaHQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgd2VpZ2h0IG9mIGEgc3RhdGUgY29udHJvbGxlZCBieSB0aGUgY29udGFpbmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIHN0YXRlIHRvIHNldCB0aGUgd2VpZ2h0IG9mLlxuICAgKiBAcGFyYW0ge251bWJlcn0gd2VpZ2h0IC0gV2VpZ2h0IHZhbHVlIHRvIHNldCBvbiB0aGUgc3RhdGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH1cbiAgICovXG4gIHNldEJsZW5kV2VpZ2h0KG5hbWUsIHdlaWdodCwgc2Vjb25kcyA9IDAsIGVhc2luZ0ZuKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBuYW1lIGlzIHZhbGlkXG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFN0YXRlKG5hbWUpO1xuXG4gICAgaWYgKHN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBzZXQgd2VpZ2h0IG9mIHN0YXRlICR7bmFtZX0gZnJvbSBCbGVuZFN0YXRlICR7dGhpcy5uYW1lfS4gTm8gc3RhdGUgZXhpc3RzIHdpdGggdGhpcyBuYW1lLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgd2VpZ2h0ID0gTWF0aFV0aWxzLmNsYW1wKHdlaWdodCk7XG4gICAgcmV0dXJuIHN0YXRlLnNldFdlaWdodCh3ZWlnaHQsIHNlY29uZHMsIGVhc2luZ0ZuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNdWx0aXBsaWVzIHRoZSB3ZWlnaHQgb2YgZWFjaCBzdWItc3RhdGUgYnkgYSBmYWN0b3IgdG8gZGV0ZXJtaW5lIHRoZSBpbnRlcm5hbCB3ZWlnaHQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmYWN0b3IgLSAwLTEgbXVsdGlwbGllciB0byBhcHBseSB0byB0aGUgdXNlciB3ZWlnaHQuXG4gICAqL1xuICB1cGRhdGVJbnRlcm5hbFdlaWdodChmYWN0b3IpIHtcbiAgICBzdXBlci51cGRhdGVJbnRlcm5hbFdlaWdodChmYWN0b3IpO1xuXG4gICAgdGhpcy5fc3RhdGVzLmZvckVhY2goc3RhdGUgPT4ge1xuICAgICAgc3RhdGUudXBkYXRlSW50ZXJuYWxXZWlnaHQodGhpcy5faW50ZXJuYWxXZWlnaHQpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhbnkgdmFsdWVzIG9mIHRoZSBzdWItc3RhdGVzIHRoYXQgbmVlZCB0byBiZSBldmFsdWF0ZWQgZXZlcnkgZnJhbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVRpbWUgLSBUaW1lIGluIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgbGFzdCB1cGRhdGUuXG4gICAqL1xuICB1cGRhdGUoZGVsdGFUaW1lKSB7XG4gICAgc3VwZXIudXBkYXRlKGRlbHRhVGltZSk7XG5cbiAgICB0aGlzLl9zdGF0ZXMuZm9yRWFjaChzdGF0ZSA9PiB7XG4gICAgICBzdGF0ZS51cGRhdGUoZGVsdGFUaW1lKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBwbGF5YmFjayBvZiB0aGUgc3ViLXN0YXRlcyBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkZpbmlzaCAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgc3RhdGUgZmluaXNoZXMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkVycm9yIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBpZiB0aGUgc3RhdGUgZW5jb3VudGVyc1xuICAgKiBhbiBlcnJvciBkdXJpbmcgcGxheWJhY2suXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkNhbmNlbCAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgaWYgcGxheWJhY2sgaXMgY2FuY2VsZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH1cbiAgICovXG4gIHBsYXkob25GaW5pc2gsIG9uRXJyb3IsIG9uQ2FuY2VsKSB7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBbc3VwZXIucGxheSgpXTtcblxuICAgIHRoaXMuX3N0YXRlcy5mb3JFYWNoKHN0YXRlID0+IHtcbiAgICAgIHByb21pc2VzLnB1c2goc3RhdGUucGxheSgpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gRGVmZXJyZWQuYWxsKHByb21pc2VzLCBvbkZpbmlzaCwgb25FcnJvciwgb25DYW5jZWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdXNlIHBsYXliYWNrIG9mIHRoZSBzdWItc3RhdGVzLiBUaGlzIHByZXZlbnRzIHBlbmRpbmcgcHJvbWlzZXMgZnJvbSBiZWluZyBleGVjdXRlZC5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBwYXVzZSgpIHtcbiAgICB0aGlzLl9zdGF0ZXMuZm9yRWFjaChzdGF0ZSA9PiB7XG4gICAgICBzdGF0ZS5wYXVzZSgpO1xuICAgIH0pO1xuICAgIHJldHVybiBzdXBlci5wYXVzZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc3VtZSBwbGF5YmFjayBvZiB0aGUgc3ViLXN0YXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uRmluaXNoIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHRoZSBzdGF0ZSBmaW5pc2hlcy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uRXJyb3IgLSBGdW5jdGlvbiB0byBleGVjdXRlIGlmIHRoZSBzdGF0ZSBlbmNvdW50ZXJzXG4gICAqIGFuIGVycm9yIGR1cmluZyBwbGF5YmFjay5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uQ2FuY2VsIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBpZiBwbGF5YmFjayBpcyBjYW5jZWxlZC5cbiAgICpcbiAgICogQHJldHVybnMge0RlZmVycmVkfVxuICAgKi9cbiAgcmVzdW1lKG9uRmluaXNoLCBvbkVycm9yLCBvbkNhbmNlbCkge1xuICAgIGNvbnN0IHByb21pc2VzID0gW3N1cGVyLnJlc3VtZSgpXTtcblxuICAgIHRoaXMuX3N0YXRlcy5mb3JFYWNoKHN0YXRlID0+IHtcbiAgICAgIHByb21pc2VzLnB1c2goc3RhdGUucmVzdW1lKCkpO1xuICAgIH0pO1xuICAgIHJldHVybiBEZWZlcnJlZC5hbGwocHJvbWlzZXMsIG9uRmluaXNoLCBvbkVycm9yLCBvbkNhbmNlbCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VsIHBsYXliYWNrIG9mIHRoZSBzdWItc3RhdGVzIGFuZCBjYW5jZWwgYW55IHBlbmRpbmcgcHJvbWlzZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgY2FuY2VsKCkge1xuICAgIHRoaXMuX3N0YXRlcy5mb3JFYWNoKHN0YXRlID0+IHtcbiAgICAgIHN0YXRlLmNhbmNlbCgpO1xuICAgIH0pO1xuICAgIHJldHVybiBzdXBlci5jYW5jZWwoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIHBsYXliYWNrIG9mIHRoZSBzdWItc3RhdGVzIGFuZCByZXNvbHZlIGFueSBwZW5kaW5nIHByb21pc2VzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0b3AoKSB7XG4gICAgdGhpcy5fc3RhdGVzLmZvckVhY2goc3RhdGUgPT4ge1xuICAgICAgc3RhdGUuc3RvcCgpO1xuICAgIH0pO1xuICAgIHJldHVybiBzdXBlci5zdG9wKCk7XG4gIH1cblxuICAvKipcbiAgICogRGlzY2FyZHMgYWxsIHN1Yi1zdGF0ZSByZXNvdXJjZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZGlzY2FyZCgpIHtcbiAgICBzdXBlci5kaXNjYXJkKCk7XG5cbiAgICB0aGlzLmRpc2NhcmRTdGF0ZXMoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBYnN0cmFjdEJsZW5kU3RhdGU7XG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxuaW1wb3J0IEFic3RyYWN0QmxlbmRTdGF0ZSBmcm9tICcuL0Fic3RyYWN0QmxlbmRTdGF0ZSc7XG5cbi8qKlxuICogQ2xhc3MgZm9yIGJsZW5kaW5nIE4gbnVtYmVyIG9mIGJsZW5kIHN0YXRlcy5cbiAqXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEJsZW5kU3RhdGVcbiAqL1xuY2xhc3MgRnJlZUJsZW5kU3RhdGUgZXh0ZW5kcyBBYnN0cmFjdEJsZW5kU3RhdGUge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gLSBPcHRpb25zIGZvciB0aGUgY29udGFpbmVyIHN0YXRlLlxuICAgKiBAcGFyYW0ge0FycmF5LjxBYnN0cmFjdFN0YXRlPn0gW2JsZW5kU3RhdGVzPVtdXSAtIEJsZW5kIHN0YXRlcyB0byBiZSBjb250cm9sbGVkIGJ5XG4gICAqIHRoaXMgY29udGFpbmVyLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9LCBibGVuZFN0YXRlcyA9IFtdKSB7XG4gICAgc3VwZXIob3B0aW9ucywgYmxlbmRTdGF0ZXMpO1xuICB9XG5cbiAgdXBkYXRlSW50ZXJuYWxXZWlnaHQoZmFjdG9yKSB7XG4gICAgc3VwZXIudXBkYXRlSW50ZXJuYWxXZWlnaHQoZmFjdG9yKTtcblxuICAgIC8vIERldGVybWluZSB0aGUgdG90YWwgYWN0aXZlIHdlaWdodCBvZiBibGVuZCBzdGF0ZXNcbiAgICBsZXQgc3VtV2VpZ2h0cyA9IDA7XG5cbiAgICB0aGlzLl9zdGF0ZXMuZm9yRWFjaChzdGF0ZSA9PiB7XG4gICAgICBzdW1XZWlnaHRzICs9IHN0YXRlLndlaWdodDtcbiAgICB9KTtcblxuICAgIC8vIEVuc3VyZSB0aGUgc3VtIG9mIGJsZW5kIHN0YXRlIGludGVybmFsIHdlaWdodHMgZG9lcyBub3QgZXhjZWVkIGNvbnRhaW5lciBpbnRlcm5hbCB3ZWlnaHRcbiAgICBmYWN0b3IgLz0gTWF0aC5tYXgoc3VtV2VpZ2h0cywgMSk7XG5cbiAgICAvLyBTdW0gb2YgYmxlbmQgc3RhdGUgaW50ZXJuYWwgd2VpZ2h0cyBzaG91bGQgbm90IGV4Y2VlZCBjb250YWluZXIgaW50ZXJuYWwgd2VpZ2h0XG4gICAgdGhpcy5fc3RhdGVzLmZvckVhY2goc3RhdGUgPT4ge1xuICAgICAgc3RhdGUudXBkYXRlSW50ZXJuYWxXZWlnaHQoZmFjdG9yICogdGhpcy5fd2VpZ2h0KTtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBGcmVlQmxlbmRTdGF0ZTtcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXG5pbXBvcnQgRGVmZXJyZWQgZnJvbSAnY29yZS9EZWZlcnJlZCc7XG5pbXBvcnQgQWJzdHJhY3RCbGVuZFN0YXRlIGZyb20gJy4vQWJzdHJhY3RCbGVuZFN0YXRlJztcbmltcG9ydCBBbmltYXRpb25VdGlscyBmcm9tICcuLi9BbmltYXRpb25VdGlscyc7XG5cbi8qKlxuICogQ2xhc3MgZm9yIGJsZW5kaW5nIE4gbnVtYmVyIG9mIGJsZW5kIHN0YXRlcyBiYXNlZCBvbiBhIHNpbmdsZVxuICogcGFyYW1ldGVyLlxuICpcbiAqIEBleHRlbmRzIEFic3RyYWN0QmxlbmRTdGF0ZVxuICovXG5jbGFzcyBCbGVuZDFkU3RhdGUgZXh0ZW5kcyBBYnN0cmFjdEJsZW5kU3RhdGUge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zIGZvciB0aGUgY29udGFpbmVyIHN0YXRlXG4gICAqIEBwYXJhbSB7QXJyYXkuPEFic3RyYWN0QmxlbmRTdGF0ZT59IFtibGVuZFN0YXRlcz1bXV0gLSBCbGVuZCBzdGF0ZXMgdG8gYmVcbiAgICogY29udHJvbGxlZCBieSB0aGlzIGNvbnRhaW5lci5cbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW2JsZW5kVGhyZXNob2xkcz1bXV0gLSBUaHJlc2hvbGQgdmFsdWVzIGZvciBhY3RpdmF0aW5nXG4gICAqIGVhY2ggYmxlbmQgc3RhdGUuXG4gICAqIEBwYXJhbSB7QXJyYXkuPGJvb2xlYW4+fSBbcGhhc2VNYXRjaGVzPVtdXSAtIEJvb2xlYW5zIGluZGljYXRpbmcgd2hldGhlciBvciBub3RcbiAgICogZWFjaCBibGVuZCBzdGF0ZSBzaG91bGQgYmUgcGhhc2UgbWF0Y2hlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIG9wdGlvbnMgPSB7fSxcbiAgICBibGVuZFN0YXRlcyA9IFtdLFxuICAgIGJsZW5kVGhyZXNob2xkcyA9IFtdLFxuICAgIHBoYXNlTWF0Y2hlcyA9IFtdXG4gICkge1xuICAgIHN1cGVyKG9wdGlvbnMsIGJsZW5kU3RhdGVzKTtcblxuICAgIHRoaXMuX2JsZW5kVmFsdWUgPSAwO1xuICAgIHRoaXMuX3Byb21pc2VzID0ge1xuICAgICAgLi4udGhpcy5fcHJvbWlzZXMsXG4gICAgICBibGVuZFZhbHVlOiBEZWZlcnJlZC5yZXNvbHZlKCksXG4gICAgfTtcblxuICAgIC8vIFZhbGlkYXRlIHRoZXJlIGFyZSBubyBkdXBsaWNhdGUgdGhyZXNob2xkc1xuICAgIGNvbnN0IG5vblplcm9EaWZmZXJlbnRTaXplID1cbiAgICAgIGJsZW5kU3RhdGVzLmxlbmd0aCAhPT0gMCAmJiBibGVuZFN0YXRlcy5sZW5ndGggIT09IGJsZW5kVGhyZXNob2xkcy5sZW5ndGg7XG4gICAgaWYgKG5vblplcm9EaWZmZXJlbnRTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgY3JlYXRlIEJsZW5kMWRTdGF0ZSB3aXRoIGJsZW5kVGhyZXNob2xkcyAke2JsZW5kVGhyZXNob2xkc30uIEJsZW5kVGhyZXNob2xkcyBjb3VudCBkb2VzIG5vdCBtYXRjaCBibGVuZFN0YXRlcyBjb3VudC5gXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnRhaW5zRHVwbGljYXRlcyA9XG4gICAgICBuZXcgU2V0KGJsZW5kVGhyZXNob2xkcykuc2l6ZSAhPT0gYmxlbmRUaHJlc2hvbGRzLmxlbmd0aDtcbiAgICBpZiAoY29udGFpbnNEdXBsaWNhdGVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgY3JlYXRlIEJsZW5kMWRTdGF0ZSB3aXRoIGJsZW5kVGhyZXNob2xkcyAke2JsZW5kVGhyZXNob2xkc30uIEJsZW5kVGhyZXNob2xkcyBjb250YWlucyBkdXBsaWNhdGUgdmFsdWVzYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSB0aHJlc2hvbGRzIG1hcFxuICAgIHRoaXMuX3RocmVzaG9sZHMgPSBbXTtcbiAgICBbLi4udGhpcy5fc3RhdGVzLnZhbHVlcygpXS5mb3JFYWNoKChzdGF0ZSwgaW5kZXgpID0+IHtcbiAgICAgIHRoaXMuX3RocmVzaG9sZHMucHVzaCh7XG4gICAgICAgIHZhbHVlOiBibGVuZFRocmVzaG9sZHNbaW5kZXhdLFxuICAgICAgICBuYW1lOiBzdGF0ZS5uYW1lLFxuICAgICAgICBwaGFzZU1hdGNoOiBwaGFzZU1hdGNoZXNbaW5kZXhdIHx8IGZhbHNlLFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9zb3J0VGhyZXNob2xkcygpO1xuICAgIHRoaXMuX2ZvcmNlTm9UaHJlc2hvbGREdXBlcyA9IHRydWU7XG5cbiAgICB0aGlzLl9waGFzZUxlYWRTdGF0ZSA9IG51bGw7XG5cbiAgICB0aGlzLl91cGRhdGVCbGVuZFdlaWdodHMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuZCBzZXRzIHRoZSBibGVuZCBwYXJhbWV0ZXIgdmFsdWUuXG4gICAqL1xuICBnZXQgYmxlbmRWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmxlbmRWYWx1ZTtcbiAgfVxuXG4gIHNldCBibGVuZFZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy5fYmxlbmRWYWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgd2hldGhlciBvciBub3QgdGhlIGJsZW5kIHZhbHVlIGlzIGN1cnJlbnRseSBiZWluZyBhbmltYXRlZC5cbiAgICovXG4gIGdldCBibGVuZFZhbHVlUGVuZGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZXMuYmxlbmRWYWx1ZSAmJiB0aGlzLl9wcm9taXNlcy5ibGVuZFZhbHVlLnBlbmRpbmc7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgdXNlciBkZWZpbmVkIHdlaWdodCBvdmVyIHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVsbH0gbmFtZSAtIFVudXNlZCBwYXJhbWV0ZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3ZWlnaHQgLSBUaGUgdGFyZ2V0IHdlaWdodCB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzZWNvbmRzPTBdIC0gVGhlIGFtb3VudCBvZiB0aW1lIGl0IHdpbGwgdGFrZSB0byByZWFjaCB0aGVcbiAgICogdGFyZ2V0IHdlaWdodC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGVhc2luZ0ZuIC0gVGhlIGVhc2luZyBmdW5jdGlvbiB0byB1c2UgZm9yIGludGVycG9sYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH1cbiAgICovXG4gIHNldEJsZW5kV2VpZ2h0KG5hbWUsIHZhbHVlLCBzZWNvbmRzID0gMCwgZWFzaW5nRm4pIHtcbiAgICB0aGlzLl9wcm9taXNlcy5ibGVuZFZhbHVlLmNhbmNlbCgpO1xuXG4gICAgdGhpcy5fcHJvbWlzZXMuYmxlbmRWYWx1ZSA9IEFuaW1hdGlvblV0aWxzLmludGVycG9sYXRlUHJvcGVydHkoXG4gICAgICB0aGlzLFxuICAgICAgJ2JsZW5kVmFsdWUnLFxuICAgICAgdmFsdWUsXG4gICAgICB7XG4gICAgICAgIHNlY29uZHMsXG4gICAgICAgIGVhc2luZ0ZuLFxuICAgICAgICBvblByb2dyZXNzOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlQmxlbmRXZWlnaHRzKCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRmluaXNoOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlQmxlbmRXZWlnaHRzKCk7XG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgKTtcblxuICAgIHJldHVybiB0aGlzLl9wcm9taXNlcy5ibGVuZFZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHVzZXIgZGVmaW5lZCB3ZWlnaHQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBnZXRCbGVuZFdlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5ibGVuZFZhbHVlO1xuICB9XG5cbiAgYWRkU3RhdGUoc3RhdGUsIHRocmVzaG9sZFZhbHVlID0gMCwgcGhhc2VNYXRjaCA9IGZhbHNlKSB7XG4gICAgdGhpcy5fdGhyZXNob2xkcyA9IHRoaXMuX3RocmVzaG9sZHMgfHwgW107XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlcmUgaXMgbm90IGFscmVhZHkgYSBzdGF0ZSB3aXRoIHRoaXMgdGhyZXNob2xkXG4gICAgY29uc3Qgc2FtZVZhbHVlID0gdGhpcy5fdGhyZXNob2xkcy5maW5kKFxuICAgICAgdGhyZXNob2xkID0+IHRocmVzaG9sZC52YWx1ZSA9PT0gdGhyZXNob2xkVmFsdWVcbiAgICApO1xuICAgIGlmICh0aGlzLl9mb3JjZU5vVGhyZXNob2xkRHVwZXMgJiYgc2FtZVZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBzZXQgYmxlbmQgdGhyZXNob2xkIG9mICR7dGhyZXNob2xkVmFsdWV9IGZvciBzdGF0ZSAke3N0YXRlLm5hbWV9IG9uICR7dGhpcy5uYW1lfS4gQSBzdGF0ZSBhbHJlYWR5IGV4aXN0cyB3aXRoIHRoYXQgdGhyZXNob2xkLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgc3VwZXIuYWRkU3RhdGUoc3RhdGUpO1xuICAgIHRoaXMuX3RocmVzaG9sZHMucHVzaCh7XG4gICAgICB2YWx1ZTogdGhyZXNob2xkVmFsdWUsXG4gICAgICBuYW1lOiBzdGF0ZS5uYW1lLFxuICAgICAgcGhhc2VNYXRjaDogcGhhc2VNYXRjaCB8fCBmYWxzZSxcbiAgICB9KTtcblxuICAgIHRoaXMuX3NvcnRUaHJlc2hvbGRzKCk7XG5cbiAgICByZXR1cm4gc3RhdGUubmFtZTtcbiAgfVxuXG4gIHJlbW92ZVN0YXRlKG5hbWUpIHtcbiAgICBjb25zdCByZW1vdmVkID0gc3VwZXIucmVtb3ZlU3RhdGUobmFtZSk7XG5cbiAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl90aHJlc2hvbGRzLmZpbmRJbmRleChcbiAgICAgICAgdGhyZXNob2xkID0+IHRocmVzaG9sZC5uYW1lID09PSBuYW1lXG4gICAgICApO1xuICAgICAgdGhpcy5fdGhyZXNob2xkcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cblxuICAgIHJldHVybiByZW1vdmVkO1xuICB9XG5cbiAgcmVuYW1lU3RhdGUoY3VycmVudE5hbWUsIG5ld05hbWUpIHtcbiAgICBuZXdOYW1lID0gc3VwZXIucmVuYW1lU3RhdGUoY3VycmVudE5hbWUsIG5ld05hbWUpO1xuXG4gICAgY29uc3QgdGhyZXNob2xkID0gdGhpcy5fdGhyZXNob2xkcy5maW5kKFxuICAgICAgdGhyZXNob2xkID0+IHRocmVzaG9sZC5uYW1lID09PSBjdXJyZW50TmFtZVxuICAgICk7XG4gICAgdGhyZXNob2xkLm5hbWUgPSBuZXdOYW1lO1xuXG4gICAgcmV0dXJuIG5ld05hbWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdGhyZXNob2xkIHZhbHVlIG9mIGEgYmxlbmQgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIGJsZW5kIHRvIGdldCB0aGUgdGhyZXNob2xkIG9mLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaHJlaG9sZCB2YWx1ZS5cbiAgICovXG4gIGdldEJsZW5kVGhyZXNob2xkKG5hbWUpIHtcbiAgICBjb25zdCB0aHJlc2hvbGQgPSB0aGlzLl90aHJlc2hvbGRzLmZpbmQoXG4gICAgICB0aHJlc2hvbGQgPT4gdGhyZXNob2xkLm5hbWUgPT09IG5hbWVcbiAgICApO1xuXG4gICAgaWYgKHRocmVzaG9sZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgZ2V0IGJsZW5kIHRocmVzaG9sZCBvZiBzdGF0ZSAke25hbWV9IG9uICR7dGhpcy5uYW1lfS4gTm8gc3RhdGUgZXhpc3RzIHdpdGggdGhhdCBuYW1lLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRocmVzaG9sZC52YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0aHJlc2hvbGQgdmFsdWUgb2YgYSBibGVuZCB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgYmxlbmQgdG8gc2V0IHRoZSB0aHJlc2hvbGQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFZhbHVlIG9mIHRoZSB0aHJlc2hvbGQgdG8gc2V0LlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBTZXQgdGhyZXNob2xkIHZhbHVlLlxuICAgKi9cbiAgc2V0QmxlbmRUaHJlc2hvbGQobmFtZSwgdmFsdWUpIHtcbiAgICAvLyBNYWtlIHN1cmUgdGhlcmUgaXMgbm90IGFscmVhZHkgYSBzdGF0ZSB3aXRoIHRoaXMgdGhyZXNob2xkXG4gICAgY29uc3Qgc2FtZVZhbHVlID0gdGhpcy5fdGhyZXNob2xkcy5maW5kKFxuICAgICAgdGhyZXNob2xkID0+IHRocmVzaG9sZC52YWx1ZSA9PT0gdmFsdWVcbiAgICApO1xuICAgIGlmIChzYW1lVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IHNldCBibGVuZCB0aHJlc2hvbGQgb2YgJHt2YWx1ZX0gZm9yIHN0YXRlICR7bmFtZX0gb24gJHt0aGlzLm5hbWV9LiBBIHN0YXRlIGFscmVhZHkgZXhpc3RzIHdpdGggdGhhdCB0aHJlc2hvbGQuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCB0aHJlc2hvbGQgPSB0aGlzLl90aHJlc2hvbGRzLmZpbmQoXG4gICAgICB0aHJlc2hvbGQgPT4gdGhyZXNob2xkLm5hbWUgPT09IG5hbWVcbiAgICApO1xuXG4gICAgaWYgKHRocmVzaG9sZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3Qgc2V0IGJsZW5kIHRocmVzaG9sZCBvZiBzdGF0ZSAke25hbWV9IG9uICR7dGhpcy5uYW1lfS4gTm8gc3RhdGUgZXhpc3RzIHdpdGggdGhhdCBuYW1lLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhyZXNob2xkLnZhbHVlID0gdmFsdWU7XG5cbiAgICB0aGlzLl9zb3J0VGhyZXNob2xkcygpO1xuXG4gICAgcmV0dXJuIHRocmVzaG9sZC52YWx1ZTtcbiAgfVxuXG4gIHVwZGF0ZUludGVybmFsV2VpZ2h0KGZhY3Rvcikge1xuICAgIHN1cGVyLnVwZGF0ZUludGVybmFsV2VpZ2h0KGZhY3Rvcik7XG5cbiAgICBpZiAodGhpcy5fcGhhc2VMZWFkU3RhdGUpIHtcbiAgICAgIHRoaXMuX3N0YXRlcy5mb3JFYWNoKHN0YXRlID0+IHtcbiAgICAgICAgaWYgKHN0YXRlLndlaWdodCAhPT0gMCkge1xuICAgICAgICAgIHN0YXRlLm5vcm1hbGl6ZWRUaW1lID0gdGhpcy5fcGhhc2VMZWFkU3RhdGUubm9ybWFsaXplZFRpbWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBibGVuZCB3ZWlnaHRzIGJhc2VkIG9uIHRoZWlyIGNvcnJlc3BvbmRpbmcgdGhyZXNob2xkIHZhbHVlc1xuICAgKiBhbmQgdGhlIGN1cnJlbnQgYmxlbmRWYWx1ZS4gQWRkaXRpb25hbGx5LCBzZXRzIGEgbGVhZCBwaGFzZSBzdGF0ZSBpZiB0aGVcbiAgICogY29uZGl0aW9ucyBmb3IgcGhhc2UtbWF0Y2hpbmcgaGF2ZSBiZWVuIHNhdGlzZmllZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVCbGVuZFdlaWdodHMoKSB7XG4gICAgaWYgKHRoaXMuX3RocmVzaG9sZHMubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICBpZiAodGhpcy5fdGhyZXNob2xkcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGVzLmdldCh0aGlzLl90aHJlc2hvbGRzWzBdLm5hbWUpO1xuICAgICAgc3RhdGUuc2V0V2VpZ2h0KDEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxseSBzZXQgYWxsIHN1Yi1zdGF0ZSB3ZWlnaHRzIHRvIHplcm9cbiAgICB0aGlzLl9zdGF0ZXMuZm9yRWFjaChzdGF0ZSA9PiB7XG4gICAgICBzdGF0ZS5zZXRXZWlnaHQoMCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9waGFzZUxlYWRTdGF0ZSA9IG51bGw7XG5cbiAgICAvLyBGaW5kIHRoZSBmaXJzdCB0aHJlc2hvbGQgdGhhdCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHBhcmFtZXRlciB2YWx1ZVxuICAgIGxldCB0YXJnZXRJbmRleCA9IHRoaXMuX3RocmVzaG9sZHMuZmluZEluZGV4KHRocmVzaG9sZCA9PiB7XG4gICAgICByZXR1cm4gdGhyZXNob2xkLnZhbHVlID49IHRoaXMuX2JsZW5kVmFsdWU7XG4gICAgfSk7XG5cbiAgICBpZiAodGFyZ2V0SW5kZXggPT09IDAgfHwgdGFyZ2V0SW5kZXggPT09IC0xKSB7XG4gICAgICAvLyBHaXZlIG9uZSBzdGF0ZSBmdWxsIGluZmx1ZW5jZVxuICAgICAgdGFyZ2V0SW5kZXggPSB0YXJnZXRJbmRleCA9PT0gLTEgPyB0aGlzLl90aHJlc2hvbGRzLmxlbmd0aCAtIDEgOiAwO1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZXMuZ2V0KHRoaXMuX3RocmVzaG9sZHNbdGFyZ2V0SW5kZXhdLm5hbWUpO1xuICAgICAgc3RhdGUuc2V0V2VpZ2h0KDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMaW5lYXIgaW50ZXJwb2xhdGUgaW5mbHVlbmNlIGJldHdlZW4gdHdvIHN0YXRlc1xuICAgICAgY29uc3QgdGhyZXNob2xkQSA9IHRoaXMuX3RocmVzaG9sZHNbdGFyZ2V0SW5kZXggLSAxXTtcbiAgICAgIGNvbnN0IHRocmVzaG9sZEIgPSB0aGlzLl90aHJlc2hvbGRzW3RhcmdldEluZGV4XTtcblxuICAgICAgY29uc3QgZmFjdG9yQiA9XG4gICAgICAgICh0aGlzLmJsZW5kVmFsdWUgLSB0aHJlc2hvbGRBLnZhbHVlKSAvXG4gICAgICAgICh0aHJlc2hvbGRCLnZhbHVlIC0gdGhyZXNob2xkQS52YWx1ZSk7XG4gICAgICBjb25zdCBmYWN0b3JBID0gMSAtIGZhY3RvckI7XG5cbiAgICAgIGNvbnN0IHN0YXRlQSA9IHRoaXMuX3N0YXRlcy5nZXQodGhyZXNob2xkQS5uYW1lKTtcbiAgICAgIGNvbnN0IHN0YXRlQiA9IHRoaXMuX3N0YXRlcy5nZXQodGhyZXNob2xkQi5uYW1lKTtcblxuICAgICAgc3RhdGVBLnNldFdlaWdodChmYWN0b3JBKTtcbiAgICAgIHN0YXRlQi5zZXRXZWlnaHQoZmFjdG9yQik7XG5cbiAgICAgIC8vIFNldCBwaGFzZS1tYXRjaGluZyBpZiBuZWVkZWRcbiAgICAgIGlmICh0aHJlc2hvbGRBLnBoYXNlTWF0Y2ggJiYgdGhyZXNob2xkQi5waGFzZU1hdGNoKSB7XG4gICAgICAgIHRoaXMuX3BoYXNlTGVhZFN0YXRlID0gZmFjdG9yQSA+IGZhY3RvckIgPyBzdGF0ZUEgOiBzdGF0ZUI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNvcnRzIHRoZSB0aHJlc2hvbGRzIGZyb20gbG93IHRvIGhpZ2ggYmFzZWQgb24gdmFsdWUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc29ydFRocmVzaG9sZHMoKSB7XG4gICAgdGhpcy5fdGhyZXNob2xkcy5zb3J0KChhLCBiKSA9PiBhLnZhbHVlIC0gYi52YWx1ZSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmxlbmQxZFN0YXRlO1xuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVyc2NvcmUtZGFuZ2xlICovXG5pbXBvcnQgRGVmZXJyZWQgZnJvbSAnY29yZS9EZWZlcnJlZCc7XG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gJ2NvcmUvTWF0aFV0aWxzJztcbmltcG9ydCBBYnN0cmFjdEJsZW5kU3RhdGUgZnJvbSAnLi9BYnN0cmFjdEJsZW5kU3RhdGUnO1xuaW1wb3J0IEFuaW1hdGlvblV0aWxzIGZyb20gJy4uL0FuaW1hdGlvblV0aWxzJztcblxuLyoqXG4gKiBDbGFzcyBmb3IgYmxlbmRpbmcgTiBudW1iZXIgb2YgYmxlbmQgc3RhdGVzIGJhc2VkIG9uIHR3b1xuICogcGFyYW10ZXJzLlxuICpcbiAqIEBleHRlbmRzIEFic3RyYWN0QmxlbmRTdGF0ZVxuICovXG5jbGFzcyBCbGVuZDJkU3RhdGUgZXh0ZW5kcyBBYnN0cmFjdEJsZW5kU3RhdGUge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zIGZvciB0aGUgY29udGFpbmVyIHN0YXRlXG4gICAqIEBwYXJhbSB7QXJyYXkuPEFic3RyYWN0QmxlbmRTdGF0ZT59IFtibGVuZFN0YXRlcz1bXV0gLSBCbGVuZCBzdGF0ZXMgdG8gYmVcbiAgICogY29udHJvbGxlZCBieSB0aGlzIGNvbnRhaW5lci5cbiAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBbYmxlbmRUaHJlc2hvbGRzPVtdXSAtIFRocmVzaG9sZCB2YWx1ZXMgZm9yIGFjdGl2YXRpbmdcbiAgICogZWFjaCBibGVuZCBzdGF0ZS5cbiAgICogQHBhcmFtIHtBcnJheS48Ym9vbGVhbj59IFtwaGFzZU1hdGNoZXM9W11dIC0gQm9vbGVhbnMgaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdFxuICAgKiBlYWNoIGJsZW5kIHN0YXRlIHNob3VsZCBiZSBwaGFzZSBtYXRjaGVkLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgb3B0aW9ucyA9IHt9LFxuICAgIGJsZW5kU3RhdGVzID0gW10sXG4gICAgYmxlbmRUaHJlc2hvbGRzID0gW10sXG4gICAgcGhhc2VNYXRjaGVzID0gW11cbiAgKSB7XG4gICAgc3VwZXIob3B0aW9ucywgYmxlbmRTdGF0ZXMpO1xuXG4gICAgaWYgKGJsZW5kU3RhdGVzLmxlbmd0aCAhPT0gYmxlbmRUaHJlc2hvbGRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGNyZWF0ZSBCbGVuZDJkU3RhdGUgd2l0aCBibGVuZFN0YXRlcyAke2JsZW5kU3RhdGVzfSBhbmQgYmxlbmRUaHJlc2hvbGRzICR7YmxlbmRUaHJlc2hvbGRzfS4gQ291bnQgb2YgYmxlbmRTdGF0ZXMgbXVzdCBtYXRjaCBjb3VudCBvZiBibGVuZFRocmVzaG9sZHMuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBibGVuZFRocmVzaG9sZHNcbiAgICAgIC5zbGljZSgwLCBibGVuZFRocmVzaG9sZHMubGVuZ3RoIC0gMSlcbiAgICAgIC5mb3JFYWNoKCh0aHJlc2hvbGQsIGluZGV4KSA9PiB7XG4gICAgICAgIGJsZW5kVGhyZXNob2xkcy5zbGljZShpbmRleCArIDEpLmZvckVhY2gob3RoZXJUaHJlc2hvbGQgPT4ge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHRocmVzaG9sZFswXSA9PT0gb3RoZXJUaHJlc2hvbGRbMF0gJiZcbiAgICAgICAgICAgIHRocmVzaG9sZFsxXSA9PT0gb3RoZXJUaHJlc2hvbGRbMV1cbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYENhbm5vdCBjcmVhdGUgQmxlbmQyZFN0YXRlIHdpdGggYmxlbmRUaHJlc2hvbGRzICR7YmxlbmRUaHJlc2hvbGRzfS4gTm8gZHVwbGljYXRlIHZhbHVlcyBhbGxvd2VkIGluIGJsZW5kVGhyZXNob2xkcy5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgIHRoaXMuX2JsZW5kVmFsdWVYID0gMDtcbiAgICB0aGlzLl9ibGVuZFZhbHVlWSA9IDA7XG5cbiAgICB0aGlzLl9wcm9taXNlcyA9IHtcbiAgICAgIC4uLnRoaXMuX3Byb21pc2VzLFxuICAgICAgYmxlbmRWYWx1ZVg6IERlZmVycmVkLnJlc29sdmUoKSxcbiAgICAgIGJsZW5kVmFsdWVZOiBEZWZlcnJlZC5yZXNvbHZlKCksXG4gICAgfTtcblxuICAgIHRoaXMuX3RocmVzaG9sZHMgPSBbXTtcbiAgICBbLi4udGhpcy5fc3RhdGVzLnZhbHVlcygpXS5mb3JFYWNoKChzdGF0ZSwgaW5kZXgpID0+IHtcbiAgICAgIHRoaXMuX3RocmVzaG9sZHMucHVzaCh7XG4gICAgICAgIG5hbWU6IHN0YXRlLm5hbWUsXG4gICAgICAgIHBoYXNlTWF0Y2g6IHBoYXNlTWF0Y2hlc1tpbmRleF0gfHwgZmFsc2UsXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3ZlcnRpY2VzID0gYmxlbmRUaHJlc2hvbGRzO1xuXG4gICAgaWYgKHRoaXMuX3ZlcnRpY2VzLmxlbmd0aCA+PSAzKSB7XG4gICAgICB0aGlzLl90cmlhbmdsZXMgPSBNYXRoVXRpbHMuZ2V0RGVsYXVuYXlUcmlhbmd1bGF0aW9uKHRoaXMuX3ZlcnRpY2VzKTtcbiAgICB9XG5cbiAgICB0aGlzLl9waGFzZUxlYWRTdGF0ZSA9IG51bGw7XG5cbiAgICB0aGlzLl91cGRhdGVCbGVuZFdlaWdodHMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB1c2VyIGRlZmluZWQgd2VpZ2h0IG92ZXIgdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIGJsZW5kIHdlaWdodCB0byB1cGRhdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3ZWlnaHQgLSBUYXJnZXQgd2VpZ2h0IHZhbHVlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NlY29uZHM9MF0gLSBUaGUgYW1vdW50IG9mIHRpbWUgaXQgd2lsbCB0YWtlIHRvIHJlYWNoIHRoZVxuICAgKiB0YXJnZXQgdmFsdWUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBlYXNpbmdGbiAtIFRoZSBlYXNpbmcgZnVuY3Rpb24gdG8gdXNlIGZvciBpbnRlcnBvbGF0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9XG4gICAqL1xuICBzZXRCbGVuZFdlaWdodChuYW1lLCB2YWx1ZSwgc2Vjb25kcyA9IDAsIGVhc2luZ0ZuKSB7XG4gICAgY29uc3QgcHJvcGVydHkgPSBgYmxlbmRWYWx1ZSR7bmFtZS50b1VwcGVyQ2FzZSgpfWA7XG4gICAgaWYgKHByb3BlcnR5ICE9PSAnYmxlbmRWYWx1ZVgnICYmIHByb3BlcnR5ICE9PSAnYmxlbmRWYWx1ZVknKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3Qgc2V0IGJsZW5kIHdlaWdodCBmb3IgJHtuYW1lfSBvbiAke3RoaXMubmFtZX0uIEJsZW5kMmRTdGF0ZSBvbmx5IGFjY2VwdHMgJ1gnIG9yICdZJyBmb3Igc2V0QmxlbmRXZWlnaHRgXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuX3Byb21pc2VzW3Byb3BlcnR5XS5jYW5jZWwoKTtcblxuICAgIHRoaXMuX3Byb21pc2VzW3Byb3BlcnR5XSA9IEFuaW1hdGlvblV0aWxzLmludGVycG9sYXRlUHJvcGVydHkoXG4gICAgICB0aGlzLFxuICAgICAgcHJvcGVydHksXG4gICAgICB2YWx1ZSxcbiAgICAgIHtcbiAgICAgICAgc2Vjb25kcyxcbiAgICAgICAgZWFzaW5nRm4sXG4gICAgICAgIG9uUHJvZ3Jlc3M6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLl91cGRhdGVCbGVuZFdlaWdodHMoKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25GaW5pc2g6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLl91cGRhdGVCbGVuZFdlaWdodHMoKTtcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VzW3Byb3BlcnR5XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB1c2VyIGRlZmluZWQgd2VpZ2h0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgYmxlbmQgd2VpZ2h0LlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0QmxlbmRXZWlnaHQobmFtZSkge1xuICAgIGNvbnN0IHByb3BlcnR5ID0gbmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgIGlmIChwcm9wZXJ0eSAhPT0gJ1gnICYmIHByb3BlcnR5ICE9PSAnWScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBnZXQgYmxlbmQgd2VpZ2h0IGZvciAke25hbWV9IG9uICR7dGhpcy5uYW1lfS4gQmxlbmQyZFN0YXRlIG9ubHkgYWNjZXB0cyAnWCcgb3IgJ1knIGZvciBnZXRCbGVuZFdlaWdodGBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3BlcnR5ID09PSAnWCcgPyB0aGlzLl9ibGVuZFZhbHVlWCA6IHRoaXMuX2JsZW5kVmFsdWVZO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW5kIHNldHMgdGhlIHggYmxlbmQgd2VpZ2h0LlxuICAgKi9cbiAgZ2V0IGJsZW5kVmFsdWVYKCkge1xuICAgIHJldHVybiB0aGlzLl9ibGVuZFZhbHVlWDtcbiAgfVxuXG4gIHNldCBibGVuZFZhbHVlWCh2YWx1ZSkge1xuICAgIHRoaXMuX2JsZW5kVmFsdWVYID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbmQgc2V0cyB0aGUgeSBibGVuZCB3ZWlnaHQuXG4gICAqL1xuICBnZXQgYmxlbmRWYWx1ZVkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JsZW5kVmFsdWVZO1xuICB9XG5cbiAgc2V0IGJsZW5kVmFsdWVZKHZhbHVlKSB7XG4gICAgdGhpcy5fYmxlbmRWYWx1ZVkgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHdoZXRoZXIgb3Igbm90IHRoZSB4IGJsZW5kIHZhbHVlIGlzIGN1cnJlbnRseSBiZWluZyBhbmltYXRlZC5cbiAgICovXG4gIGdldCBibGVuZFZhbHVlWFBlbmRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VzLmJsZW5kVmFsdWVYICYmIHRoaXMuX3Byb21pc2VzLmJsZW5kVmFsdWVYLnBlbmRpbmc7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgeSBibGVuZCB2YWx1ZSBpcyBjdXJyZW50bHkgYmVpbmcgYW5pbWF0ZWQuXG4gICAqL1xuICBnZXQgYmxlbmRWYWx1ZVlQZW5kaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm9taXNlcy5ibGVuZFZhbHVlWSAmJiB0aGlzLl9wcm9taXNlcy5ibGVuZFZhbHVlWS5wZW5kaW5nO1xuICB9XG5cbiAgdXBkYXRlSW50ZXJuYWxXZWlnaHQoZmFjdG9yKSB7XG4gICAgc3VwZXIudXBkYXRlSW50ZXJuYWxXZWlnaHQoZmFjdG9yKTtcblxuICAgIGlmICh0aGlzLl9waGFzZUxlYWRTdGF0ZSkge1xuICAgICAgWy4uLnRoaXMuX3N0YXRlcy52YWx1ZXMoKV0uZm9yRWFjaCgoc3RhdGUsIGluZGV4KSA9PiB7XG4gICAgICAgIGlmIChzdGF0ZS53ZWlnaHQgIT09IDAgJiYgdGhpcy5fdGhyZXNob2xkc1tpbmRleF0ucGhhc2VNYXRjaCkge1xuICAgICAgICAgIHN0YXRlLm5vcm1hbGl6ZWRUaW1lID0gdGhpcy5fcGhhc2VMZWFkU3RhdGUubm9ybWFsaXplZFRpbWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBibGVuZCB3ZWlnaHRzIGJhc2VkIG9uIHRoZWlyIGNvcnJlc3BvbmRpbmcgdGhyZXNob2xkIHZhbHVlc1xuICAgKiBhbmQgdGhlIGN1cnJlbnQgW3gseV0gYmxlbmRWYWx1ZS4gQWRkaXRpb25hbGx5LCBzZXRzIGEgbGVhZCBwaGFzZSBzdGF0ZSBpZiB0aGVcbiAgICogY29uZGl0aW9ucyBmb3IgcGhhc2UtbWF0Y2hpbmcgaGF2ZSBiZWVuIHNhdGlzZmllZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVCbGVuZFdlaWdodHMoKSB7XG4gICAgaWYgKCF0aGlzLl92ZXJ0aWNlcyB8fCB0aGlzLl92ZXJ0aWNlcy5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgIGlmICh0aGlzLl92ZXJ0aWNlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIFsuLi50aGlzLl9zdGF0ZXMudmFsdWVzKCldWzBdLndlaWdodCA9IDE7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGx5IHNldCBhbGwgc3ViLXN0YXRlIHdlaWdodHMgdG8gemVyb1xuICAgIHRoaXMuX3N0YXRlcy5mb3JFYWNoKHN0YXRlID0+IHtcbiAgICAgIHN0YXRlLnNldFdlaWdodCgwKTtcbiAgICB9KTtcbiAgICB0aGlzLl9waGFzZUxlYWRTdGF0ZSA9IG51bGw7XG5cbiAgICBjb25zdCBwID0gW3RoaXMuX2JsZW5kVmFsdWVYLCB0aGlzLl9ibGVuZFZhbHVlWV07XG5cbiAgICBpZiAodGhpcy5fdmVydGljZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICB0aGlzLl9zZXRJbmZsdWVuY2VDbG9zZXN0UG9pbnRPbkxpbmUocCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRyaWFuZ2xlID0gdGhpcy5fdHJpYW5nbGVzLmZpbmQodHJpYW5nbGUgPT4ge1xuICAgICAgICByZXR1cm4gTWF0aFV0aWxzLmlzUG9pbnRJblRyaWFuZ2xlKFxuICAgICAgICAgIHRoaXMuX3ZlcnRpY2VzW3RyaWFuZ2xlWzBdXSxcbiAgICAgICAgICB0aGlzLl92ZXJ0aWNlc1t0cmlhbmdsZVsxXV0sXG4gICAgICAgICAgdGhpcy5fdmVydGljZXNbdHJpYW5nbGVbMl1dLFxuICAgICAgICAgIHBcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHJpYW5nbGUpIHtcbiAgICAgICAgdGhpcy5fc2V0SW5mbHVlbmNlVHJpYW5nbGUodHJpYW5nbGUsIHApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2V0SW5mbHVlbmNlQ2xvc2VzdFBvaW50SW5UcmlhbmdsZXMocCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYmxlbmQgd2VpZ2h0cyBmb3Igc3RhdGVzIGNvcnJlc3BvbmRpbmcgdG8gYVxuICAgKiB0cmlhbmdsZSBvZiB0aHJlc2hvbGRzIGFuZCBhIGdpdmVuIFt4LHldIGJsZW5kVmFsdWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IHRyaWFuZ2xlIC0gU2V0IG9mIHRyaWFuZ2x1YXRlZCBpbmRpY2VzXG4gICAqIHRoYXQgY29ycmVzcG9uZCB0byBibGVuZCB0aHJlc2hvbGRzLlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBwIC0gR2l2ZW4gW3gseV0gYmxlbmRWYWx1ZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRJbmZsdWVuY2VUcmlhbmdsZSh0cmlhbmdsZSwgcCkge1xuICAgIGNvbnN0IGFyZWFBID0gTWF0aFV0aWxzLnRyaWFuZ2xlQXJlYShcbiAgICAgIHRoaXMuX3ZlcnRpY2VzW3RyaWFuZ2xlWzFdXSxcbiAgICAgIHRoaXMuX3ZlcnRpY2VzW3RyaWFuZ2xlWzJdXSxcbiAgICAgIHBcbiAgICApO1xuXG4gICAgY29uc3QgYXJlYUIgPSBNYXRoVXRpbHMudHJpYW5nbGVBcmVhKFxuICAgICAgdGhpcy5fdmVydGljZXNbdHJpYW5nbGVbMF1dLFxuICAgICAgdGhpcy5fdmVydGljZXNbdHJpYW5nbGVbMl1dLFxuICAgICAgcFxuICAgICk7XG5cbiAgICBjb25zdCBhcmVhQyA9IE1hdGhVdGlscy50cmlhbmdsZUFyZWEoXG4gICAgICB0aGlzLl92ZXJ0aWNlc1t0cmlhbmdsZVswXV0sXG4gICAgICB0aGlzLl92ZXJ0aWNlc1t0cmlhbmdsZVsxXV0sXG4gICAgICBwXG4gICAgKTtcblxuICAgIGNvbnN0IHRvdGFsQXJlYSA9IGFyZWFBICsgYXJlYUIgKyBhcmVhQztcblxuICAgIGNvbnN0IHdlaWdodEEgPSBhcmVhQSAvIHRvdGFsQXJlYTtcbiAgICBjb25zdCB3ZWlnaHRCID0gYXJlYUIgLyB0b3RhbEFyZWE7XG4gICAgY29uc3Qgd2VpZ2h0QyA9IGFyZWFDIC8gdG90YWxBcmVhO1xuXG4gICAgY29uc3QgdGhyZXNob2xkQSA9IHRoaXMuX3RocmVzaG9sZHNbdHJpYW5nbGVbMF1dO1xuICAgIGNvbnN0IHRocmVzaG9sZEIgPSB0aGlzLl90aHJlc2hvbGRzW3RyaWFuZ2xlWzFdXTtcbiAgICBjb25zdCB0aHJlc2hvbGRDID0gdGhpcy5fdGhyZXNob2xkc1t0cmlhbmdsZVsyXV07XG5cbiAgICBjb25zdCBzdGF0ZUEgPSB0aGlzLl9zdGF0ZXMuZ2V0KHRocmVzaG9sZEEubmFtZSk7XG4gICAgY29uc3Qgc3RhdGVCID0gdGhpcy5fc3RhdGVzLmdldCh0aHJlc2hvbGRCLm5hbWUpO1xuICAgIGNvbnN0IHN0YXRlQyA9IHRoaXMuX3N0YXRlcy5nZXQodGhyZXNob2xkQy5uYW1lKTtcblxuICAgIHN0YXRlQS5zZXRXZWlnaHQod2VpZ2h0QSk7XG4gICAgc3RhdGVCLnNldFdlaWdodCh3ZWlnaHRCKTtcbiAgICBzdGF0ZUMuc2V0V2VpZ2h0KHdlaWdodEMpO1xuXG4gICAgdGhpcy5fc2V0UGhhc2VMZWFkU3RhdGUoXG4gICAgICBbc3RhdGVBLCBzdGF0ZUIsIHN0YXRlQ10sXG4gICAgICBbdGhyZXNob2xkQS5waGFzZU1hdGNoLCB0aHJlc2hvbGRCLnBoYXNlTWF0Y2gsIHRocmVzaG9sZEMucGhhc2VNYXRjaF1cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgdGhlIGNsb3Nlc3QgcG9pbnQgd2l0aGluIGEgdHJpYW5nbGUgb2ZcbiAgICogdGhyZXNob2xkcyBiYXNlZCBvbiB0aGUgY3VycmVudCBbeCx5XSBibGVuZFZhbHVlcyBhbmRcbiAgICogdGhlbiBzZXRzIGJsZW5kIHdlaWdodHMgZm9yIHRoZSBjb3JyZXNwb25kaW5nIHN0YXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcCAtIEdpdmVuIFt4LHldIGJsZW5kVmFsdWUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0SW5mbHVlbmNlQ2xvc2VzdFBvaW50SW5UcmlhbmdsZXMocCkge1xuICAgIGxldCBnbG9iYWxDbG9zZXN0UG9pbnQgPSBudWxsO1xuICAgIGxldCBnbG9iYWxNaW5EaXN0ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGxldCBjbG9zZXN0VHJpYW5nbGUgPSAtMTtcblxuICAgIHRoaXMuX3RyaWFuZ2xlcy5mb3JFYWNoKCh0cmlhbmdsZSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHBvaW50QSA9IE1hdGhVdGlscy5jbG9zZXN0UG9pbnRPbkxpbmUoXG4gICAgICAgIHRoaXMuX3ZlcnRpY2VzW3RyaWFuZ2xlWzBdXSxcbiAgICAgICAgdGhpcy5fdmVydGljZXNbdHJpYW5nbGVbMV1dLFxuICAgICAgICBwXG4gICAgICApO1xuICAgICAgY29uc3QgcG9pbnRCID0gTWF0aFV0aWxzLmNsb3Nlc3RQb2ludE9uTGluZShcbiAgICAgICAgdGhpcy5fdmVydGljZXNbdHJpYW5nbGVbMV1dLFxuICAgICAgICB0aGlzLl92ZXJ0aWNlc1t0cmlhbmdsZVsyXV0sXG4gICAgICAgIHBcbiAgICAgICk7XG4gICAgICBjb25zdCBwb2ludEMgPSBNYXRoVXRpbHMuY2xvc2VzdFBvaW50T25MaW5lKFxuICAgICAgICB0aGlzLl92ZXJ0aWNlc1t0cmlhbmdsZVsyXV0sXG4gICAgICAgIHRoaXMuX3ZlcnRpY2VzW3RyaWFuZ2xlWzBdXSxcbiAgICAgICAgcFxuICAgICAgKTtcblxuICAgICAgY29uc3QgZGlzdEEgPSBNYXRoVXRpbHMuZGlzdGFuY2VTcXVhcmVkKHBvaW50QSwgcCk7XG4gICAgICBjb25zdCBkaXN0QiA9IE1hdGhVdGlscy5kaXN0YW5jZVNxdWFyZWQocG9pbnRCLCBwKTtcbiAgICAgIGNvbnN0IGRpc3RDID0gTWF0aFV0aWxzLmRpc3RhbmNlU3F1YXJlZChwb2ludEMsIHApO1xuXG4gICAgICBsZXQgbG9jYWxDbG9zZXN0UG9pbnQgPSBwb2ludEM7XG4gICAgICBsZXQgbG9jYWxNaW5EaXN0ID0gZGlzdEM7XG5cbiAgICAgIGlmIChkaXN0QSA8IGxvY2FsTWluRGlzdCkge1xuICAgICAgICBsb2NhbENsb3Nlc3RQb2ludCA9IHBvaW50QTtcbiAgICAgICAgbG9jYWxNaW5EaXN0ID0gZGlzdEE7XG4gICAgICB9XG4gICAgICBpZiAoZGlzdEIgPCBsb2NhbE1pbkRpc3QpIHtcbiAgICAgICAgbG9jYWxDbG9zZXN0UG9pbnQgPSBwb2ludEI7XG4gICAgICAgIGxvY2FsTWluRGlzdCA9IGRpc3RCO1xuICAgICAgfVxuXG4gICAgICBpZiAobG9jYWxNaW5EaXN0IDwgZ2xvYmFsTWluRGlzdCkge1xuICAgICAgICBnbG9iYWxNaW5EaXN0ID0gbG9jYWxNaW5EaXN0O1xuICAgICAgICBnbG9iYWxDbG9zZXN0UG9pbnQgPSBbLi4ubG9jYWxDbG9zZXN0UG9pbnRdO1xuICAgICAgICBjbG9zZXN0VHJpYW5nbGUgPSBpbmRleDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuX3NldEluZmx1ZW5jZVRyaWFuZ2xlKFxuICAgICAgdGhpcy5fdHJpYW5nbGVzW2Nsb3Nlc3RUcmlhbmdsZV0sXG4gICAgICBnbG9iYWxDbG9zZXN0UG9pbnRcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgdGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIGxpbmUgZm9ybWVkIGJldHdlZW4gdGhlXG4gICAqIHR3byBibGVuZCB0aHJlc2hvbGRzIGJhc2VkIG9uIHRoZSBjdXJyZW50IFt4LHldIGJsZW5kVmFsdWVzIGFuZFxuICAgKiB0aGVuIHNldHMgYmxlbmQgd2VpZ2h0cyBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgc3RhdGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBwIC0gR2l2ZW4gW3gseV0gYmxlbmRWYWx1ZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRJbmZsdWVuY2VDbG9zZXN0UG9pbnRPbkxpbmUocCkge1xuICAgIGNvbnN0IGNsb3Nlc3RQb2ludCA9IE1hdGhVdGlscy5jbG9zZXN0UG9pbnRPbkxpbmUoXG4gICAgICB0aGlzLl92ZXJ0aWNlc1tbMF1dLFxuICAgICAgdGhpcy5fdmVydGljZXNbWzFdXSxcbiAgICAgIHBcbiAgICApO1xuXG4gICAgY29uc3QgZGlzdEEgPSBNYXRoVXRpbHMuZGlzdGFuY2VTcXVhcmVkKHRoaXMuX3ZlcnRpY2VzWzBdLCBjbG9zZXN0UG9pbnQpO1xuICAgIGNvbnN0IGRpc3RCID0gTWF0aFV0aWxzLmRpc3RhbmNlU3F1YXJlZCh0aGlzLl92ZXJ0aWNlc1sxXSwgY2xvc2VzdFBvaW50KTtcblxuICAgIGNvbnN0IHdlaWdodEEgPSBkaXN0QiAvIChkaXN0QSArIGRpc3RCKTtcbiAgICBjb25zdCB3ZWlnaHRCID0gZGlzdEEgLyAoZGlzdEEgKyBkaXN0Qik7XG5cbiAgICBjb25zdCB0aHJlc2hvbGRBID0gdGhpcy5fdGhyZXNob2xkc1swXTtcbiAgICBjb25zdCB0aHJlc2hvbGRCID0gdGhpcy5fdGhyZXNob2xkc1sxXTtcblxuICAgIGNvbnN0IHN0YXRlQSA9IHRoaXMuX3N0YXRlcy5nZXQodGhyZXNob2xkQS5uYW1lKTtcbiAgICBjb25zdCBzdGF0ZUIgPSB0aGlzLl9zdGF0ZXMuZ2V0KHRocmVzaG9sZEIubmFtZSk7XG5cbiAgICBzdGF0ZUEuc2V0V2VpZ2h0KHdlaWdodEEpO1xuICAgIHN0YXRlQi5zZXRXZWlnaHQod2VpZ2h0Qik7XG5cbiAgICB0aGlzLl9zZXRQaGFzZUxlYWRTdGF0ZShcbiAgICAgIFtzdGF0ZUEsIHN0YXRlQl0sXG4gICAgICBbdGhyZXNob2xkQS5waGFzZU1hdGNoLCB0aHJlc2hvbGRCLnBoYXNlTWF0Y2hdXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgbGVhZCBwaGFzZSBzdGF0ZSBpZiB0aGUgY29uZGl0aW9uc1xuICAgKiBmb3IgcGhhc2UtbWF0Y2hpbmcgYXJlIHNhdGlzZmllZC5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheS48QWJzdHJhY3RCbGVuZFN0YXRlPn0gc3RhdGVzIC0gU3RhdGVzIHRvXG4gICAqIGNoZWNrIHBoYXNlLW1hdGNoaW5nIGNyaXRlcmlhLlxuICAgKiBAcGFyYW0ge0FycmF5Ljxib29sZWFuPn0gcGhhc2VNYXRjaGVkIC0gTGlzdCBvZiBwaGFzZS1tYXRjaCBib29sZWFucy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRQaGFzZUxlYWRTdGF0ZShzdGF0ZXMsIHBoYXNlTWF0Y2hlZCkge1xuICAgIGxldCBtYXggPSAwO1xuICAgIHN0YXRlcy5mb3JFYWNoKChzdGF0ZSwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChwaGFzZU1hdGNoZWRbaW5kZXhdICYmIHN0YXRlLndlaWdodCA+IG1heCkge1xuICAgICAgICB0aGlzLl9waGFzZUxlYWRTdGF0ZSA9IHN0YXRlO1xuICAgICAgICBtYXggPSBzdGF0ZS53ZWlnaHQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmxlbmQyZFN0YXRlO1xuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcbmltcG9ydCBBYnN0cmFjdEJsZW5kU3RhdGUgZnJvbSAnLi9zdGF0ZS9BYnN0cmFjdEJsZW5kU3RhdGUnO1xuaW1wb3J0IEFuaW1hdGlvblBsYXllckludGVyZmFjZSBmcm9tICcuL0FuaW1hdGlvblBsYXllckludGVyZmFjZSc7XG5pbXBvcnQgQW5pbWF0aW9uVXRpbHMgZnJvbSAnLi9BbmltYXRpb25VdGlscyc7XG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gJy4uL01hdGhVdGlscyc7XG5pbXBvcnQgRGVmZXJyZWQgZnJvbSAnLi4vRGVmZXJyZWQnO1xuaW1wb3J0IFN0YXRlQ29udGFpbmVySW50ZXJmYWNlIGZyb20gJy4vc3RhdGUvU3RhdGVDb250YWluZXJJbnRlcmZhY2UnO1xuXG4vKipcbiAqIEVudW0gZm9yIHR5cGVzIG9mIHtAbGluayBBbmltYXRpb25MYXllcn0gYmxlbmRpbmcuXG4gKlxuICogQHJlYWRvbmx5XG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgTGF5ZXJCbGVuZE1vZGVzID0ge092ZXJyaWRlOiAnT3ZlcnJpZGUnLCBBZGRpdGl2ZTogJ0FkZGl0aXZlJ307XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgYmxlbmRpbmcgbW9kZSB7QGxpbmsgQW5pbWF0aW9uTGF5ZXJ9LlxuICpcbiAqIEByZWFkb25seVxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IERlZmF1bHRMYXllckJsZW5kTW9kZSA9ICdPdmVycmlkZSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gYmxlbmRNb2RlIGlzIHByZXNlbnQgaW4gdGhlIHZhbHVlcyBvZiB7QGxpbmsgTGF5ZXJCbGVuZE1vZGVzfS5cbiAqIElmIGl0IGlzLCByZXR1cm4gdGhlIG9yaWdpbmFsIHZhbHVlLCBvdGhlcndpc2UgcmV0dXJuIHtAbGluayBEZWZhdWx0TGF5ZXJCbGVuZE1vZGV9LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBibGVuZE1vZGUgLSBUaGUgbmFtZSBvZiB0aGUgdHlwZSBvZiBibGVuZGluZy5cbiAqXG4gKiBAcmV0dXJucyB7KHN0cmluZ3xEZWZhdWx0TGF5ZXJCbGVuZE1vZGUpfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVCbGVuZE1vZGUoYmxlbmRNb2RlKSB7XG4gIGlmIChBcnJheS5mcm9tKE9iamVjdC52YWx1ZXMoTGF5ZXJCbGVuZE1vZGVzKSkuaW5jbHVkZXMoYmxlbmRNb2RlKSkge1xuICAgIHJldHVybiBibGVuZE1vZGU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIERlZmF1bHRMYXllckJsZW5kTW9kZTtcbiAgfVxufVxuXG4vKipcbiAqIENsYXNzIGZvciBtYW5hZ2luZyBhIHNldCBvZiBhbmltYXRpb25zIHdoZXJlIG9ubHkgb25lIHN0YXRlIGNhbiBiZSBhY3RpdmUgYXRcbiAqIGFueSBnaXZlbiB0aW1lLlxuICpcbiAqIEBpbXBsZW1lbnRzIEFuaW1hdGlvblBsYXllckludGVyZmFjZVxuICogQGltcGxlbWVudHMgU3RhdGVDb250YWluZXJJbnRlcmZhY2VcbiAqL1xuY2xhc3MgQW5pbWF0aW9uTGF5ZXIgZXh0ZW5kcyBBbmltYXRpb25QbGF5ZXJJbnRlcmZhY2UuTWl4aW4oXG4gIFN0YXRlQ29udGFpbmVySW50ZXJmYWNlLk1peGluKClcbikge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyAtICBPcHRpb25zIGZvciB0aGUgYW5pbWF0aW9uIGxheWVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5uYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIuIE5hbWVzIG11c3QgYmUgdW5pcXVlIHRvIHRoZVxuICAgKiBhbmltYXRpb24gZmVhdHVyZSB0aGF0IGNvbnRhaW5zIHRoZSBsYXllci5cbiAgICogQHBhcmFtIHtMYXllckJsZW5kTW9kZXN9IFtvcHRpb25zLmJsZW5kTW9kZT1EZWZhdWx0TGF5ZXJCbGVuZE1vZGVdIC1cbiAgICogVHlwZSBvZiBibGVuZGluZyB0byB1c2UgZm9yIGFsbCBzdGF0ZXMgY29udHJvbGxlZCBieSB0aGUgbGF5ZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy53ZWlnaHQ9MV0gLSBUaGUgYW1vdW50IG9mIGluZmx1ZW5jZSB0aGUgbGF5ZXIncyBjdXJyZW50XG4gICAqIGFuaW1hdGlvbiBoYXMgb3ZlciB0aGUgcmVzdWx0IGZvciB0aGUgaG9zdC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnRyYW5zaXRpb25UaW1lPTBdIC0gVGhlIGRlZmF1bHQgYW1vdW50IG9mIHRpbWUgdG8gdXNlIHdoZW5cbiAgICogcGxheWluZyBhbmQgcmVzdW1pbmcgYW5pbWF0aW9ucy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9wdGlvbnMuZWFzaW5nRm4gLSBUaGUgZGVmYXVsdCBlYXNpbmcgZnVuY3Rpb24gdG8gdXNlIHdoZW5cbiAgICogdHJhbnNpdGlvbmluZyBiZXR3ZWVuIGFuaW1hdGlvbnMgYW5kIHNldHRpbmcgbGF5ZXIgd2VpZ2h0LlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICB0aGlzLm5hbWUgPSBvcHRpb25zLm5hbWUgPT09IHVuZGVmaW5lZCA/ICdBbmltYXRpb25MYXllcicgOiBvcHRpb25zLm5hbWU7XG4gICAgdGhpcy5fYmxlbmRNb2RlID0gQXJyYXkuZnJvbShPYmplY3QudmFsdWVzKExheWVyQmxlbmRNb2RlcykpLmluY2x1ZGVzKFxuICAgICAgb3B0aW9ucy5ibGVuZE1vZGVcbiAgICApXG4gICAgICA/IG9wdGlvbnMuYmxlbmRNb2RlXG4gICAgICA6IERlZmF1bHRMYXllckJsZW5kTW9kZTtcbiAgICB0aGlzLl9wcm9taXNlcyA9IHtcbiAgICAgIHdlaWdodDogRGVmZXJyZWQucmVzb2x2ZSgpLFxuICAgIH07XG4gICAgdGhpcy5fd2VpZ2h0UGF1c2VkID0gZmFsc2U7XG5cbiAgICB0aGlzLndlaWdodCA9IHR5cGVvZiBvcHRpb25zLndlaWdodCA9PT0gJ251bWJlcicgPyBvcHRpb25zLndlaWdodCA6IDE7XG4gICAgdGhpcy5faW50ZXJuYWxXZWlnaHQgPSB0aGlzLl93ZWlnaHQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdHlwZSBvZiBibGVuZGluZyB1c2VkIGZvciBzdGF0ZXMgY29udHJvbGxlZCBieSB0aGUgbGF5ZXIuXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGJsZW5kTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmxlbmRNb2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW5kIHNldHMgdGhlIGFtb3VudCBvZiBpbmZsdWVuY2UgdGhlIGxheWVyJ3MgY3VycmVudCBhbmltYXRpb24gaGFzIG92ZXJcbiAgICogdGhlIHJlc3VsdCBmb3IgdGhlIGhvc3QuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBzZXQgd2VpZ2h0KHdlaWdodCkge1xuICAgIHRoaXMuX3dlaWdodCA9IE1hdGhVdGlscy5jbGFtcCh3ZWlnaHQsIDAsIDEpO1xuICB9XG5cbiAgZ2V0IHdlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2VpZ2h0O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgd2hldGhlciBvciBub3QgdGhlIGxheWVyJ3Mgd2VpZ2h0IHZhbHVlIGlzIGN1cnJlbnRseSBiZWluZyBhbmltYXRlZC5cbiAgICpcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IHdlaWdodFBlbmRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VzLndlaWdodCAmJiB0aGlzLl9wcm9taXNlcy53ZWlnaHQucGVuZGluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXVzZSB0aGUgY3VycmVudCBhbmltYXRpb24gc3RhdGUgYW5kIGFueSBpbnRlcnBvbGF0aW9uIGhhcHBlbmluZyBvbiB0aGUgbGF5ZXInc1xuICAgKiB3ZWlnaHQgcHJvcGVydHkuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgcGF1c2UoKSB7XG4gICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICB0aGlzLl93ZWlnaHRQYXVzZWQgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRoaXMucGF1c2VBbmltYXRpb24oKSB8fCB0aGlzLndlaWdodFBlbmRpbmc7XG4gIH1cblxuICAvKipcbiAgICogUmVzdW1lIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBzdGF0ZSBhbmQgYW55IGludGVycG9sYXRpb24gaGFwcGVuaW5nIG9uIHRoZSBsYXllcidzXG4gICAqIHdlaWdodCBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICByZXN1bWUoKSB7XG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gICAgdGhpcy5fd2VpZ2h0UGF1c2VkID0gZmFsc2U7XG5cbiAgICBjb25zdCBpc1dlaWdodEFjdGl2ZSA9IHRoaXMud2VpZ2h0UGVuZGluZztcblxuICAgIGlmICh0aGlzLl9jdXJyZW50U3RhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlc3VtZUFuaW1hdGlvbigpIHx8IGlzV2VpZ2h0QWN0aXZlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaXNXZWlnaHRBY3RpdmU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHVzZXIgZGVmaW5lZCB3ZWlnaHQgb3ZlciB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gd2VpZ2h0IC0gVGhlIHRhcmdldCB3ZWlnaHQgdmFsdWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2Vjb25kcz0wXSAtIFRoZSBhbW91bnQgb2YgdGltZSBpdCB3aWxsIHRha2UgdG8gcmVhY2ggdGhlXG4gICAqIHRhcmdldCB3ZWlnaHQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBlYXNpbmdGbiAtIFRoZSBlYXNpbmcgZnVuY3Rpb24gdG8gdXNlIGZvciBpbnRlcnBvbGF0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9XG4gICAqL1xuICBzZXRXZWlnaHQod2VpZ2h0LCBzZWNvbmRzID0gMCwgZWFzaW5nRm4pIHtcbiAgICBpZiAodGhpcy53ZWlnaHRQZW5kaW5nKSB7XG4gICAgICB0aGlzLl9wcm9taXNlcy53ZWlnaHQuY2FuY2VsKCk7XG4gICAgfVxuXG4gICAgd2VpZ2h0ID0gTWF0aFV0aWxzLmNsYW1wKHdlaWdodCk7XG4gICAgdGhpcy5fcHJvbWlzZXMud2VpZ2h0ID0gQW5pbWF0aW9uVXRpbHMuaW50ZXJwb2xhdGVQcm9wZXJ0eShcbiAgICAgIHRoaXMsXG4gICAgICAnd2VpZ2h0JyxcbiAgICAgIHdlaWdodCxcbiAgICAgIHtcbiAgICAgICAgc2Vjb25kcyxcbiAgICAgICAgZWFzaW5nRm46IGVhc2luZ0ZuICE9PSB1bmRlZmluZWQgPyBlYXNpbmdGbiA6IHRoaXMuX2Vhc2luZ0ZuLFxuICAgICAgfVxuICAgICk7XG5cbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZXMud2VpZ2h0O1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdXNlIGFueSBpbnRlcnBvbGF0aW9uIGhhcHBlbmluZyBvbiB0aGUgbGF5ZXIncyB3ZWlnaHQgcHJvcGVydHkuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgcGF1c2VXZWlnaHQoKSB7XG4gICAgdGhpcy5fd2VpZ2h0UGF1c2VkID0gdHJ1ZTtcblxuICAgIHJldHVybiB0aGlzLndlaWdodFBlbmRpbmc7XG4gIH1cblxuICAvKipcbiAgICogUmVzdW1lIGFueSBpbnRlcnBvbGF0aW9uIGhhcHBlbmluZyBvbiB0aGUgbGF5ZXIncyB3ZWlnaHQgcHJvcGVydHkuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgcmVzdW1lV2VpZ2h0KCkge1xuICAgIHRoaXMuX3dlaWdodFBhdXNlZCA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIHRoaXMud2VpZ2h0UGVuZGluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBNdWx0aXBsaWVzIHRoZSB1c2VyIHdlaWdodCBieSBhIGZhY3RvciB0byBkZXRlcm1pbmUgdGhlIGludGVybmFsIHdlaWdodC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZhY3RvciAtIDAtMSBtdWx0aXBsaWVyIHRvIGFwcGx5IHRvIHRoZSB1c2VyIHdlaWdodC5cbiAgICovXG4gIHVwZGF0ZUludGVybmFsV2VpZ2h0KGZhY3Rvcikge1xuICAgIHRoaXMuX2ludGVybmFsV2VpZ2h0ID0gdGhpcy5fd2VpZ2h0ICogZmFjdG9yO1xuXG4gICAgaWYgKHRoaXMuX2N1cnJlbnRTdGF0ZSkge1xuICAgICAgdGhpcy5fY3VycmVudFN0YXRlLnVwZGF0ZUludGVybmFsV2VpZ2h0KHRoaXMuX2ludGVybmFsV2VpZ2h0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbmFtZXMgb2YgYmxlbmQgc3RhdGVzIGluIGFuIGFuaW1hdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFuaW1hdGlvbk5hbWUgLSBOYW1lIG9mIHRoZSBhbmltYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheS48c3RyaW5nPn0gLSBOYW1lcyBvZiBibGVuZCBzdGF0ZXMuXG4gICAqL1xuICBnZXRBbmltYXRpb25CbGVuZE5hbWVzKGFuaW1hdGlvbk5hbWUpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoYW5pbWF0aW9uTmFtZSk7XG5cbiAgICBpZiAoc3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGdldCBibGVuZCBuYW1lcyBvZiBhbmltYXRpb24gJHthbmltYXRpb25OYW1lfSBvbiBsYXllciAke3RoaXMubmFtZX0uIE5vIGFuaW1hdGlvbiBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUgaW5zdGFuY2VvZiBBYnN0cmFjdEJsZW5kU3RhdGUpIHtcbiAgICAgIHJldHVybiBzdGF0ZS5nZXRTdGF0ZU5hbWVzKCk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENhbm5vdCBnZXQgYmxlbmQgbmFtZXMgb2YgYW5pbWF0aW9uICR7YW5pbWF0aW9uTmFtZX0gb24gbGF5ZXIgJHt0aGlzLm5hbWV9LiBBbmltYXRpb24gaXMgbm90IGFuIGluc3RhbmNlIG9mIEFic3RyYWN0QmxlbmRTdGF0ZS5gXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHdlaWdodCBmb3IgYSBibGVuZCBzdGF0ZSBvZiBhbiBhbmltYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbmltYXRpb25OYW1lIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uIGNvbnRhaW5pbmcgdGhlIGJsZW5kIHN0YXRlXG4gICAqIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGJsZW5kTmFtZSAtIE5hbWUgb2YgdGhlIGJsZW5kIHN0YXRlIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHdlaWdodCAtIFdlaWdodCB2YWx1ZSB0byBzZXQgb24gdGhlIGFuaW1hdGlvbi4gVGhpcyBudW1iZXIgc2hvdWRsZCBiZVxuICAgKiBpbiB0aGUgMC0xIHJhbmdlLlxuICAgKiBAcGFyYW0ge251bWJlcj19IHNlY29uZHMgLSBOdW1iZXIgb2Ygc2Vjb25kcyBpdCBzaG91bGQgdGFrZSB0byByZWFjaCB0aGUgbmV3IHdlaWdodC5cbiAgICogRGVmYXVsdCBpcyB6ZXJvIGFuZCB3aWxsIHNldCBpbW1lZGlhdGVseS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGVhc2luZ0ZuIC0gRWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSB3aGlsZSBpbnRlcnBvbGF0aW5nIHRoZSBuZXdcbiAgICogd2VpZ2h0LiBEZWZhdWx0IGlzIEVhc2luZy5MaW5lYXIuSW5PdXQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH0gLSBQcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIG9uY2UgdGhlIGFuaW1hdGlvbidzIHdlaWdodCByZWFjaGVzXG4gICAqIHRoZSB0YXJnZXQgdmFsdWUuXG4gICAqL1xuICBzZXRBbmltYXRpb25CbGVuZFdlaWdodChcbiAgICBhbmltYXRpb25OYW1lLFxuICAgIGJsZW5kTmFtZSxcbiAgICB3ZWlnaHQsXG4gICAgc2Vjb25kcyA9IDAsXG4gICAgZWFzaW5nRm5cbiAgKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFN0YXRlKGFuaW1hdGlvbk5hbWUpO1xuXG4gICAgaWYgKHN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBzZXQgYmxlbmQgd2VpZ2h0IG9mIGFuaW1hdGlvbiAke2FuaW1hdGlvbk5hbWV9IG9uIGxheWVyICR7dGhpcy5uYW1lfS4gTm8gYW5pbWF0aW9uIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZSBpbnN0YW5jZW9mIEFic3RyYWN0QmxlbmRTdGF0ZSkge1xuICAgICAgcmV0dXJuIHN0YXRlLnNldEJsZW5kV2VpZ2h0KGJsZW5kTmFtZSwgd2VpZ2h0LCBzZWNvbmRzLCBlYXNpbmdGbik7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENhbm5vdCBzZXQgYmxlbmQgd2VpZ2h0IG9mIGFuaW1hdGlvbiAke2FuaW1hdGlvbk5hbWV9IG9uIGxheWVyICR7dGhpcy5uYW1lfS4gQW5pbWF0aW9uIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBBYnN0cmFjdEJsZW5kU3RhdGUuYFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgd2VpZ2h0IGZvciBhIGJsZW5kIHN0YXRlIG9mIGFuIGFuaW1hdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFuaW1hdGlvbk5hbWUgLSBOYW1lIG9mIHRoZSBhbmltYXRpb24gY29udGFpbmluZyB0aGUgYmxlbmQgc3RhdGVcbiAgICogdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYmxlbmROYW1lIC0gTmFtZSBvZiB0aGUgYmxlbmQgc3RhdGUgdG8gcmV0cmlldmUgdGhlIHdlaWdodCBvZi5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlcn0gLSBXZWlnaHQgb2YgdGhlIGJsZW5kIHN0YXRlLlxuICAgKi9cbiAgZ2V0QW5pbWF0aW9uQmxlbmRXZWlnaHQoYW5pbWF0aW9uTmFtZSwgYmxlbmROYW1lKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFN0YXRlKGFuaW1hdGlvbk5hbWUpO1xuXG4gICAgaWYgKHN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBnZXQgYmxlbmQgd2VpZ2h0IG9mIGFuaW1hdGlvbiAke2FuaW1hdGlvbk5hbWV9IG9uIGxheWVyICR7dGhpcy5uYW1lfS4gTm8gYW5pbWF0aW9uIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZSBpbnN0YW5jZW9mIEFic3RyYWN0QmxlbmRTdGF0ZSkge1xuICAgICAgcmV0dXJuIHN0YXRlLmdldEJsZW5kV2VpZ2h0KGJsZW5kTmFtZSk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENhbm5vdCBnZXQgYmxlbmQgd2VpZ2h0IG9mIGFuaW1hdGlvbiAke2FuaW1hdGlvbk5hbWV9IG9uIGxheWVyICR7dGhpcy5uYW1lfS4gQW5pbWF0aW9uIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBBYnN0cmFjdEJsZW5kU3RhdGUuYFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGFueSB3ZWlnaHQgaW50ZXJwb2xhdG9ycyBhbmQgdGhlIGN1cnJlbnQgYW5pbWF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFUaW1lIC0gVGltZSBpbiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGxhc3QgdXBkYXRlLlxuICAgKi9cbiAgdXBkYXRlKGRlbHRhVGltZSkge1xuICAgIHN1cGVyLnVwZGF0ZShkZWx0YVRpbWUpO1xuXG4gICAgaWYgKCF0aGlzLl9wYXVzZWQgJiYgIXRoaXMuX3dlaWdodFBhdXNlZCkge1xuICAgICAgdGhpcy5fcHJvbWlzZXMud2VpZ2h0LmV4ZWN1dGUoZGVsdGFUaW1lKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VsIGFueSBwZW5kaW5nIHByb21pc2VzIGFuZCBkaXNjYXJkIHN0YXRlcyBjb250cm9sbGVkIGJ5IHRoZSBsYXllci5cbiAgICovXG4gIGRpc2NhcmQoKSB7XG4gICAgc3VwZXIuZGlzY2FyZCgpO1xuXG4gICAgdGhpcy5kaXNjYXJkU3RhdGVzKCk7XG5cbiAgICB0aGlzLl9wcm9taXNlcy53ZWlnaHQuY2FuY2VsKCk7XG4gICAgZGVsZXRlIHRoaXMuX3Byb21pc2VzO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEFuaW1hdGlvbkxheWVyO1xuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcbmltcG9ydCBEZWZlcnJlZCBmcm9tICdjb3JlL0RlZmVycmVkJztcbmltcG9ydCBBYnN0cmFjdFN0YXRlIGZyb20gJy4vQWJzdHJhY3RTdGF0ZSc7XG5pbXBvcnQge3ZhbGlkYXRlQmxlbmRNb2RlfSBmcm9tICcuLi9BbmltYXRpb25MYXllcic7XG5pbXBvcnQgQW5pbWF0aW9uVXRpbHMgZnJvbSAnLi4vQW5pbWF0aW9uVXRpbHMnO1xuXG4vKipcbiAqIENsYXNzIGZvciBwbGF5aW5nIGEgc2luZ2xlIGFuaW1hdGlvbiBjbGlwLlxuICpcbiAqIEBleHRlbmRzIEFic3RyYWN0U3RhdGVcbiAqIEBhbGlhcyBjb3JlL1NpbmdsZVN0YXRlXG4gKi9cbmNsYXNzIFNpbmdsZVN0YXRlIGV4dGVuZHMgQWJzdHJhY3RTdGF0ZSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGFuaW1hdGlvbiBzdGF0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRpb25zLm5hbWUgLSBOYW1lIGZvciB0aGUgYW5pbWF0aW9uIHN0YXRlLiBOYW1lcyBtdXN0IGJlXG4gICAqIHVuaXF1ZSBmb3IgdGhlIGxheWVyIHRoZSBzdGF0ZSBpcyBhcHBsaWVkIHRvLlxuICAgKiBAcGFyYW0ge3dlaWdodH0gW29wdGlvbnMud2VpZ2h0PTBdIC0gVGhlIDAtMSBhbW91bnQgb2YgaW5mbHVlbmNlIHRoZSBzdGF0ZSB3aWxsIGhhdmUuXG4gICAqIEBwYXJhbSB7dGltZVNjYWxlfSBbb3B0aW9ucy50aW1lU2NhbGU9MV0gLSBGYWN0b3IgdG8gc2NhbGUgdGhlIHBsYXliYWNrIHNwZWVkIG9mIHRoZVxuICAgKiBhbmltYXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5sb29wQ291bnQ9SW5maW5pdHldIC0gTnVtYmVyIG9mIHRpbWVzIHRoZSBhbmltYXRpb24gc2hvdWxkXG4gICAqIHJlcGVhdCBiZWZvcmUgZmluaXNoaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYmxlbmRNb2RlPURlZmF1bHRMYXllckJsZW5kTW9kZV0gLSBUeXBlIG9mXG4gICAqIGJsZW5kaW5nIHRoZSBhbmltYXRpb24gc2hvdWxkIHVzZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuXG4gICAgdGhpcy5fdGltZVNjYWxlID0gb3B0aW9ucy50aW1lU2NhbGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudGltZVNjYWxlIDogMTtcbiAgICB0aGlzLl9wcm9taXNlcy50aW1lU2NhbGUgPSBEZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgdGhpcy5fbG9vcENvdW50ID1cbiAgICAgIG9wdGlvbnMubG9vcENvdW50ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmxvb3BDb3VudCA6IEluZmluaXR5O1xuICAgIHRoaXMuX2JsZW5kTW9kZSA9IHZhbGlkYXRlQmxlbmRNb2RlKG9wdGlvbnMuYmxlbmRNb2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuZCBzZXRzIHRoZSBub3JtYWxpemVkIHBsYXlpbmcgdGltZSBvZiB0aGUgY3VycmVudCBhbmltYXRpb25cbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBub3JtYWxpemVkVGltZSgpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuZCBzZXRzIHRoZSBhIGZhY3RvciB0byBzY2FsZSBhbmltYXRpb24gcGxheWJhY2sgc3BlZWQgd2l0aC5cbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB0aW1lU2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbWVTY2FsZTtcbiAgfVxuXG4gIHNldCB0aW1lU2NhbGUodGltZVNjYWxlKSB7XG4gICAgdGhpcy5fdGltZVNjYWxlID0gdGltZVNjYWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgd2hldGhlciBvciBub3QgdGhlIHRpbWVTY2FsZSBpcyBjdXJyZW50bHkgYmVpbmcgYW5pbWF0ZWQuXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCB0aW1lU2NhbGVQZW5kaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm9taXNlcy50aW1lU2NhbGUucGVuZGluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB0aW1lU2NhbGUgdmFsdWUgb3ZlciB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gd2VpZ2h0IC0gVGhlIHRhcmdldCB0aW1lU2NhbGUgdmFsdWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2Vjb25kcz0wXSAtIFRoZSBhbW91bnQgb2YgdGltZSBpdCB3aWxsIHRha2UgdG8gcmVhY2ggdGhlXG4gICAqIHRhcmdldCB0aW1lU2NhbGUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBlYXNpbmdGbiAtIFRoZSBlYXNpbmcgZnVuY3Rpb24gdG8gdXNlIGZvciBpbnRlcnBvbGF0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9XG4gICAqL1xuICBzZXRUaW1lU2NhbGUodGltZVNjYWxlLCBzZWNvbmRzID0gMCwgZWFzaW5nRm4pIHtcbiAgICB0aGlzLl9wcm9taXNlcy50aW1lU2NhbGUuY2FuY2VsKCk7XG5cbiAgICB0aGlzLl9wcm9taXNlcy50aW1lU2NhbGUgPSBBbmltYXRpb25VdGlscy5pbnRlcnBvbGF0ZVByb3BlcnR5KFxuICAgICAgdGhpcyxcbiAgICAgICd0aW1lU2NhbGUnLFxuICAgICAgdGltZVNjYWxlLFxuICAgICAge3NlY29uZHMsIGVhc2luZ0ZufVxuICAgICk7XG5cbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZXMudGltZVNjYWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW5kIHNldHMgdGhlIG51bWJlciBvZiB0aW1lcyB0aGUgYW5pbWF0aW9uIHdpbGwgcmVwZWF0IGJlZm9yZSBmaW5pc2hpbmcuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbG9vcENvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl9sb29wQ291bnQ7XG4gIH1cblxuICBzZXQgbG9vcENvdW50KGxvb3BDb3VudCkge1xuICAgIHRoaXMuX2xvb3BDb3VudCA9IGxvb3BDb3VudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB0eXBlIG9mIGJsZW5kaW5nIHVzZWQgZm9yIHRoZSBhbmltYXRpb24uXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGJsZW5kTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmxlbmRNb2RlO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNpbmdsZVN0YXRlO1xuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcbmltcG9ydCBBYnN0cmFjdFN0YXRlIGZyb20gJy4vQWJzdHJhY3RTdGF0ZSc7XG5pbXBvcnQgU3RhdGVDb250YWluZXJJbnRlcmZhY2UgZnJvbSAnLi9TdGF0ZUNvbnRhaW5lckludGVyZmFjZSc7XG5pbXBvcnQgQW5pbWF0aW9uUGxheWVySW50ZXJmYWNlIGZyb20gJy4uL0FuaW1hdGlvblBsYXllckludGVyZmFjZSc7XG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vLi4vVXRpbHMnO1xuXG4vKipcbiAqIENsYXNzIGZvciBwbGF5aW5nIHJhbmRvbSBhbmltYXRpb25zIGF0IHJhbmRvbSBpbnRlcnZhbHMgd2l0aGluIHRoaXMgc3RhdGUuXG4gKlxuICogQGV4dGVuZHMgQWJzdHJhY3RTdGF0ZVxuICogQGltcGxlbWVudHMgQW5pbWF0aW9uUGxheWVySW50ZXJmYWNlXG4gKiBAaW1wbGVtZW50cyBTdGF0ZUNvbnRhaW5lckludGVyZmFjZVxuICovXG5jbGFzcyBSYW5kb21BbmltYXRpb25TdGF0ZSBleHRlbmRzIEFuaW1hdGlvblBsYXllckludGVyZmFjZS5NaXhpbihcbiAgU3RhdGVDb250YWluZXJJbnRlcmZhY2UuTWl4aW4oQWJzdHJhY3RTdGF0ZSlcbikge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gLSBPcHRpb25zIGZvciB0aGUgY29udGFpbmVyIHN0YXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucGxheUludGVydmFsPTNdIC0gVGhlIGJhc2UgYW5pbWF0aW9uIHBsYXliYWNrIGludGVydmFsLlxuICAgKiBAcGFyYW0ge0FycmF5LjxBYnN0cmFjdFN0YXRlPn0gW3N1YlN0YXRlcz1bXV0gLSBzdGF0ZXMgdG8gYmUgcmFuZG9tbHkgcGlja2VkIHRvIHBsYXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSwgc3ViU3RhdGVzID0gW10pIHtcbiAgICBzdXBlcihvcHRpb25zKTtcblxuICAgIHRoaXMuX3BsYXlJbnRlcnZhbCA9IG9wdGlvbnMucGxheUludGVydmFsID8gb3B0aW9ucy5wbGF5SW50ZXJ2YWwgOiAzO1xuXG4gICAgc3ViU3RhdGVzLmZvckVhY2goc3RhdGUgPT4ge1xuICAgICAgdGhpcy5hZGRTdGF0ZShzdGF0ZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbmQgc2V0cyB0aGUgYmFzZSBhbmltYXRpb24gcGxheSBpbnRlcnZhbFxuICAgKlxuICAgKiBAdHlwZSB7ZmxvYXR9XG4gICAqL1xuICBnZXQgcGxheUludGVydmFsKCkge1xuICAgIHJldHVybiB0aGlzLl9wbGF5SW50ZXJ2YWw7XG4gIH1cblxuICBzZXQgcGxheUludGVydmFsKHBsYXlJbnRlcnZhbCkge1xuICAgIHRoaXMuX3BsYXlJbnRlcnZhbCA9IHBsYXlJbnRlcnZhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgaW50ZXJuYWwgdGltZXIgZm9yIGFuaW1hdGlvbiBwbGF5IGludGVydmFsXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVzZXRUaW1lcigpIHtcbiAgICBjb25zdCBwbGF5VGltZXIgPSBVdGlscy5nZXRSYW5kb21GbG9hdChcbiAgICAgIHRoaXMuX3BsYXlJbnRlcnZhbCAvIDQsXG4gICAgICB0aGlzLl9wbGF5SW50ZXJ2YWwgKiAyXG4gICAgKTtcbiAgICBjb25zdCBvbkZpbmlzaCA9ICgpID0+IHtcbiAgICAgIHRoaXMucGxheVJhbmRvbUFuaW1hdGlvbih0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uRXJyb3IpO1xuICAgIH07XG4gICAgdGhpcy5fcHJvbWlzZXMudGltZXIgPSBVdGlscy53YWl0KHBsYXlUaW1lciwge29uRmluaXNofSk7XG4gIH1cblxuICB1cGRhdGVJbnRlcm5hbFdlaWdodChmYWN0b3IpIHtcbiAgICBzdXBlci51cGRhdGVJbnRlcm5hbFdlaWdodChmYWN0b3IpO1xuXG4gICAgaWYgKHRoaXMuX2N1cnJlbnRTdGF0ZSkge1xuICAgICAgdGhpcy5fY3VycmVudFN0YXRlLnVwZGF0ZUludGVybmFsV2VpZ2h0KHRoaXMuX2ludGVybmFsV2VpZ2h0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGljayBhIHJhbmRvbSBhbmltYXRpb24gYW5kIHV0aWxpemUgQW5pbWF0aW9uUGxheWVySW50ZXJmYWNlIHRvIHBsYXkgdGhhdCBhbmltYXRpb25cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uRXJyb3IgLSBGdW5jdGlvbiB0byBleGVjdXRlIGlmIHRoZSBzdGF0ZSBlbmNvdW50ZXJzXG4gICAqIGFuIGVycm9yIGR1cmluZyBwbGF5YmFjay5cbiAgICovXG4gIHBsYXlSYW5kb21BbmltYXRpb24ob25FcnJvcikge1xuICAgIHRoaXMuX3Jlc2V0VGltZXIoKTtcblxuICAgIGNvbnN0IHN0YXRlcyA9IHRoaXMuZ2V0U3RhdGVOYW1lcygpO1xuICAgIGlmICh0aGlzLl9jdXJyZW50U3RhdGUpIHtcbiAgICAgIHN0YXRlcy5zcGxpY2Uoc3RhdGVzLmluZGV4T2YodGhpcy5fY3VycmVudFN0YXRlLm5hbWUpLCAxKTtcbiAgICB9XG4gICAgY29uc3QgcmFuZG9tU3RhdGUgPSBzdGF0ZXNbVXRpbHMuZ2V0UmFuZG9tSW50KDAsIHN0YXRlcy5sZW5ndGgpXTtcblxuICAgIHRoaXMucGxheUFuaW1hdGlvbihcbiAgICAgIHJhbmRvbVN0YXRlLFxuICAgICAgdGhpcy5fdHJhbnNpdGlvblRpbWUsXG4gICAgICB0aGlzLl9lYXNpbmdGbixcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIG9uRXJyb3IsXG4gICAgICB1bmRlZmluZWRcbiAgICApO1xuICB9XG5cbiAgcGxheShvbkZpbmlzaCwgb25FcnJvciwgb25DYW5jZWwpIHtcbiAgICB0aGlzLnBsYXlSYW5kb21BbmltYXRpb24ob25FcnJvcik7XG4gICAgcmV0dXJuIHN1cGVyLnBsYXkob25GaW5pc2gsIG9uRXJyb3IsIG9uQ2FuY2VsKTtcbiAgfVxuXG4gIHBhdXNlKCkge1xuICAgIHJldHVybiBzdXBlci5wYXVzZSgpICYmIHRoaXMucGF1c2VBbmltYXRpb24oKTtcbiAgfVxuXG4gIHJlc3VtZShvbkZpbmlzaCwgb25FcnJvciwgb25DYW5jZWwpIHtcbiAgICBpZiAodGhpcy5fY3VycmVudFN0YXRlKSB7XG4gICAgICB0aGlzLnJlc3VtZUFuaW1hdGlvbihcbiAgICAgICAgdGhpcy5fY3VycmVudFN0YXRlLm5hbWUsXG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25UaW1lLFxuICAgICAgICB0aGlzLl9lYXNpbmdGbixcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICBvbkVycm9yLFxuICAgICAgICB1bmRlZmluZWRcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5yZXN1bWUob25GaW5pc2gsIG9uRXJyb3IsIG9uQ2FuY2VsKTtcbiAgfVxuXG4gIGNhbmNlbCgpIHtcbiAgICByZXR1cm4gc3VwZXIuY2FuY2VsKCkgJiYgdGhpcy5jYW5jZWxBbmltYXRpb24oKTtcbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgcmV0dXJuIHN1cGVyLnN0b3AoKSAmJiB0aGlzLnN0b3BBbmltYXRpb24oKTtcbiAgfVxuXG4gIGRpc2NhcmQoKSB7XG4gICAgc3VwZXIuZGlzY2FyZCgpO1xuICAgIHRoaXMuZGlzY2FyZFN0YXRlcygpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJhbmRvbUFuaW1hdGlvblN0YXRlO1xuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcbmltcG9ydCBBYnN0cmFjdEhvc3RGZWF0dXJlIGZyb20gJ2NvcmUvQWJzdHJhY3RIb3N0RmVhdHVyZSc7XG5pbXBvcnQgVXRpbHMgZnJvbSAnY29yZS9VdGlscyc7XG5pbXBvcnQgUXVldWVTdGF0ZSBmcm9tICcuL3N0YXRlL1F1ZXVlU3RhdGUnO1xuaW1wb3J0IEZyZWVCbGVuZFN0YXRlIGZyb20gJy4vc3RhdGUvRnJlZUJsZW5kU3RhdGUnO1xuaW1wb3J0IEJsZW5kMWRTdGF0ZSBmcm9tICcuL3N0YXRlL0JsZW5kMWRTdGF0ZSc7XG5pbXBvcnQgQmxlbmQyZFN0YXRlIGZyb20gJy4vc3RhdGUvQmxlbmQyZFN0YXRlJztcbmltcG9ydCBTaW5nbGVTdGF0ZSBmcm9tICcuL3N0YXRlL1NpbmdsZVN0YXRlJztcbmltcG9ydCBSYW5kb21BbmltYXRpb25TdGF0ZSBmcm9tICcuL3N0YXRlL1JhbmRvbUFuaW1hdGlvblN0YXRlJztcbmltcG9ydCBBbmltYXRpb25MYXllciwge0xheWVyQmxlbmRNb2Rlc30gZnJvbSAnLi9BbmltYXRpb25MYXllcic7XG5pbXBvcnQgRGVmZXJyZWQgZnJvbSAnLi4vRGVmZXJyZWQnO1xuXG4vKipcbiAqIEVudW0gZm9yIGFuaW1hdGlvbiBzdGF0ZSBjbGFzc2VzLlxuICpcbiAqIEByZWFkb25seVxuICogQGVudW0ge0NsYXNzfVxuICovXG5leHBvcnQgY29uc3QgQW5pbWF0aW9uVHlwZXMgPSB7XG4gIHNpbmdsZTogU2luZ2xlU3RhdGUsXG4gIGZyZWVCbGVuZDogRnJlZUJsZW5kU3RhdGUsXG4gIHF1ZXVlOiBRdWV1ZVN0YXRlLFxuICByYW5kb21BbmltYXRpb246IFJhbmRvbUFuaW1hdGlvblN0YXRlLFxuICBibGVuZDFkOiBCbGVuZDFkU3RhdGUsXG4gIGJsZW5kMmQ6IEJsZW5kMmRTdGF0ZSxcbn07XG5cbi8qKlxuICogRmVhdHVyZSBmb3IgbWFuYWdpbmcgYW5pbWF0aW9ucyBvbiBhbiBvYmplY3QuXG4gKlxuICogQGV4dGVuZHMgQWJzdHJhY3RIb3N0RmVhdHVyZVxuICogQGFsaWFzIGNvcmUvQW5pbWF0aW9uRmVhdHVyZVxuICpcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBFVkVOVFMgLSBCdWlsdC1pbiBtZXNzYWdlcyB0aGF0IHRoZSBmZWF0dXJlIGVtaXRzLiBXaGVuIHRoZVxuICogZmVhdHVyZSBpcyBhZGRlZCB0byBhIHtAbGluayBjb3JlL0hvc3RPYmplY3R9LCBldmVudCBuYW1lcyB3aWxsIGJlIHByZWZpeGVkIGJ5IHRoZVxuICogbmFtZSBvZiB0aGUgZmVhdHVyZSBjbGFzcyArICcuJy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLmFkZExheWVyPW9uQWRkTGF5ZXJFdmVudF0gLSBNZXNzYWdlIHRoYXQgaXMgZW1pdHRlZCBhZnRlclxuICogW2FkZExheWVyXXtAbGluayBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjYWRkTGF5ZXJ9IGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBleGVjdXRlZC5cbiAqIEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIG5hbWUgb2YgdGhlIGxheWVyIHRoYXQgd2FzIGFkZGVkIGFuZCBpdHMgaW5kZXggaW5cbiAqIHRoZSBsYXllciBzdGFjayB3aXRoIHRoZSBzaWduYXR1cmUge25hbWU6IHN0cmluZywgaW5kZXg6IG51bWJlcn0gaXMgc3VwcGxpZWRcbiAqIGFzIGFuIGFyZ3VtZW50IHRvIGxpc3RlbmVyIGZ1bmN0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLnJlbW92ZUxheWVyPW9uUmVtb3ZlTGF5ZXJFdmVudF0gLSBNZXNzYWdlIHRoYXQgaXNcbiAqIGVtaXR0ZWQgYWZ0ZXIgW3JlbW92ZUxheWVyXXtAbGluayBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjcmVtb3ZlTGF5ZXJ9IGhhcyBiZWVuXG4gKiBzdWNjZXNzZnVsbHkgZXhlY3V0ZWQuIEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIG5hbWUgb2YgdGhlIGxheWVyIHRoYXQgd2FzXG4gKiByZW1vdmVkIGFuZCBpdHMgaW5kZXggaW4gdGhlIGxheWVyIHN0YWNrIHdpdGggdGhlIHNpZ25hdHVyZSB7bmFtZTogc3RyaW5nLCBpbmRleDogbnVtYmVyfVxuICogaXMgc3VwcGxpZWQgYXMgYW4gYXJndW1lbnQgdG8gbGlzdGVuZXIgZnVuY3Rpb25zLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVFMucmVuYW1lTGF5ZXI9b25SZW5hbWVMYXllckV2ZW50XSAtIE1lc3NhZ2UgdGhhdCBpc1xuICogZW1pdHRlZCBhZnRlciBbcmVuYW1lTGF5ZXJde0BsaW5rIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNyZW5hbWVMYXllcn0gaGFzIGJlZW5cbiAqIHN1Y2Nlc3NmdWxseSBleGVjdXRlZC4gQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgb3JpZ2luYWwgbmFtZSBvZiB0aGUgbGF5ZXJcbiAqIHRoYXQgd2FzIHJlbmFtZWQgYW5kIGl0cyB1cGRhdGVkIG5hbWUgd2l0aCB0aGUgc2lnbmF0dXJlIHtvbGROYW1lOiBzdHJpbmcsIG5ld05hbWU6IHN0cmluZ31cbiAqIGlzIHN1cHBsaWVkIGFzIGFuIGFyZ3VtZW50IHRvIGxpc3RlbmVyIGZ1bmN0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLmFkZEFuaW1hdGlvbj1vbkFkZEFuaW1hdGlvbkV2ZW50XSAtIE1lc3NhZ2UgdGhhdCBpc1xuICogZW1pdHRlZCBhZnRlciBbYWRkQW5pbWF0aW9uXXtAbGluayBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjYWRkQW5pbWF0aW9ufSBoYXMgYmVlblxuICogc3VjY2Vzc2Z1bGx5IGV4ZWN1dGVkLiBBbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBuYW1lIG9mIHRoZSBsYXllciB0aGF0IHRoZVxuICogYW5pbWF0aW9uIHdhcyBhZGRlZCB0byBhbmQgdGhlIG5hbWUgb2YgdGhlIGFuaW1hdGlvbiB0aGF0IHdhcyBhZGRlZCB3aXRoIHRoZVxuICogc2lnbmF0dXJlIHtsYXllck5hbWU6IHN0cmluZywgYW5pbWF0aW9uTmFtZTogc3RyaW5nfSBpcyBzdXBwbGllZCBhcyBhbiBhcmd1bWVudFxuICogdG8gbGlzdGVuZXIgZnVuY3Rpb25zLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVFMucmVtb3ZlQW5pbWF0aW9uPW9uUmVtb3ZlZEFuaW1hdGlvbkV2ZW50XSAtIE1lc3NhZ2VcbiAqIHRoYXQgaXMgZW1pdHRlZCBhZnRlciBbcmVtb3ZlQW5pbWF0aW9uXXtAbGluayBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjcmVtb3ZlQW5pbWF0aW9ufVxuICogaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGV4ZWN1dGVkLiBBbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBuYW1lIG9mIHRoZSBsYXllclxuICogdGhhdCB0aGUgYW5pbWF0aW9uIHdhcyByZW1vdmVkIGZyb20gYW5kIHRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb24gdGhhdCB3YXMgcmVtb3ZlZFxuICogd2l0aCB0aGUgc2lnbmF0dXJlIHtsYXllck5hbWU6IHN0cmluZywgYW5pbWF0aW9uTmFtZTogc3RyaW5nfSBpcyBzdXBwbGllZCBhc1xuICogYW4gYXJndW1lbnQgdG8gbGlzdGVuZXIgZnVuY3Rpb25zLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVFMucmVuYW1lQW5pbWF0aW9uPW9uUmVuYW1lQW5pbWF0aW9uRXZlbnRdIC0gTWVzc2FnZVxuICogdGhhdCBpcyBlbWl0dGVkIGFmdGVyIFtyZW5hbWVBbmltYXRpb25de0BsaW5rIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNyZW5hbWVBbmltYXRpb259XG4gKiBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgZXhlY3V0ZWQuIEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIG5hbWUgb2YgdGhlIGxheWVyXG4gKiB0aGF0IGNvbnRhaW5zIHRoZSBhbmltYXRpb24gdGhhdCB3YXMgcmVuYW1lZCwgdGhlIG9yaWdpbmFsIG5hbWUgb2YgdGhlIGFuaW1hdGlvblxuICogdGhhdCB3YXMgcmVuYW1lZCBhbmQgaXRzIHVwZGF0ZWQgbmFtZSB3aXRoIHRoZSBzaWduYXR1cmUge2xheWVyTmFtZTogc3RyaW5nLCBvbGROYW1lOiBzdHJpbmcsIG5ld05hbWU6IHN0cmluZ31cbiAqIGlzIHN1cHBsaWVkIGFzIGFuIGFyZ3VtZW50IHRvIGxpc3RlbmVyIGZ1bmN0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLnBsYXk9b25QbGF5RXZlbnRdIC0gTWVzc2FnZSB0aGF0IGlzIGVtaXR0ZWQgYWZ0ZXJcbiAqIGVhY2ggY2FsbCB0byBbcGxheV17QGxpbmsgY29yZS9BbmltYXRpb25GZWF0dXJlI3BsYXlBbmltYXRpb259LiBBbiBvYmplY3QgcmVwcmVzZW50aW5nXG4gKiB0aGUgbmFtZSBvZiB0aGUgbGF5ZXIgY29udGFpbnMgdGhlIGFuaW1hdGlvbiB0aGF0IHdhcyBwbGF5ZWQgYW5kIHRoZSBuYW1lIG9mXG4gKiB0aGUgYW5pbWF0aW9uIHRoYXQgd2FzIHBsYXllZCB3aXRoIHRoZSBzaWduYXR1cmUge2xheWVyTmFtZTogc3RyaW5nLCBhbmltYXRpb25OYW1lOiBzdHJpbmd9XG4gKiBpcyBzdXBwbGllZCBhcyBhbiBhcmd1bWVudCB0byBsaXN0ZW5lciBmdW5jdGlvbnMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UUy5wYXVzZT1vblBhdXNlRXZlbnRdIC0gTWVzc2FnZSB0aGF0IGlzIGVtaXR0ZWQgYWZ0ZXJcbiAqIGVhY2ggY2FsbCB0byBbcGF1c2Vde0BsaW5rIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNwYXVzZUFuaW1hdGlvbn0uIEFuIG9iamVjdCByZXByZXNlbnRpbmdcbiAqIHRoZSBuYW1lIG9mIHRoZSBsYXllciBjb250YWlucyB0aGUgYW5pbWF0aW9uIHRoYXQgd2FzIHBhdXNlZCBhbmQgdGhlIG5hbWUgb2ZcbiAqIHRoZSBhbmltYXRpb24gdGhhdCB3YXMgcGF1c2VkIHdpdGggdGhlIHNpZ25hdHVyZSB7bGF5ZXJOYW1lOiBzdHJpbmcsIGFuaW1hdGlvbk5hbWU6IHN0cmluZ31cbiAqIGlzIHN1cHBsaWVkIGFzIGFuIGFyZ3VtZW50IHRvIGxpc3RlbmVyIGZ1bmN0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLnJlc3VtZT1vblJlc3VtZUV2ZW50XSAtIE1lc3NhZ2UgdGhhdCBpcyBlbWl0dGVkIGFmdGVyXG4gKiBlYWNoIGNhbGwgdG8gW3Jlc3VtZV17QGxpbmsgY29yZS9BbmltYXRpb25GZWF0dXJlI3Jlc3VtZUFuaW1hdGlvbn0uIEFuIG9iamVjdCByZXByZXNlbnRpbmdcbiAqIHRoZSBuYW1lIG9mIHRoZSBsYXllciBjb250YWlucyB0aGUgYW5pbWF0aW9uIHRoYXQgd2FzIHJlc3VtZWQgYW5kIHRoZSBuYW1lIG9mXG4gKiB0aGUgYW5pbWF0aW9uIHRoYXQgd2FzIHJlc3VtZWQgd2l0aCB0aGUgc2lnbmF0dXJlIHtsYXllck5hbWU6IHN0cmluZywgYW5pbWF0aW9uTmFtZTogc3RyaW5nfVxuICogaXMgc3VwcGxpZWQgYXMgYW4gYXJndW1lbnQgdG8gbGlzdGVuZXIgZnVuY3Rpb25zLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVFMuaW50ZXJydXB0PW9uSW50ZXJydXB0RXZlbnRdIC0gTWVzc2FnZSB0aGF0IGlzIGVtaXR0ZWRcbiAqIGlmIHRoZXJlIGlzIGEgY3VycmVudCBzcGVlY2ggaW4gcHJvZ3Jlc3MgYW5kIFtwbGF5XXtAbGluayBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjcGxheUFuaW1hdGlvbn1cbiAqIG9yIFtyZXN1bWVde0BsaW5rIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNyZXN1bWVBbmltYXRpb259IGFyZSBleGVjdXRlZCBmb3IgYSBuZXcgc3BlZWNoLlxuICogQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgbmFtZSBvZiB0aGUgbGF5ZXIgY29udGFpbnMgdGhlIGFuaW1hdGlvbiB0aGF0IHdhc1xuICogaW50ZXJydXB0ZWQgYW5kIHRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb24gdGhhdCB3YXMgaW50ZXJydXB0ZWQgd2l0aCB0aGUgc2lnbmF0dXJlXG4gKiB7bGF5ZXJOYW1lOiBzdHJpbmcsIGFuaW1hdGlvbk5hbWU6IHN0cmluZ30gaXMgc3VwcGxpZWQgYXMgYW4gYXJndW1lbnQgdG8gbGlzdGVuZXJcbiAqIGZ1bmN0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLnN0b3A9b25TdG9wRXZlbnRdIC0gTWVzc2FnZSB0aGF0IGlzIGVtaXR0ZWQgYWZ0ZXJcbiAqIGVhY2ggY2FsbCB0byBbc3RvcF17QGxpbmsgY29yZS9BbmltYXRpb25GZWF0dXJlI3N0b3BBbmltYXRpb259IGFuZCB3aGVuIGEgc3BlZWNoIHJlYWNoZXNcbiAqIHRoZSBlbmQgb2YgcGxheWJhY2suIEFuIG9iamVjdCByZXByZXNlbnRpbmdcbiAqIHRoZSBuYW1lIG9mIHRoZSBsYXllciBjb250YWlucyB0aGUgYW5pbWF0aW9uIHRoYXQgd2FzIHN0b3BwZWQgYW5kIHRoZSBuYW1lIG9mXG4gKiB0aGUgYW5pbWF0aW9uIHRoYXQgd2FzIHN0b3BwZWQgd2l0aCB0aGUgc2lnbmF0dXJlIHtsYXllck5hbWU6IHN0cmluZywgYW5pbWF0aW9uTmFtZTogc3RyaW5nfVxuICogaXMgc3VwcGxpZWQgYXMgYW4gYXJndW1lbnQgdG8gbGlzdGVuZXIgZnVuY3Rpb25zLlxuICovXG5jbGFzcyBBbmltYXRpb25GZWF0dXJlIGV4dGVuZHMgQWJzdHJhY3RIb3N0RmVhdHVyZSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtIHtjb3JlL0hvc3RPYmplY3R9IGhvc3QgLSBIb3N0IG9iamVjdCB0aGF0IG93bnMgdGhlIGZlYXR1cmUuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihob3N0KSB7XG4gICAgc3VwZXIoaG9zdCk7XG5cbiAgICB0aGlzLl9sYXllcnMgPSBbXTtcbiAgICB0aGlzLl9sYXllck1hcCA9IHt9O1xuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2Ugc3VyZSBhIHN1cHBsaWVkIGxheWVyIGluZGV4IGlzIHdpdGhpbiB0aGUgcmFuZ2Ugb2YgbGF5ZXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtib29sZWFufSBbZXhpc3Rpbmc9dHJ1ZV0gLSBXaGV0aGVyIHRoZSBpbmRleCByZXByZXNlbnRzIGFuZCBleGlzdGluZ1xuICAgKiBsYXllciBvciBhIG5ldyBsYXllciB0byBiZSBhZGRlZC5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlcj19XG4gICAqL1xuICBfdmFsaWRhdGVJbmRleChpbmRleCwgZXhpc3RpbmcgPSB0cnVlKSB7XG4gICAgLy8gSW5kZXggaXMgaW52YWxpZCBpZiB0aGVyZSBhcmUgbm8gbGF5ZXJzIGFuZCB3ZSdyZSBjaGVja2luZyBmb3IgYW4gZXhpc3RpbmcgbGF5ZXIgaW5kZXhcbiAgICBpZiAodGhpcy5fbGF5ZXJzLmxlbmd0aCA9PT0gMCAmJiBleGlzdGluZykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCBsYXN0SW5kZXggPSBleGlzdGluZyA/IHRoaXMuX2xheWVycy5sZW5ndGggLSAxIDogdGhpcy5fbGF5ZXJzLmxlbmd0aDtcblxuICAgIC8vIENvdW50IGZyb20gdGhlIGVuZCBvZiB0aGUgYXJyYXkgZm9yIG5lZ2F0aXZlIGluZGljZXNcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICBpbmRleCA9IGxhc3RJbmRleCArIGluZGV4ICsgMTtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlLWV2YWx1YXRlIGludGVybmFsIHdlaWdodCB2YWx1ZXMgb2YgbGF5ZXJzIHN0YXJ0aW5nIGZyb20gdGhlIHRvcCBvZiB0aGVcbiAgICogc3RhY2suIE92ZXJyaWRlIGxheWVycycgd2VpZ2h0cyBhZmZlY3QgdGhlIHZhbHVlcyBvZiBhbGwgbGF5ZXJzIGxvd2VyIGluIHRoZVxuICAgKiBzdGFjay5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVJbnRlcm5hbFdlaWdodHMoKSB7XG4gICAgY29uc3QgbnVtTGF5ZXJzID0gdGhpcy5fbGF5ZXJzLmxlbmd0aDtcbiAgICBsZXQgd2VpZ2h0TXVsdGlwbGllciA9IDE7XG5cbiAgICAvLyBVcGRhdGUgaW50ZXJuYWwgd2VpZ2h0IHZhbHVlcyBvbiBsYXllcnMgaW4gcmV2ZXJzZSBvcmRlclxuICAgIGZvciAobGV0IGkgPSBudW1MYXllcnMgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllcnNbaV07XG4gICAgICBsYXllci51cGRhdGVJbnRlcm5hbFdlaWdodCh3ZWlnaHRNdWx0aXBsaWVyKTtcblxuICAgICAgLy8gSWYgdGhlIGxheWVyIGlzIG92ZXJyaWRlLCB1cGRhdGUgdGhlIG11bHRpcGxpZXIgd2l0aCB0aGUgcmVtYWluZGVyIG9mIHRoZSBmdWxsIHdlaWdodFxuICAgICAgaWYgKGxheWVyLmJsZW5kTW9kZSA9PT0gTGF5ZXJCbGVuZE1vZGVzLk92ZXJyaWRlICYmIGxheWVyLmN1cnJlbnRTdGF0ZSkge1xuICAgICAgICB3ZWlnaHRNdWx0aXBsaWVyICo9IDEgLSBsYXllci5jdXJyZW50U3RhdGUuaW50ZXJuYWxXZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIG5ldyBpbnN0YW5jZSBvZiBhIFNpbmdsZVN0YXRlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gcGFzcyB0byB0aGUgU2luZ2xlU3RhdGUgY29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0aW9ucy5uYW1lIC0gTmFtZSBmb3IgdGhlIGFuaW1hdGlvbiBzdGF0ZS4gTmFtZXMgbXVzdCBiZVxuICAgKiB1bmlxdWUgZm9yIHRoZSBsYXllciB0aGUgc3RhdGUgaXMgYXBwbGllZCB0by5cbiAgICogQHBhcmFtIHt3ZWlnaHR9IFtvcHRpb25zLndlaWdodD0wXSAtIFRoZSAwLTEgYW1vdW50IG9mIGluZmx1ZW5jZSB0aGUgc3RhdGUgd2lsbCBoYXZlLlxuICAgKiBAcGFyYW0ge3RpbWVTY2FsZX0gW29wdGlvbnMudGltZVNjYWxlPTFdIC0gRmFjdG9yIHRvIHNjYWxlIHRoZSBwbGF5YmFjayBzcGVlZCBvZiB0aGVcbiAgICogYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubG9vcENvdW50PUluZmluaXR5XSAtIE51bWJlciBvZiB0aW1lcyB0aGUgYW5pbWF0aW9uIHNob3VsZFxuICAgKiByZXBlYXQgYmVmb3JlIGZpbmlzaGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmJsZW5kTW9kZT1MYXllckJsZW5kTW9kZXNbRGVmYXVsdExheWVyQmxlbmRNb2RlXV0gLSBUeXBlIG9mXG4gICAqIGJsZW5kaW5nIHRoZSBhbmltYXRpb24gc2hvdWxkIHVzZS5cbiAgICpcbiAgICogQHJldHVybnMge2NvcmUvU2luZ2xlU3RhdGV9XG4gICAqL1xuICBfY3JlYXRlU2luZ2xlU3RhdGUob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU2luZ2xlU3RhdGUob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgbmV3IGluc3RhbmNlIG9mIGEgRnJlZUJsZW5kU3RhdGUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyB0byBwYXNzIHRvIHRoZSBGcmVlQmxlbmRTdGF0ZSBjb25zdHJ1Y3Rvci5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRpb25zLm5hbWUgLSBOYW1lIGZvciB0aGUgYW5pbWF0aW9uIHN0YXRlLiBOYW1lcyBtdXN0IGJlXG4gICAqIHVuaXF1ZSBmb3IgdGhlIGxheWVyIHRoZSBzdGF0ZSBpcyBhcHBsaWVkIHRvLlxuICAgKiBAcGFyYW0ge3dlaWdodH0gW29wdGlvbnMud2VpZ2h0PTBdIC0gVGhlIDAtMSBhbW91bnQgb2YgaW5mbHVlbmNlIHRoZSBzdGF0ZSB3aWxsIGhhdmUuXG4gICAqIEBwYXJhbSB7dGltZVNjYWxlfSBbb3B0aW9ucy50aW1lU2NhbGU9MV0gLSBGYWN0b3IgdG8gc2NhbGUgdGhlIHBsYXliYWNrIHNwZWVkIG9mIHRoZVxuICAgKiBhbmltYXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5sb29wQ291bnQ9SW5maW5pdHldIC0gTnVtYmVyIG9mIHRpbWVzIHRoZSBhbmltYXRpb24gc2hvdWxkXG4gICAqIHJlcGVhdCBiZWZvcmUgZmluaXNoaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYmxlbmRNb2RlPUxheWVyQmxlbmRNb2Rlc1tEZWZhdWx0TGF5ZXJCbGVuZE1vZGVdXSAtIFR5cGUgb2ZcbiAgICogYmxlbmRpbmcgdGhlIGFuaW1hdGlvbiBzaG91bGQgdXNlLlxuICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBbb3B0aW9ucy5ibGVuZFN0YXRlT3B0aW9uc10gLSBBcnJheSBvZiBvcHRpb25zIHVzZWQgdG8gY3JlYXRlIHRoZVxuICAgKiBibGVuZCBzdGF0ZXMgZm9yIHRoaXMgY29udGFpbmVyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7RnJlZUJsZW5kU3RhdGV9XG4gICAqL1xuICBfY3JlYXRlRnJlZUJsZW5kU3RhdGUob3B0aW9ucykge1xuICAgIGNvbnN0IHtibGVuZFN0YXRlT3B0aW9ucyA9IFtdfSA9IG9wdGlvbnM7XG5cbiAgICBjb25zdCBibGVuZFN0YXRlcyA9IFtdO1xuICAgIGJsZW5kU3RhdGVPcHRpb25zLmZvckVhY2goYmxlbmRPcHRpb25zID0+IHtcbiAgICAgIGJsZW5kU3RhdGVzLnB1c2goXG4gICAgICAgIHRoaXMuX2NyZWF0ZVNpbmdsZVN0YXRlKHsuLi5ibGVuZE9wdGlvbnMsIGJsZW5kTW9kZTogb3B0aW9ucy5ibGVuZE1vZGV9KVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBuZXcgRnJlZUJsZW5kU3RhdGUob3B0aW9ucywgYmxlbmRTdGF0ZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIG5ldyBpbnN0YW5jZSBvZiBhIFF1ZXVlU3RhdGUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyB0byBwYXNzIHRvIHRoZSBRdWV1ZVN0YXRlIGNvbnN0cnVjdG9yLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdGlvbnMubmFtZSAtIE5hbWUgZm9yIHRoZSBhbmltYXRpb24gc3RhdGUuIE5hbWVzIG11c3QgYmVcbiAgICogdW5pcXVlIGZvciB0aGUgbGF5ZXIgdGhlIHN0YXRlIGlzIGFwcGxpZWQgdG8uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy53ZWlnaHQ9MF0gLSBUaGUgMC0xIGFtb3VudCBvZiBpbmZsdWVuY2UgdGhlIHN0YXRlIHdpbGwgaGF2ZS5cbiAgICogQHBhcmFtIHtudW1iZXI9fSBvcHRpb25zLnRyYW5zaXRpb25UaW1lIC0gVGhlIGFtb3VudCBvZiB0aW1lIGl0IHRha2VzIHRvIHRyYW5zaXRpb25cbiAgICogYmV0d2VlbiBxdWV1ZWQgc3RhdGVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYmxlbmRNb2RlPUxheWVyQmxlbmRNb2Rlc1tEZWZhdWx0TGF5ZXJCbGVuZE1vZGVdXSAtIFR5cGUgb2ZcbiAgICogYmxlbmRpbmcgdGhlIGFuaW1hdGlvbiBzaG91bGQgdXNlLlxuICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBbb3B0aW9ucy5xdWV1ZU9wdGlvbnNdIC0gQXJyYXkgb2Ygb3B0aW9ucyB1c2VkIHRvIGNyZWF0ZSB0aGVcbiAgICogcXVldWUgc3RhdGVzIGZvciB0aGlzIGNvbnRhaW5lci5cbiAgICpcbiAgICogQHJldHVybnMge1F1ZXVlU3RhdGV9XG4gICAqL1xuICBfY3JlYXRlUXVldWVTdGF0ZShvcHRpb25zKSB7XG4gICAgY29uc3Qge3F1ZXVlT3B0aW9ucyA9IFtdfSA9IG9wdGlvbnM7XG5cbiAgICBjb25zdCBxdWV1ZVN0YXRlcyA9IHF1ZXVlT3B0aW9ucy5tYXAocXVldWVPcHRpb24gPT5cbiAgICAgIHRoaXMuX2NyZWF0ZVNpbmdsZVN0YXRlKHtcbiAgICAgICAgdHJhbnNpdGlvblRpbWU6IG9wdGlvbnMudHJhbnNpdGlvblRpbWUsXG4gICAgICAgIC4uLnF1ZXVlT3B0aW9uLFxuICAgICAgICBibGVuZE1vZGU6IG9wdGlvbnMuYmxlbmRNb2RlLFxuICAgICAgfSlcbiAgICApO1xuXG4gICAgcmV0dXJuIG5ldyBRdWV1ZVN0YXRlKG9wdGlvbnMsIHF1ZXVlU3RhdGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBuZXcgaW5zdGFuY2Ugb2YgYSBCbGVuZDFkU3RhdGUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyB0byBwYXNzIHRvIHRoZSBCbGVuZDFkU3RhdGUgY29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0aW9ucy5uYW1lIC0gTmFtZSBmb3IgdGhlIGFuaW1hdGlvbiBzdGF0ZS4gTmFtZXMgbXVzdCBiZVxuICAgKiB1bmlxdWUgZm9yIHRoZSBsYXllciB0aGUgc3RhdGUgaXMgYXBwbGllZCB0by5cbiAgICogQHBhcmFtIHt3ZWlnaHR9IFtvcHRpb25zLndlaWdodD0wXSAtIFRoZSAwLTEgYW1vdW50IG9mIGluZmx1ZW5jZSB0aGUgc3RhdGUgd2lsbCBoYXZlLlxuICAgKiBAcGFyYW0ge3RpbWVTY2FsZX0gW29wdGlvbnMudGltZVNjYWxlPTFdIC0gRmFjdG9yIHRvIHNjYWxlIHRoZSBwbGF5YmFjayBzcGVlZCBvZiB0aGVcbiAgICogYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubG9vcENvdW50PUluZmluaXR5XSAtIE51bWJlciBvZiB0aW1lcyB0aGUgYW5pbWF0aW9uIHNob3VsZFxuICAgKiByZXBlYXQgYmVmb3JlIGZpbmlzaGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmJsZW5kTW9kZT1MYXllckJsZW5kTW9kZXNbRGVmYXVsdExheWVyQmxlbmRNb2RlXV0gLSBUeXBlIG9mXG4gICAqIGJsZW5kaW5nIHRoZSBhbmltYXRpb24gc2hvdWxkIHVzZS5cbiAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gW29wdGlvbnMuYmxlbmRTdGF0ZU9wdGlvbnNdIC0gQXJyYXkgb2Ygb3B0aW9ucyB1c2VkIHRvIGNyZWF0ZSB0aGVcbiAgICogYmxlbmQgc3RhdGVzIGZvciB0aGlzIGNvbnRhaW5lci5cbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW29wdGlvbnMuYmxlbmRUaHJlc2hvbGRzXSAtIEFycmF5IG9mIG51bWJlcnMgdXNlZCB0byBzZXQgdGhlXG4gICAqIHRocmVzaG9sZHMgZm9yIGVhY2ggYmxlbmQgc3RhdGUgaW4gdGhpcyBjb250YWluZXIuXG4gICAqIEBwYXJhbSB7QXJyYXkuPGJvb2xlYW4+fSBbb3B0aW9ucy5ibGVuZE1hdGNoUGhhc2VzPVtdXSAtIE9wdGlvbmFsIGFycmF5IG9mIGJvb2xlYW5zIHVzZWQgdG9cbiAgICogc2V0IHdoZXRoZXIgb3Igbm90IGVhY2ggYmxlbmQgc3RhdGUgaW4gdGhpcyBjb250YWluZXIgd2lsbCBtYXRjaCBwaGFzZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtCbGVuZDFkU3RhdGV9XG4gICAqL1xuICBfY3JlYXRlQmxlbmQxZFN0YXRlKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7YmxlbmRTdGF0ZU9wdGlvbnMgPSBbXX0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHtibGVuZFRocmVzaG9sZHMgPSBbXX0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHtibGVuZE1hdGNoUGhhc2VzID0gW119ID0gb3B0aW9ucztcblxuICAgIGNvbnN0IGJsZW5kU3RhdGVzID0gW107XG4gICAgYmxlbmRTdGF0ZU9wdGlvbnMuZm9yRWFjaChibGVuZE9wdGlvbnMgPT4ge1xuICAgICAgYmxlbmRTdGF0ZXMucHVzaChcbiAgICAgICAgdGhpcy5fY3JlYXRlU2luZ2xlU3RhdGUoey4uLmJsZW5kT3B0aW9ucywgYmxlbmRNb2RlOiBvcHRpb25zLmJsZW5kTW9kZX0pXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyBCbGVuZDFkU3RhdGUoXG4gICAgICBvcHRpb25zLFxuICAgICAgYmxlbmRTdGF0ZXMsXG4gICAgICBibGVuZFRocmVzaG9sZHMsXG4gICAgICBibGVuZE1hdGNoUGhhc2VzXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBuZXcgaW5zdGFuY2Ugb2YgYSBCbGVuZDJkU3RhdGUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyB0byBwYXNzIHRvIHRoZSBCbGVuZDFkU3RhdGUgY29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0aW9ucy5uYW1lIC0gTmFtZSBmb3IgdGhlIGFuaW1hdGlvbiBzdGF0ZS4gTmFtZXMgbXVzdCBiZVxuICAgKiB1bmlxdWUgZm9yIHRoZSBsYXllciB0aGUgc3RhdGUgaXMgYXBwbGllZCB0by5cbiAgICogQHBhcmFtIHt3ZWlnaHR9IFtvcHRpb25zLndlaWdodD0wXSAtIFRoZSAwLTEgYW1vdW50IG9mIGluZmx1ZW5jZSB0aGUgc3RhdGUgd2lsbCBoYXZlLlxuICAgKiBAcGFyYW0ge3RpbWVTY2FsZX0gW29wdGlvbnMudGltZVNjYWxlPTFdIC0gRmFjdG9yIHRvIHNjYWxlIHRoZSBwbGF5YmFjayBzcGVlZCBvZiB0aGVcbiAgICogYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubG9vcENvdW50PUluZmluaXR5XSAtIE51bWJlciBvZiB0aW1lcyB0aGUgYW5pbWF0aW9uIHNob3VsZFxuICAgKiByZXBlYXQgYmVmb3JlIGZpbmlzaGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmJsZW5kTW9kZT1MYXllckJsZW5kTW9kZXNbRGVmYXVsdExheWVyQmxlbmRNb2RlXV0gLSBUeXBlIG9mXG4gICAqIGJsZW5kaW5nIHRoZSBhbmltYXRpb24gc2hvdWxkIHVzZS5cbiAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gW29wdGlvbnMuYmxlbmRTdGF0ZU9wdGlvbnNdIC0gQXJyYXkgb2Ygb3B0aW9ucyB1c2VkIHRvIGNyZWF0ZSB0aGVcbiAgICogYmxlbmQgc3RhdGVzIGZvciB0aGlzIGNvbnRhaW5lci5cbiAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBbb3B0aW9ucy5ibGVuZFRocmVzaG9sZHNdIC0gQXJyYXkgb2YgQXJyYXkgb2YgbnVtYmVycyB1c2VkIHRvIHNldCB0aGVcbiAgICogdGhyZXNob2xkcyBmb3IgZWFjaCBibGVuZCBzdGF0ZSBpbiB0aGlzIGNvbnRhaW5lci5cbiAgICogQHBhcmFtIHtBcnJheS48Ym9vbGVhbj59IFtvcHRpb25zLmJsZW5kTWF0Y2hQaGFzZXM9W11dIC0gT3B0aW9uYWwgYXJyYXkgb2YgYm9vbGVhbnMgdXNlZCB0b1xuICAgKiBzZXQgd2hldGhlciBvciBub3QgZWFjaCBibGVuZCBzdGF0ZSBpbiB0aGlzIGNvbnRhaW5lciB3aWxsIG1hdGNoIHBoYXNlcy5cbiAgICpcbiAgICogQHJldHVybnMge0JsZW5kMWRTdGF0ZX1cbiAgICovXG4gIF9jcmVhdGVCbGVuZDJkU3RhdGUob3B0aW9ucykge1xuICAgIGNvbnN0IHtibGVuZFN0YXRlT3B0aW9ucyA9IFtdfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qge2JsZW5kVGhyZXNob2xkcyA9IFtdfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qge2JsZW5kTWF0Y2hQaGFzZXMgPSBbXX0gPSBvcHRpb25zO1xuXG4gICAgY29uc3QgYmxlbmRTdGF0ZXMgPSBbXTtcbiAgICBibGVuZFN0YXRlT3B0aW9ucy5mb3JFYWNoKGJsZW5kT3B0aW9ucyA9PiB7XG4gICAgICBibGVuZFN0YXRlcy5wdXNoKFxuICAgICAgICB0aGlzLl9jcmVhdGVTaW5nbGVTdGF0ZSh7Li4uYmxlbmRPcHRpb25zLCBibGVuZE1vZGU6IG9wdGlvbnMuYmxlbmRNb2RlfSlcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmV3IEJsZW5kMmRTdGF0ZShcbiAgICAgIG9wdGlvbnMsXG4gICAgICBibGVuZFN0YXRlcyxcbiAgICAgIGJsZW5kVGhyZXNob2xkcyxcbiAgICAgIGJsZW5kTWF0Y2hQaGFzZXNcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIG5ldyBpbnN0YW5jZSBvZiBhIFJhbmRvbUFuaW1hdGlvblN0YXRlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gcGFzcyB0byB0aGUgUmFuZG9tQW5pbWF0aW9uU3RhdGUgY29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0aW9ucy5uYW1lIC0gTmFtZSBmb3IgdGhlIGFuaW1hdGlvbiBzdGF0ZS4gTmFtZXMgbXVzdCBiZVxuICAgKiB1bmlxdWUgZm9yIHRoZSBsYXllciB0aGUgc3RhdGUgaXMgYXBwbGllZCB0by5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnBsYXlJbnRlcnZhbD0zXSAtIFRoZSBiYXNlIGFuaW1hdGlvbiBwbGF5YmFjayBpbnRlcnZhbC5cbiAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gW29wdGlvbnMuc3ViU3RhdGVPcHRpb25zXSAtIEFycmF5IG9mIG9wdGlvbnMgdXNlZCB0byBjcmVhdGUgdGhlXG4gICAqIHN1YiBzdGF0ZXMgZm9yIHRoaXMgY29udGFpbmVyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UmFuZG9tQW5pbWF0aW9uU3RhdGV9XG4gICAqL1xuICBfY3JlYXRlUmFuZG9tQW5pbWF0aW9uU3RhdGUob3B0aW9ucykge1xuICAgIGNvbnN0IHtzdWJTdGF0ZU9wdGlvbnMgPSBbXX0gPSBvcHRpb25zO1xuXG4gICAgY29uc3Qgc3ViU3RhdGVzID0gW107XG4gICAgc3ViU3RhdGVPcHRpb25zLmZvckVhY2goc3ViU3RhdGVPcHRpb25zID0+IHtcbiAgICAgIHN1YlN0YXRlcy5wdXNoKFxuICAgICAgICB0aGlzLl9jcmVhdGVTaW5nbGVTdGF0ZSh7XG4gICAgICAgICAgLi4uc3ViU3RhdGVPcHRpb25zLFxuICAgICAgICAgIGJsZW5kTW9kZTogb3B0aW9ucy5ibGVuZE1vZGUsXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyBSYW5kb21BbmltYXRpb25TdGF0ZShvcHRpb25zLCBzdWJTdGF0ZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2Ugc3VyZSB0aGUgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBleGlzdHMgYW5kIHJldHVybiBhIHVuaXF1ZSB2ZXJzaW9uXG4gICAqIG9mIHRoZSBhbmltYXRpb24gbmFtZSBzdXBwbGllZCBmb3IgdGhhdCBsYXllci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRvIGNoZWNrIGFnYWluc3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbmltYXRpb25OYW1lIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRvIHZhbGlkYXRlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBWYWxpZGF0ZWQgYW5pbWF0aW9uIG5hbWUuXG4gICAqL1xuICBfdmFsaWRhdGVOZXdBbmltYXRpb24obGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBsYXllck5hbWUgaXMgdmFsaWRcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW2xheWVyTmFtZV07XG5cbiAgICBpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGFkZCBhbmltYXRpb24gdG8gbGF5ZXIgJHtsYXllck5hbWV9IGZyb20gaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBsYXllciBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlIGFuaW1hdGlvbk5hbWUgaXMgdW5pcXVlXG4gICAgY29uc3QgbmFtZSA9IFV0aWxzLmdldFVuaXF1ZU5hbWUoYW5pbWF0aW9uTmFtZSwgbGF5ZXIuZ2V0U3RhdGVOYW1lcygpKTtcblxuICAgIGlmIChuYW1lICE9PSBhbmltYXRpb25OYW1lKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBBbmltYXRpb24gbmFtZSAke2FuaW1hdGlvbk5hbWV9IGlzIG5vdCB1bmlxdWUgZm9yIGxheWVyICR7bGF5ZXIubmFtZX0uIEFuaW1hdGlvbiB3aWxsIGJlIHJlbmFtZWQgdG8gJHtuYW1lfS5gXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBuYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgd2hldGhlciBvciBub3QgYWxsIGFuaW1hdGlvbnMgYXJlIHBhdXNlZC5cbiAgICpcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IHBhdXNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGF1c2VkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW4gYXJyYXkgb2YgbmFtZXMgb2YgYW5pbWF0aW9uIGxheWVycy5cbiAgICpcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAgICovXG4gIGdldCBsYXllcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xheWVycy5tYXAobGF5ZXIgPT4gbGF5ZXIubmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuZCBzdG9yZSBhIG5ldyBhbmltYXRpb24gbGF5ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZT0nTmV3TGF5ZXInXSAtIE5hbWUgZm9yIHRoZSBsYXllci5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSAtIE9wdGlvbnMgdG8gcGFzcyB0byB7QGxpbmsgQW5pbWF0aW9uTGF5ZXIjY29uc3RydWN0b3J9XG4gICAqIEBwYXJhbSB7aW5kZXg9fSBpbmRleCAtIEluZGV4IHRvIGluc2VydCB0aGUgbmV3IGxheWVyIGF0LiBJZiBub25lIGlzIHByb3ZpZGVkXG4gICAqIGl0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIGVuZCBvZiB0aGUgc3RhY2suXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IEluZGV4IG9mIHRoZSBuZXcgbGF5ZXIuXG4gICAqL1xuICBhZGRMYXllcihuYW1lID0gJ05ld0xheWVyJywgb3B0aW9ucyA9IHt9LCBpbmRleCkge1xuICAgIGNvbnN0IG51bUxheWVycyA9IHRoaXMuX2xheWVycy5sZW5ndGg7XG4gICAgbGV0IGxheWVySW5kZXggPSBpbmRleDtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgZ2l2ZW4gaW5kZXggaXMgd2l0aGluIHRoZSByYW5nZSBvZiBsYXllcnNcbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCB8fCBpbmRleCA9PT0gLTEpIHtcbiAgICAgIGxheWVySW5kZXggPSB0aGlzLl9sYXllcnMubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXllckluZGV4ID0gdGhpcy5fdmFsaWRhdGVJbmRleChpbmRleCwgZmFsc2UpO1xuXG4gICAgICBpZiAobGF5ZXJJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIEluc2VydCBhdCB0aGUgYmVnaW5uaW5nIGlmIHRoZSB1c2VyIHBhc3NlZCBpbiBhIG5lZ2F0aXZlIGluZGV4XG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICBsYXllckluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UgYXBwZW5kIHRvIHRoZSBlbmRcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbGF5ZXJJbmRleCA9IHRoaXMuX2xheWVycy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgYEluZGV4ICR7aW5kZXh9IGlzIGludmFsaWQgZm9yIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTmV3IGxheWVyIHdpbGwgYmUgYWRkZWQgYXQgdGhlIGNsb3Nlc3QgdmFsaWQgaW5kZXg6ICR7bGF5ZXJJbmRleH0uYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgbGF5ZXIgbmFtZSBpcyB1bmlxdWVcbiAgICBjb25zdCBsYXllck5hbWUgPSBVdGlscy5nZXRVbmlxdWVOYW1lKG5hbWUsIE9iamVjdC5rZXlzKHRoaXMuX2xheWVyTWFwKSk7XG5cbiAgICBpZiAobmFtZSAhPT0gbGF5ZXJOYW1lKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBMYXllciBuYW1lICR7bmFtZX0gaXMgbm90IHVuaXF1ZS4gTmV3IGxheWVyIHdpbGwgYmUgYWRkZWQgd2l0aCB0aGUgbmFtZSAke2xheWVyTmFtZX0uYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBsYXllciA9IG5ldyBBbmltYXRpb25MYXllcih7Li4ub3B0aW9ucywgbmFtZTogbGF5ZXJOYW1lfSk7XG4gICAgdGhpcy5fbGF5ZXJNYXBbbGF5ZXJOYW1lXSA9IGxheWVyO1xuXG4gICAgaWYgKGxheWVySW5kZXggPT09IG51bUxheWVycykge1xuICAgICAgdGhpcy5fbGF5ZXJzLnB1c2gobGF5ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9sYXllcnMuc3BsaWNlKGxheWVySW5kZXgsIDAsIGxheWVyKTtcbiAgICB9XG5cbiAgICAvLyBOb3RpZnkgdGhhdCBhIGxheWVyIGhhcyBiZWVuIGFkZGVkIHRvIHRoZSBmZWF0dXJlXG4gICAgY29uc3QgZXZlbnREYXRhID0ge25hbWU6IGxheWVyTmFtZSwgaW5kZXg6IGxheWVySW5kZXh9O1xuICAgIHRoaXMuZW1pdCh0aGlzLmNvbnN0cnVjdG9yLkVWRU5UUy5hZGRMYXllciwgZXZlbnREYXRhKTtcblxuICAgIHJldHVybiBldmVudERhdGE7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGFuaW1hdGlvbiBsYXllciBmcm9tIHRoZSBzdGFjay4gQW5pbWF0aW9ucyBvbiB0aGlzIGxheWVyIHdpbGwgbm9cbiAgICogbG9uZ2VyIGJlIGV2YWx1YXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIGZvciB0aGUgbGF5ZXIgdG8gcmVtb3ZlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgcmVtb3ZhbCB3YXMgc3VjY2Vzc2Z1bC5cbiAgICovXG4gIHJlbW92ZUxheWVyKG5hbWUpIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW25hbWVdO1xuXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYERpZCBub3QgcmVtb3ZlIGxheWVyICR7bmFtZX0gZnJvbSBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5vIGxheWVyIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gXG4gICAgICApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxheWVyLmRpc2NhcmQoKTtcblxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fbGF5ZXJzLmluZGV4T2YobGF5ZXIpO1xuICAgIHRoaXMuX2xheWVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIGRlbGV0ZSB0aGlzLl9sYXllck1hcFtuYW1lXTtcblxuICAgIC8vIE5vdGlmeSB0aGF0IGEgbGF5ZXIgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBmZWF0dXJlXG4gICAgdGhpcy5lbWl0KHRoaXMuY29uc3RydWN0b3IuRVZFTlRTLnJlbW92ZUxheWVyLCB7bmFtZSwgaW5kZXh9KTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlLW9yZGVyIHRoZSBsYXllciBzdGFjayBzbyB0aGF0IHRoZSBsYXllciB3aXRoIHRoZSBnaXZlbiBuYW1lIGlzIHBvc2l0aW9uZWRcbiAgICogYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRvIG1vdmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIE5ldyBpbmRleCB0byBwb3NpdGlvbiB0aGUgbGF5ZXIgYXQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBuZXcgaW5kZXggb2YgdGhlIGxheWVyXG4gICAqL1xuICBtb3ZlTGF5ZXIobmFtZSwgaW5kZXgpIHtcbiAgICAvLyBNYWtlIHN1cmUgdGhlIG5hbWUgaXMgdmFsaWRcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW25hbWVdO1xuXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBtb3ZlIGxheWVyICR7bmFtZX0gZnJvbSBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5vIGxheWVyIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgaW5kZXggZmFsbHMgaW4gdGhlIHJhbmdlIG9mIGV4aXN0aW5nIGxheWVyc1xuICAgIGNvbnN0IGxheWVySW5kZXggPSB0aGlzLl92YWxpZGF0ZUluZGV4KGluZGV4LCB0cnVlKTtcbiAgICBjb25zdCBsYXN0SW5kZXggPSB0aGlzLl9sYXllcnMubGVuZ3RoIC0gMTtcblxuICAgIGlmIChsYXllckluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBtb3ZlIGxheWVyICR7bmFtZX0gZnJvbSBob3N0ICR7dGhpcy5faG9zdC5pZH0gdG8gaW5kZXggJHtpbmRleH0uIEluZGV4IG11c3QgYmUgaW4gdGhlIDAgLSAke2xhc3RJbmRleH0gcmFuZ2UuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJyZW50SW5kZXggPSB0aGlzLl9sYXllcnMuaW5kZXhPZihsYXllcik7XG4gICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gbGF5ZXJJbmRleCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBmcm9tIHRoZSBjdXJyZW50IHBvc2l0aW9uXG4gICAgdGhpcy5fbGF5ZXJzLnNwbGljZShjdXJyZW50SW5kZXgsIDEpO1xuXG4gICAgLy8gSW5zZXJ0IGF0IHRoZSBuZXcgcG9zaXRpb25cbiAgICBpZiAobGF5ZXJJbmRleCA9PT0gbGFzdEluZGV4KSB7XG4gICAgICB0aGlzLl9sYXllcnMucHVzaChsYXllcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xheWVycy5zcGxpY2UobGF5ZXJJbmRleCwgMCwgbGF5ZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBsYXllckluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgbmFtZSBvZiBhIGxheWVyLiBOYW1lcyBtdXN0IGJlIHVuaXF1ZSwgaWYgdGhlIG5ldyBuYW1lIGlzIG5vdFxuICAgKiB1bmlxdWUgaXQgd2lsbCBoYXZlIHRyYWlsaW5nIG51bWJlcnMgYXBwZW5kZWQgdW50aWwgaXQgaXMgdW5pcXVlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY3VycmVudE5hbWUgLSBDdXJyZW50IG5hbWUgb2YgdGhlIGxheWVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3TmFtZSAtIE5ldyBuYW1lIHRvIHNldCBvbiB0aGUgbGF5ZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBuZXcgbmFtZSBvZiB0aGUgbGF5ZXJcbiAgICovXG4gIHJlbmFtZUxheWVyKGN1cnJlbnROYW1lLCBuZXdOYW1lKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBuYW1lIGlzIHZhbGlkXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllck1hcFtjdXJyZW50TmFtZV07XG5cbiAgICBpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IHJlbmFtZSBsYXllciAke2N1cnJlbnROYW1lfSBmcm9tIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTm8gbGF5ZXIgZXhpc3RzIHdpdGggdGhpcyBuYW1lLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBsYXllciBuYW1lIGlzIHVuaXF1ZVxuICAgIGNvbnN0IG5hbWUgPSBVdGlscy5nZXRVbmlxdWVOYW1lKG5ld05hbWUsIE9iamVjdC5rZXlzKHRoaXMuX2xheWVyTWFwKSk7XG5cbiAgICBpZiAobmFtZSAhPT0gbmV3TmFtZSkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgTGF5ZXIgbmFtZSAke25ld05hbWV9IGlzIG5vdCB1bmlxdWUuIExheWVyIHdpbGwgYmUgcmVuYW1lZCB0byAke25hbWV9LmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZGVsZXRlIHRoaXMuX2xheWVyTWFwW2N1cnJlbnROYW1lXTtcbiAgICB0aGlzLl9sYXllck1hcFtuYW1lXSA9IGxheWVyO1xuICAgIGxheWVyLm5hbWUgPSBuYW1lO1xuXG4gICAgLy8gTm90aWZ5IHRoYXQgYSBsYXllciBoYXMgYmVlbiByZW5hbWVkIG9uIHRoZSBmZWF0dXJlXG4gICAgdGhpcy5lbWl0KHRoaXMuY29uc3RydWN0b3IuRVZFTlRTLnJlbmFtZUxheWVyLCB7XG4gICAgICBvbGROYW1lOiBjdXJyZW50TmFtZSxcbiAgICAgIG5ld05hbWU6IG5hbWUsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHdlaWdodCBvZiBhbiBhbmltYXRpb24gbGF5ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdG8gcmV0dXJuIHdlaWdodCBmcm9tLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0TGF5ZXJXZWlnaHQobmFtZSkge1xuICAgIC8vIE1ha2Ugc3VyZSB0aGUgbmFtZSBpcyB2YWxpZFxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJNYXBbbmFtZV07XG5cbiAgICBpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGdldCB3ZWlnaHQgb24gbGF5ZXIgJHtuYW1lfSBmcm9tIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTm8gbGF5ZXIgZXhpc3RzIHdpdGggdGhpcyBuYW1lLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxheWVyLndlaWdodDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHdlaWdodCBvZiBhbiBhbmltYXRpb24gbGF5ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGxheWVyIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHdlaWdodCAtIFRoZSB3ZWlnaHQgdmFsdWUgdG8gc2V0IG9uIHRoZSBsYXllci4gVGhpcyBudW1iZXJcbiAgICogc2hvdWxkIGJlIGluIHRoZSAwLTEgcmFuZ2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gc2Vjb25kcyAtIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyBpdCBzaG91bGQgdGFrZSB0byByZWFjaCB0aGVcbiAgICogbmV3IHdlaWdodC4gRGVmYXVsdCBpcyB6ZXJvIGFuZCB3aWxsIHNldCBpbW1lZGlhdGVseS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGVhc2luZ0ZuIC0gVGhlIGVhc2luZyBmdW5jdGlvbiB0byB1c2Ugd2hpbGUgaW50ZXJwb2xhdGluZ1xuICAgKiB0aGUgd2VpZ2h0LiBEZWZhdWx0IGlzIEVhc2luZy5MaW5lYXIuSW5PdXQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH0gQSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIG9uY2UgdGhlIGxheWVyJ3Mgd2VpZ2h0IHJlYWNoZXNcbiAgICogdGhlIHRhcmdldCB2YWx1ZS5cbiAgICovXG4gIHNldExheWVyV2VpZ2h0KG5hbWUsIHdlaWdodCwgc2Vjb25kcywgZWFzaW5nRm4pIHtcbiAgICAvLyBNYWtlIHN1cmUgdGhlIG5hbWUgaXMgdmFsaWRcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW25hbWVdO1xuXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGUgPSBgQ2Fubm90IHNldCB3ZWlnaHQgb24gbGF5ZXIgJHtuYW1lfSBmcm9tIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTm8gbGF5ZXIgZXhpc3RzIHdpdGggdGhpcyBuYW1lLmA7XG4gICAgICByZXR1cm4gRGVmZXJyZWQucmVqZWN0KGUpO1xuICAgIH1cblxuICAgIHJldHVybiBsYXllci5zZXRXZWlnaHQod2VpZ2h0LCBzZWNvbmRzLCBlYXNpbmdGbik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbmFtZXMgb2YgYmxlbmQgc3RhdGVzIGluIGFuIGFuaW1hdGlvbiBpbiBhIGxheWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgY29udGFpbmluZyB0aGUgYW5pbWF0aW9uIGNvbnRhaW5pbmdcbiAgICogdGhlIGJsZW5kIHN0YXRlIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFuaW1hdGlvbk5hbWUgLSBOYW1lIG9mIHRoZSBhbmltYXRpb24gY29udGFpbmluZyB0aGUgYmxlbmQgc3RhdGVcbiAgICogdG8gdXBkYXRlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZz59IC0gTmFtZXMgb2YgYmxlbmQgc3RhdGVzLlxuICAgKi9cbiAgZ2V0QW5pbWF0aW9uQmxlbmROYW1lcyhsYXllck5hbWUsIGFuaW1hdGlvbk5hbWUpIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW2xheWVyTmFtZV07XG5cbiAgICBpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGdldCBibGVuZCBuYW1lcyBvbiBsYXllciAke2xheWVyTmFtZX0gZnJvbSBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5vIGxheWVyIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBsYXllci5nZXRBbmltYXRpb25CbGVuZE5hbWVzKGFuaW1hdGlvbk5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgd2VpZ2h0IGZvciBhIGJsZW5kIHN0YXRlIGluIGFuIGFuaW1hdGlvbiBpbiBhIGxheWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgY29udGFpbmluZyB0aGUgYW5pbWF0aW9uIGNvbnRhaW5pbmdcbiAgICogdGhlIGJsZW5kIHN0YXRlIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFuaW1hdGlvbk5hbWUgLSBOYW1lIG9mIHRoZSBhbmltYXRpb24gY29udGFpbmluZyB0aGUgYmxlbmQgc3RhdGVcbiAgICogdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYmxlbmROYW1lIC0gTmFtZSBvZiB0aGUgYmxlbmQgc3RhdGUgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gd2VpZ2h0IC0gV2VpZ2h0IHZhbHVlIHRvIHNldCBvbiB0aGUgYW5pbWF0aW9uLiBUaGlzIG51bWJlciBzaG91ZGxkIGJlXG4gICAqIGluIHRoZSAwLTEgcmFuZ2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gc2Vjb25kcyAtIE51bWJlciBvZiBzZWNvbmRzIGl0IHNob3VsZCB0YWtlIHRvIHJlYWNoIHRoZSBuZXcgd2VpZ2h0LlxuICAgKiBEZWZhdWx0IGlzIHplcm8gYW5kIHdpbGwgc2V0IGltbWVkaWF0ZWx5LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gZWFzaW5nRm4gLSBFYXNpbmcgZnVuY3Rpb24gdG8gdXNlIHdoaWxlIGludGVycG9sYXRpbmcgdGhlIG5ld1xuICAgKiB3ZWlnaHQuIERlZmF1bHQgaXMgRWFzaW5nLkxpbmVhci5Jbk91dC5cbiAgICpcbiAgICogQHJldHVybnMge0RlZmVycmVkfSAtIFByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgb25jZSB0aGUgYW5pbWF0aW9uJ3Mgd2VpZ2h0IHJlYWNoZXNcbiAgICogdGhlIHRhcmdldCB2YWx1ZS5cbiAgICovXG4gIHNldEFuaW1hdGlvbkJsZW5kV2VpZ2h0KFxuICAgIGxheWVyTmFtZSxcbiAgICBhbmltYXRpb25OYW1lLFxuICAgIGJsZW5kTmFtZSxcbiAgICB3ZWlnaHQsXG4gICAgc2Vjb25kcyxcbiAgICBlYXNpbmdGblxuICApIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW2xheWVyTmFtZV07XG5cbiAgICBpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgZSA9IGBDYW5ub3Qgc2V0IGJsZW5kIHdlaWdodCBvbiBsYXllciAke2xheWVyTmFtZX0gZnJvbSBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5vIGxheWVyIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gO1xuICAgICAgcmV0dXJuIERlZmVycmVkLnJlamVjdChlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGF5ZXIuc2V0QW5pbWF0aW9uQmxlbmRXZWlnaHQoXG4gICAgICBhbmltYXRpb25OYW1lLFxuICAgICAgYmxlbmROYW1lLFxuICAgICAgd2VpZ2h0LFxuICAgICAgc2Vjb25kcyxcbiAgICAgIGVhc2luZ0ZuXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3ZWlnaHQgZm9yIGEgYmxlbmQgc3RhdGUgaW4gYW4gYW5pbWF0aW9uIGluIGEgbGF5ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciBjb250YWluaW5nIHRoZSBhbmltYXRpb24gY29udGFpbmluZ1xuICAgKiB0aGUgYmxlbmQgc3RhdGUgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYW5pbWF0aW9uTmFtZSAtIE5hbWUgb2YgdGhlIGFuaW1hdGlvbiBjb250YWluaW5nIHRoZSBibGVuZCBzdGF0ZVxuICAgKiB0byB1cGRhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBibGVuZE5hbWUgLSBOYW1lIG9mIHRoZSBibGVuZCBzdGF0ZSB0byB1cGRhdGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gV2VpZ2h0IG9mIHRoZSBibGVuZCBzdGF0ZS5cbiAgICovXG4gIGdldEFuaW1hdGlvbkJsZW5kV2VpZ2h0KGxheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSwgYmxlbmROYW1lKSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllck1hcFtsYXllck5hbWVdO1xuXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBnZXQgYmxlbmQgd2VpZ2h0IG9uIGxheWVyICR7bGF5ZXJOYW1lfSBmcm9tIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTm8gbGF5ZXIgZXhpc3RzIHdpdGggdGhpcyBuYW1lLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxheWVyLmdldEFuaW1hdGlvbkJsZW5kV2VpZ2h0KGFuaW1hdGlvbk5hbWUsIGJsZW5kTmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogUGF1c2Ugd2VpZ2h0IGludGVycG9sYXRpb24gYW5pbWF0aW9uIG9uIGEgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0byBwYXVzZS5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59IC0gV2hldGhlciBvciBub3QgdGhlcmUgd2FzIGFuIGV4aXN0aW5nIGludGVycG9sYXRpb24gdG8gcGF1c2UuXG4gICAqL1xuICBwYXVzZUxheWVyV2VpZ2h0KG5hbWUpIHtcbiAgICAvLyBNYWtlIHN1cmUgdGhlIG5hbWUgaXMgdmFsaWRcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW25hbWVdO1xuXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBwYXVzZSB3ZWlnaHQgaW50ZXJwb2xhdGlvbiBvbiBsYXllciAke25hbWV9IGZyb20gaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBsYXllciBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGF5ZXIucGF1c2VXZWlnaHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN1bWUgd2VpZ2h0IGludGVycG9sYXRpb24gYW5pbWF0aW9uIG9uIGEgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0byByZXN1bWUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH0gLSBSZXNvbHZlcyBvbmNlIHRoZSBsYXllcidzIHdlaWdodCByZWFjaGVzIGl0cyB0YXJnZXQgdmFsdWUuXG4gICAqL1xuICByZXN1bWVMYXllcldlaWdodChuYW1lKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBuYW1lIGlzIHZhbGlkXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllck1hcFtuYW1lXTtcblxuICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBlID0gYENhbm5vdCByZXN1bWUgd2VpZ2h0IGludGVycG9sYXRpb24gb24gbGF5ZXIgJHtuYW1lfSBmcm9tIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTm8gbGF5ZXIgZXhpc3RzIHdpdGggdGhpcyBuYW1lLmA7XG4gICAgICByZXR1cm4gRGVmZXJyZWQucmVqZWN0KGUpO1xuICAgIH1cblxuICAgIHJldHVybiBsYXllci5yZXN1bWVXZWlnaHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXVzZSBjdXJyZW50IGFuaW1hdGlvbiBhbmQgd2VpZ2h0IGludGVycG9sYXRpb24gYW5pbWF0aW9uIG9uIGEgbGF5ZXIgd2l0aFxuICAgKiB0aGUgZ2l2ZW4gbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0byBwYXVzZS5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59IC0gV2hldGhlciBvciBub3QgdGhlcmUgd2FzIGFuIGV4aXN0aW5nIGludGVycG9sYXRpb24gb3JcbiAgICogY3VycmVudCBhbmltYXRpb24gdG8gcGF1c2UuXG4gICAqL1xuICBwYXVzZUxheWVyKG5hbWUpIHtcbiAgICAvLyBNYWtlIHN1cmUgdGhlIG5hbWUgaXMgdmFsaWRcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW25hbWVdO1xuXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBwYXVzZSBsYXllciAke25hbWV9IGZyb20gaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBsYXllciBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGF5ZXIucGF1c2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN1bWUgY3VycmVudCBhbmltYXRpb24gYW5kIHdlaWdodCBpbnRlcnBvbGF0aW9uIGFuaW1hdGlvbiBvbiBhIGxheWVyIHdpdGhcbiAgICogdGhlIGdpdmVuIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdG8gcmVzdW1lLlxuICAgKlxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9IC0gUmVzb2x2ZXMgb25jZSB0aGUgbGF5ZXIncyB3ZWlnaHQgcmVhY2hlcyBpdHMgdGFyZ2V0IHZhbHVlXG4gICAqIGFuZCBpdCdzIGN1cnJlbnQgYW5pbWF0aW9uIGZpbmlzaGVzIHBsYXlpbmcuXG4gICAqL1xuICByZXN1bWVMYXllcihuYW1lKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBuYW1lIGlzIHZhbGlkXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllck1hcFtuYW1lXTtcblxuICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBlID0gYENhbm5vdCByZXN1bWUgbGF5ZXIgJHtuYW1lfSBmcm9tIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTm8gbGF5ZXIgZXhpc3RzIHdpdGggdGhpcyBuYW1lLmA7XG4gICAgICByZXR1cm4gRGVmZXJyZWQucmVqZWN0KGUpO1xuICAgIH1cblxuICAgIHJldHVybiBsYXllci5yZXN1bWUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciBvciBub3QgdGhlIGFuaW1hdGlvbiBsYXllciB3aXRoIHRoZSBnaXZlbiBuYW1lIGlzIGN1cnJlbnRseVxuICAgKiB0cmFuc2l0aW9uaW5nIGJldHdlZW4gYW5pbWF0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRvIGNoZWNrLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGdldFRyYW5zaXRpb25pbmcobGF5ZXJOYW1lKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBsYXllck5hbWUgaXMgdmFsaWRcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW2xheWVyTmFtZV07XG5cbiAgICBpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgR2V0IHRyYW5zaXRpb25pbmcgb24gbGF5ZXIgJHtsYXllck5hbWV9IGZyb20gaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBsYXllciBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGF5ZXIuaXNUcmFuc2l0aW9uaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiB0aGUgbmFtZXMgb2YgYWxsIHN0YXRlcyB0aGUgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBjb250cm9scy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRvIHNlYXJjaC5cbiAgICpcbiAgICogQHJldHVybnMge0FycmF5LjxzdHJpbmc+fVxuICAgKi9cbiAgZ2V0QW5pbWF0aW9ucyhsYXllck5hbWUpIHtcbiAgICAvLyBNYWtlIHN1cmUgdGhlIGxheWVyTmFtZSBpcyB2YWxpZFxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJNYXBbbGF5ZXJOYW1lXTtcblxuICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBHZXQgYW5pbWF0aW9ucyBvbiBsYXllciAke2xheWVyTmFtZX0gZnJvbSBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5vIGxheWVyIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBsYXllci5nZXRTdGF0ZU5hbWVzKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBuYW1lIG9mIHRoZSBzdGF0ZSBjdXJyZW50bHkgYWN0aXZlIG9uIHRoZSBsYXllciB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuICAgKiBSZXR1cm4gbnVsbCBpZiB0aGVyZSBpcyBubyBjdXJyZW50IGFuaW1hdGlvbiBmb3IgdGhlIGxheWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHsoc3RyaW5nfG51bGwpfVxuICAgKi9cbiAgZ2V0Q3VycmVudEFuaW1hdGlvbihsYXllck5hbWUpIHtcbiAgICAvLyBNYWtlIHN1cmUgdGhlIGxheWVyTmFtZSBpcyB2YWxpZFxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJNYXBbbGF5ZXJOYW1lXTtcblxuICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBHZXQgY3VycmVudCBhbmltYXRpb24gb24gbGF5ZXIgJHtsYXllck5hbWV9IGZyb20gaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBsYXllciBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGF5ZXIuY3VycmVudEFuaW1hdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciBvciBub3QgYSBsYXllciB3aXRoIHRoZSBnaXZlbiBuYW1lIGlzIGN1cnJlbnRseSBwbGF5aW5nIGFuXG4gICAqIGFuaW1hdGlvbiBhbmQgdGhhdCBhbmltYXRpb24gaXMgcGF1c2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZ2V0UGF1c2VkKGxheWVyTmFtZSkge1xuICAgIC8vIE1ha2Ugc3VyZSB0aGUgbGF5ZXJOYW1lIGlzIHZhbGlkXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllck1hcFtsYXllck5hbWVdO1xuXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEdldCBwYXVzZWQgb24gbGF5ZXIgJHtsYXllck5hbWV9IGZyb20gaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBsYXllciBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGF5ZXIuY3VycmVudFN0YXRlICYmIGxheWVyLmN1cnJlbnRTdGF0ZS5wYXVzZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB0eXBlIG5hbWUgb2YgdGhlIGdpdmVuIGFuaW1hdGlvbi4gQHNlZSBBbmltYXRpb25UeXBlcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRoYXQgY29udGFpbnMgdGhlIGFuaW1hdGlvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFuaW1hdGlvbk5hbWUgLSBOYW1lIG9mIHRoZSBhbmltYXRpb24gdG8gY2hlY2suXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBnZXRBbmltYXRpb25UeXBlKGxheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSkge1xuICAgIC8vIE1ha2Ugc3VyZSB0aGUgbGF5ZXJOYW1lIGlzIHZhbGlkXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllck1hcFtsYXllck5hbWVdO1xuXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEdldCBhbmltYXRpb24gdHlwZSBvbiBsYXllciAke2xheWVyTmFtZX0gZnJvbSBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5vIGxheWVyIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXRlID0gbGF5ZXIuZ2V0U3RhdGUoYW5pbWF0aW9uTmFtZSk7XG5cbiAgICBpZiAoc3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgR2V0IGFuaW1hdGlvbiB0eXBlIGZvciBhbmltYXRpb24gJHthbmltYXRpb25OYW1lfSBvbiBsYXllciAke2xheWVyTmFtZX0gZnJvbSBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5vIGFuaW1hdGlvbiBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCB7Y29uc3RydWN0b3J9ID0gc3RhdGU7XG5cbiAgICByZXR1cm4gT2JqZWN0LmtleXMoQW5pbWF0aW9uVHlwZXMpLmZpbmQoXG4gICAgICB0eXBlTmFtZSA9PiBBbmltYXRpb25UeXBlc1t0eXBlTmFtZV0gPT09IGNvbnN0cnVjdG9yXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgYW5pbWF0aW9uIHRvIGFuIGFuaW1hdGlvbiBsYXllci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRvIGFkZCB0aGUgYW5pbWF0aW9uIHRvLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYW5pbWF0aW9uTmFtZSAtIE5hbWUgdG8gdXNlIHdoZW4gY2FsbGluZyB0aGUgYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgLSBPcHRpb25zIHRvIHBhc3MgdG8gdGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgbmV3XG4gICAqIFNpbmdsZVN0YXRlIGFuaW1hdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gLSBUaGUgbmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRoYXQgd2FzIGFkZGVkXG4gICAqL1xuICBhZGRBbmltYXRpb24oXG4gICAgbGF5ZXJOYW1lLFxuICAgIGFuaW1hdGlvbk5hbWUsXG4gICAgYW5pbWF0aW9uVHlwZSA9IEFuaW1hdGlvblR5cGVzLnNpbmdsZSxcbiAgICBvcHRpb25zID0ge31cbiAgKSB7XG4gICAgb3B0aW9ucy5uYW1lID0gdGhpcy5fdmFsaWRhdGVOZXdBbmltYXRpb24obGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lKTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgYW5pbWF0aW9uIHR5cGUgaXMgdmFsaWRcbiAgICBpZiAoIU9iamVjdC52YWx1ZXMoQW5pbWF0aW9uVHlwZXMpLmluY2x1ZGVzKGFuaW1hdGlvblR5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgYWRkIGFuaW1hdGlvbiAke2FuaW1hdGlvbk5hbWV9IHRvIGxheWVyICR7bGF5ZXJOYW1lfSBvbiBob3N0ICR7dGhpcy5faG9zdC5pZH0uIEludmFsaWQgYW5pbWF0aW9uIHR5cGUuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW2xheWVyTmFtZV07XG4gICAgb3B0aW9ucy5ibGVuZE1vZGUgPSBsYXllci5ibGVuZE1vZGU7XG4gICAgb3B0aW9ucy50cmFuc2l0aW9uVGltZSA9IGxheWVyLnRyYW5zaXRpb25UaW1lO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpc1tgX2NyZWF0ZSR7YW5pbWF0aW9uVHlwZS5uYW1lfWBdKG9wdGlvbnMpO1xuXG4gICAgY29uc3QgbmFtZSA9IGxheWVyLmFkZFN0YXRlKHN0YXRlKTtcblxuICAgIC8vIE5vdGlmeSB0aGF0IGFuIGFuaW1hdGlvbiBoYXMgYmVlbiBhZGRlZCB0byB0aGUgZmVhdHVyZVxuICAgIHRoaXMuZW1pdCh0aGlzLmNvbnN0cnVjdG9yLkVWRU5UUy5hZGRBbmltYXRpb24sIHtcbiAgICAgIGxheWVyTmFtZSxcbiAgICAgIGFuaW1hdGlvbk5hbWU6IG5hbWUsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gYW5pbWF0aW9uIGZyb20gYW4gYW5pbWF0aW9uIGxheWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdG8gcmVtb3ZlIHRoZSBhbmltYXRpb24gZnJvbS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBhbmltYXRpb24gdG8gcmVtb3ZlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHJlbW92ZUFuaW1hdGlvbihsYXllck5hbWUsIGFuaW1hdGlvbk5hbWUpIHtcbiAgICAvLyBNYWtlIHN1cmUgdGhlIG5hbWUgaXMgdmFsaWRcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW2xheWVyTmFtZV07XG5cbiAgICBpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IHJlbW92ZSBhbmltYXRpb24gZnJvbSBsYXllciAke2xheWVyTmFtZX0gZnJvbSBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5vIGxheWVyIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHJlbW92ZWQgPSBsYXllci5yZW1vdmVTdGF0ZShhbmltYXRpb25OYW1lKTtcblxuICAgIC8vIE5vdGlmeSB0aGF0IGFuIGFuaW1hdGlvbiBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIGZlYXR1cmVcbiAgICBpZiAocmVtb3ZlZCA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5lbWl0KHRoaXMuY29uc3RydWN0b3IuRVZFTlRTLnJlbW92ZUFuaW1hdGlvbiwge1xuICAgICAgICBsYXllck5hbWUsXG4gICAgICAgIGFuaW1hdGlvbk5hbWUsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVtb3ZlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIG5hbWUgb2YgYW4gYW5pbWF0aW9uLiBOYW1lcyBtdXN0IGJlIHVuaXF1ZSBvbiBlYWNoIGxheWVyLCBpZiB0aGUgbmV3XG4gICAqIG5hbWUgaXMgbm90IHVuaXF1ZSBpdCB3aWxsIGhhdmUgdHJhaWxpbmcgbnVtYmVycyBhcHBlbmRlZCB1bnRpbCBpdCBpcyB1bmlxdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0aGF0IGNvbnRhaW5zIHRoZSBhbmltYXRpb24gdGhhdFxuICAgKiB3aWxsIGJlIHJlbmFtZWQsXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjdXJyZW50QW5pbWF0aW9uTmFtZSAtIEN1cnJlbnQgbmFtZSBvZiB0aGUgYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3QW5pbWF0aW9uTmFtZSAtIE5ldyBuYW1lIHRvIHNldCBvbiB0aGUgYW5pbWF0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSBuZXcgbmFtZSBvZiB0aGUgYW5pbWF0aW9uXG4gICAqL1xuICByZW5hbWVBbmltYXRpb24obGF5ZXJOYW1lLCBjdXJyZW50QW5pbWF0aW9uTmFtZSwgbmV3QW5pbWF0aW9uTmFtZSkge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJNYXBbbGF5ZXJOYW1lXTtcblxuICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgcmVuYW1lIGFuaW1hdGlvbiAke2N1cnJlbnRBbmltYXRpb25OYW1lfSBvbiBsYXllciAke2xheWVyTmFtZX0gZm9yIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTm8gbGF5ZXIgZXhpc3RzIHdpdGggdGhpcyBuYW1lLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgbmFtZSA9IGxheWVyLnJlbmFtZVN0YXRlKGN1cnJlbnRBbmltYXRpb25OYW1lLCBuZXdBbmltYXRpb25OYW1lKTtcblxuICAgIC8vIE5vdGlmeSB0aGF0IGFuIGFuaW1hdGlvbiBoYXMgYmVlbiByZW5hbWVkIG9uIHRoZSBmZWF0dXJlXG4gICAgdGhpcy5lbWl0KHRoaXMuY29uc3RydWN0b3IuRVZFTlRTLnJlbmFtZUFuaW1hdGlvbiwge1xuICAgICAgbGF5ZXJOYW1lLFxuICAgICAgb2xkTmFtZTogY3VycmVudEFuaW1hdGlvbk5hbWUsXG4gICAgICBuZXdOYW1lOiBuYW1lLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cblxuICAvKipcbiAgICogUGF1c2UgdGhlIGN1cnJlbnRseSBwbGF5aW5nIGFuaW1hdGlvbiBhbmQgcGxheSBhIG5ldyBhbmltYXRpb24gZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCBjb250YWlucyB0aGUgYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYW5pbWF0aW9uTmFtZSAtIE5hbWUgb2YgdGhlIGFuaW1hdGlvbiBzdGF0ZSB0byBwbGF5LlxuICAgKiBAcGFyYW0ge251bWJlcj19IHNlY29uZHMgLSBUaGUgbnVtYmVyIG9mIHNlY29uZHMgaXQgc2hvdWxkIHRha2UgdG8gdHJhbnNpdGlvblxuICAgKiB0byB0aGUgbmV3IGFuaW1hdGlvbi4gRGVmYXVsdCBpcyB6ZXJvIGFuZCB3aWxsIHNldCBpbW1lZGlhdGVseS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGVhc2luZ0ZuIC0gVGhlIGVhc2luZyBmdW5jdGlvbiB0byB1c2Ugd2hpbGUgdHJhbnNpdGlvbmluZ1xuICAgKiBiZXR3ZWVuIGFuaW1hdGlvbnMuIERlZmF1bHQgaXMgRWFzaW5nLkxpbmVhci5Jbk91dC5cbiAgICpcbiAgICogQHJldHVybnMge0RlZmVycmVkfSAtIFJlc29sdmVzIG9uY2UgdGhlIGFuaW1hdGlvbiByZWFjaGVzIHRoZSBlbmQgb2YgaXRzXG4gICAqIHRpbWVsaW5lLiBMb29waW5nIGFuaW1hdGlvbnMgY2FuIG9ubHkgcmVzb2x2ZSBpZiB0aGV5IGFyZSBpbnRlcnJ1cHRlZCBvclxuICAgKiBtYW51YWxseSBzdG9wcGVkLlxuICAgKi9cbiAgcGxheUFuaW1hdGlvbihsYXllck5hbWUsIGFuaW1hdGlvbk5hbWUsIHNlY29uZHMsIGVhc2luZ0ZuKSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllck1hcFtsYXllck5hbWVdO1xuXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGUgPSBgQ2Fubm90IHBsYXkgYW5pbWF0aW9uICR7YW5pbWF0aW9uTmFtZX0gb24gbGF5ZXIgJHtsYXllck5hbWV9IGZvciBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5vIGxheWVyIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gO1xuICAgICAgcmV0dXJuIERlZmVycmVkLnJlamVjdChlKTtcbiAgICB9XG5cbiAgICAvLyBOb3RpZnkgdGhhdCBhIG5ldyBhbmltYXRpb24gaGFzIGJlZ3VuXG4gICAgdGhpcy5lbWl0KHRoaXMuY29uc3RydWN0b3IuRVZFTlRTLnBsYXlBbmltYXRpb24sIHtcbiAgICAgIGxheWVyTmFtZSxcbiAgICAgIGFuaW1hdGlvbk5hbWUsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gbGF5ZXIucGxheUFuaW1hdGlvbihcbiAgICAgIGFuaW1hdGlvbk5hbWUsXG4gICAgICBzZWNvbmRzLFxuICAgICAgZWFzaW5nRm4sXG4gICAgICAoKSA9PiB7XG4gICAgICAgIC8vIE5vdGlmeSB0aGF0IGFuIGFuaW1hdGlvbiBoYXMgc3RvcHBlZFxuICAgICAgICB0aGlzLmVtaXQodGhpcy5jb25zdHJ1Y3Rvci5FVkVOVFMuc3RvcEFuaW1hdGlvbiwge1xuICAgICAgICAgIGxheWVyTmFtZSxcbiAgICAgICAgICBhbmltYXRpb25OYW1lLFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB1bmRlZmluZWQsXG4gICAgICAoKSA9PiB7XG4gICAgICAgIC8vIE5vdGlmeSB0aGF0IGFuIGFuaW1hdGlvbiBoYXMgYmVlbiBpbnRlcnJ1cHRlZFxuICAgICAgICB0aGlzLmVtaXQodGhpcy5jb25zdHJ1Y3Rvci5FVkVOVFMuaW50ZXJydXB0QW5pbWF0aW9uLCB7XG4gICAgICAgICAgbGF5ZXJOYW1lLFxuICAgICAgICAgIGFuaW1hdGlvbk5hbWUsXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgICh7bmFtZSwgY2FuQWR2YW5jZSwgaXNRdWV1ZUVuZH0pID0+IHtcbiAgICAgICAgaWYgKGxheWVyLmN1cnJlbnRBbmltYXRpb24gPT09IGFuaW1hdGlvbk5hbWUpIHtcbiAgICAgICAgICAvLyBOb3RpZnkgdGhhdCBhIG5ldyBhbmltYXRpb24gaGFzIGJlZ3VuXG4gICAgICAgICAgdGhpcy5lbWl0KHRoaXMuY29uc3RydWN0b3IuRVZFTlRTLnBsYXlOZXh0QW5pbWF0aW9uLCB7XG4gICAgICAgICAgICBsYXllck5hbWUsXG4gICAgICAgICAgICBhbmltYXRpb25OYW1lLFxuICAgICAgICAgICAgbmV4dFF1ZXVlZEFuaW1hdGlvbjogbmFtZSxcbiAgICAgICAgICAgIGNhbkFkdmFuY2UsXG4gICAgICAgICAgICBpc1F1ZXVlRW5kLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQbGF5IHRoZSBuZXh0IGFuaW1hdGlvbiBpbiB0aGUgcXVldWUgb2YgYSBRdWV1ZVN0YXRlIGFuaW1hdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRoYXQgY29udGFpbnMgdGhlIHF1ZXVlIGFuaW1hdGlvbi5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBhbmltYXRpb25OYW1lIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uIHF1ZXVlIGFuaW1hdGlvbi4gRGVmYXVsdHNcbiAgICogdG8gdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGZvciB0aGUgbGF5ZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gc2Vjb25kcyAtIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyBpdCBzaG91bGQgdGFrZSB0byB0cmFuc2l0aW9uXG4gICAqIHRvIHRoZSBxdWV1ZSBhbmltYXRpb24gaWYgaXQncyBub3QgYWxyZWFkeSBjdXJyZW50bHkgcGxheWluZy4gRGVmYXVsdCBpcyB6ZXJvXG4gICAqIGFuZCB3aWxsIHNldCBpbW1lZGlhdGVseS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGVhc2luZ0ZuIC0gVGhlIGVhc2luZyBmdW5jdGlvbiB0byB1c2Ugd2hpbGUgdHJhbnNpdGlvbmluZ1xuICAgKiB0byB0aGUgcXVldWUgYW5pbWF0aW9uIGlmIGl0IGlzbid0IGFscmVhZHkgcGxheWluZy4gRGVmYXVsdCBpcyBFYXNpbmcuTGluZWFyLkluT3V0LlxuICAgKlxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9IC0gUmVzb2x2ZXMgb25jZSB0aGUgbGFzdCBhbmltYXRpb24gaW4gdGhlIHF1ZXVlIGZpbmlzaGVzXG4gICAqIHBsYXlpbmcuXG4gICAqL1xuICBwbGF5TmV4dEFuaW1hdGlvbihsYXllck5hbWUsIGFuaW1hdGlvbk5hbWUsIHRyYW5zaXRpb25UaW1lLCBlYXNpbmdGbikge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJNYXBbbGF5ZXJOYW1lXTtcblxuICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBlID0gYENhbm5vdCBwbGF5IG5leHQgYW5pbWF0aW9uIG9uIGxheWVyICR7bGF5ZXJOYW1lfSBmb3IgaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBsYXllciBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYDtcbiAgICAgIHJldHVybiBEZWZlcnJlZC5yZWplY3QoZSk7XG4gICAgfVxuXG4gICAgaWYgKGFuaW1hdGlvbk5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYW5pbWF0aW9uTmFtZSA9IGxheWVyLmN1cnJlbnRBbmltYXRpb247XG4gICAgfVxuXG4gICAgY29uc3QgYW5pbWF0aW9uID0gbGF5ZXIuZ2V0U3RhdGUobGF5ZXIuY3VycmVudEFuaW1hdGlvbik7XG5cbiAgICBpZiAoYW5pbWF0aW9uID09PSBudWxsKSB7XG4gICAgICBjb25zdCBlID0gYENhbm5vdCBwbGF5IG5leHQgYW5pbWF0aW9uIG9uIGxheWVyICR7bGF5ZXJOYW1lfSBmb3IgaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBhbmltYXRpb24gZXhpc3RzIHdpdGggbmFtZSAke2FuaW1hdGlvbk5hbWV9LmA7XG4gICAgICByZXR1cm4gRGVmZXJyZWQucmVqZWN0KGUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5nZXRBbmltYXRpb25UeXBlKGxheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSkgIT09ICdxdWV1ZScpIHtcbiAgICAgIGNvbnN0IGUgPSBgQ2Fubm90IHBsYXkgbmV4dCBhbmltYXRpb24gb24gbGF5ZXIgJHtsYXllck5hbWV9IGZvciBob3N0ICR7dGhpcy5faG9zdC5pZH0uICR7YW5pbWF0aW9uTmFtZX0gaXMgbm90IGEgcXVldWUgc3RhdGUuYDtcbiAgICAgIHJldHVybiBEZWZlcnJlZC5yZWplY3QoZSk7XG4gICAgfVxuXG4gICAgY29uc3Qgb25OZXh0ID0gKHtuYW1lLCBjYW5BZHZhbmNlLCBpc1F1ZXVlRW5kfSkgPT4ge1xuICAgICAgaWYgKGxheWVyLmN1cnJlbnRBbmltYXRpb24gPT09IGFuaW1hdGlvbk5hbWUpIHtcbiAgICAgICAgLy8gTm90aWZ5IHRoYXQgYSBuZXcgYW5pbWF0aW9uIGhhcyBiZWd1blxuICAgICAgICB0aGlzLmVtaXQodGhpcy5jb25zdHJ1Y3Rvci5FVkVOVFMucGxheU5leHRBbmltYXRpb24sIHtcbiAgICAgICAgICBsYXllck5hbWUsXG4gICAgICAgICAgYW5pbWF0aW9uTmFtZSxcbiAgICAgICAgICBuZXh0UXVldWVkQW5pbWF0aW9uOiBuYW1lLFxuICAgICAgICAgIGNhbkFkdmFuY2UsXG4gICAgICAgICAgaXNRdWV1ZUVuZCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIE1ha2UgdGhlIHF1ZXVlIGFuaW1hdGlvbiBjdXJyZW50IGlmIGl0IHdhc24ndCBhbHJlYWR5XG4gICAgaWYgKGxheWVyLmN1cnJlbnRBbmltYXRpb24gPT09IG51bGwpIHtcbiAgICAgIGxheWVyLnJlc3VtZUFuaW1hdGlvbihcbiAgICAgICAgYW5pbWF0aW9uLm5hbWUsXG4gICAgICAgIHRyYW5zaXRpb25UaW1lLFxuICAgICAgICBlYXNpbmdGbixcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgb25OZXh0XG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBhbmltYXRpb24ubmV4dChvbk5leHQsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdXNlIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBvbiBhIGxheWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRvIHBhdXNlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgYW4gYW5pbWF0aW9uIHdhcyBzdWNjZXNzZnVsbHkgcGF1c2VkLlxuICAgKi9cbiAgcGF1c2VBbmltYXRpb24obmFtZSkge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJNYXBbbmFtZV07XG5cbiAgICBpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgRGlkIG5vdCBwYXVzZSBhbmltYXRpb24gb24gbGF5ZXIgJHtuYW1lfSBmb3IgaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBsYXllciBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxuICAgICAgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXVzZWQgPSBsYXllci5wYXVzZUFuaW1hdGlvbigpO1xuXG4gICAgLy8gTm90aWZ5IHRoYXQgYW4gYW5pbWF0aW9uIHdhcyBwYXVzZWRcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBjb25zdCBhbmltYXRpb25OYW1lID0gbGF5ZXIuY3VycmVudEFuaW1hdGlvbjtcbiAgICAgIHRoaXMuZW1pdCh0aGlzLmNvbnN0cnVjdG9yLkVWRU5UUy5wYXVzZUFuaW1hdGlvbiwge1xuICAgICAgICBsYXllck5hbWU6IG5hbWUsXG4gICAgICAgIGFuaW1hdGlvbk5hbWUsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF1c2VkO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdXNlIHRoZSBjdXJyZW50bHkgcGxheWluZyBhbmltYXRpb24gYW5kIHBsYXkgYSBuZXcgYW5pbWF0aW9uIGZyb20gd2hlcmUgaXRcbiAgICogbGFzdCBsZWZ0IG9mZi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRoYXQgY29udGFpbnMgdGhlIGFuaW1hdGlvbi5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBhbmltYXRpb25OYW1lIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uIHN0YXRlIHRvIHJlc3VtZS4gRGVmYXVsdHNcbiAgICogdG8gdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGZvciB0aGUgbGF5ZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gc2Vjb25kcyAtIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyBpdCBzaG91bGQgdGFrZSB0byB0cmFuc2l0aW9uXG4gICAqIHRvIHRoZSBuZXcgYW5pbWF0aW9uLiBEZWZhdWx0IGlzIHplcm8gYW5kIHdpbGwgc2V0IGltbWVkaWF0ZWx5LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gZWFzaW5nRm4gLSBUaGUgZWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSB3aGlsZSB0cmFuc2l0aW9uaW5nXG4gICAqIGJldHdlZW4gYW5pbWF0aW9ucy4gRGVmYXVsdCBpcyBFYXNpbmcuTGluZWFyLkluT3V0LlxuICAgKlxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9IC0gUmVzb2x2ZXMgb25jZSB0aGUgYW5pbWF0aW9uIHJlYWNoZXMgdGhlIGVuZCBvZiBpdHNcbiAgICogdGltZWxpbmUuIExvb3BpbmcgYW5pbWF0aW9ucyBjYW4gb25seSByZXNvbHZlIGlmIHRoZXkgYXJlIGludGVycnVwdGVkIG9yXG4gICAqIG1hbnVhbGx5IHN0b3BwZWQuXG4gICAqL1xuICByZXN1bWVBbmltYXRpb24obGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lLCBzZWNvbmRzLCBlYXNpbmdGbikge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJNYXBbbGF5ZXJOYW1lXTtcblxuICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBlID0gYENhbm5vdCByZXN1bWUgYW5pbWF0aW9uICR7YW5pbWF0aW9uTmFtZX0gb24gbGF5ZXIgJHtsYXllck5hbWV9IGZvciBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5vIGxheWVyIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gO1xuICAgICAgcmV0dXJuIERlZmVycmVkLnJlamVjdChlKTtcbiAgICB9XG5cbiAgICAvLyBOb3RpZnkgdGhhdCBhbiBhbmltYXRpb24gd2FzIHJlc3VtZWRcbiAgICB0aGlzLmVtaXQodGhpcy5jb25zdHJ1Y3Rvci5FVkVOVFMucmVzdW1lQW5pbWF0aW9uLCB7XG4gICAgICBsYXllck5hbWUsXG4gICAgICBhbmltYXRpb25OYW1lLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGxheWVyLnJlc3VtZUFuaW1hdGlvbihcbiAgICAgIGFuaW1hdGlvbk5hbWUsXG4gICAgICBzZWNvbmRzLFxuICAgICAgZWFzaW5nRm4sXG4gICAgICAoKSA9PiB7XG4gICAgICAgIC8vIE5vdGlmeSB0aGF0IGFuIGFuaW1hdGlvbiBoYXMgc3RvcHBlZFxuICAgICAgICB0aGlzLmVtaXQodGhpcy5jb25zdHJ1Y3Rvci5FVkVOVFMuc3RvcEFuaW1hdGlvbiwge1xuICAgICAgICAgIGxheWVyTmFtZSxcbiAgICAgICAgICBhbmltYXRpb25OYW1lLFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB1bmRlZmluZWQsXG4gICAgICAoKSA9PiB7XG4gICAgICAgIC8vIE5vdGlmeSB0aGF0IGFuIGFuaW1hdGlvbiBoYXMgYmVlbiBpbnRlcnJ1cHRlZFxuICAgICAgICB0aGlzLmVtaXQodGhpcy5jb25zdHJ1Y3Rvci5FVkVOVFMuaW50ZXJydXB0QW5pbWF0aW9uLCB7XG4gICAgICAgICAgbGF5ZXJOYW1lLFxuICAgICAgICAgIGFuaW1hdGlvbk5hbWUsXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgICh7bmFtZSwgY2FuQWR2YW5jZSwgaXNRdWV1ZUVuZH0pID0+IHtcbiAgICAgICAgaWYgKGxheWVyLmN1cnJlbnRBbmltYXRpb24gPT09IGFuaW1hdGlvbk5hbWUpIHtcbiAgICAgICAgICAvLyBOb3RpZnkgdGhhdCBhIG5ldyBhbmltYXRpb24gaGFzIGJlZ3VuXG4gICAgICAgICAgdGhpcy5lbWl0KHRoaXMuY29uc3RydWN0b3IuRVZFTlRTLnBsYXlOZXh0QW5pbWF0aW9uLCB7XG4gICAgICAgICAgICBsYXllck5hbWUsXG4gICAgICAgICAgICBhbmltYXRpb25OYW1lLFxuICAgICAgICAgICAgbmV4dFF1ZXVlZEFuaW1hdGlvbjogbmFtZSxcbiAgICAgICAgICAgIGNhbkFkdmFuY2UsXG4gICAgICAgICAgICBpc1F1ZXVlRW5kLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBvbiBhIGxheWVyLiBTdG9wIHJld2luZHMgdGhlIGFuaW1hdGlvbiB0byB0aGVcbiAgICogYmVnaW5uaW5nIGFuZCBwcmV2ZW50cyBpdCBmcm9tIHByb2dyZXNzaW5nIGZvcndhcmQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCBjb250YWlucyB0aGUgYW5pbWF0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgYW4gYW5pbWF0aW9uIHdhcyBzdWNjZXNzZnVsbHkgc3RvcHBlZC5cbiAgICovXG4gIHN0b3BBbmltYXRpb24obmFtZSkge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJNYXBbbmFtZV07XG5cbiAgICBpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgRGlkIG5vdCBzdG9wIGFuaW1hdGlvbiBvbiBsYXllciAke25hbWV9IGZvciBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5vIGxheWVyIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gXG4gICAgICApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBsYXllci5zdG9wQW5pbWF0aW9uKCk7XG4gIH1cblxuICAvKipcbiAgICogUGF1c2UgY3VycmVudCBhbmltYXRpb24gYW5kIHdlaWdodCBpbnRlcnBvbGF0aW9uIGFuaW1hdGlvbiBvbiBhbGwgbGF5ZXJzLlxuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAtIFdoZXRoZXIgb3Igbm90IHRoZXJlIHdhcyBhbiBleGlzdGluZyBpbnRlcnBvbGF0aW9uIG9yXG4gICAqIGN1cnJlbnQgYW5pbWF0aW9ucyB0byBwYXVzZS5cbiAgICovXG4gIHBhdXNlKCkge1xuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG5cbiAgICBsZXQgcGF1c2VkID0gZmFsc2U7XG4gICAgdGhpcy5fbGF5ZXJzLmZvckVhY2gobCA9PiB7XG4gICAgICBpZiAobC5wYXVzZSgpKSB7XG4gICAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcGF1c2VkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc3VtZSBjdXJyZW50IGFuaW1hdGlvbiBhbmQgd2VpZ2h0IGludGVycG9sYXRpb24gYW5pbWF0aW9uIG9uIGFsbCBsYXllcnMuXG5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IC0gV2hldGhlciBvciBub3QgdGhlcmUgd2FzIGFuIGV4aXN0aW5nIGludGVycG9sYXRpb24gb3JcbiAgICogY3VycmVudCBhbmltYXRpb25zIHRvIHJlc3VtZS5cbiAgICovXG4gIHJlc3VtZSgpIHtcbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcblxuICAgIGxldCByZXN1bWVkID0gZmFsc2U7XG4gICAgdGhpcy5fbGF5ZXJzLmZvckVhY2gobCA9PiB7XG4gICAgICBpZiAobC5yZXN1bWUoKSkge1xuICAgICAgICByZXN1bWVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bWVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBuYW1lc3BhY2UgdG8gdGhlIGhvc3Qgd2l0aCB0aGUgbmFtZSBvZiB0aGUgZmVhdHVyZSB0byBjb250YWluIHByb3BlcnRpZXNcbiAgICogYW5kIG1ldGhvZHMgZnJvbSB0aGUgZmVhdHVyZSB0aGF0IHVzZXJzIG9mIHRoZSBob3N0IG5lZWQgYWNjZXNzIHRvLlxuICAgKlxuICAgKiBAc2VlIEFuaW1hdGlvbkZlYXR1cmVcbiAgICovXG4gIGluc3RhbGxBcGkoKSB7XG4gICAgLyoqXG4gICAgICogQGlubmVyXG4gICAgICogQG5hbWVzcGFjZSBBbmltYXRpb25GZWF0dXJlXG4gICAgICovXG4gICAgY29uc3QgYXBpID0gc3VwZXIuaW5zdGFsbEFwaSgpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoYXBpLCB7XG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI3BhdXNlZFxuICAgICAgICovXG4gICAgICBwYXVzZWQ6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiB0aGlzLnBhdXNlZCxcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI2xheWVyc1xuICAgICAgICovXG4gICAgICBsYXllcnM6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiB0aGlzLmxheWVycyxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBPYmplY3QuYXNzaWduKGFwaSwge1xuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNhZGRMYXllclxuICAgICAgICovXG4gICAgICBhZGRMYXllcjogdGhpcy5hZGRMYXllci5iaW5kKHRoaXMpLFxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNyZW1vdmVMYXllclxuICAgICAgICovXG4gICAgICByZW1vdmVMYXllcjogdGhpcy5yZW1vdmVMYXllci5iaW5kKHRoaXMpLFxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNtb3ZlTGF5ZXJcbiAgICAgICAqL1xuICAgICAgbW92ZUxheWVyOiB0aGlzLm1vdmVMYXllci5iaW5kKHRoaXMpLFxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNyZW5hbWVMYXllclxuICAgICAgICovXG4gICAgICByZW5hbWVMYXllcjogdGhpcy5yZW5hbWVMYXllci5iaW5kKHRoaXMpLFxuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEBtZXRob2RcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI2dldExheWVyV2VpZ2h0XG4gICAgICAgKi9cbiAgICAgIGdldExheWVyV2VpZ2h0OiB0aGlzLmdldExheWVyV2VpZ2h0LmJpbmQodGhpcyksXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEBtZXRob2RcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI3NldExheWVyV2VpZ2h0XG4gICAgICAgKi9cbiAgICAgIHNldExheWVyV2VpZ2h0OiB0aGlzLnNldExheWVyV2VpZ2h0LmJpbmQodGhpcyksXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEBtZXRob2RcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI3BhdXNlTGF5ZXJXZWlnaHRcbiAgICAgICAqL1xuICAgICAgcGF1c2VMYXllcldlaWdodDogdGhpcy5wYXVzZUxheWVyV2VpZ2h0LmJpbmQodGhpcyksXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEBtZXRob2RcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI3Jlc3VtZUxheWVyV2VpZ2h0XG4gICAgICAgKi9cbiAgICAgIHJlc3VtZUxheWVyV2VpZ2h0OiB0aGlzLnJlc3VtZUxheWVyV2VpZ2h0LmJpbmQodGhpcyksXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEBtZXRob2RcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI3BhdXNlTGF5ZXJcbiAgICAgICAqL1xuICAgICAgcGF1c2VMYXllcjogdGhpcy5wYXVzZUxheWVyLmJpbmQodGhpcyksXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEBtZXRob2RcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI3Jlc3VtZUxheWVyXG4gICAgICAgKi9cbiAgICAgIHJlc3VtZUxheWVyOiB0aGlzLnJlc3VtZUxheWVyLmJpbmQodGhpcyksXG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQG1ldGhvZFxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjZ2V0VHJhbnNpdGlvbmluZ1xuICAgICAgICovXG4gICAgICBnZXRUcmFuc2l0aW9uaW5nOiB0aGlzLmdldFRyYW5zaXRpb25pbmcuYmluZCh0aGlzKSxcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQG1ldGhvZFxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjZ2V0QW5pbWF0aW9uc1xuICAgICAgICovXG4gICAgICBnZXRBbmltYXRpb25zOiB0aGlzLmdldEFuaW1hdGlvbnMuYmluZCh0aGlzKSxcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQG1ldGhvZFxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjZ2V0Q3VycmVudEFuaW1hdGlvblxuICAgICAgICovXG4gICAgICBnZXRDdXJyZW50QW5pbWF0aW9uOiB0aGlzLmdldEN1cnJlbnRBbmltYXRpb24uYmluZCh0aGlzKSxcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQG1ldGhvZFxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjZ2V0UGF1c2VkXG4gICAgICAgKi9cbiAgICAgIGdldFBhdXNlZDogdGhpcy5nZXRQYXVzZWQuYmluZCh0aGlzKSxcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQG1ldGhvZFxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjZ2V0QW5pbWF0aW9uVHlwZVxuICAgICAgICovXG4gICAgICBnZXRBbmltYXRpb25UeXBlOiB0aGlzLmdldEFuaW1hdGlvblR5cGUuYmluZCh0aGlzKSxcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQG1ldGhvZFxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjYWRkQW5pbWF0aW9uXG4gICAgICAgKi9cbiAgICAgIGFkZEFuaW1hdGlvbjogdGhpcy5hZGRBbmltYXRpb24uYmluZCh0aGlzKSxcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQG1ldGhvZFxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjcmVtb3ZlQW5pbWF0aW9uXG4gICAgICAgKi9cbiAgICAgIHJlbW92ZUFuaW1hdGlvbjogdGhpcy5yZW1vdmVBbmltYXRpb24uYmluZCh0aGlzKSxcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQG1ldGhvZFxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjcmVuYW1lQW5pbWF0aW9uXG4gICAgICAgKi9cbiAgICAgIHJlbmFtZUFuaW1hdGlvbjogdGhpcy5yZW5hbWVBbmltYXRpb24uYmluZCh0aGlzKSxcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNnZXRBbmltYXRpb25CbGVuZE5hbWVzXG4gICAgICAgKi9cbiAgICAgIGdldEFuaW1hdGlvbkJsZW5kTmFtZXM6IHRoaXMuZ2V0QW5pbWF0aW9uQmxlbmROYW1lcy5iaW5kKHRoaXMpLFxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNnZXRBbmltYXRpb25CbGVuZFdlaWdodFxuICAgICAgICovXG4gICAgICBnZXRBbmltYXRpb25CbGVuZFdlaWdodDogdGhpcy5nZXRBbmltYXRpb25CbGVuZFdlaWdodC5iaW5kKHRoaXMpLFxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNzZXRBbmltYXRpb25CbGVuZFdlaWdodFxuICAgICAgICovXG4gICAgICBzZXRBbmltYXRpb25CbGVuZFdlaWdodDogdGhpcy5zZXRBbmltYXRpb25CbGVuZFdlaWdodC5iaW5kKHRoaXMpLFxuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEBtZXRob2RcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI3BsYXlBbmltYXRpb25cbiAgICAgICAqL1xuICAgICAgcGxheUFuaW1hdGlvbjogdGhpcy5wbGF5QW5pbWF0aW9uLmJpbmQodGhpcyksXG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQG1ldGhvZFxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjcGxheU5leHRBbmltYXRpb25cbiAgICAgICAqL1xuICAgICAgcGxheU5leHRBbmltYXRpb246IHRoaXMucGxheU5leHRBbmltYXRpb24uYmluZCh0aGlzKSxcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNwYXVzZUFuaW1hdGlvblxuICAgICAgICovXG4gICAgICBwYXVzZUFuaW1hdGlvbjogdGhpcy5wYXVzZUFuaW1hdGlvbi5iaW5kKHRoaXMpLFxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNyZXN1bWVBbmltYXRpb25cbiAgICAgICAqL1xuICAgICAgcmVzdW1lQW5pbWF0aW9uOiB0aGlzLnJlc3VtZUFuaW1hdGlvbi5iaW5kKHRoaXMpLFxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNzdG9wQW5pbWF0aW9uXG4gICAgICAgKi9cbiAgICAgIHN0b3BBbmltYXRpb246IHRoaXMuc3RvcEFuaW1hdGlvbi5iaW5kKHRoaXMpLFxuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEBtZXRob2RcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI3BhdXNlXG4gICAgICAgKi9cbiAgICAgIHBhdXNlOiB0aGlzLnBhdXNlLmJpbmQodGhpcyksXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEBtZXRob2RcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI3Jlc3VtZVxuICAgICAgICovXG4gICAgICByZXN1bWU6IHRoaXMucmVzdW1lLmJpbmQodGhpcyksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGVhY2ggYW5pbWF0aW9uIGxheWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFUaW1lIC0gVGltZSBzaW5jZSB0aGUgbGFzdCB1cGRhdGUuXG4gICAqL1xuICB1cGRhdGUoZGVsdGFUaW1lKSB7XG4gICAgaWYgKCF0aGlzLl9sYXllcnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BhdXNlZCkge1xuICAgICAgZGVsdGFUaW1lID0gMDtcbiAgICB9XG5cbiAgICAvLyBSZS1ldmFsdWF0ZSBpbnRlcm5hbCB3ZWlnaHRzIGZvciBsYXllcnNcbiAgICB0aGlzLl91cGRhdGVJbnRlcm5hbFdlaWdodHMoKTtcblxuICAgIC8vIFVwZGF0ZSBsYXllcnNcbiAgICB0aGlzLl9sYXllcnMuZm9yRWFjaChsYXllciA9PiB7XG4gICAgICBsYXllci51cGRhdGUoZGVsdGFUaW1lKTtcbiAgICB9KTtcblxuICAgIHN1cGVyLnVwZGF0ZShkZWx0YVRpbWUpO1xuICB9XG5cbiAgZGlzY2FyZCgpIHtcbiAgICB0aGlzLl9sYXllcnMuZm9yRWFjaChsYXllciA9PiB7XG4gICAgICBsYXllci5kaXNjYXJkKCk7XG4gICAgfSk7XG5cbiAgICBkZWxldGUgdGhpcy5fbGF5ZXJzO1xuICAgIGRlbGV0ZSB0aGlzLl9sYXllck1hcDtcblxuICAgIHN1cGVyLmRpc2NhcmQoKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQW5pbWF0aW9uRmVhdHVyZSwgJ0VWRU5UUycsIHtcbiAgdmFsdWU6IHtcbiAgICAuLi5PYmplY3QuZ2V0UHJvdG90eXBlT2YoQWJzdHJhY3RIb3N0RmVhdHVyZSkuRVZFTlRTLFxuICAgIGFkZExheWVyOiAnb25BZGRMYXllckV2ZW50JyxcbiAgICByZW1vdmVMYXllcjogJ29uUmVtb3ZlTGF5ZXJFdmVudCcsXG4gICAgcmVuYW1lTGF5ZXI6ICdvblJlbmFtZUxheWVyRXZlbnQnLFxuICAgIGFkZEFuaW1hdGlvbjogJ29uQWRkQW5pbWF0aW9uRXZlbnQnLFxuICAgIHJlbW92ZUFuaW1hdGlvbjogJ29uUmVtb3ZlZEFuaW1hdGlvbkV2ZW50JyxcbiAgICByZW5hbWVBbmltYXRpb246ICdvblJlbmFtZUFuaW1hdGlvbkV2ZW50JyxcbiAgICBwbGF5QW5pbWF0aW9uOiAnb25QbGF5RXZlbnQnLFxuICAgIHBsYXlOZXh0QW5pbWF0aW9uOiAnb25OZXh0RXZlbnQnLFxuICAgIHBhdXNlQW5pbWF0aW9uOiAnb25QYXVzZUV2ZW50JyxcbiAgICByZXN1bWVBbmltYXRpb246ICdvblJlc3VtZUV2ZW50JyxcbiAgICBpbnRlcnJ1cHRBbmltYXRpb246ICdvbkludGVycnVwdEV2ZW50JyxcbiAgICBzdG9wQW5pbWF0aW9uOiAnb25TdG9wRXZlbnQnLFxuICB9LFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEFuaW1hdGlvbkZlYXR1cmU7XG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZXJzY29yZS1kYW5nbGUgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQgTWFuYWdlZEFuaW1hdGlvbkxheWVySW50ZXJmYWNlIGZyb20gJy4vYW5pbXBhY2svTWFuYWdlZEFuaW1hdGlvbkxheWVySW50ZXJmYWNlJztcbmltcG9ydCB7QW5pbWF0aW9uVHlwZXN9IGZyb20gJy4vYW5pbXBhY2svQW5pbWF0aW9uRmVhdHVyZSc7XG5pbXBvcnQgU1NNTFNwZWVjaG1hcmtJbnRlcmZhY2UgZnJvbSAnLi9hd3NwYWNrL1NTTUxTcGVlY2htYXJrSW50ZXJmYWNlJztcbmltcG9ydCBBYnN0cmFjdEhvc3RGZWF0dXJlIGZyb20gJy4vQWJzdHJhY3RIb3N0RmVhdHVyZSc7XG5pbXBvcnQge1F1YWRyYXRpY30gZnJvbSAnLi9hbmltcGFjay9FYXNpbmcnO1xuaW1wb3J0IE1hdGhVdGlscyBmcm9tICcuL01hdGhVdGlscyc7XG5pbXBvcnQgVXRpbHMgZnJvbSAnLi9VdGlscyc7XG5cbi8qKlxuICogRW51bSBmb3IgYXhpcyBkaXJlY3Rpb25zLlxuICpcbiAqIEByZWFkb25seVxuICogQGVudW0ge0NsYXNzfVxuICovXG5jb25zdCBBeGlzTWFwID0ge1xuICBQb3NpdGl2ZVg6IFsxLCAwLCAwXSxcbiAgTmVnYXRpdmVYOiBbLTEsIDAsIDBdLFxuICBQb3NpdGl2ZVk6IFswLCAxLCAwXSxcbiAgTmVnYXRpdmVZOiBbMCwgLTEsIDBdLFxuICBQb3NpdGl2ZVo6IFswLCAwLCAxXSxcbiAgTmVnYXRpdmVaOiBbMCwgMCwgLTFdLFxufTtcblxuY29uc3QgRmFjZVRhcmdldFR5cGVzID0ge1xuICBFeWVDZW50ZXI6IDAsXG4gIEV5ZUxlZnQ6IDEsXG4gIEV5ZVJpZ2h0OiAyLFxuICBNb3V0aDogMyxcbn07XG5cbi8vIEF2ZXJhZ2UgZGlzdGFuY2UgYmV0d2VlbiBwdXBpbHMgaXMgLjA2NG0sIGdvbGRlbiByYXRpbyBzYXlzIHRoYXQgdGhlIGRpc3RhbmNlXG4vLyBmcm9tIGNlbnRlciBvZiB0aGUgcHVwaWxzIHRvIHRoZSBjZW50ZXIgb2YgdGhlIG1vdXRoIHNob3VsZCBiZSBhYm91dCB0aGUgc2FtZS5cbmNvbnN0IEZhY2VWZWN0b3JzID0gW1xuICBbMCwgMCwgMF0sXG4gIFstMC4wMzIsIDAsIDBdLFxuICBbMC4wMzIsIDAsIDBdLFxuICBbMCwgLTAuMDY0LCAwXSxcbl07XG5cbi8vIFRpbWUgcmFuZ2VzIHRvIHVzZSB3aGVuIGNob29zaW5nIGEgbmV3IHJhbmRvbSB3YWl0IHRpbWUgYmV0d2VlbiBzYWNjYWRlc1xuY29uc3QgTWljcm9TYWNjYWRlV2FpdFJhbmdlcyA9IHtcbiAgZGVmYXVsdDogWzAuOCwgMS43NV0sXG4gIHBvc3RNYWNybzogWzAuNiwgMS4zMTI1XSxcbn07XG5cbmNvbnN0IE1hY3JvU2FjY2FkZVdhaXRSYW5nZXMgPSB7XG4gIGRlZmF1bHQ6IFs1LjAsIDguMF0sXG4gIG1vdXRoVGFyZ2V0OiBbMC4yLCAwLjc1XSwgLy8gTG9vayBhd2F5IGZyb20gYSBtb3V0aCB0YXJnZXQgdGhlIGZhc3Rlc3RcbiAgZXllVGFyZ2V0OiBbMS41LCA0LjBdLFxufTtcblxuLy8gTWluaW11bSBhbmdsZSBpbiBkZWdyZWVzIHRoZSBleWUgZGlyZWN0aW9uIG11c3QgY2hhbmdlIHRvIHRyaWdnZXIgYSBibGluayBhbmltYXRpb25cbmNvbnN0IEJsaW5rVGhyZXNob2xkID0gMzU7XG5cbi8vIE1heGltdW0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB1c2UgZm9yIGNhbGN1bGF0aW5nIGxvb2sgc3BlZWRcbmNvbnN0IE1heERlbHRhID0gMTAwIC8gMztcblxuLyoqXG4gKiBQb2ludE9mSW50ZXJlc3QgY29udHJvbHMgdGhlIGdhemUgZGlyZWN0aW9uIG9mIHRoZSBob3N0LiBHaXZlbiBvbmUgb3IgbW9yZVxuICogYW5pbWF0aW9ucyBvZiB0eXBlIEJsZW5kMmRTdGF0ZSwgaXQgY2FsY3VsYXRlcyB0aGUgYW5nbGVzIGJldHdlZW4gdGhlIGxvb2tUcmFja2VyXG4gKiBvYmplY3QgKGdlbmVyYWxseSBhIGpvaW50IGluIHRoZSBob3N0J3Mgc2tlbGV0b24pIGFuZCB0aGUgbG9va1RhcmdldCAodGhlIG9iamVjdFxuICogdGhlIGhvc3Qgc2hvdWxkIGxvb2sgYXQpIGFuZCBkcml2ZXMgdGhlIG1hbmFnZWQgQmxlbmQyZFN0YXRlcycgWCBhbmQgWSBibGVuZFxuICogdmFsdWVzIHVzaW5nIHRoZSByZXN1bHQuIFlvdSBjYW4gb3B0aW9uYWxseSBhZGQgc2FjY2FkaWMgbW92ZW1lbnQgdG8gYW55IG1hbmFnZWRcbiAqIGFuaW1hdGlvbiB0byBoZWxwIG1ha2UgdGhlIGhvc3QncyBleWVzIGFwcGVhciBhbGl2ZSB3aGVuIGZvY3VzZWQgb24gdGhlIHNhbWVcbiAqIHBvaW50IGZvciBleHRlZGVkIHBlcmlvZHMgb2YgdGltZS4gSWYgYmxpbmsgYW5pbWF0aW9ucyBhcmUgc3BlY2lmaWVkLCBhIGJsaW5rXG4gKiB3aWxsIGJlIHBsYXllZCBkdXJpbmcgbGFyZ2UgY2hhbmdlcyBpbiBnYXplIGRpcmVjdGlvbi5cbiAqXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEhvc3RGZWF0dXJlXG4gKiBAYWxpYXMgY29yZS9Qb2ludE9mSW50ZXJlc3RGZWF0dXJlXG4gKiBAaW1wbGVtZW50cyBTU01MU3BlZWNobWFya0ludGVyZmFjZVxuICogQGltcGxlbWVudHMgTWFuYWdlZEFuaW1hdGlvbkxheWVySW50ZXJmYWNlXG4gKi9cbmNsYXNzIFBvaW50T2ZJbnRlcmVzdEZlYXR1cmUgZXh0ZW5kcyBBYnN0cmFjdEhvc3RGZWF0dXJlLm1peChcbiAgU1NNTFNwZWVjaG1hcmtJbnRlcmZhY2UuTWl4aW4sXG4gIE1hbmFnZWRBbmltYXRpb25MYXllckludGVyZmFjZS5NaXhpblxuKSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtIHtjb3JlL0hvc3RPYmplY3R9IGhvc3QgLSBIb3N0IHRoYXQgb3ducyB0aGUgZmVhdHVyZS5cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGZlYXR1cmUuXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gdGFyZ2V0IC0gM0QgdHJhbnNmb3JtYXRpb24gbm9kZSB0aGF0IHRoZSBob3N0IHNob3VsZCB0cnkgdG9cbiAgICogbG9vayBhdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMubG9va1RyYWNrZXIgLSAzRCB0cmFuc2Zvcm1hdGlvbiBub2RlIHRoYXQgcmVwcmVzZW50c1xuICAgKiB0aGUgZGlyZWN0aW9uIHRoZSBob3N0IGlzIGN1cnJlbnRseSBsb29raW5nIGR1cmluZyBhbmltYXRpb24uXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucy5zY2VuZSAtIEVuZ2luZS1zcGVjaWZpYyBzY2VuZSBvYmplY3QgdGhhdCBjb250YWluc1xuICAgKiB0aGUgaG9zdC4gVGhpcyBvYmplY3QgbXVzdCBiZSBkZWZpbmVkIGlmIHVzaW5nICdzZXRUYXJnZXRCeU5hbWUnIG9yICdTZXRUYXJnZXRCeUlkJ1xuICAgKiBtZXRob2RzLlxuICAgKiBAcGFyYW0ge09iamVjdD19IGxvb2tPcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGxvb2sgYW5pbWF0aW9uIGxheWVycy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtsb29rT3B0aW9ucy5ibGVuZFRpbWU9MC4xXSAtIERlZmF1bHQgYW1vdW50IG9mIHRpbWUgaXQgd2lsbFxuICAgKiB0YWtlIHRvIG1hbmlwdWxhdGUgdGhlIHdlaWdodHMgb2YgdGhlIGxvb2sgbGF5ZXJzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2xvb2tPcHRpb25zLmVhc2luZ0ZuPVF1YWRyYXRpYy5Jbk91dF0gLSBEZWZhdWx0IGVhc2luZyBmdW5jdGlvblxuICAgKiB0byB1c2Ugd2hlbiBtYW5pcHVsYXRpbmcgbG9vayBsYXllciB3ZWlnaHRzLlxuICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBbbG9va09wdGlvbnMubGF5ZXJzPVtdXSAtIEFuIGFycmF5IG9mIGxheWVyIG9wdGlvbnNcbiAgICogb2JqZWN0cyB0byByZWdpc3RlciBhcyBsb29rIGxheWVycy5cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBibGlua09wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgYmxpbmsgYW5pbWF0aW9uIGxheWVycy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtibGlua09wdGlvbnMuYmxlbmRUaW1lPTAuMDc1XSAtIERlZmF1bHQgYW1vdW50IG9mIHRpbWUgaXRcbiAgICogd2lsbCB0YWtlIHRvIG1hbmlwdWxhdGUgdGhlIHdlaWdodHMgb2YgdGhlIGJsaW5rIGxheWVycy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtibGlua09wdGlvbnMuZWFzaW5nRm49UXVhZHJhdGljLkluT3V0XSAtIERlZmF1bHQgZWFzaW5nIGZ1bmN0aW9uXG4gICAqIHRvIHVzZSB3aGVuIG1hbmlwdWxhdGluZyBibGluayBsYXllciB3ZWlnaHRzLlxuICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBbYmxpbmtPcHRpb25zLmxheWVycz1bXV0gLSBBbiBhcnJheSBvZiBsYXllciBvcHRpb25zXG4gICAqIG9iamVjdHMgdG8gcmVnaXN0ZXIgYXMgYmxpbmsgbGF5ZXJzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgaG9zdCxcbiAgICB7dGFyZ2V0LCBsb29rVHJhY2tlciwgc2NlbmV9ID0ge30sXG4gICAge1xuICAgICAgYmxlbmRUaW1lOiBsb29rQmxlbmRUaW1lID0gMC4xLFxuICAgICAgZWFzaW5nRm46IGxvb2tFYXNpbmdGbiA9IFF1YWRyYXRpYy5Jbk91dCxcbiAgICAgIGxheWVyczogbG9va0xheWVycyA9IFtdLFxuICAgIH0gPSB7fSxcbiAgICB7XG4gICAgICBibGVuZFRpbWU6IGJsaW5rQmxlbmRUaW1lID0gMC4wNzUsXG4gICAgICBlYXNpbmdGbjogYmxpbmtFYXNpbmdGbiA9IFF1YWRyYXRpYy5Jbk91dCxcbiAgICAgIGxheWVyczogYmxpbmtMYXllcnMgPSBbXSxcbiAgICB9ID0ge31cbiAgKSB7XG4gICAgc3VwZXIoaG9zdCk7XG5cbiAgICBpZiAoIXRoaXMuY29uc3RydWN0b3IuX3ZhbGlkYXRlVHJhbnNmb3JtT2JqZWN0KGxvb2tUcmFja2VyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGluaXRpYWxpemUgUG9pbnRPZkludGVyZXN0RmVhdHVyZSBvbiBob3N0ICR7dGhpcy5faG9zdC5pZH0uIExvb2tUcmFja2VyIG11c3QgYmUgZGVmaW5lZCBhcyBhIHZhbGlkIHRyYW5zZm9ybWF0aW9uIG9iamVjdC5gXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLl9sb29rVHJhY2tlciA9IGxvb2tUcmFja2VyO1xuXG4gICAgdGhpcy5fc2NlbmUgPSBzY2VuZTtcbiAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQgfHwgbnVsbDtcbiAgICB0aGlzLl9wcmV2VGFyZ2V0UG9zID0gWzAsIDAsIDBdO1xuICAgIHRoaXMuX2lzVGFyZ2V0TW92aW5nID0gZmFsc2U7XG4gICAgdGhpcy5fbG9va0xheWVycyA9IHRoaXMuX2xvb2tMYXllcnMgfHwge307XG4gICAgdGhpcy5fdHJhY2tpbmdDb25maWdzID0gdGhpcy5fdHJhY2tpbmdDb25maWdzIHx8IFtdO1xuICAgIHRoaXMuX2JsaW5rTGF5ZXJzID0gdGhpcy5fYmxpbmtMYXllcnMgfHwge307XG5cbiAgICAvLyBSZWdpc3RlciB0aGUgbG9vayBsYXllcnNcbiAgICBsb29rTGF5ZXJzLmZvckVhY2goXG4gICAgICAoe1xuICAgICAgICBuYW1lLFxuICAgICAgICBhbmltYXRpb24sXG4gICAgICAgIG1heFNwZWVkLFxuICAgICAgICByZWZlcmVuY2UsXG4gICAgICAgIGZvcndhcmRBeGlzLFxuICAgICAgICBoYXNTYWNjYWRlLFxuICAgICAgICBibGVuZFRpbWUsXG4gICAgICAgIGVhc2luZ0ZuLFxuICAgICAgfSkgPT4ge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyTG9va0xheWVyKG5hbWUsIHtcbiAgICAgICAgICBhbmltYXRpb24sXG4gICAgICAgICAgbWF4U3BlZWQsXG4gICAgICAgICAgcmVmZXJlbmNlLFxuICAgICAgICAgIGZvcndhcmRBeGlzLFxuICAgICAgICAgIGhhc1NhY2NhZGUsXG4gICAgICAgICAgYmxlbmRUaW1lOiBibGVuZFRpbWUgIT09IHVuZGVmaW5lZCA/IGJsZW5kVGltZSA6IGxvb2tCbGVuZFRpbWUsXG4gICAgICAgICAgZWFzaW5nRm46IGVhc2luZ0ZuICE9PSB1bmRlZmluZWQgPyBlYXNpbmdGbiA6IGxvb2tFYXNpbmdGbixcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgKTtcblxuICAgIC8vIFJlZ2lzdGVyIHRoZSBibGluayBsYXllcnNcbiAgICBibGlua0xheWVycy5mb3JFYWNoKCh7bmFtZSwgYW5pbWF0aW9uLCBibGVuZFRpbWUsIGVhc2luZ0ZufSkgPT4ge1xuICAgICAgdGhpcy5yZWdpc3RlckJsaW5rTGF5ZXIobmFtZSwge1xuICAgICAgICBhbmltYXRpb24sXG4gICAgICAgIGJsZW5kVGltZTogYmxlbmRUaW1lICE9PSB1bmRlZmluZWQgPyBibGVuZFRpbWUgOiBibGlua0JsZW5kVGltZSxcbiAgICAgICAgZWFzaW5nRm46IGVhc2luZ0ZuICE9PSB1bmRlZmluZWQgPyBlYXNpbmdGbiA6IGJsaW5rRWFzaW5nRm4sXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuZCBzZXRzIHRoZSB0YXJnZXQgb2JqZWN0IHRoZSBob3N0IHNob3VsZCBsb29rIGF0LlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fG51bGx9XG4gICAqL1xuICBnZXQgdGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl90YXJnZXQ7XG4gIH1cblxuICBzZXQgdGFyZ2V0KHRhcmdldCkge1xuICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldCB8fCBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGdsb2JhbCBwb3NpdGlvbiBvZiBhbiBvYmplY3QuIFNob3VsZCBiZVxuICAgKiBvdmVybG9hZGVkIGZvciBlYWNoIHJlbmRlcmluZyBlbmdpbmUgaW1wbGVtZW50YXRpb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSBfb2JqIC0gRW5naW5lLXNwZWNpZmljIDNEIHRyYW5zZm9ybSBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheS48bnVtYmVyPn0gLSBBbiBhcnJheSBjb25zaXN0aW5nIG9mIHRocmVlIG51bWJlcnMgcmVwcmVzZW50aW5nXG4gICAqIHgsIHkgYW5kIHogY29vcmRpbmF0ZXMuXG4gICAqL1xuICBzdGF0aWMgX2dldFdvcmxkUG9zaXRpb24ob2JqKSB7XG4gICAgcmV0dXJuIFswLCAwLCAwXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBtYXRyaXggcmVwcmVzZW50aW5nIHRoZSBnbG9iYWwgdHJhbnNmb3JtYXRpb24gbWF0cml4IG9mIGFuIG9iamVjdC5cbiAgICogU2hvdWxkIGJlIG92ZXJsb2FkZWQgZm9yIGVhY2ggcmVuZGVyaW5nIGVuZ2luZSBpbXBsZW1lbnRhdGlvbi5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHthbnl9IG9iaiAtIEVuZ2luZS1zcGVjaWZpYyAzRCB0cmFuc2Zvcm0gb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59IC0gQW4gYXJyYXkgY29uc2lzdGluZyBvZiAxNiBudW1iZXJzIHJlcHJlc2VudGluZ1xuICAgKiB0aGUgM2QgdHJhbnNmb3JtYXRpb24uXG4gICAqL1xuICBzdGF0aWMgX2dldFdvcmxkTWF0cml4KG9iaikge1xuICAgIHJldHVybiBbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV07XG4gIH1cblxuICAvKipcbiAgICogUm90YXRlIHRoZSBnaXZlbiBsb2NhbCBkaXJlY3Rpb24gdmVjdG9yIGJ5IHRoZSBvYmplY3QncyB3b3JsZCByb3RhdGlvbiBtYXRyaXguXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSBvYmogLSBFbmdpbmUtc3BlY2lmaWMgM0QgdHJhbnNmb3JtIG9iamVjdC5cbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZm9yd2FyZFZlY3RvciAtIFVuaXQgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgbG9jYWxcbiAgICogZm9yd2FyZCBkaXJlY3Rpb24gb2YgdGhlIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybnMge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgc3RhdGljIF9nZXRPYmplY3REaXJlY3Rpb24ob2JqLCBmb3J3YXJkVmVjdG9yID0gQXhpc01hcC5Qb3NpdGl2ZVopIHtcbiAgICBjb25zdCByb3RhdGlvbiA9IE1hdGhVdGlscy5nZXRSb3RhdGlvbk1hdHJpeCh0aGlzLl9nZXRXb3JsZE1hdHJpeChvYmopKTtcblxuICAgIHJldHVybiBNYXRoVXRpbHMucm90YXRlVmVjdG9yKGZvcndhcmRWZWN0b3IsIHJvdGF0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgbG9vayBhbmdsZXMgaW4gZGVncmVlcyBnaXZlbiBzcGhlcmljYWwgdGhldGFcbiAgICogYW5kIHBoaSBhbmdsZXMgaW4gcmFkaWFucy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRoZXRhIC0gVmVydGljYWwvcG9sYXIgYW5nbGUgaW4gcmFkaWFucyB3aGVyZSAwIHBvaW50cyBkaXJlY3RseVxuICAgKiBhbG9uZyBwb3NpdGl2ZSBZIGF4aXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaGkgLSBIb3Jpem9udGFsL2F6aW11dGhhbCBhbmdsZSBpbiByYWRpYW5zLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSAtIEFuIG9iamVjdCB3aXRoIHRoZSBzaWduYXR1cmUge2g6IG51bWJlciwgdjogbnVtYmVyfSB3aGVyZVxuICAgKiBoIHJlcHJlc2VudHMgaG9yaXpvbnRhbCByb3RhdGlvbiBpbiBkZWdyZWVzIGFuZCB2IHJlcHJlc2VudHMgdmVydGljYWwgcm90YXRpb25cbiAgICogaW4gZGVncmVlcy5cbiAgICovXG4gIHN0YXRpYyBfc3BoZXJpY2FsVG9CbGVuZFZhbHVlKHRoZXRhLCBwaGkpIHtcbiAgICBjb25zdCBoID0gTWF0aFV0aWxzLnRvRGVncmVlcyhwaGkpO1xuXG4gICAgLy8gT2Zmc2V0IHRoZSB2ZXJ0aWNhbCBhbmdsZSBzbyAwIGlzIHBvaW50aW5nIGZvcndhcmQgaW5zdGVhZCBvZiB1cFxuICAgIGNvbnN0IHYgPSBNYXRoVXRpbHMudG9EZWdyZWVzKHRoZXRhKSAtIDkwO1xuXG4gICAgLy8gQ29udmVydCB2ZXJ0aWNhbCBhbmdsZSB0byAtMTgwLCAxODAgcmFuZ2VcbiAgICByZXR1cm4ge2gsIHZ9O1xuICB9XG5cbiAgX29uTGF5ZXJBZGRlZCh7bmFtZX0pIHtcbiAgICB0aGlzLl9sb29rTGF5ZXJzID0gdGhpcy5fbG9va0xheWVycyB8fCB7fTtcbiAgICB0aGlzLl9ibGlua0xheWVycyA9IHRoaXMuX2JsaW5rTGF5ZXJzIHx8IHt9O1xuXG4gICAgc3VwZXIuX29uTGF5ZXJBZGRlZCh7bmFtZX0pO1xuXG4gICAgLy8gVmFsaWRhdGUgdGhlIGxvb2sgYW5pbWF0aW9uXG4gICAgaWYgKHRoaXMuX2xvb2tMYXllcnNbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcmVnaXN0ZXJMb29rQW5pbWF0aW9uKG5hbWUsIHRoaXMuX2xvb2tMYXllcnNbbmFtZV0pO1xuICAgIH1cbiAgfVxuXG4gIF9vbkFuaW1hdGlvbkFkZGVkKHtsYXllck5hbWUsIGFuaW1hdGlvbk5hbWV9KSB7XG4gICAgdGhpcy5fbG9va0xheWVycyA9IHRoaXMuX2xvb2tMYXllcnMgfHwge307XG4gICAgdGhpcy5fYmxpbmtMYXllcnMgPSB0aGlzLl9ibGlua0xheWVycyB8fCB7fTtcblxuICAgIHN1cGVyLl9vbkFuaW1hdGlvbkFkZGVkKHtsYXllck5hbWV9KTtcblxuICAgIC8vIFZhbGlkYXRlIHRoZSBsb29rIGFuaW1hdGlvblxuICAgIGlmICh0aGlzLl9sb29rTGF5ZXJzW2xheWVyTmFtZV0gPT09IGFuaW1hdGlvbk5hbWUpIHtcbiAgICAgIHRoaXMuX3JlZ2lzdGVyTG9va0FuaW1hdGlvbihsYXllck5hbWUsIGFuaW1hdGlvbk5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbnN1cmUgdGhhdCByZWdpc3RlcmVkIGxvb2sgYW5pbWF0aW9ucyBhcmUgQmxlbmQyZFN0YXRlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRoYXQgY29udGFpbnMgdGhlIGxvb2sgYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYW5pbWF0aW9uTmFtZSAtIE5hbWUgb2YgdGhlIGFuaW1hdGlvbi5cbiAgICovXG4gIF9yZWdpc3Rlckxvb2tBbmltYXRpb24obGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lKSB7XG4gICAgaWYgKHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXS5hbmltYXRpb25zW2FuaW1hdGlvbk5hbWVdLmlzQWN0aXZlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIEFuaW1hdGlvblR5cGVzW1xuICAgICAgICAgIHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5nZXRBbmltYXRpb25UeXBlKGxheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSlcbiAgICAgICAgXSAhPT0gQW5pbWF0aW9uVHlwZXMuYmxlbmQyZFxuICAgICAgKSB7XG4gICAgICAgIC8vIFdhcm4gYW5kIGRlYWN0aXZhdGUgaWYgdGhlIHJlZ2lzdGVyZWQgc3RhdGUgaXMgbm90IGJsZW5kMmRcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBDYW5ub3QgcmVnaXN0ZXIgUG9pbnQgb2YgSW50ZXJlc3QgbG9vayBhbmltYXRpb24gJHthbmltYXRpb25OYW1lfSBvbiBsYXllciAke2xheWVyTmFtZX0gZm9yIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTG9vayBhbmltYXRpb25zIG11c3QgYmUgb2YgdHlwZSAnYmxlbmQyZCcuYFxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0uYW5pbWF0aW9uc1tcbiAgICAgICAgICBhbmltYXRpb25OYW1lXG4gICAgICAgIF0uaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGdpdmVuIG9iamVjdCBpcyBub3Qgb2YgYW4gZW5naW5lLXNwZWNpZmljIHR5cGUuIFNob3VsZFxuICAgKiBiZSBvdmVybG9hZGVkIGZvciBlYWNoIHJlbmRlcmluZyBlbmdpbmUgaW1wbGVtZW50YXRpb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSBvYmogLSBPYmplY3QgdG8gdmFsaWRhdGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIF92YWxpZGF0ZVRyYW5zZm9ybU9iamVjdChvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgT2JqZWN0O1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBnaXZlbiBjb25maWd1cmF0aW9uIG9iamVjdCBoYXMgYWxyZWFkeSBiZWVuIHN0b3JlZCBhcyBhIHRyYWNraW5nXG4gICAqIGNvbmZpZy4gSWYgaXQgaGFzLCByZXR1cm4gdGhlIHN0b3JlZCBjb25maWd1cmF0aW9uLiBPdGhlcndpc2UsIHN0b3JlIGFuZFxuICAgKiByZXR1cm4gaXQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgLSBPYmplY3QgY29udGFpbmluZyB0cmFja2VyLCByZWZlcmVuY2UgYW5kIGZvcndhcmRBeGlzXG4gICAqIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqL1xuICBfYWRkVHJhY2tpbmdDb25maWcoY29uZmlnKSB7XG4gICAgY29uc3QgdHJhY2tpbmdDb25maWcgPSB0aGlzLl90cmFja2luZ0NvbmZpZ3MuZmluZChcbiAgICAgIGMgPT5cbiAgICAgICAgYy5yZWZlcmVuY2UgPT09IGNvbmZpZy5yZWZlcmVuY2UgJiYgYy5mb3J3YXJkQXhpcyA9PT0gY29uZmlnLmZvcndhcmRBeGlzXG4gICAgKTtcblxuICAgIGlmICh0cmFja2luZ0NvbmZpZykge1xuICAgICAgcmV0dXJuIHRyYWNraW5nQ29uZmlnO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25maWcuYW5nbGVzID0ge2g6IDAsIHY6IDB9O1xuICAgICAgY29uZmlnLnByZXZBbmdsZXMgPSB7aDogMCwgdjogMH07XG4gICAgICB0aGlzLl90cmFja2luZ0NvbmZpZ3MucHVzaChjb25maWcpO1xuICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBsb29rIHRyYWNrZXIgYW5kIHRoZSBsb29rIHRhcmdldC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIF9nZXRUYXJnZXREaXN0YW5jZSgpIHtcbiAgICAvLyBGaW5kIHRoZSB2ZWN0b3IgYmV0d2VlbiB0aGUgZ2xvYmFsIHBvc2l0aW9ucyBvZiB0cmFja2VyIGFuZCB0YXJnZXRcbiAgICBjb25zdCBzb3VyY2VQb3NpdGlvbiA9IHRoaXMuY29uc3RydWN0b3IuX2dldFdvcmxkUG9zaXRpb24oXG4gICAgICB0aGlzLl9sb29rVHJhY2tlclxuICAgICk7XG4gICAgY29uc3QgdGFyZ2V0UG9zaXRpb24gPSB0aGlzLmNvbnN0cnVjdG9yLl9nZXRXb3JsZFBvc2l0aW9uKHRoaXMuX3RhcmdldCk7XG4gICAgY29uc3QgbG9va1ZlY3RvciA9IFtcbiAgICAgIHRhcmdldFBvc2l0aW9uWzBdIC0gc291cmNlUG9zaXRpb25bMF0sXG4gICAgICB0YXJnZXRQb3NpdGlvblsxXSAtIHNvdXJjZVBvc2l0aW9uWzFdLFxuICAgICAgdGFyZ2V0UG9zaXRpb25bMl0gLSBzb3VyY2VQb3NpdGlvblsyXSxcbiAgICBdO1xuXG4gICAgcmV0dXJuIE1hdGhVdGlscy5nZXRWZWN0b3JNYWduaXR1ZGUobG9va1ZlY3Rvcik7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgYWxsIHN0b3JlZCB0cmFja2luZyBhbmdsZXMgdG8gMC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZXNldExvb2tBbmdsZXMoKSB7XG4gICAgdGhpcy5fdHJhY2tpbmdDb25maWdzLmZvckVhY2goKHthbmdsZXN9KSA9PiB7XG4gICAgICBhbmdsZXMuaCA9IDA7XG4gICAgICBhbmdsZXMudiA9IDA7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcmUgdGhlIGRpZmZlcmVuY2UgaW4gaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgcm90YXRpb24gZm9yIHRoZSB0cmFja2VyJ3NcbiAgICogcmVmZXJlbmNlIHJvdGF0aW9uIGFuZCB0aGUgZGlyZWN0aW9uIG9mIHRoZSB0YXJnZXQgZnJvbSB0aGUgdHJhY2tlci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRMb29rQW5nbGVzKCkge1xuICAgIC8vIEdldCB0aGUgY3VycmVudCBwb3NpdGlvbnMgb2YgdGhlIHRyYWNrZXIgYW5kIHRhcmdldCBvYmplY3RzXG4gICAgY29uc3QgdGFyZ2V0UG9zID0gdGhpcy5jb25zdHJ1Y3Rvci5fZ2V0V29ybGRQb3NpdGlvbih0aGlzLl90YXJnZXQpO1xuICAgIGNvbnN0IHRyYWNrZXJQb3MgPSB0aGlzLmNvbnN0cnVjdG9yLl9nZXRXb3JsZFBvc2l0aW9uKHRoaXMuX2xvb2tUcmFja2VyKTtcblxuICAgIC8vIENoZWNrIGlmIHRoZSB0YXJnZXQgaGFzIG1vdmVkXG4gICAgdGhpcy5faXNUYXJnZXRNb3ZpbmcgPVxuICAgICAgTWF0aFV0aWxzLmdldFZlY3Rvck1hZ25pdHVkZShbXG4gICAgICAgIHRhcmdldFBvc1swXSAtIHRoaXMuX3ByZXZUYXJnZXRQb3NbMF0sXG4gICAgICAgIHRhcmdldFBvc1sxXSAtIHRoaXMuX3ByZXZUYXJnZXRQb3NbMV0sXG4gICAgICAgIHRhcmdldFBvc1syXSAtIHRoaXMuX3ByZXZUYXJnZXRQb3NbMl0sXG4gICAgICBdKSA+IDA7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLl9wcmV2VGFyZ2V0UG9zLCB0YXJnZXRQb3MpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBhbmdsZXMgdG8gcm90YXRlIHRvIHRoZSB0YXJnZXRcbiAgICBjb25zdCB0YXJnZXRTcGhlcmljYWwgPSBNYXRoVXRpbHMuY2FydGVzaWFuVG9TcGhlcmljYWwoXG4gICAgICB0YXJnZXRQb3NbMF0gLSB0cmFja2VyUG9zWzBdLFxuICAgICAgdGFyZ2V0UG9zWzFdIC0gdHJhY2tlclBvc1sxXSxcbiAgICAgIHRhcmdldFBvc1syXSAtIHRyYWNrZXJQb3NbMl1cbiAgICApO1xuICAgIGNvbnN0IHRhcmdldEFuZ2xlcyA9IHRoaXMuY29uc3RydWN0b3IuX3NwaGVyaWNhbFRvQmxlbmRWYWx1ZShcbiAgICAgIHRhcmdldFNwaGVyaWNhbFsxXSxcbiAgICAgIHRhcmdldFNwaGVyaWNhbFsyXVxuICAgICk7XG5cbiAgICAvLyBDYWxjdWxhdGUgYW5nbGVzIHJlbGF0aXZlIHRvIHRoZSByZWZlcmVuY2Ugb2JqZWN0c1xuICAgIHRoaXMuX3RyYWNraW5nQ29uZmlncy5mb3JFYWNoKCh7cmVmZXJlbmNlLCBmb3J3YXJkQXhpcywgYW5nbGVzfSkgPT4ge1xuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBhbmdsZXMgdG8gcm90YXRlIHRvIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHRyYWNrZXJcbiAgICAgIGNvbnN0IHJlZkRpcmVjdGlvbiA9IHRoaXMuY29uc3RydWN0b3IuX2dldE9iamVjdERpcmVjdGlvbihcbiAgICAgICAgcmVmZXJlbmNlLFxuICAgICAgICBmb3J3YXJkQXhpc1xuICAgICAgKTtcbiAgICAgIGNvbnN0IHJlZlNwaGVyaWNhbCA9IE1hdGhVdGlscy5jYXJ0ZXNpYW5Ub1NwaGVyaWNhbCguLi5yZWZEaXJlY3Rpb24pO1xuICAgICAgY29uc3QgcmVmQW5nbGVzID0gdGhpcy5jb25zdHJ1Y3Rvci5fc3BoZXJpY2FsVG9CbGVuZFZhbHVlKFxuICAgICAgICByZWZTcGhlcmljYWxbMV0sXG4gICAgICAgIHJlZlNwaGVyaWNhbFsyXVxuICAgICAgKTtcblxuICAgICAgLy8gU3RvcmUgdGhlIGRpZmZlcmVuY2VcbiAgICAgIGFuZ2xlcy5oID0gdGFyZ2V0QW5nbGVzLmggLSByZWZBbmdsZXMuaDtcbiAgICAgIGFuZ2xlcy52ID0gdGFyZ2V0QW5nbGVzLnYgLSByZWZBbmdsZXMudjtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGFuZ2xlcyBpdCB3b3VsZCByZXF1aXJlIHRvIHNpbXVsYXRlIGxvb2tpbmdcbiAgICogYXQgdGhlIGdpdmVuIHR5cGUgb2YgZmFjZSB0YXJnZXRcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldFR5cGUgLSBJbnRlZ2VyIHJlcHJlc2VudGluZyB0aGUgRmFjZVRhcmdldFR5cGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9LSBBbiBvYmplY3Qgd2l0aCBzaWduYXR1cmUge3I6IG51bWJlciwgaDogbnVtYmVyLCB2OiBudW1iZXJ9XG4gICAqIHdoZXJlICdyJyByZXByZXNlbnRzIHJhZGl1cywgaCByZXByZXNlbnRzIHRoZSBob3Jpem9udGFsL2F6aW11dGhhbCBhbmdsZSBhbmRcbiAgICogdiByZXByZXNlbnRzIHRoZSB2ZXJ0aWNhbC9wb2xhciBhbmdsZS5cbiAgICovXG4gIF9nZXRGYWNlVGFyZ2V0QW5nbGVzKHRhcmdldFR5cGUpIHtcbiAgICAvLyBObyBvZmZzZXQgd2hlbiB0aGUgdGFyZ2V0IGlzIHRoZSBjZW50ZXIgb2YgdGhlIGV5ZXNcbiAgICBpZiAodGFyZ2V0VHlwZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHtoOiAwLCB2OiAwfTtcbiAgICB9XG5cbiAgICAvLyBCdWlsZCBhIHZlY3RvciB0byB0aGUgZmFjZSB0YXJnZXQgdHlwZSB1c2luZyB0aGUgY3VycmVudCBkaXN0YW5jZSB0byB0aGUgdGFyZ2V0XG4gICAgY29uc3QgZGlzdGFuY2UgPSB0aGlzLl9nZXRUYXJnZXREaXN0YW5jZSh0aGlzLl9sb29rVHJhY2tlcik7XG4gICAgY29uc3QgZmFjZVZlY3RvciA9IFsuLi5GYWNlVmVjdG9yc1t0YXJnZXRUeXBlXV07XG4gICAgZmFjZVZlY3RvclsyXSA9IGRpc3RhbmNlO1xuICAgIGNvbnN0IHNwaGVyaWNhbCA9IE1hdGhVdGlscy5jYXJ0ZXNpYW5Ub1NwaGVyaWNhbCguLi5mYWNlVmVjdG9yKTtcblxuICAgIC8vIE1ha2Ugc3VyZSB2YWx1ZXMgYXJlIGNsYW1wZWQgd2l0aGluIHRoZSByYW5nZSBvZiBtb3Rpb24gb2YgdGhlIGh1bWFuIGV5ZSwgaW4gY2FzZSB0aGUgdGFyZ2V0IGlzIHZlcnkgY2xvc2VcbiAgICBjb25zdCBibGVuZFZhbHVlcyA9IHRoaXMuY29uc3RydWN0b3IuX3NwaGVyaWNhbFRvQmxlbmRWYWx1ZShcbiAgICAgIHNwaGVyaWNhbFsxXSxcbiAgICAgIHNwaGVyaWNhbFsyXVxuICAgICk7XG4gICAgYmxlbmRWYWx1ZXMuaCA9IE1hdGhVdGlscy5jbGFtcChibGVuZFZhbHVlcy5oLCAtMzUsIDM1KTtcbiAgICBibGVuZFZhbHVlcy52ID0gTWF0aFV0aWxzLmNsYW1wKGJsZW5kVmFsdWVzLnYsIC0yNSwgMzApO1xuXG4gICAgcmV0dXJuIGJsZW5kVmFsdWVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZWQgdGhlIHN0b3JlZCBzcGVlZCBhbmQgZHVyYXRpb24gdmFyaWFibGVzIGZvciBhIGxheWVyIGJhc2VkIG9uIHRoZVxuICAgKiBjaGFuZ2UgaW4gaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgYW5nbGVzIG9mIHRoZSB0cmFja2VyLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdG8gc3RvcmUgdmFsdWVzIG9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaCAtIENoYW5nZSBpbiBob3Jpem9udGFsIGFuZ2xlLCBpbiBkZWdyZWVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdiAtIENoYW5nZSBpbiB2ZXJ0aWNhbCBhbmdsZSwgaW4gZGVncmVlcy5cbiAgICovXG4gIF91cGRhdGVMYXllclNwZWVkKGxheWVyTmFtZSwgaCwgdikge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdO1xuXG4gICAgLy8gRnJvbSBcIlJlYWxpc3RpYyBBdmF0YXIgYW5kIGhlYWQgQW5pbWF0aW9uIFVzaW5nIGEgTmV1cm9iaW9sb2dpY2FsIE1vZGVsIG9mIFZpc3VhbCBBdHRlbnRpb25cIiwgSXR0aSwgRGhhdmFsZSwgUGlnaGluXG4gICAgbGF5ZXIubWF4SFNwZWVkID0gNDczICogKDEgLSBNYXRoLmV4cCgtaCAvIDcuOCkpO1xuICAgIGxheWVyLm1heFZTcGVlZCA9IDQ3MyAqICgxIC0gTWF0aC5leHAoLXYgLyA3LjgpKTtcblxuICAgIC8vIEZyb20gXCJFeWVzIEFsaXZlXCIsIExlZSwgQmFkbGVyXG4gICAgY29uc3QgRDAgPSAwLjAyNTtcbiAgICBjb25zdCBkID0gMC4wMDIzNTtcbiAgICBsYXllci5oRHVyYXRpb24gPSBEMCArIGQgKiBoO1xuICAgIGxheWVyLnZEdXJhdGlvbiA9IEQwICsgZCAqIHY7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBtaWNyb1NhY2NhZGUgb2JqZWN0IHdpdGggbmV3IHJhbmRvbWl6ZWQgdmFsdWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCBvd25zIHRoZSBzYWNjYWRlIG1vdGlvbi5cbiAgICovXG4gIF9zZXRNaWNyb1NhY2NhZGUobGF5ZXJOYW1lKSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV07XG4gICAgY29uc3Qge21pY3JvU2FjY2FkZX0gPSBsYXllcjtcblxuICAgIGlmICh0aGlzLl90YXJnZXQpIHtcbiAgICAgIC8vIE1pY3JvIG1vdmVtZW50cyBzaG91bGQgYmUgc21hbGxlciB3aGVuIGZvY3VzZWQgb24gYSB0YXJnZXRcbiAgICAgIG1pY3JvU2FjY2FkZS5oID0gVXRpbHMuZ2V0UmFuZG9tRmxvYXQoMC4wMSwgMC4xNSk7XG4gICAgICBtaWNyb1NhY2NhZGUudiA9IFV0aWxzLmdldFJhbmRvbUZsb2F0KDAuMDEsIDAuMTUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNaWNyb3NhY2NhZGVzLiBFbmN5Y2xvcGVkaWEgb2YgTmV1cm9zY2llbmNlLiAoMjAwOSkgU3ByaW5nZXIsIEJlcmxpbiwgSGVpZGVsYmVyZy4gaHR0cHM6Ly9kb2kub3JnLzEwLjEwMDcvOTc4LTMtNTQwLTI5Njc4LTJfMzQ5MlxuICAgICAgbWljcm9TYWNjYWRlLmggPSBVdGlscy5nZXRSYW5kb21GbG9hdCgwLjAxLCAwLjMpO1xuICAgICAgbWljcm9TYWNjYWRlLnYgPSBVdGlscy5nZXRSYW5kb21GbG9hdCgwLjAxLCAwLjMpO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZUxheWVyU3BlZWQobGF5ZXJOYW1lLCBtaWNyb1NhY2NhZGUuaCwgbWljcm9TYWNjYWRlLnYpO1xuXG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXJcbiAgICB0aGlzLl9pbml0aWFsaXplTWljcm9UaW1lcihsYXllck5hbWUsIC4uLk1pY3JvU2FjY2FkZVdhaXRSYW5nZXMuZGVmYXVsdCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBtYWNyb1NhY2NhZGUgb2JqZWN0IHdpdGggbmV3IHJhbmRvbWl6ZWQgdmFsdWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCBvd25zIHRoZSBzYWNjYWRlIG1vdGlvbi5cbiAgICovXG4gIF9zZXRNYWNyb1NhY2NhZGUobGF5ZXJOYW1lKSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV07XG4gICAgY29uc3Qge21hY3JvU2FjY2FkZX0gPSBsYXllcjtcbiAgICBsZXQgbWFjcm9TYWNjYWRlV2FpdFJhbmdlO1xuXG4gICAgLy8gSW5jcmVhc2UgcmFuZG9tIHZhbHVlIHJhbmdlIHdoZW4gbm90IGZvY3VzZWQgb24gYSB0YXJnZXRcbiAgICBpZiAoIXRoaXMuX3RhcmdldCkge1xuICAgICAgbWFjcm9TYWNjYWRlV2FpdFJhbmdlID0gTWFjcm9TYWNjYWRlV2FpdFJhbmdlcy5kZWZhdWx0O1xuXG4gICAgICAvLyBOb3JtYWwgaHVtYW4gaG9yaXpvbnRhbCBleWUgcm90YXRpb24gbGltaXQgaXMgYWJvdXQgMzUgZGVncmVlc1xuICAgICAgY29uc3QgaExpbWl0ID0gVXRpbHMuZ2V0UmFuZG9tRmxvYXQoMC4xNDMsIDAuMjg2KTtcbiAgICAgIGNvbnN0IGhGYWN0b3IgPSBVdGlscy5nZXRSYW5kb21GbG9hdCgtaExpbWl0LCBoTGltaXQpO1xuICAgICAgbWFjcm9TYWNjYWRlLmggPSBoRmFjdG9yICogMzU7XG5cbiAgICAgIC8vIE5vcm1hbCBodW1hbiB2ZXJ0aWNhbCBleWUgcm90YXRpb24gbGltaXQgaXMgYWJvdXQgMjUgZGVncmVlcyB1cHdhcmQgYW5kIDMwIGRlZ3JlZXMgZG93bndhcmRcbiAgICAgIGNvbnN0IHZMaW1pdCA9IFV0aWxzLmdldFJhbmRvbUZsb2F0KDAuMDkzLCAwLjE4Nik7XG4gICAgICBjb25zdCB2RmFjdG9yID0gVXRpbHMuZ2V0UmFuZG9tRmxvYXQoLXZMaW1pdCwgdkxpbWl0KTtcbiAgICAgIG1hY3JvU2FjY2FkZS52ID0gdkZhY3RvciA+IDAgPyB2RmFjdG9yICogMjUgOiB2RmFjdG9yICogMzA7XG4gICAgfVxuXG4gICAgLy8gUGljayBhIG5ldyBmYWNlIHRhcmdldFxuICAgIGVsc2Uge1xuICAgICAgLy8gU29jaWFsIHRyaWFuZ2xlIC0gc2FjY2FkZSBiZXR3ZWVuIGV5ZXMgYW5kIG1vdXRoLCB3ZWlnaHRlZCB0byBsb29rIGF0IGV5ZXMgbW9yZSBvZnRlblxuICAgICAgc3dpdGNoIChsYXllci5zYWNjYWRlVGFyZ2V0KSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBtYWNyb1NhY2NhZGVXYWl0UmFuZ2UgPSBNYWNyb1NhY2NhZGVXYWl0UmFuZ2VzLmV5ZVRhcmdldDtcbiAgICAgICAgICBsYXllci5zYWNjYWRlVGFyZ2V0ID1cbiAgICAgICAgICAgIE1hdGgucmFuZG9tKCkgPCAwLjc1XG4gICAgICAgICAgICAgID8gRmFjZVRhcmdldFR5cGVzLkV5ZVJpZ2h0XG4gICAgICAgICAgICAgIDogRmFjZVRhcmdldFR5cGVzLk1vdXRoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgbWFjcm9TYWNjYWRlV2FpdFJhbmdlID0gTWFjcm9TYWNjYWRlV2FpdFJhbmdlcy5leWVUYXJnZXQ7XG4gICAgICAgICAgbGF5ZXIuc2FjY2FkZVRhcmdldCA9XG4gICAgICAgICAgICBNYXRoLnJhbmRvbSgpIDwgMC43NVxuICAgICAgICAgICAgICA/IEZhY2VUYXJnZXRUeXBlcy5FeWVMZWZ0XG4gICAgICAgICAgICAgIDogRmFjZVRhcmdldFR5cGVzLk1vdXRoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgbWFjcm9TYWNjYWRlV2FpdFJhbmdlID0gTWFjcm9TYWNjYWRlV2FpdFJhbmdlcy5tb3V0aFRhcmdldDtcbiAgICAgICAgICBsYXllci5zYWNjYWRlVGFyZ2V0ID1cbiAgICAgICAgICAgIE1hdGgucmFuZG9tKCkgPCAwLjVcbiAgICAgICAgICAgICAgPyBGYWNlVGFyZ2V0VHlwZXMuRXllTGVmdFxuICAgICAgICAgICAgICA6IEZhY2VUYXJnZXRUeXBlcy5FeWVSaWdodDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIG1hY3JvU2FjY2FkZVdhaXRSYW5nZSA9IE1hY3JvU2FjY2FkZVdhaXRSYW5nZXMuZXllVGFyZ2V0O1xuICAgICAgICAgIGxheWVyLnNhY2NhZGVUYXJnZXQgPVxuICAgICAgICAgICAgTWF0aC5yYW5kb20oKSA8IDAuNVxuICAgICAgICAgICAgICA/IEZhY2VUYXJnZXRUeXBlcy5FeWVMZWZ0XG4gICAgICAgICAgICAgIDogRmFjZVRhcmdldFR5cGVzLkV5ZVJpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7aCwgdn0gPSB0aGlzLl9nZXRGYWNlVGFyZ2V0QW5nbGVzKGxheWVyLnNhY2NhZGVUYXJnZXQpO1xuICAgICAgbWFjcm9TYWNjYWRlLmggPSBoO1xuICAgICAgbWFjcm9TYWNjYWRlLnYgPSB2O1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZUxheWVyU3BlZWQobGF5ZXJOYW1lLCBtYWNyb1NhY2NhZGUuaCwgbWFjcm9TYWNjYWRlLnYpO1xuXG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXJzXG4gICAgdGhpcy5faW5pdGlhbGl6ZU1pY3JvVGltZXIobGF5ZXJOYW1lLCAuLi5NaWNyb1NhY2NhZGVXYWl0UmFuZ2VzLnBvc3RNYWNybyk7XG4gICAgdGhpcy5faW5pdGlhbGl6ZU1hY3JvVGltZXIobGF5ZXJOYW1lLCAuLi5tYWNyb1NhY2NhZGVXYWl0UmFuZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGEgbmV3IHdhaXQgdGltZXIgdGhhdCB3aWxsIHNldCBhIG5ldyBtaWNybyBzYWNjYWRlIG1vdmVtZW50IHdoZW4gaXRcbiAgICogcmVzb2x2ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0aGF0IG93bnMgdGhlIHNhY2NhZGUgbW90aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluV2FpdFRpbWUgLSBNaW5pbXVtIG51bWJlciBvZiBzZWNvbmRzIGJlZm9yZSBhIG5ldyBzYWNjYWRlXG4gICAqIHdpbGwgYmUgdHJpZ2dlcmVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4V2FpdFRpbWUgLSBNYXhpbXVtIG51bWJlciBvZiBzZWNvbmRzIGJlZm9yZSBhIG5ldyBzYWNjYWRlXG4gICAqIHdpbGwgYmUgdHJpZ2dlcmVkLlxuICAgKi9cbiAgX2luaXRpYWxpemVNaWNyb1RpbWVyKGxheWVyTmFtZSwgbWluV2FpdFRpbWUsIG1heFdhaXRUaW1lKSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV07XG4gICAgY29uc3Qgd2FpdFRpbWUgPSBVdGlscy5nZXRSYW5kb21GbG9hdChtaW5XYWl0VGltZSwgbWF4V2FpdFRpbWUpO1xuXG4gICAgaWYgKGxheWVyLm1pY3JvU2FjY2FkZVRpbWVyKSB7XG4gICAgICBsYXllci5taWNyb1NhY2NhZGVUaW1lci5jYW5jZWwoKTtcbiAgICB9XG4gICAgbGF5ZXIubWljcm9TYWNjYWRlVGltZXIgPSBVdGlscy53YWl0KHdhaXRUaW1lLCB7XG4gICAgICBvbkZpbmlzaDogKCkgPT4ge1xuICAgICAgICB0aGlzLl9zZXRNaWNyb1NhY2NhZGUobGF5ZXJOYW1lKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgYSBuZXcgd2FpdCB0aW1lciB0aGF0IHdpbGwgc2V0IGEgbmV3IG1hY3JvIHNhY2NhZGUgbW92ZW1lbnQgd2hlbiBpdFxuICAgKiByZXNvbHZlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRoYXQgb3ducyB0aGUgc2FjY2FkZSBtb3Rpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5XYWl0VGltZSAtIE1pbmltdW0gbnVtYmVyIG9mIHNlY29uZHMgYmVmb3JlIGEgbmV3IHNhY2NhZGVcbiAgICogd2lsbCBiZSB0cmlnZ2VyZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhXYWl0VGltZSAtIE1heGltdW0gbnVtYmVyIG9mIHNlY29uZHMgYmVmb3JlIGEgbmV3IHNhY2NhZGVcbiAgICogd2lsbCBiZSB0cmlnZ2VyZWQuXG4gICAqL1xuICBfaW5pdGlhbGl6ZU1hY3JvVGltZXIobGF5ZXJOYW1lLCBtaW5XYWl0VGltZSwgbWF4V2FpdFRpbWUpIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXTtcbiAgICBjb25zdCB3YWl0VGltZSA9IFV0aWxzLmdldFJhbmRvbUZsb2F0KG1pbldhaXRUaW1lLCBtYXhXYWl0VGltZSk7XG5cbiAgICBpZiAobGF5ZXIubWFjcm9TYWNjYWRlVGltZXIpIHtcbiAgICAgIGxheWVyLm1hY3JvU2FjY2FkZVRpbWVyLmNhbmNlbCgpO1xuICAgIH1cbiAgICBsYXllci5tYWNyb1NhY2NhZGVUaW1lciA9IFV0aWxzLndhaXQod2FpdFRpbWUsIHtcbiAgICAgIG9uRmluaXNoOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3NldE1hY3JvU2FjY2FkZShsYXllck5hbWUpO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgbmV3IHRhcmdldCB0byBsb29rIGF0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdHxudWxsfSB0YXJnZXQgLSBUaGUgbmV3IHRhcmdldCB0byBsb29rIGF0LlxuICAgKi9cbiAgc2V0VGFyZ2V0KHRhcmdldCkge1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIGFuIG9iamVjdCBnaXZlbiBpdHMgbmFtZSBhbmQgc2V0cyBpdCBhcyB0aGUgbmV3IHRhcmdldCB0byBsb29rIGF0LlxuICAgKiBTaG91bGQgYmUgb3ZlcmxvYWRlZCBmb3IgZWFjaCByZW5kZXJpbmcgZW5naW5lIGltcGxlbWVudGF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0IC0gTmFtZSB0byBzZWFyY2ggZm9yLlxuICAgKi9cbiAgc2V0VGFyZ2V0QnlOYW1lKG5hbWUpIHtcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHRoaXMuX3RhcmdldCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9zY2VuZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IHNldCBQb2ludE9mSW50ZXJlc3RGZWF0dXJlIHRhcmdldCB1c2luZyBuYW1lICR7bmFtZX0gb24gaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBTY2VuZSBtdXN0IGJlIGRlZmluZWQuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgYW4gb2JqZWN0IGdpdmVuIGl0cyBpZCBhbmQgc2V0cyBpdCBhcyB0aGUgbmV3IHRhcmdldCB0byBsb29rIGF0LlxuICAgKiBTaG91bGQgYmUgb3ZlcmxvYWRlZCBmb3IgZWFjaCByZW5kZXJpbmcgZW5naW5lIGltcGxlbWVudGF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHRhcmdldCAtIElkIHRvIHNlYXJjaCBmb3IuXG4gICAqL1xuICBzZXRUYXJnZXRCeUlkKGlkKSB7XG4gICAgaWYgKCFpZCkge1xuICAgICAgdGhpcy5fdGFyZ2V0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3NjZW5lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3Qgc2V0IFBvaW50T2ZJbnRlcmVzdEZlYXR1cmUgdGFyZ2V0IHVzaW5nIGlkICR7aWR9IG9uIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gU2NlbmUgbXVzdCBiZSBkZWZpbmVkLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGtlZXBpbmcgdHJhY2sgb2YgYW4gYW5pbWF0aW9uIGxheWVyIHRoYXQgb3ducyBhIGJsZW5kMmQgYW5pbWF0aW9uIHdpdGhcbiAgICogYmxlbmRXZWlnaHRzIGNvcnJlc3BvbmRpbmcgdG8gaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgbG9vayBhbmdsZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0byBrZWVwIHRyYWNrIG9mLlxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgbGF5ZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb24gPSAnbG9vayddIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uIG9uIHRoZVxuICAgKiBsYXllciB3aG9zZSBibGVuZFdlaWdodHMgd2lsbCBiZSBkcml2ZW4gYmFzZWQgb24gdGhlIGFuZ2xlIGJldHdlZW4gdGhlIGxvb2tUcmFja2VyXG4gICAqIGFuZCB0aGUgbG9va1RhcmdldC4gVGhpcyBhbmltYXRpb24gbXVzdCBiZSBvZiB0eXBlIGJsZW5kMmQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhTcGVlZCA9IDI1XSAtIFRoZSBtYXhpbXVtIHNwZWVkIGF0IHdoaWNoIHRoZSBibGVuZDJkXG4gICAqIGJsZW5kV2VpZ2h0cyBjYW4gYmUgbWFuaXB1bGF0ZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5mb3J3YXJkQXhpcyA9ICdQb3NpdGl2ZVonXSAtIEF4aXMgcG9pbnRpbmcgZnJvbSB0aGVcbiAgICogZnJvbnQgb2YgdGhlIGxvb2tSZWZlcmVuY2Ugb2JqZWN0LiBWYWxpZCBvcHRpb25zIGFyZSAnUG9zaXRpdmVYJywgJ05lZ2F0aXZlWCcsXG4gICAqICdQb3NpdGl2ZVknLCAnTmVnYXRpdmVZJywgJ1Bvc2l0aXZlWicsICdOZWdhdGl2ZVonLlxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMubG9va1JlZmVyZW5jZSAtIDNEIHRyYW5zZm9ybWF0aW9uIG5vZGUgdGhhdCB0aGUgbG9va1RyYWNrZXJcbiAgICogcm90YXRpb24gbGltaXRzIHNob3VsZCBiZSBjYWxjdWxhdGVkIHJlbGF0aXZlIHRvLiBEZWZhdWx0cyB0byB0aGUgaG9zdCBvd25lci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmhhc1NhY2NhZGUgPSBmYWxzZV0gLSBXaGV0aGVyIG9yIG5vdCB0byBpbmNsdWRlXG4gICAqIHNhY2NhZGljIG1vdGlvbiBvbnRvIHRoZSBibGVuZFdlaWdodCBhbmltYXRpb24uIFRoaXMgc2hvdWxkIG9ubHkgYmUgc2V0IHRvXG4gICAqIHRydWUgZm9yIGJsZW5kMmQgYW5pbWF0aW9ucyByZXByZXNlbnRpbmcgZXllIGFuaW1hdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXI9fSBbb3B0aW9ucy5ibGVuZFRpbWU9W1BvaW50T2ZJbnRlcmVzdEZlYXR1cmUuREVGQVVMVF9MQVlFUl9PUFRJT05TLmJsZW5kVGltZV17QGxpbmsgUG9pbnRPZkludGVyZXN0RmVhdHVyZSNERUZBVUxUX0xBWUVSX09QVElPTlMjYmxlbmRUaW1lfV0gLVxuICAgKiBEZWZhdWx0IGFtb3VudCBvZiB0aW1lIHRvIHVzZSB3aGVuIG1hbmlwdWxhdGluZyBsYXllciB3ZWlnaHQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvcHRpb25zLmVhc2luZ0ZuIC0gRGVmYXVsdCBlYXNpbmcgZnVuY3Rpb24gdG8gdXNlIHdoZW5cbiAgICogbWFuaXB1bGF0aW5nIGxheWVyIHdlaWdodC5cbiAgICovXG4gIHJlZ2lzdGVyTG9va0xheWVyKFxuICAgIGxheWVyTmFtZSxcbiAgICB7XG4gICAgICBhbmltYXRpb24gPSAnbG9vaycsXG4gICAgICBtYXhTcGVlZCA9IDI1LFxuICAgICAgcmVmZXJlbmNlLFxuICAgICAgZm9yd2FyZEF4aXMgPSAnUG9zaXRpdmVaJyxcbiAgICAgIGhhc1NhY2NhZGUgPSBmYWxzZSxcbiAgICAgIGJsZW5kVGltZSA9IFBvaW50T2ZJbnRlcmVzdEZlYXR1cmUuREVGQVVMVF9MQVlFUl9PUFRJT05TLmJsZW5kVGltZSxcbiAgICAgIGVhc2luZ0ZuLFxuICAgIH0gPSB7fVxuICApIHtcbiAgICAvLyBWYWxpZGF0ZSByZWZlcmVuY2Ugb2JqZWN0XG4gICAgcmVmZXJlbmNlID0gcmVmZXJlbmNlIHx8IHRoaXMuX2hvc3Qub3duZXI7XG5cbiAgICBpZiAoIXRoaXMuY29uc3RydWN0b3IuX3ZhbGlkYXRlVHJhbnNmb3JtT2JqZWN0KHJlZmVyZW5jZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBpbml0aWFsaXplIHJlZ2lzdGVyIGxvb2sgbGF5ZXIgJHtsYXllck5hbWV9IGZvciBQb2ludE9mSW50ZXJlc3RGZWF0dXJlIG9uIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gUmVmZXJlbmNlIG11c3QgYmUgZGVmaW5lZCBhcyBhIHZhbGlkIHRyYW5zZm9ybWF0aW9uIG9iamVjdC5gXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEZpbmQgdmVjdG9yIGFzc29jaWF0ZWQgd2l0aCBheGlzIHN0cmluZ1xuICAgIGZvcndhcmRBeGlzID1cbiAgICAgIEF4aXNNYXBbZm9yd2FyZEF4aXNdICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBBeGlzTWFwW2ZvcndhcmRBeGlzXVxuICAgICAgICA6IEF4aXNNYXAuUG9zaXRpdmVaO1xuXG4gICAgLy8gU3RvcmUgdHJhY2tpbmcgY29uZmlndXJhdGlvblxuICAgIGNvbnN0IHRyYWNraW5nQ29uZmlnID0gdGhpcy5fYWRkVHJhY2tpbmdDb25maWcoe1xuICAgICAgcmVmZXJlbmNlLFxuICAgICAgZm9yd2FyZEF4aXMsXG4gICAgfSk7XG5cbiAgICAvLyBSZWdpc3RlciB0aGUgbGF5ZXIgYW5kIGFuaW1hdGlvblxuICAgIHRoaXMucmVnaXN0ZXJMYXllcihsYXllck5hbWUsIHtcbiAgICAgIHRyYWNraW5nQ29uZmlnLFxuICAgICAgbWF4U3BlZWQsXG4gICAgICBtYXhIU3BlZWQ6IHVuZGVmaW5lZCxcbiAgICAgIG1heFZTcGVlZDogdW5kZWZpbmVkLFxuICAgICAgaER1cmF0aW9uOiB1bmRlZmluZWQsXG4gICAgICB2RHVyYXRpb246IHVuZGVmaW5lZCxcbiAgICAgIGhWZWxvY2l0eTogWzAsIDBdLFxuICAgICAgdlZlbG9jaXR5OiBbMCwgMF0sXG4gICAgICBoYXNTYWNjYWRlLFxuICAgICAgYmxlbmRUaW1lLFxuICAgICAgZWFzaW5nRm4sXG4gICAgICBtaWNyb1NhY2NhZGU6IHtoOiAwLCB2OiAwfSxcbiAgICAgIG1hY3JvU2FjY2FkZToge2g6IDAsIHY6IDB9LFxuICAgICAgc2FjY2FkZVRhcmdldDogRmFjZVRhcmdldFR5cGVzLkV5ZUNlbnRlcixcbiAgICAgIGFuaW1hdGlvbnM6IHtbYW5pbWF0aW9uXToge319LFxuICAgIH0pO1xuICAgIHRoaXMuX2xvb2tMYXllcnNbbGF5ZXJOYW1lXSA9IGFuaW1hdGlvbjtcblxuICAgIC8vIFZhbGlkYXRlIHRoZSBsb29rIGFuaW1hdGlvblxuICAgIHRoaXMuX3JlZ2lzdGVyTG9va0FuaW1hdGlvbihsYXllck5hbWUsIGFuaW1hdGlvbik7XG5cbiAgICAvLyBJbml0aWFsaXplIHNhY2NhZGUgdGltZXJzXG4gICAgaWYgKGhhc1NhY2NhZGUpIHtcbiAgICAgIGNvbnN0IG1hY3JvU2FjY2FkZVdhaXRSYW5nZSA9IHRoaXMuX3RhcmdldFxuICAgICAgICA/IE1hY3JvU2FjY2FkZVdhaXRSYW5nZXMuZXllVGFyZ2V0XG4gICAgICAgIDogTWFjcm9TYWNjYWRlV2FpdFJhbmdlcy5kZWZhdWx0O1xuICAgICAgdGhpcy5faW5pdGlhbGl6ZU1pY3JvVGltZXIobGF5ZXJOYW1lLCAuLi5NaWNyb1NhY2NhZGVXYWl0UmFuZ2VzLmRlZmF1bHQpO1xuICAgICAgdGhpcy5faW5pdGlhbGl6ZU1hY3JvVGltZXIobGF5ZXJOYW1lLCAuLi5tYWNyb1NhY2NhZGVXYWl0UmFuZ2UpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBrZWVwaW5nIHRyYWNrIG9mIGFuIGFuaW1hdGlvbiBsYXllciB0aGF0IG93bnMgYSBibGluayBhbmltYXRpb24uIEJsaW5rXG4gICAqIGFuaW1hdGlvbnMgY2FuIGJlIG9mIGFueSB0eXBlLCBidXQgaWYgaXQgaXMgb2YgdHlwZSByYW5kb21BbmltYXRpb24gdGhlbiBhXG4gICAqIGl0IHdpbGwgYmUgcmFuZG9taXplZCBlYWNoIHRpbWUgYSBibGluayBpcyBjYWxsZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0byBrZWVwIHRyYWNrIG9mLlxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgbGF5ZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb24gPSAnYmxpbmsnXSAtIE5hbWUgb2YgdGhlIGJsaW5rIGFuaW1hdGlvblxuICAgKiBvbiB0aGUgbGF5ZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5ibGVuZFRpbWU9W1BvaW50T2ZJbnRlcmVzdEZlYXR1cmUuREVGQVVMVF9MQVlFUl9PUFRJT05TLmJsZW5kVGltZV17QGxpbmsgUG9pbnRPZkludGVyZXN0RmVhdHVyZSNERUZBVUxUX0xBWUVSX09QVElPTlMjYmxlbmRUaW1lfV0gLVxuICAgKiBEZWZhdWx0IGFtb3VudCBvZiB0aW1lIHRvIHVzZSB3aGVuIG1hbmlwdWxhdGluZyB0aGUgbGF5ZXIncyB3ZWlnaHQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvcHRpb25zLmVhc2luZ0ZuIC0gRGVmYXVsdCBlYXNpbmcgZnVuY3Rpb24gdG8gdXNlIHdoZW5cbiAgICogbWFuaXB1bGF0aW5nIHRoZSBsYXllcidzIHdlaWdodC5cbiAgICovXG4gIHJlZ2lzdGVyQmxpbmtMYXllcihcbiAgICBsYXllck5hbWUsXG4gICAge1xuICAgICAgYW5pbWF0aW9uID0gJ2JsaW5rJyxcbiAgICAgIGJsZW5kVGltZSA9IFBvaW50T2ZJbnRlcmVzdEZlYXR1cmUuREVGQVVMVF9MQVlFUl9PUFRJT05TLmJsZW5kVGltZSxcbiAgICAgIGVhc2luZ0ZuLFxuICAgIH0gPSB7fVxuICApIHtcbiAgICAvLyBSZWdpc3RlciB0aGUgbGF5ZXIgYW5kIGFuaW1hdGlvblxuICAgIHRoaXMucmVnaXN0ZXJMYXllcihsYXllck5hbWUsIHtcbiAgICAgIGJsZW5kVGltZSxcbiAgICAgIGVhc2luZ0ZuLFxuICAgICAgYW5pbWF0aW9uczoge1thbmltYXRpb25dOiB7fX0sXG4gICAgfSk7XG4gICAgdGhpcy5fYmxpbmtMYXllcnNbbGF5ZXJOYW1lXSA9IGFuaW1hdGlvbjtcbiAgfVxuXG4gIHVwZGF0ZShkZWx0YVRpbWUpIHtcbiAgICBzdXBlci51cGRhdGUoZGVsdGFUaW1lKTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgbG9vayBhbmdsZXNcbiAgICBpZiAodGhpcy5fdGFyZ2V0KSB7XG4gICAgICB0aGlzLl9zZXRMb29rQW5nbGVzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jlc2V0TG9va0FuZ2xlcygpO1xuICAgIH1cblxuICAgIGNvbnN0IGRlbHRhU2Vjb25kcyA9IE1hdGgubWluKGRlbHRhVGltZSwgTWF4RGVsdGEpIC8gMTAwMDtcbiAgICBsZXQgdHJpZ2dlckJsaW5rID0gZmFsc2U7XG5cbiAgICAvLyBTZXQgbG9vayBibGVuZCB2YWx1ZXNcbiAgICBPYmplY3QuZW50cmllcyh0aGlzLl9sb29rTGF5ZXJzKS5mb3JFYWNoKChbbGF5ZXJOYW1lLCBhbmltTmFtZV0pID0+IHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV07XG5cbiAgICAgIC8vIEluY3JlbWVudCB0aGUgc2FjY2FkZSB0aW1lcnNcbiAgICAgIGlmIChvcHRpb25zLmlzQWN0aXZlICYmIG9wdGlvbnMuaGFzU2FjY2FkZSkge1xuICAgICAgICBvcHRpb25zLm1pY3JvU2FjY2FkZVRpbWVyLmV4ZWN1dGUoZGVsdGFUaW1lKTtcbiAgICAgICAgb3B0aW9ucy5tYWNyb1NhY2NhZGVUaW1lci5leGVjdXRlKGRlbHRhVGltZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB0aGUgYmxlbmQgdmFsdWVzXG4gICAgICBpZiAob3B0aW9ucy5hbmltYXRpb25zW2FuaW1OYW1lXS5pc0FjdGl2ZSkge1xuICAgICAgICBjb25zdCBjdXJyZW50SCA9IHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5nZXRBbmltYXRpb25CbGVuZFdlaWdodChcbiAgICAgICAgICBsYXllck5hbWUsXG4gICAgICAgICAgYW5pbU5hbWUsXG4gICAgICAgICAgJ1gnXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRWID0gdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlLmdldEFuaW1hdGlvbkJsZW5kV2VpZ2h0KFxuICAgICAgICAgIGxheWVyTmFtZSxcbiAgICAgICAgICBhbmltTmFtZSxcbiAgICAgICAgICAnWSdcbiAgICAgICAgKTtcblxuICAgICAgICBsZXQgdGFyZ2V0SCA9IG9wdGlvbnMudHJhY2tpbmdDb25maWcuYW5nbGVzLmg7XG4gICAgICAgIGxldCB0YXJnZXRWID0gb3B0aW9ucy50cmFja2luZ0NvbmZpZy5hbmdsZXMudjtcblxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgbG9vayBhbmdsZSBoYXMgY2hhbmdlZCBlbm91Z2ggdG8gdHJpZ2dlciBhIGJsaW5rXG4gICAgICAgIGlmICh0aGlzLl9pc1RhcmdldE1vdmluZyAmJiAhdHJpZ2dlckJsaW5rKSB7XG4gICAgICAgICAgY29uc3QgcHJldlRhcmdldEggPSBvcHRpb25zLnRyYWNraW5nQ29uZmlnLnByZXZBbmdsZXMuaDtcbiAgICAgICAgICBjb25zdCBwcmV2VGFyZ2V0ViA9IG9wdGlvbnMudHJhY2tpbmdDb25maWcucHJldkFuZ2xlcy52O1xuICAgICAgICAgIGNvbnN0IGNoYW5nZUFtb3VudCA9IE1hdGhVdGlscy50b0RlZ3JlZXMoXG4gICAgICAgICAgICBNYXRoVXRpbHMuZ2V0QW5nbGVCZXR3ZWVuKFxuICAgICAgICAgICAgICBbcHJldlRhcmdldEgsIHByZXZUYXJnZXRWXSxcbiAgICAgICAgICAgICAgW3RhcmdldEgsIHRhcmdldFZdXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmIChjaGFuZ2VBbW91bnQgPj0gQmxpbmtUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgIHRyaWdnZXJCbGluayA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucy50cmFja2luZ0NvbmZpZy5wcmV2QW5nbGVzLmggPSB0YXJnZXRIO1xuICAgICAgICBvcHRpb25zLnRyYWNraW5nQ29uZmlnLnByZXZBbmdsZXMudiA9IHRhcmdldFY7XG5cbiAgICAgICAgLy8gQWRkIGluIHRoZSBzYWNjYWRlIG1vdmVtZW50XG4gICAgICAgIGlmIChvcHRpb25zLmhhc1NhY2NhZGUpIHtcbiAgICAgICAgICBNYXRoVXRpbHMuZGFtcFZhbHVlKFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIG9wdGlvbnMubWFjcm9TYWNjYWRlLmggKyBvcHRpb25zLm1hY3JvU2FjY2FkZS5oLFxuICAgICAgICAgICAgb3B0aW9ucy5oVmVsb2NpdHksXG4gICAgICAgICAgICBvcHRpb25zLmhEdXJhdGlvbixcbiAgICAgICAgICAgIG9wdGlvbnMubWF4SFNwZWVkXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0YXJnZXRIICs9IG9wdGlvbnMuaFZlbG9jaXR5WzBdO1xuICAgICAgICAgIE1hdGhVdGlscy5kYW1wVmFsdWUoXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgb3B0aW9ucy5tYWNyb1NhY2NhZGUudiArIG9wdGlvbnMubWFjcm9TYWNjYWRlLnYsXG4gICAgICAgICAgICBvcHRpb25zLnZWZWxvY2l0eSxcbiAgICAgICAgICAgIG9wdGlvbnMudkR1cmF0aW9uLFxuICAgICAgICAgICAgb3B0aW9ucy5tYXhWU3BlZWRcbiAgICAgICAgICApO1xuICAgICAgICAgIHRhcmdldFYgKz0gb3B0aW9ucy52VmVsb2NpdHlbMF07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDbGFtcCB0byBtYXggc3BlZWRcbiAgICAgICAgY29uc3QgZmFjdG9yID0gTWF0aFV0aWxzLmNsYW1wKGRlbHRhU2Vjb25kcyAqIG9wdGlvbnMubWF4U3BlZWQsIDAsIDEpO1xuICAgICAgICB0YXJnZXRIID0gTWF0aFV0aWxzLmxlcnAoY3VycmVudEgsIHRhcmdldEgsIGZhY3Rvcik7XG4gICAgICAgIHRhcmdldFYgPSBNYXRoVXRpbHMubGVycChjdXJyZW50ViwgdGFyZ2V0ViwgZmFjdG9yKTtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIGJsZW5kIHZhbHVlc1xuICAgICAgICB0aGlzLl9ob3N0LkFuaW1hdGlvbkZlYXR1cmUuc2V0QW5pbWF0aW9uQmxlbmRXZWlnaHQoXG4gICAgICAgICAgbGF5ZXJOYW1lLFxuICAgICAgICAgIGFuaW1OYW1lLFxuICAgICAgICAgICdYJyxcbiAgICAgICAgICB0YXJnZXRIXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5zZXRBbmltYXRpb25CbGVuZFdlaWdodChcbiAgICAgICAgICBsYXllck5hbWUsXG4gICAgICAgICAgYW5pbU5hbWUsXG4gICAgICAgICAgJ1knLFxuICAgICAgICAgIHRhcmdldFZcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghdHJpZ2dlckJsaW5rIHx8ICF0aGlzLl9pc1RhcmdldE1vdmluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEV4ZWN1dGUgYmxpbmtcbiAgICBPYmplY3QuZW50cmllcyh0aGlzLl9ibGlua0xheWVycykuZm9yRWFjaCgoW2xheWVyTmFtZSwgYW5pbU5hbWVdKSA9PiB7XG4gICAgICBjb25zdCBhbmltYXRpb24gPSB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0uYW5pbWF0aW9uc1thbmltTmFtZV07XG5cbiAgICAgIGlmIChhbmltYXRpb24uaXNBY3RpdmUpIHtcbiAgICAgICAgdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlLnBsYXlBbmltYXRpb24obGF5ZXJOYW1lLCBhbmltTmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpbnN0YWxsQXBpKCkge1xuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqIEBuYW1lc3BhY2UgUG9pbnRPZkludGVyZXN0RmVhdHVyZVxuICAgICAqL1xuICAgIGNvbnN0IGFwaSA9IHN1cGVyLmluc3RhbGxBcGkoKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGFwaSwge1xuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgUG9pbnRPZkludGVyZXN0RmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAc2VlIGNvcmUvUG9pbnRPZkludGVyZXN0RmVhdHVyZSN0YXJnZXRcbiAgICAgICAqL1xuICAgICAgdGFyZ2V0OiB7XG4gICAgICAgIGdldDogKCkgPT4gdGhpcy50YXJnZXQsXG4gICAgICAgIHNldDogdGFyZ2V0ID0+IHtcbiAgICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBPYmplY3QuYXNzaWduKGFwaSwge1xuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgUG9pbnRPZkludGVyZXN0RmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAc2VlIGNvcmUvUG9pbnRPZkludGVyZXN0RmVhdHVyZSNyZWdpc3Rlckxvb2tMYXllclxuICAgICAgICovXG4gICAgICByZWdpc3Rlckxvb2tMYXllcjogdGhpcy5yZWdpc3Rlckxvb2tMYXllci5iaW5kKHRoaXMpLFxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgUG9pbnRPZkludGVyZXN0RmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAc2VlIGNvcmUvUG9pbnRPZkludGVyZXN0RmVhdHVyZSNyZWdpc3RlckJsaW5rTGF5ZXJcbiAgICAgICAqL1xuICAgICAgcmVnaXN0ZXJCbGlua0xheWVyOiB0aGlzLnJlZ2lzdGVyQmxpbmtMYXllci5iaW5kKHRoaXMpLFxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgUG9pbnRPZkludGVyZXN0RmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAc2VlIGNvcmUvUG9pbnRPZkludGVyZXN0RmVhdHVyZSNzZXRUYXJnZXRcbiAgICAgICAqL1xuICAgICAgc2V0VGFyZ2V0OiB0aGlzLnNldFRhcmdldC5iaW5kKHRoaXMpLFxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgUG9pbnRPZkludGVyZXN0RmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAc2VlIGNvcmUvUG9pbnRPZkludGVyZXN0RmVhdHVyZSNzZXRUYXJnZXRCeU5hbWVcbiAgICAgICAqL1xuICAgICAgc2V0VGFyZ2V0QnlOYW1lOiB0aGlzLnNldFRhcmdldEJ5TmFtZS5iaW5kKHRoaXMpLFxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgUG9pbnRPZkludGVyZXN0RmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAc2VlIGNvcmUvUG9pbnRPZkludGVyZXN0RmVhdHVyZSNzZXRUYXJnZXRCeUlkXG4gICAgICAgKi9cbiAgICAgIHNldFRhcmdldEJ5SWQ6IHRoaXMuc2V0VGFyZ2V0QnlJZC5iaW5kKHRoaXMpLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGFwaTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQb2ludE9mSW50ZXJlc3RGZWF0dXJlO1xuZXhwb3J0IHtBeGlzTWFwfTtcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXG5cbi8qKlxuICogQG1vZHVsZSBjb3JlL2FuaW1wYWNrXG4gKi9cblxuaW1wb3J0IHtcbiAgTGluZWFyLFxuICBRdWFkcmF0aWMsXG4gIEN1YmljLFxuICBRdWFydGljLFxuICBRdWludGljLFxuICBTaW51c29pZGFsLFxuICBFeHBvbmVudGlhbCxcbiAgQ2lyY3VsYXIsXG4gIEVsYXN0aWMsXG4gIEJhY2ssXG4gIEJvdW5jZSxcbn0gZnJvbSAnLi9FYXNpbmcnO1xuaW1wb3J0IEFuaW1hdGlvbkZlYXR1cmUsIHtBbmltYXRpb25UeXBlc30gZnJvbSAnLi9BbmltYXRpb25GZWF0dXJlJztcbmltcG9ydCBBbmltYXRpb25MYXllciwge1xuICBMYXllckJsZW5kTW9kZXMsXG4gIERlZmF1bHRMYXllckJsZW5kTW9kZSxcbn0gZnJvbSAnLi9BbmltYXRpb25MYXllcic7XG5pbXBvcnQgU2luZ2xlU3RhdGUgZnJvbSAnLi9zdGF0ZS9TaW5nbGVTdGF0ZSc7XG5pbXBvcnQgVHJhbnNpdGlvblN0YXRlIGZyb20gJy4vc3RhdGUvVHJhbnNpdGlvblN0YXRlJztcbmltcG9ydCBGcmVlQmxlbmRTdGF0ZSBmcm9tICcuL3N0YXRlL0ZyZWVCbGVuZFN0YXRlJztcbmltcG9ydCBRdWV1ZVN0YXRlIGZyb20gJy4vc3RhdGUvUXVldWVTdGF0ZSc7XG5pbXBvcnQgUmFuZG9tQW5pbWF0aW9uU3RhdGUgZnJvbSAnLi9zdGF0ZS9SYW5kb21BbmltYXRpb25TdGF0ZSc7XG5pbXBvcnQgQmxlbmQxZFN0YXRlIGZyb20gJy4vc3RhdGUvQmxlbmQxZFN0YXRlJztcbmltcG9ydCBCbGVuZDJkU3RhdGUgZnJvbSAnLi9zdGF0ZS9CbGVuZDJkU3RhdGUnO1xuaW1wb3J0IEFuaW1hdGlvblV0aWxzIGZyb20gJy4vQW5pbWF0aW9uVXRpbHMnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2VcbiAqL1xuY29uc3QgRWFzaW5nID0ge1xuICAvKipcbiAgICogQHNlZSBMaW5lYXJcbiAgICovXG4gIExpbmVhcixcbiAgLyoqXG4gICAqIEBzZWUgUXVhZHJhdGljXG4gICAqL1xuICBRdWFkcmF0aWMsXG4gIC8qKlxuICAgKiBAc2VlIEN1YmljXG4gICAqL1xuICBDdWJpYyxcbiAgLyoqXG4gICAqIEBzZWUgUXVhcnRpY1xuICAgKi9cbiAgUXVhcnRpYyxcbiAgLyoqXG4gICAqIEBzZWUgUXVpbnRpY1xuICAgKi9cbiAgUXVpbnRpYyxcbiAgLyoqXG4gICAqIEBzZWUgU2ludXNvaWRhbFxuICAgKi9cbiAgU2ludXNvaWRhbCxcbiAgLyoqXG4gICAqIEBzZWUgRXhwb25lbnRpYWxcbiAgICovXG4gIEV4cG9uZW50aWFsLFxuICAvKipcbiAgICogQHNlZSBDaXJjdWxhclxuICAgKi9cbiAgQ2lyY3VsYXIsXG4gIC8qKlxuICAgKiBAc2VlIEVsYXN0aWNcbiAgICovXG4gIEVsYXN0aWMsXG4gIC8qKlxuICAgKiBAc2VlIEJhY2tcbiAgICovXG4gIEJhY2ssXG4gIC8qKlxuICAgKiBAc2VlIEJvdW5jZVxuICAgKi9cbiAgQm91bmNlLFxufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICAvKipcbiAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmVcbiAgICovXG4gIEFuaW1hdGlvbkZlYXR1cmUsXG4gIC8qKlxuICAgKiBAc2VlIEFuaW1hdGlvbkxheWVyXG4gICAqL1xuICBBbmltYXRpb25MYXllcixcbiAgLyoqXG4gICAqIEBzZWUgY29yZS9TaW5nbGVTdGF0ZVxuICAgKi9cbiAgU2luZ2xlU3RhdGUsXG4gIC8qKlxuICAgKiBAc2VlIFRyYW5zaXRpb25TdGF0ZVxuICAgKi9cbiAgVHJhbnNpdGlvblN0YXRlLFxuICAvKipcbiAgICogQHNlZSBGcmVlQmxlbmRTdGF0ZVxuICAgKi9cbiAgRnJlZUJsZW5kU3RhdGUsXG4gIC8qKlxuICAgKiBAc2VlIFF1ZXVlU3RhdGVcbiAgICovXG4gIFF1ZXVlU3RhdGUsXG4gIC8qKlxuICAgKiBAc2VlIFJhbmRvbUFuaW1hdGlvblN0YXRlXG4gICAqL1xuICBSYW5kb21BbmltYXRpb25TdGF0ZSxcbiAgLyoqXG4gICAqIEBzZWUgQmxlbmQxZFN0YXRlXG4gICAqL1xuICBCbGVuZDFkU3RhdGUsXG4gIC8qKlxuICAgKiBAc2VlIEJsZW5kMmRTdGF0ZVxuICAgKi9cbiAgQmxlbmQyZFN0YXRlLFxuICAvKipcbiAgICogQHNlZSBBbmltYXRpb25VdGlsc1xuICAgKi9cbiAgQW5pbWF0aW9uVXRpbHMsXG5cbiAgRWFzaW5nLFxuICAvKipcbiAgICogQHNlZSBMYXllckJsZW5kTW9kZXNcbiAgICovXG4gIExheWVyQmxlbmRNb2RlcyxcbiAgLyoqXG4gICAqIEBzZWUgRGVmYXVsdExheWVyQmxlbmRNb2RlXG4gICAqL1xuICBEZWZhdWx0TGF5ZXJCbGVuZE1vZGUsXG4gIC8qKlxuICAgKiBAc2VlIEFuaW1hdGlvblR5cGVzXG4gICAqL1xuICBBbmltYXRpb25UeXBlcyxcbn07XG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxuXG5pbXBvcnQgVXRpbHMgZnJvbSAnY29yZS9VdGlscyc7XG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIHVzZWZ1bCB0ZXh0LXRvLXNwZWVjaCBmdW5jdGlvbnMuXG4gKlxuICogQGhpZGVjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBUZXh0VG9TcGVlY2hVdGlscyB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IHN0cmluZyB3aXRoIFNTTUwgbWFya3MgaW5zZXJ0ZWQgYmFzZWQgb25cbiAgICogbWF0Y2hlcyBiZXR3ZWVuIHRoZSBpbnB1dCBzdHJpbmcgYW5kIHRoZSBpbnB1dCBtYXAuIFRoZVxuICAgKiB3b3JkIG1hdGNoZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUuIFdvcmRzIHdpdGhpbiBleGlzdGluZ1xuICAgKiBTU01MIHRhZ3Mgd2lsbCBub3QgYmUgYWZmZWN0ZWQuIElucHV0IHRleHQgd2lsbCBiZSBzdXJyb3VuZGVkXG4gICAqIGJ5IDxzcGVhaz48L3NwZWFrPiB0YWdzIGlmIG5lZWRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBJbnB1dCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBtYXAgLSBJbnB1dCBvYmplY3QgdGhhdCBtYXBzIG1hcmsga2V5c1xuICAgKiB0byBhcnJheXMgb2Ygd29yZHMuIEV4YW1wbGU6XG4gICAqXG4gICAqICB7XG4gICAqICAgICdtYXJrOnNhZCcgOiBbJ3NhZCcsICdibHVlJywgJ2Rvd24nXSxcbiAgICogICAgJ21hcms6aGFwcHknIDogWydqb3knLCAnZ2xhZCcsICdncmVhdCddLFxuICAgKiAgICAnbWFyazpubycgOiBbJ25vJywgJ25haCcsICduYXknLCAnc3VyZSddXG4gICAqICB9XG4gICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IFtyYW5kb21NYXJrcyA9IFtdXSAtIElmIHRoZXJlIGFyZSBzZW50ZW5jZXMgdGhhdCBkb24ndFxuICAgKiBtYXRjaCBhbnkgd29yZHMgZnJvbSB0aGUgbWFwIG9iamVjdCwgbWFya3MgZnJvbSB0aGlzIGFycmF5IHdpbGwgYmUgcmFuZG9tbHlcbiAgICogY2hvc2VuIGFuZCBpbnNlcnRlZC5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gLSBVcGRhdGVkIGlucHV0IHN0cmluZy5cbiAgICovXG4gIHN0YXRpYyBhdXRvR2VuZXJhdGVTU01MTWFya3ModGV4dCwgbWFwLCByYW5kb21NYXJrcyA9IFtdKSB7XG4gICAgaWYgKHR5cGVvZiBtYXAgIT09ICdvYmplY3QnIHx8IG1hcCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGdlbmVyYXRlIFNTTUwgbWFya3MgZm9yIHRleHQgXCIke3RleHR9XCIgYmVjYXVzZSBtYXAgaXMgbm90IGFuIG9iamVjdC5gXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIHByb2Nlc3MgdGhlIGlucHV0IG1hcCBpbnRvIGFuIGludGVybmFsIGZvcm1hdFxuICAgIGNvbnN0IGludGVybmFsTWFwID0gdGhpcy5fcHJvY2Vzc0lucHV0TWFwKG1hcCk7XG5cbiAgICBjb25zdCBzcGVha1RhZ3MgPSBbJzxzcGVhaz4nLCAnPC9zcGVhaz4nXTtcbiAgICBjb25zdCBzc21sTWFya1JlZ2V4ID0gLzxtYXJrIG5hbWU9KD86XCJ8JykoLio/KSg/OlwifCcpXFwvPi87XG4gICAgY29uc3Qgc3NtbFRhZ1JlZ2V4ID0gLzxbXj5dKj4vZztcblxuICAgIC8vIElkZW50aWZ5IGFueSBleGlzdGluZyBTU01MIHRhZ3NcbiAgICBjb25zdCBleGlzdGluZ1RhZ3MgPSBbXTtcbiAgICBsZXQgcmVzdWx0ID0gc3NtbFRhZ1JlZ2V4LmV4ZWModGV4dCk7XG5cbiAgICB3aGlsZSAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICBleGlzdGluZ1RhZ3MucHVzaCh7XG4gICAgICAgIHN0YXJ0OiByZXN1bHQuaW5kZXgsXG4gICAgICAgIGVuZDogcmVzdWx0LmluZGV4ICsgcmVzdWx0WzBdLmxlbmd0aCxcbiAgICAgICAgdGV4dDogcmVzdWx0WzBdLFxuICAgICAgfSk7XG5cbiAgICAgIHJlc3VsdCA9IHNzbWxUYWdSZWdleC5leGVjKHRleHQpO1xuICAgIH1cblxuICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgbGV0IHNzbWxNYXJrUmVzdWx0O1xuICAgIGxldCBkdXBsaWNhdGVNYXJrVG9DaGVjayA9IFtdO1xuICAgIGV4aXN0aW5nVGFncy5mb3JFYWNoKGV4aXN0aW5nVGFnID0+IHtcbiAgICAgIGNvbnN0IHN1YnN0ciA9IHRleHQuc2xpY2UoaW5kZXgsIGV4aXN0aW5nVGFnLnN0YXJ0KTtcblxuICAgICAgaWYgKHN1YnN0ciAhPT0gJycpIHtcbiAgICAgICAgLy8gYXV0by1tYXJrIG5vbi10YWcgdGV4dFxuICAgICAgICBjaHVua3MucHVzaChcbiAgICAgICAgICB0aGlzLl9pbnNlcnRNYXJrcyhzdWJzdHIsIGludGVybmFsTWFwLCBkdXBsaWNhdGVNYXJrVG9DaGVjaylcbiAgICAgICAgKTtcblxuICAgICAgICBkdXBsaWNhdGVNYXJrVG9DaGVjayA9IFtdO1xuICAgICAgfVxuXG4gICAgICBzc21sTWFya1Jlc3VsdCA9IHNzbWxNYXJrUmVnZXguZXhlYyhleGlzdGluZ1RhZy50ZXh0KTtcblxuICAgICAgaWYgKHNzbWxNYXJrUmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IG1hcmtUZXh0ID0gc3NtbE1hcmtSZXN1bHRbMV07XG4gICAgICAgIGR1cGxpY2F0ZU1hcmtUb0NoZWNrLnB1c2gobWFya1RleHQpO1xuICAgICAgfSBlbHNlIGlmICghc3BlYWtUYWdzLmluY2x1ZGVzKGV4aXN0aW5nVGFnLnRleHQpKSB7XG4gICAgICAgIGNodW5rcy5wdXNoKGV4aXN0aW5nVGFnLnRleHQpO1xuICAgICAgfVxuXG4gICAgICAvLyBhZHZhbmNlIHRoZSBpbmRleFxuICAgICAgaW5kZXggPSBleGlzdGluZ1RhZy5lbmQ7XG4gICAgfSk7XG5cbiAgICBjaHVua3MucHVzaChcbiAgICAgIHRoaXMuX2luc2VydE1hcmtzKHRleHQuc2xpY2UoaW5kZXgpLCBpbnRlcm5hbE1hcCwgZHVwbGljYXRlTWFya1RvQ2hlY2spXG4gICAgKTtcblxuICAgIGxldCBtYXJrZWRUZXh0ID0gY2h1bmtzLmpvaW4oJycpO1xuXG4gICAgaWYgKHJhbmRvbU1hcmtzICYmIHJhbmRvbU1hcmtzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIGFkZCByYW5kb20gbWFya3MgdG8gYW55IHVubWFya2VkIHNlbnRlbmNlc1xuICAgICAgbWFya2VkVGV4dCA9IHRoaXMuYWRkTWFya3NUb1VubWFya2VkU2VudGVuY2VzKG1hcmtlZFRleHQsIHJhbmRvbU1hcmtzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gVGV4dFRvU3BlZWNoVXRpbHMudmFsaWRhdGVUZXh0KG1hcmtlZFRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgc3RyaW5nIHdpdGggYSByYW5kb20gU1NNTCBtYXJrIGluc2VydGVkIGF0IGVhY2ggc2VudGVuY2UgdGhhdFxuICAgKiBkb2VzIG5vdCBhbHJlYWR5IGNvbnRhaW4gYW4gU1NNTCBtYXJrLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIElucHV0IHN0cmluZy5cbiAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gbWFya3MgLSBBbnkgYXJyYXkgb2YgcmFuZG9tIFNTTUwgbWFya3MgdG8gY2hvb3NlIGZyb21cbiAgICogd2hlbiBtb2RpZnlpbmcgdGhlIHRleHQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgYWRkTWFya3NUb1VubWFya2VkU2VudGVuY2VzKHRleHQsIG1hcmtzKSB7XG4gICAgaWYgKCFtYXJrcyB8fCBtYXJrcy5sZW5ndGggPT09IDApIHJldHVybiB0ZXh0O1xuXG4gICAgY29uc3Qgc3NtbE1hcmtSZWdleCA9IC88bWFyayBuYW1lPSg/OlwifCcpKC4qPykoPzpcInwnKVxcLz4vZztcbiAgICBjb25zdCBzc21sVGFnUmVnZXggPSAvPFtePl0qPi9nO1xuXG4gICAgLy8gRmluZCB0aGUgaW5kaWNlcyBvZiBhbnkgbWFya3MgaW4gdGhlIHRleHRcbiAgICBjb25zdCBtYXJrSW5kaWNlcyA9IFtdO1xuICAgIGxldCBtYXJrUmVzdWx0ID0gc3NtbE1hcmtSZWdleC5leGVjKHRleHQpO1xuXG4gICAgd2hpbGUgKG1hcmtSZXN1bHQgIT09IG51bGwpIHtcbiAgICAgIG1hcmtJbmRpY2VzLnB1c2gobWFya1Jlc3VsdC5pbmRleCk7XG4gICAgICBtYXJrUmVzdWx0ID0gc3NtbE1hcmtSZWdleC5leGVjKHRleHQpO1xuICAgIH1cblxuICAgIC8vIEZpbmQgYWxsIFNTTUwgdGFncyBpbiB0aGUgdGV4dFxuICAgIGNvbnN0IGV4aXN0aW5nVGFncyA9IFtdO1xuICAgIGxldCBzc21sUmVzdWx0ID0gc3NtbFRhZ1JlZ2V4LmV4ZWModGV4dCk7XG4gICAgd2hpbGUgKHNzbWxSZXN1bHQgIT09IG51bGwpIHtcbiAgICAgIGV4aXN0aW5nVGFncy5wdXNoKHtcbiAgICAgICAgc3RhcnQ6IHNzbWxSZXN1bHQuaW5kZXgsXG4gICAgICAgIGVuZDogc3NtbFJlc3VsdC5pbmRleCArIHNzbWxSZXN1bHRbMF0ubGVuZ3RoLFxuICAgICAgICB0ZXh0OiBzc21sUmVzdWx0WzBdLFxuICAgICAgfSk7XG4gICAgICBzc21sUmVzdWx0ID0gc3NtbFRhZ1JlZ2V4LmV4ZWModGV4dCk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGUgdGV4dCB3aXRoIGFsbCBTU01MIG1hcmtzIHJlcGxhY2VzIHdpdGggd2hpdGVzcGFjZVxuICAgIGxldCBjbGVhbmVkVGV4dCA9IHRleHQuc2xpY2UoKTtcbiAgICBleGlzdGluZ1RhZ3MuZm9yRWFjaChleGlzdGluZ1NzbWwgPT4ge1xuICAgICAgY29uc3Qgd2hpdGVzcGFjZSA9IG5ldyBBcnJheShleGlzdGluZ1NzbWwudGV4dC5sZW5ndGggKyAxKS5qb2luKCcgJyk7XG4gICAgICBjbGVhbmVkVGV4dCA9IFtcbiAgICAgICAgY2xlYW5lZFRleHQuc2xpY2UoMCwgZXhpc3RpbmdTc21sLnN0YXJ0KSxcbiAgICAgICAgd2hpdGVzcGFjZSxcbiAgICAgICAgY2xlYW5lZFRleHQuc2xpY2UoZXhpc3RpbmdTc21sLmVuZCksXG4gICAgICBdLmpvaW4oJycpO1xuICAgIH0pO1xuXG4gICAgY29uc3Qgc2VudGVuY2VFbmRJbmRpY2VzID0gdGhpcy5fZ2V0U2VudGVuY2VFbmRzKGNsZWFuZWRUZXh0KTtcblxuICAgIC8vIE9ubHkgaW5zZXJ0IHJhbmRvbSBtYXJrcyBpbnRvIHNlbnRlbmNlcyB0aGF0IGRvbid0IGFscmVhZHkgaGF2ZSBhbnlcbiAgICBsZXQgcHJldkluZGV4ID0gMDtcbiAgICBjb25zdCB0YXJnZXRJbmRpY2VzID0gc2VudGVuY2VFbmRJbmRpY2VzLmZpbHRlcihpbmRleCA9PiB7XG4gICAgICBjb25zdCBjb250YWluc01hcmsgPVxuICAgICAgICBtYXJrSW5kaWNlcy5maW5kSW5kZXgobWFya0luZGV4ID0+IHtcbiAgICAgICAgICByZXR1cm4gcHJldkluZGV4IDw9IG1hcmtJbmRleCAmJiBpbmRleCA+IG1hcmtJbmRleDtcbiAgICAgICAgfSkgIT09IC0xO1xuICAgICAgcHJldkluZGV4ID0gaW5kZXg7XG4gICAgICByZXR1cm4gIWNvbnRhaW5zTWFyaztcbiAgICB9KTtcblxuICAgIGNvbnN0IHJhbmRvbU1hcmtlZFRleHQgPSB0aGlzLl9pbnNlcnRSYW5kb21NYXJrc0F0KFxuICAgICAgdGV4dCxcbiAgICAgIHRhcmdldEluZGljZXMsXG4gICAgICBtYXJrc1xuICAgICk7XG5cbiAgICByZXR1cm4gcmFuZG9tTWFya2VkVGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHZlcnNpb24gb2YgZ2l2ZW4gdGV4dCB0aGF0IGlzIGVuY2xvc2VkIGJ5IFBvbGx5IHNzbWwgc3BlYWsgdGFncy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byB2YWxpZGF0ZS5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gLSBVcGRhdGVkIGlucHV0IHN0cmluZy5cbiAgICovXG4gIHN0YXRpYyB2YWxpZGF0ZVRleHQodGV4dCkge1xuICAgIGlmICghdGV4dCkge1xuICAgICAgdGV4dCA9ICc8c3BlYWs+PC9zcGVhaz4nO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZXh0ID0gdGV4dFxuICAgICAgICAucmVwbGFjZSgvKF5cXHMqPFxccypzcGVha1xccyopPlxccyp8KF5cXHMqKS8sICc8c3BlYWs+JylcbiAgICAgICAgLnJlcGxhY2UoLyhcXHMqPFxccypcXC9cXHMqc3BlYWtcXHMqPlxccyokfFxccyokKS8sICc8L3NwZWFrPicpO1xuICAgIH1cblxuICAgIHJldHVybiB0ZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGFuIGlucHV0IHN0cmluZyBhbmQgaW5zZXJ0IFNTTUwgbWFya3MgYmFzZWQgb25cbiAgICogd29yZCBtYXRjaGVzIGluIGEgbWFwLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIElucHV0IHN0cmluZy5cbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW2luZGljZXMgPSBbXV0gLSBBbiBhcnJheSBvZiBpbmRpY2VzIGluIHRoZSB0ZXh0IGlucHV0XG4gICAqIHdoZXJlIHJhbmRvbSBtYXJrcyBzaG91bGQgYmUgaW5zZXJ0ZWQuXG4gICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IFttYXJrcyA9IFtdXSAtIEFuIGFycmF5IG9mIG1hcmsgc3RyaW5ncyB0byBjaG9vc2VcbiAgICogZnJvbSB3aGVuIGluc2VydGluZyByYW5kb20gbWFya3MuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVXBkYXRlZCBpbnB1dCBzdHJpbmcuXG4gICAqL1xuICBzdGF0aWMgX2luc2VydFJhbmRvbU1hcmtzQXQodGV4dCwgaW5kaWNlcyA9IFtdLCBtYXJrcyA9IFtdKSB7XG4gICAgaWYgKCFtYXJrcyB8fCBtYXJrcy5sZW5ndGggPT09IDAgfHwgIWluZGljZXMgfHwgaW5kaWNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cblxuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGluZGljZXMuZm9yRWFjaChpbmRleCA9PiB7XG4gICAgICBjb25zdCByYW5kb21NYXJrID0gYDxtYXJrIG5hbWU9JyR7XG4gICAgICAgIG1hcmtzW1V0aWxzLmdldFJhbmRvbUludCgwLCBtYXJrcy5sZW5ndGgpXVxuICAgICAgfScvPmA7XG4gICAgICB0ZXh0ID0gW1xuICAgICAgICB0ZXh0LnNsaWNlKDAsIGluZGV4ICsgb2Zmc2V0KSxcbiAgICAgICAgcmFuZG9tTWFyayxcbiAgICAgICAgdGV4dC5zbGljZShpbmRleCArIG9mZnNldCksXG4gICAgICBdLmpvaW4oJycpO1xuICAgICAgb2Zmc2V0ICs9IHJhbmRvbU1hcmsubGVuZ3RoO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGEgc3RyaW5nIG9mIHRleHQgYW5kIHJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgaW5kaWNlc1xuICAgKiBvZiB0aGUgbGFzdCBjaGFyYWN0ZXIgaW4gYSBzZW50ZW5jZSB0aGF0IGlzIG5vdCBpbiB0aGUgZm9sbG93aW5nIGxpc3Q6XG4gICAqICAoJy4nLCAnPycsICchJylcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUZXh0IHRvIHByb2Nlc3MgZm9yIGVuZCBvZiBzZW50ZW5jZVxuICAgKiBpbmRpY2VzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59IC0gQXJyYXkgb2YgZW5kIG9mIHNlbnRlbmNlIGluZGljZXMuXG4gICAqL1xuICBzdGF0aWMgX2dldFNlbnRlbmNlRW5kcyh0ZXh0KSB7XG4gICAgY29uc3Qgc2VudGVuY2VSZWdleCA9IC9bXi4hP10rWy4hP10rL2c7XG4gICAgY29uc3QgZW5kU2VudGVuY2VSZWdleCA9IC9bLiE/XSsvO1xuXG4gICAgbGV0IHJlc3VsdCA9IHNlbnRlbmNlUmVnZXguZXhlYyh0ZXh0KTtcbiAgICBjb25zdCBzZW50ZW5jZUVuZHMgPSBbXTtcbiAgICB3aGlsZSAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAvLyBmaW5kIHRoZSBsYXN0IG5vbi1wdW5jdHVhdGlvbiBjaGFyYWN0ZXJcbiAgICAgIGNvbnN0IHB1bmN0UmVzdWx0ID0gZW5kU2VudGVuY2VSZWdleC5leGVjKHJlc3VsdFswXSk7XG4gICAgICBzZW50ZW5jZUVuZHMucHVzaChcbiAgICAgICAgcmVzdWx0LmluZGV4ICsgcmVzdWx0WzBdLmxlbmd0aCAtIHB1bmN0UmVzdWx0WzBdLmxlbmd0aFxuICAgICAgKTtcbiAgICAgIHJlc3VsdCA9IHNlbnRlbmNlUmVnZXguZXhlYyh0ZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VudGVuY2VFbmRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGFuIGlucHV0IHN0cmluZyBhbmQgaW5zZXJ0IFNTTUwgbWFya3MgYmFzZWQgb25cbiAgICogd29yZCBtYXRjaGVzIGluIGEgbWFwLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIElucHV0IHN0cmluZy5cbiAgICogQHBhcmFtIHtNYXB9IG1hcCAtIE1hcHBpbmcgb2Ygd29yZHMgdG8gbWFyayB2YWx1ZXMgdGhhdFxuICAgKiB3aWxsIGJlIGluc2VydGVkIGFzIHRoZSB2YWx1ZSBmb3IgYSBtYXJrJ3MgJ25hbWUnIGF0dHJpYnV0ZS5cbiAgICogQHBhcmFtIHtBcnJheX0gZHVwbGljYXRlc1RvQ2hlY2sgLSBBIGxpc3Qgb2YgbWFyayB2YWx1ZXMgdG8gY2hlY2sgZm9yIGR1cGxpY2F0ZSBhZ2FpbnN0IHRoZSBmaXJzdCB3b3JkXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVXBkYXRlZCBpbnB1dCBzdHJpbmcuXG4gICAqL1xuICBzdGF0aWMgX2luc2VydE1hcmtzKHRleHQsIG1hcCwgZHVwbGljYXRlc1RvQ2hlY2spIHtcbiAgICBpZiAodGV4dCA9PT0gJycpIHJldHVybiB0ZXh0O1xuXG4gICAgY29uc3Qgd29yZFJlZ2V4ID0gL1xcdyt8XFxzK3xbXlxcc1xcd10rL2c7XG5cbiAgICBsZXQgbG93ZXJDYXNlV29yZDtcbiAgICBsZXQgY2hlY2tEdXBsaWNhdGUgPSB0cnVlO1xuICAgIGNvbnN0IG1hcmtlZFdvcmRzID0gdGV4dC5tYXRjaCh3b3JkUmVnZXgpLm1hcCh3b3JkID0+IHtcbiAgICAgIGxvd2VyQ2FzZVdvcmQgPSB3b3JkLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIGlmIChtYXAuaGFzKGxvd2VyQ2FzZVdvcmQpKSB7XG4gICAgICAgIGNvbnN0IG1hcmtzID0gbWFwLmdldChsb3dlckNhc2VXb3JkKS5tYXAobWFyayA9PiB7XG4gICAgICAgICAgaWYgKGNoZWNrRHVwbGljYXRlKSB7XG4gICAgICAgICAgICBjaGVja0R1cGxpY2F0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGR1cGxpY2F0ZXNUb0NoZWNrLmluY2x1ZGVzKG1hcmspXG4gICAgICAgICAgICAgID8gJydcbiAgICAgICAgICAgICAgOiBgPG1hcmsgbmFtZT0nJHttYXJrfScvPmA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgPG1hcmsgbmFtZT0nJHttYXJrfScvPmA7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGAke21hcmtzLmpvaW4oJycpfSR7d29yZH1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hlY2tEdXBsaWNhdGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHdvcmQ7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBleGlzdGluZ01hcmtzID0gZHVwbGljYXRlc1RvQ2hlY2subWFwKG1hcmsgPT4ge1xuICAgICAgcmV0dXJuIGA8bWFyayBuYW1lPScke21hcmt9Jy8+YDtcbiAgICB9KTtcblxuICAgIHJldHVybiBgJHtleGlzdGluZ01hcmtzLmpvaW4oJycpfSR7bWFya2VkV29yZHMuam9pbignJyl9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgYW4gaW5wdXQgb2JqZWN0IGZvciBtYXBwaW5nIGFuIGFycmF5XG4gICAqIG9mIHdvcmRzIHRvIHNwZWNpZmljIG1hcmsga2V5cy4gQ29udmVydHMgdGhlIGlucHV0XG4gICAqIG1hcCBpbnRvIGEgTWFwIHdpdGggYSBtb3JlIGVmZmljaWVudCBmb3JtYXQgZm9yXG4gICAqIHBlcmZvcm1pbmcgbWFyayBpbmplY3Rpb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBtYXAgLSBJbnB1dCBvYmplY3QgdGhhdCBtYXBzIG1hcmsga2V5c1xuICAgKiB0byBhcnJheXMgb2Ygd29yZHMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtNYXB9IC0gTWFwIGZvciBpbnRlcm5hbCB1c2UuXG4gICAqL1xuICBzdGF0aWMgX3Byb2Nlc3NJbnB1dE1hcChtYXApIHtcbiAgICBjb25zdCBpbnRlcm5hbE1hcCA9IG5ldyBNYXAoKTtcblxuICAgIGxldCBsaXN0ID0gW107XG4gICAgT2JqZWN0LmVudHJpZXMobWFwKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBDYW5ub3QgZ2VuZXJhdGUgU1NNTCBtYXJrcyBmcm9tIG1hcCBcIiR7bWFwfVwiIGJlY2F1c2UgdmFsdWUgZm9yIGtleSAnJHtrZXl9JyBpcyBub3QgYW4gYXJyYXkuYFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB2YWx1ZS5mb3JFYWNoKHdvcmQgPT4ge1xuICAgICAgICBjb25zdCBsb3dlckNhc2VXb3JkID0gd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBsaXN0ID0gaW50ZXJuYWxNYXAuZ2V0KGxvd2VyQ2FzZVdvcmQpO1xuXG4gICAgICAgIGlmIChsaXN0ICE9PSB1bmRlZmluZWQgJiYgIWxpc3QuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgIGludGVybmFsTWFwLnNldChsb3dlckNhc2VXb3JkLCBbLi4ubGlzdCwga2V5XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW50ZXJuYWxNYXAuc2V0KGxvd2VyQ2FzZVdvcmQsIFtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gaW50ZXJuYWxNYXA7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGV4dFRvU3BlZWNoVXRpbHM7XG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxuaW1wb3J0IERlZmVycmVkIGZyb20gJ2NvcmUvRGVmZXJyZWQnO1xuXG4vKipcbiAqIENsYXNzIHRoYXQgY2FuIHBsYXkgYmFjayBhdWRpbyBnZW5lcmF0ZWQgYnkgQVdTIFBvbGx5IGFuZCBzeW5jaHJvbml6ZWQgZW1pdFxuICogc3BlZWNobWFyayBtZXNzYWdlcy5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqL1xuY2xhc3MgQWJzdHJhY3RTcGVlY2gge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7Y29yZS9UZXh0VG9TcGVlY2hGZWF0dXJlfSBzcGVha2VyIC0gVGhlIGZlYXR1cmUgdGhhdCBvd25zIHRoZSBTcGVlY2ggYW5kXG4gICAqIHdpbGwgZW1pdCBzcGVlY2htYXJrIG1lc3NhZ2VzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIFRoZSB0ZXh0IG9mIHRoZSBzcGVlY2guXG4gICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IFtzcGVlY2htYXJrcz1bXV0gLSBBbiBhcnJheSBvZiBzcGVlY2htYXJrIG9iamVjdHMgcmVwcmVzZW50aW5nXG4gICAqIHRoZSB0ZXh0IGFuZCB0aW1pbmcgb2YgdGhlIHNwZWVjaC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHNwZWFrZXIsIHRleHQsIHNwZWVjaG1hcmtzID0gW10pIHtcbiAgICB0aGlzLl9zcGVha2VyID0gc3BlYWtlcjtcbiAgICB0aGlzLl90ZXh0ID0gdGV4dDtcbiAgICB0aGlzLl9zcGVlY2htYXJrcyA9IHNwZWVjaG1hcmtzO1xuICAgIHRoaXMuX3NwZWVjaG1hcmtPZmZzZXQgPSAwO1xuICAgIHRoaXMuX3Jlc2V0KCk7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgdHJhY2tpbmcgcHJvcGVydGllcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtjdXJyZW50VGltZT0wXSAtIFRpbWUgdG8gdXNlIGZvciBfc3RhcnRUaW1lLlxuICAgKi9cbiAgX3Jlc2V0KGN1cnJlbnRUaW1lID0gMCkge1xuICAgIHRoaXMuX3N0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIHRoaXMuX2xvY2FsVGltZSA9IDA7XG4gICAgdGhpcy5fcGF1c2VUaW1lID0gMDtcbiAgICB0aGlzLl9wbGF5aW5nID0gZmFsc2U7XG4gICAgdGhpcy5fbWFya0l0ZXIgPSB0aGlzLl9zcGVlY2htYXJrcy52YWx1ZXMoKTtcbiAgICBjb25zdCB7dmFsdWUsIGRvbmV9ID0gdGhpcy5fbWFya0l0ZXIubmV4dCgpO1xuICAgIHRoaXMuX2N1cnJlbnRNYXJrID0gdmFsdWU7XG4gICAgdGhpcy5fZW5kVGltZSA9IHRoaXMuX3NwZWVjaG1hcmtzLmxlbmd0aFxuICAgICAgPyB0aGlzLl9zcGVlY2htYXJrc1t0aGlzLl9zcGVlY2htYXJrcy5sZW5ndGggLSAxXS50aW1lXG4gICAgICA6IDA7XG4gICAgdGhpcy5fZG9uZSA9IGRvbmU7XG4gICAgdGhpcy5fcHJvbWlzZSA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHByb21pc2UgdGhhdCB3aWxsIHN0b3AgcGxheWJhY2sgYW5kIGVtaXQgbWVzc2FnZXMgZm9yIHRoaXMgc3BlZWNoLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25GaW5pc2ggLSBGdW5jaXRvbiB0byBleGVjdXRlIG9uY2UgdGhlIHNwZWVjaCBzdG9wcy5cbiAgICogQHBhcmFtIHtvbkVycm9yPX0gb25FcnJvciAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgaWYgdGhlIHNwZWVjaCBlbmNvdW50ZXJzIGFuXG4gICAqIGVycm9yLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25JbnRlcnJ1cHQgLSBGdW5jdGlvbiB0byBleGVjdXRlIGlmIHRoZSBzcGVlY2ggaXMgY2FuY2VsZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH1cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jcmVhdGVQcm9taXNlKG9uRmluaXNoLCBvbkVycm9yLCBvbkludGVycnVwdCkge1xuICAgIGNvbnN0IG9uUmVzb2x2ZSA9IHZhbHVlID0+IHtcbiAgICAgIHRoaXMuX3BsYXlpbmcgPSBmYWxzZTtcblxuICAgICAgdGhpcy5fc3BlYWtlci5lbWl0KHRoaXMuX3NwZWFrZXIuY29uc3RydWN0b3IuRVZFTlRTLnN0b3AsIHRoaXMpO1xuICAgICAgdGhpcy5fc3BlYWtlci5jb25zdHJ1Y3Rvci5lbWl0KFxuICAgICAgICB0aGlzLl9zcGVha2VyLmNvbnN0cnVjdG9yLkVWRU5UUy5zdG9wLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuXG4gICAgICBpZiAodHlwZW9mIG9uRmluaXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9uRmluaXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgb25SZWplY3QgPSBlID0+IHtcbiAgICAgIHRoaXMuX3BsYXlpbmcgPSBmYWxzZTtcblxuICAgICAgdGhpcy5fc3BlYWtlci5lbWl0KHRoaXMuX3NwZWFrZXIuY29uc3RydWN0b3IuRVZFTlRTLnN0b3AsIHRoaXMpO1xuICAgICAgdGhpcy5fc3BlYWtlci5jb25zdHJ1Y3Rvci5lbWl0KFxuICAgICAgICB0aGlzLl9zcGVha2VyLmNvbnN0cnVjdG9yLkVWRU5UUy5zdG9wLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuXG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IGVuY291bnRlcmVkIGFuIHVuZXhwZWN0ZWQgZXJyb3I6ICR7ZX1gXG4gICAgICApO1xuXG4gICAgICBpZiAodHlwZW9mIG9uRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb25FcnJvcihlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgb25DYW5jZWwgPSB2YWx1ZSA9PiB7XG4gICAgICB0aGlzLl9wbGF5aW5nID0gZmFsc2U7XG5cbiAgICAgIHRoaXMuX3NwZWFrZXIuZW1pdCh0aGlzLl9zcGVha2VyLmNvbnN0cnVjdG9yLkVWRU5UUy5pbnRlcnJ1cHQsIHRoaXMpO1xuICAgICAgdGhpcy5fc3BlYWtlci5jb25zdHJ1Y3Rvci5lbWl0KFxuICAgICAgICB0aGlzLl9zcGVha2VyLmNvbnN0cnVjdG9yLkVWRU5UUy5pbnRlcnJ1cHQsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG5cbiAgICAgIGlmICh0eXBlb2Ygb25JbnRlcnJ1cHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb25JbnRlcnJ1cHQodmFsdWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLl9wcm9taXNlID0gbmV3IERlZmVycmVkKHVuZGVmaW5lZCwgb25SZXNvbHZlLCBvblJlamVjdCwgb25DYW5jZWwpO1xuXG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgb3Igbm90IHRoZSBzcGVlY2ggaGFzIHJlYWNoZWQgaXQncyBlbmQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgX2NoZWNrRmluaXNoZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RvbmUgJiYgdGhpcy5fbG9jYWxUaW1lID49IHRoaXMuX2VuZFRpbWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgcGxheWJhY2sgc3RhdGUgb2YgdGhlIGF1ZGlvLlxuICAgKlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgcGxheWluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGxheWluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB0ZXh0IG9mIHRoZSBzcGVlY2guXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IHRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RleHQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhIHNoYWxsb3cgY29weSBvZiB0aGUgc3BlZWNobWFya3MgYXJyYXkgZm9yIHRoZSBzcGVlY2guXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59XG4gICAqL1xuICBnZXQgc3BlZWNobWFya3MoKSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLl9zcGVlY2htYXJrc107XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbmQgc2V0cyB0aGUgbnVtYmVyIG9mIHNlY29uZHMgdG8gb2Zmc2V0IHNwZWVjaG1hcmsgZW1pc3Npb24uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgc3BlZWNobWFya09mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3BlZWNobWFya09mZnNldCAvIDEwMDA7XG4gIH1cblxuICBzZXQgc3BlZWNobWFya09mZnNldChvZmZzZXQpIHtcbiAgICB0aGlzLl9zcGVlY2htYXJrT2Zmc2V0ID0gb2Zmc2V0ICogMTAwMDsgLy8gU3RvcmUgYXMgbWlsbGlzZWNvbmRzXG4gIH1cblxuICAvKipcbiAgICogRW1pdCBzcGVlY2htYXJrIG1lc3NhZ2VzIGFzIHRoZXkgYXJlIGVuY291bnRlcmVkIGluIHN5bmMgd2l0aCBhdWRpby5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnRUaW1lIC0gQ3VycmVudCBnbG9iYWwgdGltZSB3aGVuIHVwZGF0ZSB3YXMgY2FsbGVkLlxuICAgKi9cbiAgdXBkYXRlKGN1cnJlbnRUaW1lKSB7XG4gICAgaWYgKCF0aGlzLl9wbGF5aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIGxvY2FsIGF1ZGlvIHRpbWVcbiAgICB0aGlzLl9sb2NhbFRpbWUgPSBjdXJyZW50VGltZSAtIHRoaXMuX3N0YXJ0VGltZTtcblxuICAgIGlmICghdGhpcy5fZG9uZSkge1xuICAgICAgLy8gRW1pdCBzcGVlY2htYXJrIG1lc3NhZ2VzIGZvciBtYXJrcyB1cCB0byB0aGUgY3VycmVudCB0aW1lXG4gICAgICB3aGlsZSAoXG4gICAgICAgICF0aGlzLl9kb25lICYmXG4gICAgICAgIHRoaXMuX2N1cnJlbnRNYXJrLnRpbWUgKyB0aGlzLl9zcGVlY2htYXJrT2Zmc2V0IDw9IHRoaXMuX2xvY2FsVGltZVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuX3NwZWFrZXIuZW1pdChcbiAgICAgICAgICB0aGlzLl9zcGVha2VyLmNvbnN0cnVjdG9yLkVWRU5UU1t0aGlzLl9jdXJyZW50TWFyay50eXBlXSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzcGVlY2g6IHRoaXMsXG4gICAgICAgICAgICBtYXJrOiB0aGlzLl9jdXJyZW50TWFyayxcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHt2YWx1ZSwgZG9uZX0gPSB0aGlzLl9tYXJrSXRlci5uZXh0KCk7XG5cbiAgICAgICAgdGhpcy5fY3VycmVudE1hcmsgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fZG9uZSA9IGRvbmU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRW5kIHBsYXliYWNrXG4gICAgaWYgKHRoaXMuX2NoZWNrRmluaXNoZWQoKSkge1xuICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICB0aGlzLl9yZXNldCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQbGF5IHRoZSBzcGVlY2ggZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY3VycmVudFRpbWUgLSBDdXJyZW50IGdsb2JhbCB0aW1lIHdoZW4gcGxheSB3YXMgY2FsbGVkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25GaW5pc2ggLSBPcHRpb25hbCBmdW5jdGlvbiB0byBleGVjdXRlIG9uY2UgdGhlIHNwZWVjaFxuICAgKiBwcm9taXNlIHJlc29sdmVzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25FcnJvciAtIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgaWYgdGhlIHNwZWVjaFxuICAgKiBlbmNvdW50ZXJzIGFuZCBlcnJvciBkdXJpbmcgcGxheWJhY2suXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkludGVycnVwdCAtIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgaWYgdGhlIHNwZWVjaFxuICAgKiBpcyBjYW5jZWxlZC5cbiAgICpcbiAgICogQHJldHVybnMge0RlZmVycmVkfSBSZXNvbHZlcyBvbmNlIHRoZSBzcGVlY2ggcmVhY2hlcyB0aGUgZW5kIG9mIHBsYXliYWNrLlxuICAgKi9cbiAgcGxheShjdXJyZW50VGltZSwgb25GaW5pc2gsIG9uRXJyb3IsIG9uSW50ZXJydXB0KSB7XG4gICAgdGhpcy5fcmVzZXQoY3VycmVudFRpbWUpO1xuICAgIHRoaXMuX3BsYXlpbmcgPSB0cnVlO1xuXG4gICAgdGhpcy5fc3BlYWtlci5lbWl0KHRoaXMuX3NwZWFrZXIuY29uc3RydWN0b3IuRVZFTlRTLnBsYXksIHRoaXMpO1xuICAgIHRoaXMuX3NwZWFrZXIuY29uc3RydWN0b3IuZW1pdCh0aGlzLl9zcGVha2VyLmNvbnN0cnVjdG9yLkVWRU5UUy5wbGF5LCB0aGlzKTtcblxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVQcm9taXNlKG9uRmluaXNoLCBvbkVycm9yLCBvbkludGVycnVwdCk7XG4gIH1cblxuICAvKipcbiAgICogUGF1c2UgdGhlIHNwZWVjaCBhdCB0aGUgY3VycmVudCB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY3VycmVudFRpbWUgLSBDdXJyZW50IGdsb2JhbCB0aW1lIHdoZW4gcGF1c2Ugd2FzIGNhbGxlZC5cbiAgICovXG4gIHBhdXNlKGN1cnJlbnRUaW1lKSB7XG4gICAgdGhpcy5fcGxheWluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3BhdXNlVGltZSA9IGN1cnJlbnRUaW1lO1xuXG4gICAgdGhpcy5fc3BlYWtlci5lbWl0KHRoaXMuX3NwZWFrZXIuY29uc3RydWN0b3IuRVZFTlRTLnBhdXNlLCB0aGlzKTtcbiAgICB0aGlzLl9zcGVha2VyLmNvbnN0cnVjdG9yLmVtaXQoXG4gICAgICB0aGlzLl9zcGVha2VyLmNvbnN0cnVjdG9yLkVWRU5UUy5wYXVzZSxcbiAgICAgIHRoaXNcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc3VtZSB0aGUgc3BlZWNoIGF0IHRoZSBjdXJyZW50IHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50VGltZSAtIEN1cnJlbnQgZ2xvYmFsIHRpbWUgd2hlbiByZXN1bWUgd2FzIGNhbGxlZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uRmluaXNoIC0gT3B0aW9uYWwgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbmNlIHRoZSBzcGVlY2hcbiAgICogcHJvbWlzZSByZXNvbHZlcy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uRXJyb3IgLSBPcHRpb25hbCBmdW5jdGlvbiB0byBleGVjdXRlIGlmIHRoZSBzcGVlY2hcbiAgICogZW5jb3VudGVycyBhbmQgZXJyb3IgZHVyaW5nIHBsYXliYWNrLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25JbnRlcnJ1cHQgLSBPcHRpb25hbCBmdW5jdGlvbiB0byBleGVjdXRlIGlmIHRoZSBzcGVlY2hcbiAgICogaXMgY2FuY2VsZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH0gUmVzb2x2ZXMgb25jZSB0aGUgc3BlZWNoIHJlYWNoZXMgdGhlIGVuZCBvZiBwbGF5YmFjay5cbiAgICovXG4gIHJlc3VtZShjdXJyZW50VGltZSwgb25GaW5pc2gsIG9uRXJyb3IsIG9uSW50ZXJydXB0KSB7XG4gICAgLy8gUGxheSBmcm9tIHRoZSBiZWdpbm5pbmcgaWYgdGhlIHNwZWVjaCBoYXNuJ3QgcGxheWVkIHlldFxuICAgIGlmICghdGhpcy5fcHJvbWlzZSkge1xuICAgICAgdGhpcy5fcmVzZXQoY3VycmVudFRpbWUpO1xuICAgICAgdGhpcy5fY3JlYXRlUHJvbWlzZShvbkZpbmlzaCwgb25FcnJvciwgb25JbnRlcnJ1cHQpO1xuICAgIH1cblxuICAgIHRoaXMuX3BsYXlpbmcgPSB0cnVlO1xuICAgIHRoaXMuX3N0YXJ0VGltZSArPSBjdXJyZW50VGltZSAtIHRoaXMuX3BhdXNlVGltZTtcblxuICAgIHRoaXMuX3NwZWFrZXIuZW1pdCh0aGlzLl9zcGVha2VyLmNvbnN0cnVjdG9yLkVWRU5UUy5yZXN1bWUsIHRoaXMpO1xuICAgIHRoaXMuX3NwZWFrZXIuY29uc3RydWN0b3IuZW1pdChcbiAgICAgIHRoaXMuX3NwZWFrZXIuY29uc3RydWN0b3IuRVZFTlRTLnJlc3VtZSxcbiAgICAgIHRoaXNcbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VscyBwbGF5YmFjayBvZiB0aGUgc3BlZWNoIGF0IHRoZSBjdXJyZW50IHRpbWUuIENhbmNlbCB0aGUgc3BlZWNoIHByb21pc2UuXG4gICAqL1xuICBjYW5jZWwoKSB7XG4gICAgaWYgKHRoaXMuX3Byb21pc2UpIHtcbiAgICAgIHRoaXMuX3Byb21pc2UuY2FuY2VsKCk7XG4gICAgICB0aGlzLl9wcm9taXNlID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLl9wbGF5aW5nID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCB0aGUgc3BlZWNoIGFuZCByZXNldCB0aW1lIHRvIHRoZSBiZWdpbm5pbmcuIFJlc29sdmUgdGhlIHNwZWVjaCBwcm9taXNlLlxuICAgKi9cbiAgc3RvcCgpIHtcbiAgICBpZiAodGhpcy5fcHJvbWlzZSkge1xuICAgICAgdGhpcy5fcHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB0aGlzLl9wcm9taXNlID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLl9wbGF5aW5nID0gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQWJzdHJhY3RTcGVlY2g7XG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxuaW1wb3J0IEFic3RyYWN0U3BlZWNoIGZyb20gJy4vQWJzdHJhY3RTcGVlY2gnO1xuXG4vKipcbiAqIFRoZSBidWlsdC1pbiBjbGFzcyBmb3IgYXN5bmNocm9ub3VzIFByb21pc2VzLlxuICogQGV4dGVybmFsIEF1ZGlvXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MQXVkaW9FbGVtZW50L0F1ZGlvXG4gKi9cblxuLyoqXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFNwZWVjaFxuICogQGFsaWFzIGNvcmUvU3BlZWNoXG4gKi9cbmNsYXNzIFNwZWVjaCBleHRlbmRzIEFic3RyYWN0U3BlZWNoIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUb1NwZWVjaH0gc3BlYWtlciAtIFRoZSBvd25lciBvZiB0aGUgU3BlZWNoIHRoYXQgd2lsbCBlbWl0IHNwZWVjaG1hcmtcbiAgICogbWVzc2FnZXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgb2YgdGhlIHNwZWVjaC5cbiAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gW3NwZWVjaG1hcmtzPVtdXSAtIEFuIGFycmF5IG9mIHNwZWVjaG1hcmsgb2JqZWN0cyByZXByZXNlbnRpbmdcbiAgICogdGhlIHRleHQgYW5kIHRpbWluZyBvZiB0aGUgc3BlZWNoLlxuICAgKiBAcGFyYW0ge09iamVjdH0gYXVkaW9Db25maWcgLSBPYmplY3QgY29udGFpbmluZyBhdWRpbyBhbmQgdXJsLlxuICAgKiBAcGFyYW0ge2V4dGVybmFsOkF1ZGlvfSBhdWRpb0NvbmZpZy5hdWRpbyAtIFBsYXlhYmxlIGF1ZGlvIG9iamVjdC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHNwZWFrZXIsIHRleHQsIHNwZWVjaG1hcmtzID0gW10sIGF1ZGlvQ29uZmlnKSB7XG4gICAgc3VwZXIoc3BlYWtlciwgdGV4dCwgc3BlZWNobWFya3MpO1xuICAgIHRoaXMuX2F1ZGlvID0gYXVkaW9Db25maWcuYXVkaW87XG5cbiAgICAvLyBLZWVwIHRyYWNrIG9mIHdoZXRoZXIgdGhlIGF1ZGlvIGhhcyBmaW5pc2hlZCBwbGF5aW5nIHRocm91Z2hcbiAgICB0aGlzLl9hdWRpby5vbmVuZGVkID0gKCkgPT4ge1xuICAgICAgdGhpcy5fYXVkaW9GaW5pc2hlZCA9IHRydWU7XG4gICAgfTtcbiAgICB0aGlzLl9hdWRpb0ZpbmlzaGVkID0gdHJ1ZTtcbiAgfVxuXG4gIF9jaGVja0ZpbmlzaGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9hdWRpb0ZpbmlzaGVkICYmIHN1cGVyLl9jaGVja0ZpbmlzaGVkKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgcGxheWFibGUgYXVkaW8gZm9yIHRoZSBzcGVlY2guXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7ZXh0ZXJuYWw6QXVkaW99XG4gICAqL1xuICBnZXQgYXVkaW8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F1ZGlvO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGF1ZGlvIHZvbHVtZSBmb3IgdGhlIHNwZWVjaC5cbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB2b2x1bWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F1ZGlvLnZvbHVtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBhdWRpbyB2b2x1bWUgZm9yIHRoZSBzcGVlY2guXG4gICAqL1xuICBzZXQgdm9sdW1lKHZvbHVtZSkge1xuICAgIHRoaXMuX2F1ZGlvLnZvbHVtZSA9IHZvbHVtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGF1ZGlvJ3MgY3VycmVudCBsb2NhbCB0aW1lIGFuZCBwbGF5IGl0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3BsYXlBdWRpbygpIHtcbiAgICBpZiAodGhpcy5fc3BlZWNobWFya09mZnNldCA8IDApIHtcbiAgICAgIHRoaXMuX2F1ZGlvLmN1cnJlbnRUaW1lID0gdGhpcy5fc3BlZWNobWFya09mZnNldDtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fcGxheWluZykge1xuICAgICAgICAgIHRoaXMuX2F1ZGlvLmN1cnJlbnRUaW1lID1cbiAgICAgICAgICAgICh0aGlzLl9sb2NhbFRpbWUgKyB0aGlzLl9zcGVlY2htYXJrT2Zmc2V0KSAvIDEwMDA7XG4gICAgICAgICAgdGhpcy5fYXVkaW8ucGxheSgpO1xuICAgICAgICB9XG4gICAgICB9LCAtdGhpcy5fc3BlZWNobWFya09mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2F1ZGlvLmN1cnJlbnRUaW1lID0gMDtcbiAgICAgIHRoaXMuX2F1ZGlvLnBsYXkoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGF1c2UgdGhlIGF1ZGlvIG9uY2UgaXQgaXMgcGxheWFibGUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcGF1c2VBdWRpbygpIHtcbiAgICB0aGlzLl9hdWRpby5wbGF5KCkudGhlbigoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX3BsYXlpbmcpIHtcbiAgICAgICAgdGhpcy5fYXVkaW8ucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHBsYXkoY3VycmVudFRpbWUsIG9uRmluaXNoLCBvbkVycm9yLCBvbkludGVycnVwdCkge1xuICAgIHRoaXMuX2F1ZGlvRmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wbGF5QXVkaW8oKTtcblxuICAgIHJldHVybiBzdXBlci5wbGF5KGN1cnJlbnRUaW1lLCBvbkZpbmlzaCwgb25FcnJvciwgb25JbnRlcnJ1cHQpO1xuICB9XG5cbiAgcGF1c2UoY3VycmVudFRpbWUpIHtcbiAgICB0aGlzLl9wYXVzZUF1ZGlvKCk7XG4gICAgc3VwZXIucGF1c2UoY3VycmVudFRpbWUpO1xuICB9XG5cbiAgcmVzdW1lKGN1cnJlbnRUaW1lLCBvbkZpbmlzaCwgb25FcnJvciwgb25JbnRlcnJ1cHQpIHtcbiAgICB0aGlzLl9hdWRpb0ZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fYXVkaW8ucGxheSgpO1xuXG4gICAgcmV0dXJuIHN1cGVyLnJlc3VtZShjdXJyZW50VGltZSwgb25GaW5pc2gsIG9uRXJyb3IsIG9uSW50ZXJydXB0KTtcbiAgfVxuXG4gIGNhbmNlbCgpIHtcbiAgICB0aGlzLl9wYXVzZUF1ZGlvKCk7XG4gICAgc3VwZXIuY2FuY2VsKCk7XG4gIH1cblxuICBzdG9wKCkge1xuICAgIHRoaXMuX3BhdXNlQXVkaW8oKTtcbiAgICB0aGlzLl9hdWRpby5jdXJyZW50VGltZSA9IDA7XG4gICAgc3VwZXIuc3RvcCgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNwZWVjaDtcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXG5pbXBvcnQgQWJzdHJhY3RIb3N0RmVhdHVyZSBmcm9tICdjb3JlL0Fic3RyYWN0SG9zdEZlYXR1cmUnO1xuaW1wb3J0IEFuaW1hdGlvblV0aWxzIGZyb20gJ2NvcmUvYW5pbXBhY2svQW5pbWF0aW9uVXRpbHMnO1xuaW1wb3J0IE1hdGhVdGlscyBmcm9tICdjb3JlL01hdGhVdGlscyc7XG5pbXBvcnQgRGVmZXJyZWQgZnJvbSAnY29yZS9EZWZlcnJlZCc7XG5pbXBvcnQgU3BlZWNoIGZyb20gJy4vQWJzdHJhY3RTcGVlY2gnO1xuaW1wb3J0IFRleHRUb1NwZWVjaFV0aWxzIGZyb20gJy4vVGV4dFRvU3BlZWNoVXRpbHMnO1xuXG4vKipcbiAqIFRoZSBBbWF6b24gUG9sbHkgc2VydmljZSBvYmplY3QuXG4gKiBAZXh0ZXJuYWwgUG9sbHlcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FXU0phdmFTY3JpcHRTREsvbGF0ZXN0L0FXUy9Qb2xseS5odG1sXG4gKi9cblxuLyoqXG4gKiBUaGUgcHJlc2lnbmVyIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIGdlbmVyYXRlIHByZXNpZ25lZCB1cmxzIGZvciB0aGUgUG9sbHkgc2VydmljZS5cbiAqIEBleHRlcm5hbCBQcmVzaWduZXJcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FXU0phdmFTY3JpcHRTREsvbGF0ZXN0L0FXUy9Qb2xseS9QcmVzaWduZXIuaHRtbFxuICovXG5cbi8vIEF2YWlsYWJsZSBvcHRpb25zIGZvciBQb2xseVxuY29uc3QgZW5naW5lcyA9IFsnc3RhbmRhcmQnLCAnbmV1cmFsJ107XG5jb25zdCBhdWRpb0Zvcm1hdHMgPSBbJ21wMycsICdvZ2dfdm9yYmlzJywgJ3BjbSddO1xuY29uc3Qgc3BlZWNobWFya1R5cGVzID0gWydzZW50ZW5jZScsICdzc21sJywgJ3Zpc2VtZScsICd3b3JkJ107XG5jb25zdCBzYW1wbGVSYXRlcyA9IHtcbiAgbXAzOiB7XG4gICAgcmF0ZXM6IFsnODAwMCcsICcxNjAwMCcsICcyMjA1MCcsICcyNDAwMCddLFxuICAgIGRlZmF1bHRzOiB7XG4gICAgICBzdGFuZGFyZDogJzIwNTAnLFxuICAgICAgbmV1cmFsOiAnMjQwMCcsXG4gICAgfSxcbiAgfSxcbiAgcGNtOiB7XG4gICAgcmF0ZXM6IFsnODAwMCcsICcxNjAwMCddLFxuICAgIGRlZmF1bHRzOiB7XG4gICAgICBzdGFuZGFyZDogJzE2MDAnLFxuICAgICAgbmV1cmFsOiAnMTYwMCcsXG4gICAgfSxcbiAgfSxcbn07XG5zYW1wbGVSYXRlcy5vZ2dfdm9yYmlzID0gc2FtcGxlUmF0ZXMubXAzO1xubGV0IGF3c1ZlcnNpb247XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgdHVybmluZyB0ZXh0IGlucHV0IGludG8gcGxheWFibGUgYXVkaW8uIFRoZXJlIHNob3VsZCBiZSBvbmUgaW5zdGFuY2VcbiAqIHBlciBzcGVha2VyLCBlYWNoIGluc3RhbmNlIGNhbiBwbGF5IG9ubHkgb25lIHBpZWNlIG9mIHRleHQgYXQgYSB0aW1lLlxuICpcbiAqIEBleHRlbmRzIEFic3RyYWN0SG9zdEZlYXR1cmVcbiAqIEBhYnN0cmFjdFxuICpcbiAqIEBwcm9wZXJ0eSB7KG51bWJlcnx1bmRlZmluZWQpfSBBV1NfVkVSU0lPTiAtIEdldHMgdGhlIHZlcnNpb24gb2YgQVdTIFNESyBiZWluZ1xuICogdXNlZC4gV2lsbCBiZSB1bmRlZmluZWQgdW50aWwgW2luaXRpYWxpemVTZXJ2aWNlXXtAbGluayBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUuaW5pdGlhbGl6ZVNlcnZpY2V9XG4gKiBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgZXhlY3V0ZWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW1BPTExZX01JTl9ORVVSQUxfVkVSU0lPTj0nMi41MDMnXSAtIEdldHMgdGhlIG1pbmltdW0gdmVyc2lvblxuICogb2YgdGhlIEFXUyBTREsgdGhhdCBpcyBuZWNlc3NhcnkgdG8gdXNlIG5ldXJhbCB2b2ljZXMgd2l0aCBBV1MgUG9sbHkuXG4gKiBAcHJvcGVydHkge09iamVjdH0gUE9MTFlfREVGQVVMVFMgLSBEZWZhdWx0IHZhbHVlcyB0byB1c2Ugd2l0aCBjYWxscyB0byB7QGxpbmsgZXh0ZXJuYWw6UG9sbHl9LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtQT0xMWV9ERUZBVUxUUy5FbmdpbmU9J3N0YW5kYXJkJ11cbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPHN0cmluZz59IFtQT0xMWV9ERUZBVUxUUy5MZXhpY29uTmFtZXM9W11dXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW1BPTExZX0RFRkFVTFRTLk91dHB1dEZvcm1hdD0nbXAzJ11cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbUE9MTFlfREVGQVVMVFMuU2FtcGxlUmF0ZT0nMjIwNTAnXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtQT0xMWV9ERUZBVUxUUy5UZXh0PScnXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtQT0xMWV9ERUZBVUxUUy5UZXh0VHlwZT0nc3NtbCddXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW1BPTExZX0RFRkFVTFRTLlZvaWNlSWQ9J0FteSddXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW1BPTExZX0RFRkFVTFRTLkxhbmd1YWdlQ29kZT0nZW4tR0InXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtQT0xMWV9ERUZBVUxUUy5MYW5ndWFnZU5hbWU9J0JyaXRpc2ggRW5nbGlzaCddXG4gKiBAcHJvcGVydHkge0FycmF5LjxzdHJpbmc+fSBbUE9MTFlfVk9JQ0VTPVtdXSAtIEFuIGFycmF5IG9mIHZvaWNlcyBhdmFpbGFibGUgaW5cbiAqIFBvbGx5LiBXaWxsIGJlIGVtcHR5IHVudGlsIFtpbml0aWFsaXplU2VydmljZV17QGxpbmsgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlLmluaXRpYWxpemVTZXJ2aWNlfVxuICogaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGV4ZWN1dGVkLiBTZWUgW1BvbGx5IERvY3VtZW50YXRpb25de0BsaW5rIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9wb2xseS9sYXRlc3QvZGcvdm9pY2VsaXN0Lmh0bWx9XG4gKiBmb3IgYSBmdWxsIGxpc3Qgb2YgYXZhaWxhYmxlIHZvaWNlcy5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbUE9MTFlfTEFOR1VBR0VTPXt9XSAtIEFuIG9iamVjdCB0aGF0IG1hcHMgbGFuZ3VhZ2UgbmFtZXNcbiAqIHRvIGxhbmd1YWdlIGNvZGVzIHRoYXQgYXJlIGF2YWlsYWJsZSBpbiBQb2xseS4gV2lsbCBiZSBlbXB0eSB1bnRpbFxuICogW2luaXRpYWxpemVTZXJ2aWNlXXtAbGluayBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUuaW5pdGlhbGl6ZVNlcnZpY2V9XG4gKiBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgZXhlY3V0ZWQuIFNlZSBbUG9sbHkgRG9jdW1lbnRhdGlvbl17QGxpbmsgaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL3BvbGx5L2xhdGVzdC9kZy9TdXBwb3J0ZWRMYW5ndWFnZS5odG1sfVxuICogZm9yIGEgZnVsbCBsaXN0IG9mIGF2YWlsYWJsZSBsYW5ndWFnZXMgYW5kIGNvcnJlc3BvbmRpbmcgY29kZXMuXG4gKiBAcHJvcGVydHkge09iamVjdH0gW1BPTExZX0xBTkdVQUdFX0NPREVTPXt9XSAtIEFuIG9iamVjdCB0aGF0IG1hcHMgbGFuZ3VhZ2UgY29kZXNcbiAqIHRvIGxhbmd1YWdlIG5hbWVzIHRoYXQgYXJlIGF2YWlsYWJsZSBpbiBQb2xseS4gV2lsbCBiZSBlbXB0eSB1bnRpbFxuICogW2luaXRpYWxpemVTZXJ2aWNlXXtAbGluayBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUuaW5pdGlhbGl6ZVNlcnZpY2V9XG4gKiBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgZXhlY3V0ZWQuIFNlZSBbUG9sbHkgRG9jdW1lbnRhdGlvbl17QGxpbmsgaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL3BvbGx5L2xhdGVzdC9kZy9TdXBwb3J0ZWRMYW5ndWFnZS5odG1sfVxuICogZm9yIGEgZnVsbCBsaXN0IG9mIGF2YWlsYWJsZSBsYW5ndWFnZXMgYW5kIGNvcnJlc3BvbmRpbmcgY29kZXMuXG4gKiBAcHJvcGVydHkge09iamVjdH0gRVZFTlRTIC0gQnVpbHQtaW4gbWVzc2FnZXMgdGhhdCB0aGUgZmVhdHVyZSBlbWl0cy4gV2hlbiB0aGVcbiAqIGZlYXR1cmUgaXMgYWRkZWQgdG8gYSB7QGxpbmsgY29yZS9Ib3N0T2JqZWN0fSwgZXZlbnQgbmFtZXMgd2lsbCBiZSBwcmVmaXhlZCBieSB0aGVcbiAqIG5hbWUgb2YgdGhlIGZlYXR1cmUgY2xhc3MgKyAnLicuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UUy5yZWFkeT1vblJlYWR5RXZlbnRdIC0gTWVzc2FnZSB0aGF0IGlzIGVtaXR0ZWQgYWZ0ZXJcbiAqIFtpbml0aWFsaXplU2VydmljZV17QGxpbmsgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlLmluaXRpYWxpemVTZXJ2aWNlfSBoYXMgYmVlblxuICogc3VjY2Vzc2Z1bGx5IGV4ZWN1dGVkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVFMucGxheT1vblBsYXlFdmVudF0gLSBNZXNzYWdlIHRoYXQgaXMgZW1pdHRlZCBhZnRlclxuICogZWFjaCBjYWxsIHRvIFtwbGF5XXtAbGluayBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUjcGxheX0uIFRoZSBzcGVlY2ggdGhhdCB3YXMgcGxheWVkXG4gKiBpcyBzdXBwbGllZCBhcyBhbiBhcmd1bWVudCB0byBsaXN0ZW5lciBmdW5jdGlvbnMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UUy5wYXVzZT1vblBhdXNlRXZlbnRdIC0gTWVzc2FnZSB0aGF0IGlzIGVtaXR0ZWQgYWZ0ZXJcbiAqIGVhY2ggY2FsbCB0byBbcGF1c2Vde0BsaW5rIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSNwYXVzZX0uIFRoZSBzcGVlY2ggdGhhdCB3YXMgcGF1c2VkXG4gKiBpcyBzdXBwbGllZCBhcyBhbiBhcmd1bWVudCB0byBsaXN0ZW5lciBmdW5jdGlvbnMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UUy5yZXN1bWU9b25SZXN1bWVFdmVudF0gLSBNZXNzYWdlIHRoYXQgaXMgZW1pdHRlZCBhZnRlclxuICogZWFjaCBjYWxsIHRvIFtyZXN1bWVde0BsaW5rIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSNyZXN1bWV9LiBUaGUgc3BlZWNoIHRoYXQgd2FzXG4gKiByZXN1bWVkIGlzIHN1cHBsaWVkIGFzIGFuIGFyZ3VtZW50IHRvIGxpc3RlbmVyIGZ1bmN0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLmludGVycnVwdD1vbkludGVycnVwdEV2ZW50XSAtIE1lc3NhZ2UgdGhhdCBpcyBlbWl0dGVkXG4gKiBpZiB0aGVyZSBpcyBhIGN1cnJlbnQgc3BlZWNoIGluIHByb2dyZXNzIGFuZCBbcGxheV17QGxpbmsgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlI3BsYXl9XG4gKiBvciBbcmVzdW1lXXtAbGluayBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUjcmVzdW1lfSBhcmUgZXhlY3V0ZWQgZm9yIGEgbmV3IHNwZWVjaC5cbiAqIFRoZSBzcGVlY2ggdGhhdCB3YXMgaW50ZXJydXB0ZWQgaXMgc3VwcGxpZWQgYXMgYW4gYXJndW1lbnQgdG8gbGlzdGVuZXIgZnVuY3Rpb25zLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVFMuc3RvcD1vblN0b3BFdmVudF0gLSBNZXNzYWdlIHRoYXQgaXMgZW1pdHRlZCBhZnRlclxuICogZWFjaCBjYWxsIHRvIFtzdG9wXXtAbGluayBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUjc3RvcH0gYW5kIHdoZW4gYSBzcGVlY2ggcmVhY2hlc1xuICogdGhlIGVuZCBvZiBwbGF5YmFjay4gVGhlIHNwZWVjaCB0aGF0IHdhcyBzdG9wcGVkIGlzIHN1cHBsaWVkIGFzIGFuIGFyZ3VtZW50XG4gKiB0byBsaXN0ZW5lciBmdW5jdGlvbnMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UUy5zZW50ZW5jZT1vblNlbnRlbmNlRXZlbnRdIC0gTWVzc2FnZSB0aGF0IGlzIGVtaXR0ZWRcbiAqIGVhY2ggdGltZSBhIHNlbnRlbmNlIHNwZWVjaG1hcmsgaXMgZW5jb3VudGVyZWQgd2hvc2UgdGltZXN0YW1wIG1hdGNoZXMgdXAgd2l0aFxuICogdGhlIHNwZWVjaCBhdWRpbydzIGN1cnJlbnQgdGltZS4gVGhlIHNlbnRlbmNlIHNwZWVjaG1hcmsgb2JqZWN0IGlzIHN1cHBsaWVkIGFzXG4gKiBhbiBhcmd1bWVudCB0byBsaXN0ZW5lciBmdW5jdGlvbnMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UUy53b3JkPW9uV29yZEV2ZW50XSAtIE1lc3NhZ2UgdGhhdCBpcyBlbWl0dGVkXG4gKiBlYWNoIHRpbWUgYSB3b3JkIHNwZWVjaG1hcmsgaXMgZW5jb3VudGVyZWQgd2hvc2UgdGltZXN0YW1wIG1hdGNoZXMgdXAgd2l0aFxuICogdGhlIHNwZWVjaCBhdWRpbydzIGN1cnJlbnQgdGltZS4gVGhlIHdvcmQgc3BlZWNobWFyayBvYmplY3QgaXMgc3VwcGxpZWQgYXNcbiAqIGFuIGFyZ3VtZW50IHRvIGxpc3RlbmVyIGZ1bmN0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLnZpc2VtZT1vblZpc2VtZUV2ZW50XSAtIE1lc3NhZ2UgdGhhdCBpcyBlbWl0dGVkXG4gKiBlYWNoIHRpbWUgYSB2aXNlbWUgc3BlZWNobWFyayBpcyBlbmNvdW50ZXJlZCB3aG9zZSB0aW1lc3RhbXAgbWF0Y2hlcyB1cCB3aXRoXG4gKiB0aGUgc3BlZWNoIGF1ZGlvJ3MgY3VycmVudCB0aW1lLiBUaGUgdmlzZW1lIHNwZWVjaG1hcmsgb2JqZWN0IGlzIHN1cHBsaWVkIGFzXG4gKiBhbiBhcmd1bWVudCB0byBsaXN0ZW5lciBmdW5jdGlvbnMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UUy5zc21sPW9uU3NtbEV2ZW50XSAtIE1lc3NhZ2UgdGhhdCBpcyBlbWl0dGVkXG4gKiBlYWNoIHRpbWUgYSBzc21sIHNwZWVjaG1hcmsgaXMgZW5jb3VudGVyZWQgd2hvc2UgdGltZXN0YW1wIG1hdGNoZXMgdXAgd2l0aFxuICogdGhlIHNwZWVjaCBhdWRpbydzIGN1cnJlbnQgdGltZS4gVGhlIHNzbWwgc3BlZWNobWFyayBvYmplY3QgaXMgc3VwcGxpZWQgYXNcbiAqIGFuIGFyZ3VtZW50IHRvIGxpc3RlbmVyIGZ1bmN0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBTRVJWSUNFUyAtIEFXUyBzZXJ2aWNlcyB0aGF0IGFyZSBuZWNlc3NhcnkgZm9yIHRoZSBmZWF0dXJlXG4gKiB0byBmdW5jdGlvbi5cbiAqIEBwcm9wZXJ0eSB7ZXh0ZXJuYWw6UG9sbHl9IFNFUlZJQ0VTLnBvbGx5IC0gVGhlIFBvbGx5IHNlcnZpY2UgdGhhdCBpcyB1c2VkXG4gKiB0byBzeW50aGVzaXplIHNwZWVjaG1hcmtzLiBXaWxsIGJlIHVuZGVmaW5lZCB1bnRpbCBbaW5pdGlhbGl6ZVNlcnZpY2Vde0BsaW5rIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZS5pbml0aWFsaXplU2VydmljZX1cbiAqIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBleGVjdXRlZFxuICogQHByb3BlcnR5IHtleHRlcm5hbDpQcmVzaWduZXJ9IFNFUlZJQ0VTLnByZXNpZ25lciAtIFRoZSBQb2xseSBQcmVzaWduZXJcbiAqIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gc3ludGhlc2l6ZSBzcGVlY2ggYXVkaW8uIFdpbGwgYmUgdW5kZWZpbmVkIHVudGlsXG4gKiBbaW5pdGlhbGl6ZVNlcnZpY2Vde0BsaW5rIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZS5pbml0aWFsaXplU2VydmljZX1cbiAqIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBleGVjdXRlZC5cbiAqL1xuY2xhc3MgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlIGV4dGVuZHMgQWJzdHJhY3RIb3N0RmVhdHVyZSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtIHtjb3JlL0hvc3RPYmplY3R9IGhvc3QgLSBIb3N0IG9iamVjdCBtYW5hZ2luZyB0aGUgZmVhdHVyZS5cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIC0gT3B0aW9ucyB0aGF0IHdpbGwgYmUgc2VudCB0byBQb2xseSBmb3IgZWFjaCBzcGVlY2guXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0aW9ucy52b2ljZSAtIFRoZSBuYW1lIG9mIHRoZSBQb2xseSB2b2ljZSB0byB1c2UgZm9yIGFsbCBzcGVlY2guXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0aW9ucy5lbmdpbmUgLSBUaGUgbmFtZSBvZiB0aGUgUG9sbHkgZW5naW5lIHRvIHVzZSBmb3IgYWxsIHNwZWVjaC5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRpb25zLmxhbmd1YWdlIC0gVGhlIG5hbWUgb2YgdGhlIGxhbmd1YWdlIHRvIHVzZSBmb3IgYWxsIHNwZWVjaC5cbiAgICogQHBhcmFtIHthdWRpb0Zvcm1hdH0gW29wdGlvbnMuYXVkaW9Gb3JtYXQ9J21wMyddIC0gVGhlIGZvcm1hdCB0byB1c2UgZm9yIGdlbmVyYXRlZFxuICAgKiBhdWRpbyBmb3IgYWxsIHNwZWVjaGVzLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdGlvbnMuc2FtcGxlUmF0ZSAtIFRoZSBzYW1wbGUgcmF0ZSBmb3IgYXVkaW8gZmlsZXMgZm9yIGFsbFxuICAgKiBzcGVlY2hlcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnNwZWVjaG1hcmtPZmZzZXQ9MF0gLSBBbW91bnQgb2YgdGltZSBpbiBzZWNvbmRzIHRvXG4gICAqIG9mZnNldCBzcGVlY2htYXJrIGV2ZW50IGVtaXNzaW9uIGZyb20gdGhlIGF1ZGlvLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWluRW5kTWFya0R1cmF0aW9uPS4wNV0gLSBUaGUgbWluaW11bSBhbW91bnQgb2YgdGltZVxuICAgKiBpbiBzZWNvbmRzIHRoYXQgdGhlIGxhc3Qgc3BlZWNobWFyayBvZiBlYWNoIHR5cGUgaW4gYSBzcGVlY2ggY2FuIGhhdmUgaXRzXG4gICAqIGR1cmF0aW9uIHByb3BlcnR5IHNldCB0by5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnZvbHVtZT0xXSAtIFRoZSBkZWZhdWx0IHZvbHVtZSB0byBwbGF5IHNwZWVjaCBhdWRpb1xuICAgKiB3aXRoLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmlzR2xvYmFsPWZhbHNlXSAtIFdoZXRoZXIgdGhlIGF1ZGlvIHNvdXJjZSBzaG91bGQgZGVmYXVsdFxuICAgKiB0byBnbG9iYWwgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIG9yIG5vdCBpdCBpcyBhdHRhY2hlZCB0byBhbiBvYmplY3QuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBob3N0LFxuICAgIG9wdGlvbnMgPSB7XG4gICAgICB2b2ljZTogdW5kZWZpbmVkLFxuICAgICAgZW5naW5lOiB1bmRlZmluZWQsXG4gICAgICBsYW5ndWFnZTogdW5kZWZpbmVkLFxuICAgICAgYXVkaW9Gb3JtYXQ6ICdtcDMnLFxuICAgICAgc2FtcGxlUmF0ZTogdW5kZWZpbmVkLFxuICAgICAgc3BlZWNobWFya09mZnNldDogMCxcbiAgICAgIG1pbkVuZE1hcmtEdXJhdGlvbjogMC4wNSxcbiAgICAgIHZvbHVtZTogMSxcbiAgICAgIGlzR2xvYmFsOiBmYWxzZSxcbiAgICB9XG4gICkge1xuICAgIHN1cGVyKGhvc3QpO1xuXG4gICAgdGhpcy5fc3BlZWNoQ2FjaGUgPSB7fTtcbiAgICB0aGlzLl9jdXJyZW50U3BlZWNoID0gbnVsbDtcbiAgICB0aGlzLl9jdXJyZW50UHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5faXNWYWxpZGF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnNwZWVjaG1hcmtPZmZzZXQgPSBOdW1iZXIuaXNOYU4oTnVtYmVyKG9wdGlvbnMuc3BlZWNobWFya09mZnNldCkpXG4gICAgICA/IDBcbiAgICAgIDogTnVtYmVyKG9wdGlvbnMuc3BlZWNobWFya09mZnNldCk7XG4gICAgdGhpcy5taW5FbmRNYXJrRHVyYXRpb24gPSBOdW1iZXIuaXNOYU4oTnVtYmVyKG9wdGlvbnMubWluRW5kTWFya0R1cmF0aW9uKSlcbiAgICAgID8gMFxuICAgICAgOiBOdW1iZXIob3B0aW9ucy5taW5FbmRNYXJrRHVyYXRpb24pO1xuICAgIHRoaXMudm9sdW1lID0gTnVtYmVyLmlzTmFOKE51bWJlcihvcHRpb25zLnZvbHVtZSkpXG4gICAgICA/IDFcbiAgICAgIDogTnVtYmVyKG9wdGlvbnMudm9sdW1lKTtcbiAgICB0aGlzLl9pc0dsb2JhbCA9IG9wdGlvbnMuaXNHbG9iYWwgfHwgZmFsc2U7XG4gICAgdGhpcy5fcHJvbWlzZXMgPSB7XG4gICAgICB2b2x1bWU6IERlZmVycmVkLnJlc29sdmUoKSxcbiAgICB9O1xuICAgIHRoaXMuX3ZvbHVtZVBhdXNlZCA9IGZhbHNlO1xuXG4gICAgLy8gU2V0IGRlZmF1bHQgb3B0aW9ucyBmb3IgZWFjaCBzcGVlY2hcbiAgICB0aGlzLl92b2ljZSA9IG9wdGlvbnMudm9pY2UgfHwgdGhpcy5jb25zdHJ1Y3Rvci5QT0xMWV9ERUZBVUxUUy5Wb2ljZUlkO1xuICAgIHRoaXMuX2xhbmd1YWdlID1cbiAgICAgIG9wdGlvbnMubGFuZ3VhZ2UgfHwgdGhpcy5jb25zdHJ1Y3Rvci5QT0xMWV9ERUZBVUxUUy5MYW5ndWFnZU5hbWU7XG4gICAgdGhpcy5fZW5naW5lID0gZW5naW5lcy5pbmNsdWRlcyhvcHRpb25zLmVuZ2luZSlcbiAgICAgID8gb3B0aW9ucy5lbmdpbmVcbiAgICAgIDogdGhpcy5jb25zdHJ1Y3Rvci5QT0xMWV9ERUZBVUxUUy5FbmdpbmU7XG4gICAgdGhpcy5fYXVkaW9Gb3JtYXQgPSBhdWRpb0Zvcm1hdHMuaW5jbHVkZXMob3B0aW9ucy5hdWRpb0Zvcm1hdClcbiAgICAgID8gb3B0aW9ucy5hdWRpb0Zvcm1hdFxuICAgICAgOiB0aGlzLmNvbnN0cnVjdG9yLlBPTExZX0RFRkFVTFRTLk91dHB1dEZvcm1hdDtcbiAgICB0aGlzLl9zYW1wbGVSYXRlID0gc2FtcGxlUmF0ZXNbdGhpcy5fYXVkaW9Gb3JtYXRdLnJhdGVzLmluY2x1ZGVzKFxuICAgICAgb3B0aW9ucy5zYW1wbGVSYXRlXG4gICAgKVxuICAgICAgPyBvcHRpb25zLnNhbXBsZVJhdGVcbiAgICAgIDogdGhpcy5jb25zdHJ1Y3Rvci5QT0xMWV9ERUZBVUxUUy5TYW1wbGVSYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlIFBvbGx5LCBQcmVzaWduZXIgYW5kIEFXUyBTREsgVmVyc2lvbiBmb3IgdXNlIGFjcm9zcyBhbGwgaW5zdGFuY2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge2V4dGVybmFsOlBvbGx5fSBwb2xseSAtIFBvbGx5IGluc3RhbmNlIHRvIHVzZSB0byBnZW5lcmF0ZSBzcGVlY2htYXJrcy5cbiAgICogQHBhcmFtIHtleHRlcm5hbDpQcmVzaWduZXJ9IHByZXNpZ25lciAtIFByZXNpZ25lciBpbnN0YW5jZSB0byB1c2UgdG8gZ2VuZXJhdGVcbiAgICogYXVkaW8gVVJMcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHZlcnNpb24gLSBWZXJzaW9uIG9mIHRoZSBBV1MgU0RLIHRvIHVzZSB0byB2YWxpZGF0ZSB2b2ljZSBvcHRpb25zLlxuICAgKi9cbiAgc3RhdGljIGluaXRpYWxpemVTZXJ2aWNlKHBvbGx5LCBwcmVzaWduZXIsIHZlcnNpb24pIHtcbiAgICAvLyBNYWtlIHN1cmUgYWxsIHdlcmUgZGVmaW5lZFxuICAgIGlmIChcbiAgICAgIHBvbGx5ID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHByZXNpZ25lciA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB2ZXJzaW9uID09PSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCBpbml0aWFsaXplIFRleHRUb1NwZWVjaCBmZWF0dXJlLiBBbGwgYXJndW1lbnRzIG11c3QgYmUgZGVmaW5lZC4nXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEFkZCBzdW1lcmlhbiBob3N0cyB1c2VyLWFnZW50XG4gICAgaWYgKHBvbGx5LmNvbmZpZykge1xuICAgICAgcG9sbHkuY29uZmlnLmN1c3RvbVVzZXJBZ2VudCA9IHRoaXMuX3dpdGhDdXN0b21Vc2VyQWdlbnQoXG4gICAgICAgIHBvbGx5LmNvbmZpZy5jdXN0b21Vc2VyQWdlbnRcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChwcmVzaWduZXIuc2VydmljZSAmJiBwcmVzaWduZXIuc2VydmljZS5jb25maWcpIHtcbiAgICAgIHByZXNpZ25lci5zZXJ2aWNlLmNvbmZpZy5jdXN0b21Vc2VyQWdlbnQgPSB0aGlzLl93aXRoQ3VzdG9tVXNlckFnZW50KFxuICAgICAgICBwcmVzaWduZXIuc2VydmljZS5jb25maWcuY3VzdG9tVXNlckFnZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuX2lzUmVhZHkgPSBmYWxzZTtcblxuICAgIC8vIFN0b3JlIHBhcmFtZXRlcnNcbiAgICB0aGlzLlNFUlZJQ0VTLnBvbGx5ID0gcG9sbHk7XG4gICAgdGhpcy5TRVJWSUNFUy5wcmVzaWduZXIgPSBwcmVzaWduZXI7XG4gICAgYXdzVmVyc2lvbiA9IHZlcnNpb247XG5cbiAgICAvLyBDbGVhciB0aGUgY3VycmVudCBwb2xseSBvYmplY3RzXG4gICAgY29uc3QgYXZhaWxhYmxlVm9pY2VzID0gdGhpcy5QT0xMWV9WT0lDRVM7XG4gICAgYXZhaWxhYmxlVm9pY2VzLmxlbmd0aCA9IDA7XG5cbiAgICBjb25zdCBhdmFpbGFibGVMYW5ndWFnZXMgPSB0aGlzLlBPTExZX0xBTkdVQUdFUztcbiAgICBPYmplY3Qua2V5cyhhdmFpbGFibGVMYW5ndWFnZXMpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICBkZWxldGUgYXZhaWxhYmxlTGFuZ3VhZ2VzW25hbWVdO1xuICAgIH0pO1xuXG4gICAgY29uc3QgYXZhaWxhYmxlTGFuZ3VhZ2VDb2RlcyA9IHRoaXMuUE9MTFlfTEFOR1VBR0VfQ09ERVM7XG4gICAgT2JqZWN0LmtleXMoYXZhaWxhYmxlTGFuZ3VhZ2VDb2RlcykuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgIGRlbGV0ZSBhdmFpbGFibGVMYW5ndWFnZUNvZGVzW25hbWVdO1xuICAgIH0pO1xuXG4gICAgLy8gUmUtcG9wdWxhdGUgYWNjb3JkaW5nIHRvIHZlcnNpb25cbiAgICBjb25zdCBtaW5OZXVyYWxTZGsgPSB0aGlzLlBPTExZX01JTl9ORVVSQUxfVkVSU0lPTjtcblxuICAgIHJldHVybiB0aGlzLlNFUlZJQ0VTLnBvbGx5XG4gICAgICAuZGVzY3JpYmVWb2ljZXMoKVxuICAgICAgLnByb21pc2UoKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICBjb25zdCBhbGxDb2RlcyA9IHt9O1xuXG4gICAgICAgIHJlc3BvbnNlLlZvaWNlcy5mb3JFYWNoKHZvaWNlID0+IHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB2b2ljZS5TdXBwb3J0ZWRFbmdpbmVzLmluY2x1ZGVzKCdzdGFuZGFyZCcpIHx8XG4gICAgICAgICAgICB2ZXJzaW9uID49IG1pbk5ldXJhbFNka1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgYXZhaWxhYmxlVm9pY2VzLnB1c2godm9pY2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGF2YWlsYWJsZVZvaWNlcy5mb3JFYWNoKHZvaWNlID0+IHtcbiAgICAgICAgICAgIGF2YWlsYWJsZUxhbmd1YWdlc1t2b2ljZS5MYW5ndWFnZU5hbWVdID0gdm9pY2UuTGFuZ3VhZ2VDb2RlO1xuICAgICAgICAgICAgYWxsQ29kZXNbdm9pY2UuTGFuZ3VhZ2VDb2RlXSA9IHZvaWNlLkxhbmd1YWdlTmFtZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgT2JqZWN0LmVudHJpZXMoYXZhaWxhYmxlTGFuZ3VhZ2VzKS5mb3JFYWNoKChbbmFtZSwgY29kZV0pID0+IHtcbiAgICAgICAgICBhdmFpbGFibGVMYW5ndWFnZUNvZGVzW2NvZGVdID0gbmFtZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gTm90aWZ5IHRoYXQgd2UncmUgcmVhZHkgdG8gZ2VuZXJhdGUgc3BlZWNoZXNcbiAgICAgICAgdGhpcy5faXNSZWFkeSA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdCh0aGlzLkVWRU5UUy5yZWFkeSk7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdGhlIGNsYXNzIGlzIGNhcGFibGUgb2YgZ2VuZXJhdGluZyBzcGVlY2ggYXVkaW8uIFBvbGx5LFxuICAgKiBQcmVzaWduZXIgYW5kIEFXUyBTREsgdmVyc2lvbiBudW1iZXIgbXVzdCBoYXZlIGJlZW4gZGVmaW5lZCB1c2luZ1xuICAgKiBbaW5pdGlhbGl6ZVNlcnZpY2Vde0BsaW5rIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZS5pbml0aWFsaXplU2VydmljZX0uXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBnZXQgaXNSZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNSZWFkeTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB0ZXh0IG9mIHRoZSBjdXJyZW50bHkgcGxheWluZyBzcGVlY2guXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGN1cnJlbnRTcGVlY2goKSB7XG4gICAgaWYgKHRoaXMuX2N1cnJlbnRTcGVlY2gpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50U3BlZWNoLnRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuZCBzZXRzIHRoZSBudW1iZXIgb2Ygc2Vjb25kcyB0byBvZmZzZXQgc3BlZWNobWFyayBlbWlzc2lvbi5cbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBzcGVlY2htYXJrT2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9zcGVlY2htYXJrT2Zmc2V0O1xuICB9XG5cbiAgc2V0IHNwZWVjaG1hcmtPZmZzZXQob2Zmc2V0KSB7XG4gICAgdGhpcy5fc3BlZWNobWFya09mZnNldCA9IG9mZnNldDtcblxuICAgIGlmICh0aGlzLl9jdXJyZW50U3BlZWNoKSB7XG4gICAgICB0aGlzLl9jdXJyZW50U3BlZWNoLnNwZWVjaG1hcmtPZmZzZXQgPSBvZmZzZXQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW5kIHNldHMgdGhlIFRoZSBtaW5pbXVtIGFtb3VudCBvZiB0aW1lIGluIHNlY29uZHMgdGhhdCB0aGUgbGFzdFxuICAgKiBzcGVlY2htYXJrIG9mIGVhY2ggdHlwZSBpbiBhIHNwZWVjaCBjYW4gaGF2ZSBpdHMgZHVyYXRpb24gcHJvcGVydHkgc2V0IHRvLlxuICAgKlxuICAgKiBAdHlwZSBudW1iZXJcbiAgICovXG4gIGdldCBtaW5FbmRNYXJrRHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21pbkVuZE1hcmtEdXJhdGlvbiAvIDEwMDA7XG4gIH1cblxuICBzZXQgbWluRW5kTWFya0R1cmF0aW9uKGR1cmF0aW9uKSB7XG4gICAgdGhpcy5fbWluRW5kTWFya0R1cmF0aW9uID0gZHVyYXRpb24gKiAxMDAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZHMgdGhlIFN1bWVyaWFuIEhvc3RzIGN1c3RvbSB1c2VyLWFnZW50IHRvIGEgc3RyaW5nIGlmIGl0IGlzIG5vdFxuICAgKiBhbHJlYWR5IHByZXNlbnQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjdXJyZW50VXNlckFnZW50IC0gU3RyaW5nIHRvIGFwcGVuZCB0byBpZiBuZWVkZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgX3dpdGhDdXN0b21Vc2VyQWdlbnQoY3VycmVudFVzZXJBZ2VudCkge1xuICAgIGNvbnN0IHN1bWVyaWFuSG9zdHNVc2VyQWdlbnQgPSAncmVxdWVzdC1zb3VyY2UvU3VtZXJpYW5Ib3N0cyc7XG5cbiAgICBpZiAoY3VycmVudFVzZXJBZ2VudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gc3VtZXJpYW5Ib3N0c1VzZXJBZ2VudDtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudFVzZXJBZ2VudC5pbmRleE9mKHN1bWVyaWFuSG9zdHNVc2VyQWdlbnQpICE9PSAtMSkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRVc2VyQWdlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnRVc2VyQWdlbnQuY29uY2F0KCcgJywgc3VtZXJpYW5Ib3N0c1VzZXJBZ2VudCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgZ2l2ZW4gZW5naW5lIHR5cGUgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBBV1MgU0RLIHZlcnNpb24uIElmIGl0XG4gICAqIGlzLCByZXR1cm4gdGhlIG9yaWdpbmFsIHZhbHVlLiBPdGhlcndpc2UgcmV0dXJuIGEgZGVmYXVsdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVuZ2luZSAtIFRoZSB0eXBlIG9mIFBvbGx5IHZvaWNlIGVuZ2luZSB0byB2YWxpZGF0ZS5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIF92YWxpZGF0ZUVuZ2luZShlbmdpbmUpIHtcbiAgICAvLyBEZWZhdWx0IHRvIHRoZSBzdGFuZGFyZCBlbmdpbmUgaWYgbmV1cmFsIGlzIG5vdCBhdmFpbGFibGUgZm9yIHRoaXMgdmVyc2lvblxuICAgIGlmIChcbiAgICAgIGVuZ2luZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLkFXU19WRVJTSU9OIDwgdGhpcy5jb25zdHJ1Y3Rvci5QT0xMWV9NSU5fTkVVUkFMX1ZFUlNJT05cbiAgICApIHtcbiAgICAgIGVuZ2luZSA9IHRoaXMuY29uc3RydWN0b3IuUE9MTFlfREVGQVVMVFMuRW5naW5lO1xuICAgIH1cblxuICAgIHJldHVybiBlbmdpbmU7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgZ2l2ZW4gYXVkaW8gZm9ybWF0IHR5cGUgaXMgY29tcGF0aWJsZSB3aXRoIFBvbGx5LiBJZiBpdCBpcywgcmV0dXJuXG4gICAqIHRoZSBvcmlnaW5hbCB2YWx1ZS4gT3RoZXJ3aXNlIHJldHVybiBhIGRlZmF1bHQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbmdpbmUgLSBUaGUgdHlwZSBvZiBQb2xseSB2b2ljZSBlbmdpbmUgdG8gdmFsaWRhdGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBfdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkIHx8ICFhdWRpb0Zvcm1hdHMuaW5jbHVkZXMoZm9ybWF0KSkge1xuICAgICAgZm9ybWF0ID0gdGhpcy5jb25zdHJ1Y3Rvci5QT0xMWV9ERUZBVUxUUy5PdXRwdXRGb3JtYXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvcm1hdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBnaXZlbiBhdWRpbyBzYW1wbGluZyByYXRlIGlzIGNvbXBhdGlibGUgd2l0aCB0aGUgY3VycmVudCBhdWRpb1xuICAgKiBmb3JtYXQuIElmIGl0IGlzLCByZXR1cm4gdGhlIG9yaWdpbmFsIHZhbHVlLiBPdGhlcndpc2UgcmV0dXJuIGEgZGVmYXVsdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVuZ2luZSAtIFRoZSB0eXBlIG9mIFBvbGx5IHZvaWNlIGVuZ2luZSB0byB2YWxpZGF0ZS5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIF92YWxpZGF0ZVJhdGUocmF0ZSkge1xuICAgIC8vIFVzZSBkZWZhdWx0IGlmIHNwZWNpZmllZCBzYW1wbGUgcmF0ZSBpcyBub3QgdmFsaWQgZm9yIHRoZSBhdWRpbyBmb3JtYXRcbiAgICBpZiAoXG4gICAgICByYXRlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICFzYW1wbGVSYXRlc1t0aGlzLl9hdWRpb0Zvcm1hdF0ucmF0ZXMuaW5jbHVkZXMocmF0ZSlcbiAgICApIHtcbiAgICAgIHJhdGUgPSBzYW1wbGVSYXRlc1t0aGlzLl9hdWRpb0Zvcm1hdF0uZGVmYXVsdHNbdGhpcy5fZW5naW5lXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBnaXZlbiBQb2xseSB2b2ljZSBpZCBpcyBjb21wYXRpYmxlIHdpdGggdGhlIGN1cnJlbnQgUG9sbHkgZW5naW5lLlxuICAgKiBJZiBpdCBpcywgcmV0dXJuIHRoZSBvcmlnaW5hbCB2YWx1ZS4gT3RoZXJ3aXNlIHJldHVybiBhIGRlZmF1bHQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbmdpbmUgLSBUaGUgdHlwZSBvZiBQb2xseSB2b2ljZSBlbmdpbmUgdG8gdmFsaWRhdGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBfdmFsaWRhdGVWb2ljZSh2b2ljZUlkKSB7XG4gICAgY29uc3Qgdm9pY2UgPSB0aGlzLmNvbnN0cnVjdG9yLlBPTExZX1ZPSUNFUy5maW5kKHYgPT4gdi5JZCA9PT0gdm9pY2VJZCk7XG5cbiAgICAvLyBVc2UgdGhlIGRlZmF1bHQgdm9pY2UgaWYgdGhlIHZvaWNlIGlzbid0IHN1cHBvcnRlZCBieSB0aGUgZW5naW5lXG4gICAgaWYgKHZvaWNlID09PSB1bmRlZmluZWQgfHwgIXZvaWNlLlN1cHBvcnRlZEVuZ2luZXMuaW5jbHVkZXModGhpcy5fZW5naW5lKSkge1xuICAgICAgdm9pY2VJZCA9IHRoaXMuY29uc3RydWN0b3IuUE9MTFlfREVGQVVMVFMuVm9pY2VJZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdm9pY2VJZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBnaXZlbiBQb2xseSBsYW5ndWFnZSBpcyBjb21wYXRpYmxlIHdpdGggdGhlIGN1cnJlbnQgUG9sbHkgdm9pY2UuXG4gICAqIElmIGl0IGlzLCByZXR1cm4gdGhlIG9yaWdpbmFsIHZhbHVlLiBPdGhlcndpc2UgcmV0dXJuIGEgZGVmYXVsdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVuZ2luZSAtIFRoZSB0eXBlIG9mIFBvbGx5IHZvaWNlIGVuZ2luZSB0byB2YWxpZGF0ZS5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIF92YWxpZGF0ZUxhbmd1YWdlKGxhbmd1YWdlKSB7XG4gICAgY29uc3Qgdm9pY2UgPSB0aGlzLmNvbnN0cnVjdG9yLlBPTExZX1ZPSUNFUy5maW5kKHYgPT4gdi5JZCA9PT0gdGhpcy5fdm9pY2UpO1xuICAgIGNvbnN0IGxhbmd1YWdlQ29kZSA9IHRoaXMuY29uc3RydWN0b3IuUE9MTFlfTEFOR1VBR0VTW2xhbmd1YWdlXTtcblxuICAgIC8vIEZpbmQgdGhlIGxhbmd1YWdlcyBhdmFpbGFibGUgZm9yIHRoZSBjdXJyZW50IHZvaWNlXG4gICAgY29uc3QgYXZhaWxhYmxlQ29kZXMgPSBbdm9pY2UuTGFuZ3VhZ2VDb2RlXTtcbiAgICBpZiAodm9pY2UuQWRkaXRpb25hbExhbmd1YWdlQ29kZXMpIHtcbiAgICAgIGF2YWlsYWJsZUNvZGVzLnB1c2goLi4udm9pY2UuQWRkaXRpb25hbExhbmd1YWdlQ29kZXMpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBjdXJyZW50IHZvaWNlIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgbGFuZ3VhZ2UsIHVzZSBpdHMgZGVmYXVsdFxuICAgIGlmICghYXZhaWxhYmxlQ29kZXMuaW5jbHVkZXMobGFuZ3VhZ2VDb2RlKSkge1xuICAgICAgbGFuZ3VhZ2UgPSB0aGlzLmNvbnN0cnVjdG9yLlBPTExZX0xBTkdVQUdFX0NPREVTW3ZvaWNlLkxhbmd1YWdlQ29kZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhbmd1YWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIHRoZSBjdXJyZW50IFBvbGx5IG9wdGlvbnMgdG8gbWFrZSBzdXJlIHRoZXkgYXJlIGNvbXBhdGlibGUgd2l0aCBlYWNoXG4gICAqIG90aGVyLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3ZhbGlkYXRlKCkge1xuICAgIC8vIFZhbGlkYXRlIHNwZWVjaCBwYXJhbWV0ZXJzXG4gICAgdGhpcy5fZW5naW5lID0gdGhpcy5fdmFsaWRhdGVFbmdpbmUodGhpcy5fZW5naW5lKTtcbiAgICB0aGlzLl9hdWRpb0Zvcm1hdCA9IHRoaXMuX3ZhbGlkYXRlRm9ybWF0KHRoaXMuX2F1ZGlvRm9ybWF0KTtcbiAgICB0aGlzLl9zYW1wbGVSYXRlID0gdGhpcy5fdmFsaWRhdGVSYXRlKHRoaXMuX3NhbXBsZVJhdGUpO1xuICAgIHRoaXMuX3ZvaWNlID0gdGhpcy5fdmFsaWRhdGVWb2ljZSh0aGlzLl92b2ljZSk7XG4gICAgdGhpcy5fbGFuZ3VhZ2UgPSB0aGlzLl92YWxpZGF0ZUxhbmd1YWdlKHRoaXMuX2xhbmd1YWdlKTtcbiAgICB0aGlzLl9pc1ZhbGlkYXRlZCA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIG9iamVjdCBjb250YWluaW5nIHBhcmFtZXRlcnMgY29tcGF0aWJsZSB3aXRoIFBvbGx5LnN5bnRoZXNpemVTcGVlY2guXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqL1xuICBfZ2V0Q29uZmlnKCkge1xuICAgIC8vIE1ha2Ugc3VyZSBwYXJhbWV0ZXJzIGhhdmUgYmVlbiB2YWxpZGF0ZWRcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5pc1JlYWR5ICYmICF0aGlzLl9pc1ZhbGlkYXRlZCkge1xuICAgICAgdGhpcy5fdmFsaWRhdGUoKTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYSBjb25maWcgb2JqZWN0IGNvbXBhdGlibGUgd2l0aCBQb2xseVxuICAgIHJldHVybiB7XG4gICAgICBFbmdpbmU6IHRoaXMuX2VuZ2luZSxcbiAgICAgIE91dHB1dEZvcm1hdDogdGhpcy5fYXVkaW9Gb3JtYXQsXG4gICAgICBTYW1wbGVSYXRlOiB0aGlzLl9zYW1wbGVSYXRlLFxuICAgICAgVm9pY2VJZDogdGhpcy5fdm9pY2UsXG4gICAgICBMYW5ndWFnZUNvZGU6IHRoaXMuY29uc3RydWN0b3IuUE9MTFlfTEFOR1VBR0VTW3RoaXMuX2xhbmd1YWdlXSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBQb2xseSBwYXJhbWV0ZXJzIHdpdGggb3B0aW9ucyBmcm9tIGEgZ2l2ZW4gY29uZmlnLiBBbGwgc3RvcmVkIHNwZWVjaGVzXG4gICAqIHdpbGwgYmUgdXBkYXRlZCB0byB1c2UgdGhlIG5ldyBwYXJhbWV0ZXJzLCB1bmxlc3MgdGhlIHNwZWVjaCB0ZXh0IGlzIGNvbnRhaW5lZFxuICAgKiBpbiB0aGUgJ3NraXBTcGVlY2hlcycgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIC0gUG9sbHkgcGFyYW1ldGVyIG9wdGlvbnMgdG8gb3ZlcndyaXRlLlxuICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBza2lwU3BlZWNoZXMgLSBUZXh0IG9mIGFueSBzcGVlY2hlcyB0aGF0IHNob3VsZCBub3RcbiAgICogaGF2ZSBwYXJhbWV0ZXJzIHVwZGF0ZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqL1xuICBfdXBkYXRlQ29uZmlnKGNvbmZpZywgc2tpcFNwZWVjaGVzID0gW10pIHtcbiAgICBjb25zdCBjdXJyZW50Q29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKCk7XG4gICAgaWYgKCFjb25maWcpIHtcbiAgICAgIHJldHVybiBjdXJyZW50Q29uZmlnO1xuICAgIH1cblxuICAgIHRoaXMuX2lzVmFsaWRhdGVkID0gZmFsc2U7XG4gICAgY29uc3QgY3VycmVudENvbmZpZ1N0ciA9IEpTT04uc3RyaW5naWZ5KGN1cnJlbnRDb25maWcpO1xuXG4gICAgLy8gVXBkYXRlIG9wdGlvbnNcbiAgICBpZiAoY29uZmlnLkVuZ2luZSkge1xuICAgICAgdGhpcy5fZW5naW5lID0gY29uZmlnLkVuZ2luZTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmF1ZGlvRm9ybWF0KSB7XG4gICAgICB0aGlzLl9hdWRpb0Zvcm1hdCA9IGNvbmZpZy5hdWRpb0Zvcm1hdDtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLlNhbXBsZVJhdGUpIHtcbiAgICAgIHRoaXMuX3NhbXBsZVJhdGUgPSBjb25maWcuU2FtcGxlUmF0ZTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLlZvaWNlSWQpIHtcbiAgICAgIHRoaXMuX3ZvaWNlID0gY29uZmlnLlZvaWNlSWQ7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5MYW5ndWFnZSkge1xuICAgICAgdGhpcy5fbGFuZ3VhZ2UgPSBjb25maWcuTGFuZ3VhZ2U7XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgdGhlIGNvbmZpZ1xuICAgIGNvbnN0IHZhbGlkQ29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKCk7XG5cbiAgICAvLyBFeGl0IGlmIG5vdGhpbmcgaGFzIGNoYW5nZWRcbiAgICBjb25zdCBjb25maWdTdHIgPSBKU09OLnN0cmluZ2lmeSh2YWxpZENvbmZpZyk7XG4gICAgaWYgKGN1cnJlbnRDb25maWdTdHIgPT09IGNvbmZpZ1N0cikge1xuICAgICAgdGhpcy5faXNWYWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHZhbGlkQ29uZmlnO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBhbGwgY2FjaGVkIGNvbmZpZ3NcbiAgICBPYmplY3QuZW50cmllcyh0aGlzLl9zcGVlY2hDYWNoZSkuZm9yRWFjaCgoW3RleHQsIHNwZWVjaF0pID0+IHtcbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBza2lwcGVkIHNwZWVjaFxuICAgICAgaWYgKHNraXBTcGVlY2hlcy5pbmNsdWRlcyh0ZXh0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNwZWVjaENvbmZpZ1N0ciA9IEpTT04uc3RyaW5naWZ5KHNwZWVjaC5jb25maWcpO1xuXG4gICAgICAvLyBVcGRhdGUgdGhlIHNwZWVjaCB3aXRoIG5ldyBwYXJhbWV0ZXJzXG4gICAgICBpZiAoc3BlZWNoQ29uZmlnU3RyICE9PSBjb25maWdTdHIpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlU3BlZWNoKHRleHQsIHZhbGlkQ29uZmlnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB2YWxpZENvbmZpZztcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgYW4gZXhpc3Rpbmcgc3BlZWNoLCBvciBhZGQgYSBuZXcgc3BlZWNoIHdpdGggbmV3IFBvbGx5IHBhcmFtZXRlcnMgd2l0aFxuICAgKiBvcHRpb25zIGZyb20gYSBnaXZlbiBjb25maWcuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgb2YgdGhlIHNwZWVjaCB0byB1cGRhdGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgLSBQb2xseSBwYXJhbWV0ZXIgb3B0aW9ucyB0byB1cGRhdGUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlPWZhbHNlXSAtIFdoZXRoZXIgdG8gZm9yY2UgdGhlIHNwZWVjaCB0byBiZSB1cGRhdGVkXG4gICAqIGlmIG5vIHBhcmFtZXRlcnMgaGF2ZSBjaGFuZ2VzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7QWJzdHJhY3RTcGVlY2h9XG4gICAqL1xuICBfdXBkYXRlU3BlZWNoKHRleHQsIGNvbmZpZywgZm9yY2UgPSBmYWxzZSkge1xuICAgIGNvbnN0IHNwZWVjaCA9IHRoaXMuX3NwZWVjaENhY2hlW3RleHRdIHx8IHt9O1xuICAgIC8vIEV4aXQgaWYgbm90aGluZyBoYXMgY2hhbmdlZCBhbmQgZm9yY2UgaXMgZmFsc2VcbiAgICBpZiAoXG4gICAgICAhZm9yY2UgJiZcbiAgICAgIGNvbmZpZyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBzcGVlY2guY29uZmlnICYmXG4gICAgICBKU09OLnN0cmluZ2lmeShjb25maWcpID09PSBKU09OLnN0cmluZ2lmeShzcGVlY2guY29uZmlnKVxuICAgICkge1xuICAgICAgcmV0dXJuIHNwZWVjaDtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgc2VwYXJhdGUgcGFyYW1ldGVycyBmb3IgYXVkaW8gYW5kIHNwZWVjaG1hcmsgZ2VuZXJhdGlvblxuICAgIGNvbnN0IGF1ZGlvUGFyYW1zID0ge1xuICAgICAgLi4uY29uZmlnLFxuICAgICAgVGV4dDogdGV4dCxcbiAgICAgIFRleHRUeXBlOiAnc3NtbCcsXG4gICAgfTtcbiAgICBjb25zdCBzcGVlY2htYXJrUGFyYW1zID0ge1xuICAgICAgLi4uYXVkaW9QYXJhbXMsXG4gICAgICBPdXRwdXRGb3JtYXQ6ICdqc29uJyxcbiAgICAgIFNwZWVjaE1hcmtUeXBlczogc3BlZWNobWFya1R5cGVzLFxuICAgIH07XG5cbiAgICAvLyBHZW5lcmF0ZSBhdWRpbyBhbmQgc3BlZWNobWFya3NcbiAgICBzcGVlY2guY29uZmlnID0gY29uZmlnO1xuICAgIHNwZWVjaC5wcm9taXNlID0gUHJvbWlzZS5hbGwoW1xuICAgICAgdGhpcy5fc3ludGhlc2l6ZVNwZWVjaG1hcmtzKHNwZWVjaG1hcmtQYXJhbXMpLFxuICAgICAgdGhpcy5fc3ludGhlc2l6ZUF1ZGlvKGF1ZGlvUGFyYW1zKSxcbiAgICBdKS50aGVuKHJlc3VsdHMgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZVNwZWVjaCh0ZXh0LCAuLi5yZXN1bHRzKTtcbiAgICB9KTtcbiAgICB0aGlzLl9zcGVlY2hDYWNoZVt0ZXh0XSA9IHNwZWVjaDtcblxuICAgIHJldHVybiBzcGVlY2g7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFNwZWVjaCBvYmplY3QgZm9yIHRoZSBzcGVha2VyLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUb1NwZWVjaH0gc3BlYWtlciAtIFRoZSBUZXh0VG9TcGVlY2ggaW5zdGFuY2UgdGhhdCB3aWxsIG93biB0aGUgc3BlZWNoLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIFRleHQgb2YgdGhlIHNwZWVjaC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHNwZWVjaG1hcmtzIC0gU3BlZWNobWFya3MgZm9yIHRoZSBzcGVlY2guXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhdWRpb0NvbmZpZyAtIEF1ZGlvIGZvciB0aGUgc3BlZWNoLlxuICAgKlxuICAgKiBAcmV0dXJucyB7QWJzdHJhY3RTcGVlY2h9XG4gICAqL1xuICBfY3JlYXRlU3BlZWNoKHRleHQsIHNwZWVjaG1hcmtzLCBhdWRpb0NvbmZpZykge1xuICAgIHJldHVybiBuZXcgU3BlZWNoKHRoaXMsIHRleHQsIHNwZWVjaG1hcmtzLCBhdWRpb0NvbmZpZyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHByZXNpZ25lZCBVUkwgb2Ygc3BlZWNoIGF1ZGlvIGZvciB0aGUgZ2l2ZW4gc3BlZWNoIHRleHQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBQYXJhbWV0ZXJzIG9iamVjdCBjb21wYXRpYmxlIHdpdGggUG9sbHkuc3ludGhlc2l6ZVNwZWVjaC5cbiAgICpcbiAgICogQHJldHVybnMge0RlZmVycmVkfSBSZXNvbHZlcyB3aXRoIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBhdWRpbyBVUkwuXG4gICAqL1xuICBfc3ludGhlc2l6ZUF1ZGlvKHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgRGVmZXJyZWQoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5TRVJWSUNFUy5wcmVzaWduZXIuZ2V0U3ludGhlc2l6ZVNwZWVjaFVybChcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBmdW5jdGlvbihlcnJvciwgdXJsKSB7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgcmVzb2x2ZSh7dXJsfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhbmQgcGFyc2VzIHNwZWVjaG1hcmtzIGZvciB0aGUgZ2l2ZW4gc3BlZWNoIHRleHQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBQYXJhbWV0ZXJzIG9iamVjdCBjb21wYXRpYmxlIHdpdGggUG9sbHkuc3ludGhlc2l6ZVNwZWVjaC5cbiAgICpcbiAgICogQHJldHVybnMge0RlZmVycmVkfSBSZXNvbHZlcyB3aXRoIGFuIGFycmF5IG9mIHNwZWVjaG1hcmsgb2JqZWN0c1xuICAgKi9cbiAgX3N5bnRoZXNpemVTcGVlY2htYXJrcyhwYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5TRVJWSUNFUy5wb2xseVxuICAgICAgLnN5bnRoZXNpemVTcGVlY2gocGFyYW1zKVxuICAgICAgLnByb21pc2UoKVxuICAgICAgLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgLy8gQ29udmVydCBjaGFyY29kZXMgdG8gc3RyaW5nXG4gICAgICAgIGNvbnN0IGpzb25TdHJpbmcgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQuQXVkaW9TdHJlYW0pO1xuICAgICAgICBjb25zdCBqc29uID0gSlNPTi5wYXJzZShqc29uU3RyaW5nKTtcbiAgICAgICAgY29uc3QgZGF0YVN0ciA9IGpzb24uZGF0YS5tYXAoYyA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKS5qb2luKCcnKTtcblxuICAgICAgICBjb25zdCBtYXJrVHlwZXMgPSB7XG4gICAgICAgICAgc2VudGVuY2U6IFtdLFxuICAgICAgICAgIHdvcmQ6IFtdLFxuICAgICAgICAgIHZpc2VtZTogW10sXG4gICAgICAgICAgc3NtbDogW10sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGVuZE1hcmtUeXBlcyA9IHtcbiAgICAgICAgICBzZW50ZW5jZTogbnVsbCxcbiAgICAgICAgICB3b3JkOiBudWxsLFxuICAgICAgICAgIHZpc2VtZTogbnVsbCxcbiAgICAgICAgICBzc21sOiBudWxsLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNwbGl0IGJ5IGVuY2xvc2luZyB7fSB0byBjcmVhdGUgc3BlZWNobWFyayBvYmplY3RzXG4gICAgICAgIGNvbnN0IHNwZWVjaE1hcmtzID0gWy4uLmRhdGFTdHIubWF0Y2hBbGwoL1xcey4qP1xcfSg/PVxcbnwkKS9nbSldLm1hcChcbiAgICAgICAgICBtYXRjaCA9PiB7XG4gICAgICAgICAgICBjb25zdCBtYXJrID0gSlNPTi5wYXJzZShtYXRjaFswXSk7XG5cbiAgICAgICAgICAgIC8vIFNldCB0aGUgZHVyYXRpb24gb2YgdGhlIGxhc3Qgc3BlZWNobWFyayBzdG9yZWQgbWF0Y2hpbmcgdGhpcyBvbmUncyB0eXBlXG4gICAgICAgICAgICBjb25zdCBudW1NYXJrcyA9IG1hcmtUeXBlc1ttYXJrLnR5cGVdLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChudW1NYXJrcyA+IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgbGFzdE1hcmsgPSBtYXJrVHlwZXNbbWFyay50eXBlXVtudW1NYXJrcyAtIDFdO1xuICAgICAgICAgICAgICBsYXN0TWFyay5kdXJhdGlvbiA9IG1hcmsudGltZSAtIGxhc3RNYXJrLnRpbWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1hcmtUeXBlc1ttYXJrLnR5cGVdLnB1c2gobWFyayk7XG4gICAgICAgICAgICBlbmRNYXJrVHlwZXNbbWFyay50eXBlXSA9IG1hcms7XG4gICAgICAgICAgICByZXR1cm4gbWFyaztcbiAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gRmluZCB0aGUgdGltZSBvZiB0aGUgbGF0ZXN0IHNwZWVjaG1hcmtcbiAgICAgICAgY29uc3QgZW5kVGltZXMgPSBbXTtcbiAgICAgICAgaWYgKGVuZE1hcmtUeXBlcy5zZW50ZW5jZSkge1xuICAgICAgICAgIGVuZFRpbWVzLnB1c2goZW5kTWFya1R5cGVzLnNlbnRlbmNlLnRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRNYXJrVHlwZXMud29yZCkge1xuICAgICAgICAgIGVuZFRpbWVzLnB1c2goZW5kTWFya1R5cGVzLndvcmQudGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZE1hcmtUeXBlcy52aXNlbWUpIHtcbiAgICAgICAgICBlbmRUaW1lcy5wdXNoKGVuZE1hcmtUeXBlcy52aXNlbWUudGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZE1hcmtUeXBlcy5zc21sKSB7XG4gICAgICAgICAgZW5kVGltZXMucHVzaChlbmRNYXJrVHlwZXMuc3NtbC50aW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmRUaW1lID0gTWF0aC5tYXgoLi4uZW5kVGltZXMpO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBkdXJhdGlvbiBmb3IgdGhlIGVuZGluZyBzcGVlY2hNYXJrcyBvZiBlYWNoIHR5cGVcbiAgICAgICAgaWYgKGVuZE1hcmtUeXBlcy5zZW50ZW5jZSkge1xuICAgICAgICAgIGVuZE1hcmtUeXBlcy5zZW50ZW5jZS5kdXJhdGlvbiA9IE1hdGgubWF4KFxuICAgICAgICAgICAgdGhpcy5fbWluRW5kTWFya0R1cmF0aW9uLFxuICAgICAgICAgICAgZW5kVGltZSAtIGVuZE1hcmtUeXBlcy5zZW50ZW5jZS50aW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kTWFya1R5cGVzLndvcmQpIHtcbiAgICAgICAgICBlbmRNYXJrVHlwZXMud29yZC5kdXJhdGlvbiA9IE1hdGgubWF4KFxuICAgICAgICAgICAgdGhpcy5fbWluRW5kTWFya0R1cmF0aW9uLFxuICAgICAgICAgICAgZW5kVGltZSAtIGVuZE1hcmtUeXBlcy53b3JkLnRpbWVcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRNYXJrVHlwZXMudmlzZW1lKSB7XG4gICAgICAgICAgZW5kTWFya1R5cGVzLnZpc2VtZS5kdXJhdGlvbiA9IE1hdGgubWF4KFxuICAgICAgICAgICAgdGhpcy5fbWluRW5kTWFya0R1cmF0aW9uLFxuICAgICAgICAgICAgZW5kVGltZSAtIGVuZE1hcmtUeXBlcy52aXNlbWUudGltZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZE1hcmtUeXBlcy5zc21sKSB7XG4gICAgICAgICAgZW5kTWFya1R5cGVzLnNzbWwuZHVyYXRpb24gPSBNYXRoLm1heChcbiAgICAgICAgICAgIHRoaXMuX21pbkVuZE1hcmtEdXJhdGlvbixcbiAgICAgICAgICAgIGVuZFRpbWUgLSBlbmRNYXJrVHlwZXMuc3NtbC50aW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzcGVlY2hNYXJrcztcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBTcGVlY2ggb2JqZWN0IHRoYXQgaGFzIHRoZSBnaXZlbiB0ZXh0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIFRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIFNwZWVjaC5cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBjb25maWcgLSBPcHRpb25zIHRvIHVwZGF0ZSB0aGUgU3BlZWNoIHdpdGguXG4gICAqXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH0gUmVzb2x2ZXMgd2l0aCBTcGVlY2ggb3IgbnVsbDtcbiAgICovXG4gIF9nZXRTcGVlY2godGV4dCwgY29uZmlnKSB7XG4gICAgLy8gTWFrZSBzdXJlIEFXUyBzZXJ2aWNlcyBleGlzdFxuICAgIGlmICghdGhpcy5jb25zdHJ1Y3Rvci5pc1JlYWR5KSB7XG4gICAgICBjb25zdCBlID0gJ0FXUyBzZXJ2aWNlcyBoYXZlIG5vdCBiZWVuIGluaXRpYWxpemVkLic7XG4gICAgICByZXR1cm4gRGVmZXJyZWQucmVqZWN0KGUpO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSBpdHMgcG9zc2libGUgdG8gZ2VuZXJhdGUgc3BlZWNoZXNcbiAgICBpZiAoIXRleHQpIHtcbiAgICAgIGNvbnN0IGUgPSAnQ2Fubm90IHBsYXkgYSBzcGVlY2ggd2l0aCBubyB0ZXh0Lic7XG4gICAgICByZXR1cm4gRGVmZXJyZWQucmVqZWN0KGUpO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB0aGUgc3BlZWNoIHdpdGggb3B0aW9uc1xuICAgIHRleHQgPSBUZXh0VG9TcGVlY2hVdGlscy52YWxpZGF0ZVRleHQodGV4dCk7XG4gICAgY29uZmlnID0gdGhpcy5fdXBkYXRlQ29uZmlnKGNvbmZpZywgdGV4dCk7XG5cbiAgICByZXR1cm4gdGhpcy5fdXBkYXRlU3BlZWNoKHRleHQsIGNvbmZpZykucHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgbmFtZXNwYWNlIHRvIHRoZSBob3N0IHdpdGggdGhlIG5hbWUgb2YgdGhlIGZlYXR1cmUgdG8gY29udGFpbiBwcm9wZXJ0aWVzXG4gICAqIGFuZCBtZXRob2RzIGZyb20gdGhlIGZlYXR1cmUgdGhhdCB1c2VycyBvZiB0aGUgaG9zdCBuZWVkIGFjY2VzcyB0by5cbiAgICpcbiAgICogQHNlZSBUZXh0VG9TcGVlY2hGZWF0dXJlXG4gICAqL1xuICBpbnN0YWxsQXBpKCkge1xuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqIEBuYW1lc3BhY2UgVGV4dFRvU3BlZWNoRmVhdHVyZVxuICAgICAqL1xuICAgIGNvbnN0IGFwaSA9IHN1cGVyLmluc3RhbGxBcGkoKTtcblxuICAgIE9iamVjdC5hc3NpZ24oYXBpLCB7XG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBUZXh0VG9TcGVlY2hGZWF0dXJlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEBtZXRob2RcbiAgICAgICAqIEBzZWUgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlI3BsYXlcbiAgICAgICAqL1xuICAgICAgcGxheTogdGhpcy5wbGF5LmJpbmQodGhpcyksXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBUZXh0VG9TcGVlY2hGZWF0dXJlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEBtZXRob2RcbiAgICAgICAqIEBzZWUgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlI3BhdXNlXG4gICAgICAgKi9cbiAgICAgIHBhdXNlOiB0aGlzLnBhdXNlLmJpbmQodGhpcyksXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBUZXh0VG9TcGVlY2hGZWF0dXJlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEBtZXRob2RcbiAgICAgICAqIEBzZWUgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlI3Jlc3VtZVxuICAgICAgICovXG4gICAgICByZXN1bWU6IHRoaXMucmVzdW1lLmJpbmQodGhpcyksXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBUZXh0VG9TcGVlY2hGZWF0dXJlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEBtZXRob2RcbiAgICAgICAqIEBzZWUgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlI3N0b3BcbiAgICAgICAqL1xuICAgICAgc3RvcDogdGhpcy5zdG9wLmJpbmQodGhpcyksXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBUZXh0VG9TcGVlY2hGZWF0dXJlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEBtZXRob2RcbiAgICAgICAqIEBzZWUgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlI2dldFZvbHVtZVxuICAgICAgICovXG4gICAgICBnZXRWb2x1bWU6IHRoaXMuZ2V0Vm9sdW1lLmJpbmQodGhpcyksXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBUZXh0VG9TcGVlY2hGZWF0dXJlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEBtZXRob2RcbiAgICAgICAqIEBzZWUgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlI3NldFZvbHVtZVxuICAgICAgICovXG4gICAgICBzZXRWb2x1bWU6IHRoaXMuc2V0Vm9sdW1lLmJpbmQodGhpcyksXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBUZXh0VG9TcGVlY2hGZWF0dXJlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEBtZXRob2RcbiAgICAgICAqIEBzZWUgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlI3BhdXNlVm9sdW1lXG4gICAgICAgKi9cbiAgICAgIHBhdXNlVm9sdW1lOiB0aGlzLnBhdXNlVm9sdW1lLmJpbmQodGhpcyksXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBUZXh0VG9TcGVlY2hGZWF0dXJlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEBtZXRob2RcbiAgICAgICAqIEBzZWUgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlI3Jlc3VtZVZvbHVtZVxuICAgICAgICovXG4gICAgICByZXN1bWVWb2x1bWU6IHRoaXMucmVzdW1lVm9sdW1lLmJpbmQodGhpcyksXG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhhcGksIHtcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlcm9mIFRleHRUb1NwZWVjaEZlYXR1cmVcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQHNlZSBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUjc3BlZWNobWFya09mZnNldFxuICAgICAgICovXG4gICAgICBzcGVlY2htYXJrT2Zmc2V0OiB7XG4gICAgICAgIGdldDogKCkgPT4gdGhpcy5zcGVlY2htYXJrT2Zmc2V0LFxuICAgICAgICBzZXQ6IG9mZnNldCA9PiB7XG4gICAgICAgICAgdGhpcy5zcGVlY2htYXJrT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIHJldHVybiBhcGk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbmQgc2V0cyB0aGUgdm9sdW1lIHVzZWQgZm9yIGFsbCBhdWRpbyBjbGlwcyBwbGF5ZWQgYnkgdGhlIHNwZWFrZXIuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBzZXQgdm9sdW1lKHZvbHVtZSkge1xuICAgIHRoaXMuX3ZvbHVtZSA9IE1hdGhVdGlscy5jbGFtcCh2b2x1bWUpO1xuICB9XG5cbiAgZ2V0IHZvbHVtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdm9sdW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgd2hldGhlciBvciBub3QgdGhlIHNwZWFrZXIncyB2b2x1bWUgdmFsdWUgaXMgY3VycmVudGx5IGJlaW5nIHR3ZWVuZWQuXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCB2b2x1bWVQZW5kaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm9taXNlcy52b2x1bWUgJiYgdGhpcy5fcHJvbWlzZXMudm9sdW1lLnBlbmRpbmc7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdm9sdW1lIHVzZWQgZm9yIGFsbCBhdWRpbyBjbGlwcyBwbGF5ZWQgYnkgdGhlIHNwZWFrZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBnZXRWb2x1bWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudm9sdW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHZvbHVtZSB1c2VkIGZvciBhbGwgYXVkaW8gY2xpcHMgcGxheWVkIGJ5IHRoZSBzcGVha2VyIG92ZXIgdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZvbHVtZSAtIFRhcmdldCB2b2x1bWUgdmFsdWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2Vjb25kcz0wXSAtIEFtb3VudCBvZiB0aW1lIGl0IHdpbGwgdGFrZSB0byByZWFjaCB0aGUgdGFyZ2V0XG4gICAqIHZvbHVtZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGVhc2luZ0ZuIC0gRWFzaW5nIGZ1bmN0aW9uIHVzZWQgZm9yIGludGVycG9sYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH1cbiAgICovXG4gIHNldFZvbHVtZSh2b2x1bWUsIHNlY29uZHMgPSAwLCBlYXNpbmdGbikge1xuICAgIGlmICh0aGlzLnZvbHVtZVBlbmRpbmcpIHtcbiAgICAgIHRoaXMuX3Byb21pc2VzLnZvbHVtZS5jYW5jZWwoKTtcbiAgICB9XG5cbiAgICB2b2x1bWUgPSBNYXRoVXRpbHMuY2xhbXAodm9sdW1lKTtcbiAgICB0aGlzLl9wcm9taXNlcy52b2x1bWUgPSBBbmltYXRpb25VdGlscy5pbnRlcnBvbGF0ZVByb3BlcnR5KFxuICAgICAgdGhpcyxcbiAgICAgICd2b2x1bWUnLFxuICAgICAgdm9sdW1lLFxuICAgICAge3NlY29uZHMsIGVhc2luZ0ZufVxuICAgICk7XG5cbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZXMudm9sdW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdXNlIGludGVycG9sYXRpb24gaGFwcGVuaW5nIG9uIHRoZSBzcGVha2VyJ3Mgdm9sdW1lIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHBhdXNlVm9sdW1lKCkge1xuICAgIHRoaXMuX3ZvbHVtZVBhdXNlZCA9IHRydWU7XG5cbiAgICByZXR1cm4gdGhpcy52b2x1bWVQZW5kaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc3VtZSBhbnkgaW50ZXJwb2xhdGlvbiBoYXBwZW5pbmcgb24gdGhlIHNwZWFrZXIncyB2b2x1bWUgcHJvcGVydHkuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgcmVzdW1lVm9sdW1lKCkge1xuICAgIHRoaXMuX3ZvbHVtZVBhdXNlZCA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIHRoaXMudm9sdW1lUGVuZGluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGN1cnJlbnRseSBwbGF5aW5nIHNwZWVjaC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhVGltZSAtIFRpbWUgc2luY2UgdGhlIGxhc3QgdXBkYXRlLlxuICAgKi9cbiAgdXBkYXRlKGRlbHRhVGltZSkge1xuICAgIGlmICghdGhpcy5fdm9sdW1lUGF1c2VkKSB7XG4gICAgICB0aGlzLl9wcm9taXNlcy52b2x1bWUuZXhlY3V0ZShkZWx0YVRpbWUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jdXJyZW50U3BlZWNoICYmIHRoaXMuX2N1cnJlbnRTcGVlY2gucGxheWluZykge1xuICAgICAgdGhpcy5fY3VycmVudFNwZWVjaC52b2x1bWUgPSB0aGlzLl92b2x1bWU7XG4gICAgICB0aGlzLl9jdXJyZW50U3BlZWNoLnVwZGF0ZSh0aGlzLl9ob3N0Lm5vdyk7XG4gICAgICBzdXBlci51cGRhdGUoZGVsdGFUaW1lKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBjdXJyZW50IHNwZWVjaCB0byBhIG5ldyBhc3NldCBhbmQgdXBkYXRlIHRoZSBzcGVlY2gncyBzcGVlY2htYXJrXG4gICAqIG9mZnNldCB2YWx1ZSB0byBtYXRjaCB0aGF0IG9mIHRoZSBmZWF0dXJlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge0Fic3RyYWN0U3BlZWNofSBzcGVlY2ggLSBTcGVlY2ggdG8gc2V0IGFzIGN1cnJlbnQuXG4gICAqL1xuICBfc2V0Q3VycmVudFNwZWVjaChzcGVlY2gpIHtcbiAgICBzcGVlY2guc3BlZWNobWFya09mZnNldCA9IHRoaXMuX3NwZWVjaG1hcmtPZmZzZXQ7XG4gICAgdGhpcy5fY3VycmVudFNwZWVjaCA9IHNwZWVjaDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBwcm9taXNlIHRoYXQgd2lsbCBwbGF5L3Jlc3VtZSBhIHNwZWVjaCB3aXRoIHRoZSBnaXZlbiB0ZXh0IGFmdGVyXG4gICAqIHRoZSBhdWRpbyBjb250ZXh0IGF0dGVtcHRzIHRvIHJlc3VtZSBhbmQgc3BlZWNoIGF1ZGlvIGlzIHJldHJpZXZlZCBmcm9tIFBvbGx5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIFRoZSB0ZXh0IG9mIHRoZSBuZXcgc3BlZWNoIHRvIHBsYXkuXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gY29uZmlnIC0gT3B0aW9uYWwgcGFyYW1ldGVycyBmb3IgdGhlIHNwZWVjaC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtwbGF5TWV0aG9kID0gJ3BsYXknXSAtIE1ldGhvZCB0byBleGVjdXRlIG9uIHRoZSByZXN1bHRpbmdcbiAgICogU3BlZWNoIG9iamVjdC4gVmFsaWQgb3B0aW9ucyBhcmUgJ3BsYXknIGFuZCAncmVzdW1lJy5cbiAgICovXG4gIF9zdGFydFNwZWVjaCh0ZXh0LCBjb25maWcsIHBsYXlNZXRob2QgPSAncGxheScpIHtcbiAgICAvLyBJZiBubyB0ZXh0IGlzIHByb3ZpZGVkLCB0cnkgdG8gdXNlIHRoZSBjdXJyZW50IHNwZWVjaFxuICAgIGlmICh0ZXh0ID09PSB1bmRlZmluZWQgJiYgcGxheU1ldGhvZCA9PT0gJ3Jlc3VtZScgJiYgdGhpcy5fY3VycmVudFNwZWVjaCkge1xuICAgICAgdGV4dCA9IHRoaXMuX2N1cnJlbnRTcGVlY2gudGV4dDtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJyZW50UHJvbWlzZSA9IHRoaXMuX2N1cnJlbnRQcm9taXNlIHx8IHtcbiAgICAgIHBsYXk6IG5ldyBEZWZlcnJlZChcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgY3VycmVudFByb21pc2Uuc3BlZWNoLmNhbmNlbCgpO1xuICAgICAgICB9LFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgY3VycmVudFByb21pc2Uuc3BlZWNoLmNhbmNlbCgpO1xuICAgICAgICB9LFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgY3VycmVudFByb21pc2Uuc3BlZWNoLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgc3BlZWNoOiBuZXcgRGVmZXJyZWQoKSxcbiAgICB9O1xuICAgIHRoaXMuX2N1cnJlbnRQcm9taXNlID0gY3VycmVudFByb21pc2U7XG5cbiAgICB0aGlzLl9nZXRTcGVlY2godGV4dCwgY29uZmlnKVxuICAgICAgLnRoZW4oc3BlZWNoID0+IHtcbiAgICAgICAgLy8gRXhpdCBpZiB0aGUgcHJvbWlzZSBpcyBubyBsb25nZXIgcGVuZGluZyBiZWNhdXNlIG9mIHVzZXIgaW50ZXJhY3Rpb25cbiAgICAgICAgaWYgKCFjdXJyZW50UHJvbWlzZS5wbGF5LnBlbmRpbmcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fY3VycmVudFByb21pc2UgIT09IGN1cnJlbnRQcm9taXNlKSB7XG4gICAgICAgICAgLy8gQ2FuY2VsIGlmIGFub3RoZXIgY2FsbCB0byBwbGF5IGhhcyBhbHJlYWR5IGJlZW4gbWFkZVxuICAgICAgICAgIGN1cnJlbnRQcm9taXNlLnBsYXkuY2FuY2VsKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVzZXQgY3VycmVudCBzcGVlY2ggd2hlbiB0aGUgc3BlZWNoIGVuZHNcbiAgICAgICAgY29uc3Qgb25GaW5pc2ggPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fY3VycmVudFNwZWVjaCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fY3VycmVudFByb21pc2UgPSBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENhbmNlbCB0aGUgY3VycmVudGx5IHBsYXlpbmcgc3BlZWNoXG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50U3BlZWNoICYmIHRoaXMuX2N1cnJlbnRTcGVlY2gucGxheWluZykge1xuICAgICAgICAgIGlmIChwbGF5TWV0aG9kID09PSAncGxheScpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTcGVlY2guY2FuY2VsKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIHBsYXlNZXRob2QgPT09ICdyZXN1bWUnICYmXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50U3BlZWNoLmF1ZGlvICE9PSBzcGVlY2guYXVkaW9cbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTcGVlY2guY2FuY2VsKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2V0Q3VycmVudFNwZWVjaChzcGVlY2gpO1xuXG4gICAgICAgIC8vIFBsYXkgdGhlIHNwZWVjaFxuICAgICAgICBjdXJyZW50UHJvbWlzZS5zcGVlY2ggPSBzcGVlY2hbcGxheU1ldGhvZF0oXG4gICAgICAgICAgdGhpcy5faG9zdC5ub3csXG4gICAgICAgICAgb25GaW5pc2gsXG4gICAgICAgICAgb25GaW5pc2gsXG4gICAgICAgICAgb25GaW5pc2hcbiAgICAgICAgKTtcbiAgICAgICAgY3VycmVudFByb21pc2Uuc3BlZWNoXG4gICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRQcm9taXNlLnNwZWVjaC5yZXNvbHZlZCkge1xuICAgICAgICAgICAgICBjdXJyZW50UHJvbWlzZS5wbGF5LnJlc29sdmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRQcm9taXNlLnBsYXkuY2FuY2VsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgY3VycmVudFByb21pc2UucGxheS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgIH0pO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaChlID0+IHtcbiAgICAgICAgZSA9IGBDYW5ub3QgJHtwbGF5TWV0aG9kfSBzcGVlY2ggJHt0ZXh0fSBvbiBob3N0ICR7dGhpcy5ob3N0LmlkfS4gJHtlfWA7XG4gICAgICAgIGN1cnJlbnRQcm9taXNlLnBsYXkucmVqZWN0KGUpO1xuICAgICAgfSk7XG5cbiAgICByZXR1cm4gY3VycmVudFByb21pc2UucGxheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIGFueSBzcGVlY2hlcyBjdXJyZW50bHkgcGxheWluZyBhbmQgcGxheSBhIG5ldyBzcGVlY2ggZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIFRoZSB0ZXh0IG9mIHRoZSBuZXcgc3BlZWNoIHRvIHBsYXkuXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gY29uZmlnIC0gT3B0aW9uYWwgcGFyYW1ldGVycyBmb3IgdGhlIHNwZWVjaC5cbiAgICpcbiAgICogQHJldHVybnMge0RlZmVycmVkfVxuICAgKi9cbiAgcGxheSh0ZXh0LCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhcnRTcGVlY2godGV4dCwgY29uZmlnLCAncGxheScpO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIGEgc3BlZWNoIGlzIGN1cnJlbnRseSBwbGF5aW5nLCBwYXVzZSBpdCBhdCB0aGUgY3VycmVudCB0aW1lLlxuICAgKi9cbiAgcGF1c2UoKSB7XG4gICAgaWYgKHRoaXMuX2N1cnJlbnRTcGVlY2ggJiYgdGhpcy5fY3VycmVudFNwZWVjaC5wbGF5aW5nKSB7XG4gICAgICB0aGlzLl9jdXJyZW50U3BlZWNoLnBhdXNlKHRoaXMuX2hvc3Qubm93KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgQ2Fubm90IHBhdXNlIHNwZWVjaCBvbiBob3N0ICR7dGhpcy5ob3N0LmlkfS4gTm8gc3BlZWNoIGlzIGN1cnJlbnRseSBwbGF5aW5nYFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RvcCBhbnkgc3BlZWNoZXMgY3VycmVudGx5IHBsYXlpbmcgYW5kIHJlc3VtZSBhIG5ldyBzcGVlY2ggZnJvbSB0aGUgY3VycmVudFxuICAgKiB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZz19IHRleHQgLSBUaGUgdGV4dCBvZiB0aGUgbmV3IHNwZWVjaCB0byBwbGF5LiBJZiB1bmRlZmluZWQgYW5kXG4gICAqIHRoZXJlIGlzIGEgY3VycmVudCBzcGVlY2ggdGhhdCBpcyBwYXVzZWQsIHRoZSBjdXJyZW50IHNwZWVjaCB3aWxsIGJlIHJlc3VtZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gY29uZmlnIC0gT3B0aW9uYWwgcGFyYW1ldGVycyBmb3IgdGhlIHNwZWVjaC5cbiAgICpcbiAgICogQHJldHVybnMge0RlZmVycmVkfVxuICAgKi9cbiAgcmVzdW1lKHRleHQsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLl9zdGFydFNwZWVjaCh0ZXh0LCBjb25maWcsICdyZXN1bWUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBhIHNwZWVjaCBpcyBjdXJyZW50bHkgcGxheWluZywgc3RvcCBwbGF5YmFjayBhbmQgcmVzZXQgdGltZS5cbiAgICovXG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMuX2N1cnJlbnRTcGVlY2ggJiYgdGhpcy5fY3VycmVudFNwZWVjaC5wbGF5aW5nKSB7XG4gICAgICB0aGlzLl9jdXJyZW50U3BlZWNoLnN0b3AoKTtcbiAgICAgIHRoaXMuX2N1cnJlbnRTcGVlY2ggPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBDYW5ub3Qgc3RvcCBzcGVlY2ggb24gaG9zdCAke3RoaXMuaG9zdC5pZH0uIE5vIHNwZWVjaCBpcyBjdXJyZW50bHkgcGxheWluZy5gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGRpc2NhcmQoKSB7XG4gICAgaWYgKHRoaXMuX2N1cnJlbnRTcGVlY2ggJiYgdGhpcy5fY3VycmVudFNwZWVjaC5wbGF5aW5nKSB7XG4gICAgICB0aGlzLl9jdXJyZW50U3BlZWNoLnN0b3AoKTtcbiAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5fc3BlZWNoQ2FjaGU7XG5cbiAgICBzdXBlci5kaXNjYXJkKCk7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlLCB7XG4gIEFXU19WRVJTSU9OOiB7XG4gICAgZ2V0OiAoKSA9PiBhd3NWZXJzaW9uLFxuICB9LFxuICBQT0xMWV9NSU5fTkVVUkFMX1ZFUlNJT046IHtcbiAgICB2YWx1ZTogJzIuNTAzJyxcbiAgICB3cml0YWJsZTogZmFsc2UsXG4gIH0sXG4gIFBPTExZX0RFRkFVTFRTOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIEVuZ2luZTogJ3N0YW5kYXJkJyxcbiAgICAgIExleGljb25OYW1lczogW10sXG4gICAgICBPdXRwdXRGb3JtYXQ6ICdtcDMnLFxuICAgICAgU2FtcGxlUmF0ZTogJzIyMDUwJyxcbiAgICAgIFRleHQ6ICcnLFxuICAgICAgVGV4dFR5cGU6ICdzc21sJyxcbiAgICAgIFZvaWNlSWQ6ICdBbXknLFxuICAgICAgTGFuZ3VhZ2VDb2RlOiAnZW4tR0InLFxuICAgICAgTGFuZ3VhZ2VOYW1lOiAnQnJpdGlzaCBFbmdsaXNoJyxcbiAgICB9LFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgfSxcbiAgUE9MTFlfVk9JQ0VTOiB7XG4gICAgdmFsdWU6IFtdLFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgfSxcbiAgUE9MTFlfTEFOR1VBR0VTOiB7XG4gICAgdmFsdWU6IHt9LFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgfSxcbiAgUE9MTFlfTEFOR1VBR0VfQ09ERVM6IHtcbiAgICB2YWx1ZToge30sXG4gICAgd3JpdGFibGU6IGZhbHNlLFxuICB9LFxuICBfaXNSZWFkeToge1xuICAgIHZhbHVlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgfSxcbiAgRVZFTlRTOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIC4uLk9iamVjdC5nZXRQcm90b3R5cGVPZihBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUpLkVWRU5UUyxcbiAgICAgIHJlYWR5OiAnb25SZWFkeUV2ZW50JyxcbiAgICAgIHBsYXk6ICdvblBsYXlFdmVudCcsXG4gICAgICBwYXVzZTogJ29uUGF1c2VFdmVudCcsXG4gICAgICByZXN1bWU6ICdvblJlc3VtZUV2ZW50JyxcbiAgICAgIGludGVycnVwdDogJ29uSW50ZXJydXB0RXZlbnQnLFxuICAgICAgc3RvcDogJ29uU3RvcEV2ZW50JyxcbiAgICAgIHNlbnRlbmNlOiAnb25TZW50ZW5jZUV2ZW50JyxcbiAgICAgIHdvcmQ6ICdvbldvcmRFdmVudCcsXG4gICAgICB2aXNlbWU6ICdvblZpc2VtZUV2ZW50JyxcbiAgICAgIHNzbWw6ICdvblNzbWxFdmVudCcsXG4gICAgfSxcbiAgfSxcbiAgU0VSVklDRVM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgLi4uT2JqZWN0LmdldFByb3RvdHlwZU9mKEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSkuU0VSVklDRVMsXG4gICAgICBwb2xseTogdW5kZWZpbmVkLFxuICAgICAgcHJlc2lnbmVyOiB1bmRlZmluZWQsXG4gICAgfSxcbiAgfSxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmU7XG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxuaW1wb3J0IFNwZWVjaCBmcm9tICcuL1NwZWVjaCc7XG5pbXBvcnQgRGVmZXJyZWQgZnJvbSAnLi4vRGVmZXJyZWQnO1xuaW1wb3J0IEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSBmcm9tICcuL0Fic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSc7XG5cbi8qKlxuICogQGV4dGVuZHMgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlXG4gKiBAYWxpYXMgY29yZS9UZXh0VG9TcGVlY2hGZWF0dXJlXG4gKi9cbmNsYXNzIFRleHRUb1NwZWVjaEZlYXR1cmUgZXh0ZW5kcyBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG5cbiAgICB0aGlzLl9lbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5fc2V0QXVkaW9Db250ZXh0KCk7XG4gICAgdGhpcy5fb2JzZXJ2ZUF1ZGlvQ29udGV4dCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlIHRoZSBhdWRpbyBjb250ZXh0IHRoYXQgd2lsbCBiZSB1c2VkIHRvIGVuc3VyZSBhdWRpbyBjYW4gYmUgcGxheWVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldEF1ZGlvQ29udGV4dCgpIHtcbiAgICB0aGlzLl9hdWRpb0NvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KCk7XG4gIH1cblxuICAvKipcbiAgICogTGlzdGVuIGZvciBzdGF0ZSBjaGFuZ2VzIG9uIHRoZSBhdWRpbyBjb250ZXh0IHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBmZWF0dXJlXG4gICAqIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb2JzZXJ2ZUF1ZGlvQ29udGV4dCgpIHtcbiAgICBpZiAodGhpcy5fYXVkaW9Db250ZXh0KSB7XG4gICAgICB0aGlzLl9hdWRpb0NvbnRleHQub25zdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX2F1ZGlvQ29udGV4dC5zdGF0ZSA9PT0gJ3J1bm5pbmcnKSB7XG4gICAgICAgICAgdGhpcy5fZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICdUaGUgYXVkaW8gY29udGV4dCBpcyBub3QgcnVubmluZy4gU3BlZWNoIHdpbGwgbm90IGJlIGFibGUgdG8gYmUgcGxheWVkIHVudGlsIGl0IGlzIHJlc3VtZWQuIFVzZSB0aGUgXCJUZXh0VG9TcGVlY2hGZWF0dXJlLnJlc3VtZUF1ZGlvXCIgbWV0aG9kIHRvIHRyeSB0byByZXN1bWUgaXQgYWZ0ZXIgYSB1c2VyIGdlc3R1cmUuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX2F1ZGlvQ29udGV4dC5vbnN0YXRlY2hhbmdlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBBdWRpbyBvYmplY3Qgb2Ygc3BlZWNoIGF1ZGlvIGZvciB0aGUgZ2l2ZW4gc3BlZWNoIHRleHQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBQYXJhbWV0ZXJzIG9iamVjdCBjb21wYXRpYmxlIHdpdGggUG9sbHkuc3ludGhlc2l6ZVNwZWVjaC5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9IFJlc29sdmVzIHdpdGggYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGF1ZGlvIFVSTCBhbmQgQXVkaW9cbiAgICogb2JqZWN0LlxuICAgKi9cbiAgX3N5bnRoZXNpemVBdWRpbyhwYXJhbXMpIHtcbiAgICByZXR1cm4gc3VwZXIuX3N5bnRoZXNpemVBdWRpbyhwYXJhbXMpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgIGNvbnN0IHt1cmx9ID0gcmVzdWx0O1xuXG4gICAgICAvLyBDcmVhdGUgYW4gQXVkaW8gb2JqZWN0IHRoYXQgcG9pbnRzIHRvIHRoZSBwcmVzaWduZWQgdXJsXG4gICAgICBjb25zdCBhdWRpbyA9IG5ldyBBdWRpbyh1cmwpO1xuICAgICAgYXVkaW8ubG9vcCA9IHRoaXMubG9vcDtcbiAgICAgIGF1ZGlvLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XG4gICAgICBhdWRpby5wcmVsb2FkID0gJ2F1dG8nO1xuICAgICAgcmVzdWx0LmF1ZGlvID0gYXVkaW87XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgLy8gUmVzb2x2ZSBvbmNlIHRoZSBtaW5pbXVtIGFtb3VudCBpcyBsb2FkZWRcbiAgICAgICAgYXVkaW8uYWRkRXZlbnRMaXN0ZW5lcignY2FucGxheXRocm91Z2gnLCAoKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTdGFydCBsb2FkaW5nIHRoZSBhdWRpb1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGF1ZGlvKTtcbiAgICAgICAgYXVkaW8ubG9hZCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFNwZWVjaCBvYmplY3QgZm9yIHRoZSBzcGVha2VyLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUb1NwZWVjaH0gc3BlYWtlciAtIFRoZSBUZXh0VG9TcGVlY2ggaW5zdGFuY2UgdGhhdCB3aWxsIG93biB0aGUgc3BlZWNoLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIFRleHQgb2YgdGhlIHNwZWVjaC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHNwZWVjaG1hcmtzIC0gU3BlZWNobWFya3MgZm9yIHRoZSBzcGVlY2guXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhdWRpb0NvbmZpZyAtIEF1ZGlvIGZvciB0aGUgc3BlZWNoLlxuICAgKlxuICAgKiBAcmV0dXJucyB7QWJzdHJhY3RTcGVlY2h9XG4gICAqL1xuICBfY3JlYXRlU3BlZWNoKHRleHQsIHNwZWVjaG1hcmtzLCBhdWRpb0NvbmZpZykge1xuICAgIHJldHVybiBuZXcgU3BlZWNoKHRoaXMsIHRleHQsIHNwZWVjaG1hcmtzLCBhdWRpb0NvbmZpZyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgYXVkaW8gY29udGV4dCBpcyBydW5uaW5nIGFuZCBzcGVlY2ggY2FuIGJlIHBsYXllZC5cbiAgICpcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7XG4gIH1cblxuICAvKipcbiAgICogVHJ5IHRvIHJlc3VtZSB0aGUgYXVkaW8gY29udGV4dC4gVGhpcyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgZXhlY3V0ZWQgZWFjaCB0aW1lXG4gICAqIHNwZWVjaCBpcyBwbGF5ZWQgb3IgcmVzdW1lZC4gSWYgdXNpbmcgbWFudWFsbHksIGl0IHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgYVxuICAgKiB1c2VyIGludGVyYWN0aW9uIG9jY3Vycy5cbiAgICpcbiAgICogQHJldHVybnMge0RlZmVycmVkfSAtIFJlc29sdmVzIG9uY2UgdGhlIGF1ZGlvIGNvbnRleHQgaGFzIHJlc3VtZWQuXG4gICAqL1xuICByZXN1bWVBdWRpbygpIHtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IERlZmVycmVkKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX2F1ZGlvQ29udGV4dFxuICAgICAgICAucmVzdW1lKClcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICAgIHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgX3N0YXJ0U3BlZWNoKHRleHQsIGNvbmZpZywgcGxheU1ldGhvZCA9ICdwbGF5Jykge1xuICAgIGNvbnN0IGN1cnJlbnRQcm9taXNlID0ge1xuICAgICAgcGxheTogbmV3IERlZmVycmVkKFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBjdXJyZW50UHJvbWlzZS5zcGVlY2guY2FuY2VsKCk7XG4gICAgICAgIH0sXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBjdXJyZW50UHJvbWlzZS5zcGVlY2guY2FuY2VsKCk7XG4gICAgICAgIH0sXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBjdXJyZW50UHJvbWlzZS5zcGVlY2guY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICBzcGVlY2g6IG5ldyBEZWZlcnJlZCgpLFxuICAgIH07XG4gICAgdGhpcy5fY3VycmVudFByb21pc2UgPSBjdXJyZW50UHJvbWlzZTtcblxuICAgIC8vIFRyeSB0byBzdGFydCB0aGUgYXVkaW8gY29udGV4dFxuICAgIHRoaXMucmVzdW1lQXVkaW8oKS50aGVuKCgpID0+IHtcbiAgICAgIC8vIEV4aXQgaWYgdGhlIHByb21pc2UgaXMgbm8gbG9uZ2VyIHBlbmRpbmcgYmVjYXVzZSBvZiB1c2VyIGludGVyYWN0aW9uXG4gICAgICBpZiAoIWN1cnJlbnRQcm9taXNlLnBsYXkucGVuZGluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBDYW5jZWwgaWYgYW5vdGhlciBjYWxsIHRvIHBsYXkgaGFzIGFscmVhZHkgYmVlbiBtYWRlXG4gICAgICBlbHNlIGlmICh0aGlzLl9jdXJyZW50UHJvbWlzZSAhPT0gY3VycmVudFByb21pc2UpIHtcbiAgICAgICAgY3VycmVudFByb21pc2UucGxheS5jYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgYXVkaW8gY29udGV4dCBpcyBydW5uaW5nIHNvIHRoZSBzcGVlY2ggY2FuIGJlIHBsYXllZFxuICAgICAgaWYgKHRoaXMuX2VuYWJsZWQpIHtcbiAgICAgICAgc3VwZXIuX3N0YXJ0U3BlZWNoKHRleHQsIGNvbmZpZywgcGxheU1ldGhvZCk7XG4gICAgICB9XG4gICAgICAvLyBSZWplY3QgaWYgdGhlIGF1ZGlvIGNvbnRleHQgaXMgbm90IHJ1bm5pbmdcbiAgICAgIGVsc2Uge1xuICAgICAgICBjdXJyZW50UHJvbWlzZS5yZWplY3QoXG4gICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgYENhbm5vdCAke3BsYXlNZXRob2R9IHNwZWVjaCBvbiBob3N0ICR7dGhpcy5faG9zdC5pZH0uIFRoZSBhdWRpbyBjb250ZXh0IGlzIG5vdCBydW5uaW5nLiBVc2UgdGhlIFwiVGV4dFRvU3BlZWNoRmVhdHVyZS5yZXN1bWVBdWRpb1wiIG1ldGhvZCB0byB0cnkgdG8gcmVzdW1lIGl0IGFmdGVyIGEgdXNlciBnZXN0dXJlLmBcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY3VycmVudFByb21pc2UucGxheTtcbiAgfVxuXG4gIHBsYXkodGV4dCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0U3BlZWNoKHRleHQsIGNvbmZpZywgJ3BsYXknKTtcbiAgfVxuXG4gIHJlc3VtZSh0ZXh0LCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhcnRTcGVlY2godGV4dCwgY29uZmlnLCAncmVzdW1lJyk7XG4gIH1cblxuICBpbnN0YWxsQXBpKCkge1xuICAgIGNvbnN0IGFwaSA9IHN1cGVyLmluc3RhbGxBcGkoKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGFwaSwge1xuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgVGV4dFRvU3BlZWNoRmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAc2VlIGNvcmUvVGV4dFRvU3BlZWNoRmVhdHVyZSNlbmFibGVkXG4gICAgICAgKi9cbiAgICAgIGVuYWJsZWQ6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiB0aGlzLl9lbmFibGVkLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIHJldHVybiBhcGk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGV4dFRvU3BlZWNoRmVhdHVyZTtcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXG5pbXBvcnQgVGV4dFRvU3BlZWNoVXRpbHMgZnJvbSAnLi9UZXh0VG9TcGVlY2hVdGlscyc7XG5pbXBvcnQgQWJzdHJhY3RTcGVlY2ggZnJvbSAnLi9BYnN0cmFjdFNwZWVjaCc7XG5pbXBvcnQgU3BlZWNoIGZyb20gJy4vU3BlZWNoJztcbmltcG9ydCBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUgZnJvbSAnLi9BYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUnO1xuaW1wb3J0IFRleHRUb1NwZWVjaEZlYXR1cmUgZnJvbSAnLi9UZXh0VG9TcGVlY2hGZWF0dXJlJztcbi8qKlxuICogQG1vZHVsZSBjb3JlL2F3c3BhY2tcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIC8qKlxuICAgKiBAc2VlIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZVxuICAgKi9cbiAgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlLFxuICAvKipcbiAgICogQHNlZSBjb3JlL1RleHRUb1NwZWVjaEZlYXR1cmVcbiAgICovXG4gIFRleHRUb1NwZWVjaEZlYXR1cmUsXG4gIC8qKlxuICAgKiBAc2VlIFRleHRUb1NwZWVjaFV0aWxzXG4gICAqL1xuICBUZXh0VG9TcGVlY2hVdGlscyxcbiAgLyoqXG4gICAqIEBzZWUgQWJzdHJhY3RTcGVlY2hcbiAgICovXG4gIEFic3RyYWN0U3BlZWNoLFxuICAvKipcbiAgICogQHNlZSBjb3JlL1NwZWVjaFxuICAgKi9cbiAgU3BlZWNoLFxufTtcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXG5cbi8qKlxuICogQG1vZHVsZSBjb3JlL0hPU1RcbiAqL1xuXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi9VdGlscyc7XG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gJy4vTWF0aFV0aWxzJztcbmltcG9ydCBEZWZlcnJlZCBmcm9tICcuL0RlZmVycmVkJztcbmltcG9ydCB7ZW52fSBmcm9tICcuL0hvc3RFbnZpcm9ubWVudCc7XG5pbXBvcnQgTWVzc2VuZ2VyIGZyb20gJy4vTWVzc2VuZ2VyJztcbmltcG9ydCBIb3N0T2JqZWN0IGZyb20gJy4vSG9zdE9iamVjdCc7XG5pbXBvcnQgTGlwc3luY0ZlYXR1cmUsIHtEZWZhdWx0VmlzZW1lTWFwfSBmcm9tICcuL0xpcHN5bmNGZWF0dXJlJztcbmltcG9ydCBHZXN0dXJlRmVhdHVyZSwge0RlZmF1bHRHZXN0dXJlV29yZHN9IGZyb20gJy4vR2VzdHVyZUZlYXR1cmUnO1xuaW1wb3J0IFBvaW50T2ZJbnRlcmVzdEZlYXR1cmUsIHtBeGlzTWFwfSBmcm9tICcuL1BvaW50T2ZJbnRlcmVzdEZlYXR1cmUnO1xuXG5pbXBvcnQgYW5pbXBhY2sgZnJvbSAnLi9hbmltcGFjayc7XG5cbmltcG9ydCBhd3MgZnJvbSAnLi9hd3NwYWNrJztcblxuY29uc3Qge1xuICBFYXNpbmcsXG4gIEFuaW1hdGlvbkZlYXR1cmUsXG4gIEFuaW1hdGlvblR5cGVzLFxuICBBbmltYXRpb25MYXllcixcbiAgTGF5ZXJCbGVuZE1vZGVzLFxuICBEZWZhdWx0TGF5ZXJCbGVuZE1vZGUsXG4gIFNpbmdsZVN0YXRlLFxuICBUcmFuc2l0aW9uU3RhdGUsXG4gIEZyZWVCbGVuZFN0YXRlLFxuICBRdWV1ZVN0YXRlLFxuICBSYW5kb21BbmltYXRpb25TdGF0ZSxcbiAgQmxlbmQxZFN0YXRlLFxuICBCbGVuZDJkU3RhdGUsXG4gIEFuaW1hdGlvblV0aWxzLFxufSA9IGFuaW1wYWNrO1xuY29uc3Qge1xuICBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUsXG4gIFRleHRUb1NwZWVjaEZlYXR1cmUsXG4gIFRleHRUb1NwZWVjaFV0aWxzLFxuICBBYnN0cmFjdFNwZWVjaCxcbiAgU3BlZWNoLFxufSA9IGF3cztcblxuZXhwb3J0IGRlZmF1bHQge1xuICAvKipcbiAgICogQHNlZSBlbnZcbiAgICovXG4gIGVudixcbiAgLyoqXG4gICAqIEBzZWUgVXRpbHNcbiAgICovXG4gIFV0aWxzLFxuICAvKipcbiAgICogQHNlZSBNYXRoVXRpbHNcbiAgICovXG4gIE1hdGhVdGlscyxcbiAgLyoqXG4gICAqIEBzZWUgRGVmZXJyZWRcbiAgICovXG4gIERlZmVycmVkLFxuICAvKipcbiAgICogQHNlZSBjb3JlL01lc3NlbmdlclxuICAgKi9cbiAgTWVzc2VuZ2VyLFxuICAvKipcbiAgICogQHNlZSBjb3JlL0hvc3RPYmplY3RcbiAgICovXG4gIEhvc3RPYmplY3QsXG4gIC8qKlxuICAgKiBAc2VlIGNvcmUvTGlwc3luY0ZlYXR1cmVcbiAgICovXG4gIExpcHN5bmNGZWF0dXJlLFxuICAvKipcbiAgICogQHNlZSBjb3JlL0dlc3R1cmVGZWF0dXJlXG4gICAqL1xuICBHZXN0dXJlRmVhdHVyZSxcbiAgLyoqXG4gICAqIEBzZWUgY29yZS9Qb2ludE9mSW50ZXJlc3RGZWF0dXJlXG4gICAqL1xuICBQb2ludE9mSW50ZXJlc3RGZWF0dXJlLFxuICAvKipcbiAgICogQHNlZSBEZWZhdWx0VmlzZW1lTWFwXG4gICAqL1xuICBEZWZhdWx0VmlzZW1lTWFwLFxuICAvKipcbiAgICogQHNlZSBEZWZhdWx0R2VzdHVyZVdvcmRzXG4gICAqL1xuICBEZWZhdWx0R2VzdHVyZVdvcmRzLFxuICAvKipcbiAgICogQHNlZSBBeGlzTWFwXG4gICAqL1xuICBBeGlzTWFwLFxuXG4gIC8vIEFtbmltcGFja1xuICAvKipcbiAgICogQHNlZSBtb2R1bGU6Y29yZS9hbmltcGFjay5FYXNpbmdcbiAgICovXG4gIEVhc2luZyxcbiAgLyoqXG4gICAqIEBzZWUgbW9kdWxlOmNvcmUvYW5pbXBhY2suQW5pbWF0aW9uRmVhdHVyZVxuICAgKi9cbiAgQW5pbWF0aW9uRmVhdHVyZSxcbiAgLyoqXG4gICAqIEBzZWUgbW9kdWxlOmNvcmUvYW5pbXBhY2suQW5pbWF0aW9uTGF5ZXJcbiAgICovXG4gIEFuaW1hdGlvbkxheWVyLFxuICAvKipcbiAgICogQHNlZSBtb2R1bGU6Y29yZS9hbmltcGFjay5TaW5nbGVTdGF0ZVxuICAgKi9cbiAgU2luZ2xlU3RhdGUsXG4gIC8qKlxuICAgKiBAc2VlIG1vZHVsZTpjb3JlL2FuaW1wYWNrLlRyYW5zaXRpb25TdGF0ZVxuICAgKi9cbiAgVHJhbnNpdGlvblN0YXRlLFxuICAvKipcbiAgICogQHNlZSBtb2R1bGU6Y29yZS9hbmltcGFjay5GcmVlQmxlbmRTdGF0ZVxuICAgKi9cbiAgRnJlZUJsZW5kU3RhdGUsXG4gIC8qKlxuICAgKiBAc2VlIG1vZHVsZTpjb3JlL2FuaW1wYWNrLlF1ZXVlU3RhdGVcbiAgICovXG4gIFF1ZXVlU3RhdGUsXG4gIC8qKlxuICAgKiBAc2VlIG1vZHVsZTpjb3JlL2FuaW1wYWNrLlJhbmRvbUFuaW1hdGlvblN0YXRlXG4gICAqL1xuICBSYW5kb21BbmltYXRpb25TdGF0ZSxcbiAgLyoqXG4gICAqIEBzZWUgbW9kdWxlOmNvcmUvYW5pbXBhY2suQmxlbmQxZFN0YXRlXG4gICAqL1xuICBCbGVuZDFkU3RhdGUsXG4gIC8qKlxuICAgKiBAc2VlIG1vZHVsZTpjb3JlL2FuaW1wYWNrLkJsZW5kMmRTdGF0ZVxuICAgKi9cbiAgQmxlbmQyZFN0YXRlLFxuICAvKipcbiAgICogQHNlZSBtb2R1bGU6Y29yZS9hbmltcGFjay5BbmltYXRpb25VdGlsc1xuICAgKi9cbiAgQW5pbWF0aW9uVXRpbHMsXG4gIC8qKlxuICAgKiBAc2VlIG1vZHVsZTpjb3JlL2FuaW1wYWNrLkxheWVyQmxlbmRNb2Rlc1xuICAgKi9cbiAgTGF5ZXJCbGVuZE1vZGVzLFxuICAvKipcbiAgICogQHNlZSBtb2R1bGU6Y29yZS9hbmltcGFjay5EZWZhdWx0TGF5ZXJCbGVuZE1vZGVcbiAgICovXG4gIERlZmF1bHRMYXllckJsZW5kTW9kZSxcbiAgLyoqXG4gICAqIEBzZWUgbW9kdWxlOmNvcmUvYW5pbXBhY2suQW5pbWF0aW9uVHlwZXNcbiAgICovXG4gIEFuaW1hdGlvblR5cGVzLFxuXG4gIC8vIEFXUyBQYWNrXG4gIC8qKlxuICAgKiBAc2VlIG1vZHVsZTpjb3JlL2F3c3BhY2suQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlXG4gICAqL1xuICBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUsXG4gIC8qKlxuICAgKiBAc2VlIG1vZHVsZTpjb3JlL2F3c3BhY2suVGV4dFRvU3BlZWNoRmVhdHVyZVxuICAgKi9cbiAgVGV4dFRvU3BlZWNoRmVhdHVyZSxcbiAgLyoqXG4gICAqIEBzZWUgbW9kdWxlOmNvcmUvYXdzcGFjay5UZXh0VG9TcGVlY2hVdGlsc1xuICAgKi9cbiAgVGV4dFRvU3BlZWNoVXRpbHMsXG4gIC8qKlxuICAgKiBAc2VlIG1vZHVsZTpjb3JlL2F3c3BhY2suQWJzdHJhY3RTcGVlY2hcbiAgICovXG4gIEFic3RyYWN0U3BlZWNoLFxuICAvKipcbiAgICogQHNlZSBtb2R1bGU6Y29yZS9hd3NwYWNrLlNwZWVjaFxuICAgKi9cbiAgU3BlZWNoLFxufTtcbiJdLCJuYW1lcyI6WyJEZWZlcnJlZCIsImV4ZWN1dGFibGUiLCJvblJlc29sdmUiLCJvblJlamVjdCIsIm9uQ2FuY2VsIiwiRXJyb3IiLCJyZXMiLCJyZWoiLCJjYW5jZWwiLCJzdGF0dXMiLCJyZXNvbHZlZCIsInJlamVjdGVkIiwiY2FuY2VsZWQiLCJwZW5kaW5nIiwicmVzb2x2ZSIsInJlamVjdCIsInZhbHVlIiwiX3N0YXR1cyIsIl9yZXNvbHZlIiwiX3JlamVjdCIsIl9jYW5jZWwiLCJfZXhlY3V0YWJsZSIsImFyZ3MiLCJpdGVyYWJsZSIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiZSIsImFycmF5IiwiZGVmZXJyZWQiLCJmaWx0ZXIiLCJpdGVtIiwicmVzdWx0IiwidW5kZWZpbmVkIiwicmVzb2x2ZVZhbHVlIiwiZm9yRWFjaCIsImxlbmd0aCIsImVycm9yIiwiY2FuY2VsVmFsdWUiLCJudW1JdGVtcyIsIml0ZW1UcmFja2VyIiwiZmFpbGVkIiwibnVtUmVzb2x2ZWQiLCJyZXNvbHV0aW9ucyIsImluZGV4IiwiUHJvbWlzZSIsInRoZW4iLCJVdGlscyIsInJlcGxhY2UiLCJjIiwicmFuZG9tTnVtYmVyIiwiTWF0aCIsImZsb29yIiwiRGF0ZSIsIm5vdyIsInJhbmRvbSIsInRvU3RyaW5nIiwibmFtZSIsIm5hbWVBcnJheSIsImluY2x1ZGVzIiwibmFtZVNldCIsIlNldCIsIm1hdGNoR3JvdXAiLCJtYXRjaCIsImJhc2VOYW1lIiwic2xpY2UiLCJpbmNyZW1lbnQiLCJOdW1iZXIiLCJzZXROYW1lIiwic2V0TWF0Y2hHcm91cCIsInNldEluY3JlbWVudCIsInNlY29uZHMiLCJvbkZpbmlzaCIsIm9uUHJvZ3Jlc3MiLCJvbkVycm9yIiwiY29uc29sZSIsIndhcm4iLCJjdXJyZW50VGltZSIsInRvdGFsVGltZSIsIm9uVXBkYXRlIiwiZGVsdGFUaW1lIiwibWluIiwibWF4IiwiY2VpbCIsIlJhZGlhblRvRGVncmVlIiwiUEkiLCJEZWdyZWVUb1JhZGlhbiIsIk1hdGhVdGlscyIsInJhZGlhbnMiLCJkZWdyZWVzIiwiZnJvbSIsInRvIiwiZmFjdG9yIiwiYSIsImIiLCJwIiwiZGlzdFNxciIsImRpc3RhbmNlU3F1YXJlZCIsInQiLCJwb2ludCIsInZlcnRpY2VzIiwibWluWCIsIlBPU0lUSVZFX0lORklOSVRZIiwibWluWSIsIm1heFgiLCJORUdBVElWRV9JTkZJTklUWSIsIm1heFkiLCJ2IiwiZFgiLCJkWSIsIm1pZFgiLCJtaWRZIiwiZE1heCIsInN1cGVySW5kaWNlcyIsInZlcnRzV2l0aFN1cGVyIiwic3VwZXJTb3J0ZWRJbmRpY2VzIiwic29ydFBvaW50c0NDVyIsInN1cGVyVHJpYW5nbGUiLCJpbmRpY2VzIiwiZWRnZXMiLCJ0cmlhbmdsZXMiLCJuZXdWZXJ0IiwibmV3SW5kZXgiLCJpbnZhbGlkVHJpYW5nbGVzIiwidHJpYW5nbGUiLCJpc1BvaW50SW5DaXJjdW1DaXJjbGUiLCJwdXNoIiwiYm91bmRpbmdQb2x5IiwiZWRnZSIsImNvdW50Iiwib3RoZXJUcmlhbmdsZSIsIm90aGVyRWRnZSIsInNwbGljZSIsImluZGV4T2YiLCJzb3J0ZWRJbmRpY2VzIiwidHJpYW5nbGVzVG9SZW1vdmUiLCJtYXAiLCJheCIsImF5IiwiYngiLCJieSIsImN4IiwiY3kiLCJkZW5vbSIsImFWYWwiLCJiVmFsIiwiY1ZhbCIsImNlbnRyb2lkIiwic29ydCIsImF0YW4yIiwiYWJzIiwidmVjdG9yIiwiQXJyYXkiLCJyZWR1Y2VyIiwiYWNjdW11bGF0b3IiLCJjdXJyZW50VmFsdWUiLCJzcXJ0IiwicmVkdWNlIiwidmVjdG9yQSIsInZlY3RvckIiLCJ2YWx1ZUEiLCJ2YWx1ZUIiLCJub3JtYWxBIiwibm9ybWFsaXplVmVjdG9yIiwibm9ybWFsQiIsImRvdCIsImdldERvdFByb2R1Y3QiLCJhY29zIiwiY2xhbXAiLCJ2ZWN0b3IzIiwibWF0cml4MyIsImV2ZXJ5IiwieCIsInkiLCJ6IiwibWFnbml0dWRlIiwiZ2V0VmVjdG9yTWFnbml0dWRlIiwiZmlsbCIsIm1hdHJpeDQiLCJzY2FsZVgiLCJzY2FsZVkiLCJzY2FsZVoiLCJyIiwidGFyZ2V0VmFsdWUiLCJ2YWx1ZVN0b3JlIiwic21vb3RoVGltZSIsIm1heFNwZWVkIiwiY2xhbXBUaW1lIiwiZGVsdGFWYWx1ZSIsImNsYW1wRGVsdGFWYWx1ZSIsImxhc3RWYWx1ZSIsImQxIiwiZDIiLCJkMyIsImQ0IiwiZW52IiwiTWVzc2VuZ2VyIiwiaWQiLCJfaWQiLCJjcmVhdGVJZCIsIl9kaXNwYXRjaGVyIiwid2luZG93IiwiX2NhbGxiYWNrcyIsIl9ldmVudExpc3RlbmVycyIsIm1lc3NhZ2UiLCJjYWxsYmFjayIsImRldGFpbCIsIkN1c3RvbUV2ZW50IiwibGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwiX2NyZWF0ZUxvY2FsTWVzc2FnZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJfY3JlYXRlTGlzdGVuZXIiLCJfYWRkTGlzdGVuZXIiLCJpIiwic3RvcExpc3RlbmluZyIsIl9yZW1vdmVMaXN0ZW5lciIsInJlZ2V4cCIsIm1lc3NhZ2VzIiwiT2JqZWN0Iiwia2V5cyIsInRlc3QiLCJldmVudCIsIl9jcmVhdGVFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJtZXNzZW5nZXIiLCJHbG9iYWxNZXNzZW5nZXIiLCJsaXN0ZW5UbyIsInN0b3BMaXN0ZW5pbmdUb0FsbCIsImVtaXQiLCJkZWZpbmVQcm9wZXJ0aWVzIiwid3JpdGFibGUiLCJFVkVOVFMiLCJBYnN0cmFjdEhvc3RGZWF0dXJlIiwiaG9zdCIsIl9ob3N0IiwiZXZlbnRzIiwiYXBpIiwiZW50cmllcyIsImNvbnN0cnVjdG9yIiwib3duZXIiLCJzdG9wTGlzdGVuaW5nQnlSZWdleHAiLCJ1cGRhdGUiLCJSZWdFeHAiLCJzb3VyY2UiLCJSZXN1bHRDbGFzcyIsIm1peGluQ2xhc3NGYWN0b3JpZXMiLCJtaXhpbkNsYXNzRmFjdG9yeSIsIlNFUlZJQ0VTIiwiSG9zdE9iamVjdCIsIl9vd25lciIsIl9mZWF0dXJlcyIsIl93YWl0cyIsIl9sYXN0VXBkYXRlIiwiZHQiLCJ3YWl0IiwiZXhlY3V0ZSIsInZhbHVlcyIsImZlYXR1cmUiLCJvbkNvbXBsZXRlIiwiRmVhdHVyZUNsYXNzIiwiZm9yY2UiLCJpbnB1dFR5cGUiLCJwcm90b3R5cGUiLCJpbnN0YWxsQXBpIiwiYWRkRmVhdHVyZSIsInR5cGVOYW1lIiwicmVtb3ZlRmVhdHVyZSIsImRpc2NhcmQiLCJkZWZpbmVQcm9wZXJ0eSIsImdldFByb3RvdHlwZU9mIiwiTGluZWFyIiwiTm9uZSIsImsiLCJJbiIsIk91dCIsIkluT3V0IiwiUXVhZHJhdGljIiwiQ3ViaWMiLCJRdWFydGljIiwiUXVpbnRpYyIsIlNpbnVzb2lkYWwiLCJjb3MiLCJzaW4iLCJFeHBvbmVudGlhbCIsIkNpcmN1bGFyIiwiRWxhc3RpYyIsInMiLCJhc2luIiwiQmFjayIsIkJvdW5jZSIsIkZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UiLCJCYXNlQ2xhc3MiLCJGZWF0dXJlRGVwZW5kZW50TWl4aW4iLCJfaW5pdGlhbGl6ZWQiLCJfb25GZWF0dXJlQWRkZWQiLCJiaW5kIiwiX29uRmVhdHVyZVJlbW92ZWQiLCJFVkVOVF9ERVBFTkRFTkNJRVMiLCJldmVudE5hbWUiLCJBbmltYXRpb25GZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlIiwib2xkTmFtZSIsIm5ld05hbWUiLCJsYXllck5hbWUiLCJhbmltYXRpb25OYW1lIiwiUGFyZW50Q2xhc3MiLCJNaXhpbiIsIkFuaW1hdGlvbkZlYXR1cmVEZXBlbmRlbnRNaXhpbiIsIkFuaW1hdGlvbkZlYXR1cmUiLCJhZGRMYXllciIsInJlbW92ZUxheWVyIiwicmVuYW1lTGF5ZXIiLCJhZGRBbmltYXRpb24iLCJyZW1vdmVBbmltYXRpb24iLCJyZW5hbWVBbmltYXRpb24iLCJNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2UiLCJvcHRpb25zIiwibmFtZUZpbHRlciIsIndlaWdodCIsImVhc2luZ0ZuIiwiTWFuYWdlZEFuaW1hdGlvbkxheWVyTWl4aW4iLCJfbWFuYWdlZExheWVycyIsImxheWVycyIsIl9vbkxheWVyQWRkZWQiLCJfb25MYXllclJlbW92ZWQiLCJpc0FjdGl2ZSIsImdldEFuaW1hdGlvbnMiLCJhbmltTmFtZSIsIl9vbkFuaW1hdGlvbkFkZGVkIiwiYW5pbWF0aW9ucyIsIl9vbkFuaW1hdGlvblJlbW92ZWQiLCJsYXllck9wdGlvbnMiLCJhbmltT3B0aW9ucyIsIkRFRkFVTFRfTEFZRVJfT1BUSU9OUyIsImFuaW1hdGlvbk9wdGlvbnMiLCJhc3NpZ24iLCJyZWdpc3RlckFuaW1hdGlvbiIsInJlZ2lzdGVyTGF5ZXIiLCJsYXllck5hbWVzIiwic2V0TGF5ZXJXZWlnaHQiLCJibGVuZFRpbWUiLCJzZXRMYXllcldlaWdodHMiLCJlbmFibGUiLCJkaXNhYmxlIiwiVGV4dFRvU3BlZWNoRmVhdHVyZURlcGVuZGVudEludGVyZmFjZSIsIlRleHRUb1NwZWVjaEZlYXR1cmVEZXBlbmRlbnRNaXhpbiIsIlRleHRUb1NwZWVjaEZlYXR1cmUiLCJwbGF5IiwicGF1c2UiLCJyZXN1bWUiLCJzdG9wIiwic2VudGVuY2UiLCJ3b3JkIiwidmlzZW1lIiwic3NtbCIsIkRlZmF1bHRWaXNlbWVNYXAiLCJzaWwiLCJvdmVycmlkZVdlaWdodCIsIlMiLCJUIiwiZiIsInUiLCJFIiwibyIsIk8iLCJMaXBzeW5jRmVhdHVyZSIsInZpc2VtZUJsZW5kVGltZSIsImRlY2F5UmF0ZSIsImFtb3VudCIsInZpc2VtZUVhc2luZ0ZuIiwidmlzZW1lTGF5ZXJzIiwidGFsa2luZ0JsZW5kVGltZSIsInRhbGtpbmdFYXNpbmdGbiIsInRhbGtpbmdMYXllcnMiLCJ2aXNlbWVMZWFkVGltZSIsIl92aXNlbWVMYXllcnMiLCJfdGFsa2luZ0xheWVycyIsImFuaW1hdGlvbiIsInZpc2VtZU1hcCIsInJlZ2lzdGVyVmlzZW1lTGF5ZXIiLCJyZWdpc3RlclRhbGtpbmdMYXllciIsImdldEFuaW1hdGlvblR5cGUiLCJ3ZWlnaHROYW1lcyIsImdldEFuaW1hdGlvbkJsZW5kTmFtZXMiLCJ2aXNlbWVPcHRpb25zIiwic3BlZWNobWFya09mZnNldCIsIl92aXNlbWVMZWFkVGltZSIsIl9yZWdpc3RlclZpc2VtZUFuaW1hdGlvbiIsInJlc3VtZUFuaW1hdGlvbiIsIl9vblN0b3AiLCJfb25QbGF5IiwicGF1c2VBbmltYXRpb24iLCJtYXJrIiwiaXNWaXNlbWVBY3RpdmUiLCJ2aXNlbWVOYW1lcyIsImR1cmF0aW9uIiwibGVycEZhY3RvciIsImxlcnAiLCJibGVuZEluVGltZSIsImhvbGRUaW1lIiwiX2FuaW1hdGVTaW1wbGVWaXNlbWUiLCJkZWNheVdlaWdodCIsIl9hbmltYXRlSGVsZFZpc2VtZSIsInZpc2VtZU5hbWUiLCJwZWFrV2VpZ2h0IiwiYmxlbmRPdXRUaW1lIiwid2VpZ2h0UHJvbWlzZSIsInNldEFuaW1hdGlvbkJsZW5kV2VpZ2h0Iiwic3RhcnRQcm9taXNlIiwiaG9sZFByb21pc2UiLCJnZXQiLCJzZXQiLCJtaXgiLCJTU01MU3BlZWNobWFya0ludGVyZmFjZSIsIlNTTUxTcGVlY2hNYXJrTWl4aW4iLCJKU09OIiwicGFyc2UiLCJtZXRob2QiLCJhcHBseSIsIkRlZmF1bHRHZXN0dXJlV29yZHMiLCJiaWciLCJoZWFydCIsIm1hbnkiLCJtb3ZlbWVudCIsIm9uZSIsImFnZ3Jlc3NpdmUiLCJ5b3UiLCJkZWZlbnNlIiwid2F2ZSIsInNlbGYiLCJHZXN0dXJlRmVhdHVyZSIsIm1pbmltdW1JbnRlcnZhbCIsImxheWVyIiwibGF5ZXJIb2xkVGltZSIsImxheWVyTWluaW11bUludGVydmFsIiwiY2FuQWR2YW5jZSIsImlzUXVldWVFbmQiLCJjdXJyZW50R2VzdHVyZSIsIl9nZXRIb2xkVGltZSIsImhvbGRUaW1lciIsInBsYXlOZXh0QW5pbWF0aW9uIiwicGxheVRpbWVyIiwiYXV0b0Rpc2FibGUiLCJhbmltIiwid29yZHMiLCJnZXN0dXJlTWFwIiwidHJhbnNpdGlvblRpbWUiLCJrZXkiLCJzdHJpbmdpZnkiLCJnZW5lcmljR2VzdHVyZXMiLCJyZWFzb24iLCJfZ2V0TWluaW11bUludGVydmFsIiwicGxheUFuaW1hdGlvbiIsImdldFBhdXNlZCIsImNyZWF0ZUdlc3R1cmVNYXAiLCJjcmVhdGVHZW5lcmljR2VzdHVyZUFycmF5IiwicGxheUdlc3R1cmUiLCJzdG9wQW5pbWF0aW9uIiwiaW50ZXJydXB0QW5pbWF0aW9uIiwiQW5pbWF0aW9uVXRpbHMiLCJwcm9wZXJ0eU93bmVyIiwicHJvcGVydHlOYW1lIiwiaXNOYU4iLCJzdGFydFZhbHVlIiwiaW50ZXJwb2xhdG9yIiwicHJvZ3Jlc3MiLCJlYXNlRmFjdG9yIiwiQWJzdHJhY3RTdGF0ZSIsIl93ZWlnaHQiLCJfaW50ZXJuYWxXZWlnaHQiLCJfcGF1c2VkIiwiX3Byb21pc2VzIiwiZmluaXNoIiwiX3BsYXlDYWxsYmFja3MiLCJpbnRlcnBvbGF0ZVByb3BlcnR5IiwicHJvbWlzZSIsImFsbCIsInVwZGF0ZUludGVybmFsV2VpZ2h0IiwiVHJhbnNpdGlvblN0YXRlIiwiX3RvIiwiX2Zyb20iLCJfd2VpZ2h0UHJvbWlzZSIsInRvdGFsV2VpZ2h0Iiwic3RhdGUiLCJjdXJyZW50U3RhdGVzIiwidGFyZ2V0U3RhdGUiLCJkZWFjdGl2YXRlIiwicmVzZXQiLCJ3ZWlnaHRQcm9taXNlcyIsInNldFdlaWdodCIsIm9uTmV4dCIsInByb21pc2VzIiwiQW5pbWF0aW9uUGxheWVySW50ZXJmYWNlIiwiZm4iLCJwbGF5TWV0aG9kIiwiQW5pbWF0aW9uUGxheWVyTWl4aW4iLCJfdHJhbnNpdGlvblN0YXRlIiwiX3N0YXRlcyIsIk1hcCIsIl9jdXJyZW50U3RhdGUiLCJfdHJhbnNpdGlvblRpbWUiLCJfZWFzaW5nRm4iLCJoYXMiLCJjdXJyZW50QW5pbWF0aW9uIiwid2VpZ2h0UGVuZGluZyIsImNvbmZpZ3VyZSIsIl9wcmVwYXJlQ3VycmVudFN0YXRlIiwiU3RhdGVDb250YWluZXJJbnRlcmZhY2UiLCJjdXJyZW50TmFtZSIsIlN0YXRlQ29udGFpbmVyTWl4aW4iLCJ1bmlxdWVOYW1lIiwiZ2V0VW5pcXVlTmFtZSIsIlF1ZXVlU3RhdGUiLCJxdWV1ZVN0YXRlcyIsImFkZFN0YXRlIiwiX3F1ZXVlIiwiX2RvbmUiLCJpbnRlcm5hbFdlaWdodCIsIm5leHQiLCJkb25lIiwid3JhcCIsImxhc3ROYW1lIiwic2l6ZSIsImdldFN0YXRlIiwibG9vcENvdW50IiwiSW5maW5pdHkiLCJpc1RyYW5zaXRpb25pbmciLCJfcmVzZXQiLCJwYXVzZWQiLCJzdG9wcGVkIiwiZGlzY2FyZFN0YXRlcyIsIkFic3RyYWN0QmxlbmRTdGF0ZSIsImJsZW5kU3RhdGVzIiwiYmxlbmRXZWlnaHRzIiwiRnJlZUJsZW5kU3RhdGUiLCJzdW1XZWlnaHRzIiwiQmxlbmQxZFN0YXRlIiwiYmxlbmRUaHJlc2hvbGRzIiwicGhhc2VNYXRjaGVzIiwiX2JsZW5kVmFsdWUiLCJibGVuZFZhbHVlIiwibm9uWmVyb0RpZmZlcmVudFNpemUiLCJjb250YWluc0R1cGxpY2F0ZXMiLCJfdGhyZXNob2xkcyIsInBoYXNlTWF0Y2giLCJfc29ydFRocmVzaG9sZHMiLCJfZm9yY2VOb1RocmVzaG9sZER1cGVzIiwiX3BoYXNlTGVhZFN0YXRlIiwiX3VwZGF0ZUJsZW5kV2VpZ2h0cyIsInRocmVzaG9sZFZhbHVlIiwic2FtZVZhbHVlIiwiZmluZCIsInRocmVzaG9sZCIsInJlbW92ZWQiLCJmaW5kSW5kZXgiLCJub3JtYWxpemVkVGltZSIsInRhcmdldEluZGV4IiwidGhyZXNob2xkQSIsInRocmVzaG9sZEIiLCJmYWN0b3JCIiwiZmFjdG9yQSIsInN0YXRlQSIsInN0YXRlQiIsIkJsZW5kMmRTdGF0ZSIsIm90aGVyVGhyZXNob2xkIiwiX2JsZW5kVmFsdWVYIiwiX2JsZW5kVmFsdWVZIiwiYmxlbmRWYWx1ZVgiLCJibGVuZFZhbHVlWSIsIl92ZXJ0aWNlcyIsIl90cmlhbmdsZXMiLCJnZXREZWxhdW5heVRyaWFuZ3VsYXRpb24iLCJwcm9wZXJ0eSIsInRvVXBwZXJDYXNlIiwiX3NldEluZmx1ZW5jZUNsb3Nlc3RQb2ludE9uTGluZSIsImlzUG9pbnRJblRyaWFuZ2xlIiwiX3NldEluZmx1ZW5jZVRyaWFuZ2xlIiwiX3NldEluZmx1ZW5jZUNsb3Nlc3RQb2ludEluVHJpYW5nbGVzIiwiYXJlYUEiLCJ0cmlhbmdsZUFyZWEiLCJhcmVhQiIsImFyZWFDIiwidG90YWxBcmVhIiwid2VpZ2h0QSIsIndlaWdodEIiLCJ3ZWlnaHRDIiwidGhyZXNob2xkQyIsInN0YXRlQyIsIl9zZXRQaGFzZUxlYWRTdGF0ZSIsImdsb2JhbENsb3Nlc3RQb2ludCIsImdsb2JhbE1pbkRpc3QiLCJjbG9zZXN0VHJpYW5nbGUiLCJwb2ludEEiLCJjbG9zZXN0UG9pbnRPbkxpbmUiLCJwb2ludEIiLCJwb2ludEMiLCJkaXN0QSIsImRpc3RCIiwiZGlzdEMiLCJsb2NhbENsb3Nlc3RQb2ludCIsImxvY2FsTWluRGlzdCIsImNsb3Nlc3RQb2ludCIsInN0YXRlcyIsInBoYXNlTWF0Y2hlZCIsIkxheWVyQmxlbmRNb2RlcyIsIk92ZXJyaWRlIiwiQWRkaXRpdmUiLCJEZWZhdWx0TGF5ZXJCbGVuZE1vZGUiLCJ2YWxpZGF0ZUJsZW5kTW9kZSIsImJsZW5kTW9kZSIsIkFuaW1hdGlvbkxheWVyIiwiX2JsZW5kTW9kZSIsIl93ZWlnaHRQYXVzZWQiLCJpc1dlaWdodEFjdGl2ZSIsImdldFN0YXRlTmFtZXMiLCJibGVuZE5hbWUiLCJzZXRCbGVuZFdlaWdodCIsImdldEJsZW5kV2VpZ2h0IiwiU2luZ2xlU3RhdGUiLCJfdGltZVNjYWxlIiwidGltZVNjYWxlIiwiX2xvb3BDb3VudCIsIlJhbmRvbUFuaW1hdGlvblN0YXRlIiwic3ViU3RhdGVzIiwiX3BsYXlJbnRlcnZhbCIsInBsYXlJbnRlcnZhbCIsImdldFJhbmRvbUZsb2F0IiwicGxheVJhbmRvbUFuaW1hdGlvbiIsInRpbWVyIiwiX3Jlc2V0VGltZXIiLCJyYW5kb21TdGF0ZSIsImdldFJhbmRvbUludCIsImNhbmNlbEFuaW1hdGlvbiIsIkFuaW1hdGlvblR5cGVzIiwic2luZ2xlIiwiZnJlZUJsZW5kIiwicXVldWUiLCJyYW5kb21BbmltYXRpb24iLCJibGVuZDFkIiwiYmxlbmQyZCIsIl9sYXllcnMiLCJfbGF5ZXJNYXAiLCJleGlzdGluZyIsImxhc3RJbmRleCIsIm51bUxheWVycyIsIndlaWdodE11bHRpcGxpZXIiLCJjdXJyZW50U3RhdGUiLCJibGVuZFN0YXRlT3B0aW9ucyIsImJsZW5kT3B0aW9ucyIsIl9jcmVhdGVTaW5nbGVTdGF0ZSIsInF1ZXVlT3B0aW9ucyIsInF1ZXVlT3B0aW9uIiwiYmxlbmRNYXRjaFBoYXNlcyIsInN1YlN0YXRlT3B0aW9ucyIsImxheWVySW5kZXgiLCJfdmFsaWRhdGVJbmRleCIsImV2ZW50RGF0YSIsImN1cnJlbnRJbmRleCIsImdldEFuaW1hdGlvbkJsZW5kV2VpZ2h0IiwicGF1c2VXZWlnaHQiLCJyZXN1bWVXZWlnaHQiLCJhbmltYXRpb25UeXBlIiwiX3ZhbGlkYXRlTmV3QW5pbWF0aW9uIiwicmVtb3ZlU3RhdGUiLCJjdXJyZW50QW5pbWF0aW9uTmFtZSIsIm5ld0FuaW1hdGlvbk5hbWUiLCJyZW5hbWVTdGF0ZSIsIm5leHRRdWV1ZWRBbmltYXRpb24iLCJsIiwicmVzdW1lZCIsIm1vdmVMYXllciIsImdldExheWVyV2VpZ2h0IiwicGF1c2VMYXllcldlaWdodCIsInJlc3VtZUxheWVyV2VpZ2h0IiwicGF1c2VMYXllciIsInJlc3VtZUxheWVyIiwiZ2V0VHJhbnNpdGlvbmluZyIsImdldEN1cnJlbnRBbmltYXRpb24iLCJfdXBkYXRlSW50ZXJuYWxXZWlnaHRzIiwiQXhpc01hcCIsIlBvc2l0aXZlWCIsIk5lZ2F0aXZlWCIsIlBvc2l0aXZlWSIsIk5lZ2F0aXZlWSIsIlBvc2l0aXZlWiIsIk5lZ2F0aXZlWiIsIkZhY2VUYXJnZXRUeXBlcyIsIkV5ZUNlbnRlciIsIkV5ZUxlZnQiLCJFeWVSaWdodCIsIk1vdXRoIiwiRmFjZVZlY3RvcnMiLCJNaWNyb1NhY2NhZGVXYWl0UmFuZ2VzIiwicG9zdE1hY3JvIiwiTWFjcm9TYWNjYWRlV2FpdFJhbmdlcyIsIm1vdXRoVGFyZ2V0IiwiZXllVGFyZ2V0IiwiQmxpbmtUaHJlc2hvbGQiLCJNYXhEZWx0YSIsIlBvaW50T2ZJbnRlcmVzdEZlYXR1cmUiLCJ0YXJnZXQiLCJsb29rVHJhY2tlciIsInNjZW5lIiwibG9va0JsZW5kVGltZSIsImxvb2tFYXNpbmdGbiIsImxvb2tMYXllcnMiLCJibGlua0JsZW5kVGltZSIsImJsaW5rRWFzaW5nRm4iLCJibGlua0xheWVycyIsIl92YWxpZGF0ZVRyYW5zZm9ybU9iamVjdCIsIl9sb29rVHJhY2tlciIsIl9zY2VuZSIsIl90YXJnZXQiLCJfcHJldlRhcmdldFBvcyIsIl9pc1RhcmdldE1vdmluZyIsIl9sb29rTGF5ZXJzIiwiX3RyYWNraW5nQ29uZmlncyIsIl9ibGlua0xheWVycyIsInJlZmVyZW5jZSIsImZvcndhcmRBeGlzIiwiaGFzU2FjY2FkZSIsInJlZ2lzdGVyTG9va0xheWVyIiwicmVnaXN0ZXJCbGlua0xheWVyIiwiX3JlZ2lzdGVyTG9va0FuaW1hdGlvbiIsImNvbmZpZyIsInRyYWNraW5nQ29uZmlnIiwiYW5nbGVzIiwiaCIsInByZXZBbmdsZXMiLCJzb3VyY2VQb3NpdGlvbiIsIl9nZXRXb3JsZFBvc2l0aW9uIiwidGFyZ2V0UG9zaXRpb24iLCJsb29rVmVjdG9yIiwidGFyZ2V0UG9zIiwidHJhY2tlclBvcyIsInRhcmdldFNwaGVyaWNhbCIsImNhcnRlc2lhblRvU3BoZXJpY2FsIiwidGFyZ2V0QW5nbGVzIiwiX3NwaGVyaWNhbFRvQmxlbmRWYWx1ZSIsInJlZkRpcmVjdGlvbiIsIl9nZXRPYmplY3REaXJlY3Rpb24iLCJyZWZTcGhlcmljYWwiLCJyZWZBbmdsZXMiLCJ0YXJnZXRUeXBlIiwiZGlzdGFuY2UiLCJfZ2V0VGFyZ2V0RGlzdGFuY2UiLCJmYWNlVmVjdG9yIiwic3BoZXJpY2FsIiwiYmxlbmRWYWx1ZXMiLCJtYXhIU3BlZWQiLCJleHAiLCJtYXhWU3BlZWQiLCJEMCIsImQiLCJoRHVyYXRpb24iLCJ2RHVyYXRpb24iLCJtaWNyb1NhY2NhZGUiLCJfdXBkYXRlTGF5ZXJTcGVlZCIsIl9pbml0aWFsaXplTWljcm9UaW1lciIsIm1hY3JvU2FjY2FkZSIsIm1hY3JvU2FjY2FkZVdhaXRSYW5nZSIsImhMaW1pdCIsImhGYWN0b3IiLCJ2TGltaXQiLCJ2RmFjdG9yIiwic2FjY2FkZVRhcmdldCIsIl9nZXRGYWNlVGFyZ2V0QW5nbGVzIiwiX2luaXRpYWxpemVNYWNyb1RpbWVyIiwibWluV2FpdFRpbWUiLCJtYXhXYWl0VGltZSIsIndhaXRUaW1lIiwibWljcm9TYWNjYWRlVGltZXIiLCJfc2V0TWljcm9TYWNjYWRlIiwibWFjcm9TYWNjYWRlVGltZXIiLCJfc2V0TWFjcm9TYWNjYWRlIiwiX2FkZFRyYWNraW5nQ29uZmlnIiwiaFZlbG9jaXR5IiwidlZlbG9jaXR5IiwiX3NldExvb2tBbmdsZXMiLCJfcmVzZXRMb29rQW5nbGVzIiwiZGVsdGFTZWNvbmRzIiwidHJpZ2dlckJsaW5rIiwiY3VycmVudEgiLCJjdXJyZW50ViIsInRhcmdldEgiLCJ0YXJnZXRWIiwicHJldlRhcmdldEgiLCJwcmV2VGFyZ2V0ViIsImNoYW5nZUFtb3VudCIsInRvRGVncmVlcyIsImdldEFuZ2xlQmV0d2VlbiIsImRhbXBWYWx1ZSIsInNldFRhcmdldCIsInNldFRhcmdldEJ5TmFtZSIsInNldFRhcmdldEJ5SWQiLCJvYmoiLCJmb3J3YXJkVmVjdG9yIiwicm90YXRpb24iLCJnZXRSb3RhdGlvbk1hdHJpeCIsIl9nZXRXb3JsZE1hdHJpeCIsInJvdGF0ZVZlY3RvciIsInRoZXRhIiwicGhpIiwiRWFzaW5nIiwiVGV4dFRvU3BlZWNoVXRpbHMiLCJ0ZXh0IiwicmFuZG9tTWFya3MiLCJpbnRlcm5hbE1hcCIsIl9wcm9jZXNzSW5wdXRNYXAiLCJzcGVha1RhZ3MiLCJzc21sTWFya1JlZ2V4Iiwic3NtbFRhZ1JlZ2V4IiwiZXhpc3RpbmdUYWdzIiwiZXhlYyIsInN0YXJ0IiwiZW5kIiwiY2h1bmtzIiwic3NtbE1hcmtSZXN1bHQiLCJkdXBsaWNhdGVNYXJrVG9DaGVjayIsImV4aXN0aW5nVGFnIiwic3Vic3RyIiwiX2luc2VydE1hcmtzIiwibWFya1RleHQiLCJtYXJrZWRUZXh0Iiwiam9pbiIsImFkZE1hcmtzVG9Vbm1hcmtlZFNlbnRlbmNlcyIsInZhbGlkYXRlVGV4dCIsIm1hcmtzIiwibWFya0luZGljZXMiLCJtYXJrUmVzdWx0Iiwic3NtbFJlc3VsdCIsImNsZWFuZWRUZXh0IiwiZXhpc3RpbmdTc21sIiwid2hpdGVzcGFjZSIsInNlbnRlbmNlRW5kSW5kaWNlcyIsIl9nZXRTZW50ZW5jZUVuZHMiLCJwcmV2SW5kZXgiLCJ0YXJnZXRJbmRpY2VzIiwiY29udGFpbnNNYXJrIiwibWFya0luZGV4IiwicmFuZG9tTWFya2VkVGV4dCIsIl9pbnNlcnRSYW5kb21NYXJrc0F0Iiwib2Zmc2V0IiwicmFuZG9tTWFyayIsInNlbnRlbmNlUmVnZXgiLCJlbmRTZW50ZW5jZVJlZ2V4Iiwic2VudGVuY2VFbmRzIiwicHVuY3RSZXN1bHQiLCJkdXBsaWNhdGVzVG9DaGVjayIsIndvcmRSZWdleCIsImxvd2VyQ2FzZVdvcmQiLCJjaGVja0R1cGxpY2F0ZSIsIm1hcmtlZFdvcmRzIiwidG9Mb3dlckNhc2UiLCJleGlzdGluZ01hcmtzIiwibGlzdCIsImlzQXJyYXkiLCJBYnN0cmFjdFNwZWVjaCIsInNwZWFrZXIiLCJzcGVlY2htYXJrcyIsIl9zcGVha2VyIiwiX3RleHQiLCJfc3BlZWNobWFya3MiLCJfc3BlZWNobWFya09mZnNldCIsIl9zdGFydFRpbWUiLCJfbG9jYWxUaW1lIiwiX3BhdXNlVGltZSIsIl9wbGF5aW5nIiwiX21hcmtJdGVyIiwiX2N1cnJlbnRNYXJrIiwiX2VuZFRpbWUiLCJ0aW1lIiwiX3Byb21pc2UiLCJvbkludGVycnVwdCIsImludGVycnVwdCIsInR5cGUiLCJzcGVlY2giLCJfY2hlY2tGaW5pc2hlZCIsIl9jcmVhdGVQcm9taXNlIiwiU3BlZWNoIiwiYXVkaW9Db25maWciLCJfYXVkaW8iLCJhdWRpbyIsIm9uZW5kZWQiLCJfYXVkaW9GaW5pc2hlZCIsInZvbHVtZSIsInNldFRpbWVvdXQiLCJfcGxheUF1ZGlvIiwiX3BhdXNlQXVkaW8iLCJlbmdpbmVzIiwiYXVkaW9Gb3JtYXRzIiwic3BlZWNobWFya1R5cGVzIiwic2FtcGxlUmF0ZXMiLCJtcDMiLCJyYXRlcyIsImRlZmF1bHRzIiwic3RhbmRhcmQiLCJuZXVyYWwiLCJwY20iLCJvZ2dfdm9yYmlzIiwiYXdzVmVyc2lvbiIsIkFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSIsInZvaWNlIiwiZW5naW5lIiwibGFuZ3VhZ2UiLCJhdWRpb0Zvcm1hdCIsInNhbXBsZVJhdGUiLCJtaW5FbmRNYXJrRHVyYXRpb24iLCJpc0dsb2JhbCIsIl9zcGVlY2hDYWNoZSIsIl9jdXJyZW50U3BlZWNoIiwiX2N1cnJlbnRQcm9taXNlIiwiX2lzVmFsaWRhdGVkIiwiX2lzR2xvYmFsIiwiX3ZvbHVtZVBhdXNlZCIsIl92b2ljZSIsIlBPTExZX0RFRkFVTFRTIiwiVm9pY2VJZCIsIl9sYW5ndWFnZSIsIkxhbmd1YWdlTmFtZSIsIl9lbmdpbmUiLCJFbmdpbmUiLCJfYXVkaW9Gb3JtYXQiLCJPdXRwdXRGb3JtYXQiLCJfc2FtcGxlUmF0ZSIsIlNhbXBsZVJhdGUiLCJfbWluRW5kTWFya0R1cmF0aW9uIiwiQVdTX1ZFUlNJT04iLCJQT0xMWV9NSU5fTkVVUkFMX1ZFUlNJT04iLCJmb3JtYXQiLCJyYXRlIiwidm9pY2VJZCIsIlBPTExZX1ZPSUNFUyIsIklkIiwiU3VwcG9ydGVkRW5naW5lcyIsImxhbmd1YWdlQ29kZSIsIlBPTExZX0xBTkdVQUdFUyIsImF2YWlsYWJsZUNvZGVzIiwiTGFuZ3VhZ2VDb2RlIiwiQWRkaXRpb25hbExhbmd1YWdlQ29kZXMiLCJQT0xMWV9MQU5HVUFHRV9DT0RFUyIsIl92YWxpZGF0ZUVuZ2luZSIsIl92YWxpZGF0ZUZvcm1hdCIsIl92YWxpZGF0ZVJhdGUiLCJfdmFsaWRhdGVWb2ljZSIsIl92YWxpZGF0ZUxhbmd1YWdlIiwiaXNSZWFkeSIsIl92YWxpZGF0ZSIsInNraXBTcGVlY2hlcyIsImN1cnJlbnRDb25maWciLCJfZ2V0Q29uZmlnIiwiY3VycmVudENvbmZpZ1N0ciIsIkxhbmd1YWdlIiwidmFsaWRDb25maWciLCJjb25maWdTdHIiLCJzcGVlY2hDb25maWdTdHIiLCJfdXBkYXRlU3BlZWNoIiwiYXVkaW9QYXJhbXMiLCJUZXh0IiwiVGV4dFR5cGUiLCJzcGVlY2htYXJrUGFyYW1zIiwiU3BlZWNoTWFya1R5cGVzIiwiX3N5bnRoZXNpemVTcGVlY2htYXJrcyIsIl9zeW50aGVzaXplQXVkaW8iLCJyZXN1bHRzIiwiX2NyZWF0ZVNwZWVjaCIsInBhcmFtcyIsInByZXNpZ25lciIsImdldFN5bnRoZXNpemVTcGVlY2hVcmwiLCJ1cmwiLCJwb2xseSIsInN5bnRoZXNpemVTcGVlY2giLCJqc29uU3RyaW5nIiwiQXVkaW9TdHJlYW0iLCJqc29uIiwiZGF0YVN0ciIsImRhdGEiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJtYXJrVHlwZXMiLCJlbmRNYXJrVHlwZXMiLCJzcGVlY2hNYXJrcyIsIm1hdGNoQWxsIiwibnVtTWFya3MiLCJsYXN0TWFyayIsImVuZFRpbWVzIiwiZW5kVGltZSIsIl91cGRhdGVDb25maWciLCJnZXRWb2x1bWUiLCJzZXRWb2x1bWUiLCJwYXVzZVZvbHVtZSIsInJlc3VtZVZvbHVtZSIsIl92b2x1bWUiLCJ2b2x1bWVQZW5kaW5nIiwicGxheWluZyIsImN1cnJlbnRQcm9taXNlIiwiX2dldFNwZWVjaCIsIl9zZXRDdXJyZW50U3BlZWNoIiwiX3N0YXJ0U3BlZWNoIiwidmVyc2lvbiIsImN1c3RvbVVzZXJBZ2VudCIsIl93aXRoQ3VzdG9tVXNlckFnZW50Iiwic2VydmljZSIsIl9pc1JlYWR5IiwiYXZhaWxhYmxlVm9pY2VzIiwiYXZhaWxhYmxlTGFuZ3VhZ2VzIiwiYXZhaWxhYmxlTGFuZ3VhZ2VDb2RlcyIsIm1pbk5ldXJhbFNkayIsImRlc2NyaWJlVm9pY2VzIiwicmVzcG9uc2UiLCJhbGxDb2RlcyIsIlZvaWNlcyIsImNvZGUiLCJyZWFkeSIsImN1cnJlbnRVc2VyQWdlbnQiLCJzdW1lcmlhbkhvc3RzVXNlckFnZW50IiwiY29uY2F0IiwiTGV4aWNvbk5hbWVzIiwiX2VuYWJsZWQiLCJfc2V0QXVkaW9Db250ZXh0IiwiX29ic2VydmVBdWRpb0NvbnRleHQiLCJfYXVkaW9Db250ZXh0IiwiQXVkaW9Db250ZXh0Iiwib25zdGF0ZWNoYW5nZSIsIkF1ZGlvIiwibG9vcCIsImNyb3NzT3JpZ2luIiwicHJlbG9hZCIsImRvY3VtZW50IiwiYm9keSIsImFwcGVuZENoaWxkIiwibG9hZCIsInJlc3VtZUF1ZGlvIiwiZW5hYmxlZCIsImFuaW1wYWNrIiwiYXdzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///437\n')}},__webpack_require__={d:(e,t)=>{for(var n in t)__webpack_require__.o(t,n)&&!__webpack_require__.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},__webpack_exports__={};return __webpack_modules__[437](0,__webpack_exports__,__webpack_require__),__webpack_exports__=__webpack_exports__.default,__webpack_exports__})()}));