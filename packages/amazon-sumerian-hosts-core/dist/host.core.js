/*! For license information please see host.core.js.LICENSE.txt */
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("HOST",[],t):"object"==typeof exports?exports.HOST=t():e.HOST=t()}("undefined"!=typeof self?self:"undefined"!=typeof global?global:this,(function(){return(()=>{"use strict";var __webpack_modules__={437:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "default": () => (/* binding */ core)\n});\n\n;// CONCATENATED MODULE: ./src/core/Deferred.js\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\n * The built-in class for asynchronous Promises.\n * @external Promise\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\n */\n\n/**\n * A Promise object that can be resolved, rejected or canceled at any time by the\n * user.\n *\n * @extends external:Promise\n */\nvar Deferred = /*#__PURE__*/function (_Promise) {\n  _inherits(Deferred, _Promise);\n\n  var _super = _createSuper(Deferred);\n\n  /**\n   * @constructor\n   *\n   * @param {Function} [executable=() => {}] - The function to be executed by the\n   * constructor, during the process of constructing the promise. The signature\n   * of this is expected to be: executable(  resolutionFunc, rejectionFunc, cancellationFunc ).\n   * @param {Function=} onResolve - Optional function to execute once the promise\n   * is resolved.\n   * @param {Function=} onReject - Optional function to execute once the promise\n   * is rejected.\n   * @param {Function=} onCancel - Optional function to execute if the user cancels\n   * the promise. Canceling results in the promise having a status of \'resolved\'.\n   */\n  function Deferred() {\n    var _this;\n\n    var executable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n    var onResolve = arguments.length > 1 ? arguments[1] : undefined;\n    var onReject = arguments.length > 2 ? arguments[2] : undefined;\n    var onCancel = arguments.length > 3 ? arguments[3] : undefined;\n\n    _classCallCheck(this, Deferred);\n\n    if (typeof executable !== \'function\') {\n      throw new Error("Cannot create new Deferred. Executable must be a function.");\n    }\n\n    if (typeof onResolve !== \'undefined\' && typeof onResolve !== \'function\') {\n      throw new Error("Cannot create new Deferred. OnResolve must be a function.");\n    }\n\n    if (typeof onReject !== \'undefined\' && typeof onReject !== \'function\') {\n      throw new Error("Cannot create new Deferred. OnReject must be a function.");\n    }\n\n    if (typeof onCancel !== \'undefined\' && typeof onCancel !== \'function\') {\n      throw new Error("Cannot create new Deferred. OnCancel must be a function.");\n    }\n\n    var res;\n    var rej;\n    var cancel;\n    var status = {\n      resolved: false,\n      rejected: false,\n      canceled: false,\n      pending: true\n    };\n    _this = _super.call(this, function (resolve, reject) {\n      // Store the resolver\n      res = function res(value) {\n        if (status.pending) {\n          status.resolved = true;\n          status.pending = false;\n\n          if (typeof onResolve === \'function\') {\n            value = onResolve(value);\n          }\n\n          return resolve(value);\n        }\n      }; // Store the rejecter\n\n\n      rej = function rej(value) {\n        if (status.pending) {\n          status.rejected = true;\n          status.pending = false;\n\n          if (typeof onReject === \'function\') {\n            value = onReject(value);\n          }\n\n          return reject(value);\n        }\n      }; // Store the canceler\n\n\n      cancel = function cancel(value) {\n        if (status.pending) {\n          status.canceled = true;\n          status.pending = false;\n\n          if (typeof onCancel === \'function\') {\n            value = onCancel(value);\n          }\n\n          return resolve(value);\n        }\n      }; // Run the executable with custom resolver and rejecter\n\n\n      executable(res, rej, cancel);\n    });\n    _this._status = status;\n    _this._resolve = res;\n    _this._reject = rej;\n    _this._cancel = cancel;\n    _this._executable = executable;\n    return _this;\n  }\n  /**\n   * Gets the resolved state of the promise.\n   *\n   * @readonly\n   */\n\n\n  _createClass(Deferred, [{\n    key: "resolved",\n    get: function get() {\n      return this._status.resolved;\n    }\n    /**\n     * Gets the rejected state of the promise.\n     *\n     * @readonly\n     */\n\n  }, {\n    key: "rejected",\n    get: function get() {\n      return this._status.rejected;\n    }\n    /**\n     * Gets the canceled state of the promise.\n     *\n     * @readonly\n     */\n\n  }, {\n    key: "canceled",\n    get: function get() {\n      return this._status.canceled;\n    }\n    /**\n     * Gets the pending state of the promise.\n     *\n     * @readonly\n     */\n\n  }, {\n    key: "pending",\n    get: function get() {\n      return this._status.pending;\n    }\n    /**\n     * Force the promise to resolve.\n     *\n     * @param {any=} value - Value to pass to the resolver.\n     *\n     * @returns {any} - The return value of the resolver function.\n     */\n\n  }, {\n    key: "resolve",\n    value: function resolve(value) {\n      return this._resolve(value);\n    }\n    /**\n     * Force the promise to reject.\n     *\n     * @param {any=} value - Value to pass to the rejecter.\n     *\n     * @returns {any} - The return value of the rejecter function.\n     */\n\n  }, {\n    key: "reject",\n    value: function reject(value) {\n      return this._reject(value);\n    }\n    /**\n     * Force the promise to resolve and set the canceled state to true.\n     *\n     * @param {any=} value - Value to pass to the canceller.\n     *\n     * @returns {any} - The return value of the canceller function.\n     */\n\n  }, {\n    key: "cancel",\n    value: function cancel(value) {\n      return this._cancel(value);\n    }\n    /**\n     * Run the promise function to try to resolve the promise. Promise must be\n     * pending.\n     *\n     * @param {...any} args - Optional arguments to pass after resolve and reject.\n     */\n\n  }, {\n    key: "execute",\n    value: function execute() {\n      if (this.pending) {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        this._executable.apply(this, [this._resolve, this._reject, this._cancel].concat(args));\n      }\n    }\n    /**\n     * Return a canceled deferred promise.\n     *\n     * @param {any=} value - Value to cancel the promise with.\n     *\n     * @returns {Deferred}\n     */\n\n  }], [{\n    key: "cancel",\n    value: function cancel(value) {\n      return new Deferred(function (_resolve, _reject, cancel) {\n        cancel(value);\n      });\n    }\n    /**\n     * Return a new Deferred promise that will resolve or reject once all promises\n     * in the input array have been resolved or one promise is canceled or rejected.\n     * Promises in the array that are Deferred promises will be manually resolved,\n     * rejected or canceled when calling resolve, reject or cancel on the return promise.\n     *\n     * @param {Array.<any>} iterable - An iterable such as an array.\n     * @param {Function=} onResolve - Optional function to execute once the promise\n     * is resolved.\n     * @param {Function=} onReject - Optional function to execute once the promise\n     * is rejected.\n     * @param {Function=} onCancel - Optional function to execute if the user cancels\n     * the promise. Canceling results in the promise having a status of \'canceled\'.\n     *\n     * @returns Deferred\n     */\n\n  }, {\n    key: "all",\n    value: function all(iterable, onResolve, onReject, onCancel) {\n      if (iterable == null || typeof iterable[Symbol.iterator] !== \'function\') {\n        var e = "Cannot execute Deferred.all. First argument must be iterable.";\n\n        if (typeof onReject === \'function\') {\n          e = onReject(e);\n        }\n\n        return Deferred.reject(e);\n      }\n\n      var array = _toConsumableArray(iterable);\n\n      var deferred = array.filter(function (item) {\n        return item instanceof Deferred;\n      });\n      var result = new Deferred(undefined, function (resolveValue) {\n        deferred.forEach(function (item) {\n          item.resolve(resolveValue);\n        });\n        deferred.length = 0;\n\n        if (typeof onResolve === \'function\') {\n          return onResolve(resolveValue);\n        } else {\n          return resolveValue;\n        }\n      }, function (error) {\n        deferred.forEach(function (item) {\n          item.reject(error);\n        });\n        deferred.length = 0;\n\n        if (typeof onReject === \'function\') {\n          return onReject(error);\n        } else {\n          return error;\n        }\n      }, function (cancelValue) {\n        deferred.forEach(function (item) {\n          item.cancel(cancelValue);\n        });\n        deferred.length = 0;\n\n        if (typeof onCancel === \'function\') {\n          return onCancel(cancelValue);\n        } else {\n          return cancelValue;\n        }\n      });\n      var numItems = array.length;\n      var itemTracker = {\n        failed: false,\n        numResolved: 0,\n        resolutions: []\n      };\n      array.forEach(function (item, index) {\n        if (itemTracker.failed) {\n          return;\n        } else if (!(item instanceof Promise)) {\n          itemTracker.resolutions[index] = item;\n          itemTracker.numResolved += 1;\n\n          if (itemTracker.numResolved === numItems) {\n            result.resolve(itemTracker.resolutions);\n          }\n\n          return;\n        }\n\n        item.then(function (value) {\n          if (!itemTracker.failed && !item.canceled) {\n            itemTracker.resolutions[index] = value;\n            itemTracker.numResolved += 1;\n\n            if (itemTracker.numResolved === numItems) {\n              result.resolve(itemTracker.resolutions);\n            }\n          } else if (!itemTracker.failed) {\n            itemTracker.failed = true;\n            result.cancel(value);\n          }\n        }, function (error) {\n          if (!itemTracker.failed) {\n            itemTracker.failed = true;\n            result.reject(error);\n          }\n        });\n      });\n      return result;\n    }\n  }]);\n\n  return Deferred;\n}( /*#__PURE__*/_wrapNativeSuper(Promise));\n\n/* harmony default export */ const core_Deferred = (Deferred);\n;// CONCATENATED MODULE: ./src/core/Utils.js\nfunction Utils_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Utils_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Utils_createClass(Constructor, protoProps, staticProps) { if (protoProps) Utils_defineProperties(Constructor.prototype, protoProps); if (staticProps) Utils_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\n * A collection of useful generic functions.\n *\n * @hideconstructor\n */\n\nvar Utils = /*#__PURE__*/function () {\n  function Utils() {\n    Utils_classCallCheck(this, Utils);\n  }\n\n  Utils_createClass(Utils, null, [{\n    key: "createId",\n    value:\n    /**\n     * @static\n     *\n     * Generate a unique id\n     *\n     * @returns {String}\n     */\n    function createId() {\n      return \'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx\'.replace(/[xy]/g, function (c) {\n        var randomNumber = Math.floor((Date.now() + Math.random() * 16) % 16);\n\n        if (c === \'x\') {\n          return randomNumber.toString(16);\n        } // Set bit 6 and 7 to 0 and 1\n\n\n        return (randomNumber & 0x3 | 0x8).toString(16);\n      });\n    }\n    /**\n     * @static\n     *\n     * Check a name string against an array of strings to determine if it is unique.\n     * If it isn\'t, append incremented trailing integers to the end of the name\n     * until it is unique.\n     *\n     * @param {string} name - String name to make unique.\n     * @param {Array.<string>=} nameArray - Array of string names to check agains.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: "getUniqueName",\n    value: function getUniqueName(name) {\n      var nameArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n      // If the name isn\'t in the array return it right away\n      if (!nameArray.includes(name)) {\n        return name;\n      }\n\n      var nameSet = new Set(nameArray); // Separate the name into string and trailing numbers\n\n      var matchGroup = name.match(/\\d*$/);\n      var index = matchGroup.index;\n      var baseName = name.slice(0, index);\n      var increment = Number(matchGroup[0]); // Find the highest trailing number value for the base of the name\n\n      nameSet.forEach(function (setName) {\n        var setMatchGroup = setName.match(/\\d*$/);\n\n        if (setName.slice(0, setMatchGroup.index) === baseName) {\n          var setIncrement = Number(setMatchGroup[0]);\n\n          if (setIncrement > increment) {\n            increment = setIncrement;\n          }\n        }\n      }); // Increment the highest trailing number and append to the name\n\n      return "".concat(baseName).concat(increment + 1);\n    }\n    /**\n     * Return a deferred promise that will wait a given number of seconds before\n     * resolving. Pass delta time in milliseconds to the deferred promise\'s execute\n     * method in an update loop to progress time.\n     *\n     * @param {number} [seconds=0] - Number of seconds to wait before resolving.\n     * @param {Object=} options - Optional options object\n     * @param {Function} [options.onFinish] - Callback to execute once the wait time\n     * is met.\n     * @param {Function=} options.onProgress - Callback to execute each time the wait\n     * time progresses towards the target number of seconds. The amount of progress\n     * as a 0-1 percentage is passed as an argument.\n     * @param {Function=} options.onCancel - Callback to execute if the user cancels\n     * the wait before completion.\n     * @param {Function=} options.onError - Callback to execute if the wait stops\n     * because an error is encountered. The error message is passed as a parameter.\n     *\n     * @returns {Deferred}\n     */\n\n  }, {\n    key: "wait",\n    value: function wait() {\n      var seconds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          onFinish = _ref.onFinish,\n          onProgress = _ref.onProgress,\n          onCancel = _ref.onCancel,\n          onError = _ref.onError;\n\n      // Make sure seconds is numeric\n      if (typeof seconds !== \'number\') {\n        console.warn("Invalid seconds value ".concat(seconds, " for wait. Defaulting to 0."));\n        seconds = 0;\n      } // Resolve immediately if the wait time is not greater than 0\n\n\n      if (seconds <= 0) {\n        if (typeof onFinish === \'function\') {\n          onFinish();\n        }\n\n        return core_Deferred.resolve();\n      }\n\n      var currentTime = 0;\n      var totalTime = seconds * 1000; // convert to milliseconds\n      // Executable to pass to Deferred, meant to be run in an update loop\n\n      var onUpdate = function onUpdate(resolve, reject, _cancel) {\n        var deltaTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n        if (typeof deltaTime !== \'number\') {\n          var e = new Error("Invalid property wait deltaTime. DeltaTime must be a number.");\n          reject(e);\n          return;\n        } // Make sure time has passed\n\n\n        if (deltaTime === 0) {\n          return;\n        } // Signal progress\n\n\n        currentTime += deltaTime;\n\n        if (currentTime < 0) {\n          currentTime = 0;\n        }\n\n        if (typeof onProgress === \'function\') {\n          onProgress(Math.min(currentTime / totalTime, 1));\n        } // Signal completion once time is up\n\n\n        if (currentTime >= totalTime) {\n          resolve();\n        }\n      };\n\n      return new core_Deferred(onUpdate, onFinish, onError, onCancel);\n    }\n    /**\n     * Get a random float number between a min (inclusive) and max (exclusive) value\n     * @param {number} min minimum value\n     * @param {number} max maximum value\n     * @returns {float}\n     */\n\n  }, {\n    key: "getRandomFloat",\n    value: function getRandomFloat(min, max) {\n      return Math.random() * (max - min) + min;\n    }\n    /**\n     * Get a random integer number between a min (inclusive) and max (exclusive) value\n     * @param {number} min minimum value\n     * @param {number} max maximum value\n     * @returns {integer}\n     */\n\n  }, {\n    key: "getRandomInt",\n    value: function getRandomInt(min, max) {\n      min = Math.ceil(min);\n      max = Math.floor(max);\n      return Math.floor(Math.random() * (max - min)) + min;\n    }\n  }]);\n\n  return Utils;\n}();\n\n/* harmony default export */ const core_Utils = (Utils);\n;// CONCATENATED MODULE: ./src/core/MathUtils.js\nfunction MathUtils_toConsumableArray(arr) { return MathUtils_arrayWithoutHoles(arr) || MathUtils_iterableToArray(arr) || MathUtils_unsupportedIterableToArray(arr) || MathUtils_nonIterableSpread(); }\n\nfunction MathUtils_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction MathUtils_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return MathUtils_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return MathUtils_arrayLikeToArray(o, minLen); }\n\nfunction MathUtils_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction MathUtils_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return MathUtils_arrayLikeToArray(arr); }\n\nfunction MathUtils_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction MathUtils_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction MathUtils_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction MathUtils_createClass(Constructor, protoProps, staticProps) { if (protoProps) MathUtils_defineProperties(Constructor.prototype, protoProps); if (staticProps) MathUtils_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\nvar RadianToDegree = 180 / Math.PI;\nvar DegreeToRadian = Math.PI / 180;\n/**\n * A collection of useful math functions.\n *\n * @hideconstructor\n */\n\nvar MathUtils = /*#__PURE__*/function () {\n  function MathUtils() {\n    MathUtils_classCallCheck(this, MathUtils);\n  }\n\n  MathUtils_createClass(MathUtils, null, [{\n    key: "toDegrees",\n    value:\n    /**\n     * Convert the given angle from radians to degrees.\n     *\n     * @param {number} radians - Angle in radians.\n     *\n     * @returns {number} - Angle in degrees.\n     */\n    function toDegrees(radians) {\n      return radians * RadianToDegree;\n    }\n    /**\n     * Convert the given angle from degrees to radians.\n     *\n     * @param {number} degrees - Angle in degrees.\n     *\n     * @returns {number} - Angle in radians.\n     */\n\n  }, {\n    key: "toRadians",\n    value: function toRadians(degrees) {\n      return degrees * DegreeToRadian;\n    }\n    /**\n     * Linearly interpolate between two values.\n     *\n     * @param {number} from - Start value.\n     * @param {number} to - Target value.\n     * @param {number} factor - 0-1 amount to interpolate between from and to.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: "lerp",\n    value: function lerp(from, to, factor) {\n      return from + (to - from) * factor;\n    }\n    /**\n     * Clamp a number between 2 values.\n     *\n     * @param {number} value - Value to clamp.\n     * @param {number} [min=0] - Minumum value.\n     * @param {number} [max=1] - Maximum value.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: "clamp",\n    value: function clamp(value) {\n      var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      return Math.max(min, Math.min(value, max));\n    }\n    /**\n     * Calculates the closest point on a given 2D line segement\n     * from a given 2D point.\n     *\n     * @param {Array.<number>} a - First point on line segment.\n     * @param {Array.<number>} b - Second point on line segment.\n     * @param {Array.<number>} p - 2D point.\n     *\n     * @returns {Array.<number>}\n     */\n\n  }, {\n    key: "closestPointOnLine",\n    value: function closestPointOnLine(a, b, p) {\n      var distSqr = MathUtils.distanceSquared(a, b); // Line segment is a single point\n\n      if (distSqr === 0) {\n        return a;\n      }\n\n      var t = ((p[0] - a[0]) * (b[0] - a[0]) + (p[1] - a[1]) * (b[1] - a[1])) / distSqr;\n\n      var point = MathUtils_toConsumableArray(a);\n\n      if (t > 1) {\n        point = MathUtils_toConsumableArray(b);\n      } else if (t > 0) {\n        point = [a[0] + t * (b[0] - a[0]), a[1] + t * (b[1] - a[1])];\n      }\n\n      return point;\n    }\n    /**\n     * Gets the distance squared for two 2D points.\n     * @param {Array.<number>} a - 2D point.\n     * @param {Array.<number>} b - 2D point.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: "distanceSquared",\n    value: function distanceSquared(a, b) {\n      return (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]);\n    }\n    /**\n     * Triangulates a set of 2D points using an implementation\n     * of the Bowyer-Watson incremental Delaunay triangulation.\n     *\n     * @param {Array.<Array.<number>>} vertices - Array of 2D points.\n     *\n     * @returns {Array.<Array<number>>} - Array of triangle indices.\n     */\n\n  }, {\n    key: "getDelaunayTriangulation",\n    value: function getDelaunayTriangulation(vertices) {\n      if (!vertices || vertices.length < 3) {\n        throw new Error("Cannot get delaunay triangulation for points ".concat(vertices, ". Input must contain at least three points."));\n      }\n\n      var minX = Number.POSITIVE_INFINITY;\n      var minY = Number.POSITIVE_INFINITY;\n      var maxX = Number.NEGATIVE_INFINITY;\n      var maxY = Number.NEGATIVE_INFINITY;\n      vertices.forEach(function (v) {\n        minX = v[0] < minX ? v[0] : minX;\n        minY = v[1] < minY ? v[1] : minY;\n        maxX = v[0] > maxX ? v[0] : maxX;\n        maxY = v[1] > maxY ? v[1] : maxY;\n      });\n      var dX = maxX - minX;\n      var dY = maxY - minY;\n      var midX = (minX + maxX) / 2;\n      var midY = (minY + maxY) / 2;\n      var dMax = dX > dY ? dX : dY;\n      var superIndices = [vertices.length, vertices.length + 1, vertices.length + 2];\n      var vertsWithSuper = [].concat(MathUtils_toConsumableArray(vertices), [[midX - 20 * dMax, midY - dMax], [midX, midY + 20 * dMax], [midX + 20 * dMax, midY - dMax]]);\n      var superSortedIndices = MathUtils.sortPointsCCW(superIndices, vertsWithSuper);\n      var superTriangle = {\n        indices: superSortedIndices,\n        edges: [[superSortedIndices[0], superSortedIndices[1]], [superSortedIndices[1], superSortedIndices[2]], [superSortedIndices[2], superSortedIndices[0]]]\n      };\n      var triangles = [superTriangle];\n      vertsWithSuper.forEach(function (newVert, newIndex) {\n        var invalidTriangles = [];\n        triangles.forEach(function (triangle) {\n          if (MathUtils.isPointInCircumCircle(vertsWithSuper[triangle.indices[0]], vertsWithSuper[triangle.indices[1]], vertsWithSuper[triangle.indices[2]], newVert)) {\n            invalidTriangles.push(triangle);\n          }\n        });\n        var boundingPoly = [];\n        invalidTriangles.forEach(function (triangle) {\n          triangle.edges.forEach(function (edge) {\n            var count = 0;\n            invalidTriangles.forEach(function (otherTriangle) {\n              if (triangle !== otherTriangle) {\n                otherTriangle.edges.forEach(function (otherEdge) {\n                  if (edge[0] === otherEdge[0] && edge[1] === otherEdge[1] || edge[1] === otherEdge[0] && edge[0] === otherEdge[1]) {\n                    count += 1;\n                  }\n                });\n              }\n            });\n            if (count === 0) boundingPoly.push(edge);\n          });\n        });\n        invalidTriangles.forEach(function (triangle) {\n          triangles.splice(triangles.indexOf(triangle), 1);\n        });\n        boundingPoly.forEach(function (edge) {\n          var sortedIndices = MathUtils.sortPointsCCW([edge[0], edge[1], newIndex], vertsWithSuper);\n          triangles.push({\n            indices: sortedIndices,\n            edges: [[sortedIndices[0], sortedIndices[1]], [sortedIndices[1], sortedIndices[2]], [sortedIndices[2], sortedIndices[0]]]\n          });\n        });\n      });\n      var trianglesToRemove = [];\n      triangles.forEach(function (triangle) {\n        triangle.indices.forEach(function (index) {\n          if (superIndices.includes(index)) {\n            trianglesToRemove.push(triangle);\n          }\n        });\n      });\n      trianglesToRemove.forEach(function (triangle) {\n        var index = triangles.indexOf(triangle);\n\n        if (index !== -1) {\n          triangles.splice(index, 1);\n        }\n      });\n      return triangles.map(function (triangle) {\n        return triangle.indices;\n      });\n    }\n    /**\n     * Determines if a given 2D point is within the cicrumcircle\n     * defined by three 2D points. The triangle points must be in\n     * counter-clockwise order a -> b -> c.\n     *\n     * @param {Array.<number>} a - First triangle point.\n     * @param {Array.<number>} b - Second triangle point.\n     * @param {Array.<number>} c - Third triangle point.\n     * @param {Array.<number>} p - 2D point.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "isPointInCircumCircle",\n    value: function isPointInCircumCircle(a, b, c, p) {\n      var ax = a[0] - p[0];\n      var ay = a[1] - p[1];\n      var bx = b[0] - p[0];\n      var by = b[1] - p[1];\n      var cx = c[0] - p[0];\n      var cy = c[1] - p[1];\n      return (ax * ax + ay * ay) * (bx * cy - cx * by) - (bx * bx + by * by) * (ax * cy - cx * ay) + (cx * cx + cy * cy) * (ax * by - bx * ay) > 0;\n    }\n    /**\n     * Determines if a given 2D point is within a given triangle.\n     *\n     * @param {Array.<number>} a - First triangle point.\n     * @param {Array.<number>} b - Second triangle point.\n     * @param {Array.<number>} c - Third triangle point.\n     * @param {Array.<number>} p - 2D point.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "isPointInTriangle",\n    value: function isPointInTriangle(a, b, c, p) {\n      var denom = (b[1] - c[1]) * (a[0] - c[0]) + (c[0] - b[0]) * (a[1] - c[1]);\n      var aVal = ((b[1] - c[1]) * (p[0] - c[0]) + (c[0] - b[0]) * (p[1] - c[1])) / denom;\n      var bVal = ((c[1] - a[1]) * (p[0] - c[0]) + (a[0] - c[0]) * (p[1] - c[1])) / denom;\n      var cVal = 1 - aVal - bVal;\n      return aVal >= 0 && aVal <= 1 && bVal >= 0 && bVal <= 1 && cVal >= 0 && cVal <= 1;\n    }\n    /**\n     * Gets the sorted indices of a given set of 2D points in\n     * counter-clockwise order.\n     *\n     * @param {Array.<number>} indices - List of indices.\n     * @param {Array.<Array.<number>>} vertices - List of 2D points.\n     *\n     * @returns {Array.<Array.<number>>} - List of sorted indices.\n     */\n\n  }, {\n    key: "sortPointsCCW",\n    value: function sortPointsCCW(indices, vertices) {\n      var centroid = [0, 0];\n      indices.forEach(function (index) {\n        centroid[0] += vertices[index][0];\n        centroid[1] += vertices[index][1];\n      });\n      centroid[0] /= indices.length;\n      centroid[1] /= indices.length;\n      indices.sort(function (a, b) {\n        var bVal = Math.atan2(vertices[b][1] - centroid[1], vertices[b][0] - centroid[0]);\n        var aVal = Math.atan2(vertices[a][1] - centroid[1], vertices[a][0] - centroid[0]);\n        return aVal - bVal;\n      });\n      return indices;\n    }\n    /**\n     * Cacluates the area of a triangle\n     * @param {Array.<number>} a - First triangle point.\n     * @param {Array.<number>} b - Second triangle point.\n     * @param {Array.<number>} c - Third triangle point.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: "triangleArea",\n    value: function triangleArea(a, b, c) {\n      return Math.abs((a[0] * (b[1] - c[1]) + b[0] * (c[1] - a[1]) + c[0] * (a[1] - b[1])) * 0.5);\n    }\n    /**\n     * Return the magnitude of a given vector array.\n     *\n     * @param {Array.<number>} vector - Array consisting of numbers.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: "getVectorMagnitude",\n    value: function getVectorMagnitude(vector) {\n      if (!(vector instanceof Array)) {\n        throw new Error("Cannot get magnitude for vector ".concat(vector, ". Input must be an Array numbers."));\n      }\n\n      var reducer = function reducer(accumulator, currentValue) {\n        if (typeof currentValue !== \'number\') {\n          throw new Error("Cannot get magnitude for vector ".concat(vector, ". All items in the input Array must be numbers."));\n        }\n\n        return accumulator + Math.pow(currentValue, 2);\n      };\n\n      return Math.sqrt(vector.reduce(reducer, 0));\n    }\n    /**\n     * Return the dot product between two vectors.\n     *\n     * @param {Array.<number>} vectorA - Array consisting of numbers.\n     * @param {Array.<number>} vectorB - Array consisting of numbers.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: "getDotProduct",\n    value: function getDotProduct(vectorA, vectorB) {\n      if (!(vectorA instanceof Array) || !(vectorB instanceof Array) || vectorA.length !== vectorB.length) {\n        throw new Error("Cannot get dot product between ".concat(vectorA, " and ").concat(vectorB, ". Inputs must be vectors of the same length."));\n      }\n\n      var result = 0;\n      vectorA.forEach(function (valueA, index) {\n        var valueB = vectorB[index];\n\n        if (typeof valueA !== \'number\' || typeof valueB !== \'number\') {\n          throw new Error("Cannot get dot product between ".concat(vectorA, " and ").concat(vectorB, ". Vectors must only consist of numeric values."));\n        }\n\n        result += valueA * valueB;\n      });\n      return result;\n    }\n    /**\n     * Return the angle in radians between vectorA and vectorB.\n     *\n     * @param {Array.<number>} vectorA - Array consisting of numbers.\n     * @param {Array.<number>} vectorB - Array consisting of numbers.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: "getAngleBetween",\n    value: function getAngleBetween(vectorA, vectorB) {\n      var normalA = this.normalizeVector(MathUtils_toConsumableArray(vectorA));\n      var normalB = this.normalizeVector(MathUtils_toConsumableArray(vectorB));\n      var dot = this.getDotProduct(normalA, normalB);\n      return Math.acos(this.clamp(dot, -1, 1));\n    }\n    /**\n     * Multiply a 3x3 rotation matrix with a vector3.\n     *\n     * @param {Array.<number>} vector3 - Array consisting of 3 numbers representing\n     * a direction vector.\n     * @param {Array.<number>} matrix3 - An array of 9 numbers representing a row\n     * major rotation matrix.\n     *\n     * @returns {Array.<number>} - An array of 3 numbers representing the new direction\n     * of the vector.\n     */\n\n  }, {\n    key: "rotateVector",\n    value: function rotateVector(vector3, matrix3) {\n      if (!(vector3 instanceof Array) || vector3.length !== 3 || !vector3.every(function (v) {\n        return typeof v === \'number\';\n      })) {\n        throw new Error("Cannot rotate vector ".concat(vector3, " by rotation matrix ").concat(matrix3, ". Input vector must be an array of 3 numbers."));\n      }\n\n      if (!(matrix3 instanceof Array) || matrix3.length !== 9 || !matrix3.every(function (v) {\n        return typeof v === \'number\';\n      })) {\n        throw new Error("Cannot rotate vector ".concat(vector3, " by rotation matrix ").concat(matrix3, ". Input matrix3 must be an array of 9 numbers."));\n      }\n\n      var x = matrix3[0] * vector3[0] + matrix3[3] * vector3[1] + matrix3[6] * vector3[2];\n      var y = matrix3[1] * vector3[0] + matrix3[4] * vector3[1] + matrix3[7] * vector3[2];\n      var z = matrix3[2] * vector3[0] + matrix3[5] * vector3[1] + matrix3[8] * vector3[2];\n      return [x, y, z];\n    }\n    /**\n     * Normalize a given vector array.\n     *\n     * @param {Array.<number>} vector - Array consisting of numbers.\n     *\n     * @returns {Array.<number>} The original vector with normalized values, for chaining.\n     */\n\n  }, {\n    key: "normalizeVector",\n    value: function normalizeVector(vector) {\n      var magnitude = this.getVectorMagnitude(vector);\n\n      if (magnitude === 0) {\n        vector.fill(0);\n      } else {\n        vector.forEach(function (value, index) {\n          vector[index] = value / magnitude;\n        });\n      }\n\n      return vector;\n    }\n    /**\n     * Extract the 3x3 rotation matrix from a given 4x4 transformation matrix.\n     *\n     * @param {Array.<number>} matrix4 - An array of 16 numbers representing a row\n     * major transformation matrix.\n     *\n     * @returns {Array.<number>} - An array of 9 numbers representing a row major\n     * rotation matrix.\n     */\n\n  }, {\n    key: "getRotationMatrix",\n    value: function getRotationMatrix(matrix4) {\n      if (!(matrix4 instanceof Array) || matrix4.length !== 16 || !matrix4.every(function (v) {\n        return typeof v === \'number\';\n      })) {\n        throw new Error("Cannot convert matrix ".concat(matrix4, " to a rotation matrix. Input matrix must be an array of 16 numbers."));\n      } // Extract scale\n\n\n      var scaleX = 1 / (this.getVectorMagnitude(matrix4.slice(0, 4)) || 1);\n      var scaleY = 1 / (this.getVectorMagnitude(matrix4.slice(4, 8)) || 1);\n      var scaleZ = 1 / (this.getVectorMagnitude(matrix4.slice(8, 12)) || 1);\n      return [matrix4[0] * scaleX, matrix4[1] * scaleX, matrix4[2] * scaleX, matrix4[4] * scaleY, matrix4[5] * scaleY, matrix4[6] * scaleY, matrix4[8] * scaleZ, matrix4[9] * scaleZ, matrix4[10] * scaleZ];\n    }\n    /**\n     * Return an array containing the spherical coordinates of the given cartesian\n     * xyz coordinates.\n     *\n     * @private\n     *\n     * @param {number} x - Position along the x axis.\n     * @param {number} y - Position along the y axis.\n     * @param {number} z - Position along the z axis.\n     *\n     * @returns {Array.<number>} - An array consisting of three numberes where index\n     * 0 represents the radius, index 1 represents the vertical/polar angle in radians\n     * and index 2 represents the horizontal/azimuthal angle in radians.\n     */\n\n  }, {\n    key: "cartesianToSpherical",\n    value: function cartesianToSpherical(x, y, z) {\n      var r = this.getVectorMagnitude([x, y, z]); // Return identity if the vector has no length\n\n      if (r === 0) {\n        return [0, 0, 0];\n      }\n\n      return [r, Math.acos(this.clamp(y / r, -1, 1)), Math.atan2(x, z)];\n    }\n    /**\n     * Gradually change a value of a numeric property towards a goal over time using\n     * a critically damped spring function.\n     *\n     * @param {number} currentValue - The starting value.\n     * @param {number} targetValue- The goal value.\n     * @param {Array.<number>} [valueStore = [0, 0]] - An Array consisting of two\n     * numbers where the first number holds the result value and the second holds\n     * the velocity that resulted in that value. The same array should be provided\n     * with each call to this function.\n     * @param {number} [deltaTime = 1e-7] - The time since the last call to this function\n     * in seconds.\n     * @param {number} [smoothTime = 0.3] - The approximate amount of time in seconds\n     * it should take to reach the target value.\n     * @param {number} [maxSpeed = 1e7] - A clamping value for the maximum speed the\n     * value can change.\n     *\n     * @returns {Array.<number>} - The valueStore array.\n     */\n\n  }, {\n    key: "dampValue",\n    value: function dampValue(currentValue, targetValue) {\n      var valueStore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0];\n      var deltaTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1e-7;\n      var smoothTime = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.3;\n      var maxSpeed = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1e7;\n      smoothTime = Math.max(0.0001, smoothTime);\n      deltaTime = Math.max(1e-7, deltaTime); // Find the delta between values and use it to estimate the previous value\n\n      var clampTime = maxSpeed * smoothTime;\n      var deltaValue = currentValue - targetValue;\n      var clampDeltaValue = this.clamp(deltaValue, -clampTime, clampTime);\n      var lastValue = currentValue - clampDeltaValue; // Calculate damping factors\n\n      var d1 = 2 / smoothTime;\n      var d2 = d1 * deltaTime;\n      var d3 = 1 / (1 + d2 + 0.5 * Math.pow(d2, 2) + 0.25 * Math.pow(d2, 3));\n      var d4 = (valueStore[1] + d1 * clampDeltaValue) * deltaTime; // Damp the target value and update the velocity\n\n      valueStore[0] = lastValue + (clampDeltaValue + d4) * d3;\n      valueStore[1] = (valueStore[1] - d1 * d4) * d3; // Prevent overshooting\n\n      if (targetValue - currentValue > 0 === valueStore[0] > targetValue) {\n        valueStore[0] = targetValue;\n        valueStore[1] = (valueStore[0] - targetValue) / deltaTime;\n      }\n\n      return valueStore;\n    }\n  }]);\n\n  return MathUtils;\n}();\n\n/* harmony default export */ const core_MathUtils = (MathUtils);\n;// CONCATENATED MODULE: ./src/core/HostEnvironment.js\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable import/prefer-default-export */\n\n/**\n * Indicates the type of host build.\n *\n * @type {string}\n */\nvar env = \'core\';\n\n;// CONCATENATED MODULE: ./src/core/Messenger.js\nfunction Messenger_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Messenger_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Messenger_createClass(Constructor, protoProps, staticProps) { if (protoProps) Messenger_defineProperties(Constructor.prototype, protoProps); if (staticProps) Messenger_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable no-underscore-dangle */\n\n/**\n * Class that can execute functions when local messages are received. Local messages\n * are prefixed with the instance\'s id.\n *\n * @alias core/Messenger\n *\n * @property {core/Messenger} GlobalMessenger - A messenger that can be used for\n * global messaging. When using static listen and emit methods they are executed\n * on this messenger.\n * @property {Object} EVENTS - Built-in events that the Messenger emits.\n */\n\nvar Messenger = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   *\n   * @param {any=} id - Id for the object. If none is provided a new id will\n   * be created. Id should be able to be represented as a string.\n   */\n  function Messenger(id) {\n    Messenger_classCallCheck(this, Messenger);\n\n    this._id = id !== undefined ? id : core_Utils.createId();\n    this._dispatcher = window;\n    this._callbacks = {};\n    this._eventListeners = {};\n  }\n  /**\n   * Gets the string id of the object.\n   *\n   * @readonly\n   * @type {string}\n   */\n\n\n  Messenger_createClass(Messenger, [{\n    key: "id",\n    get: function get() {\n      return this._id;\n    }\n    /**\n     * Prefix a message with the instance id.\n     *\n     * @private\n     *\n     * @param {string} message\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: "_createLocalMessage",\n    value: function _createLocalMessage(message) {\n      return "".concat(this.id, ".").concat(message);\n    }\n    /**\n     * Return a function that will call a callback function and supply the event\'s\n     * detail property as an argument.\n     *\n     * @private\n     *\n     * @param {Function} callback\n     *\n     * @returns {Function}\n     */\n\n  }, {\n    key: "_createListener",\n    value: function _createListener(callback) {\n      return function (e) {\n        var value;\n\n        if (e.detail !== null) {\n          value = e.detail;\n        }\n\n        callback(value);\n      };\n    }\n    /**\n     * Create an event object and send it to listeners.\n     *\n     * @private\n     *\n     * @param {string} message - Event type name.\n     * @param {any=} value - Value to send to listeners.\n     *\n     * @returns {CustomEvent}\n     */\n\n  }, {\n    key: "_createEvent",\n    value: function _createEvent(message, value) {\n      return new CustomEvent(message, {\n        detail: value\n      });\n    }\n    /**\n     * Register an event.\n     *\n     * @private\n     *\n     * @param {string} message - Event type name.\n     * @param {Function} listener - A listener function generated using _createListener.\n     */\n\n  }, {\n    key: "_addListener",\n    value: function _addListener(message, listener) {\n      this._dispatcher.addEventListener(this._createLocalMessage(message), listener);\n    }\n    /**\n     * Unregister an event.\n     *\n     * @private\n     *\n     * @param {string} message - Event type name.\n     * @param {Function} listener - A listener function generated using _createListener.\n     */\n\n  }, {\n    key: "_removeListener",\n    value: function _removeListener(message, listener) {\n      this._dispatcher.removeEventListener(this._createLocalMessage(message), listener);\n    }\n    /**\n     * Execute a function when a message is received for this object.\n     *\n     * @param {string} message - The message to listen for.\n     * @param {Function} callback - Function to execute once the message is received.\n     */\n\n  }, {\n    key: "listenTo",\n    value: function listenTo(message, callback) {\n      if (typeof callback !== \'function\') {\n        throw new Error("Cannot add listener for ".concat(message, " on ").concat(this.id, ". Callback must be a function."));\n      }\n\n      if (this._callbacks[message] === undefined) {\n        this._callbacks[message] = [];\n        this._eventListeners[message] = [];\n      }\n\n      var listener = this._createListener(callback);\n\n      this._callbacks[message].push(callback);\n\n      this._eventListeners[message].push(listener);\n\n      this._addListener(message, listener);\n    }\n    /**\n     * Prevent a function from being executed when a message is received for this\n     * object.\n     *\n     * @param {string} message - The message to stop listening for.\n     * @param {Function=} callback - Optional callback to remove. If none is defined,\n     * remove all callbacks for the message.\n     */\n\n  }, {\n    key: "stopListening",\n    value: function stopListening(message, callback) {\n      if (this._callbacks[message] === undefined) {\n        return;\n      } else if (callback === undefined) {\n        // If no callback was defined, call stopListening on all callbacks for the message\n        for (var i = this._callbacks[message].length - 1; i > -1; i--) {\n          this.stopListening(message, this._callbacks[message][i]);\n        }\n\n        return;\n      } // If a callback was defined, make sure it\'s a listener\n\n\n      var index = this._callbacks[message].indexOf(callback);\n\n      if (index === -1) {\n        return;\n      }\n\n      var listener = this._eventListeners[message][index];\n\n      this._removeListener(message, listener);\n\n      this._callbacks[message].splice(index, 1);\n\n      this._eventListeners[message].splice(index, 1);\n\n      if (this._callbacks[message].length === 0) {\n        delete this._callbacks[message];\n        delete this._eventListeners[message];\n      }\n    }\n    /**\n     * De-register callback(s) from being executed when messages matching the given\n     * regular expression are received.\n     *\n     * @param {Regexp} regexp - regexp - The regular expression to filter messages with.\n     * @param {Function=} callback - Optional callback to remove. If none is defined,\n     * remove all callbacks for messages matching the regular expression.\n     */\n\n  }, {\n    key: "stopListeningByRegexp",\n    value: function stopListeningByRegexp(regexp, callback) {\n      var _this = this;\n\n      var messages = Object.keys(this._callbacks).filter(function (message) {\n        return regexp.test(message);\n      });\n      messages.forEach(function (message) {\n        _this.stopListening(message, callback);\n      });\n    }\n    /**\n     * Prevent any functions from being executed when any message is received for\n     * this object.\n     */\n\n  }, {\n    key: "stopListeningToAll",\n    value: function stopListeningToAll() {\n      var messages = Object.keys(this._callbacks);\n\n      for (var i = messages.length - 1; i > -1; i--) {\n        this.stopListening(messages[i]);\n      }\n    }\n    /**\n     * Send a message, causing listener functions for the message on this object\n     * to be executed.\n     *\n     * @param {string} message - The message to emit.\n     * @param {any=} value - Optional argument to pass to listener callbacks.\n     */\n\n  }, {\n    key: "emit",\n    value: function emit(message, value) {\n      if (this._callbacks[message] === undefined) {\n        return;\n      }\n\n      message = this._createLocalMessage(message);\n\n      var event = this._createEvent(message, value);\n\n      this._dispatcher.dispatchEvent(event);\n    }\n    /**\n     * Execute a function when a message is received for the global Messenger instance.\n     *\n     * @static\n     *\n     * @param {string} message - The message to listen for.\n     * @param {Function} callback - Function to execute once the message is received.\n     */\n\n  }], [{\n    key: "listenTo",\n    value: function listenTo(message, callback, messenger) {\n      this.GlobalMessenger.listenTo(message, callback, messenger);\n    }\n    /**\n     * Prevent a function from being executed when a message is received for the\n     * global Messenger instance.\n     *\n     * @static\n     *\n     * @param {string} message - The message to stop listening for.\n     * @param {Function=} callback - Optional callback to remove. If none is defined,\n     * remove all callbacks for the message.\n     */\n\n  }, {\n    key: "stopListening",\n    value: function stopListening(message, callback) {\n      this.GlobalMessenger.stopListening(message, callback);\n    }\n    /**\n     * De-register callback(s) from being executed on the global messengerr instance\n     * when messages matching the given regular expression are received.\n     *\n     * @param {Regexp} regexp - regexp - The regular expression to filter messages with.\n     * @param {Function=} callback - Optional callback to remove. If none is defined,\n     * remove all callbacks for messages matching the regular expression.\n     */\n\n  }, {\n    key: "stopListeningByRegexp",\n    value: function stopListeningByRegexp(regexp, callback) {\n      var _this2 = this;\n\n      var messages = Object.keys(this.GlobalMessenger._callbacks).filter(function (message) {\n        return regexp.test(message);\n      });\n      messages.forEach(function (message) {\n        _this2.stopListening(message, callback);\n      });\n    }\n    /**\n     * Prevent any functions from being executed when any message is received for\n     * the global Messenger instance.\n     *\n     * @static\n     */\n\n  }, {\n    key: "stopListeningToAll",\n    value: function stopListeningToAll() {\n      this.GlobalMessenger.stopListeningToAll();\n    }\n    /**\n     * Send a message, causing listener functions for the message on the global Messenger\n     * instance to be executed.\n     *\n     * @static\n     *\n     * @param {string} message - The message to emit.\n     * @param {any=} value - Optional argument to pass to listener callbacks.\n     */\n\n  }, {\n    key: "emit",\n    value: function emit(message, value) {\n      this.GlobalMessenger.emit(message, value);\n    }\n  }]);\n\n  return Messenger;\n}();\n\nObject.defineProperties(Messenger, {\n  GlobalMessenger: {\n    value: new Messenger(),\n    writable: false\n  },\n  EVENTS: {\n    value: {},\n    writable: false\n  }\n});\n/* harmony default export */ const core_Messenger = (Messenger);\n;// CONCATENATED MODULE: ./src/core/AbstractHostFeature.js\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || AbstractHostFeature_unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction AbstractHostFeature_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return AbstractHostFeature_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return AbstractHostFeature_arrayLikeToArray(o, minLen); }\n\nfunction AbstractHostFeature_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction AbstractHostFeature_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AbstractHostFeature_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AbstractHostFeature_createClass(Constructor, protoProps, staticProps) { if (protoProps) AbstractHostFeature_defineProperties(Constructor.prototype, protoProps); if (staticProps) AbstractHostFeature_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\n * Base class for all host features. Keeps a reference to the host object managing\n * the feature.\n *\n * @abstract\n *\n * @property {Object} EVENTS - Built-in messages that the feature emits. When the\n * feature is added to a {@link core/HostObject}, event names will be prefixed by the\n * name of the feature class + \'.\'.\n * @property {string} [EVENTS.update=onUpdate] - Message that is emitted after\n * each call to [update]{@link AbstractHostFeature#update}.\n * @property {Object} SERVICES - Any AWS services that are necessary for the\n * feature to function.\n */\n\nvar AbstractHostFeature = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   *\n   * @param {core/HostObject} host - The HostObject managing the feature.\n   */\n  function AbstractHostFeature(host) {\n    AbstractHostFeature_classCallCheck(this, AbstractHostFeature);\n\n    this._host = host;\n  }\n  /**\n   * Adds a namespace to the host with the name of the feature to contain properties\n   * and methods from the feature that users of the host need access to.\n   */\n\n\n  AbstractHostFeature_createClass(AbstractHostFeature, [{\n    key: "installApi",\n    value: function installApi() {\n      var _this = this;\n\n      var events = {};\n      var api = {\n        EVENTS: events\n      }; // Add the class name to event names\n\n      Object.entries(this.constructor.EVENTS).forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            name = _ref2[0],\n            value = _ref2[1];\n\n        events[name] = "".concat(_this.constructor.name, ".").concat(value);\n      });\n      this._host[this.constructor.name] = api;\n      return api;\n    }\n    /**\n     * Gets the host that manages the feature.\n     *\n     * @readonly\n     */\n\n  }, {\n    key: "host",\n    get: function get() {\n      return this._host;\n    }\n    /**\n     * Gets the engine owner object of the host.\n     *\n     * @readonly\n     */\n\n  }, {\n    key: "owner",\n    get: function get() {\n      return this._host.owner;\n    }\n    /**\n     * Listen to a feature message from the host object.\n     *\n     * @param {string} message - Message to listen for.\n     * @param {Function} callback - The callback to execute when the message is received.\n     */\n\n  }, {\n    key: "listenTo",\n    value: function listenTo(message, callback) {\n      this._host.listenTo(message, callback);\n    }\n    /**\n     * Listen to a feature message from the global messenger. Feature messages will\n     * be prefixed with the class name of the feature.\n     *\n     * @param {string} message - Message to listen for.\n     * @param {Function} callback - The callback to execute when the message is received.\n     */\n\n  }, {\n    key: "stopListening",\n    value:\n    /**\n     * Stop listening to a message from the host object.\n     *\n     * @param {string} message - Message to stop listening for.\n     * @param {Function=} callback - Optional callback to remove. If none is defined,\n     * remove all callbacks for the message.\n     */\n    function stopListening(message, callback) {\n      this._host.stopListening(message, callback);\n    }\n    /**\n     * Stop listening to a message from the global messenger.\n     *\n     * @param {string} message - Message to stop listening for.\n     * @param {Function=} callback - Optional callback to remove. If none is defined,\n     * remove all callbacks for the message.\n     */\n\n  }, {\n    key: "stopListeningByRegexp",\n    value:\n    /**\n     * Stop listening to a message matching the given regular expression from the\n     * host object.\n     *\n     * @param {Regexp} regexp - The regular expression to stop listening for.\n     * @param {Function=} callback - Optional callback to remove. If none is defined,\n     * remove all callbacks for the message.\n     */\n    function stopListeningByRegexp(regexp, callback) {\n      this._host.stopListeningByRegexp(regexp, callback);\n    }\n    /**\n     * Stop listening to a message matching the given regular expression from the\n     * global messenger.\n     *\n     * @param {Regexp} regexp - The regular expression to stop listening for.\n     * @param {Function=} callback - Optional callback to remove. If none is defined,\n     * remove all callbacks for the message.\n     */\n\n  }, {\n    key: "stopListeningToAll",\n    value:\n    /**\n     * Stop listening to all messages.\n     */\n    function stopListeningToAll() {\n      this._host.stopListeningToAll();\n    }\n    /**\n     * Stop listening to all feature messages.\n     */\n\n  }, {\n    key: "emit",\n    value:\n    /**\n     * Emit feature messages from the host. Feature messages will be prefixed with\n     * the class name of the feature.\n     *\n     * @param {string} message - The message to emit.\n     * @param {any=} value - Optional parameter to pass to listener callbacks.\n     */\n    function emit(message, value) {\n      message = "".concat(this.constructor.name, ".").concat(message);\n\n      this._host.emit(message, value);\n    }\n    /**\n     * Emit feature messages from the global messenger. Feature messages will be prefixed\n     * with the class name of the feature.\n     *\n     * @param {string} message - The message to emit.\n     * @param {any=} value - Optional parameter to pass to listener callbacks.\n     */\n\n  }, {\n    key: "update",\n    value:\n    /**\n     * Executes each time the host is updated.\n     *\n     * @param {number} deltaTime - Amount of time since the last host update was\n     * called.\n     */\n    function update(deltaTime) {\n      this.emit(this.constructor.EVENTS.update, deltaTime);\n    }\n    /**\n     * Clean up once the feature is no longer in use. Remove the feature namespace\n     * from the host and remove reference to the host.\n     */\n\n  }, {\n    key: "discard",\n    value: function discard() {\n      var _this2 = this;\n\n      Object.keys(this._host[this.constructor.name]).forEach(function (name) {\n        delete _this2._host[_this2.constructor.name][name];\n      });\n      delete this._host[this.constructor.name];\n      delete this._host;\n    }\n    /**\n     * Applies a sequence of mixin class factory functions to this class and\n     * returns the result. Each function is expected to return a class that\n     * extends the class it was given. The functions are applied in the order\n     * that parameters are given, meaning that the first factory will\n     * extend this base class.\n     *\n     * @param {...Function} mixinClassFactories Class factory functions that will\n     * be applied.\n     *\n     * @returns {Class} A class that is the result of applying the factory functions.\n     * The resulting class will always inherit from AbstractHostFeature.\n     */\n\n  }], [{\n    key: "listenTo",\n    value: function listenTo(message, callback) {\n      message = "".concat(this.name, ".").concat(message);\n      core_Messenger.listenTo(message, callback);\n    }\n  }, {\n    key: "stopListening",\n    value: function stopListening(message, callback) {\n      message = "".concat(this.name, ".").concat(message);\n      core_Messenger.stopListening(message, callback);\n    }\n  }, {\n    key: "stopListeningByRegexp",\n    value: function stopListeningByRegexp(regexp, callback) {\n      regexp = new RegExp("^".concat(this.name, ".").concat(regexp.source.replace(/\\^/, \'\')));\n      core_Messenger.stopListeningByRegexp(regexp, callback);\n    }\n  }, {\n    key: "stopListeningToAll",\n    value: function stopListeningToAll() {\n      core_Messenger.stopListeningByRegexp(new RegExp("^".concat(this.name, ".")));\n    }\n  }, {\n    key: "emit",\n    value: function emit(message, value) {\n      message = "".concat(this.name, ".").concat(message);\n      core_Messenger.emit(message, value);\n    }\n  }, {\n    key: "mix",\n    value: function mix() {\n      var ResultClass = this;\n\n      for (var _len = arguments.length, mixinClassFactories = new Array(_len), _key = 0; _key < _len; _key++) {\n        mixinClassFactories[_key] = arguments[_key];\n      }\n\n      mixinClassFactories.forEach(function (mixinClassFactory) {\n        ResultClass = mixinClassFactory(ResultClass);\n      });\n      return ResultClass;\n    }\n  }]);\n\n  return AbstractHostFeature;\n}();\n\nObject.defineProperties(AbstractHostFeature, {\n  EVENTS: {\n    value: {\n      update: \'onUpdate\'\n    },\n    writable: false\n  },\n  SERVICES: {\n    value: {},\n    writable: false\n  }\n});\n/* harmony default export */ const core_AbstractHostFeature = (AbstractHostFeature);\n;// CONCATENATED MODULE: ./src/core/HostObject.js\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction HostObject_construct(Parent, args, Class) { if (HostObject_isNativeReflectConstruct()) { HostObject_construct = Reflect.construct; } else { HostObject_construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) HostObject_setPrototypeOf(instance, Class.prototype); return instance; }; } return HostObject_construct.apply(null, arguments); }\n\nfunction HostObject_typeof(obj) { "@babel/helpers - typeof"; return HostObject_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, HostObject_typeof(obj); }\n\nfunction HostObject_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction HostObject_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction HostObject_createClass(Constructor, protoProps, staticProps) { if (protoProps) HostObject_defineProperties(Constructor.prototype, protoProps); if (staticProps) HostObject_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction HostObject_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) HostObject_setPrototypeOf(subClass, superClass); }\n\nfunction HostObject_setPrototypeOf(o, p) { HostObject_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return HostObject_setPrototypeOf(o, p); }\n\nfunction HostObject_createSuper(Derived) { var hasNativeReflectConstruct = HostObject_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = HostObject_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = HostObject_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return HostObject_possibleConstructorReturn(this, result); }; }\n\nfunction HostObject_possibleConstructorReturn(self, call) { if (call && (HostObject_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return HostObject_assertThisInitialized(self); }\n\nfunction HostObject_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction HostObject_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction HostObject_getPrototypeOf(o) { HostObject_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return HostObject_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n/**\n * Object that manages access to all Host features. Contains a reference to\n * engine-specific visuals if applicable.\n *\n * @extends core/Messenger\n * @alias core/HostObject\n *\n * @property {Object} EVENTS - Built-in messages that the Messenger emits.\n * @property {string} [EVENTS.update=\'onUpdate\'] - Message that is emitted after\n * each call to [update]{@link core/HostObject#update}.\n * @property {string} [EVENTS.addFeature=\'onAddFeature\'] - Message that is emitted\n * after each call to [addFeature]{@link core/HostObject#addFeature}.\n * @property {string} [EVENTS.removeFeature=\'onRemoveFeature\'] - Message that is emitted\n * after each call to [removeFeature]{@link core/HostObject#removeFeature}.\n */\n\nvar HostObject = /*#__PURE__*/function (_Messenger) {\n  HostObject_inherits(HostObject, _Messenger);\n\n  var _super = HostObject_createSuper(HostObject);\n\n  /**\n   * @constructor\n   *\n   * @param {Object=} options - Options for the host.\n   * @param {Object=} options.owner - Optional engine-specific owner of the host.\n   */\n  function HostObject() {\n    var _this;\n\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$owner = _ref.owner,\n        owner = _ref$owner === void 0 ? {} : _ref$owner;\n\n    HostObject_classCallCheck(this, HostObject);\n\n    // If an owner is specified, use its id for messaging\n    _this = _super.call(this, owner.id);\n    _this._owner = owner;\n    _this._features = {};\n    _this._waits = [];\n    _this._lastUpdate = _this.now;\n    return _this;\n  }\n  /**\n   * Gets the engine owner object of the host.\n   *\n   * @readonly\n   * @type {Object}\n   */\n\n\n  HostObject_createClass(HostObject, [{\n    key: "owner",\n    get: function get() {\n      return this._owner;\n    }\n    /**\n     * Gets the current time in milliseconds.\n     *\n     * @readonly\n     * @type {number}\n     */\n\n  }, {\n    key: "now",\n    get: function get() {\n      return Date.now();\n    }\n    /**\n     * Gets the amount of time in milliseconds since update was last called.\n     *\n     * @readonly\n     * @type {number}\n     */\n\n  }, {\n    key: "deltaTime",\n    get: function get() {\n      return this.now - this._lastUpdate;\n    }\n    /**\n     * This function should be called in the engine\'s render loop. Executes update\n     * loops for all features.\n     */\n\n  }, {\n    key: "update",\n    value: function update() {\n      var currentTime = this.now;\n      var dt = this.deltaTime; // Progress stored waits\n\n      this._waits.forEach(function (wait) {\n        wait.execute(dt);\n      }); // Update all features\n\n\n      Object.values(this._features).forEach(function (feature) {\n        feature.update(dt);\n      }); // Notify listeners an update occured\n\n      this.emit(this.constructor.EVENTS.update, dt);\n      this._lastUpdate = currentTime;\n    }\n    /**\n     * Return a deferred promise that will wait a given number of seconds before\n     * resolving. The host will continuously update the wait promise during the\n     * update loop until it resolves.\n     *\n     * @param {number} [seconds=0] - Number of seconds to wait before resolving.\n     * @param {Object=} options - Optional options object\n     * @param {Function} [options.onFinish] - Callback to execute once the wait time\n     * is met.\n     * @param {Function=} options.onProgress - Callback to execute each time the wait\n     * time progresses towards the target number of seconds. The amount of progress\n     * as a 0-1 percentage is passed as an argument.\n     * @param {Function=} options.onCancel - Callback to execute if the user cancels\n     * the wait before completion.\n     * @param {Function=} options.onError - Callback to execute if the wait stops\n     * because an error is encountered. The error message is passed as a parameter.\n     *\n     * @returns {Deferred}\n     */\n\n  }, {\n    key: "wait",\n    value: function wait(seconds) {\n      var _this2 = this;\n\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          onFinish = _ref2.onFinish,\n          onProgress = _ref2.onProgress,\n          onCancel = _ref2.onCancel,\n          onError = _ref2.onError;\n\n      var wait = core_Utils.wait(seconds, {\n        onFinish: onFinish,\n        onProgress: onProgress,\n        onCancel: onCancel,\n        onError: onError\n      });\n\n      this._waits.push(wait); // Once the wait promise is no longer pending remove it from the waits array\n\n\n      var onComplete = function onComplete() {\n        _this2._waits.splice(_this2._waits.indexOf(wait), 1);\n      };\n\n      wait.then(onComplete, onComplete);\n      return wait;\n    }\n    /**\n     * Instantiate a new Host feature and store it. Features must inherit from\n     * AbstractHostFeature.\n     *\n     * @param {Class} FeatureClass - Class that will instantiate the feature. Must\n     * extend {@link AbstractHostFeature}.\n     * @param {boolean} [force=false] - Whether or not to overwrite an existing\n     * feature if one of this type already exists on the object.\n     * @param  {...any} args - Additional arguments to pass to the FeatureClass\n     * constructor. The HostObject will always be passed as the first argument.\n     *\n     * @returns {boolean} - Whether or not a feature was successfully added.\n     */\n\n  }, {\n    key: "addFeature",\n    value: function addFeature(FeatureClass) {\n      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      var inputType = HostObject_typeof(FeatureClass); // Make sure the FeatureClass can be executed\n\n\n      if (inputType !== \'function\') {\n        throw new Error("Cannot add feature to host ".concat(this.id, ". FeatureClass must be a class."));\n      } // Make sure the feature is a host feature\n      else if (!(FeatureClass.prototype instanceof core_AbstractHostFeature)) {\n        throw new Error("Cannot add feature ".concat(FeatureClass.name, " to host ").concat(this.id, ". FeatureClass must extend AbstractHostFeature."));\n      } // Check if the FeatureClass already exists on this object\n\n\n      if (this._features[FeatureClass.name] !== undefined) {\n        if (force) {\n          console.warn("Feature ".concat(FeatureClass.name, " already exists on host ").concat(this.id, ". Existing feature will be overwritten."));\n        } else {\n          throw new Error("Feature ".concat(FeatureClass.name, " already exists on host ").concat(this.id, ". Use \'force\' argument to overwrite the feature."));\n        }\n      } // Initialize the feature\n\n\n      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n      }\n\n      var feature = HostObject_construct(FeatureClass, [this].concat(args));\n\n      feature.installApi();\n      this._features[FeatureClass.name] = feature;\n      this.emit(this.constructor.EVENTS.addFeature, FeatureClass.name);\n      return true;\n    }\n    /**\n     * Remove a feature from the object.\n     *\n     * @param {string} typeName - Name of the type of feature to remove.\n     *\n     * @returns {boolean} - Whether or not a feature was successfully removed.\n     */\n\n  }, {\n    key: "removeFeature",\n    value: function removeFeature(typeName) {\n      if (this._features[typeName] === undefined) {\n        console.warn("Feature of type ".concat(typeName, " does not exist on host ").concat(this.id, ". No feature will be removed."));\n        return false;\n      } else {\n        // Remove the feature\n        this.emit(this.constructor.EVENTS.removeFeature, typeName);\n\n        this._features[typeName].discard();\n\n        delete this._features[typeName];\n        return true;\n      }\n    }\n    /**\n     * Indicate whether a specified feature is installed on the host.\n     *\n     * @param {string} typeName - Name of the type of feature to look for.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "hasFeature",\n    value: function hasFeature(typeName) {\n      return !!this._features[typeName];\n    }\n    /**\n     * List the names of the features installed on the host.\n     *\n     * @returns {Array.<string>}\n     */\n\n  }, {\n    key: "listFeatures",\n    value: function listFeatures() {\n      return Object.keys(this._features);\n    }\n  }]);\n\n  return HostObject;\n}(core_Messenger);\n\nObject.defineProperty(HostObject, \'EVENTS\', {\n  value: _objectSpread(_objectSpread({}, Object.getPrototypeOf(HostObject).EVENTS), {}, {\n    update: \'onUpdate\',\n    addFeature: \'onAddFeature\',\n    removeFeature: \'onRemoveFeature\'\n  }),\n  writable: false\n});\n/* harmony default export */ const core_HostObject = (HostObject);\n;// CONCATENATED MODULE: ./src/core/animpack/Easing.js\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\n * @typedef {Object} EasingObject Object containing easing functions\n * @property {Function} In - Easing \'In\' function. Should use the signature (k:number):number.\n * @property {Function} Out - Easing \'Out\' function. Should use the signature (k:number):number.\n * @property {Function} InOut - Easing \'InOut\' function. Should use the signature (k:number):number.\n */\n\n/**\n * Linear Easing\n * @type {EasingObject}\n */\nvar Linear = {\n  None: function None(k) {\n    return k;\n  },\n  In: function In(k) {\n    return k;\n  },\n  Out: function Out(k) {\n    return k;\n  },\n  InOut: function InOut(k) {\n    return k;\n  }\n};\n/**\n * Quadratic Easing\n * @type {EasingObject}\n */\n\nvar Quadratic = {\n  In: function In(k) {\n    return k * k;\n  },\n  Out: function Out(k) {\n    return k * (2 - k);\n  },\n  InOut: function InOut(k) {\n    k *= 2;\n\n    if (k < 1) {\n      return 0.5 * k * k;\n    }\n\n    return -0.5 * (--k * (k - 2) - 1);\n  }\n};\n/**\n * Cubic Easing\n * @type {EasingObject}\n */\n\nvar Cubic = {\n  In: function In(k) {\n    return k * k * k;\n  },\n  Out: function Out(k) {\n    return --k * k * k + 1;\n  },\n  InOut: function InOut(k) {\n    k *= 2;\n\n    if (k < 1) {\n      return 0.5 * k * k * k;\n    }\n\n    k -= 2;\n    return 0.5 * (k * k * k + 2);\n  }\n};\n/**\n * Quartic Easing\n * @type {EasingObject}\n */\n\nvar Quartic = {\n  In: function In(k) {\n    return k * k * k * k;\n  },\n  Out: function Out(k) {\n    return 1 - --k * k * k * k;\n  },\n  InOut: function InOut(k) {\n    k *= 2;\n\n    if (k < 1) {\n      return 0.5 * k * k * k * k;\n    }\n\n    k -= 2;\n    return -0.5 * (k * k * k * k - 2);\n  }\n};\n/**\n * Quintic Easing\n * @type {EasingObject}\n */\n\nvar Quintic = {\n  In: function In(k) {\n    return k * k * k * k * k;\n  },\n  Out: function Out(k) {\n    return --k * k * k * k * k + 1;\n  },\n  InOut: function InOut(k) {\n    k *= 2;\n\n    if (k < 1) {\n      return 0.5 * k * k * k * k * k;\n    }\n\n    k -= 2;\n    return 0.5 * (k * k * k * k * k + 2);\n  }\n};\n/**\n * Sinusoidal Easing\n * @type {EasingObject}\n */\n\nvar Sinusoidal = {\n  In: function In(k) {\n    return 1 - Math.cos(k * Math.PI / 2);\n  },\n  Out: function Out(k) {\n    return Math.sin(k * Math.PI / 2);\n  },\n  InOut: function InOut(k) {\n    return 0.5 * (1 - Math.cos(Math.PI * k));\n  }\n};\n/**\n * Exponential Easing\n * @type {EasingObject}\n */\n\nvar Exponential = {\n  In: function In(k) {\n    return k === 0 ? 0 : Math.pow(1024, k - 1);\n  },\n  Out: function Out(k) {\n    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n  },\n  InOut: function InOut(k) {\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    k *= 2;\n\n    if (k < 1) {\n      return 0.5 * Math.pow(1024, k - 1);\n    }\n\n    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n  }\n};\n/**\n * Circular Easing\n * @type {EasingObject}\n */\n\nvar Circular = {\n  In: function In(k) {\n    return 1 - Math.sqrt(1 - k * k);\n  },\n  Out: function Out(k) {\n    return Math.sqrt(1 - --k * k);\n  },\n  InOut: function InOut(k) {\n    k *= 2;\n\n    if (k < 1) {\n      return -0.5 * (Math.sqrt(1 - k * k) - 1);\n    }\n\n    k -= 2;\n    return 0.5 * (Math.sqrt(1 - k * k) + 1);\n  }\n};\n/**\n * Elastic Easing\n * @type {EasingObject}\n */\n\nvar Elastic = {\n  In: function In(k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * Math.asin(1 / a) / (2 * Math.PI);\n    }\n\n    k -= 1;\n    return -(a * Math.pow(2, 10 * k) * Math.sin((k - s) * (2 * Math.PI) / p));\n  },\n  Out: function Out(k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * Math.asin(1 / a) / (2 * Math.PI);\n    }\n\n    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;\n  },\n  InOut: function InOut(k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * Math.asin(1 / a) / (2 * Math.PI);\n    }\n\n    k *= 2;\n\n    if (k < 1) {\n      k -= 1;\n      return -0.5 * (a * Math.pow(2, 10 * k) * Math.sin((k - s) * (2 * Math.PI) / p));\n    }\n\n    k -= 1;\n    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n  }\n};\n/**\n * Back Easing\n * @type {EasingObject}\n */\n\nvar Back = {\n  In: function In(k) {\n    var s = 1.70158;\n    return k * k * ((s + 1) * k - s);\n  },\n  Out: function Out(k) {\n    var s = 1.70158;\n    return --k * k * ((s + 1) * k + s) + 1;\n  },\n  InOut: function InOut(k) {\n    var s = 1.70158 * 1.525;\n    k *= 2;\n\n    if (k < 1) {\n      return 0.5 * (k * k * ((s + 1) * k - s));\n    }\n\n    k -= 2;\n    return 0.5 * (k * k * ((s + 1) * k + s) + 2);\n  }\n};\n/**\n * Bounce Easing\n * @type {EasingObject}\n */\n\nvar Bounce = {\n  In: function In(k) {\n    return 1 - Bounce.Out(1 - k);\n  },\n  Out: function Out(k) {\n    if (k < 1 / 2.75) {\n      return 7.5625 * k * k;\n    } else if (k < 2 / 2.75) {\n      k -= 1.5;\n      return 7.5625 * (k / 2.75) * k + 0.75;\n    } else if (k < 2.5 / 2.75) {\n      k -= 2.25;\n      return 7.5625 * (k / 2.75) * k + 0.9375;\n    }\n\n    k -= 2.625;\n    return 7.5625 * (k / 2.75) * k + 0.984375;\n  },\n  InOut: function InOut(k) {\n    if (k < 0.5) {\n      return Bounce.In(k * 2) * 0.5;\n    }\n\n    return Bounce.Out(k * 2 - 1) * 0.5 + 0.5;\n  }\n};\n;// CONCATENATED MODULE: ./src/core/FeatureDependentInterface.js\nfunction FeatureDependentInterface_typeof(obj) { "@babel/helpers - typeof"; return FeatureDependentInterface_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, FeatureDependentInterface_typeof(obj); }\n\nfunction FeatureDependentInterface_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction FeatureDependentInterface_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? FeatureDependentInterface_ownKeys(Object(source), !0).forEach(function (key) { FeatureDependentInterface_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : FeatureDependentInterface_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction FeatureDependentInterface_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction FeatureDependentInterface_slicedToArray(arr, i) { return FeatureDependentInterface_arrayWithHoles(arr) || FeatureDependentInterface_iterableToArrayLimit(arr, i) || FeatureDependentInterface_unsupportedIterableToArray(arr, i) || FeatureDependentInterface_nonIterableRest(); }\n\nfunction FeatureDependentInterface_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction FeatureDependentInterface_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return FeatureDependentInterface_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return FeatureDependentInterface_arrayLikeToArray(o, minLen); }\n\nfunction FeatureDependentInterface_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction FeatureDependentInterface_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction FeatureDependentInterface_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = FeatureDependentInterface_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction FeatureDependentInterface_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) FeatureDependentInterface_setPrototypeOf(subClass, superClass); }\n\nfunction FeatureDependentInterface_setPrototypeOf(o, p) { FeatureDependentInterface_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return FeatureDependentInterface_setPrototypeOf(o, p); }\n\nfunction FeatureDependentInterface_createSuper(Derived) { var hasNativeReflectConstruct = FeatureDependentInterface_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = FeatureDependentInterface_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = FeatureDependentInterface_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return FeatureDependentInterface_possibleConstructorReturn(this, result); }; }\n\nfunction FeatureDependentInterface_possibleConstructorReturn(self, call) { if (call && (FeatureDependentInterface_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return FeatureDependentInterface_assertThisInitialized(self); }\n\nfunction FeatureDependentInterface_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction FeatureDependentInterface_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction FeatureDependentInterface_getPrototypeOf(o) { FeatureDependentInterface_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return FeatureDependentInterface_getPrototypeOf(o); }\n\nfunction FeatureDependentInterface_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction FeatureDependentInterface_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction FeatureDependentInterface_createClass(Constructor, protoProps, staticProps) { if (protoProps) FeatureDependentInterface_defineProperties(Constructor.prototype, protoProps); if (staticProps) FeatureDependentInterface_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable no-unused-vars */\n\n/* eslint-disable max-classes-per-file */\n\n/**\n * Class factory interface for features that are dependent on other features being\n * present on the host. Event dependencies will be listened for when a feature of\n * matching type is added to the host and will stop being listened for when one\n * is removed. If the feature is already present when constructed, events will\n * be listened for right away.\n *\n * @interface\n *\n * @property {Object} EVENT_DEPENDENCIES - Events that the feature should start/stop\n * listening for when a feature of type FeatureName is added/removed from the host.\n * Event dependencies should follow the signature:\n *  { FeatureName: { eventName: callbackName, ... }, ... }\n */\n\nvar FeatureDependentInterface = /*#__PURE__*/function () {\n  function FeatureDependentInterface() {\n    FeatureDependentInterface_classCallCheck(this, FeatureDependentInterface);\n  }\n\n  FeatureDependentInterface_createClass(FeatureDependentInterface, [{\n    key: "_onFeatureAdded",\n    value:\n    /**\n     * Start listening for event dependencies that match the given feature type.\n     *\n     * @private\n     *\n     * @param {string} typeName - type of feature to listen for.\n     */\n    function _onFeatureAdded(typeName) {}\n    /**\n     * Stop listening for event dependencies that match the given feature type.\n     *\n     * @private\n     *\n     * @param {string} typeName - type of feature to stop listening for.\n     */\n\n  }, {\n    key: "_onFeatureRemoved",\n    value: function _onFeatureRemoved(typeName) {}\n    /**\n     * @augments {@link AbstractHostFeature#discard}\n     */\n\n  }, {\n    key: "discard",\n    value: function discard() {}\n    /**\n     * Creates a class that implements {@link FeatureDependentInterface} and extends\n     * a specified base class.\n     *\n     * @param {Class} BaseClass - The class to extend.\n     *\n     * @return {Class} A class that extends `BaseClass` and implements {@link FeatureDependentInterface}.\n     */\n\n  }], [{\n    key: "Mixin",\n    value: function Mixin(BaseClass) {\n      var FeatureDependentMixin = /*#__PURE__*/function (_BaseClass) {\n        FeatureDependentInterface_inherits(FeatureDependentMixin, _BaseClass);\n\n        var _super = FeatureDependentInterface_createSuper(FeatureDependentMixin);\n\n        function FeatureDependentMixin(host) {\n          var _this;\n\n          FeatureDependentInterface_classCallCheck(this, FeatureDependentMixin);\n\n          _this = _super.call(this, host);\n          _this._host = host; // No need to listen for events if the mixin is in the prototype chain multiple times\n\n          if (!_this._initialized) {\n            _this._initialized = true; // Start listening for feature events\n\n            _this._onFeatureAdded = _this._onFeatureAdded.bind(FeatureDependentInterface_assertThisInitialized(_this));\n            _this._onFeatureRemoved = _this._onFeatureRemoved.bind(FeatureDependentInterface_assertThisInitialized(_this));\n\n            _this._host.listenTo(core_HostObject.EVENTS.addFeature, _this._onFeatureAdded);\n\n            _this._host.listenTo(core_HostObject.EVENTS.removeFeature, _this._onFeatureRemoved); // Register features that already exist\n\n\n            Object.keys(_this.constructor.EVENT_DEPENDENCIES).forEach(function (typeName) {\n              if (_this._host[typeName] !== undefined) {\n                _this._onFeatureAdded(typeName);\n              }\n            });\n          }\n\n          return _this;\n        }\n\n        FeatureDependentInterface_createClass(FeatureDependentMixin, [{\n          key: "_onFeatureAdded",\n          value: function _onFeatureAdded(typeName) {\n            var _this2 = this;\n\n            if (this.constructor.EVENT_DEPENDENCIES[typeName] !== undefined) {\n              var events = this.constructor.EVENT_DEPENDENCIES[typeName];\n              Object.entries(events).forEach(function (_ref) {\n                var _ref2 = FeatureDependentInterface_slicedToArray(_ref, 2),\n                    eventName = _ref2[0],\n                    callback = _ref2[1];\n\n                _this2[callback] = _this2[callback].bind(_this2);\n\n                _this2._host.listenTo(_this2._host[typeName].EVENTS[eventName], _this2[callback]);\n              });\n            }\n          }\n        }, {\n          key: "_onFeatureRemoved",\n          value: function _onFeatureRemoved(typeName) {\n            var _this3 = this;\n\n            if (this.constructor.EVENT_DEPENDENCIES[typeName] !== undefined) {\n              var events = this.constructor.EVENT_DEPENDENCIES[typeName];\n              Object.entries(events).forEach(function (_ref3) {\n                var _ref4 = FeatureDependentInterface_slicedToArray(_ref3, 2),\n                    eventName = _ref4[0],\n                    callback = _ref4[1];\n\n                _this3._host.stopListening(_this3._host[typeName].EVENTS[eventName], _this3[callback]);\n              });\n            }\n          }\n        }, {\n          key: "discard",\n          value: function discard() {\n            var _this4 = this;\n\n            // Stop listening for feature events\n            this._host.stopListening(core_HostObject.EVENTS.addFeature, this._onFeatureAdded);\n\n            this._host.stopListening(core_HostObject.EVENTS.removeFeature, this._onFeatureRemoved); // Stop listening to feature-specific events\n\n\n            Object.keys(this.constructor.EVENT_DEPENDENCIES).forEach(function (typeName) {\n              if (_this4._host[typeName] !== undefined) {\n                _this4._onFeatureRemoved(typeName);\n              }\n            });\n\n            _get(FeatureDependentInterface_getPrototypeOf(FeatureDependentMixin.prototype), "discard", this).call(this);\n          }\n        }]);\n\n        return FeatureDependentMixin;\n      }(BaseClass);\n\n      var EVENT_DEPENDENCIES = BaseClass.EVENT_DEPENDENCIES || {};\n      Object.defineProperties(FeatureDependentMixin, {\n        EVENT_DEPENDENCIES: {\n          value: FeatureDependentInterface_objectSpread({}, EVENT_DEPENDENCIES),\n          writable: false\n        }\n      });\n      return FeatureDependentMixin;\n    }\n  }]);\n\n  return FeatureDependentInterface;\n}();\n/**\n * Event dependencies should follow the signature:\n * {\n *  FeatureName: {\n *    // Events that the feature should start/stop listening for when a feature\n *    // of type FeatureName is added/removed from the host\n *    {\n *      eventName: callbackName,\n *      ...\n *    },\n *  }\n * }\n */\n\n\nObject.defineProperties(FeatureDependentInterface, {\n  EVENT_DEPENDENCIES: {\n    value: {},\n    writable: false\n  }\n});\n/* harmony default export */ const core_FeatureDependentInterface = (FeatureDependentInterface);\n;// CONCATENATED MODULE: ./src/core/animpack/AnimationFeatureDependentInterface.js\nfunction AnimationFeatureDependentInterface_typeof(obj) { "@babel/helpers - typeof"; return AnimationFeatureDependentInterface_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, AnimationFeatureDependentInterface_typeof(obj); }\n\nfunction AnimationFeatureDependentInterface_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction AnimationFeatureDependentInterface_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? AnimationFeatureDependentInterface_ownKeys(Object(source), !0).forEach(function (key) { AnimationFeatureDependentInterface_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : AnimationFeatureDependentInterface_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction AnimationFeatureDependentInterface_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction AnimationFeatureDependentInterface_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AnimationFeatureDependentInterface_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AnimationFeatureDependentInterface_createClass(Constructor, protoProps, staticProps) { if (protoProps) AnimationFeatureDependentInterface_defineProperties(Constructor.prototype, protoProps); if (staticProps) AnimationFeatureDependentInterface_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction AnimationFeatureDependentInterface_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) AnimationFeatureDependentInterface_setPrototypeOf(subClass, superClass); }\n\nfunction AnimationFeatureDependentInterface_setPrototypeOf(o, p) { AnimationFeatureDependentInterface_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return AnimationFeatureDependentInterface_setPrototypeOf(o, p); }\n\nfunction AnimationFeatureDependentInterface_createSuper(Derived) { var hasNativeReflectConstruct = AnimationFeatureDependentInterface_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = AnimationFeatureDependentInterface_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = AnimationFeatureDependentInterface_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return AnimationFeatureDependentInterface_possibleConstructorReturn(this, result); }; }\n\nfunction AnimationFeatureDependentInterface_possibleConstructorReturn(self, call) { if (call && (AnimationFeatureDependentInterface_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return AnimationFeatureDependentInterface_assertThisInitialized(self); }\n\nfunction AnimationFeatureDependentInterface_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction AnimationFeatureDependentInterface_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction AnimationFeatureDependentInterface_getPrototypeOf(o) { AnimationFeatureDependentInterface_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return AnimationFeatureDependentInterface_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable no-unused-vars */\n\n/* eslint-disable max-classes-per-file */\n\n/**\n * Class factory interface for features that are dependent on the AnimationFeature\n * being present on the host. Layer and animation events will automatically be\n * listened for once a AnimationFeature is added to the host and stopped once it\n * is removed.\n *\n * @interface\n * @extends FeatureDependentInterface\n *\n * @property {Object} EVENT_DEPENDENCIES - Events that the feature should start/stop\n * listening for when a feature of type FeatureName is added/removed from the host.\n * @property {Object} EVENT_DEPENDENCIES.AnimationFeature - Events that are\n * specific to the AnimationFeature.\n * @property {string} [EVENT_DEPENDENCIES.AnimationFeature.addLayer=\'_onLayerAdded\'] -\n * The name of the method that will be executed when AnimationFeature addLayer\n * events are emitted.\n * @property {string} [EVENT_DEPENDENCIES.AnimationFeature.removeLayer=\'_onLayerRemoved\'] -\n * The name of the method that will be executed when AnimationFeature removeLayer\n * events are emitted.\n * @property {string} [EVENT_DEPENDENCIES.AnimationFeature.renameLayer=\'_onLayerRenamed\'] -\n * The name of the method that will be executed when AnimationFeature renameLayer\n * events are emitted.\n * @property {string} [EVENT_DEPENDENCIES.AnimationFeature.addAnimation=\'_onAnimationAdded\'] -\n * The name of the method that will be executed when AnimationFeature addAnimation\n * events are emitted.\n * @property {string} [EVENT_DEPENDENCIES.AnimationFeature.removeAnimation=\'_onAnimationRemoved\'] -\n * The name of the method that will be executed when AnimationFeature removeAnimation\n * events are emitted.\n * @property {string} [EVENT_DEPENDENCIES.AnimationFeature.renameAnimation=\'_onAnimationRenamed\'] -\n * The name of the method that will be executed when AnimationFeature renameAnimation\n * events are emitted.\n */\n\nvar AnimationFeatureDependentInterface = /*#__PURE__*/function (_FeatureDependentInte) {\n  AnimationFeatureDependentInterface_inherits(AnimationFeatureDependentInterface, _FeatureDependentInte);\n\n  var _super = AnimationFeatureDependentInterface_createSuper(AnimationFeatureDependentInterface);\n\n  function AnimationFeatureDependentInterface() {\n    AnimationFeatureDependentInterface_classCallCheck(this, AnimationFeatureDependentInterface);\n\n    return _super.apply(this, arguments);\n  }\n\n  AnimationFeatureDependentInterface_createClass(AnimationFeatureDependentInterface, [{\n    key: "_onLayerAdded",\n    value:\n    /**\n     * Executed when animation layer added events are caught.\n     *\n     * @private\n     *\n     * @param {string} name - Name of the layer that was added.\n     */\n    function _onLayerAdded(_ref) {\n      var name = _ref.name;\n    }\n    /**\n     * Executed when animation layer removed events are caught.\n     *\n     * @private\n     *\n     * @param {string} name - Name of the layer that was removed.\n     */\n\n  }, {\n    key: "_onLayerRemoved",\n    value: function _onLayerRemoved(_ref2) {\n      var name = _ref2.name;\n    }\n    /**\n     * Executed when animation layer renamed events are caught.\n     *\n     * @private\n     *\n     * @param {string} oldName - Name of the layer that was renamed.\n     * @param {string} newName - New name of the layer.\n     */\n\n  }, {\n    key: "_onLayerRenamed",\n    value: function _onLayerRenamed(_ref3) {\n      var oldName = _ref3.oldName,\n          newName = _ref3.newName;\n    }\n    /**\n     * Executed when animation added events are caught.\n     *\n     * @private\n     *\n     * @param {string} layerName - Name of the layer that an animation was added to.\n     * @param {string} animationName - Name of the animation that was added.\n     */\n\n  }, {\n    key: "_onAnimationAdded",\n    value: function _onAnimationAdded(_ref4) {\n      var layerName = _ref4.layerName,\n          animationName = _ref4.animationName;\n    }\n    /**\n     * Executed when animation removed events are caught.\n     *\n     * @private\n     *\n     * @param {string} layerName - Name of the layer that an animation was removed from.\n     * @param {string} animationName - Name of the animation that was removed.\n     */\n\n  }, {\n    key: "_onAnimationRemoved",\n    value: function _onAnimationRemoved(_ref5) {\n      var layerName = _ref5.layerName,\n          animationName = _ref5.animationName;\n    }\n    /**\n     * Executed when animation renamed events are caught.\n     *\n     * @private\n     *\n     * @param {string} layerName - Name of the layer that an animation belongs to.\n     * @param {string} oldName - Name of the animation that was renamed.\n     * @param {string} newName - New name of the animation.\n     */\n\n  }, {\n    key: "_onAnimationRenamed",\n    value: function _onAnimationRenamed(_ref6) {\n      var layerName = _ref6.layerName,\n          oldName = _ref6.oldName,\n          newName = _ref6.newName;\n    }\n    /**\n     * Creates a class that implements {@link AnimationFeatureDependentInterface}\n     * and extends a specified base class.\n     *\n     * @param {Class} BaseClass - The class to extend.\n     *\n     * @return {Class} A class that extends `BaseClass` and implements {@link AnimationFeatureDependentInterface}.\n     */\n\n  }], [{\n    key: "Mixin",\n    value: function Mixin(BaseClass) {\n      var ParentClass = core_FeatureDependentInterface.Mixin(BaseClass);\n\n      var AnimationFeatureDependentMixin = /*#__PURE__*/function (_ParentClass) {\n        AnimationFeatureDependentInterface_inherits(AnimationFeatureDependentMixin, _ParentClass);\n\n        var _super2 = AnimationFeatureDependentInterface_createSuper(AnimationFeatureDependentMixin);\n\n        function AnimationFeatureDependentMixin() {\n          AnimationFeatureDependentInterface_classCallCheck(this, AnimationFeatureDependentMixin);\n\n          return _super2.apply(this, arguments);\n        }\n\n        AnimationFeatureDependentInterface_createClass(AnimationFeatureDependentMixin, [{\n          key: "_onLayerAdded",\n          value: function _onLayerAdded(_ref7) {\n            var name = _ref7.name;\n          }\n        }, {\n          key: "_onLayerRemoved",\n          value: function _onLayerRemoved(_ref8) {\n            var name = _ref8.name;\n          }\n        }, {\n          key: "_onLayerRenamed",\n          value: function _onLayerRenamed(_ref9) {\n            var oldName = _ref9.oldName,\n                newName = _ref9.newName;\n          }\n        }, {\n          key: "_onAnimationAdded",\n          value: function _onAnimationAdded(_ref10) {\n            var layerName = _ref10.layerName,\n                animationName = _ref10.animationName;\n          }\n        }, {\n          key: "_onAnimationRemoved",\n          value: function _onAnimationRemoved(_ref11) {\n            var layerName = _ref11.layerName,\n                animationName = _ref11.animationName;\n          }\n        }, {\n          key: "_onAnimationRenamed",\n          value: function _onAnimationRenamed(_ref12) {\n            var layerName = _ref12.layerName,\n                oldName = _ref12.oldName,\n                newName = _ref12.newName;\n          }\n        }]);\n\n        return AnimationFeatureDependentMixin;\n      }(ParentClass);\n\n      Object.defineProperties(AnimationFeatureDependentMixin, {\n        EVENT_DEPENDENCIES: {\n          value: AnimationFeatureDependentInterface_objectSpread(AnimationFeatureDependentInterface_objectSpread({}, ParentClass.EVENT_DEPENDENCIES), AnimationFeatureDependentInterface.EVENT_DEPENDENCIES),\n          writable: false\n        }\n      });\n      return AnimationFeatureDependentMixin;\n    }\n  }]);\n\n  return AnimationFeatureDependentInterface;\n}(core_FeatureDependentInterface);\n\nObject.defineProperties(AnimationFeatureDependentInterface, {\n  EVENT_DEPENDENCIES: {\n    value: {\n      AnimationFeature: {\n        addLayer: \'_onLayerAdded\',\n        removeLayer: \'_onLayerRemoved\',\n        renameLayer: \'_onLayerRenamed\',\n        addAnimation: \'_onAnimationAdded\',\n        removeAnimation: \'_onAnimationRemoved\',\n        renameAnimation: \'_onAnimationRenamed\'\n      }\n    },\n    writable: false\n  }\n});\n/* harmony default export */ const animpack_AnimationFeatureDependentInterface = (AnimationFeatureDependentInterface);\n;// CONCATENATED MODULE: ./src/core/animpack/ManagedAnimationLayerInterface.js\nfunction ManagedAnimationLayerInterface_typeof(obj) { "@babel/helpers - typeof"; return ManagedAnimationLayerInterface_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, ManagedAnimationLayerInterface_typeof(obj); }\n\nfunction ManagedAnimationLayerInterface_slicedToArray(arr, i) { return ManagedAnimationLayerInterface_arrayWithHoles(arr) || ManagedAnimationLayerInterface_iterableToArrayLimit(arr, i) || ManagedAnimationLayerInterface_unsupportedIterableToArray(arr, i) || ManagedAnimationLayerInterface_nonIterableRest(); }\n\nfunction ManagedAnimationLayerInterface_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction ManagedAnimationLayerInterface_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return ManagedAnimationLayerInterface_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return ManagedAnimationLayerInterface_arrayLikeToArray(o, minLen); }\n\nfunction ManagedAnimationLayerInterface_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ManagedAnimationLayerInterface_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction ManagedAnimationLayerInterface_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction ManagedAnimationLayerInterface_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction ManagedAnimationLayerInterface_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ManagedAnimationLayerInterface_ownKeys(Object(source), !0).forEach(function (key) { ManagedAnimationLayerInterface_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ManagedAnimationLayerInterface_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction ManagedAnimationLayerInterface_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ManagedAnimationLayerInterface_get() { if (typeof Reflect !== "undefined" && Reflect.get) { ManagedAnimationLayerInterface_get = Reflect.get; } else { ManagedAnimationLayerInterface_get = function _get(target, property, receiver) { var base = ManagedAnimationLayerInterface_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return ManagedAnimationLayerInterface_get.apply(this, arguments); }\n\nfunction ManagedAnimationLayerInterface_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = ManagedAnimationLayerInterface_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction ManagedAnimationLayerInterface_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction ManagedAnimationLayerInterface_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction ManagedAnimationLayerInterface_createClass(Constructor, protoProps, staticProps) { if (protoProps) ManagedAnimationLayerInterface_defineProperties(Constructor.prototype, protoProps); if (staticProps) ManagedAnimationLayerInterface_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction ManagedAnimationLayerInterface_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) ManagedAnimationLayerInterface_setPrototypeOf(subClass, superClass); }\n\nfunction ManagedAnimationLayerInterface_setPrototypeOf(o, p) { ManagedAnimationLayerInterface_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return ManagedAnimationLayerInterface_setPrototypeOf(o, p); }\n\nfunction ManagedAnimationLayerInterface_createSuper(Derived) { var hasNativeReflectConstruct = ManagedAnimationLayerInterface_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = ManagedAnimationLayerInterface_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = ManagedAnimationLayerInterface_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return ManagedAnimationLayerInterface_possibleConstructorReturn(this, result); }; }\n\nfunction ManagedAnimationLayerInterface_possibleConstructorReturn(self, call) { if (call && (ManagedAnimationLayerInterface_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return ManagedAnimationLayerInterface_assertThisInitialized(self); }\n\nfunction ManagedAnimationLayerInterface_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction ManagedAnimationLayerInterface_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction ManagedAnimationLayerInterface_getPrototypeOf(o) { ManagedAnimationLayerInterface_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return ManagedAnimationLayerInterface_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable no-unused-vars */\n\n/* eslint-disable max-classes-per-file */\n\n/**\n * Class factory interface for that keeps track of layers and animations on a host.\n * Tracked assets are marked as inactive until layers and animations with matching\n * names are detected as present on the host.\n *\n * @interface\n * @extends AnimationFeatureDependentInterface\n *\n * @property {Object} DEFAULT_LAYER_OPTIONS - Default options to use when executing\n * {@link AnimationLayer} methods.\n * @property {number} [DEFAULT_LAYER_OPTIONS.blendTime=0.5] - Default time in seconds\n * to use when executing {@link AnimationLayer.setBlendWeight}.\n * @property {Object} [DEFAULT_LAYER_OPTIONS.animations={}] - Maps animation names\n * to default options objects to use for managed animations.\n */\n\nvar ManagedAnimationLayerInterface = /*#__PURE__*/function (_AnimationFeatureDepe) {\n  ManagedAnimationLayerInterface_inherits(ManagedAnimationLayerInterface, _AnimationFeatureDepe);\n\n  var _super = ManagedAnimationLayerInterface_createSuper(ManagedAnimationLayerInterface);\n\n  function ManagedAnimationLayerInterface() {\n    ManagedAnimationLayerInterface_classCallCheck(this, ManagedAnimationLayerInterface);\n\n    return _super.apply(this, arguments);\n  }\n\n  ManagedAnimationLayerInterface_createClass(ManagedAnimationLayerInterface, [{\n    key: "registerLayer",\n    value:\n    /**\n     * Start tracking keeping track of whether a layer with the given name is present\n     * on the host.\n     *\n     * @param {string} name - Name of the layer to keep track of.\n     * @param {Object=} options - Options for the layer.\n     * @param {number=} options.blendTime - Default amount of time to use when\n     * manipulating layer weights on this layer.\n     * @param {Function=} options.easingFn - Default easing function to use when\n     * manipulating layer weights on this layer.\n     * @param {Object=} options.animations - Animations to keep track of on the layer.\n     * Animations are represented as key/value pairs of animation names and their\n     * options.\n     */\n    function registerLayer(name) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    }\n    /**\n     * Start tracking keeping track of whether an animation with the given name is\n     * present on the host.\n     *\n     * @param {string} layerName - Name of the layer that will own the animation.\n     * @param {string} animationName - Name of the animation to keep track of.\n     * @param {Object=} options - Options for the animation.\n     */\n\n  }, {\n    key: "registerAnimation",\n    value: function registerAnimation(layerName, animationName) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    }\n    /**\n     * Set layer weights on tracked layers.\n     *\n     * @param {Function=} nameFilter - Predicate function to test each tracked layer\n     * with. By default all layers will pass.\n     * @param {number} weight - Weight value to set on layers.\n     * @param {number=} seconds - Number of seconds it will take to reach the weight\n     * on each layer. If undefined, each layers\' blendTime option is used.\n     * @param {Function=} easingFn - Easing function to use when setting weight\n     * on each layer. If undefined, each layers\' easingFn option is used.\n     */\n\n  }, {\n    key: "setLayerWeights",\n    value: function setLayerWeights() {\n      var nameFilter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {\n        return true;\n      };\n      var weight = arguments.length > 1 ? arguments[1] : undefined;\n      var seconds = arguments.length > 2 ? arguments[2] : undefined;\n      var easingFn = arguments.length > 3 ? arguments[3] : undefined;\n    }\n    /**\n     * Set all tracked layers\' weights to 1.\n     *\n     * @param {number=} seconds - Number of seconds it will take to reach the weight\n     * on each layer. If undefined, each layers\' blendTime option is used.\n     * @param {Function=} easingFn - Easing function to use when setting weight\n     * on each layer. If undefined, each layers\' easingFn option is used.\n     */\n\n  }, {\n    key: "enable",\n    value: function enable(seconds, easingFn) {}\n    /**\n     * Set all tracked layers\' weights to 0.\n     *\n     * @param {number=} seconds - Number of seconds it will take to reach the weight\n     * on each layer. If undefined, each layers\' blendTime option is used.\n     * @param {Function=} easingFn - Easing function to use when setting weight\n     * on each layer. If undefined, each layers\' easingFn option is used.\n     */\n\n  }, {\n    key: "disable",\n    value: function disable(seconds, easingFn) {}\n    /**\n     * Creates a class that implements {@link ManagedAnimationLayerInterface}\n     * and extends a specified base class.\n     *\n     * @param {Class} BaseClass - The class to extend.\n     *\n     * @return {Class} A class that extends `BaseClass` and implements {@link ManagedAnimationLayerInterface}.\n     */\n\n  }], [{\n    key: "Mixin",\n    value: function Mixin(BaseClass) {\n      var ParentClass = animpack_AnimationFeatureDependentInterface.Mixin(BaseClass);\n\n      var ManagedAnimationLayerMixin = /*#__PURE__*/function (_ParentClass) {\n        ManagedAnimationLayerInterface_inherits(ManagedAnimationLayerMixin, _ParentClass);\n\n        var _super2 = ManagedAnimationLayerInterface_createSuper(ManagedAnimationLayerMixin);\n\n        function ManagedAnimationLayerMixin() {\n          var _this;\n\n          ManagedAnimationLayerInterface_classCallCheck(this, ManagedAnimationLayerMixin);\n\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          _this = _super2.call.apply(_super2, [this].concat(args));\n          _this._managedLayers = {};\n          return _this;\n        }\n\n        ManagedAnimationLayerInterface_createClass(ManagedAnimationLayerMixin, [{\n          key: "_onFeatureAdded",\n          value: function _onFeatureAdded(typeName) {\n            var _this2 = this;\n\n            ManagedAnimationLayerInterface_get(ManagedAnimationLayerInterface_getPrototypeOf(ManagedAnimationLayerMixin.prototype), "_onFeatureAdded", this).call(this, typeName);\n\n            if (typeName !== \'AnimationFeature\') {\n              return;\n            }\n\n            this._managedLayers = this._managedLayers || {}; // Detect new layers\n\n            this._host.AnimationFeature.layers.forEach(function (name) {\n              _this2._onLayerAdded({\n                name: name\n              });\n            });\n          }\n        }, {\n          key: "_onFeatureRemoved",\n          value: function _onFeatureRemoved(typeName) {\n            var _this3 = this;\n\n            ManagedAnimationLayerInterface_get(ManagedAnimationLayerInterface_getPrototypeOf(ManagedAnimationLayerMixin.prototype), "_onFeatureRemoved", this).call(this, typeName);\n\n            if (typeName !== \'AnimationFeature\') {\n              return;\n            }\n\n            this._managedLayers = this._managedLayers || {}; // Deactivate the layers\n\n            Object.keys(this._managedLayers).forEach(function (name) {\n              _this3._onLayerRemoved({\n                name: name\n              });\n            });\n          }\n        }, {\n          key: "_onLayerAdded",\n          value: function _onLayerAdded(_ref) {\n            var _this4 = this;\n\n            var name = _ref.name;\n\n            // Mark the layer as active if it is managed\n            if (this._managedLayers[name] !== undefined) {\n              this._managedLayers[name].isActive = true; // Detect new animations\n\n              this._host.AnimationFeature.getAnimations(name).forEach(function (animName) {\n                _this4._onAnimationAdded({\n                  layerName: name,\n                  animationName: animName\n                });\n              });\n            }\n          }\n        }, {\n          key: "_onLayerRemoved",\n          value: function _onLayerRemoved(_ref2) {\n            var _this5 = this;\n\n            var name = _ref2.name;\n\n            // Deactivate the layer if it is managed\n            if (this._managedLayers[name] !== undefined) {\n              this._managedLayers[name].isActive = false; // Deactivate the animations\n\n              Object.keys(this._managedLayers[name].animations).forEach(function (animName) {\n                _this5._onAnimationRemoved({\n                  layerName: name,\n                  animationName: animName\n                });\n              });\n            }\n          }\n        }, {\n          key: "_onLayerRenamed",\n          value: function _onLayerRenamed(_ref3) {\n            var oldName = _ref3.oldName,\n                newName = _ref3.newName;\n            var layerOptions = this._managedLayers[oldName]; // Replace the layer key with the new name\n\n            if (layerOptions !== undefined) {\n              delete this._managedLayers[oldName];\n              this._managedLayers[newName] = layerOptions;\n            }\n          }\n        }, {\n          key: "_onAnimationAdded",\n          value: function _onAnimationAdded(_ref4) {\n            var layerName = _ref4.layerName,\n                animationName = _ref4.animationName;\n\n            // Mark the animation as active if it is managed\n            if (this._managedLayers[layerName] !== undefined && this._managedLayers[layerName].animations[animationName] !== undefined) {\n              this._managedLayers[layerName].animations[animationName].isActive = true;\n            }\n          }\n        }, {\n          key: "_onAnimationRemoved",\n          value: function _onAnimationRemoved(_ref5) {\n            var layerName = _ref5.layerName,\n                animationName = _ref5.animationName;\n\n            // Deactivate the animation if it is managed\n            if (this._managedLayers[layerName] !== undefined && this._managedLayers[layerName].animations[animationName] !== undefined) {\n              this._managedLayers[layerName].animations[animationName].isActive = false;\n            }\n          }\n        }, {\n          key: "_onAnimationRenamed",\n          value: function _onAnimationRenamed(_ref6) {\n            var layerName = _ref6.layerName,\n                oldName = _ref6.oldName,\n                newName = _ref6.newName;\n\n            if (this._managedLayers[layerName] !== undefined && this._managedLayers[layerName].animations[oldName] !== undefined) {\n              // Replace the animation key with the new name\n              var animOptions = this._managedLayers[layerName].animations[oldName];\n              delete this._managedLayers[layerName].animations[oldName];\n              this._managedLayers[layerName].animations[newName] = animOptions;\n            }\n          }\n        }, {\n          key: "registerLayer",\n          value: function registerLayer(name) {\n            var _this6 = this;\n\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            // Start with default options for each new layer\n            if (this._managedLayers[name] === undefined) {\n              this._managedLayers[name] = ManagedAnimationLayerInterface_objectSpread(ManagedAnimationLayerInterface_objectSpread({}, this.constructor.DEFAULT_LAYER_OPTIONS), {}, {\n                animations: {}\n              });\n            } // Update all options except animations\n\n\n            var layerOptions = this._managedLayers[name];\n            options = ManagedAnimationLayerInterface_objectSpread({}, options);\n            var animationOptions = options.animations || {};\n            delete options.animations;\n            Object.assign(layerOptions, options); // Check whether the layer can be manipulated now\n\n            layerOptions.isActive = this._host.AnimationFeature !== undefined && this._host.AnimationFeature.layers.includes(name); // Register the animations\n\n            Object.entries(animationOptions).forEach(function (_ref7) {\n              var _ref8 = ManagedAnimationLayerInterface_slicedToArray(_ref7, 2),\n                  animName = _ref8[0],\n                  animOptions = _ref8[1];\n\n              _this6.registerAnimation(name, animName, animOptions);\n            });\n          }\n        }, {\n          key: "registerAnimation",\n          value: function registerAnimation(layerName, animationName) {\n            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n            // Register the layer if it hasn\'t been registered yet\n            if (this._managedLayers[layerName] === undefined) {\n              this.registerLayer(layerName);\n            } // Update animation options\n\n\n            var animOptions = this._managedLayers[layerName].animations[animationName] || {};\n            Object.assign(animOptions, options);\n            this._managedLayers[layerName].animations[animationName] = animOptions; // Check whether the animation can be manipulated now\n\n            this._managedLayers[layerName].animations[animationName].isActive = this._managedLayers[layerName].isActive && this._host.AnimationFeature.getAnimations(layerName).includes(animationName);\n          }\n        }, {\n          key: "setLayerWeights",\n          value: function setLayerWeights() {\n            var _this7 = this;\n\n            var nameFilter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {\n              return true;\n            };\n            var weight = arguments.length > 1 ? arguments[1] : undefined;\n            var seconds = arguments.length > 2 ? arguments[2] : undefined;\n            var easingFn = arguments.length > 3 ? arguments[3] : undefined;\n            var layerNames = Object.keys(this._managedLayers).filter(nameFilter);\n            layerNames.forEach(function (name) {\n              var layerOptions = _this7._managedLayers[name];\n\n              if (layerOptions.isActive) {\n                _this7._host.AnimationFeature.setLayerWeight(name, weight, seconds !== undefined ? seconds : layerOptions.blendTime, easingFn || layerOptions.easingFn);\n              }\n            });\n          }\n        }, {\n          key: "enable",\n          value: function enable(seconds, easingFn) {\n            this.setLayerWeights(undefined, 1, seconds, easingFn);\n          }\n        }, {\n          key: "disable",\n          value: function disable(seconds, easingFn) {\n            this.setLayerWeights(undefined, 0, seconds, easingFn);\n          }\n        }, {\n          key: "installApi",\n          value: function installApi() {\n            var api = ManagedAnimationLayerInterface_get(ManagedAnimationLayerInterface_getPrototypeOf(ManagedAnimationLayerMixin.prototype), "installApi", this).call(this);\n\n            Object.assign(api, {\n              registerLayer: this.registerLayer.bind(this),\n              registerAnimation: this.registerAnimation.bind(this),\n              setLayerWeights: this.setLayerWeights.bind(this),\n              enable: this.enable.bind(this),\n              disable: this.disable.bind(this)\n            });\n            return api;\n          }\n        }]);\n\n        return ManagedAnimationLayerMixin;\n      }(ParentClass);\n\n      Object.defineProperties(ManagedAnimationLayerMixin, {\n        DEFAULT_LAYER_OPTIONS: {\n          value: ManagedAnimationLayerInterface.DEFAULT_LAYER_OPTIONS,\n          writable: false\n        }\n      });\n      return ManagedAnimationLayerMixin;\n    }\n  }]);\n\n  return ManagedAnimationLayerInterface;\n}(animpack_AnimationFeatureDependentInterface);\n\nObject.defineProperties(ManagedAnimationLayerInterface, {\n  DEFAULT_LAYER_OPTIONS: {\n    value: {\n      blendTime: 0.5,\n      animations: {}\n    },\n    writable: false\n  }\n});\n/* harmony default export */ const animpack_ManagedAnimationLayerInterface = (ManagedAnimationLayerInterface);\n;// CONCATENATED MODULE: ./src/core/awspack/TextToSpeechFeatureDependentInterface.js\nfunction TextToSpeechFeatureDependentInterface_typeof(obj) { "@babel/helpers - typeof"; return TextToSpeechFeatureDependentInterface_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, TextToSpeechFeatureDependentInterface_typeof(obj); }\n\nfunction TextToSpeechFeatureDependentInterface_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction TextToSpeechFeatureDependentInterface_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? TextToSpeechFeatureDependentInterface_ownKeys(Object(source), !0).forEach(function (key) { TextToSpeechFeatureDependentInterface_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : TextToSpeechFeatureDependentInterface_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction TextToSpeechFeatureDependentInterface_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TextToSpeechFeatureDependentInterface_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction TextToSpeechFeatureDependentInterface_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction TextToSpeechFeatureDependentInterface_createClass(Constructor, protoProps, staticProps) { if (protoProps) TextToSpeechFeatureDependentInterface_defineProperties(Constructor.prototype, protoProps); if (staticProps) TextToSpeechFeatureDependentInterface_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction TextToSpeechFeatureDependentInterface_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) TextToSpeechFeatureDependentInterface_setPrototypeOf(subClass, superClass); }\n\nfunction TextToSpeechFeatureDependentInterface_setPrototypeOf(o, p) { TextToSpeechFeatureDependentInterface_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return TextToSpeechFeatureDependentInterface_setPrototypeOf(o, p); }\n\nfunction TextToSpeechFeatureDependentInterface_createSuper(Derived) { var hasNativeReflectConstruct = TextToSpeechFeatureDependentInterface_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = TextToSpeechFeatureDependentInterface_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = TextToSpeechFeatureDependentInterface_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return TextToSpeechFeatureDependentInterface_possibleConstructorReturn(this, result); }; }\n\nfunction TextToSpeechFeatureDependentInterface_possibleConstructorReturn(self, call) { if (call && (TextToSpeechFeatureDependentInterface_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return TextToSpeechFeatureDependentInterface_assertThisInitialized(self); }\n\nfunction TextToSpeechFeatureDependentInterface_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction TextToSpeechFeatureDependentInterface_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction TextToSpeechFeatureDependentInterface_getPrototypeOf(o) { TextToSpeechFeatureDependentInterface_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return TextToSpeechFeatureDependentInterface_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable max-classes-per-file */\n\n/**\n * Class factory interface for features that are dependent on the TextToSpeechFeature\n * being present on the host. Speech events will automatically be listened for once a\n * TextToSpeechFeature is added to the host and stopped once it is removed.\n *\n * @interface\n * @extends FeatureDependentInterface\n *\n * @property {Object} EVENT_DEPENDENCIES - Events that the feature should start/stop\n * listening for when a feature of type FeatureName is added/removed from the host.\n * @property {Object} EVENT_DEPENDENCIES.TextToSpeechFeature - Events that are\n * specific to the TextToSpeechFeature.\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.play=\'_onPlay\'] -\n * The name of the method that will be executed when TextToSpeechFeature play\n * events are emitted.\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.pause=\'_onPause\'] -\n * The name of the method that will be executed when TextToSpeechFeature pause\n * events are emitted.\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.resume=\'_onResume\'] -\n * The name of the method that will be executed when TextToSpeechFeature resume\n * events are emitted.\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.stop=\'_onStop\'] -\n * The name of the method that will be executed when TextToSpeechFeature stop\n * events are emitted.\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.sentence=\'_onSentence\'] -\n * The name of the method that will be executed when TextToSpeechFeature sentence\n * events are emitted.\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.word=\'_onWord\'] -\n * The name of the method that will be executed when TextToSpeechFeature word\n * events are emitted.\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.viseme=\'_onViseme\'] -\n * The name of the method that will be executed when TextToSpeechFeature viseme\n * events are emitted.\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.ssml=\'_onSsml\'] -\n * The name of the method that will be executed when TextToSpeechFeature ssml\n * events are emitted.\n */\n\nvar TextToSpeechFeatureDependentInterface = /*#__PURE__*/function (_FeatureDependentInte) {\n  TextToSpeechFeatureDependentInterface_inherits(TextToSpeechFeatureDependentInterface, _FeatureDependentInte);\n\n  var _super = TextToSpeechFeatureDependentInterface_createSuper(TextToSpeechFeatureDependentInterface);\n\n  function TextToSpeechFeatureDependentInterface() {\n    TextToSpeechFeatureDependentInterface_classCallCheck(this, TextToSpeechFeatureDependentInterface);\n\n    return _super.apply(this, arguments);\n  }\n\n  TextToSpeechFeatureDependentInterface_createClass(TextToSpeechFeatureDependentInterface, [{\n    key: "_onPlay",\n    value:\n    /**\n     * Executed when speech play events are caught.\n     *\n     * @private\n     */\n    function _onPlay() {}\n    /**\n     * Executed when speech pause events are caught.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_onPause",\n    value: function _onPause() {}\n    /**\n     * Executed when speech resume events are caught.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_onResume",\n    value: function _onResume() {}\n    /**\n     * Executed when speech stop events are caught.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_onStop",\n    value: function _onStop() {}\n    /**\n     * Executed when speech sentence events are caught.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_onSentence",\n    value: function _onSentence() {}\n    /**\n     * Executed when speech word events are caught.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_onWord",\n    value: function _onWord() {}\n    /**\n     * Executed when speech viseme events are caught.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_onViseme",\n    value: function _onViseme() {}\n    /**\n     * Executed when speech ssml events are caught.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_onSsml",\n    value: function _onSsml() {}\n    /**\n     * Creates a class that implements {@link TextToSpeechFeatureDependentInterface}\n     * and extends a specified base class.\n     *\n     * @param {Class} BaseClass - The class to extend.\n     *\n     * @return {Class} A class that extends `BaseClass` and implements {@link TextToSpeechFeatureDependentInterface}.\n     */\n\n  }], [{\n    key: "Mixin",\n    value: function Mixin(BaseClass) {\n      var ParentClass = core_FeatureDependentInterface.Mixin(BaseClass);\n\n      var TextToSpeechFeatureDependentMixin = /*#__PURE__*/function (_ParentClass) {\n        TextToSpeechFeatureDependentInterface_inherits(TextToSpeechFeatureDependentMixin, _ParentClass);\n\n        var _super2 = TextToSpeechFeatureDependentInterface_createSuper(TextToSpeechFeatureDependentMixin);\n\n        function TextToSpeechFeatureDependentMixin() {\n          TextToSpeechFeatureDependentInterface_classCallCheck(this, TextToSpeechFeatureDependentMixin);\n\n          return _super2.apply(this, arguments);\n        }\n\n        TextToSpeechFeatureDependentInterface_createClass(TextToSpeechFeatureDependentMixin, [{\n          key: "_onPlay",\n          value: function _onPlay() {}\n        }, {\n          key: "_onPause",\n          value: function _onPause() {}\n        }, {\n          key: "_onResume",\n          value: function _onResume() {}\n        }, {\n          key: "_onStop",\n          value: function _onStop() {}\n        }, {\n          key: "_onSentence",\n          value: function _onSentence() {}\n        }, {\n          key: "_onWord",\n          value: function _onWord() {}\n        }, {\n          key: "_onViseme",\n          value: function _onViseme() {}\n        }, {\n          key: "_onSsml",\n          value: function _onSsml() {}\n        }]);\n\n        return TextToSpeechFeatureDependentMixin;\n      }(ParentClass);\n\n      Object.defineProperties(TextToSpeechFeatureDependentMixin, {\n        EVENT_DEPENDENCIES: {\n          value: TextToSpeechFeatureDependentInterface_objectSpread(TextToSpeechFeatureDependentInterface_objectSpread({}, ParentClass.EVENT_DEPENDENCIES), TextToSpeechFeatureDependentInterface.EVENT_DEPENDENCIES),\n          writable: false\n        }\n      });\n      return TextToSpeechFeatureDependentMixin;\n    }\n  }]);\n\n  return TextToSpeechFeatureDependentInterface;\n}(core_FeatureDependentInterface);\n\nObject.defineProperties(TextToSpeechFeatureDependentInterface, {\n  EVENT_DEPENDENCIES: {\n    value: {\n      TextToSpeechFeature: {\n        play: \'_onPlay\',\n        pause: \'_onPause\',\n        resume: \'_onResume\',\n        stop: \'_onStop\',\n        sentence: \'_onSentence\',\n        word: \'_onWord\',\n        viseme: \'_onViseme\',\n        ssml: \'_onSsml\'\n      }\n    },\n    writable: false\n  }\n});\n/* harmony default export */ const awspack_TextToSpeechFeatureDependentInterface = (TextToSpeechFeatureDependentInterface);\n;// CONCATENATED MODULE: ./src/core/LipsyncFeature.js\nfunction LipsyncFeature_typeof(obj) { "@babel/helpers - typeof"; return LipsyncFeature_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, LipsyncFeature_typeof(obj); }\n\nfunction LipsyncFeature_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction LipsyncFeature_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? LipsyncFeature_ownKeys(Object(source), !0).forEach(function (key) { LipsyncFeature_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : LipsyncFeature_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction LipsyncFeature_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\nfunction LipsyncFeature_slicedToArray(arr, i) { return LipsyncFeature_arrayWithHoles(arr) || LipsyncFeature_iterableToArrayLimit(arr, i) || LipsyncFeature_unsupportedIterableToArray(arr, i) || LipsyncFeature_nonIterableRest(); }\n\nfunction LipsyncFeature_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction LipsyncFeature_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return LipsyncFeature_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return LipsyncFeature_arrayLikeToArray(o, minLen); }\n\nfunction LipsyncFeature_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction LipsyncFeature_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction LipsyncFeature_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction LipsyncFeature_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction LipsyncFeature_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction LipsyncFeature_createClass(Constructor, protoProps, staticProps) { if (protoProps) LipsyncFeature_defineProperties(Constructor.prototype, protoProps); if (staticProps) LipsyncFeature_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction LipsyncFeature_get() { if (typeof Reflect !== "undefined" && Reflect.get) { LipsyncFeature_get = Reflect.get; } else { LipsyncFeature_get = function _get(target, property, receiver) { var base = LipsyncFeature_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return LipsyncFeature_get.apply(this, arguments); }\n\nfunction LipsyncFeature_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = LipsyncFeature_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction LipsyncFeature_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) LipsyncFeature_setPrototypeOf(subClass, superClass); }\n\nfunction LipsyncFeature_setPrototypeOf(o, p) { LipsyncFeature_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return LipsyncFeature_setPrototypeOf(o, p); }\n\nfunction LipsyncFeature_createSuper(Derived) { var hasNativeReflectConstruct = LipsyncFeature_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = LipsyncFeature_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = LipsyncFeature_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return LipsyncFeature_possibleConstructorReturn(this, result); }; }\n\nfunction LipsyncFeature_possibleConstructorReturn(self, call) { if (call && (LipsyncFeature_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return LipsyncFeature_assertThisInitialized(self); }\n\nfunction LipsyncFeature_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction LipsyncFeature_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction LipsyncFeature_getPrototypeOf(o) { LipsyncFeature_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return LipsyncFeature_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n\n/**\n * Default mapping of Polly viseme names to animation options objects.\n *\n * @property {Object} [sil={name: \'sil\'}]\n * @property {Object} [p={name: \'p\', overrideWeight: 0.9}]\n * @property {Object} [t={name: \'t\', blendTime: 0.2}]\n * @property {Object} [S={name: \'S\'}]\n * @property {Object} [T={name: \'T\'}]\n * @property {Object} [f={name: \'f\', overrideWeight: 0.75}]\n * @property {Object} [k={name: \'k\'}]\n * @property {Object} [i={name: \'i\'}]\n * @property {Object} [r={name: \'r\'}]\n * @property {Object} [s={name: \'s\', blendTime: 0.25}]\n * @property {Object} [u={name: \'u\'}]\n * @property {Object} [@={name: \'@\'}]\n * @property {Object} [a={name: \'a\'}]\n * @property {Object} [e={name: \'e\', blendTime: 0.2}]\n * @property {Object} [E={name: \'E\'}]\n * @property {Object} [o={name: \'o\'}]\n * @property {Object} [O={name: \'O\'}]\n */\n\nvar DefaultVisemeMap = {\n  sil: {\n    name: \'sil\'\n  },\n  p: {\n    name: \'p\',\n    overrideWeight: 0.9\n  },\n  t: {\n    name: \'t\',\n    blendTime: 0.2\n  },\n  S: {\n    name: \'S\'\n  },\n  T: {\n    name: \'T\'\n  },\n  f: {\n    name: \'f\',\n    overrideWeight: 0.75\n  },\n  k: {\n    name: \'k\'\n  },\n  i: {\n    name: \'i\'\n  },\n  r: {\n    name: \'r\'\n  },\n  s: {\n    name: \'s\',\n    blendTime: 0.25\n  },\n  u: {\n    name: \'u\'\n  },\n  \'@\': {\n    name: \'@\'\n  },\n  a: {\n    name: \'a\'\n  },\n  e: {\n    name: \'e\',\n    blendTime: 0.2\n  },\n  E: {\n    name: \'E\'\n  },\n  o: {\n    name: \'o\'\n  },\n  O: {\n    name: \'O\'\n  }\n};\n/**\n * Lipsync controls two types of movement: idle animation that should play while\n * speech is playing and viseme animations corresponding to Polly visemes whose\n * weights should be turned on and off as they are encountered in the Polly SSML\n * transcript. Layers owned by this feature will be enabled while speech is playing\n * and disabled once it stops.\n *\n * @extends AbstractHostFeature\n * @alias core/LipsyncFeature\n * @implements TextToSpeechFeatureDependentInterface\n * @implements ManagedAnimationLayerInterface\n */\n\nvar LipsyncFeature = /*#__PURE__*/function (_AbstractHostFeature$) {\n  LipsyncFeature_inherits(LipsyncFeature, _AbstractHostFeature$);\n\n  var _super = LipsyncFeature_createSuper(LipsyncFeature);\n\n  /**\n   * @constructor\n   *\n   * @param {core/HostObject} host - Host that owns the feature.\n   * @param {Object=} visemeOptions - Options for the viseme layers.\n   * @param {number} [visemeOptions.blendTime=0.15] - Default amount of time it\n   * will take to manipulate each freeBlend weight on the viseme states.\n   * @param {Object} [visemeOptions.decayRate={amount: .5, seconds: .5}] - An object\n   * describing the 0-1 factor viseme weight will decay if the viseme duration is\n   * longer than the blendTime and the number of seconds it would take to decay\n   * by that factor.\n   * @param {number} [visemeOptions.easingFn=Quadratic.InOut] - Default easing function\n   * to use when manipulating viseme freeBlend weights.\n   * @param {Array.<Object>} [visemeOptions..layers=[]] - An array of layer options\n   * objects to register as viseme layers.\n   * @param {Object=} talkingOptions - Options for the talking layers.\n   * @param {number} [talkingOptions.blendTime=0.75] - Default amount of time to\n   * enable and disable the talking idle layers\n   * @param {number} [talkingOptions.easingFn=Quadratic.InOut] - Default easing\n   * function to use when manipulating weights on the talking idle layers.\n   * @param {Array.<Object>} [talkingOptions.layers=[]] - An array of layer options\n   * objects to register as talking layers.\n   * @param {number} [visemeLeadTime=.067] - The amount of time to instruct the\n   * TextToSpeechFeature to emit speechmarks before each one\'s actual timestamp\n   * is reached. This will set the \'speechMarkOffset\' variable on the TextToSpeechFeature.\n   */\n  function LipsyncFeature(host) {\n    var _this;\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$blendTime = _ref.blendTime,\n        visemeBlendTime = _ref$blendTime === void 0 ? 0.15 : _ref$blendTime,\n        _ref$decayRate = _ref.decayRate;\n\n    _ref$decayRate = _ref$decayRate === void 0 ? {} : _ref$decayRate;\n    var _ref$decayRate$amount = _ref$decayRate.amount,\n        amount = _ref$decayRate$amount === void 0 ? 0.5 : _ref$decayRate$amount,\n        _ref$decayRate$second = _ref$decayRate.seconds,\n        seconds = _ref$decayRate$second === void 0 ? 0.5 : _ref$decayRate$second,\n        _ref$easingFn = _ref.easingFn,\n        visemeEasingFn = _ref$easingFn === void 0 ? Quadratic.InOut : _ref$easingFn,\n        _ref$layers = _ref.layers,\n        visemeLayers = _ref$layers === void 0 ? [] : _ref$layers;\n\n    var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref2$blendTime = _ref2.blendTime,\n        talkingBlendTime = _ref2$blendTime === void 0 ? 0.75 : _ref2$blendTime,\n        _ref2$easingFn = _ref2.easingFn,\n        talkingEasingFn = _ref2$easingFn === void 0 ? Quadratic.InOut : _ref2$easingFn,\n        _ref2$layers = _ref2.layers,\n        talkingLayers = _ref2$layers === void 0 ? [] : _ref2$layers;\n\n    var visemeLeadTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.067;\n\n    LipsyncFeature_classCallCheck(this, LipsyncFeature);\n\n    _this = _super.call(this, host);\n    _this._visemeLayers = {};\n    _this._talkingLayers = {};\n    _this.visemeLeadTime = visemeLeadTime; // Register the viseme layers\n\n    visemeLayers.forEach(function (_ref3) {\n      var name = _ref3.name,\n          animation = _ref3.animation,\n          _ref3$visemeMap = _ref3.visemeMap,\n          visemeMap = _ref3$visemeMap === void 0 ? DefaultVisemeMap : _ref3$visemeMap;\n\n      _this.registerVisemeLayer(name, {\n        animation: animation,\n        visemeMap: visemeMap,\n        decayRate: {\n          amount: amount,\n          seconds: seconds\n        },\n        blendTime: visemeBlendTime,\n        easingFn: visemeEasingFn\n      });\n    }); // Register the talking layers\n\n    talkingLayers.forEach(function (_ref4) {\n      var name = _ref4.name,\n          animation = _ref4.animation;\n\n      _this.registerTalkingLayer(name, {\n        animation: animation,\n        blendTime: talkingBlendTime,\n        easingFn: talkingEasingFn\n      });\n    });\n    return _this;\n  }\n  /**\n   * Ensure that registered viseme animations are FreeBlendStates.\n   *\n   * @private\n   *\n   * @param {string} layerName - Name of the layer that contains the viseme animation.\n   * @param {string} animationName - Name of the animation.\n   */\n\n\n  LipsyncFeature_createClass(LipsyncFeature, [{\n    key: "_registerVisemeAnimation",\n    value: function _registerVisemeAnimation(layerName, animationName) {\n      if (this._managedLayers[layerName].animations[animationName].isActive) {\n        if (this._host.AnimationFeature.getAnimationType(layerName, animationName) !== \'freeBlend\') {\n          // Warn and deactivate if the registered state is not freeBlend\n          console.warn("Cannot register Lipsync viseme animation ".concat(animationName, " on layer ").concat(layerName, " for host ").concat(this._host.id, ". Viseme animations must be of type \'freeBlend\'."));\n          this._managedLayers[layerName].animations[animationName].isActive = false;\n        } else {\n          // Check if the blendWeights can be manipulated now\n          var weightNames = this._host.AnimationFeature.getAnimationBlendNames(layerName, animationName);\n\n          var visemeMap = this._managedLayers[layerName].animations[animationName].visemeMap;\n          Object.values(visemeMap).forEach(function (visemeOptions) {\n            visemeOptions.isActive = weightNames.includes(visemeOptions.name);\n          });\n        }\n      }\n    }\n    /**\n     * If the added feature is TextToSpeech, update its speechMarkOffset variable.\n     *\n     * @private\n     *\n     * @param {string} typeName - Name of the type of feature that was added.\n     */\n\n  }, {\n    key: "_onFeatureAdded",\n    value: function _onFeatureAdded(typeName) {\n      this._visemeLayers = this._visemeLayers || {};\n      this._talkingLayers = this._talkingLayers || {};\n\n      LipsyncFeature_get(LipsyncFeature_getPrototypeOf(LipsyncFeature.prototype), "_onFeatureAdded", this).call(this, typeName);\n\n      if (typeName === \'TextToSpeechFeature\') {\n        this._host.TextToSpeechFeature.speechmarkOffset = -this._visemeLeadTime || 0;\n      }\n    }\n  }, {\n    key: "_onLayerAdded",\n    value: function _onLayerAdded(_ref5) {\n      var name = _ref5.name;\n\n      LipsyncFeature_get(LipsyncFeature_getPrototypeOf(LipsyncFeature.prototype), "_onLayerAdded", this).call(this, {\n        name: name\n      }); // Validate the viseme animation\n\n\n      if (this._visemeLayers[name] !== undefined) {\n        this._registerVisemeAnimation(name, this._visemeLayers[name]);\n      }\n    }\n  }, {\n    key: "_onAnimationAdded",\n    value: function _onAnimationAdded(_ref6) {\n      var layerName = _ref6.layerName,\n          animationName = _ref6.animationName;\n\n      LipsyncFeature_get(LipsyncFeature_getPrototypeOf(LipsyncFeature.prototype), "_onAnimationAdded", this).call(this, {\n        layerName: layerName\n      }); // Validate the viseme animation\n\n\n      if (this._visemeLayers[layerName] === animationName) {\n        this._registerVisemeAnimation(layerName, this._visemeLayers[layerName]);\n      }\n    }\n  }, {\n    key: "_onPlay",\n    value: function _onPlay() {\n      var _this2 = this;\n\n      // Turn on the layer weights\n      this.enable(); // Set the current animations\n\n      [this._visemeLayers, this._talkingLayers].forEach(function (layers) {\n        Object.entries(layers).forEach(function (_ref7) {\n          var _ref8 = LipsyncFeature_slicedToArray(_ref7, 2),\n              layerName = _ref8[0],\n              animationName = _ref8[1];\n\n          if (_this2._managedLayers[layerName].animations[animationName].isActive) {\n            _this2._host.AnimationFeature.resumeAnimation(layerName, animationName);\n          }\n        });\n      });\n    }\n  }, {\n    key: "_onPause",\n    value: function _onPause() {\n      this._onStop();\n    }\n  }, {\n    key: "_onResume",\n    value: function _onResume() {\n      this._onPlay();\n    }\n  }, {\n    key: "_onStop",\n    value: function _onStop() {\n      var _this3 = this;\n\n      // Turn off the layer weights\n      this.disable(); // Pause the current animations\n\n      [this._visemeLayers, this._talkingLayers].forEach(function (layers) {\n        Object.entries(layers).forEach(function (_ref9) {\n          var _ref10 = LipsyncFeature_slicedToArray(_ref9, 2),\n              layerName = _ref10[0],\n              animationName = _ref10[1];\n\n          if (_this3._managedLayers[layerName].animations[animationName].isActive) {\n            _this3._host.AnimationFeature.pauseAnimation(layerName, animationName);\n          }\n        });\n      });\n    }\n    /**\n     * When viseme events are caught, turn on weight of the new viseme for the duration\n     * of the speech mark, then turn weight back off.\n     *\n     * @private\n     *\n     * @param {Object} event - Event data passed from the speech.\n     * @param {Object} event.mark - Speechmark object.\n     */\n\n  }, {\n    key: "_onViseme",\n    value: function () {\n      var _onViseme2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref11) {\n        var _this4 = this;\n\n        var mark;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                mark = _ref11.mark;\n                Object.entries(this._visemeLayers).forEach(function (_ref12) {\n                  var _ref13 = LipsyncFeature_slicedToArray(_ref12, 2),\n                      layerName = _ref13[0],\n                      animName = _ref13[1];\n\n                  // Make sure the layer can be manipulated\n                  var _this4$_managedLayers = _this4._managedLayers[layerName].animations[animName],\n                      isActive = _this4$_managedLayers.isActive,\n                      visemeMap = _this4$_managedLayers.visemeMap;\n\n                  if (!isActive) {\n                    return;\n                  } // Take variables from the viseme if they exist and default to the layer\n\n\n                  var _this4$_managedLayers2 = LipsyncFeature_objectSpread(LipsyncFeature_objectSpread({}, _this4._managedLayers[layerName]), visemeMap[mark.value]),\n                      viseme = _this4$_managedLayers2.name,\n                      isVisemeActive = _this4$_managedLayers2.isActive,\n                      decayRate = _this4$_managedLayers2.decayRate,\n                      blendTime = _this4$_managedLayers2.blendTime,\n                      easingFn = _this4$_managedLayers2.easingFn,\n                      overrideWeight = _this4$_managedLayers2.overrideWeight;\n\n                  var visemeNames = _this4._host.AnimationFeature.getAnimationBlendNames(layerName, animName); // Make sure the new viseme has an active freeBlend weight\n\n\n                  if (!isVisemeActive || !visemeNames.includes(viseme)) {\n                    return;\n                  } // Find the peak weight for the viseme and the amount of time it should\n                  // take to reach it\n\n\n                  var weight = 1;\n                  var duration = mark.duration / 1000;\n\n                  if (duration < blendTime) {\n                    var lerpFactor = blendTime > 0 ? duration / blendTime : 1;\n                    weight = overrideWeight !== undefined ? overrideWeight : core_MathUtils.lerp(0, 1, lerpFactor);\n                  }\n\n                  var blendInTime = Math.min(duration, blendTime); // Find the amount and time viseme will be held for\n\n                  var holdTime = duration - blendTime;\n\n                  if (holdTime < 0) {\n                    // Perform in -> out animation\n                    _this4._animateSimpleViseme(layerName, animName, viseme, weight, blendInTime, blendTime, easingFn);\n                  } else {\n                    var _lerpFactor = decayRate.seconds > 0 ? holdTime / decayRate.seconds : 1; // Perform in -> hold -> out animation\n\n\n                    var decayWeight = core_MathUtils.lerp(weight, weight * decayRate.amount, Math.min(1, _lerpFactor));\n\n                    _this4._animateHeldViseme(layerName, animName, viseme, weight, decayWeight, blendInTime, holdTime, blendTime, easingFn);\n                  }\n                });\n\n              case 2:\n              case "end":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _onViseme(_x) {\n        return _onViseme2.apply(this, arguments);\n      }\n\n      return _onViseme;\n    }()\n    /**\n     * Animate a viseme blend weight towards a value and then back to zero.\n     *\n     * @private\n     *\n     * @param {string} layerName - Name of the layer that contains the viseme.\n     * @param {string} animName - Name of the freeblend animation that contains\n     * the viseme.\n     * @param {string} visemeName - Name of the blend weight to manipulate.\n     * @param {number} weight - Peak weight to animate towards.\n     * @param {number} blendInTime - Amount of time it should take to reach the\n     * peak weight.\n     * @param {number} blendOutTime - Amount of time it should take to animate back\n     * to zero after reaching the peak weight.\n     * @param {Function} easingFn - Easing function to use during animation.\n     */\n\n  }, {\n    key: "_animateSimpleViseme",\n    value: function _animateSimpleViseme(layerName, animName, visemeName, peakWeight, blendInTime, blendOutTime, easingFn) {\n      var _this5 = this;\n\n      // Animate towards the peak value\n      var weightPromise = this._host.AnimationFeature.setAnimationBlendWeight(layerName, animName, visemeName, peakWeight, blendInTime, easingFn); // Animate back to zero if there was no weight interruption\n\n\n      weightPromise.then(function () {\n        if (!weightPromise.canceled) {\n          _this5._host.AnimationFeature.setAnimationBlendWeight(layerName, animName, visemeName, 0, blendOutTime, easingFn);\n        }\n      });\n    }\n    /**\n     * Animate a viseme blend weight towards a value and then back to zero.\n     *\n     * @private\n     *\n     * @param {string} layerName - Name of the layer that contains the viseme.\n     * @param {string} animName - Name of the freeblend animation that contains\n     * the viseme.\n     * @param {string} visemeName - Name of the blend weight to manipulate.\n     * @param {number} peakWeight - Peak weight to animate towards.\n     * @param {number} decayWeight - Weight to animate towards after reaching the\n     * peak weight.\n     * @param {number} blendInTime - Amount of time it should take to reach the\n     * peak weight.\n     * @param {number} holdTime - Amount of time it should take to reach the decay\n     * weight after the peak weight has been reached.\n     * @param {number} blendOutTime - Amount of time it should take to animate back\n     * to zero after reaching the decay weight.\n     * @param {Function} easingFn - Easing function to use during animation.\n     */\n\n  }, {\n    key: "_animateHeldViseme",\n    value: function () {\n      var _animateHeldViseme2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(layerName, animName, visemeName, peakWeight, decayWeight, blendInTime, holdTime, blendOutTime, easingFn) {\n        var startPromise, holdPromise;\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                // Animate towards the peak value\n                startPromise = this._host.AnimationFeature.setAnimationBlendWeight(layerName, animName, visemeName, peakWeight, blendInTime, easingFn);\n                _context2.next = 3;\n                return startPromise;\n\n              case 3:\n                if (startPromise.canceled) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                // Animate towards the decay value if there was no weight interruption\n                holdPromise = this._host.AnimationFeature.setAnimationBlendWeight(layerName, animName, visemeName, decayWeight, holdTime, easingFn);\n                _context2.next = 7;\n                return holdPromise;\n\n              case 7:\n                if (!holdPromise.canceled) {\n                  // Animate back to zero if there was no weight interruption\n                  this._host.AnimationFeature.setAnimationBlendWeight(layerName, animName, visemeName, 0, blendOutTime, easingFn);\n                }\n\n              case 8:\n              case "end":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _animateHeldViseme(_x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9, _x10) {\n        return _animateHeldViseme2.apply(this, arguments);\n      }\n\n      return _animateHeldViseme;\n    }()\n    /**\n     * Gets and sets the amount of time in seconds to negatively offset speechmark\n     * emission by.\n     *\n     * @type {number}\n     */\n\n  }, {\n    key: "visemeLeadTime",\n    get: function get() {\n      return this._visemeLeadTime;\n    },\n    set: function set(seconds) {\n      this._visemeLeadTime = seconds;\n\n      if (this._host.TextToSpeechFeature) {\n        this._host.TextToSpeechFeature.speechmarkOffset = -seconds;\n      }\n    }\n    /**\n     * Start keeping track of an animation layer that owns a freeBlend animation\n     * with blendWeights corresponding to visemes.\n     *\n     * @param {string} layerName - Name of the layer to keep track of.\n     * @param {Object=} options - Options for the layer.\n     * @param {string} [options.animation=\'visemes\'] - Name of the animation on the\n     * layer that will be played during speech. This animation must be of type\n     * freeBlend.\n     * @param {Object=} decayRate\n     * @param {number} [decayRate.amount=0.5] - The percentage to decrease the viseme\'s\n     * peak value by over time once the peak value has been reached.\n     * @param {number} [decayRate.seconds=0.5] - The amount of time in seconds to\n     * decrease the viseme\'s weight once it has reached its peak value.\n     * @param {number=} [options.blendTime=[LipsyncFeature.DEFAULT_LAYER_OPTIONS.blendTime]{@link LipsyncFeature#DEFAULT_LAYER_OPTIONS#blendTime}] -\n     * Default amount of time to use when manipulating animation blendWeights.\n     * @param {Function=} options.easingFn - Default easing function to use when\n     * manipulating animation blendWeights.\n     * @param {Object} [options.visemeMap=DefaultVisemeMap] - Object containing key/value pairs of\n     * Polly viseme names mapped to objects containing the name of the corresponding\n     * animation blendWeight and any other animation options to use such as viseme\n     * specific blend times and easing functions.\n     */\n\n  }, {\n    key: "registerVisemeLayer",\n    value: function registerVisemeLayer(layerName) {\n      var _ref14 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref14$animation = _ref14.animation,\n          animation = _ref14$animation === void 0 ? \'visemes\' : _ref14$animation,\n          _ref14$decayRate = _ref14.decayRate,\n          decayRate = _ref14$decayRate === void 0 ? {\n        amount: 0.5,\n        seconds: 0.5\n      } : _ref14$decayRate,\n          _ref14$blendTime = _ref14.blendTime,\n          blendTime = _ref14$blendTime === void 0 ? LipsyncFeature.DEFAULT_LAYER_OPTIONS.blendTime : _ref14$blendTime,\n          easingFn = _ref14.easingFn,\n          _ref14$visemeMap = _ref14.visemeMap,\n          visemeMap = _ref14$visemeMap === void 0 ? DefaultVisemeMap : _ref14$visemeMap;\n\n      // Register the layer and animation\n      this.registerLayer(layerName, {\n        decayRate: decayRate,\n        blendTime: blendTime,\n        easingFn: easingFn,\n        animations: LipsyncFeature_defineProperty({}, animation, {\n          visemeMap: visemeMap\n        })\n      });\n      this._visemeLayers[layerName] = animation; // Validate the viseme animation\n\n      this._registerVisemeAnimation(layerName, animation);\n    }\n    /**\n     * Start keeping track of an animation layer that contains a looping animation\n     * to be played during speech.\n     *\n     * @param {string} layerName - Name of the layer to keep track of.\n     * @param {Object=} options - Options for the layer.\n     * @param {string} [options.animation=\'stand_talk\'] - Name of the animation on the\n     * layer that will be played during speech.\n     * @param {number} [options.blendTime=[LipsyncFeature.DEFAULT_LAYER_OPTIONS.blendTime]{@link LipsyncFeature#DEFAULT_LAYER_OPTIONS#blendTime}] -\n     * Default amount of time to use when manipulating the layer\'s weights.\n     * @param {Function=} options.easingFn - Default easing function to use when\n     * manipulating the layer\'s weights.\n     */\n\n  }, {\n    key: "registerTalkingLayer",\n    value: function registerTalkingLayer(layerName) {\n      var _ref15 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref15$animation = _ref15.animation,\n          animation = _ref15$animation === void 0 ? \'stand_talk\' : _ref15$animation,\n          _ref15$blendTime = _ref15.blendTime,\n          blendTime = _ref15$blendTime === void 0 ? LipsyncFeature.DEFAULT_LAYER_OPTIONS.blendTime : _ref15$blendTime,\n          easingFn = _ref15.easingFn;\n\n      // Register the layer and animation\n      this.registerLayer(layerName, {\n        blendTime: blendTime,\n        easingFn: easingFn,\n        animations: LipsyncFeature_defineProperty({}, animation, {})\n      });\n      this._talkingLayers[layerName] = animation;\n    }\n    /**\n     * Adds a namespace to the host with the name of the feature to contain properties\n     * and methods from the feature that users of the host need access to.\n     *\n     * @see LipsyncFeature\n     */\n\n  }, {\n    key: "installApi",\n    value: function installApi() {\n      var _this6 = this;\n\n      /**\n       * @inner\n       * @namespace LipsyncFeature\n       */\n      var api = LipsyncFeature_get(LipsyncFeature_getPrototypeOf(LipsyncFeature.prototype), "installApi", this).call(this);\n      /**\n       * @memberof LipsyncFeature\n       * @name registerLayer\n       * @instance\n       * @method\n       * @see ManagedAnimationLayerInterface#registerLayer\n       */\n\n      /**\n       * @memberof LipsyncFeature\n       * @name registerAnimation\n       * @instance\n       * @method\n       * @see ManagedAnimationLayerInterface#registerAnimation\n       */\n\n      /**\n       * @memberof LipsyncFeature\n       * @name setLayerWeights\n       * @instance\n       * @method\n       * @see ManagedAnimationLayerInterface#setLayerWeights\n       */\n\n      /**\n       * @memberof LipsyncFeature\n       * @name enable\n       * @instance\n       * @method\n       * @see ManagedAnimationLayerInterface#enable\n       */\n\n      /**\n       * @memberof LipsyncFeature\n       * @name disable\n       * @instance\n       * @method\n       * @see ManagedAnimationLayerInterface#disable\n       */\n\n\n      Object.assign(api, {\n        /**\n         * @memberof LipsyncFeature\n         * @instance\n         * @method\n         * @see core/LipsyncFeature#registerVisemeLayer\n         */\n        registerVisemeLayer: this.registerVisemeLayer.bind(this),\n\n        /**\n         * @memberof LipsyncFeature\n         * @instance\n         * @method\n         * @see core/LipsyncFeature#registerTalkingLayer\n         */\n        registerTalkingLayer: this.registerTalkingLayer.bind(this)\n      });\n      /**\n       * @memberof LipsyncFeature\n       * @instance\n       * @name visemeLeadTime\n       * @see core/LipsyncFeature#visemeLeadTime\n       */\n\n      Object.defineProperty(api, \'visemeLeadTime\', {\n        get: function get() {\n          return _this6.visemeLeadTime;\n        },\n        set: function set(seconds) {\n          _this6.visemeLeadTime = seconds;\n        }\n      });\n      return api;\n    }\n  }]);\n\n  return LipsyncFeature;\n}(core_AbstractHostFeature.mix(awspack_TextToSpeechFeatureDependentInterface.Mixin, animpack_ManagedAnimationLayerInterface.Mixin));\n\n/* harmony default export */ const core_LipsyncFeature = (LipsyncFeature);\n\n;// CONCATENATED MODULE: ./src/core/awspack/SSMLSpeechmarkInterface.js\nfunction SSMLSpeechmarkInterface_typeof(obj) { "@babel/helpers - typeof"; return SSMLSpeechmarkInterface_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, SSMLSpeechmarkInterface_typeof(obj); }\n\nfunction SSMLSpeechmarkInterface_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction SSMLSpeechmarkInterface_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction SSMLSpeechmarkInterface_createClass(Constructor, protoProps, staticProps) { if (protoProps) SSMLSpeechmarkInterface_defineProperties(Constructor.prototype, protoProps); if (staticProps) SSMLSpeechmarkInterface_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction SSMLSpeechmarkInterface_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) SSMLSpeechmarkInterface_setPrototypeOf(subClass, superClass); }\n\nfunction SSMLSpeechmarkInterface_setPrototypeOf(o, p) { SSMLSpeechmarkInterface_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return SSMLSpeechmarkInterface_setPrototypeOf(o, p); }\n\nfunction SSMLSpeechmarkInterface_createSuper(Derived) { var hasNativeReflectConstruct = SSMLSpeechmarkInterface_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = SSMLSpeechmarkInterface_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = SSMLSpeechmarkInterface_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return SSMLSpeechmarkInterface_possibleConstructorReturn(this, result); }; }\n\nfunction SSMLSpeechmarkInterface_possibleConstructorReturn(self, call) { if (call && (SSMLSpeechmarkInterface_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return SSMLSpeechmarkInterface_assertThisInitialized(self); }\n\nfunction SSMLSpeechmarkInterface_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction SSMLSpeechmarkInterface_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction SSMLSpeechmarkInterface_getPrototypeOf(o) { SSMLSpeechmarkInterface_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return SSMLSpeechmarkInterface_getPrototypeOf(o); }\n\n/* eslint-disable no-unused-vars */\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable max-classes-per-file */\n\n/* eslint-disable no-empty */\n\n/**\n * Class factory interface for that registers callback method when a ssml speechmark event is emitted.\n *\n * @interface\n * @extends TextToSpeechFeatureDependentInterface\n */\n\nvar SSMLSpeechmarkInterface = /*#__PURE__*/function (_TextToSpeechFeatureD) {\n  SSMLSpeechmarkInterface_inherits(SSMLSpeechmarkInterface, _TextToSpeechFeatureD);\n\n  var _super = SSMLSpeechmarkInterface_createSuper(SSMLSpeechmarkInterface);\n\n  function SSMLSpeechmarkInterface() {\n    SSMLSpeechmarkInterface_classCallCheck(this, SSMLSpeechmarkInterface);\n\n    return _super.apply(this, arguments);\n  }\n\n  SSMLSpeechmarkInterface_createClass(SSMLSpeechmarkInterface, [{\n    key: "_onSsml",\n    value:\n    /**\n     * When ssml events are caught, this will try to parse the speech mark value and execute any function which meets criteria defined in the value.\n     * Speech mark value will be treated as stringified json format containing required feature name, function name and argument array to pass in.\n     * Example speech mark value might look like: \'{"feature":"GestureFeature", "method":"switchToGesture", "args":["genricA", 0.5]}\'\n     *\n     * @private\n     *\n     * @param {Object} event - Event data passed from the speech.\n     * @param {Object} event.mark - Speechmark object.\n     */\n    function _onSsml(_ref) {\n      var mark = _ref.mark;\n    }\n    /**\n     * Creates a class that implements {@link SSMLSpeechmarkInterface}\n     * and extends a specified base class.\n     *\n     * @param {Class} BaseClass - The class to extend.\n     *\n     * @return {Class} A class that extends `BaseClass` and implements {@link SSMLSpeechmarkInterface}.\n     */\n\n  }], [{\n    key: "Mixin",\n    value: function Mixin(BaseClass) {\n      var ParentClass = awspack_TextToSpeechFeatureDependentInterface.Mixin(BaseClass);\n\n      var SSMLSpeechMarkMixin = /*#__PURE__*/function (_ParentClass) {\n        SSMLSpeechmarkInterface_inherits(SSMLSpeechMarkMixin, _ParentClass);\n\n        var _super2 = SSMLSpeechmarkInterface_createSuper(SSMLSpeechMarkMixin);\n\n        function SSMLSpeechMarkMixin() {\n          SSMLSpeechmarkInterface_classCallCheck(this, SSMLSpeechMarkMixin);\n\n          return _super2.apply(this, arguments);\n        }\n\n        SSMLSpeechmarkInterface_createClass(SSMLSpeechMarkMixin, [{\n          key: "_onSsml",\n          value: function _onSsml(_ref2) {\n            var mark = _ref2.mark;\n\n            try {\n              var _JSON$parse = JSON.parse(mark.value),\n                  feature = _JSON$parse.feature,\n                  method = _JSON$parse.method,\n                  args = _JSON$parse.args;\n\n              if (this.constructor.name === feature) {\n                var callback = this[method];\n\n                if (callback && typeof callback === \'function\') {\n                  callback.apply(this, args);\n                } else {\n                  console.warn("Function ".concat(method, " does not exist within feature ").concat(feature));\n                }\n              }\n            } catch (e) {}\n          }\n        }]);\n\n        return SSMLSpeechMarkMixin;\n      }(ParentClass);\n\n      return SSMLSpeechMarkMixin;\n    }\n  }]);\n\n  return SSMLSpeechmarkInterface;\n}(awspack_TextToSpeechFeatureDependentInterface);\n\n/* harmony default export */ const awspack_SSMLSpeechmarkInterface = (SSMLSpeechmarkInterface);\n;// CONCATENATED MODULE: ./src/core/GestureFeature.js\nfunction GestureFeature_typeof(obj) { "@babel/helpers - typeof"; return GestureFeature_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, GestureFeature_typeof(obj); }\n\nfunction GestureFeature_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction GestureFeature_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? GestureFeature_ownKeys(Object(source), !0).forEach(function (key) { GestureFeature_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : GestureFeature_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction GestureFeature_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction GestureFeature_slicedToArray(arr, i) { return GestureFeature_arrayWithHoles(arr) || GestureFeature_iterableToArrayLimit(arr, i) || GestureFeature_unsupportedIterableToArray(arr, i) || GestureFeature_nonIterableRest(); }\n\nfunction GestureFeature_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction GestureFeature_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return GestureFeature_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return GestureFeature_arrayLikeToArray(o, minLen); }\n\nfunction GestureFeature_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction GestureFeature_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction GestureFeature_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction GestureFeature_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction GestureFeature_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction GestureFeature_createClass(Constructor, protoProps, staticProps) { if (protoProps) GestureFeature_defineProperties(Constructor.prototype, protoProps); if (staticProps) GestureFeature_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction GestureFeature_get() { if (typeof Reflect !== "undefined" && Reflect.get) { GestureFeature_get = Reflect.get; } else { GestureFeature_get = function _get(target, property, receiver) { var base = GestureFeature_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return GestureFeature_get.apply(this, arguments); }\n\nfunction GestureFeature_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = GestureFeature_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction GestureFeature_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) GestureFeature_setPrototypeOf(subClass, superClass); }\n\nfunction GestureFeature_setPrototypeOf(o, p) { GestureFeature_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return GestureFeature_setPrototypeOf(o, p); }\n\nfunction GestureFeature_createSuper(Derived) { var hasNativeReflectConstruct = GestureFeature_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = GestureFeature_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = GestureFeature_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return GestureFeature_possibleConstructorReturn(this, result); }; }\n\nfunction GestureFeature_possibleConstructorReturn(self, call) { if (call && (GestureFeature_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return GestureFeature_assertThisInitialized(self); }\n\nfunction GestureFeature_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction GestureFeature_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction GestureFeature_getPrototypeOf(o) { GestureFeature_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return GestureFeature_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n\n/**\n * @constant\n */\n\nvar DefaultGestureWords = {\n  big: [\'add\', \'above\', \'authority\', \'big\', \'cover\', \'full\', \'fly\', \'grow\', \'growth\', \'high\', \'huge\', \'increase\', \'major\', \'majority\', \'large\', \'leader\', \'lot\', \'raise\', \'rise\', \'tall\'],\n  heart: [\'accept\', \'admit\', \'believe\', \'care\', \'feeling\', \'feel\', \'friend\', \'grateful\', \'happy\', \'heart\', \'human\', \'pain\', \'save\', \'safe\', \'kind\', \'love\'],\n  "in": [\'include\', \'including\', \'inside\', \'into\', \'now\', \'near\', \'nearest\', \'closest\', \'therein\', \'within\'],\n  many: [\'all\', \'always\', \'any\', \'anyone\', \'among\', \'area\', \'around\', \'beautiful\', \'entire\', \'environment\', \'environments\', \'environmental\', \'everybody\', \'everyone\', \'everything\', \'audience\', \'total\', \'group\', \'groups\', \'million\', \'millions\', \'others\', \'billion\', \'billions\', \'hundred\', \'hundreds\', \'many\', \'thousand\', \'thousands\', \'world\', \'worlds\', \'outside\', \'reveal\'],\n  movement: [\'away\', \'across\', \'ahead\', \'along\', \'far\', \'fast\', \'follow\', \'go\', \'leave\', \'move\', \'movement\', \'through\', \'throughout\', \'toward\', \'travel\', \'turned\', \'passed\'],\n  one: [\'single\', \'one\', \'once\', \'first\', \'firstly\', \'only\', \'solo\', \'warned\', \'truly\', \'up\', \'alone\'],\n  aggressive: [\'power\', \'powers\', \'powerful\', \'assert\', \'assertive\', \'strong\', \'stronger\', \'strongest\', \'strength\', \'flex\', \'dang\', \'damn\', \'damnit\', \'darn\', \'shucks\', \'doh\', \'drat\', \'angry\', \'angrier\', \'angriest\', \'aggressive\', \'annoyed\', \'annoying\', \'attack\', \'attacking\', \'offense\', \'offensive\', \'battle\'],\n  you: [\'you\', \'yall\', "y\'all", \'your\', \'yours\', \'thou\', \'thy\'],\n  defense: [\'defense\', \'fear\', \'repulsed\', \'scared\', \'scary\', \'scarier\', \'scariest\', \'fearful\', \'afraid\', \'cower\', \'cowers\', \'cowering\', \'hideous\', \'doomed\', \'terrified\', \'terrify\', \'terrifying\', \'terrifies\', \'spooky\', \'spookier\', \'spookiest\'],\n  wave: [\'hello\', \'hi\', \'hiya\', \'howdy\', \'welcome\', \'aloha\', \'heya\', \'hey\', \'bye\', \'goodbye\', \'hola\', \'adios\', \'chao\'],\n  self: [\'my\', \'I\', \'myself\', \'self\', "I\'ve", \'Ive\', \'me\', \'mine\', \'own\']\n};\n/**\n * Gesture allows you to play animations on demand on one or more layers from script\n * or ssml. If gesture is played that is a QueueState, the queue will automatically\n * be progressed after a given hold time if a looping queued state is reached. Gesture\n * layers can optionally be automatically disabled when no gesture animation is\n * in progress.\n *\n * @extends AbstractHostFeature\n * @implements SSMLSpeechmarkInterface\n * @implements ManagedAnimationLayerInterface\n */\n\nvar GestureFeature = /*#__PURE__*/function (_AbstractHostFeature$) {\n  GestureFeature_inherits(GestureFeature, _AbstractHostFeature$);\n\n  var _super = GestureFeature_createSuper(GestureFeature);\n\n  /**\n   * @constructor\n   *\n   * @param {core/HostObject} host - Host object that owns the feature.\n   * @param {Object=} options - Optional options for the feature.\n   * @param {number} [options.holdTime = 3] - Amount of time in seconds that must\n   * elapse before advancing a gesture that\'s a {@link QueueState} when the current\n   * state in the queue is set to loop infinitely.\n   * @param {number} [options.minimumInterval = 0.25] - The minimum amount of time\n   * in seconds that must elapse before another gesture can be played.\n   * @param  {Object} layers - An object that maps layer names to layer options.\n   * These are the layers that will be registered as tracked gesture layers. See\n   * {@link ManagedAnimationLayerInterface#registerLayer} for more information\n   * on expected format for each layer options object.\n   */\n  function GestureFeature(host) {\n    var _this;\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$holdTime = _ref.holdTime,\n        holdTime = _ref$holdTime === void 0 ? 3 : _ref$holdTime,\n        _ref$minimumInterval = _ref.minimumInterval,\n        minimumInterval = _ref$minimumInterval === void 0 ? 1 : _ref$minimumInterval,\n        _ref$layers = _ref.layers,\n        layers = _ref$layers === void 0 ? {} : _ref$layers;\n\n    GestureFeature_classCallCheck(this, GestureFeature);\n\n    _this = _super.call(this, host);\n    _this.holdTime = holdTime;\n    _this.minimumInterval = minimumInterval; // Register the gesture layers\n\n    Object.entries(layers).forEach(function (_ref2) {\n      var _ref3 = GestureFeature_slicedToArray(_ref2, 2),\n          name = _ref3[0],\n          _ref3$ = _ref3[1],\n          options = _ref3$ === void 0 ? {} : _ref3$;\n\n      _this.registerLayer(name, options);\n    });\n    return _this;\n  }\n  /**\n   * Return a valid hold time value. If hold time isn\'t defined for the animation,\n   * try to use the hold time for the layer. If that\'s not defined, fall back to\n   * the hold time for the feature.\n   *\n   * @private\n   *\n   * @param {Object} layer - Managed layer options object.\n   * @param {Object} animation - Managed animation options object.\n   *\n   * @returns {number}\n   */\n\n\n  GestureFeature_createClass(GestureFeature, [{\n    key: "_getHoldTime",\n    value: function _getHoldTime(layer, animation) {\n      var layerHoldTime = layer.holdTime !== undefined ? layer.holdTime : this.holdTime;\n      return animation.holdTime !== undefined ? animation.holdTime : layerHoldTime;\n    }\n    /**\n     * Return a valid minimum interval value. If minimum interval isn\'t defined for\n     * the animation, try to use the minimum interval for the layer. If that\'s not\n     * defined, fall back to the minimum interval for the feature.\n     *\n     * @private\n     *\n     * @param {Object} layer - Managed layer options object.\n     * @param {Object} animation - Managed animation options object.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: "_getMinimumInterval",\n    value: function _getMinimumInterval(layer, animation) {\n      var layerMinimumInterval = layer.minimumInterval !== undefined ? layer.minimumInterval : this.minimumInterval;\n      return animation.minimumInterval !== undefined ? animation.minimumInterval : layerMinimumInterval;\n    }\n    /**\n     * Callback for {@link core/AnimationFeature#playNextAnimation} event. If the\n     * event is emitted for a managed animation and the new queued state cannot\n     * advance on its own, start a new timer promise that will advance the queue\n     * once it resolves.\n     *\n     * @private\n     *\n     * @param {Object} options - Options object passed from playNextAnimation event.\n     * @param {string} layerName - Name of the layer that owns the queue state.\n     * @param {string} animationName - Name of the queue state animation.\n     * @param {boolean} canAdvance - Whether or not the current state in the queue\n     * can advance on its own.\n     * @param {boolean} isQueueEnd - Whether the current state in the queue is the last\n     * state in the queue.\n     */\n\n  }, {\n    key: "_onNext",\n    value: function _onNext(_ref4) {\n      var _this2 = this;\n\n      var layerName = _ref4.layerName,\n          animationName = _ref4.animationName,\n          canAdvance = _ref4.canAdvance,\n          isQueueEnd = _ref4.isQueueEnd;\n      // Exit if this isn\'t a managed layer\n      var layer = this._managedLayers[layerName];\n\n      if (layer === undefined) {\n        return;\n      } // Exit if it isn\'t a managed animation\n\n\n      var animation = layer.animations[animationName];\n\n      if (animation === undefined) {\n        return;\n      } // Start a new timer for looping states that aren\'t the end of the queue\n\n\n      if (!canAdvance && !isQueueEnd && layer.currentGesture === animationName) {\n        var holdTime = this._getHoldTime(layer, animation);\n\n        layer.holdTimer.cancel(); // Skip to the next animation right away if hold time is zero\n\n        if (holdTime <= 0) {\n          this._host.AnimationFeature.playNextAnimation(layerName, animationName);\n        } // Wait for the given hold time before progressing\n        else {\n          layer.holdTimer = core_Utils.wait(holdTime, {\n            onFinish: function onFinish() {\n              // Advance the queue to the next state\n              if (layer.currentGesture === animationName) {\n                _this2._host.AnimationFeature.playNextAnimation(layerName, animationName);\n              }\n            }\n          });\n        }\n      }\n    }\n    /**\n     * Callback for {@link core/AnimationFeature#stopAnimation} event. If the\n     * event is emitted for a managed animation cancel the layer\'s stored timers.\n     * If the layer is set to auto-disable set its weight to 0.\n     *\n     * @private\n     *\n     * @param {Object} options - Options object passed from playNextAnimation event.\n     * @param {string} layerName - Name of the layer that owns the stopped animation.\n     * @param {string} animationName - Name of the animation that was stopped.\n     */\n\n  }, {\n    key: "_onStop",\n    value: function _onStop(_ref5) {\n      var layerName = _ref5.layerName,\n          animationName = _ref5.animationName;\n      // Make sure the layer is managed\n      var layer = this._managedLayers[layerName];\n\n      if (layer === undefined) {\n        return;\n      } // Make sure the animation is managed\n\n\n      var animation = layer.animations[animationName];\n\n      if (animation !== undefined && animationName === layer.currentGesture) {\n        layer.currentGesture = null;\n        layer.playTimer = null;\n        layer.holdTimer.cancel(); // Turn off layer weight\n\n        if (layer.autoDisable) {\n          this.setLayerWeights(function (name) {\n            return name === layerName;\n          }, 0);\n        }\n      }\n    }\n  }, {\n    key: "_onAnimationAdded",\n    value: function _onAnimationAdded(_ref6) {\n      var layerName = _ref6.layerName,\n          animationName = _ref6.animationName;\n      var layer = this._managedLayers[layerName];\n\n      if (layer !== undefined) {\n        var animation = layer.animations[animationName]; // Register the animation as active if it is unmanaged\n\n        if (animation === undefined) {\n          this.registerAnimation(layerName, animationName);\n        } // Mark the animation as active if it is managed\n        else {\n          animation.isActive = true;\n        }\n      }\n    }\n  }, {\n    key: "registerLayer",\n    value: function registerLayer(name) {\n      var _this3 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      GestureFeature_get(GestureFeature_getPrototypeOf(GestureFeature.prototype), "registerLayer", this).call(this, name, GestureFeature_objectSpread(GestureFeature_objectSpread({}, options), {}, {\n        holdTimer: core_Deferred.resolve(),\n        playTimer: null,\n        currentGesture: null\n      }));\n\n      if (this._managedLayers[name].isActive) {\n        this._host.AnimationFeature.getAnimations(name).forEach(function (anim) {\n          // Automatically register all animations on the layer\n          if (_this3._managedLayers[name].animations[anim] === undefined) {\n            _this3.registerAnimation(name, anim, _this3._managedLayers[name].animations[anim]);\n          }\n        });\n      }\n    }\n  }, {\n    key: "registerAnimation",\n    value: function registerAnimation(layerName, animationName) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      // Try to fall back to a default word array\n      if (!(options.words instanceof Array) && !(options.words instanceof Set)) {\n        options.words = DefaultGestureWords[animationName] || [];\n      }\n\n      GestureFeature_get(GestureFeature_getPrototypeOf(GestureFeature.prototype), "registerAnimation", this).call(this, layerName, animationName, options);\n    }\n    /**\n     * Create an object that maps ssml mark syntax required to play each gesture to\n     * the words array associated with each gesture. Words arrays are defined at when\n     * the gesture animation is registered. Gestures without associated words will\n     * be excluded from the result. The resulting object can be used as an input\n     * for {@link TextToSpeechUtils.autoGenerateSSMLMarks} to update a speech string\n     * with the markup required to play gestures timed with their associated words.\n     *\n     * @returns {Object}\n     */\n\n  }, {\n    key: "createGestureMap",\n    value: function createGestureMap() {\n      var _this4 = this;\n\n      var gestureMap = {};\n      Object.entries(this._managedLayers).forEach(function (_ref7) {\n        var _ref8 = GestureFeature_slicedToArray(_ref7, 2),\n            layerName = _ref8[0],\n            animations = _ref8[1].animations;\n\n        Object.entries(animations).forEach(function (_ref9) {\n          var _ref10 = GestureFeature_slicedToArray(_ref9, 2),\n              animationName = _ref10[0],\n              _ref10$ = _ref10[1],\n              holdTime = _ref10$.holdTime,\n              minimumInterval = _ref10$.minimumInterval,\n              words = _ref10$.words,\n              transitionTime = _ref10$.transitionTime;\n\n          // Only store gestures that have any associated words\n          if (words.length) {\n            var options = GestureFeature_objectSpread(GestureFeature_objectSpread(GestureFeature_objectSpread({}, holdTime && {\n              holdTime: holdTime\n            }), minimumInterval && {\n              minimumInterval: minimumInterval\n            }), transitionTime && {\n              transitionTime: transitionTime\n            });\n\n            var key = {\n              feature: _this4.constructor.name,\n              method: \'playGesture\',\n              args: [layerName, animationName, options]\n            };\n            gestureMap[JSON.stringify(key)] = words;\n          }\n        });\n      });\n      return gestureMap;\n    }\n    /**\n     * Create an array that contains ssml mark syntax required to play each gesture\n     * that does not have any associated words. The resulting array can be used as\n     * an input for {@link TextToSpeechUtils.autoGenerateSSMLMarks} or\n     * {@link TextToSpeechUtils.addMarksToUnmarkedSentences} to update a speech\n     * string with the markup required to play random gestures at each unmarked\n     * sentence in the string.\n     *\n     * @param {Array.<string>=} layers - An array of names of managed layers to generate\n     * marks for. If undefined, use all managed layers.\n     *\n     * @returns {Array.<string>}\n     */\n\n  }, {\n    key: "createGenericGestureArray",\n    value: function createGenericGestureArray(layers) {\n      var _this5 = this;\n\n      var genericGestures = [];\n      layers = layers || Object.keys(this._managedLayers);\n      layers.forEach(function (layerName) {\n        var layer = _this5._managedLayers[layerName]; // Make sure the layer is managed\n\n        if (!layer) {\n          return;\n        }\n\n        Object.entries(layer.animations).forEach(function (_ref11) {\n          var _ref12 = GestureFeature_slicedToArray(_ref11, 2),\n              animationName = _ref12[0],\n              _ref12$ = _ref12[1],\n              holdTime = _ref12$.holdTime,\n              minimumInterval = _ref12$.minimumInterval,\n              words = _ref12$.words,\n              transitionTime = _ref12$.transitionTime;\n\n          // Only store gestures that don\'t have any associated words\n          if (!words.length) {\n            var options = GestureFeature_objectSpread(GestureFeature_objectSpread(GestureFeature_objectSpread({}, holdTime && {\n              holdTime: holdTime\n            }), minimumInterval && {\n              minimumInterval: minimumInterval\n            }), transitionTime && {\n              transitionTime: transitionTime\n            });\n\n            var key = JSON.stringify({\n              feature: _this5.constructor.name,\n              method: \'playGesture\',\n              args: [layerName, animationName, options]\n            });\n\n            if (!genericGestures.includes(key)) {\n              genericGestures.push(key);\n            }\n          }\n        });\n      });\n      return genericGestures;\n    }\n    /**\n     * Play a managed gesture animation.\n     *\n     * @param {string} layerName - The name of the layer that contains the gesture\n     * animation.\n     * @param {string} animationName - The name of the gesture animation.\n     * @param {Object=} options - Optional gesture options.\n     * @param {number=} options.holdTime - This option only applies to {@link QueueState}\n     * gestures. When a QueueState gesture progresses to a looping state, this option\n     * defines how many seconds should elapse before moving the queue forward. If\n     * undefined, it will fall back first to the holdTime defined in the options when\n     * the gesture animation was registered and then to the holdTime defined on the\n     * feature.\n     * @param {number=} options.minimumInterval - The minimum amount of time that\n     * must have elapsed since the last time a gesture was played.\n     */\n\n  }, {\n    key: "playGesture",\n    value: function playGesture(layerName, animationName) {\n      var _ref13 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n          holdTime = _ref13.holdTime,\n          minimumInterval = _ref13.minimumInterval,\n          transitionTime = _ref13.transitionTime,\n          _ref13$force = _ref13.force,\n          force = _ref13$force === void 0 ? false : _ref13$force;\n\n      // Make sure the animation is registered\n      if (this._managedLayers[layerName] === undefined || this._managedLayers[layerName].animations[animationName] === undefined) {\n        this.registerAnimation(layerName, animationName, {\n          holdTime: holdTime,\n          minimumInterval: minimumInterval,\n          transitionTime: transitionTime\n        });\n      }\n\n      var layer = this._managedLayers[layerName];\n      var animation = layer.animations[animationName]; // Make sure the animation is active\n\n      if (!animation.isActive) {\n        // Create warning message based on which object doesn\'t exist yet\n        var typeName = layer.isActive ? \'animation\' : \'layer\';\n        var message = "Skipping gesture ".concat(animationName, " on layer ").concat(layerName, " for host ").concat(this._host.id, ". No ").concat(typeName, " exists with this name yet.");\n        console.warn(message);\n        return core_Deferred.cancel({\n          reason: \'inactive\',\n          value: typeName\n        });\n      } // Check if the gesture is already playing\n\n\n      var currentGesture = layer.currentGesture;\n\n      if (currentGesture === animationName && !force) {\n        var _message = "Skipping gesture ".concat(animationName, " on layer ").concat(layerName, " for host ").concat(this._host.id, ". The gesture is already playing. Use options.force to force the gesture replay, which may result in a hard transition.");\n\n        console.warn(_message);\n        return core_Deferred.cancel({\n          reason: \'playing\',\n          value: animationName\n        });\n      } // Update animation options\n\n\n      if (holdTime !== undefined) {\n        animation.holdTime = holdTime;\n      }\n\n      if (minimumInterval !== undefined) {\n        animation.minimumInterval = minimumInterval;\n      } else {\n        minimumInterval = this._getMinimumInterval(layer, animation);\n      } // Check the interval\n\n\n      if (!force && layer.playTimer !== null && layer.playTimer < minimumInterval) {\n        console.warn("Skipping gesture ".concat(animationName, " on layer ").concat(layerName, " for host ").concat(this._host.id, ". Minimum interval ").concat(minimumInterval, " has not been met."));\n        return core_Deferred.cancel({\n          reason: \'minimumInterval\',\n          value: minimumInterval - layer.playTimer\n        });\n      } // Play the animation\n\n\n      layer.currentGesture = animationName;\n      layer.playTimer = 0;\n      layer.holdTimer.cancel();\n\n      if (layer.autoDisable) {\n        this.setLayerWeights(function (name) {\n          return name === layerName;\n        }, 1);\n      }\n\n      return this._host.AnimationFeature.playAnimation(layerName, animationName, transitionTime);\n    }\n  }, {\n    key: "update",\n    value: function update(deltaTime) {\n      var _this6 = this;\n\n      GestureFeature_get(GestureFeature_getPrototypeOf(GestureFeature.prototype), "update", this).call(this, deltaTime); // Increment the timers\n\n\n      Object.entries(this._managedLayers).forEach(function (_ref14) {\n        var _ref15 = GestureFeature_slicedToArray(_ref14, 2),\n            name = _ref15[0],\n            options = _ref15[1];\n\n        if (options.isActive && !_this6._host.AnimationFeature.getPaused(name)) {\n          options.holdTimer.execute(deltaTime);\n\n          if (options.playTimer !== null) {\n            options.playTimer += deltaTime / 1000;\n          }\n        }\n      });\n    }\n  }, {\n    key: "installApi",\n    value: function installApi() {\n      /**\n       * @inner\n       * @namespace GestureFeature\n       */\n      var api = GestureFeature_get(GestureFeature_getPrototypeOf(GestureFeature.prototype), "installApi", this).call(this);\n\n      Object.assign(api, {\n        /**\n         * @memberof GestureFeature\n         * @instance\n         * @method\n         * @see GestureFeature#createGestureMap\n         */\n        createGestureMap: this.createGestureMap.bind(this),\n\n        /**\n         * @memberof GestureFeature\n         * @instance\n         * @method\n         * @see GestureFeature#createGenericGestureArray\n         */\n        createGenericGestureArray: this.createGenericGestureArray.bind(this),\n\n        /**\n         * @memberof GestureFeature\n         * @instance\n         * @method\n         * @see GestureFeature#playGesture\n         */\n        playGesture: this.playGesture.bind(this)\n      });\n    }\n  }]);\n\n  return GestureFeature;\n}(core_AbstractHostFeature.mix(awspack_SSMLSpeechmarkInterface.Mixin, animpack_ManagedAnimationLayerInterface.Mixin));\n\nObject.defineProperties(GestureFeature, {\n  DEFAULT_LAYER_OPTIONS: {\n    value: GestureFeature_objectSpread(GestureFeature_objectSpread({}, GestureFeature.DEFAULT_LAYER_OPTIONS), {}, {\n      autoDisable: true\n    }),\n    writable: false\n  },\n  EVENT_DEPENDENCIES: {\n    value: GestureFeature_objectSpread(GestureFeature_objectSpread({}, GestureFeature.EVENT_DEPENDENCIES), {}, {\n      AnimationFeature: GestureFeature_objectSpread(GestureFeature_objectSpread({}, GestureFeature.EVENT_DEPENDENCIES.AnimationFeature), {}, {\n        playNextAnimation: \'_onNext\',\n        stopAnimation: \'_onStop\',\n        interruptAnimation: \'_onStop\'\n      })\n    })\n  }\n});\n/* harmony default export */ const core_GestureFeature = (GestureFeature);\n\n;// CONCATENATED MODULE: ./src/core/animpack/AnimationUtils.js\nfunction AnimationUtils_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AnimationUtils_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AnimationUtils_createClass(Constructor, protoProps, staticProps) { if (protoProps) AnimationUtils_defineProperties(Constructor.prototype, protoProps); if (staticProps) AnimationUtils_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n/**\n * A collection of useful animation functions.\n *\n * @hideconstructor\n */\n\nvar AnimationUtils = /*#__PURE__*/function () {\n  function AnimationUtils() {\n    AnimationUtils_classCallCheck(this, AnimationUtils);\n  }\n\n  AnimationUtils_createClass(AnimationUtils, null, [{\n    key: "lerp",\n    value: function lerp(from, to, factor) {\n      console.warn("AnimationUtils.lerp is being deprecated. Use MathUtils.lerp instead.");\n      return core_MathUtils.lerp(from, to, factor);\n    }\n    /**\n     * Clamp a number between 2 values.\n     *\n     * @param {number} value - Value to clamp.\n     * @param {number} [min=0] - Minumum value.\n     * @param {number} [max=1] - Maximum value.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: "clamp",\n    value: function clamp(value) {\n      var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      console.warn("AnimationUtils.clamp is being deprecated. Use MathUtils.clamp instead.");\n      return core_MathUtils.clamp(value, min, max);\n    }\n    /**\n     * Return a deferred promise that can be used to update the value of a numeric\n     * property of this object over time. Pass delta time in milliseconds to the\n     * deferred promise\'s execute method in an update loop to animate the property\n     * towards the target value.\n     *\n     * @param {Object} propertyOwner - Object that contains the property to animation.\n     * @param {string} propertyName - Name of the property to animate.\n     * @param {number} targetValue - Target value to reach.\n     * @param {Object=} options - Optional options object\n     * @param {number} [options.seconds=0] - Number of seconds it will take to reach\n     * the target value.\n     * @param {Function} [options.easingFn=Linear.InOut] - Easing function to use for animation.\n     * @param {Function} [options.onFinish] - Callback to execute once the animation completes.\n     * The target value is passed as a parameter.\n     * @param {Function=} options.onProgress - Callback to execute each time the animation\n     * property is updated during the animation. The property\'s value at the time of\n     * the update is passed as a parameter.\n     * @param {Function=} options.onCancel - Callback to execute if the user cancels the\n     * animation before completion. The animation property\'s value at the time of\n     * cancel is passed as a parameter.\n     * @param {Function=} options.onError - Callback to execute if the animation stops\n     * because an error is encountered. The error message is passed as a parameter.\n     *\n     * @returns {Deferred} Resolves with the property\'s value once it reaches the\n     * target value.\n     */\n\n  }, {\n    key: "interpolateProperty",\n    value: function interpolateProperty(propertyOwner, propertyName, targetValue) {\n      var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n          _ref$seconds = _ref.seconds,\n          seconds = _ref$seconds === void 0 ? 0 : _ref$seconds,\n          easingFn = _ref.easingFn,\n          _onFinish = _ref.onFinish,\n          _onProgress = _ref.onProgress,\n          _onCancel = _ref.onCancel,\n          onError = _ref.onError;\n\n      // Make sure property is an object\n      if (!(propertyOwner instanceof Object)) {\n        var e = new Error("Cannot interpolate property ".concat(propertyName, ". Property owner must be an object."));\n\n        if (typeof onError === \'function\') {\n          onError(e);\n        }\n\n        return core_Deferred.reject(e);\n      } // Make sure property is numeric\n\n\n      if (Number.isNaN(Number(propertyOwner[propertyName]))) {\n        var _e = new Error("Cannot interpolate property ".concat(propertyName, ". Property must be numeric."));\n\n        if (typeof onError === \'function\') {\n          onError(_e);\n        }\n\n        return core_Deferred.reject(_e);\n      } // Make sure the target value is numeric\n\n\n      if (Number.isNaN(Number(targetValue))) {\n        var _e2 = new Error("Cannot interpolate property ".concat(propertyName, " to value ").concat(targetValue, ". Target value must be numeric."));\n\n        if (typeof onError === \'function\') {\n          onError(_e2);\n        }\n\n        return core_Deferred.reject(_e2);\n      } // Resolve immediately if the target has already been reached\n\n\n      var startValue = propertyOwner[propertyName];\n\n      if (startValue === targetValue) {\n        if (typeof _onFinish === \'function\') {\n          _onFinish(targetValue);\n        }\n\n        return core_Deferred.resolve(targetValue);\n      } // Default to linear interpolation\n\n\n      if (typeof easingFn !== \'function\') {\n        if (easingFn !== undefined) {\n          console.warn("Invalid property interpolation easingFn. Defaulting to linear interpolation.");\n        }\n\n        easingFn = Linear.InOut;\n      }\n\n      var interpolator = core_Utils.wait(seconds, {\n        onFinish: function onFinish() {\n          propertyOwner[propertyName] = targetValue;\n\n          if (typeof _onFinish === \'function\') {\n            _onFinish(targetValue);\n          }\n        },\n        onCancel: function onCancel() {\n          if (typeof _onCancel === \'function\') {\n            _onCancel(propertyOwner[propertyName]);\n          }\n        },\n        onProgress: function onProgress(progress) {\n          if (propertyOwner[propertyName] !== targetValue) {\n            // Calculate the lerp factor\n            var easeFactor = easingFn(progress);\n\n            if (typeof easeFactor !== \'number\') {\n              var _e3 = new Error("Invalid property interpolation easingFn. EasingFn must return a number.");\n\n              interpolator.reject(_e3);\n              return;\n            } // Update the value\n\n\n            propertyOwner[propertyName] = core_MathUtils.lerp(startValue, targetValue, easeFactor);\n          } // Signal progress\n\n\n          if (typeof _onProgress === \'function\') {\n            _onProgress(propertyOwner[propertyName]);\n          } // Signal completion once time is up\n\n\n          if (progress === 1) {\n            propertyOwner[propertyName] = targetValue;\n            interpolator.resolve(targetValue);\n          }\n        },\n        onError: onError\n      });\n      return interpolator;\n    }\n  }]);\n\n  return AnimationUtils;\n}();\n\n/* harmony default export */ const animpack_AnimationUtils = (AnimationUtils);\n;// CONCATENATED MODULE: ./src/core/animpack/state/AbstractState.js\nfunction AbstractState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AbstractState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AbstractState_createClass(Constructor, protoProps, staticProps) { if (protoProps) AbstractState_defineProperties(Constructor.prototype, protoProps); if (staticProps) AbstractState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n/**\n * Base class for a state in our animation system.\n *\n * @abstract\n */\n\nvar AbstractState = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   *\n   * @param {Object=} options - Options for the animation state.\n   * @param {string=} options.name - Name for the animation state. Names must be\n   * unique for the container the state is applied to and should be validated at\n   * the container level. If no name is given it will default to the constructor\n   * name.\n   * @param {weight} [options.weight=0] - The 0-1 amount of influence the state will have.\n   */\n  function AbstractState() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    AbstractState_classCallCheck(this, AbstractState);\n\n    this.name = options.name !== undefined ? options.name : this.constructor.name;\n    this._weight = options.weight !== undefined ? core_MathUtils.clamp(options.weight, 0, 1) : 0;\n    this._internalWeight = this._weight;\n    this._paused = false;\n    this._promises = {\n      finish: core_Deferred.resolve(),\n      weight: core_Deferred.resolve(),\n      play: core_Deferred.resolve()\n    };\n    this._playCallbacks = {\n      onFinish: undefined,\n      onError: undefined,\n      onCancel: undefined\n    };\n  }\n  /**\n   * Gets whether or not the state is currently paused.\n   *\n   * @type {number}\n   */\n\n\n  AbstractState_createClass(AbstractState, [{\n    key: "paused",\n    get: function get() {\n      return this._paused;\n    }\n    /**\n     * Gets and sets the user defined weight.\n     *\n     * @type {number}\n     */\n\n  }, {\n    key: "weight",\n    get: function get() {\n      return this._weight;\n    },\n    set: function set(weight) {\n      this._weight = core_MathUtils.clamp(weight, 0, 1);\n    }\n    /**\n     * Gets whether or not the weight is currently being animated.\n     *\n     * @readonly\n     * @type {boolean}\n     */\n\n  }, {\n    key: "weightPending",\n    get: function get() {\n      return this._promises.weight && this._promises.weight.pending;\n    }\n    /**\n     * Updates the user defined weight over time.\n     *\n     * @param {number} weight - The target weight value.\n     * @param {number} [seconds=0] - The amount of time it will take to reach the\n     * target weight.\n     * @param {Function=} easingFn - The easing function to use for interpolation.\n     *\n     * @returns {Deferred}\n     */\n\n  }, {\n    key: "setWeight",\n    value: function setWeight(weight) {\n      var seconds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var easingFn = arguments.length > 2 ? arguments[2] : undefined;\n\n      this._promises.weight.cancel();\n\n      weight = core_MathUtils.clamp(weight);\n      this._promises.weight = animpack_AnimationUtils.interpolateProperty(this, \'weight\', weight, {\n        seconds: seconds,\n        easingFn: easingFn\n      });\n      return this._promises.weight;\n    }\n    /**\n     * Gets the internal weight.\n     *\n     * @readonly\n     * @type {number}\n     */\n\n  }, {\n    key: "internalWeight",\n    get: function get() {\n      return this._internalWeight;\n    }\n    /**\n     * Multiplies the user weight by a factor to determine the internal weight.\n     *\n     * @param {number} factor - 0-1 multiplier to apply to the user weight.\n     */\n\n  }, {\n    key: "updateInternalWeight",\n    value: function updateInternalWeight(factor) {\n      this._internalWeight = this._weight * factor;\n    }\n    /**\n     * Update any values that need to be evaluated every frame.\n     *\n     * @param {number} deltaTime - Time in milliseconds since the last update.\n     */\n\n  }, {\n    key: "update",\n    value: function update(deltaTime) {\n      if (!this._paused) {\n        Object.values(this._promises).forEach(function (promise) {\n          promise.execute(deltaTime);\n        });\n      }\n    }\n    /**\n     * Start playback of the state from the beginning.\n     *\n     * @param {Function=} onFinish - Function to execute when the state finishes.\n     * @param {Function=} onError - Function to execute if the state encounters\n     * an error during playback.\n     * @param {Function=} onCancel - Function to execute if playback is canceled.\n     *\n     * @returns {Deferred}\n     */\n\n  }, {\n    key: "play",\n    value: function play(onFinish, onError, onCancel) {\n      this._paused = false;\n      this._playCallbacks.onFinish = onFinish;\n      this._playCallbacks.onError = onError;\n      this._playCallbacks.onCancel = onCancel;\n      this._promises.play = new core_Deferred(undefined, onFinish, onError, onCancel);\n      this._promises.finish = core_Deferred.all([this._promises.play, this._promises.weight]);\n      return this._promises.finish;\n    }\n    /**\n     * Pause playback of the state. This prevents pending promises from being executed.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "pause",\n    value: function pause() {\n      this._paused = true;\n      return true;\n    }\n    /**\n     * Resume playback of the state.\n     *\n     * @param {Function=} onFinish - Function to execute when the state finishes.\n     * @param {Function=} onError - Function to execute if the state encounters\n     * an error during playback.\n     * @param {Function=} onCancel - Function to execute if playback is canceled.\n     *\n     * @returns {Deferred}\n     */\n\n  }, {\n    key: "resume",\n    value: function resume(onFinish, onError, onCancel) {\n      this._paused = false;\n\n      if (!this._promises.play.pending) {\n        this._playCallbacks.onFinish = onFinish || this._playCallbacks.onFinish;\n        this._playCallbacks.onError = onError || this._playCallbacks.onError;\n        this._playCallbacks.onCancel = onCancel || this._playCallbacks.onCancel;\n        this._promises.play = new core_Deferred(undefined, this._playCallbacks.onFinish, this._playCallbacks.onError, this._playCallbacks.onCancel);\n        this._promises.finish = core_Deferred.all([this._promises.play, this._promises.weight]);\n      }\n\n      return this._promises.finish;\n    }\n    /**\n     * Cancel playback of the state and cancel any pending promises.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "cancel",\n    value: function cancel() {\n      this._paused = true;\n      Object.values(this._promises).forEach(function (promise) {\n        promise.cancel();\n      });\n      return true;\n    }\n    /**\n     * Stop playback of the state and resolve any pending promises.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "stop",\n    value: function stop() {\n      this._paused = true;\n      Object.values(this._promises).forEach(function (promise) {\n        promise.resolve();\n      });\n      return true;\n    }\n    /**\n     * Cancel any pending promises and remove reference to them.\n     */\n\n  }, {\n    key: "discard",\n    value: function discard() {\n      this.cancel();\n      delete this._promises;\n    }\n    /**\n     * Force the internal weight to 0. Should be called before switching or transitioning\n     * to a new state.\n     */\n\n  }, {\n    key: "deactivate",\n    value: function deactivate() {\n      this.updateInternalWeight(0);\n    }\n  }]);\n\n  return AbstractState;\n}();\n\n/* harmony default export */ const state_AbstractState = (AbstractState);\n;// CONCATENATED MODULE: ./src/core/animpack/state/TransitionState.js\nfunction TransitionState_typeof(obj) { "@babel/helpers - typeof"; return TransitionState_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, TransitionState_typeof(obj); }\n\nfunction TransitionState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction TransitionState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction TransitionState_createClass(Constructor, protoProps, staticProps) { if (protoProps) TransitionState_defineProperties(Constructor.prototype, protoProps); if (staticProps) TransitionState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction TransitionState_get() { if (typeof Reflect !== "undefined" && Reflect.get) { TransitionState_get = Reflect.get; } else { TransitionState_get = function _get(target, property, receiver) { var base = TransitionState_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return TransitionState_get.apply(this, arguments); }\n\nfunction TransitionState_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = TransitionState_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction TransitionState_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) TransitionState_setPrototypeOf(subClass, superClass); }\n\nfunction TransitionState_setPrototypeOf(o, p) { TransitionState_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return TransitionState_setPrototypeOf(o, p); }\n\nfunction TransitionState_createSuper(Derived) { var hasNativeReflectConstruct = TransitionState_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = TransitionState_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = TransitionState_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return TransitionState_possibleConstructorReturn(this, result); }; }\n\nfunction TransitionState_possibleConstructorReturn(self, call) { if (call && (TransitionState_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return TransitionState_assertThisInitialized(self); }\n\nfunction TransitionState_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction TransitionState_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction TransitionState_getPrototypeOf(o) { TransitionState_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return TransitionState_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n/**\n * Class for smooth transitioning between states on an animation layer.\n *\n * @extends AbstractState\n */\n\nvar TransitionState = /*#__PURE__*/function (_AbstractState) {\n  TransitionState_inherits(TransitionState, _AbstractState);\n\n  var _super = TransitionState_createSuper(TransitionState);\n\n  function TransitionState() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    TransitionState_classCallCheck(this, TransitionState);\n\n    _this = _super.call(this, options);\n    _this._to = null;\n    _this._from = [];\n    _this._weightPromise = core_Deferred.resolve();\n    return _this;\n  }\n\n  TransitionState_createClass(TransitionState, [{\n    key: "internalWeight",\n    get: function get() {\n      // Find the combined weight of all sub-states\n      var totalWeight = 0;\n\n      if (this._to) {\n        totalWeight += this._to.weight;\n      }\n\n      this._from.forEach(function (state) {\n        totalWeight += state.weight;\n      });\n\n      return totalWeight * this._internalWeight;\n    }\n  }, {\n    key: "updateInternalWeight",\n    value: function updateInternalWeight(factor) {\n      var _this2 = this;\n\n      TransitionState_get(TransitionState_getPrototypeOf(TransitionState.prototype), "updateInternalWeight", this).call(this, factor);\n\n      this._from.forEach(function (state) {\n        state.updateInternalWeight(_this2._internalWeight);\n      });\n\n      if (this._to) {\n        this._to.updateInternalWeight(this._internalWeight);\n      }\n    }\n    /**\n     * Update sub-states the transition is controlling and start new weight\n     * animations on each one. This should be called each time the current state of\n     * an animation layer gets updated to a new value and a transition time greater\n     * that zero is specified.\n     *\n     * @param {Array.<AbstractState>} [currentStates=[]] - States whose weight values\n     * will be animated to 0.\n     * @param {AbstractState=} targetState - State whose weight will be animated\n     * to 1.\n     * @param {number} transitionTime - Amount of time it will in seconds take for\n     * weight animations to complete.\n     * @param {Function=} easingFn - Easing function to use for weight animations.\n     * Default is Easing.Linear.InOut.\n     * @param {Function=} onComplete - Function to execute once all weight animations\n     * complete.\n     */\n\n  }, {\n    key: "configure",\n    value: function configure() {\n      var currentStates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var targetState = arguments.length > 1 ? arguments[1] : undefined;\n      var transitionTime = arguments.length > 2 ? arguments[2] : undefined;\n      var easingFn = arguments.length > 3 ? arguments[3] : undefined;\n      var onComplete = arguments.length > 4 ? arguments[4] : undefined;\n\n      // Deactivate any states that aren\'t in the new configuration\n      if (this._to === targetState || currentStates.includes(this._to)) {\n        this._to = null;\n      }\n\n      this._from = this._from.filter(function (state) {\n        return state !== targetState && !currentStates.includes(state);\n      });\n      this.deactivate();\n      this._from = currentStates;\n      this._to = targetState;\n      this.reset(transitionTime, easingFn, onComplete);\n    }\n    /**\n     * Start new weight animations state the transition controls. This should be called\n     * if an animation is played with a transition time greater than zero and a transtion\n     * to that animation was already in progress.\n     *\n     * @param {number} transitionTime - Amount of time it will in seconds take for\n     * weight animations to complete.\n     * @param {Function=} easingFn - Easing function to use for weight animations.\n     * Default is Easing.Linear.InOut.\n     * @param {Function=} onComplete - Function to execute once all weight animations\n     * complete.\n     */\n\n  }, {\n    key: "reset",\n    value: function reset(transitionTime, easingFn, onComplete) {\n      var _this3 = this;\n\n      // Stop any pending promises\n      this._weightPromise.cancel(); // Start tweening weight to 0 for the current states\n\n\n      var weightPromises = this._from.map(function (state) {\n        return state.setWeight(0, transitionTime, easingFn);\n      }); // Start tweening weight to 1 for the target state\n\n\n      if (this._to) {\n        weightPromises.push(this._to.setWeight(1, transitionTime, easingFn));\n        this.name = this._to.name;\n      } else {\n        this.name = null;\n      }\n\n      this._weightPromise = core_Deferred.all(weightPromises, function () {\n        _this3._from.forEach(function (state) {\n          state.cancel();\n          state.deactivate();\n        });\n\n        if (typeof onComplete === \'function\') {\n          onComplete();\n        }\n      });\n    }\n  }, {\n    key: "play",\n    value: function play(onFinish, onError, onCancel, onNext) {\n      this._paused = false;\n      this._playCallbacks.onFinish = onFinish;\n      this._playCallbacks.onError = onError;\n      this._playCallbacks.onCancel = onCancel;\n      var promises = [this._weightPromise];\n\n      this._from.forEach(function (state) {\n        state.resume();\n      });\n\n      if (this._to) {\n        this._promises.play = this._to.play(undefined, undefined, undefined, onNext);\n        promises.push(this._promises.play);\n      }\n\n      this._promises.finish = core_Deferred.all(promises, onFinish, onError, onCancel);\n      return this._promises.finish;\n    }\n  }, {\n    key: "pause",\n    value: function pause() {\n      this._from.forEach(function (state) {\n        state.pause();\n      });\n\n      if (this._to) {\n        this._to.pause();\n      }\n\n      return TransitionState_get(TransitionState_getPrototypeOf(TransitionState.prototype), "pause", this).call(this);\n    }\n  }, {\n    key: "resume",\n    value: function resume(onFinish, onError, onCancel, onNext) {\n      this._paused = false;\n\n      if (!this._promises.play.pending) {\n        this._playCallbacks.onFinish = onFinish || this._playCallbacks.onFinish;\n        this._playCallbacks.onError = onError || this._playCallbacks.onError;\n        this._playCallbacks.onCancel = onCancel || this._playCallbacks.onCancel;\n      }\n\n      var promises = [this._weightPromise];\n\n      this._from.forEach(function (state) {\n        state.resume();\n      });\n\n      if (this._to) {\n        this._promises.play = this._to.resume(undefined, undefined, undefined, onNext);\n        promises.push(this._promises.play);\n      }\n\n      this._promises.finish = core_Deferred.all(promises, this._playCallbacks.onFinish, this._playCallbacks.onError, this._playCallbacks.onCancel);\n      return this._promises.finish;\n    }\n  }, {\n    key: "cancel",\n    value: function cancel() {\n      this._from.forEach(function (state) {\n        state.pause();\n      });\n\n      if (this._to) {\n        this._to.cancel();\n      }\n\n      this._weightPromise.cancel();\n\n      return TransitionState_get(TransitionState_getPrototypeOf(TransitionState.prototype), "cancel", this).call(this);\n    }\n  }, {\n    key: "stop",\n    value: function stop() {\n      this._from.forEach(function (state) {\n        state.pause();\n      });\n\n      if (this._to) {\n        this._to.stop();\n      }\n\n      return TransitionState_get(TransitionState_getPrototypeOf(TransitionState.prototype), "stop", this).call(this);\n    }\n  }, {\n    key: "update",\n    value: function update(deltaTime) {\n      TransitionState_get(TransitionState_getPrototypeOf(TransitionState.prototype), "update", this).call(this, deltaTime);\n\n      this._from.forEach(function (state) {\n        state.update(deltaTime);\n      });\n\n      if (this._to) {\n        this._to.update(deltaTime);\n      }\n    }\n  }, {\n    key: "discard",\n    value: function discard() {\n      TransitionState_get(TransitionState_getPrototypeOf(TransitionState.prototype), "discard", this).call(this);\n\n      this._weightPromise.cancel();\n\n      delete this._weightPromise;\n      this._to = null;\n      this._from.length = 0;\n    }\n  }, {\n    key: "deactivate",\n    value: function deactivate() {\n      if (this._to) {\n        this._to.deactivate();\n      }\n\n      this._from.forEach(function (state) {\n        state.deactivate();\n      });\n    }\n  }]);\n\n  return TransitionState;\n}(state_AbstractState);\n\n/* harmony default export */ const state_TransitionState = (TransitionState);\n;// CONCATENATED MODULE: ./src/core/animpack/AnimationPlayerInterface.js\nfunction AnimationPlayerInterface_typeof(obj) { "@babel/helpers - typeof"; return AnimationPlayerInterface_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, AnimationPlayerInterface_typeof(obj); }\n\nfunction AnimationPlayerInterface_toConsumableArray(arr) { return AnimationPlayerInterface_arrayWithoutHoles(arr) || AnimationPlayerInterface_iterableToArray(arr) || AnimationPlayerInterface_unsupportedIterableToArray(arr) || AnimationPlayerInterface_nonIterableSpread(); }\n\nfunction AnimationPlayerInterface_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction AnimationPlayerInterface_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return AnimationPlayerInterface_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return AnimationPlayerInterface_arrayLikeToArray(o, minLen); }\n\nfunction AnimationPlayerInterface_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction AnimationPlayerInterface_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return AnimationPlayerInterface_arrayLikeToArray(arr); }\n\nfunction AnimationPlayerInterface_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction AnimationPlayerInterface_get() { if (typeof Reflect !== "undefined" && Reflect.get) { AnimationPlayerInterface_get = Reflect.get; } else { AnimationPlayerInterface_get = function _get(target, property, receiver) { var base = AnimationPlayerInterface_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return AnimationPlayerInterface_get.apply(this, arguments); }\n\nfunction AnimationPlayerInterface_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = AnimationPlayerInterface_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction AnimationPlayerInterface_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) AnimationPlayerInterface_setPrototypeOf(subClass, superClass); }\n\nfunction AnimationPlayerInterface_setPrototypeOf(o, p) { AnimationPlayerInterface_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return AnimationPlayerInterface_setPrototypeOf(o, p); }\n\nfunction AnimationPlayerInterface_createSuper(Derived) { var hasNativeReflectConstruct = AnimationPlayerInterface_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = AnimationPlayerInterface_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = AnimationPlayerInterface_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return AnimationPlayerInterface_possibleConstructorReturn(this, result); }; }\n\nfunction AnimationPlayerInterface_possibleConstructorReturn(self, call) { if (call && (AnimationPlayerInterface_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return AnimationPlayerInterface_assertThisInitialized(self); }\n\nfunction AnimationPlayerInterface_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction AnimationPlayerInterface_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction AnimationPlayerInterface_getPrototypeOf(o) { AnimationPlayerInterface_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return AnimationPlayerInterface_getPrototypeOf(o); }\n\nfunction AnimationPlayerInterface_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AnimationPlayerInterface_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AnimationPlayerInterface_createClass(Constructor, protoProps, staticProps) { if (protoProps) AnimationPlayerInterface_defineProperties(Constructor.prototype, protoProps); if (staticProps) AnimationPlayerInterface_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable max-classes-per-file */\n\n/* eslint-disable no-unused-vars */\n\n/* eslint-disable no-empty-function */\n\n/* eslint-disable getter-return */\n\n/* eslint-disable no-useless-constructor */\n\n\n/**\n * Class factory interface for controlling playback of a collection of animations.\n * One animation can be played at any given time, crossfading between animations\n * will result in playing a {@link TransitionState}.\n *\n * @interface\n */\n\nvar AnimationPlayerInterface = /*#__PURE__*/function () {\n  function AnimationPlayerInterface() {\n    AnimationPlayerInterface_classCallCheck(this, AnimationPlayerInterface);\n  }\n\n  AnimationPlayerInterface_createClass(AnimationPlayerInterface, [{\n    key: "paused",\n    get:\n    /**\n     * Gets whether or not the player is updating states.\n     *\n     * @readonly\n     * @type {boolean}\n     */\n    function get() {\n      return this._paused;\n    }\n    /**\n     * Gets and sets the default number of seconds it takes to transition to a new\n     * animation.\n     *\n     * @type {number}\n     */\n\n  }, {\n    key: "transitionTime",\n    get: function get() {},\n    set: function set(seconds) {}\n    /**\n     * Gets and sets the default easing function to use when transitioning and\n     * setting weights.\n     *\n     * @type {Function}\n     */\n\n  }, {\n    key: "easingFn",\n    get: function get() {},\n    set: function set(fn) {}\n    /**\n     * Gets the state the layer is currently in control of.\n     *\n     * @readonly\n     * @type {AbstractState}\n     */\n\n  }, {\n    key: "currentState",\n    get: function get() {}\n    /**\n     * Gets the name of the state the layer is currently in control of.\n     *\n     * @readonly\n     * @type {string}\n     */\n\n  }, {\n    key: "currentAnimation",\n    get: function get() {}\n    /**\n     * Gets whether or not the layer is currently transitioning to a new animation.\n     *\n     * @readonly\n     * @type {boolean}\n     */\n\n  }, {\n    key: "isTransitioning",\n    get: function get() {}\n    /**\n     * Update the layer\'s current state to a new value. If transitionTime is defined\n     * and greater than zero, perform a smooth blend between any states that currently\n     * have non-zero weight values and the new state.\n     *\n     * @private\n     *\n     * @param {(string|null)} name - Name of the state to transition to.\n     * @param {string} playMethod - Name of the operation being prepared for, to be\n     * used in error messaging.\n     * @param {number=} transitionTime - Amount of time in seconds it will take to\n     * switch to the new state.\n     * @param {Function=} easingFn - Easing function to use when transitioning to a\n     * new state over time.\n     * @param {Function=} onError - Function to execute if an error is encountered.\n     */\n\n  }, {\n    key: "_prepareCurrentState",\n    value: function _prepareCurrentState(name, playMethod, transitionTime, easingFn, onError) {}\n    /**\n     * Start playback an animation from the beginning.\n     *\n     * @param {string} name - Name of the animation to play.\n     * @param {number=} transitionTime - Amount of time it will take before the\n     * new state has full influence for the layer.\n     * @param {Function=} easingFn - Easing function to use for blending if transitionTime\n     * is greater than zero.\n     * @param {Function=} onFinish - Function to execute when the animation finishes.\n     * @param {Function=} onError - Function to execute if the animation encounters\n     * an error during playback.\n     * @param {Function=} onCancel - Function to execute if playback is canceled.\n     * @param {Function=} onNext - Function to execute if an animation queue is\n     * played and it advances to the next animation.\n     *\n     * @returns {Deferred}\n     */\n\n  }, {\n    key: "playAnimation",\n    value: function playAnimation(name, transitionTime, easingFn, onFinish, onError, onCancel, onNext) {}\n    /**\n     * Cancel playback of the current animation.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "cancelAnimation",\n    value: function cancelAnimation() {}\n    /**\n     * Pause playback of the current animation.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "pauseAnimation",\n    value: function pauseAnimation() {}\n    /**\n     * Resume playback of an animation.\n     *\n     * @param {string=} name - Name of the animation to resume playback for. Default\n     * is the layer\'s current animation name.\n     * @param {number=} transitionTime - Amount of time it will take before the\n     * new state has full influence for the layer.\n     * @param {Function=} onFinish - Function to execute when the state finishes.\n     * @param {Function=} onError - Function to execute if the state encounters\n     * an error during playback.\n     * @param {Function=} onCancel - Function to execute if playback is canceled.\n     * @param {Function=} onNext - Function to execute if an animation queue is\n     * played and it advances to the next animation.\n     *\n     * @returns {Deferred}\n     */\n\n  }, {\n    key: "resumeAnimation",\n    value: function resumeAnimation(name, transitionTime, easingFn, onFinish, onError, onCancel, onNext) {}\n    /**\n     * Stop playback of the current animation.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "stopAnimation",\n    value: function stopAnimation() {}\n    /**\n     * Update the current animation.\n     *\n     * @param {number} deltaTime - Time in milliseconds since the last update.\n     */\n\n  }, {\n    key: "update",\n    value: function update(deltaTime) {}\n    /**\n     * Discard the transition state.\n     */\n\n  }, {\n    key: "discard",\n    value: function discard() {}\n    /**\n     * Creates a class that implements {@link AnimationPlayerInterface} and extends\n     * a specified base class.\n     *\n     * @param {Class} [BaseClass = class{}] - The class to extend.\n     *\n     * @return {Class} A class that extends `BaseClass` and implements {@link AnimationPlayerInterface}.\n     */\n\n  }], [{\n    key: "Mixin",\n    value: function Mixin() {\n      var BaseClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : /*#__PURE__*/function () {\n        function _class() {\n          AnimationPlayerInterface_classCallCheck(this, _class);\n        }\n\n        return AnimationPlayerInterface_createClass(_class);\n      }();\n\n      var AnimationPlayerMixin = /*#__PURE__*/function (_BaseClass) {\n        AnimationPlayerInterface_inherits(AnimationPlayerMixin, _BaseClass);\n\n        var _super = AnimationPlayerInterface_createSuper(AnimationPlayerMixin);\n\n        function AnimationPlayerMixin() {\n          var _this;\n\n          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n          AnimationPlayerInterface_classCallCheck(this, AnimationPlayerMixin);\n\n          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n          }\n\n          _this = _super.call.apply(_super, [this, options].concat(args));\n          _this._transitionState = new state_TransitionState();\n          _this._states = _this._states !== undefined ? _this._states : new Map();\n          _this._currentState = null;\n          _this._paused = false;\n          _this._transitionTime = Number(options.transitionTime) >= 0 ? Number(options.transitionTime) : 0;\n          _this._easingFn = typeof options.easingFn === \'function\' ? options.easingFn : undefined;\n          return _this;\n        }\n\n        AnimationPlayerInterface_createClass(AnimationPlayerMixin, [{\n          key: "paused",\n          get: function get() {\n            return this._paused;\n          }\n        }, {\n          key: "transitionTime",\n          get: function get() {\n            return this._transitionTime;\n          },\n          set: function set(seconds) {\n            seconds = Number(seconds);\n\n            if (!(seconds >= 0)) {\n              throw new Error("Cannot set transition time for ".concat(this.constructor.name, " to ").concat(seconds, ". Seconds must be a numeric value greather than or equal to zero."));\n            }\n\n            this._transitionTime = seconds;\n          }\n        }, {\n          key: "easingFn",\n          get: function get() {\n            return this._easingFn;\n          },\n          set: function set(fn) {\n            this._easingFn = fn;\n          }\n        }, {\n          key: "currentState",\n          get: function get() {\n            return this._currentState;\n          }\n        }, {\n          key: "currentAnimation",\n          get: function get() {\n            if (this._currentState) {\n              return this._currentState.name;\n            }\n\n            return null;\n          }\n        }, {\n          key: "isTransitioning",\n          get: function get() {\n            return this._currentState === this._transitionState;\n          }\n        }, {\n          key: "_prepareCurrentState",\n          value: function _prepareCurrentState(name, playMethod, transitionTime, easingFn, onError) {\n            var _this2 = this;\n\n            if (name !== null && !this._states.has(name)) {\n              var e = new Error("Cannot ".concat(playMethod, " animation ").concat(name, ". No animation exists with this name."));\n\n              if (typeof onError === \'function\') {\n                onError(e);\n              }\n\n              throw e;\n            }\n\n            var targetState = name !== null ? this._states.get(name) : null; // Make sure the new state isn\'t already playing\n\n            if (this.currentAnimation !== name) {\n              // Switch to the new state immediately\n              if (transitionTime <= 0) {\n                // Cancel the current state and set its weight to 0\n                if (this._currentState) {\n                  this._currentState.cancel();\n\n                  this._currentState.weight = 0;\n\n                  this._currentState.deactivate();\n                }\n\n                this._currentState = targetState;\n              } // Blend to the new state over time\n              else {\n                // Make sure to transition out of any states with non-zero weight\n                var currentStates = AnimationPlayerInterface_toConsumableArray(this._states.values()).filter(function (s) {\n                  return s !== targetState && (s.weight || s.weightPending);\n                }); // Update the transition state with new inputs\n\n\n                this._transitionState.configure(currentStates, targetState, transitionTime, easingFn, function () {\n                  _this2._currentState = targetState;\n                  _this2._transitionState.weight = 0;\n                });\n\n                this._currentState = this._transitionState;\n              }\n            } else if (playMethod === \'play\') {\n              this._currentState.cancel();\n\n              if (this._currentState === this._transitionState) {\n                this._transitionState.reset(transitionTime, easingFn, function () {\n                  _this2._currentState = targetState;\n                  _this2._transitionState.weight = 0;\n                });\n              }\n            } // Update weight for the new current state so it has full influence for the player\n\n\n            this._currentState.weight = 1;\n\n            this._currentState.updateInternalWeight(this._internalWeight);\n          }\n        }, {\n          key: "playAnimation",\n          value: function playAnimation(name, transitionTime, easingFn, onFinish, onError, onCancel, onNext) {\n            var error;\n            var reject = false;\n\n            try {\n              this._prepareCurrentState(name, \'play\', transitionTime !== undefined ? transitionTime : this._transitionTime, easingFn !== undefined ? easingFn : this._easingFn, onError);\n            } catch (e) {\n              error = e;\n              reject = true;\n            }\n\n            if (reject) {\n              return core_Deferred.reject(error);\n            }\n\n            return this._currentState.play(onFinish, onError, onCancel, onNext);\n          }\n        }, {\n          key: "pauseAnimation",\n          value: function pauseAnimation() {\n            if (this._currentState) {\n              return this._currentState.pause();\n            } else {\n              return false;\n            }\n          }\n        }, {\n          key: "resumeAnimation",\n          value: function resumeAnimation(name, transitionTime, easingFn, onFinish, onError, onCancel, onNext) {\n            if (name === undefined && this._currentState) {\n              name = this._currentState.name;\n            }\n\n            var error;\n            var reject = false;\n\n            try {\n              this._prepareCurrentState(name, \'resume\', transitionTime !== undefined ? transitionTime : this._transitionTime, easingFn !== undefined ? easingFn : this._easingFn, onError);\n            } catch (e) {\n              error = e;\n              reject = true;\n            }\n\n            if (reject) {\n              return core_Deferred.reject(error);\n            }\n\n            return this._currentState.resume(onFinish, onError, onCancel, onNext);\n          }\n        }, {\n          key: "cancelAnimation",\n          value: function cancelAnimation() {\n            if (this._currentState) {\n              return this._currentState.cancel();\n            } else {\n              return false;\n            }\n          }\n        }, {\n          key: "stopAnimation",\n          value: function stopAnimation() {\n            if (this._currentState) {\n              return this._currentState.stop();\n            } else {\n              return false;\n            }\n          }\n        }, {\n          key: "update",\n          value: function update(deltaTime) {\n            if (AnimationPlayerInterface_get(AnimationPlayerInterface_getPrototypeOf(AnimationPlayerMixin.prototype), "update", this)) {\n              AnimationPlayerInterface_get(AnimationPlayerInterface_getPrototypeOf(AnimationPlayerMixin.prototype), "update", this).call(this, deltaTime);\n            }\n\n            if (this._currentState) {\n              this._currentState.update(deltaTime);\n            }\n          }\n        }, {\n          key: "discard",\n          value: function discard() {\n            if (AnimationPlayerInterface_get(AnimationPlayerInterface_getPrototypeOf(AnimationPlayerMixin.prototype), "discard", this)) {\n              AnimationPlayerInterface_get(AnimationPlayerInterface_getPrototypeOf(AnimationPlayerMixin.prototype), "discard", this).call(this);\n            }\n\n            this._transitionState.discard();\n\n            delete this._transitionState;\n          }\n        }]);\n\n        return AnimationPlayerMixin;\n      }(BaseClass);\n\n      return AnimationPlayerMixin;\n    }\n  }]);\n\n  return AnimationPlayerInterface;\n}();\n\n/* harmony default export */ const animpack_AnimationPlayerInterface = (AnimationPlayerInterface);\n;// CONCATENATED MODULE: ./src/core/animpack/state/StateContainerInterface.js\nfunction StateContainerInterface_typeof(obj) { "@babel/helpers - typeof"; return StateContainerInterface_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, StateContainerInterface_typeof(obj); }\n\nfunction StateContainerInterface_toConsumableArray(arr) { return StateContainerInterface_arrayWithoutHoles(arr) || StateContainerInterface_iterableToArray(arr) || StateContainerInterface_unsupportedIterableToArray(arr) || StateContainerInterface_nonIterableSpread(); }\n\nfunction StateContainerInterface_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction StateContainerInterface_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return StateContainerInterface_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return StateContainerInterface_arrayLikeToArray(o, minLen); }\n\nfunction StateContainerInterface_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction StateContainerInterface_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return StateContainerInterface_arrayLikeToArray(arr); }\n\nfunction StateContainerInterface_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction StateContainerInterface_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) StateContainerInterface_setPrototypeOf(subClass, superClass); }\n\nfunction StateContainerInterface_setPrototypeOf(o, p) { StateContainerInterface_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return StateContainerInterface_setPrototypeOf(o, p); }\n\nfunction StateContainerInterface_createSuper(Derived) { var hasNativeReflectConstruct = StateContainerInterface_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = StateContainerInterface_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = StateContainerInterface_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return StateContainerInterface_possibleConstructorReturn(this, result); }; }\n\nfunction StateContainerInterface_possibleConstructorReturn(self, call) { if (call && (StateContainerInterface_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return StateContainerInterface_assertThisInitialized(self); }\n\nfunction StateContainerInterface_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction StateContainerInterface_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction StateContainerInterface_getPrototypeOf(o) { StateContainerInterface_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return StateContainerInterface_getPrototypeOf(o); }\n\nfunction StateContainerInterface_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction StateContainerInterface_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction StateContainerInterface_createClass(Constructor, protoProps, staticProps) { if (protoProps) StateContainerInterface_defineProperties(Constructor.prototype, protoProps); if (staticProps) StateContainerInterface_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable max-classes-per-file */\n\n/* eslint-disable no-unused-vars */\n\n/* eslint-disable no-empty-function */\n\n/* eslint-disable getter-return */\n\n/**\n * Class factory interface for manipulating a collection of {@link AbstractState}.\n *\n * @interface\n */\n\nvar StateContainerInterface = /*#__PURE__*/function () {\n  function StateContainerInterface() {\n    StateContainerInterface_classCallCheck(this, StateContainerInterface);\n  }\n\n  StateContainerInterface_createClass(StateContainerInterface, [{\n    key: "getState",\n    value:\n    /**\n     * Return the state with the given name.\n     *\n     * @param {string} name - Name of the state.\n     *\n     * @returns {AbstractState}\n     */\n    function getState(name) {}\n    /**\n     * Gets an array of the names of all states in the container.\n     *\n     * @type {Array.<string>}\n     */\n\n  }, {\n    key: "getStateNames",\n    value: function getStateNames() {}\n    /**\n     * Add a new state to be controlled by the container. States are stored keyed\n     * by their name property, which must be unique. If it isn\'t, a number will\n     * be added or incremented until a unique key is generated.\n     *\n     * @param {AbstractState} state - State to add to the container.\n     *\n     * @returns {string} - Unique name of the state.\n     */\n\n  }, {\n    key: "addState",\n    value: function addState(state) {}\n    /**\n     * Removes a state with the given name from the container.\n     *\n     * @param {string} name - Name of the state to remove.\n     *\n     * @returns {boolean} - Whether or not a state was removed.\n     */\n\n  }, {\n    key: "removeState",\n    value: function removeState(name) {}\n    /**\n     * Renames a state with the given name in the container. Name must be unique\n     * to the container, if it isn\'t the name will be incremented until it is unique.\n     *\n     * @param {string} currentName - Name of the state to rename.\n     * @param {string} newName - Name to update the state with.\n     *\n     * @returns {string} - Updated name for the state.\n     */\n\n  }, {\n    key: "renameState",\n    value: function renameState(currentName, newName) {}\n    /**\n     * Discards all states.\n     */\n\n  }, {\n    key: "discardStates",\n    value: function discardStates() {}\n    /**\n     * Creates a class that implements {@link StateContainerInterface} and extends\n     * a specified base class.\n     *\n     * @param {Class} [BaseClass = class{}] - The class to extend.\n     *\n     * @return {Class} A class that extends `BaseClass` and implements {@link StateContainerInterface}.\n     */\n\n  }], [{\n    key: "Mixin",\n    value: function Mixin() {\n      var BaseClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : /*#__PURE__*/function () {\n        function _class() {\n          StateContainerInterface_classCallCheck(this, _class);\n        }\n\n        return StateContainerInterface_createClass(_class);\n      }();\n\n      /**\n       * This mixin adds functionality for manipulating uniquely-named animation states in\n       * a map.\n       */\n      var StateContainerMixin = /*#__PURE__*/function (_BaseClass) {\n        StateContainerInterface_inherits(StateContainerMixin, _BaseClass);\n\n        var _super = StateContainerInterface_createSuper(StateContainerMixin);\n\n        function StateContainerMixin() {\n          var _this;\n\n          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n          StateContainerInterface_classCallCheck(this, StateContainerMixin);\n\n          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n          }\n\n          _this = _super.call.apply(_super, [this, options].concat(args));\n          _this._states = _this._states !== undefined ? _this._states : new Map();\n          return _this;\n        }\n\n        StateContainerInterface_createClass(StateContainerMixin, [{\n          key: "getState",\n          value: function getState(name) {\n            return this._states.get(name);\n          }\n        }, {\n          key: "getStateNames",\n          value: function getStateNames() {\n            return StateContainerInterface_toConsumableArray(this._states.keys());\n          }\n        }, {\n          key: "addState",\n          value: function addState(state) {\n            // Make sure the state is not already in this container\n            if (StateContainerInterface_toConsumableArray(this._states.values()).includes(state)) {\n              console.warn("Cannot add animation to state ".concat(this.name, ". Animation was already added."));\n              return state.name;\n            } // Make sure the state name is unique\n\n\n            var uniqueName = core_Utils.getUniqueName(state.name, StateContainerInterface_toConsumableArray(this._states.keys()));\n\n            if (state.name !== uniqueName) {\n              console.warn("Animation name ".concat(state.name, " is not unique for state ").concat(this.name, ". New animation will be added with name ").concat(uniqueName, "."));\n              state.name = uniqueName;\n            }\n\n            this._states.set(state.name, state);\n\n            return state.name;\n          }\n        }, {\n          key: "removeState",\n          value: function removeState(name) {\n            // Check if the state is in this container\n            if (!this._states || !this._states.has(name)) {\n              console.warn("Did not remove animation ".concat(name, " from state ").concat(this.name, ". No animation exists with this name."));\n              return false;\n            }\n\n            this._states.get(name).discard();\n\n            this._states["delete"](name);\n\n            return true;\n          }\n        }, {\n          key: "renameState",\n          value: function renameState(currentName, newName) {\n            // Make sure the state is in this container\n            if (!this._states || !this._states.has(currentName)) {\n              throw new Error("Cannot rename animation ".concat(currentName, " in ").concat(this.name, ". No animation exists with this name."));\n            }\n\n            var state = this._states.get(currentName); // Exit if the names are the same\n\n\n            if (currentName === newName) {\n              return currentName;\n            } // Make sure the name is unique\n\n\n            var uniqueName = core_Utils.getUniqueName(newName, StateContainerInterface_toConsumableArray(this._states.keys()).filter(function (s) {\n              return s.name !== currentName;\n            }));\n\n            if (newName !== uniqueName) {\n              console.warn("Animation name ".concat(newName, " is not unique in state ").concat(this.name, ". Animation will be renamed to ").concat(uniqueName, "."));\n              newName = uniqueName;\n            }\n\n            state.name = newName;\n\n            this._states["delete"](currentName);\n\n            this._states.set(state.name, state);\n\n            return state.name;\n          }\n        }, {\n          key: "discardStates",\n          value: function discardStates() {\n            this._states.forEach(function (state) {\n              state.discard();\n            });\n\n            delete this._states;\n          }\n        }]);\n\n        return StateContainerMixin;\n      }(BaseClass);\n\n      return StateContainerMixin;\n    }\n  }]);\n\n  return StateContainerInterface;\n}();\n\n/* harmony default export */ const state_StateContainerInterface = (StateContainerInterface);\n;// CONCATENATED MODULE: ./src/core/animpack/state/QueueState.js\nfunction QueueState_typeof(obj) { "@babel/helpers - typeof"; return QueueState_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, QueueState_typeof(obj); }\n\nfunction QueueState_toConsumableArray(arr) { return QueueState_arrayWithoutHoles(arr) || QueueState_iterableToArray(arr) || QueueState_unsupportedIterableToArray(arr) || QueueState_nonIterableSpread(); }\n\nfunction QueueState_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction QueueState_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return QueueState_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return QueueState_arrayLikeToArray(o, minLen); }\n\nfunction QueueState_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction QueueState_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return QueueState_arrayLikeToArray(arr); }\n\nfunction QueueState_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction QueueState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction QueueState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction QueueState_createClass(Constructor, protoProps, staticProps) { if (protoProps) QueueState_defineProperties(Constructor.prototype, protoProps); if (staticProps) QueueState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction QueueState_get() { if (typeof Reflect !== "undefined" && Reflect.get) { QueueState_get = Reflect.get; } else { QueueState_get = function _get(target, property, receiver) { var base = QueueState_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return QueueState_get.apply(this, arguments); }\n\nfunction QueueState_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = QueueState_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction QueueState_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) QueueState_setPrototypeOf(subClass, superClass); }\n\nfunction QueueState_setPrototypeOf(o, p) { QueueState_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return QueueState_setPrototypeOf(o, p); }\n\nfunction QueueState_createSuper(Derived) { var hasNativeReflectConstruct = QueueState_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = QueueState_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = QueueState_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return QueueState_possibleConstructorReturn(this, result); }; }\n\nfunction QueueState_possibleConstructorReturn(self, call) { if (call && (QueueState_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return QueueState_assertThisInitialized(self); }\n\nfunction QueueState_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction QueueState_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction QueueState_getPrototypeOf(o) { QueueState_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return QueueState_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n/**\n * Class for playing an ordered array of animation states in sequence.\n *\n * @extends AbstractState\n * @implements @AnimationPlayerInterface\n */\n\nvar QueueState = /*#__PURE__*/function (_AnimationPlayerInter) {\n  QueueState_inherits(QueueState, _AnimationPlayerInter);\n\n  var _super = QueueState_createSuper(QueueState);\n\n  /**\n   * @constructor\n   *\n   * @param {Object} [options={}] - Options for the state.\n   * @param {boolean} [options.autoAdvance=true] - Whether to autmatically advance\n   * to the next state in the queue as each state completes.\n   * @param {Array.<AbstractState>} [queueStates=[]] - Array of states to be played\n   * in order.\n   */\n  function QueueState() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var queueStates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    QueueState_classCallCheck(this, QueueState);\n\n    _this = _super.call(this, options);\n    queueStates.forEach(function (state) {\n      _this.addState(state);\n    });\n    _this._queue = _this._states.keys();\n    _this._done = true;\n    return _this;\n  }\n  /**\n   * Gets whether the animation queue has reached the end.\n   */\n\n\n  QueueState_createClass(QueueState, [{\n    key: "done",\n    get: function get() {\n      return this._done;\n    }\n    /**\n     * Gets the internal weight.\n     *\n     * @readonly\n     * @type {number}\n     */\n\n  }, {\n    key: "internalWeight",\n    get: function get() {\n      return this._currentState ? this._currentState.internalWeight * this._internalWeight : 0;\n    }\n    /**\n     * Restart the queue iterator.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_reset",\n    value: function _reset() {\n      this._queue = this._states.keys();\n\n      var _this$_queue$next = this._queue.next(),\n          value = _this$_queue$next.value,\n          done = _this$_queue$next.done;\n\n      this._done = done;\n      return value || null;\n    }\n    /**\n     * Multiplies the user weight by a factor to determine the internal weight.\n     *\n     * @param {number} factor - 0-1 multiplier to apply to the user weight.\n     */\n\n  }, {\n    key: "updateInternalWeight",\n    value: function updateInternalWeight(factor) {\n      QueueState_get(QueueState_getPrototypeOf(QueueState.prototype), "updateInternalWeight", this).call(this, factor);\n\n      if (this._currentState) {\n        this._currentState.updateInternalWeight(this._internalWeight);\n      }\n    }\n    /**\n     * Start the next animation in the queue.\n     *\n     * @param {Function=} onNext - Function to execute each time an animation completes\n     * and the queue moves to the next animation.\n     * @param {boolean} [wrap=false] - Whether or not to start the queue from the\n     * beginning again if the end has been reached.\n     *\n     * @returns {Deferred}\n     */\n\n  }, {\n    key: "next",\n    value: function next(onNext) {\n      var _this2 = this;\n\n      var wrap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      // Move the queue forward\n      var _this$_queue$next2 = this._queue.next(),\n          name = _this$_queue$next2.value,\n          done = _this$_queue$next2.done;\n\n      this._done = done;\n      this._paused = false; // The queue has reached the end\n\n      if (done) {\n        // Start the queue over\n        if (wrap) {\n          return this.play(this._playCallbacks.onFinish, this._playCallbacks.onError, this._playCallbacks.onCancel, onNext);\n        } // Stop the queue\n        else {\n          this._promises.finish.resolve();\n\n          return this._promises.finish;\n        }\n      } // Signal the next animation is starting\n\n\n      if (typeof onNext === \'function\') {\n        var lastName = QueueState_toConsumableArray(this._states.keys())[this._states.size - 1];\n\n        var isQueueEnd = name === lastName;\n        onNext({\n          name: name,\n          canAdvance: this.getState(name).loopCount !== Infinity && !isQueueEnd,\n          isQueueEnd: isQueueEnd\n        });\n      } // Start the next animation\n\n\n      this.playAnimation(name, this._transitionTime, this._easingFn, function () {\n        if (!_this2._paused && !_this2.isTransitioning) {\n          _this2.next(onNext);\n        }\n      }, this._playCallbacks.onError);\n      return this._promises.finish;\n    }\n  }, {\n    key: "play",\n    value: function play(onFinish, onError, onCancel, onNext) {\n      var _this3 = this;\n\n      var name = this._reset();\n\n      QueueState_get(QueueState_getPrototypeOf(QueueState.prototype), "play", this).call(this, onFinish, onError, onCancel);\n\n      if (this._done) {\n        this._promises.finish.resolve();\n      } else {\n        // Signal the next animation is starting\n        if (name !== this.currentAnimation && typeof onNext === \'function\') {\n          var lastName = QueueState_toConsumableArray(this._states.keys())[this._states.size - 1];\n\n          var isQueueEnd = name === lastName;\n          onNext({\n            name: name,\n            canAdvance: name ? this.getState(name).loopCount !== Infinity && !isQueueEnd : true,\n            isQueueEnd: !name || isQueueEnd\n          });\n        } // Start the next animation\n\n\n        this.playAnimation(name, this._currentState ? this._transitionTime : 0, this._easingFn, function () {\n          if (!_this3._paused && !_this3.isTransitioning) {\n            _this3.next(onNext);\n          }\n        }, onError);\n      }\n\n      return this._promises.finish;\n    }\n  }, {\n    key: "pause",\n    value: function pause() {\n      var paused = QueueState_get(QueueState_getPrototypeOf(QueueState.prototype), "pause", this).call(this);\n\n      this.pauseAnimation();\n      return paused;\n    }\n  }, {\n    key: "resume",\n    value: function resume(onFinish, onError, onCancel, onNext) {\n      var _this4 = this;\n\n      if (this._done) {\n        return this.play(onFinish, onError, onCancel, onNext);\n      } else {\n        QueueState_get(QueueState_getPrototypeOf(QueueState.prototype), "resume", this).call(this, onFinish, onError, onCancel);\n\n        this.resumeAnimation(this._currentState.name, this._transitionTime, this._easingFn, function () {\n          if (!_this4._paused && !_this4.isTransitioning) {\n            _this4.next(onNext);\n          }\n        }, onError);\n        return this._promises.finish;\n      }\n    }\n  }, {\n    key: "cancel",\n    value: function cancel() {\n      var canceled = QueueState_get(QueueState_getPrototypeOf(QueueState.prototype), "cancel", this).call(this);\n\n      if (this._currentState) {\n        this._currentState.cancel();\n      }\n\n      return canceled;\n    }\n  }, {\n    key: "stop",\n    value: function stop() {\n      var stopped = QueueState_get(QueueState_getPrototypeOf(QueueState.prototype), "stop", this).call(this);\n\n      this.stopAnimation();\n      this._done = true;\n      return stopped;\n    }\n  }, {\n    key: "discard",\n    value: function discard() {\n      QueueState_get(QueueState_getPrototypeOf(QueueState.prototype), "discard", this).call(this);\n\n      this.discardStates();\n    }\n  }]);\n\n  return QueueState;\n}(animpack_AnimationPlayerInterface.Mixin(state_StateContainerInterface.Mixin(state_AbstractState)));\n\n/* harmony default export */ const state_QueueState = (QueueState);\n;// CONCATENATED MODULE: ./src/core/animpack/state/AbstractBlendState.js\nfunction AbstractBlendState_typeof(obj) { "@babel/helpers - typeof"; return AbstractBlendState_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, AbstractBlendState_typeof(obj); }\n\nfunction AbstractBlendState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AbstractBlendState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AbstractBlendState_createClass(Constructor, protoProps, staticProps) { if (protoProps) AbstractBlendState_defineProperties(Constructor.prototype, protoProps); if (staticProps) AbstractBlendState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction AbstractBlendState_get() { if (typeof Reflect !== "undefined" && Reflect.get) { AbstractBlendState_get = Reflect.get; } else { AbstractBlendState_get = function _get(target, property, receiver) { var base = AbstractBlendState_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return AbstractBlendState_get.apply(this, arguments); }\n\nfunction AbstractBlendState_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = AbstractBlendState_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction AbstractBlendState_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) AbstractBlendState_setPrototypeOf(subClass, superClass); }\n\nfunction AbstractBlendState_setPrototypeOf(o, p) { AbstractBlendState_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return AbstractBlendState_setPrototypeOf(o, p); }\n\nfunction AbstractBlendState_createSuper(Derived) { var hasNativeReflectConstruct = AbstractBlendState_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = AbstractBlendState_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = AbstractBlendState_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return AbstractBlendState_possibleConstructorReturn(this, result); }; }\n\nfunction AbstractBlendState_possibleConstructorReturn(self, call) { if (call && (AbstractBlendState_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return AbstractBlendState_assertThisInitialized(self); }\n\nfunction AbstractBlendState_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction AbstractBlendState_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction AbstractBlendState_getPrototypeOf(o) { AbstractBlendState_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return AbstractBlendState_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n/**\n * Base class for a state that blends a collection of {@link AbstractState}.\n *\n * @abstract\n * @implements StateContainerInterface\n */\n\nvar AbstractBlendState = /*#__PURE__*/function (_StateContainerInterf) {\n  AbstractBlendState_inherits(AbstractBlendState, _StateContainerInterf);\n\n  var _super = AbstractBlendState_createSuper(AbstractBlendState);\n\n  function AbstractBlendState() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var blendStates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    AbstractBlendState_classCallCheck(this, AbstractBlendState);\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this, options].concat(args));\n    blendStates.forEach(function (state) {\n      _this.addState(state);\n    });\n    return _this;\n  }\n  /**\n   * Gets the sum of internal weights of the sub-states.\n   *\n   * @readonly\n   * @type {number}\n   */\n\n\n  AbstractBlendState_createClass(AbstractBlendState, [{\n    key: "internalWeight",\n    get: function get() {\n      var blendWeights = 0;\n\n      this._states.forEach(function (state) {\n        blendWeights += state.internalWeight;\n      });\n\n      return blendWeights;\n    }\n    /**\n     * Returns the weight of a state controlled by the container.\n     *\n     * @param {string} name - Name of the state to return the weight from.\n     *\n     * @returns {number} - Weight of the state.\n     */\n\n  }, {\n    key: "getBlendWeight",\n    value: function getBlendWeight(name) {\n      // Make sure the name is valid\n      var state = this.getState(name);\n\n      if (state === undefined) {\n        throw new Error("Cannot get weight of state ".concat(name, " from BlendState ").concat(this.name, ". No state exists with this name."));\n      }\n\n      return state.weight;\n    }\n    /**\n     * Sets the weight of a state controlled by the container.\n     *\n     * @param {string} name - Name of the state to set the weight of.\n     * @param {number} weight - Weight value to set on the state.\n     *\n     * @returns {Deferred}\n     */\n\n  }, {\n    key: "setBlendWeight",\n    value: function setBlendWeight(name, weight) {\n      var seconds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var easingFn = arguments.length > 3 ? arguments[3] : undefined;\n      // Make sure the name is valid\n      var state = this.getState(name);\n\n      if (state === undefined) {\n        throw new Error("Cannot set weight of state ".concat(name, " from BlendState ").concat(this.name, ". No state exists with this name."));\n      }\n\n      weight = core_MathUtils.clamp(weight);\n      return state.setWeight(weight, seconds, easingFn);\n    }\n    /**\n     * Multiplies the weight of each sub-state by a factor to determine the internal weight.\n     *\n     * @param {number} factor - 0-1 multiplier to apply to the user weight.\n     */\n\n  }, {\n    key: "updateInternalWeight",\n    value: function updateInternalWeight(factor) {\n      var _this2 = this;\n\n      AbstractBlendState_get(AbstractBlendState_getPrototypeOf(AbstractBlendState.prototype), "updateInternalWeight", this).call(this, factor);\n\n      this._states.forEach(function (state) {\n        state.updateInternalWeight(_this2._internalWeight);\n      });\n    }\n    /**\n     * Update any values of the sub-states that need to be evaluated every frame.\n     *\n     * @param {number} deltaTime - Time in milliseconds since the last update.\n     */\n\n  }, {\n    key: "update",\n    value: function update(deltaTime) {\n      AbstractBlendState_get(AbstractBlendState_getPrototypeOf(AbstractBlendState.prototype), "update", this).call(this, deltaTime);\n\n      this._states.forEach(function (state) {\n        state.update(deltaTime);\n      });\n    }\n    /**\n     * Start playback of the sub-states from the beginning.\n     *\n     * @param {Function=} onFinish - Function to execute when the state finishes.\n     * @param {Function=} onError - Function to execute if the state encounters\n     * an error during playback.\n     * @param {Function=} onCancel - Function to execute if playback is canceled.\n     *\n     * @returns {Deferred}\n     */\n\n  }, {\n    key: "play",\n    value: function play(onFinish, onError, onCancel) {\n      var promises = [AbstractBlendState_get(AbstractBlendState_getPrototypeOf(AbstractBlendState.prototype), "play", this).call(this)];\n\n      this._states.forEach(function (state) {\n        promises.push(state.play());\n      });\n\n      return core_Deferred.all(promises, onFinish, onError, onCancel);\n    }\n    /**\n     * Pause playback of the sub-states. This prevents pending promises from being executed.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "pause",\n    value: function pause() {\n      this._states.forEach(function (state) {\n        state.pause();\n      });\n\n      return AbstractBlendState_get(AbstractBlendState_getPrototypeOf(AbstractBlendState.prototype), "pause", this).call(this);\n    }\n    /**\n     * Resume playback of the sub-states.\n     *\n     * @param {Function=} onFinish - Function to execute when the state finishes.\n     * @param {Function=} onError - Function to execute if the state encounters\n     * an error during playback.\n     * @param {Function=} onCancel - Function to execute if playback is canceled.\n     *\n     * @returns {Deferred}\n     */\n\n  }, {\n    key: "resume",\n    value: function resume(onFinish, onError, onCancel) {\n      var promises = [AbstractBlendState_get(AbstractBlendState_getPrototypeOf(AbstractBlendState.prototype), "resume", this).call(this)];\n\n      this._states.forEach(function (state) {\n        promises.push(state.resume());\n      });\n\n      return core_Deferred.all(promises, onFinish, onError, onCancel);\n    }\n    /**\n     * Cancel playback of the sub-states and cancel any pending promises.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "cancel",\n    value: function cancel() {\n      this._states.forEach(function (state) {\n        state.cancel();\n      });\n\n      return AbstractBlendState_get(AbstractBlendState_getPrototypeOf(AbstractBlendState.prototype), "cancel", this).call(this);\n    }\n    /**\n     * Stop playback of the sub-states and resolve any pending promises.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "stop",\n    value: function stop() {\n      this._states.forEach(function (state) {\n        state.stop();\n      });\n\n      return AbstractBlendState_get(AbstractBlendState_getPrototypeOf(AbstractBlendState.prototype), "stop", this).call(this);\n    }\n    /**\n     * Discards all sub-state resources.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "discard",\n    value: function discard() {\n      AbstractBlendState_get(AbstractBlendState_getPrototypeOf(AbstractBlendState.prototype), "discard", this).call(this);\n\n      this.discardStates();\n    }\n  }]);\n\n  return AbstractBlendState;\n}(state_StateContainerInterface.Mixin(state_AbstractState));\n\n/* harmony default export */ const state_AbstractBlendState = (AbstractBlendState);\n;// CONCATENATED MODULE: ./src/core/animpack/state/FreeBlendState.js\nfunction FreeBlendState_typeof(obj) { "@babel/helpers - typeof"; return FreeBlendState_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, FreeBlendState_typeof(obj); }\n\nfunction FreeBlendState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction FreeBlendState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction FreeBlendState_createClass(Constructor, protoProps, staticProps) { if (protoProps) FreeBlendState_defineProperties(Constructor.prototype, protoProps); if (staticProps) FreeBlendState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction FreeBlendState_get() { if (typeof Reflect !== "undefined" && Reflect.get) { FreeBlendState_get = Reflect.get; } else { FreeBlendState_get = function _get(target, property, receiver) { var base = FreeBlendState_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return FreeBlendState_get.apply(this, arguments); }\n\nfunction FreeBlendState_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = FreeBlendState_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction FreeBlendState_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) FreeBlendState_setPrototypeOf(subClass, superClass); }\n\nfunction FreeBlendState_setPrototypeOf(o, p) { FreeBlendState_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return FreeBlendState_setPrototypeOf(o, p); }\n\nfunction FreeBlendState_createSuper(Derived) { var hasNativeReflectConstruct = FreeBlendState_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = FreeBlendState_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = FreeBlendState_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return FreeBlendState_possibleConstructorReturn(this, result); }; }\n\nfunction FreeBlendState_possibleConstructorReturn(self, call) { if (call && (FreeBlendState_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return FreeBlendState_assertThisInitialized(self); }\n\nfunction FreeBlendState_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction FreeBlendState_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction FreeBlendState_getPrototypeOf(o) { FreeBlendState_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return FreeBlendState_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\n * Class for blending N number of blend states.\n *\n * @extends AbstractBlendState\n */\n\nvar FreeBlendState = /*#__PURE__*/function (_AbstractBlendState) {\n  FreeBlendState_inherits(FreeBlendState, _AbstractBlendState);\n\n  var _super = FreeBlendState_createSuper(FreeBlendState);\n\n  /**\n   * @constructor\n   *\n   * @param {Object} [options={}] - Options for the container state.\n   * @param {Array.<AbstractState>} [blendStates=[]] - Blend states to be controlled by\n   * this container.\n   */\n  function FreeBlendState() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var blendStates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    FreeBlendState_classCallCheck(this, FreeBlendState);\n\n    return _super.call(this, options, blendStates);\n  }\n\n  FreeBlendState_createClass(FreeBlendState, [{\n    key: "updateInternalWeight",\n    value: function updateInternalWeight(factor) {\n      var _this = this;\n\n      FreeBlendState_get(FreeBlendState_getPrototypeOf(FreeBlendState.prototype), "updateInternalWeight", this).call(this, factor); // Determine the total active weight of blend states\n\n\n      var sumWeights = 0;\n\n      this._states.forEach(function (state) {\n        sumWeights += state.weight;\n      }); // Ensure the sum of blend state internal weights does not exceed container internal weight\n\n\n      factor /= Math.max(sumWeights, 1); // Sum of blend state internal weights should not exceed container internal weight\n\n      this._states.forEach(function (state) {\n        state.updateInternalWeight(factor * _this._weight);\n      });\n    }\n  }]);\n\n  return FreeBlendState;\n}(state_AbstractBlendState);\n\n/* harmony default export */ const state_FreeBlendState = (FreeBlendState);\n;// CONCATENATED MODULE: ./src/core/animpack/state/Blend1dState.js\nfunction Blend1dState_typeof(obj) { "@babel/helpers - typeof"; return Blend1dState_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, Blend1dState_typeof(obj); }\n\nfunction Blend1dState_toConsumableArray(arr) { return Blend1dState_arrayWithoutHoles(arr) || Blend1dState_iterableToArray(arr) || Blend1dState_unsupportedIterableToArray(arr) || Blend1dState_nonIterableSpread(); }\n\nfunction Blend1dState_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Blend1dState_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Blend1dState_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Blend1dState_arrayLikeToArray(o, minLen); }\n\nfunction Blend1dState_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction Blend1dState_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return Blend1dState_arrayLikeToArray(arr); }\n\nfunction Blend1dState_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Blend1dState_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction Blend1dState_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? Blend1dState_ownKeys(Object(source), !0).forEach(function (key) { Blend1dState_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : Blend1dState_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction Blend1dState_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Blend1dState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Blend1dState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Blend1dState_createClass(Constructor, protoProps, staticProps) { if (protoProps) Blend1dState_defineProperties(Constructor.prototype, protoProps); if (staticProps) Blend1dState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction Blend1dState_get() { if (typeof Reflect !== "undefined" && Reflect.get) { Blend1dState_get = Reflect.get; } else { Blend1dState_get = function _get(target, property, receiver) { var base = Blend1dState_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return Blend1dState_get.apply(this, arguments); }\n\nfunction Blend1dState_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Blend1dState_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Blend1dState_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) Blend1dState_setPrototypeOf(subClass, superClass); }\n\nfunction Blend1dState_setPrototypeOf(o, p) { Blend1dState_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Blend1dState_setPrototypeOf(o, p); }\n\nfunction Blend1dState_createSuper(Derived) { var hasNativeReflectConstruct = Blend1dState_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Blend1dState_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Blend1dState_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Blend1dState_possibleConstructorReturn(this, result); }; }\n\nfunction Blend1dState_possibleConstructorReturn(self, call) { if (call && (Blend1dState_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return Blend1dState_assertThisInitialized(self); }\n\nfunction Blend1dState_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Blend1dState_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction Blend1dState_getPrototypeOf(o) { Blend1dState_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Blend1dState_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n/**\n * Class for blending N number of blend states based on a single\n * parameter.\n *\n * @extends AbstractBlendState\n */\n\nvar Blend1dState = /*#__PURE__*/function (_AbstractBlendState) {\n  Blend1dState_inherits(Blend1dState, _AbstractBlendState);\n\n  var _super = Blend1dState_createSuper(Blend1dState);\n\n  /**\n   * @constructor\n   *\n   * @param {Object} [options] - Options for the container state\n   * @param {Array.<AbstractBlendState>} [blendStates=[]] - Blend states to be\n   * controlled by this container.\n   * @param {Array.<number>} [blendThresholds=[]] - Threshold values for activating\n   * each blend state.\n   * @param {Array.<boolean>} [phaseMatches=[]] - Booleans indicating whether or not\n   * each blend state should be phase matched.\n   */\n  function Blend1dState() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var blendStates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var blendThresholds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var phaseMatches = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n    Blend1dState_classCallCheck(this, Blend1dState);\n\n    _this = _super.call(this, options, blendStates);\n    _this._blendValue = 0;\n    _this._promises = Blend1dState_objectSpread(Blend1dState_objectSpread({}, _this._promises), {}, {\n      blendValue: core_Deferred.resolve()\n    }); // Validate there are no duplicate thresholds\n\n    var nonZeroDifferentSize = blendStates.length !== 0 && blendStates.length !== blendThresholds.length;\n\n    if (nonZeroDifferentSize) {\n      throw new Error("Cannot create Blend1dState with blendThresholds ".concat(blendThresholds, ". BlendThresholds count does not match blendStates count."));\n    }\n\n    var containsDuplicates = new Set(blendThresholds).size !== blendThresholds.length;\n\n    if (containsDuplicates) {\n      throw new Error("Cannot create Blend1dState with blendThresholds ".concat(blendThresholds, ". BlendThresholds contains duplicate values"));\n    } // Initialize the thresholds map\n\n\n    _this._thresholds = [];\n\n    Blend1dState_toConsumableArray(_this._states.values()).forEach(function (state, index) {\n      _this._thresholds.push({\n        value: blendThresholds[index],\n        name: state.name,\n        phaseMatch: phaseMatches[index] || false\n      });\n    });\n\n    _this._sortThresholds();\n\n    _this._forceNoThresholdDupes = true;\n    _this._phaseLeadState = null;\n\n    _this._updateBlendWeights();\n\n    return _this;\n  }\n  /**\n   * Gets and sets the blend parameter value.\n   */\n\n\n  Blend1dState_createClass(Blend1dState, [{\n    key: "blendValue",\n    get: function get() {\n      return this._blendValue;\n    },\n    set: function set(value) {\n      this._blendValue = value;\n    }\n    /**\n     * Gets whether or not the blend value is currently being animated.\n     */\n\n  }, {\n    key: "blendValuePending",\n    get: function get() {\n      return this._promises.blendValue && this._promises.blendValue.pending;\n    }\n    /**\n     * Updates the user defined weight over time.\n     *\n     * @param {null} name - Unused parameter.\n     * @param {number} weight - The target weight value.\n     * @param {number} [seconds=0] - The amount of time it will take to reach the\n     * target weight.\n     * @param {Function=} easingFn - The easing function to use for interpolation.\n     *\n     * @returns {Deferred}\n     */\n\n  }, {\n    key: "setBlendWeight",\n    value: function setBlendWeight(name, value) {\n      var _this2 = this;\n\n      var seconds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var easingFn = arguments.length > 3 ? arguments[3] : undefined;\n\n      this._promises.blendValue.cancel();\n\n      this._promises.blendValue = animpack_AnimationUtils.interpolateProperty(this, \'blendValue\', value, {\n        seconds: seconds,\n        easingFn: easingFn,\n        onProgress: function onProgress() {\n          _this2._updateBlendWeights();\n        },\n        onFinish: function onFinish() {\n          _this2._updateBlendWeights();\n        }\n      });\n      return this._promises.blendValue;\n    }\n    /**\n     * Gets the user defined weight.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: "getBlendWeight",\n    value: function getBlendWeight() {\n      return this.blendValue;\n    }\n  }, {\n    key: "addState",\n    value: function addState(state) {\n      var thresholdValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var phaseMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      this._thresholds = this._thresholds || []; // Make sure there is not already a state with this threshold\n\n      var sameValue = this._thresholds.find(function (threshold) {\n        return threshold.value === thresholdValue;\n      });\n\n      if (this._forceNoThresholdDupes && sameValue !== undefined) {\n        throw new Error("Cannot set blend threshold of ".concat(thresholdValue, " for state ").concat(state.name, " on ").concat(this.name, ". A state already exists with that threshold."));\n      }\n\n      Blend1dState_get(Blend1dState_getPrototypeOf(Blend1dState.prototype), "addState", this).call(this, state);\n\n      this._thresholds.push({\n        value: thresholdValue,\n        name: state.name,\n        phaseMatch: phaseMatch || false\n      });\n\n      this._sortThresholds();\n\n      return state.name;\n    }\n  }, {\n    key: "removeState",\n    value: function removeState(name) {\n      var removed = Blend1dState_get(Blend1dState_getPrototypeOf(Blend1dState.prototype), "removeState", this).call(this, name);\n\n      if (removed) {\n        var index = this._thresholds.findIndex(function (threshold) {\n          return threshold.name === name;\n        });\n\n        this._thresholds.splice(index, 1);\n      }\n\n      return removed;\n    }\n  }, {\n    key: "renameState",\n    value: function renameState(currentName, newName) {\n      newName = Blend1dState_get(Blend1dState_getPrototypeOf(Blend1dState.prototype), "renameState", this).call(this, currentName, newName);\n\n      var threshold = this._thresholds.find(function (threshold) {\n        return threshold.name === currentName;\n      });\n\n      threshold.name = newName;\n      return newName;\n    }\n    /**\n     * Gets the threshold value of a blend with the corresponding name.\n     *\n     * @param {string} name - Name of the blend to get the threshold of.\n     *\n     * @returns {number} Threhold value.\n     */\n\n  }, {\n    key: "getBlendThreshold",\n    value: function getBlendThreshold(name) {\n      var threshold = this._thresholds.find(function (threshold) {\n        return threshold.name === name;\n      });\n\n      if (threshold === undefined) {\n        throw new Error("Cannot get blend threshold of state ".concat(name, " on ").concat(this.name, ". No state exists with that name."));\n      }\n\n      return threshold.value;\n    }\n    /**\n     * Sets the threshold value of a blend with the corresponding name.\n     *\n     * @param {string} name - Name of the blend to set the threshold.\n     * @param {number} value - Value of the threshold to set.\n     *\n     * @returns {number} Set threshold value.\n     */\n\n  }, {\n    key: "setBlendThreshold",\n    value: function setBlendThreshold(name, value) {\n      // Make sure there is not already a state with this threshold\n      var sameValue = this._thresholds.find(function (threshold) {\n        return threshold.value === value;\n      });\n\n      if (sameValue !== undefined) {\n        throw new Error("Cannot set blend threshold of ".concat(value, " for state ").concat(name, " on ").concat(this.name, ". A state already exists with that threshold."));\n      }\n\n      var threshold = this._thresholds.find(function (threshold) {\n        return threshold.name === name;\n      });\n\n      if (threshold === undefined) {\n        throw new Error("Cannot set blend threshold of state ".concat(name, " on ").concat(this.name, ". No state exists with that name."));\n      }\n\n      threshold.value = value;\n\n      this._sortThresholds();\n\n      return threshold.value;\n    }\n  }, {\n    key: "updateInternalWeight",\n    value: function updateInternalWeight(factor) {\n      var _this3 = this;\n\n      Blend1dState_get(Blend1dState_getPrototypeOf(Blend1dState.prototype), "updateInternalWeight", this).call(this, factor);\n\n      if (this._phaseLeadState) {\n        this._states.forEach(function (state) {\n          if (state.weight !== 0) {\n            state.normalizedTime = _this3._phaseLeadState.normalizedTime;\n          }\n        });\n      }\n    }\n    /**\n     * Updates the blend weights based on their corresponding threshold values\n     * and the current blendValue. Additionally, sets a lead phase state if the\n     * conditions for phase-matching have been satisfied.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_updateBlendWeights",\n    value: function _updateBlendWeights() {\n      var _this4 = this;\n\n      if (this._thresholds.length === 0) return;\n\n      if (this._thresholds.length === 1) {\n        var state = this._states.get(this._thresholds[0].name);\n\n        state.setWeight(1);\n        return;\n      } // Initially set all sub-state weights to zero\n\n\n      this._states.forEach(function (state) {\n        state.setWeight(0);\n      });\n\n      this._phaseLeadState = null; // Find the first threshold that is greater than or equal to the parameter value\n\n      var targetIndex = this._thresholds.findIndex(function (threshold) {\n        return threshold.value >= _this4._blendValue;\n      });\n\n      if (targetIndex === 0 || targetIndex === -1) {\n        // Give one state full influence\n        targetIndex = targetIndex === -1 ? this._thresholds.length - 1 : 0;\n\n        var _state = this._states.get(this._thresholds[targetIndex].name);\n\n        _state.setWeight(1);\n      } else {\n        // Linear interpolate influence between two states\n        var thresholdA = this._thresholds[targetIndex - 1];\n        var thresholdB = this._thresholds[targetIndex];\n        var factorB = (this.blendValue - thresholdA.value) / (thresholdB.value - thresholdA.value);\n        var factorA = 1 - factorB;\n\n        var stateA = this._states.get(thresholdA.name);\n\n        var stateB = this._states.get(thresholdB.name);\n\n        stateA.setWeight(factorA);\n        stateB.setWeight(factorB); // Set phase-matching if needed\n\n        if (thresholdA.phaseMatch && thresholdB.phaseMatch) {\n          this._phaseLeadState = factorA > factorB ? stateA : stateB;\n        }\n      }\n    }\n    /**\n     * Sorts the thresholds from low to high based on value.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_sortThresholds",\n    value: function _sortThresholds() {\n      this._thresholds.sort(function (a, b) {\n        return a.value - b.value;\n      });\n    }\n  }]);\n\n  return Blend1dState;\n}(state_AbstractBlendState);\n\n/* harmony default export */ const state_Blend1dState = (Blend1dState);\n;// CONCATENATED MODULE: ./src/core/animpack/state/Blend2dState.js\nfunction Blend2dState_typeof(obj) { "@babel/helpers - typeof"; return Blend2dState_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, Blend2dState_typeof(obj); }\n\nfunction Blend2dState_toConsumableArray(arr) { return Blend2dState_arrayWithoutHoles(arr) || Blend2dState_iterableToArray(arr) || Blend2dState_unsupportedIterableToArray(arr) || Blend2dState_nonIterableSpread(); }\n\nfunction Blend2dState_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Blend2dState_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Blend2dState_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Blend2dState_arrayLikeToArray(o, minLen); }\n\nfunction Blend2dState_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction Blend2dState_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return Blend2dState_arrayLikeToArray(arr); }\n\nfunction Blend2dState_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Blend2dState_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction Blend2dState_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? Blend2dState_ownKeys(Object(source), !0).forEach(function (key) { Blend2dState_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : Blend2dState_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction Blend2dState_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Blend2dState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Blend2dState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Blend2dState_createClass(Constructor, protoProps, staticProps) { if (protoProps) Blend2dState_defineProperties(Constructor.prototype, protoProps); if (staticProps) Blend2dState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction Blend2dState_get() { if (typeof Reflect !== "undefined" && Reflect.get) { Blend2dState_get = Reflect.get; } else { Blend2dState_get = function _get(target, property, receiver) { var base = Blend2dState_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return Blend2dState_get.apply(this, arguments); }\n\nfunction Blend2dState_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Blend2dState_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Blend2dState_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) Blend2dState_setPrototypeOf(subClass, superClass); }\n\nfunction Blend2dState_setPrototypeOf(o, p) { Blend2dState_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Blend2dState_setPrototypeOf(o, p); }\n\nfunction Blend2dState_createSuper(Derived) { var hasNativeReflectConstruct = Blend2dState_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Blend2dState_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Blend2dState_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Blend2dState_possibleConstructorReturn(this, result); }; }\n\nfunction Blend2dState_possibleConstructorReturn(self, call) { if (call && (Blend2dState_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return Blend2dState_assertThisInitialized(self); }\n\nfunction Blend2dState_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Blend2dState_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction Blend2dState_getPrototypeOf(o) { Blend2dState_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Blend2dState_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable no-underscore-dangle */\n\n\n\n\n/**\n * Class for blending N number of blend states based on two\n * paramters.\n *\n * @extends AbstractBlendState\n */\n\nvar Blend2dState = /*#__PURE__*/function (_AbstractBlendState) {\n  Blend2dState_inherits(Blend2dState, _AbstractBlendState);\n\n  var _super = Blend2dState_createSuper(Blend2dState);\n\n  /**\n   * @constructor\n   *\n   * @param {Object} [options] - Options for the container state\n   * @param {Array.<AbstractBlendState>} [blendStates=[]] - Blend states to be\n   * controlled by this container.\n   * @param {Array.<Array.<number>>} [blendThresholds=[]] - Threshold values for activating\n   * each blend state.\n   * @param {Array.<boolean>} [phaseMatches=[]] - Booleans indicating whether or not\n   * each blend state should be phase matched.\n   */\n  function Blend2dState() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var blendStates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var blendThresholds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var phaseMatches = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n    Blend2dState_classCallCheck(this, Blend2dState);\n\n    _this = _super.call(this, options, blendStates);\n\n    if (blendStates.length !== blendThresholds.length) {\n      throw new Error("Cannot create Blend2dState with blendStates ".concat(blendStates, " and blendThresholds ").concat(blendThresholds, ". Count of blendStates must match count of blendThresholds."));\n    }\n\n    blendThresholds.slice(0, blendThresholds.length - 1).forEach(function (threshold, index) {\n      blendThresholds.slice(index + 1).forEach(function (otherThreshold) {\n        if (threshold[0] === otherThreshold[0] && threshold[1] === otherThreshold[1]) {\n          throw new Error("Cannot create Blend2dState with blendThresholds ".concat(blendThresholds, ". No duplicate values allowed in blendThresholds."));\n        }\n      });\n    });\n    _this._blendValueX = 0;\n    _this._blendValueY = 0;\n    _this._promises = Blend2dState_objectSpread(Blend2dState_objectSpread({}, _this._promises), {}, {\n      blendValueX: core_Deferred.resolve(),\n      blendValueY: core_Deferred.resolve()\n    });\n    _this._thresholds = [];\n\n    Blend2dState_toConsumableArray(_this._states.values()).forEach(function (state, index) {\n      _this._thresholds.push({\n        name: state.name,\n        phaseMatch: phaseMatches[index] || false\n      });\n    });\n\n    _this._vertices = blendThresholds;\n\n    if (_this._vertices.length >= 3) {\n      _this._triangles = core_MathUtils.getDelaunayTriangulation(_this._vertices);\n    }\n\n    _this._phaseLeadState = null;\n\n    _this._updateBlendWeights();\n\n    return _this;\n  }\n  /**\n   * Updates the user defined weight over time.\n   *\n   * @param {string} name - Name of blend weight to update.\n   * @param {number} weight - Target weight value.\n   * @param {number} [seconds=0] - The amount of time it will take to reach the\n   * target value.\n   * @param {Function=} easingFn - The easing function to use for interpolation.\n   *\n   * @returns {Deferred}\n   */\n\n\n  Blend2dState_createClass(Blend2dState, [{\n    key: "setBlendWeight",\n    value: function setBlendWeight(name, value) {\n      var _this2 = this;\n\n      var seconds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var easingFn = arguments.length > 3 ? arguments[3] : undefined;\n      var property = "blendValue".concat(name.toUpperCase());\n\n      if (property !== \'blendValueX\' && property !== \'blendValueY\') {\n        throw new Error("Cannot set blend weight for ".concat(name, " on ").concat(this.name, ". Blend2dState only accepts \'X\' or \'Y\' for setBlendWeight"));\n      }\n\n      this._promises[property].cancel();\n\n      this._promises[property] = animpack_AnimationUtils.interpolateProperty(this, property, value, {\n        seconds: seconds,\n        easingFn: easingFn,\n        onProgress: function onProgress() {\n          _this2._updateBlendWeights();\n        },\n        onFinish: function onFinish() {\n          _this2._updateBlendWeights();\n        }\n      });\n      return this._promises[property];\n    }\n    /**\n     * Gets the user defined weight.\n     *\n     * @param {string} name - Name of blend weight.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: "getBlendWeight",\n    value: function getBlendWeight(name) {\n      var property = name.toUpperCase();\n\n      if (property !== \'X\' && property !== \'Y\') {\n        throw new Error("Cannot get blend weight for ".concat(name, " on ").concat(this.name, ". Blend2dState only accepts \'X\' or \'Y\' for getBlendWeight"));\n      }\n\n      return property === \'X\' ? this._blendValueX : this._blendValueY;\n    }\n    /**\n     * Gets and sets the x blend weight.\n     */\n\n  }, {\n    key: "blendValueX",\n    get: function get() {\n      return this._blendValueX;\n    },\n    set: function set(value) {\n      this._blendValueX = value;\n    }\n    /**\n     * Gets and sets the y blend weight.\n     */\n\n  }, {\n    key: "blendValueY",\n    get: function get() {\n      return this._blendValueY;\n    },\n    set: function set(value) {\n      this._blendValueY = value;\n    }\n    /**\n     * Gets whether or not the x blend value is currently being animated.\n     */\n\n  }, {\n    key: "blendValueXPending",\n    get: function get() {\n      return this._promises.blendValueX && this._promises.blendValueX.pending;\n    }\n    /**\n     * Gets whether or not the y blend value is currently being animated.\n     */\n\n  }, {\n    key: "blendValueYPending",\n    get: function get() {\n      return this._promises.blendValueY && this._promises.blendValueY.pending;\n    }\n  }, {\n    key: "updateInternalWeight",\n    value: function updateInternalWeight(factor) {\n      var _this3 = this;\n\n      Blend2dState_get(Blend2dState_getPrototypeOf(Blend2dState.prototype), "updateInternalWeight", this).call(this, factor);\n\n      if (this._phaseLeadState) {\n        Blend2dState_toConsumableArray(this._states.values()).forEach(function (state, index) {\n          if (state.weight !== 0 && _this3._thresholds[index].phaseMatch) {\n            state.normalizedTime = _this3._phaseLeadState.normalizedTime;\n          }\n        });\n      }\n    }\n    /**\n     * Updates the blend weights based on their corresponding threshold values\n     * and the current [x,y] blendValue. Additionally, sets a lead phase state if the\n     * conditions for phase-matching have been satisfied.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_updateBlendWeights",\n    value: function _updateBlendWeights() {\n      var _this4 = this;\n\n      if (!this._vertices || this._vertices.length === 0) return;\n\n      if (this._vertices.length === 1) {\n        Blend2dState_toConsumableArray(this._states.values())[0].weight = 1;\n        return;\n      } // Initially set all sub-state weights to zero\n\n\n      this._states.forEach(function (state) {\n        state.setWeight(0);\n      });\n\n      this._phaseLeadState = null;\n      var p = [this._blendValueX, this._blendValueY];\n\n      if (this._vertices.length === 2) {\n        this._setInfluenceClosestPointOnLine(p);\n      } else {\n        var triangle = this._triangles.find(function (triangle) {\n          return core_MathUtils.isPointInTriangle(_this4._vertices[triangle[0]], _this4._vertices[triangle[1]], _this4._vertices[triangle[2]], p);\n        });\n\n        if (triangle) {\n          this._setInfluenceTriangle(triangle, p);\n        } else {\n          this._setInfluenceClosestPointInTriangles(p);\n        }\n      }\n    }\n    /**\n     * Sets blend weights for states corresponding to a\n     * triangle of thresholds and a given [x,y] blendValues.\n     *\n     * @param {Array.<Array.<number>>} triangle - Set of triangluated indices\n     * that correspond to blend thresholds.\n     * @param {Array.<number>} p - Given [x,y] blendValue.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_setInfluenceTriangle",\n    value: function _setInfluenceTriangle(triangle, p) {\n      var areaA = core_MathUtils.triangleArea(this._vertices[triangle[1]], this._vertices[triangle[2]], p);\n      var areaB = core_MathUtils.triangleArea(this._vertices[triangle[0]], this._vertices[triangle[2]], p);\n      var areaC = core_MathUtils.triangleArea(this._vertices[triangle[0]], this._vertices[triangle[1]], p);\n      var totalArea = areaA + areaB + areaC;\n      var weightA = areaA / totalArea;\n      var weightB = areaB / totalArea;\n      var weightC = areaC / totalArea;\n      var thresholdA = this._thresholds[triangle[0]];\n      var thresholdB = this._thresholds[triangle[1]];\n      var thresholdC = this._thresholds[triangle[2]];\n\n      var stateA = this._states.get(thresholdA.name);\n\n      var stateB = this._states.get(thresholdB.name);\n\n      var stateC = this._states.get(thresholdC.name);\n\n      stateA.setWeight(weightA);\n      stateB.setWeight(weightB);\n      stateC.setWeight(weightC);\n\n      this._setPhaseLeadState([stateA, stateB, stateC], [thresholdA.phaseMatch, thresholdB.phaseMatch, thresholdC.phaseMatch]);\n    }\n    /**\n     * Determines the closest point within a triangle of\n     * thresholds based on the current [x,y] blendValues and\n     * then sets blend weights for the corresponding states.\n     *\n     * @param {Array.<number>} p - Given [x,y] blendValue.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_setInfluenceClosestPointInTriangles",\n    value: function _setInfluenceClosestPointInTriangles(p) {\n      var _this5 = this;\n\n      var globalClosestPoint = null;\n      var globalMinDist = Number.POSITIVE_INFINITY;\n      var closestTriangle = -1;\n\n      this._triangles.forEach(function (triangle, index) {\n        var pointA = core_MathUtils.closestPointOnLine(_this5._vertices[triangle[0]], _this5._vertices[triangle[1]], p);\n        var pointB = core_MathUtils.closestPointOnLine(_this5._vertices[triangle[1]], _this5._vertices[triangle[2]], p);\n        var pointC = core_MathUtils.closestPointOnLine(_this5._vertices[triangle[2]], _this5._vertices[triangle[0]], p);\n        var distA = core_MathUtils.distanceSquared(pointA, p);\n        var distB = core_MathUtils.distanceSquared(pointB, p);\n        var distC = core_MathUtils.distanceSquared(pointC, p);\n        var localClosestPoint = pointC;\n        var localMinDist = distC;\n\n        if (distA < localMinDist) {\n          localClosestPoint = pointA;\n          localMinDist = distA;\n        }\n\n        if (distB < localMinDist) {\n          localClosestPoint = pointB;\n          localMinDist = distB;\n        }\n\n        if (localMinDist < globalMinDist) {\n          globalMinDist = localMinDist;\n          globalClosestPoint = Blend2dState_toConsumableArray(localClosestPoint);\n          closestTriangle = index;\n        }\n      });\n\n      this._setInfluenceTriangle(this._triangles[closestTriangle], globalClosestPoint);\n    }\n    /**\n     * Determines the closest point on the line formed between the\n     * two blend thresholds based on the current [x,y] blendValues and\n     * then sets blend weights for the corresponding states.\n     *\n     * @param {Array.<number>} p - Given [x,y] blendValue.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_setInfluenceClosestPointOnLine",\n    value: function _setInfluenceClosestPointOnLine(p) {\n      var closestPoint = core_MathUtils.closestPointOnLine(this._vertices[[0]], this._vertices[[1]], p);\n      var distA = core_MathUtils.distanceSquared(this._vertices[0], closestPoint);\n      var distB = core_MathUtils.distanceSquared(this._vertices[1], closestPoint);\n      var weightA = distB / (distA + distB);\n      var weightB = distA / (distA + distB);\n      var thresholdA = this._thresholds[0];\n      var thresholdB = this._thresholds[1];\n\n      var stateA = this._states.get(thresholdA.name);\n\n      var stateB = this._states.get(thresholdB.name);\n\n      stateA.setWeight(weightA);\n      stateB.setWeight(weightB);\n\n      this._setPhaseLeadState([stateA, stateB], [thresholdA.phaseMatch, thresholdB.phaseMatch]);\n    }\n    /**\n     * Sets a lead phase state if the conditions\n     * for phase-matching are satisfied.\n     *\n     * @param {Array.<AbstractBlendState>} states - States to\n     * check phase-matching criteria.\n     * @param {Array.<boolean>} phaseMatched - List of phase-match booleans.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_setPhaseLeadState",\n    value: function _setPhaseLeadState(states, phaseMatched) {\n      var _this6 = this;\n\n      var max = 0;\n      states.forEach(function (state, index) {\n        if (phaseMatched[index] && state.weight > max) {\n          _this6._phaseLeadState = state;\n          max = state.weight;\n        }\n      });\n    }\n  }]);\n\n  return Blend2dState;\n}(state_AbstractBlendState);\n\n/* harmony default export */ const state_Blend2dState = (Blend2dState);\n;// CONCATENATED MODULE: ./src/core/animpack/AnimationLayer.js\nfunction AnimationLayer_typeof(obj) { "@babel/helpers - typeof"; return AnimationLayer_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, AnimationLayer_typeof(obj); }\n\nfunction AnimationLayer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AnimationLayer_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AnimationLayer_createClass(Constructor, protoProps, staticProps) { if (protoProps) AnimationLayer_defineProperties(Constructor.prototype, protoProps); if (staticProps) AnimationLayer_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction AnimationLayer_get() { if (typeof Reflect !== "undefined" && Reflect.get) { AnimationLayer_get = Reflect.get; } else { AnimationLayer_get = function _get(target, property, receiver) { var base = AnimationLayer_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return AnimationLayer_get.apply(this, arguments); }\n\nfunction AnimationLayer_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = AnimationLayer_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction AnimationLayer_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) AnimationLayer_setPrototypeOf(subClass, superClass); }\n\nfunction AnimationLayer_setPrototypeOf(o, p) { AnimationLayer_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return AnimationLayer_setPrototypeOf(o, p); }\n\nfunction AnimationLayer_createSuper(Derived) { var hasNativeReflectConstruct = AnimationLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = AnimationLayer_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = AnimationLayer_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return AnimationLayer_possibleConstructorReturn(this, result); }; }\n\nfunction AnimationLayer_possibleConstructorReturn(self, call) { if (call && (AnimationLayer_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return AnimationLayer_assertThisInitialized(self); }\n\nfunction AnimationLayer_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction AnimationLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction AnimationLayer_getPrototypeOf(o) { AnimationLayer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return AnimationLayer_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n\n\n/**\n * Enum for types of {@link AnimationLayer} blending.\n *\n * @readonly\n * @enum {string}\n */\n\nvar LayerBlendModes = {\n  Override: \'Override\',\n  Additive: \'Additive\'\n};\n/**\n * The default blending mode {@link AnimationLayer}.\n *\n * @readonly\n * @type {string}\n */\n\nvar DefaultLayerBlendMode = \'Override\';\n/**\n * Checks if a given blendMode is present in the values of {@link LayerBlendModes}.\n * If it is, return the original value, otherwise return {@link DefaultLayerBlendMode}.\n *\n * @param {string} blendMode - The name of the type of blending.\n *\n * @returns {(string|DefaultLayerBlendMode)}\n */\n\nfunction validateBlendMode(blendMode) {\n  if (Array.from(Object.values(LayerBlendModes)).includes(blendMode)) {\n    return blendMode;\n  } else {\n    return DefaultLayerBlendMode;\n  }\n}\n/**\n * Class for managing a set of animations where only one state can be active at\n * any given time.\n *\n * @implements AnimationPlayerInterface\n * @implements StateContainerInterface\n */\n\nvar AnimationLayer = /*#__PURE__*/function (_AnimationPlayerInter) {\n  AnimationLayer_inherits(AnimationLayer, _AnimationPlayerInter);\n\n  var _super = AnimationLayer_createSuper(AnimationLayer);\n\n  /**\n   * @constructor\n   *\n   * @param {Object=} options -  Options for the animation layer.\n   * @param {string} options.name - Name of the layer. Names must be unique to the\n   * animation feature that contains the layer.\n   * @param {LayerBlendModes} [options.blendMode=DefaultLayerBlendMode] -\n   * Type of blending to use for all states controlled by the layer.\n   * @param {number} [options.weight=1] - The amount of influence the layer\'s current\n   * animation has over the result for the host.\n   * @param {number} [options.transitionTime=0] - The default amount of time to use when\n   * playing and resuming animations.\n   * @param {Function=} options.easingFn - The default easing function to use when\n   * transitioning between animations and setting layer weight.\n   */\n  function AnimationLayer() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    AnimationLayer_classCallCheck(this, AnimationLayer);\n\n    _this = _super.call(this, options);\n    _this.name = options.name === undefined ? \'AnimationLayer\' : options.name;\n    _this._blendMode = Array.from(Object.values(LayerBlendModes)).includes(options.blendMode) ? options.blendMode : DefaultLayerBlendMode;\n    _this._promises = {\n      weight: core_Deferred.resolve()\n    };\n    _this._weightPaused = false;\n    _this.weight = typeof options.weight === \'number\' ? options.weight : 1;\n    _this._internalWeight = _this._weight;\n    return _this;\n  }\n  /**\n   * Gets the type of blending used for states controlled by the layer.\n   *\n   * @readonly\n   * @type {string}\n   */\n\n\n  AnimationLayer_createClass(AnimationLayer, [{\n    key: "blendMode",\n    get: function get() {\n      return this._blendMode;\n    }\n    /**\n     * Gets and sets the amount of influence the layer\'s current animation has over\n     * the result for the host.\n     *\n     * @type {number}\n     */\n\n  }, {\n    key: "weight",\n    get: function get() {\n      return this._weight;\n    }\n    /**\n     * Gets whether or not the layer\'s weight value is currently being animated.\n     *\n     * @readonly\n     * @type {boolean}\n     */\n    ,\n    set: function set(weight) {\n      this._weight = core_MathUtils.clamp(weight, 0, 1);\n    }\n  }, {\n    key: "weightPending",\n    get: function get() {\n      return this._promises.weight && this._promises.weight.pending;\n    }\n    /**\n     * Pause the current animation state and any interpolation happening on the layer\'s\n     * weight property.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "pause",\n    value: function pause() {\n      this._paused = true;\n      this._weightPaused = true;\n      return this.pauseAnimation() || this.weightPending;\n    }\n    /**\n     * Resume the current animation state and any interpolation happening on the layer\'s\n     * weight property.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "resume",\n    value: function resume() {\n      this._paused = false;\n      this._weightPaused = false;\n      var isWeightActive = this.weightPending;\n\n      if (this._currentState) {\n        return this.resumeAnimation() || isWeightActive;\n      } else {\n        return isWeightActive;\n      }\n    }\n    /**\n     * Updates the user defined weight over time.\n     *\n     * @param {number} weight - The target weight value.\n     * @param {number} [seconds=0] - The amount of time it will take to reach the\n     * target weight.\n     * @param {Function=} easingFn - The easing function to use for interpolation.\n     *\n     * @returns {Deferred}\n     */\n\n  }, {\n    key: "setWeight",\n    value: function setWeight(weight) {\n      var seconds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var easingFn = arguments.length > 2 ? arguments[2] : undefined;\n\n      if (this.weightPending) {\n        this._promises.weight.cancel();\n      }\n\n      weight = core_MathUtils.clamp(weight);\n      this._promises.weight = animpack_AnimationUtils.interpolateProperty(this, \'weight\', weight, {\n        seconds: seconds,\n        easingFn: easingFn !== undefined ? easingFn : this._easingFn\n      });\n      return this._promises.weight;\n    }\n    /**\n     * Pause any interpolation happening on the layer\'s weight property.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "pauseWeight",\n    value: function pauseWeight() {\n      this._weightPaused = true;\n      return this.weightPending;\n    }\n    /**\n     * Resume any interpolation happening on the layer\'s weight property.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "resumeWeight",\n    value: function resumeWeight() {\n      this._weightPaused = false;\n      return this.weightPending;\n    }\n    /**\n     * Multiplies the user weight by a factor to determine the internal weight.\n     *\n     * @param {number} factor - 0-1 multiplier to apply to the user weight.\n     */\n\n  }, {\n    key: "updateInternalWeight",\n    value: function updateInternalWeight(factor) {\n      this._internalWeight = this._weight * factor;\n\n      if (this._currentState) {\n        this._currentState.updateInternalWeight(this._internalWeight);\n      }\n    }\n    /**\n     * Returns the names of blend states in an animation.\n     *\n     * @param {string} animationName - Name of the animation.\n     *\n     * @returns {Array.<string>} - Names of blend states.\n     */\n\n  }, {\n    key: "getAnimationBlendNames",\n    value: function getAnimationBlendNames(animationName) {\n      var state = this.getState(animationName);\n\n      if (state === undefined) {\n        throw new Error("Cannot get blend names of animation ".concat(animationName, " on layer ").concat(this.name, ". No animation exists with this name."));\n      }\n\n      if (state instanceof state_AbstractBlendState) {\n        return state.getStateNames();\n      }\n\n      throw new Error("Cannot get blend names of animation ".concat(animationName, " on layer ").concat(this.name, ". Animation is not an instance of AbstractBlendState."));\n    }\n    /**\n     * Update the weight for a blend state of an animation.\n     *\n     * @param {string} animationName - Name of the animation containing the blend state\n     * to update.\n     * @param {string} blendName - Name of the blend state to update.\n     * @param {number} weight - Weight value to set on the animation. This number shoudld be\n     * in the 0-1 range.\n     * @param {number=} seconds - Number of seconds it should take to reach the new weight.\n     * Default is zero and will set immediately.\n     * @param {Function=} easingFn - Easing function to use while interpolating the new\n     * weight. Default is Easing.Linear.InOut.\n     *\n     * @returns {Deferred} - Promise that will resolve once the animation\'s weight reaches\n     * the target value.\n     */\n\n  }, {\n    key: "setAnimationBlendWeight",\n    value: function setAnimationBlendWeight(animationName, blendName, weight) {\n      var seconds = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var easingFn = arguments.length > 4 ? arguments[4] : undefined;\n      var state = this.getState(animationName);\n\n      if (state === undefined) {\n        throw new Error("Cannot set blend weight of animation ".concat(animationName, " on layer ").concat(this.name, ". No animation exists with this name."));\n      }\n\n      if (state instanceof state_AbstractBlendState) {\n        return state.setBlendWeight(blendName, weight, seconds, easingFn);\n      }\n\n      throw new Error("Cannot set blend weight of animation ".concat(animationName, " on layer ").concat(this.name, ". Animation is not an instance of AbstractBlendState."));\n    }\n    /**\n     * Returns the weight for a blend state of an animation.\n     *\n     * @param {string} animationName - Name of the animation containing the blend state\n     * to update.\n     * @param {string} blendName - Name of the blend state to retrieve the weight of.\n     *\n     * @returns {number} - Weight of the blend state.\n     */\n\n  }, {\n    key: "getAnimationBlendWeight",\n    value: function getAnimationBlendWeight(animationName, blendName) {\n      var state = this.getState(animationName);\n\n      if (state === undefined) {\n        throw new Error("Cannot get blend weight of animation ".concat(animationName, " on layer ").concat(this.name, ". No animation exists with this name."));\n      }\n\n      if (state instanceof state_AbstractBlendState) {\n        return state.getBlendWeight(blendName);\n      }\n\n      throw new Error("Cannot get blend weight of animation ".concat(animationName, " on layer ").concat(this.name, ". Animation is not an instance of AbstractBlendState."));\n    }\n    /**\n     * Update any weight interpolators and the current animation.\n     *\n     * @param {number} deltaTime - Time in milliseconds since the last update.\n     */\n\n  }, {\n    key: "update",\n    value: function update(deltaTime) {\n      AnimationLayer_get(AnimationLayer_getPrototypeOf(AnimationLayer.prototype), "update", this).call(this, deltaTime);\n\n      if (!this._paused && !this._weightPaused) {\n        this._promises.weight.execute(deltaTime);\n      }\n    }\n    /**\n     * Cancel any pending promises and discard states controlled by the layer.\n     */\n\n  }, {\n    key: "discard",\n    value: function discard() {\n      AnimationLayer_get(AnimationLayer_getPrototypeOf(AnimationLayer.prototype), "discard", this).call(this);\n\n      this.discardStates();\n\n      this._promises.weight.cancel();\n\n      delete this._promises;\n    }\n  }]);\n\n  return AnimationLayer;\n}(animpack_AnimationPlayerInterface.Mixin(state_StateContainerInterface.Mixin()));\n\n/* harmony default export */ const animpack_AnimationLayer = (AnimationLayer);\n;// CONCATENATED MODULE: ./src/core/animpack/state/SingleState.js\nfunction SingleState_typeof(obj) { "@babel/helpers - typeof"; return SingleState_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, SingleState_typeof(obj); }\n\nfunction SingleState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction SingleState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction SingleState_createClass(Constructor, protoProps, staticProps) { if (protoProps) SingleState_defineProperties(Constructor.prototype, protoProps); if (staticProps) SingleState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction SingleState_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) SingleState_setPrototypeOf(subClass, superClass); }\n\nfunction SingleState_setPrototypeOf(o, p) { SingleState_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return SingleState_setPrototypeOf(o, p); }\n\nfunction SingleState_createSuper(Derived) { var hasNativeReflectConstruct = SingleState_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = SingleState_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = SingleState_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return SingleState_possibleConstructorReturn(this, result); }; }\n\nfunction SingleState_possibleConstructorReturn(self, call) { if (call && (SingleState_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return SingleState_assertThisInitialized(self); }\n\nfunction SingleState_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction SingleState_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction SingleState_getPrototypeOf(o) { SingleState_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return SingleState_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n/**\n * Class for playing a single animation clip.\n *\n * @extends AbstractState\n * @alias core/SingleState\n */\n\nvar SingleState = /*#__PURE__*/function (_AbstractState) {\n  SingleState_inherits(SingleState, _AbstractState);\n\n  var _super = SingleState_createSuper(SingleState);\n\n  /**\n   * @constructor\n   *\n   * @param {Object=} options - Options for the animation state.\n   * @param {string=} options.name - Name for the animation state. Names must be\n   * unique for the layer the state is applied to.\n   * @param {weight} [options.weight=0] - The 0-1 amount of influence the state will have.\n   * @param {timeScale} [options.timeScale=1] - Factor to scale the playback speed of the\n   * animation.\n   * @param {number} [options.loopCount=Infinity] - Number of times the animation should\n   * repeat before finishing.\n   * @param {string} [options.blendMode=DefaultLayerBlendMode] - Type of\n   * blending the animation should use.\n   */\n  function SingleState() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    SingleState_classCallCheck(this, SingleState);\n\n    _this = _super.call(this, options);\n    _this._timeScale = options.timeScale !== undefined ? options.timeScale : 1;\n    _this._promises.timeScale = core_Deferred.resolve();\n    _this._loopCount = options.loopCount !== undefined ? options.loopCount : Infinity;\n    _this._blendMode = validateBlendMode(options.blendMode);\n    return _this;\n  }\n  /**\n   * Gets and sets the normalized playing time of the current animation\n   *\n   * @type {number}\n   */\n\n\n  SingleState_createClass(SingleState, [{\n    key: "normalizedTime",\n    get: function get() {\n      return 0;\n    },\n    set: function set(time) {}\n    /**\n     * Gets and sets the a factor to scale animation playback speed with.\n     *\n     * @type {number}\n     */\n\n  }, {\n    key: "timeScale",\n    get: function get() {\n      return this._timeScale;\n    },\n    set: function set(timeScale) {\n      this._timeScale = timeScale;\n    }\n    /**\n     * Gets whether or not the timeScale is currently being animated.\n     *\n     * @readonly\n     * @type {boolean}\n     */\n\n  }, {\n    key: "timeScalePending",\n    get: function get() {\n      return this._promises.timeScale.pending;\n    }\n    /**\n     * Updates the timeScale value over time.\n     *\n     * @param {number} weight - The target timeScale value.\n     * @param {number} [seconds=0] - The amount of time it will take to reach the\n     * target timeScale.\n     * @param {Function=} easingFn - The easing function to use for interpolation.\n     *\n     * @returns {Deferred}\n     */\n\n  }, {\n    key: "setTimeScale",\n    value: function setTimeScale(timeScale) {\n      var seconds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var easingFn = arguments.length > 2 ? arguments[2] : undefined;\n\n      this._promises.timeScale.cancel();\n\n      this._promises.timeScale = animpack_AnimationUtils.interpolateProperty(this, \'timeScale\', timeScale, {\n        seconds: seconds,\n        easingFn: easingFn\n      });\n      return this._promises.timeScale;\n    }\n    /**\n     * Gets and sets the number of times the animation will repeat before finishing.\n     *\n     * @type {number}\n     */\n\n  }, {\n    key: "loopCount",\n    get: function get() {\n      return this._loopCount;\n    },\n    set: function set(loopCount) {\n      this._loopCount = loopCount;\n    }\n    /**\n     * Gets the type of blending used for the animation.\n     *\n     * @readonly\n     * @type {string}\n     */\n\n  }, {\n    key: "blendMode",\n    get: function get() {\n      return this._blendMode;\n    }\n  }]);\n\n  return SingleState;\n}(state_AbstractState);\n\n/* harmony default export */ const state_SingleState = (SingleState);\n;// CONCATENATED MODULE: ./src/core/animpack/state/RandomAnimationState.js\nfunction RandomAnimationState_typeof(obj) { "@babel/helpers - typeof"; return RandomAnimationState_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, RandomAnimationState_typeof(obj); }\n\nfunction RandomAnimationState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction RandomAnimationState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction RandomAnimationState_createClass(Constructor, protoProps, staticProps) { if (protoProps) RandomAnimationState_defineProperties(Constructor.prototype, protoProps); if (staticProps) RandomAnimationState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction RandomAnimationState_get() { if (typeof Reflect !== "undefined" && Reflect.get) { RandomAnimationState_get = Reflect.get; } else { RandomAnimationState_get = function _get(target, property, receiver) { var base = RandomAnimationState_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return RandomAnimationState_get.apply(this, arguments); }\n\nfunction RandomAnimationState_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = RandomAnimationState_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction RandomAnimationState_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) RandomAnimationState_setPrototypeOf(subClass, superClass); }\n\nfunction RandomAnimationState_setPrototypeOf(o, p) { RandomAnimationState_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return RandomAnimationState_setPrototypeOf(o, p); }\n\nfunction RandomAnimationState_createSuper(Derived) { var hasNativeReflectConstruct = RandomAnimationState_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = RandomAnimationState_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = RandomAnimationState_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return RandomAnimationState_possibleConstructorReturn(this, result); }; }\n\nfunction RandomAnimationState_possibleConstructorReturn(self, call) { if (call && (RandomAnimationState_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return RandomAnimationState_assertThisInitialized(self); }\n\nfunction RandomAnimationState_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction RandomAnimationState_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction RandomAnimationState_getPrototypeOf(o) { RandomAnimationState_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return RandomAnimationState_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n/**\n * Class for playing random animations at random intervals within this state.\n *\n * @extends AbstractState\n * @implements AnimationPlayerInterface\n * @implements StateContainerInterface\n */\n\nvar RandomAnimationState = /*#__PURE__*/function (_AnimationPlayerInter) {\n  RandomAnimationState_inherits(RandomAnimationState, _AnimationPlayerInter);\n\n  var _super = RandomAnimationState_createSuper(RandomAnimationState);\n\n  /**\n   * @constructor\n   *\n   * @param {Object} [options={}] - Options for the container state.\n   * @param {number} [options.playInterval=3] - The base animation playback interval.\n   * @param {Array.<AbstractState>} [subStates=[]] - states to be randomly picked to play\n   */\n  function RandomAnimationState() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var subStates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    RandomAnimationState_classCallCheck(this, RandomAnimationState);\n\n    _this = _super.call(this, options);\n    _this._playInterval = options.playInterval ? options.playInterval : 3;\n    subStates.forEach(function (state) {\n      _this.addState(state);\n    });\n    return _this;\n  }\n  /**\n   * Gets and sets the base animation play interval\n   *\n   * @type {float}\n   */\n\n\n  RandomAnimationState_createClass(RandomAnimationState, [{\n    key: "playInterval",\n    get: function get() {\n      return this._playInterval;\n    },\n    set: function set(playInterval) {\n      this._playInterval = playInterval;\n    }\n    /**\n     * Reset the internal timer for animation play interval\n     *\n     * @private\n     */\n\n  }, {\n    key: "_resetTimer",\n    value: function _resetTimer() {\n      var _this2 = this;\n\n      var playTimer = core_Utils.getRandomFloat(this._playInterval / 4, this._playInterval * 2);\n\n      var onFinish = function onFinish() {\n        _this2.playRandomAnimation(_this2._playCallbacks.onError);\n      };\n\n      this._promises.timer = core_Utils.wait(playTimer, {\n        onFinish: onFinish\n      });\n    }\n  }, {\n    key: "updateInternalWeight",\n    value: function updateInternalWeight(factor) {\n      RandomAnimationState_get(RandomAnimationState_getPrototypeOf(RandomAnimationState.prototype), "updateInternalWeight", this).call(this, factor);\n\n      if (this._currentState) {\n        this._currentState.updateInternalWeight(this._internalWeight);\n      }\n    }\n    /**\n     * Pick a random animation and utilize AnimationPlayerInterface to play that animation\n     *\n     * @param {Function=} onError - Function to execute if the state encounters\n     * an error during playback.\n     */\n\n  }, {\n    key: "playRandomAnimation",\n    value: function playRandomAnimation(onError) {\n      this._resetTimer();\n\n      var states = this.getStateNames();\n\n      if (this._currentState) {\n        states.splice(states.indexOf(this._currentState.name), 1);\n      }\n\n      var randomState = states[core_Utils.getRandomInt(0, states.length)];\n      this.playAnimation(randomState, this._transitionTime, this._easingFn, undefined, onError, undefined);\n    }\n  }, {\n    key: "play",\n    value: function play(onFinish, onError, onCancel) {\n      this.playRandomAnimation(onError);\n      return RandomAnimationState_get(RandomAnimationState_getPrototypeOf(RandomAnimationState.prototype), "play", this).call(this, onFinish, onError, onCancel);\n    }\n  }, {\n    key: "pause",\n    value: function pause() {\n      return RandomAnimationState_get(RandomAnimationState_getPrototypeOf(RandomAnimationState.prototype), "pause", this).call(this) && this.pauseAnimation();\n    }\n  }, {\n    key: "resume",\n    value: function resume(onFinish, onError, onCancel) {\n      if (this._currentState) {\n        this.resumeAnimation(this._currentState.name, this._transitionTime, this._easingFn, undefined, onError, undefined);\n      }\n\n      return RandomAnimationState_get(RandomAnimationState_getPrototypeOf(RandomAnimationState.prototype), "resume", this).call(this, onFinish, onError, onCancel);\n    }\n  }, {\n    key: "cancel",\n    value: function cancel() {\n      return RandomAnimationState_get(RandomAnimationState_getPrototypeOf(RandomAnimationState.prototype), "cancel", this).call(this) && this.cancelAnimation();\n    }\n  }, {\n    key: "stop",\n    value: function stop() {\n      return RandomAnimationState_get(RandomAnimationState_getPrototypeOf(RandomAnimationState.prototype), "stop", this).call(this) && this.stopAnimation();\n    }\n  }, {\n    key: "discard",\n    value: function discard() {\n      RandomAnimationState_get(RandomAnimationState_getPrototypeOf(RandomAnimationState.prototype), "discard", this).call(this);\n\n      this.discardStates();\n    }\n  }]);\n\n  return RandomAnimationState;\n}(animpack_AnimationPlayerInterface.Mixin(state_StateContainerInterface.Mixin(state_AbstractState)));\n\n/* harmony default export */ const state_RandomAnimationState = (RandomAnimationState);\n;// CONCATENATED MODULE: ./src/core/animpack/AnimationFeature.js\nfunction AnimationFeature_typeof(obj) { "@babel/helpers - typeof"; return AnimationFeature_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, AnimationFeature_typeof(obj); }\n\nfunction AnimationFeature_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction AnimationFeature_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? AnimationFeature_ownKeys(Object(source), !0).forEach(function (key) { AnimationFeature_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : AnimationFeature_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction AnimationFeature_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction AnimationFeature_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AnimationFeature_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AnimationFeature_createClass(Constructor, protoProps, staticProps) { if (protoProps) AnimationFeature_defineProperties(Constructor.prototype, protoProps); if (staticProps) AnimationFeature_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction AnimationFeature_get() { if (typeof Reflect !== "undefined" && Reflect.get) { AnimationFeature_get = Reflect.get; } else { AnimationFeature_get = function _get(target, property, receiver) { var base = AnimationFeature_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return AnimationFeature_get.apply(this, arguments); }\n\nfunction AnimationFeature_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = AnimationFeature_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction AnimationFeature_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) AnimationFeature_setPrototypeOf(subClass, superClass); }\n\nfunction AnimationFeature_setPrototypeOf(o, p) { AnimationFeature_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return AnimationFeature_setPrototypeOf(o, p); }\n\nfunction AnimationFeature_createSuper(Derived) { var hasNativeReflectConstruct = AnimationFeature_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = AnimationFeature_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = AnimationFeature_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return AnimationFeature_possibleConstructorReturn(this, result); }; }\n\nfunction AnimationFeature_possibleConstructorReturn(self, call) { if (call && (AnimationFeature_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return AnimationFeature_assertThisInitialized(self); }\n\nfunction AnimationFeature_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction AnimationFeature_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction AnimationFeature_getPrototypeOf(o) { AnimationFeature_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return AnimationFeature_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n\n\n\n\n\n\n/**\n * Enum for animation state classes.\n *\n * @readonly\n * @enum {Class}\n */\n\nvar AnimationTypes = {\n  single: state_SingleState,\n  freeBlend: state_FreeBlendState,\n  queue: state_QueueState,\n  randomAnimation: state_RandomAnimationState,\n  blend1d: state_Blend1dState,\n  blend2d: state_Blend2dState\n};\n/**\n * Feature for managing animations on an object.\n *\n * @extends AbstractHostFeature\n * @alias core/AnimationFeature\n *\n * @property {Object} EVENTS - Built-in messages that the feature emits. When the\n * feature is added to a {@link core/HostObject}, event names will be prefixed by the\n * name of the feature class + \'.\'.\n * @property {string} [EVENTS.addLayer=onAddLayerEvent] - Message that is emitted after\n * [addLayer]{@link core/AnimationFeature#addLayer} has been successfully executed.\n * An object representing the name of the layer that was added and its index in\n * the layer stack with the signature {name: string, index: number} is supplied\n * as an argument to listener functions.\n * @property {string} [EVENTS.removeLayer=onRemoveLayerEvent] - Message that is\n * emitted after [removeLayer]{@link core/AnimationFeature#removeLayer} has been\n * successfully executed. An object representing the name of the layer that was\n * removed and its index in the layer stack with the signature {name: string, index: number}\n * is supplied as an argument to listener functions.\n * @property {string} [EVENTS.renameLayer=onRenameLayerEvent] - Message that is\n * emitted after [renameLayer]{@link core/AnimationFeature#renameLayer} has been\n * successfully executed. An object representing the original name of the layer\n * that was renamed and its updated name with the signature {oldName: string, newName: string}\n * is supplied as an argument to listener functions.\n * @property {string} [EVENTS.addAnimation=onAddAnimationEvent] - Message that is\n * emitted after [addAnimation]{@link core/AnimationFeature#addAnimation} has been\n * successfully executed. An object representing the name of the layer that the\n * animation was added to and the name of the animation that was added with the\n * signature {layerName: string, animationName: string} is supplied as an argument\n * to listener functions.\n * @property {string} [EVENTS.removeAnimation=onRemovedAnimationEvent] - Message\n * that is emitted after [removeAnimation]{@link core/AnimationFeature#removeAnimation}\n * has been successfully executed. An object representing the name of the layer\n * that the animation was removed from and the name of the animation that was removed\n * with the signature {layerName: string, animationName: string} is supplied as\n * an argument to listener functions.\n * @property {string} [EVENTS.renameAnimation=onRenameAnimationEvent] - Message\n * that is emitted after [renameAnimation]{@link core/AnimationFeature#renameAnimation}\n * has been successfully executed. An object representing the name of the layer\n * that contains the animation that was renamed, the original name of the animation\n * that was renamed and its updated name with the signature {layerName: string, oldName: string, newName: string}\n * is supplied as an argument to listener functions.\n * @property {string} [EVENTS.play=onPlayEvent] - Message that is emitted after\n * each call to [play]{@link core/AnimationFeature#playAnimation}. An object representing\n * the name of the layer contains the animation that was played and the name of\n * the animation that was played with the signature {layerName: string, animationName: string}\n * is supplied as an argument to listener functions.\n * @property {string} [EVENTS.pause=onPauseEvent] - Message that is emitted after\n * each call to [pause]{@link core/AnimationFeature#pauseAnimation}. An object representing\n * the name of the layer contains the animation that was paused and the name of\n * the animation that was paused with the signature {layerName: string, animationName: string}\n * is supplied as an argument to listener functions.\n * @property {string} [EVENTS.resume=onResumeEvent] - Message that is emitted after\n * each call to [resume]{@link core/AnimationFeature#resumeAnimation}. An object representing\n * the name of the layer contains the animation that was resumed and the name of\n * the animation that was resumed with the signature {layerName: string, animationName: string}\n * is supplied as an argument to listener functions.\n * @property {string} [EVENTS.interrupt=onInterruptEvent] - Message that is emitted\n * if there is a current speech in progress and [play]{@link core/AnimationFeature#playAnimation}\n * or [resume]{@link core/AnimationFeature#resumeAnimation} are executed for a new speech.\n * An object representing the name of the layer contains the animation that was\n * interrupted and the name of the animation that was interrupted with the signature\n * {layerName: string, animationName: string} is supplied as an argument to listener\n * functions.\n * @property {string} [EVENTS.stop=onStopEvent] - Message that is emitted after\n * each call to [stop]{@link core/AnimationFeature#stopAnimation} and when a speech reaches\n * the end of playback. An object representing\n * the name of the layer contains the animation that was stopped and the name of\n * the animation that was stopped with the signature {layerName: string, animationName: string}\n * is supplied as an argument to listener functions.\n */\n\nvar AnimationFeature = /*#__PURE__*/function (_AbstractHostFeature) {\n  AnimationFeature_inherits(AnimationFeature, _AbstractHostFeature);\n\n  var _super = AnimationFeature_createSuper(AnimationFeature);\n\n  /**\n   * @constructor\n   *\n   * @param {core/HostObject} host - Host object that owns the feature.\n   */\n  function AnimationFeature(host) {\n    var _this;\n\n    AnimationFeature_classCallCheck(this, AnimationFeature);\n\n    _this = _super.call(this, host);\n    _this._layers = [];\n    _this._layerMap = {};\n    _this._paused = false;\n    return _this;\n  }\n  /**\n   * Make sure a supplied layer index is within the range of layers.\n   *\n   * @private\n   *\n   * @param {number} index\n   * @param {boolean} [existing=true] - Whether the index represents and existing\n   * layer or a new layer to be added.\n   *\n   * @returns {number=}\n   */\n\n\n  AnimationFeature_createClass(AnimationFeature, [{\n    key: "_validateIndex",\n    value: function _validateIndex(index) {\n      var existing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      // Index is invalid if there are no layers and we\'re checking for an existing layer index\n      if (this._layers.length === 0 && existing) {\n        return undefined;\n      }\n\n      var lastIndex = existing ? this._layers.length - 1 : this._layers.length; // Count from the end of the array for negative indices\n\n      if (index < 0) {\n        index = lastIndex + index + 1;\n      }\n\n      if (index < 0 || index > lastIndex) {\n        return undefined;\n      } else {\n        return index;\n      }\n    }\n    /**\n     * Re-evaluate internal weight values of layers starting from the top of the\n     * stack. Override layers\' weights affect the values of all layers lower in the\n     * stack.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_updateInternalWeights",\n    value: function _updateInternalWeights() {\n      var numLayers = this._layers.length;\n      var weightMultiplier = 1; // Update internal weight values on layers in reverse order\n\n      for (var i = numLayers - 1; i >= 0; i--) {\n        var layer = this._layers[i];\n        layer.updateInternalWeight(weightMultiplier); // If the layer is override, update the multiplier with the remainder of the full weight\n\n        if (layer.blendMode === LayerBlendModes.Override && layer.currentState) {\n          weightMultiplier *= 1 - layer.currentState.internalWeight;\n        }\n      }\n    }\n    /**\n     * Return a new instance of a SingleState.\n     *\n     * @private\n     *\n     * @param {Object} options - Options to pass to the SingleState constructor.\n     * @param {string=} options.name - Name for the animation state. Names must be\n     * unique for the layer the state is applied to.\n     * @param {weight} [options.weight=0] - The 0-1 amount of influence the state will have.\n     * @param {timeScale} [options.timeScale=1] - Factor to scale the playback speed of the\n     * animation.\n     * @param {number} [options.loopCount=Infinity] - Number of times the animation should\n     * repeat before finishing.\n     * @param {string} [options.blendMode=LayerBlendModes[DefaultLayerBlendMode]] - Type of\n     * blending the animation should use.\n     *\n     * @returns {core/SingleState}\n     */\n\n  }, {\n    key: "_createSingleState",\n    value: function _createSingleState(options) {\n      return new state_SingleState(options);\n    }\n    /**\n     * Return a new instance of a FreeBlendState.\n     *\n     * @private\n     *\n     * @param {Object} options - Options to pass to the FreeBlendState constructor.\n     * @param {string=} options.name - Name for the animation state. Names must be\n     * unique for the layer the state is applied to.\n     * @param {weight} [options.weight=0] - The 0-1 amount of influence the state will have.\n     * @param {timeScale} [options.timeScale=1] - Factor to scale the playback speed of the\n     * animation.\n     * @param {number} [options.loopCount=Infinity] - Number of times the animation should\n     * repeat before finishing.\n     * @param {string} [options.blendMode=LayerBlendModes[DefaultLayerBlendMode]] - Type of\n     * blending the animation should use.\n     * @param {Array.<Object>} [options.blendStateOptions] - Array of options used to create the\n     * blend states for this container.\n     *\n     * @returns {FreeBlendState}\n     */\n\n  }, {\n    key: "_createFreeBlendState",\n    value: function _createFreeBlendState(options) {\n      var _this2 = this;\n\n      var _options$blendStateOp = options.blendStateOptions,\n          blendStateOptions = _options$blendStateOp === void 0 ? [] : _options$blendStateOp;\n      var blendStates = [];\n      blendStateOptions.forEach(function (blendOptions) {\n        blendStates.push(_this2._createSingleState(AnimationFeature_objectSpread(AnimationFeature_objectSpread({}, blendOptions), {}, {\n          blendMode: options.blendMode\n        })));\n      });\n      return new state_FreeBlendState(options, blendStates);\n    }\n    /**\n     * Return a new instance of a QueueState.\n     *\n     * @private\n     *\n     * @param {Object} options - Options to pass to the QueueState constructor.\n     * @param {string=} options.name - Name for the animation state. Names must be\n     * unique for the layer the state is applied to.\n     * @param {number} [options.weight=0] - The 0-1 amount of influence the state will have.\n     * @param {number=} options.transitionTime - The amount of time it takes to transition\n     * between queued states.\n     * @param {string} [options.blendMode=LayerBlendModes[DefaultLayerBlendMode]] - Type of\n     * blending the animation should use.\n     * @param {Array.<Object>} [options.queueOptions] - Array of options used to create the\n     * queue states for this container.\n     *\n     * @returns {QueueState}\n     */\n\n  }, {\n    key: "_createQueueState",\n    value: function _createQueueState(options) {\n      var _this3 = this;\n\n      var _options$queueOptions = options.queueOptions,\n          queueOptions = _options$queueOptions === void 0 ? [] : _options$queueOptions;\n      var queueStates = queueOptions.map(function (queueOption) {\n        return _this3._createSingleState(AnimationFeature_objectSpread(AnimationFeature_objectSpread({\n          transitionTime: options.transitionTime\n        }, queueOption), {}, {\n          blendMode: options.blendMode\n        }));\n      });\n      return new state_QueueState(options, queueStates);\n    }\n    /**\n     * Return a new instance of a Blend1dState.\n     *\n     * @private\n     *\n     * @param {Object} options - Options to pass to the Blend1dState constructor.\n     * @param {string=} options.name - Name for the animation state. Names must be\n     * unique for the layer the state is applied to.\n     * @param {weight} [options.weight=0] - The 0-1 amount of influence the state will have.\n     * @param {timeScale} [options.timeScale=1] - Factor to scale the playback speed of the\n     * animation.\n     * @param {number} [options.loopCount=Infinity] - Number of times the animation should\n     * repeat before finishing.\n     * @param {string} [options.blendMode=LayerBlendModes[DefaultLayerBlendMode]] - Type of\n     * blending the animation should use.\n     * @param {Array.<Object>} [options.blendStateOptions] - Array of options used to create the\n     * blend states for this container.\n     * @param {Array.<number>} [options.blendThresholds] - Array of numbers used to set the\n     * thresholds for each blend state in this container.\n     * @param {Array.<boolean>} [options.blendMatchPhases=[]] - Optional array of booleans used to\n     * set whether or not each blend state in this container will match phases.\n     *\n     * @returns {Blend1dState}\n     */\n\n  }, {\n    key: "_createBlend1dState",\n    value: function _createBlend1dState(options) {\n      var _this4 = this;\n\n      var _options$blendStateOp2 = options.blendStateOptions,\n          blendStateOptions = _options$blendStateOp2 === void 0 ? [] : _options$blendStateOp2;\n      var _options$blendThresho = options.blendThresholds,\n          blendThresholds = _options$blendThresho === void 0 ? [] : _options$blendThresho;\n      var _options$blendMatchPh = options.blendMatchPhases,\n          blendMatchPhases = _options$blendMatchPh === void 0 ? [] : _options$blendMatchPh;\n      var blendStates = [];\n      blendStateOptions.forEach(function (blendOptions) {\n        blendStates.push(_this4._createSingleState(AnimationFeature_objectSpread(AnimationFeature_objectSpread({}, blendOptions), {}, {\n          blendMode: options.blendMode\n        })));\n      });\n      return new state_Blend1dState(options, blendStates, blendThresholds, blendMatchPhases);\n    }\n    /**\n     * Return a new instance of a Blend2dState.\n     *\n     * @private\n     *\n     * @param {Object} options - Options to pass to the Blend1dState constructor.\n     * @param {string=} options.name - Name for the animation state. Names must be\n     * unique for the layer the state is applied to.\n     * @param {weight} [options.weight=0] - The 0-1 amount of influence the state will have.\n     * @param {timeScale} [options.timeScale=1] - Factor to scale the playback speed of the\n     * animation.\n     * @param {number} [options.loopCount=Infinity] - Number of times the animation should\n     * repeat before finishing.\n     * @param {string} [options.blendMode=LayerBlendModes[DefaultLayerBlendMode]] - Type of\n     * blending the animation should use.\n     * @param {Array.<Object>} [options.blendStateOptions] - Array of options used to create the\n     * blend states for this container.\n     * @param {Array.<Array.<number>>} [options.blendThresholds] - Array of Array of numbers used to set the\n     * thresholds for each blend state in this container.\n     * @param {Array.<boolean>} [options.blendMatchPhases=[]] - Optional array of booleans used to\n     * set whether or not each blend state in this container will match phases.\n     *\n     * @returns {Blend1dState}\n     */\n\n  }, {\n    key: "_createBlend2dState",\n    value: function _createBlend2dState(options) {\n      var _this5 = this;\n\n      var _options$blendStateOp3 = options.blendStateOptions,\n          blendStateOptions = _options$blendStateOp3 === void 0 ? [] : _options$blendStateOp3;\n      var _options$blendThresho2 = options.blendThresholds,\n          blendThresholds = _options$blendThresho2 === void 0 ? [] : _options$blendThresho2;\n      var _options$blendMatchPh2 = options.blendMatchPhases,\n          blendMatchPhases = _options$blendMatchPh2 === void 0 ? [] : _options$blendMatchPh2;\n      var blendStates = [];\n      blendStateOptions.forEach(function (blendOptions) {\n        blendStates.push(_this5._createSingleState(AnimationFeature_objectSpread(AnimationFeature_objectSpread({}, blendOptions), {}, {\n          blendMode: options.blendMode\n        })));\n      });\n      return new state_Blend2dState(options, blendStates, blendThresholds, blendMatchPhases);\n    }\n    /**\n     * Return a new instance of a RandomAnimationState.\n     *\n     * @private\n     *\n     * @param {Object} options - Options to pass to the RandomAnimationState constructor.\n     * @param {string=} options.name - Name for the animation state. Names must be\n     * unique for the layer the state is applied to.\n     * @param {number} [options.playInterval=3] - The base animation playback interval.\n     * @param {Array.<Object>} [options.subStateOptions] - Array of options used to create the\n     * sub states for this container.\n     *\n     * @returns {RandomAnimationState}\n     */\n\n  }, {\n    key: "_createRandomAnimationState",\n    value: function _createRandomAnimationState(options) {\n      var _this6 = this;\n\n      var _options$subStateOpti = options.subStateOptions,\n          subStateOptions = _options$subStateOpti === void 0 ? [] : _options$subStateOpti;\n      var subStates = [];\n      subStateOptions.forEach(function (subStateOptions) {\n        subStates.push(_this6._createSingleState(AnimationFeature_objectSpread(AnimationFeature_objectSpread({}, subStateOptions), {}, {\n          blendMode: options.blendMode\n        })));\n      });\n      return new state_RandomAnimationState(options, subStates);\n    }\n    /**\n     * Make sure the layer with the given name exists and return a unique version\n     * of the animation name supplied for that layer.\n     *\n     * @private\n     *\n     * @param {string} layerName - Name of the layer to check against.\n     * @param {string} animationName - Name of the animation to validate.\n     *\n     * @returns {string} Validated animation name.\n     */\n\n  }, {\n    key: "_validateNewAnimation",\n    value: function _validateNewAnimation(layerName, animationName) {\n      // Make sure the layerName is valid\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Cannot add animation to layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      } // Make sure the animationName is unique\n\n\n      var name = core_Utils.getUniqueName(animationName, layer.getStateNames());\n\n      if (name !== animationName) {\n        console.warn("Animation name ".concat(animationName, " is not unique for layer ").concat(layer.name, ". Animation will be renamed to ").concat(name, "."));\n      }\n\n      return name;\n    }\n    /**\n     * Gets whether or not all animations are paused.\n     *\n     * @readonly\n     * @type {boolean}\n     */\n\n  }, {\n    key: "paused",\n    get: function get() {\n      return this._paused;\n    }\n    /**\n     * Gets an array of names of animation layers.\n     *\n     * @readonly\n     * @type {Array.<string>}\n     */\n\n  }, {\n    key: "layers",\n    get: function get() {\n      return this._layers.map(function (layer) {\n        return layer.name;\n      });\n    }\n    /**\n     * Create and store a new animation layer.\n     *\n     * @param {string} [name=\'NewLayer\'] - Name for the layer.\n     * @param {Object} [options={}] - Options to pass to {@link AnimationLayer#constructor}\n     * @param {index=} index - Index to insert the new layer at. If none is provided\n     * it will be added to the end of the stack.\n     *\n     * @returns {number} Index of the new layer.\n     */\n\n  }, {\n    key: "addLayer",\n    value: function addLayer() {\n      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \'NewLayer\';\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var index = arguments.length > 2 ? arguments[2] : undefined;\n      var numLayers = this._layers.length;\n      var layerIndex = index; // Make sure the given index is within the range of layers\n\n      if (index === undefined || index === -1) {\n        layerIndex = this._layers.length;\n      } else {\n        layerIndex = this._validateIndex(index, false);\n\n        if (layerIndex === undefined) {\n          // Insert at the beginning if the user passed in a negative index\n          if (index < 0) {\n            layerIndex = 0;\n          } // Otherwise append to the end\n          else {\n            layerIndex = this._layers.length;\n          }\n\n          console.warn("Index ".concat(index, " is invalid for host ").concat(this._host.id, ". New layer will be added at the closest valid index: ").concat(layerIndex, "."));\n        }\n      } // Make sure the layer name is unique\n\n\n      var layerName = core_Utils.getUniqueName(name, Object.keys(this._layerMap));\n\n      if (name !== layerName) {\n        console.warn("Layer name ".concat(name, " is not unique. New layer will be added with the name ").concat(layerName, "."));\n      }\n\n      var layer = new animpack_AnimationLayer(AnimationFeature_objectSpread(AnimationFeature_objectSpread({}, options), {}, {\n        name: layerName\n      }));\n      this._layerMap[layerName] = layer;\n\n      if (layerIndex === numLayers) {\n        this._layers.push(layer);\n      } else {\n        this._layers.splice(layerIndex, 0, layer);\n      } // Notify that a layer has been added to the feature\n\n\n      var eventData = {\n        name: layerName,\n        index: layerIndex\n      };\n      this.emit(this.constructor.EVENTS.addLayer, eventData);\n      return eventData;\n    }\n    /**\n     * Remove an animation layer from the stack. Animations on this layer will no\n     * longer be evaluated.\n     *\n     * @param {string} name - Name for the layer to remove.\n     *\n     * @returns {boolean} Whether or not removal was successful.\n     */\n\n  }, {\n    key: "removeLayer",\n    value: function removeLayer(name) {\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        console.warn("Did not remove layer ".concat(name, " from host ").concat(this._host.id, ". No layer exists with this name."));\n        return false;\n      }\n\n      layer.discard();\n\n      var index = this._layers.indexOf(layer);\n\n      this._layers.splice(index, 1);\n\n      delete this._layerMap[name]; // Notify that a layer has been removed from the feature\n\n      this.emit(this.constructor.EVENTS.removeLayer, {\n        name: name,\n        index: index\n      });\n      return true;\n    }\n    /**\n     * Re-order the layer stack so that the layer with the given name is positioned\n     * at the given index.\n     *\n     * @param {string} name - Name of the layer to move.\n     * @param {number} index - New index to position the layer at.\n     *\n     * @returns {number} The new index of the layer\n     */\n\n  }, {\n    key: "moveLayer",\n    value: function moveLayer(name, index) {\n      // Make sure the name is valid\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        throw new Error("Cannot move layer ".concat(name, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      } // Make sure the index falls in the range of existing layers\n\n\n      var layerIndex = this._validateIndex(index, true);\n\n      var lastIndex = this._layers.length - 1;\n\n      if (layerIndex === undefined) {\n        throw new Error("Cannot move layer ".concat(name, " from host ").concat(this._host.id, " to index ").concat(index, ". Index must be in the 0 - ").concat(lastIndex, " range."));\n      }\n\n      var currentIndex = this._layers.indexOf(layer);\n\n      if (currentIndex === layerIndex) {\n        return;\n      } // Remove from the current position\n\n\n      this._layers.splice(currentIndex, 1); // Insert at the new position\n\n\n      if (layerIndex === lastIndex) {\n        this._layers.push(layer);\n      } else {\n        this._layers.splice(layerIndex, 0, layer);\n      }\n\n      return layerIndex;\n    }\n    /**\n     * Update the name of a layer. Names must be unique, if the new name is not\n     * unique it will have trailing numbers appended until it is unique.\n     *\n     * @param {string} currentName - Current name of the layer.\n     * @param {string} newName - New name to set on the layer.\n     *\n     * @returns {string} The new name of the layer\n     */\n\n  }, {\n    key: "renameLayer",\n    value: function renameLayer(currentName, newName) {\n      // Make sure the name is valid\n      var layer = this._layerMap[currentName];\n\n      if (layer === undefined) {\n        throw new Error("Cannot rename layer ".concat(currentName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      } // Make sure the layer name is unique\n\n\n      var name = core_Utils.getUniqueName(newName, Object.keys(this._layerMap));\n\n      if (name !== newName) {\n        console.warn("Layer name ".concat(newName, " is not unique. Layer will be renamed to ").concat(name, "."));\n      }\n\n      delete this._layerMap[currentName];\n      this._layerMap[name] = layer;\n      layer.name = name; // Notify that a layer has been renamed on the feature\n\n      this.emit(this.constructor.EVENTS.renameLayer, {\n        oldName: currentName,\n        newName: name\n      });\n      return name;\n    }\n    /**\n     * Return the weight of an animation layer.\n     *\n     * @param {string} name - Name of the layer to return weight from.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: "getLayerWeight",\n    value: function getLayerWeight(name) {\n      // Make sure the name is valid\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        throw new Error("Cannot get weight on layer ".concat(name, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      return layer.weight;\n    }\n    /**\n     * Update the weight of an animation layer.\n     *\n     * @param {string} name - The name of the layer to update.\n     * @param {number} weight - The weight value to set on the layer. This number\n     * should be in the 0-1 range.\n     * @param {number=} seconds - The number of seconds it should take to reach the\n     * new weight. Default is zero and will set immediately.\n     * @param {Function=} easingFn - The easing function to use while interpolating\n     * the weight. Default is Easing.Linear.InOut.\n     *\n     * @returns {Deferred} A promise that will resolve once the layer\'s weight reaches\n     * the target value.\n     */\n\n  }, {\n    key: "setLayerWeight",\n    value: function setLayerWeight(name, weight, seconds, easingFn) {\n      // Make sure the name is valid\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        var e = "Cannot set weight on layer ".concat(name, " from host ").concat(this._host.id, ". No layer exists with this name.");\n        return core_Deferred.reject(e);\n      }\n\n      return layer.setWeight(weight, seconds, easingFn);\n    }\n    /**\n     * Returns the names of blend states in an animation in a layer.\n     *\n     * @param {string} layerName - Name of the layer containing the animation containing\n     * the blend state to update.\n     * @param {string} animationName - Name of the animation containing the blend state\n     * to update.\n     *\n     * @returns {Array.<string>} - Names of blend states.\n     */\n\n  }, {\n    key: "getAnimationBlendNames",\n    value: function getAnimationBlendNames(layerName, animationName) {\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Cannot get blend names on layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      return layer.getAnimationBlendNames(animationName);\n    }\n    /**\n     * Update the weight for a blend state in an animation in a layer.\n     *\n     * @param {string} layerName - Name of the layer containing the animation containing\n     * the blend state to update.\n     * @param {string} animationName - Name of the animation containing the blend state\n     * to update.\n     * @param {string} blendName - Name of the blend state to update.\n     * @param {number} weight - Weight value to set on the animation. This number shoudld be\n     * in the 0-1 range.\n     * @param {number=} seconds - Number of seconds it should take to reach the new weight.\n     * Default is zero and will set immediately.\n     * @param {Function=} easingFn - Easing function to use while interpolating the new\n     * weight. Default is Easing.Linear.InOut.\n     *\n     * @returns {Deferred} - Promise that will resolve once the animation\'s weight reaches\n     * the target value.\n     */\n\n  }, {\n    key: "setAnimationBlendWeight",\n    value: function setAnimationBlendWeight(layerName, animationName, blendName, weight, seconds, easingFn) {\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        var e = "Cannot set blend weight on layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name.");\n        return core_Deferred.reject(e);\n      }\n\n      return layer.setAnimationBlendWeight(animationName, blendName, weight, seconds, easingFn);\n    }\n    /**\n     * Returns the weight for a blend state in an animation in a layer.\n     *\n     * @param {string} layerName - Name of the layer containing the animation containing\n     * the blend state to update.\n     * @param {string} animationName - Name of the animation containing the blend state\n     * to update.\n     * @param {string} blendName - Name of the blend state to update.\n     *\n     * @returns {number} - Weight of the blend state.\n     */\n\n  }, {\n    key: "getAnimationBlendWeight",\n    value: function getAnimationBlendWeight(layerName, animationName, blendName) {\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Cannot get blend weight on layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      return layer.getAnimationBlendWeight(animationName, blendName);\n    }\n    /**\n     * Pause weight interpolation animation on a layer with the given name.\n     *\n     * @param {string} name - Name of the layer to pause.\n     *\n     * @returns {boolean} - Whether or not there was an existing interpolation to pause.\n     */\n\n  }, {\n    key: "pauseLayerWeight",\n    value: function pauseLayerWeight(name) {\n      // Make sure the name is valid\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        throw new Error("Cannot pause weight interpolation on layer ".concat(name, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      return layer.pauseWeight();\n    }\n    /**\n     * Resume weight interpolation animation on a layer with the given name.\n     *\n     * @param {string} name - Name of the layer to resume.\n     *\n     * @returns {Deferred} - Resolves once the layer\'s weight reaches its target value.\n     */\n\n  }, {\n    key: "resumeLayerWeight",\n    value: function resumeLayerWeight(name) {\n      // Make sure the name is valid\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        var e = "Cannot resume weight interpolation on layer ".concat(name, " from host ").concat(this._host.id, ". No layer exists with this name.");\n        return core_Deferred.reject(e);\n      }\n\n      return layer.resumeWeight();\n    }\n    /**\n     * Pause current animation and weight interpolation animation on a layer with\n     * the given name.\n     *\n     * @param {string} name - Name of the layer to pause.\n     *\n     * @returns {boolean} - Whether or not there was an existing interpolation or\n     * current animation to pause.\n     */\n\n  }, {\n    key: "pauseLayer",\n    value: function pauseLayer(name) {\n      // Make sure the name is valid\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        throw new Error("Cannot pause layer ".concat(name, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      return layer.pause();\n    }\n    /**\n     * Resume current animation and weight interpolation animation on a layer with\n     * the given name.\n     *\n     * @param {string} name - Name of the layer to resume.\n     *\n     * @returns {Deferred} - Resolves once the layer\'s weight reaches its target value\n     * and it\'s current animation finishes playing.\n     */\n\n  }, {\n    key: "resumeLayer",\n    value: function resumeLayer(name) {\n      // Make sure the name is valid\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        var e = "Cannot resume layer ".concat(name, " from host ").concat(this._host.id, ". No layer exists with this name.");\n        return core_Deferred.reject(e);\n      }\n\n      return layer.resume();\n    }\n    /**\n     * Return whether or not the animation layer with the given name is currently\n     * transitioning between animations.\n     *\n     * @param {string} layerName - Name of the layer to check.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "getTransitioning",\n    value: function getTransitioning(layerName) {\n      // Make sure the layerName is valid\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Get transitioning on layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      return layer.isTransitioning;\n    }\n    /**\n     * Return an array of the names of all states the layer with the given name controls.\n     *\n     * @param {string} layerName - Name of the layer to search.\n     *\n     * @returns {Array.<string>}\n     */\n\n  }, {\n    key: "getAnimations",\n    value: function getAnimations(layerName) {\n      // Make sure the layerName is valid\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Get animations on layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      return layer.getStateNames();\n    }\n    /**\n     * Return the name of the state currently active on the layer with the given name.\n     * Return null if there is no current animation for the layer.\n     *\n     * @param {string} layerName - Name of the layer.\n     *\n     * @returns {(string|null)}\n     */\n\n  }, {\n    key: "getCurrentAnimation",\n    value: function getCurrentAnimation(layerName) {\n      // Make sure the layerName is valid\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Get current animation on layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      return layer.currentAnimation;\n    }\n    /**\n     * Return whether or not a layer with the given name is currently playing an\n     * animation and that animation is paused.\n     *\n     * @param {string} layerName - Name of the layer.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "getPaused",\n    value: function getPaused(layerName) {\n      // Make sure the layerName is valid\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Get paused on layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      return layer.currentState && layer.currentState.paused;\n    }\n    /**\n     * Return the type name of the given animation. @see AnimationTypes.\n     *\n     * @param {string} layerName - Name of the layer that contains the animation.\n     * @param {string} animationName - Name of the animation to check.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: "getAnimationType",\n    value: function getAnimationType(layerName, animationName) {\n      // Make sure the layerName is valid\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Get animation type on layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      var state = layer.getState(animationName);\n\n      if (state === undefined) {\n        throw new Error("Get animation type for animation ".concat(animationName, " on layer ").concat(layerName, " from host ").concat(this._host.id, ". No animation exists with this name."));\n      }\n\n      var constructor = state.constructor;\n      return Object.keys(AnimationTypes).find(function (typeName) {\n        return AnimationTypes[typeName] === constructor;\n      });\n    }\n    /**\n     * Add a new animation to an animation layer.\n     *\n     * @param {string} layerName - Name of the layer to add the animation to.\n     * @param {string} animationName - Name to use when calling the animation.\n     * @param {Object=} options - Options to pass to the constructor for the new\n     * SingleState animation.\n     *\n     * @returns {string} - The name of the animation that was added\n     */\n\n  }, {\n    key: "addAnimation",\n    value: function addAnimation(layerName, animationName) {\n      var animationType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : AnimationTypes.single;\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      options.name = this._validateNewAnimation(layerName, animationName); // Make sure the animation type is valid\n\n      if (!Object.values(AnimationTypes).includes(animationType)) {\n        throw new Error("Cannot add animation ".concat(animationName, " to layer ").concat(layerName, " on host ").concat(this._host.id, ". Invalid animation type."));\n      }\n\n      var layer = this._layerMap[layerName];\n      options.blendMode = layer.blendMode;\n      options.transitionTime = layer.transitionTime;\n      var state = this["_create".concat(animationType.name)](options);\n      var name = layer.addState(state); // Notify that an animation has been added to the feature\n\n      this.emit(this.constructor.EVENTS.addAnimation, {\n        layerName: layerName,\n        animationName: name\n      });\n      return name;\n    }\n    /**\n     * Remove an animation from an animation layer.\n     *\n     * @param {string} layerName - Name of the layer to remove the animation from.\n     * @param {string} name - Name of the animation to remove.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "removeAnimation",\n    value: function removeAnimation(layerName, animationName) {\n      // Make sure the name is valid\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Cannot remove animation from layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      var removed = layer.removeState(animationName); // Notify that an animation has been removed from the feature\n\n      if (removed === true) {\n        this.emit(this.constructor.EVENTS.removeAnimation, {\n          layerName: layerName,\n          animationName: animationName\n        });\n      }\n\n      return removed;\n    }\n    /**\n     * Update the name of an animation. Names must be unique on each layer, if the new\n     * name is not unique it will have trailing numbers appended until it is unique.\n     *\n     * @param {string} layerName - Name of the layer that contains the animation that\n     * will be renamed,\n     * @param {string} currentAnimationName - Current name of the animation.\n     * @param {string} newAnimationName - New name to set on the animation.\n     *\n     * @returns {string} - The new name of the animation\n     */\n\n  }, {\n    key: "renameAnimation",\n    value: function renameAnimation(layerName, currentAnimationName, newAnimationName) {\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Cannot rename animation ".concat(currentAnimationName, " on layer ").concat(layerName, " for host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      var name = layer.renameState(currentAnimationName, newAnimationName); // Notify that an animation has been renamed on the feature\n\n      this.emit(this.constructor.EVENTS.renameAnimation, {\n        layerName: layerName,\n        oldName: currentAnimationName,\n        newName: name\n      });\n      return name;\n    }\n    /**\n     * Pause the currently playing animation and play a new animation from the beginning.\n     *\n     * @param {string} layerName - Name of the layer that contains the animation.\n     * @param {string} animationName - Name of the animation state to play.\n     * @param {number=} seconds - The number of seconds it should take to transition\n     * to the new animation. Default is zero and will set immediately.\n     * @param {Function=} easingFn - The easing function to use while transitioning\n     * between animations. Default is Easing.Linear.InOut.\n     *\n     * @returns {Deferred} - Resolves once the animation reaches the end of its\n     * timeline. Looping animations can only resolve if they are interrupted or\n     * manually stopped.\n     */\n\n  }, {\n    key: "playAnimation",\n    value: function playAnimation(layerName, animationName, seconds, easingFn) {\n      var _this7 = this;\n\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        var e = "Cannot play animation ".concat(animationName, " on layer ").concat(layerName, " for host ").concat(this._host.id, ". No layer exists with this name.");\n        return core_Deferred.reject(e);\n      } // Notify that a new animation has begun\n\n\n      this.emit(this.constructor.EVENTS.playAnimation, {\n        layerName: layerName,\n        animationName: animationName\n      });\n      return layer.playAnimation(animationName, seconds, easingFn, function () {\n        // Notify that an animation has stopped\n        _this7.emit(_this7.constructor.EVENTS.stopAnimation, {\n          layerName: layerName,\n          animationName: animationName\n        });\n      }, undefined, function () {\n        // Notify that an animation has been interrupted\n        _this7.emit(_this7.constructor.EVENTS.interruptAnimation, {\n          layerName: layerName,\n          animationName: animationName\n        });\n      }, function (_ref) {\n        var name = _ref.name,\n            canAdvance = _ref.canAdvance,\n            isQueueEnd = _ref.isQueueEnd;\n\n        if (layer.currentAnimation === animationName) {\n          // Notify that a new animation has begun\n          _this7.emit(_this7.constructor.EVENTS.playNextAnimation, {\n            layerName: layerName,\n            animationName: animationName,\n            nextQueuedAnimation: name,\n            canAdvance: canAdvance,\n            isQueueEnd: isQueueEnd\n          });\n        }\n      });\n    }\n    /**\n     * Play the next animation in the queue of a QueueState animation.\n     *\n     * @param {string} layerName - Name of the layer that contains the queue animation.\n     * @param {string=} animationName - Name of the animation queue animation. Defaults\n     * to the name of the current animation for the layer.\n     * @param {number=} seconds - The number of seconds it should take to transition\n     * to the queue animation if it\'s not already currently playing. Default is zero\n     * and will set immediately.\n     * @param {Function=} easingFn - The easing function to use while transitioning\n     * to the queue animation if it isn\'t already playing. Default is Easing.Linear.InOut.\n     *\n     * @returns {Deferred} - Resolves once the last animation in the queue finishes\n     * playing.\n     */\n\n  }, {\n    key: "playNextAnimation",\n    value: function playNextAnimation(layerName, animationName, transitionTime, easingFn) {\n      var _this8 = this;\n\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        var e = "Cannot play next animation on layer ".concat(layerName, " for host ").concat(this._host.id, ". No layer exists with this name.");\n        return core_Deferred.reject(e);\n      }\n\n      if (animationName === undefined) {\n        animationName = layer.currentAnimation;\n      }\n\n      var animation = layer.getState(layer.currentAnimation);\n\n      if (animation === null) {\n        var _e = "Cannot play next animation on layer ".concat(layerName, " for host ").concat(this._host.id, ". No animation exists with name ").concat(animationName, ".");\n\n        return core_Deferred.reject(_e);\n      } else if (this.getAnimationType(layerName, animationName) !== \'queue\') {\n        var _e2 = "Cannot play next animation on layer ".concat(layerName, " for host ").concat(this._host.id, ". ").concat(animationName, " is not a queue state.");\n\n        return core_Deferred.reject(_e2);\n      }\n\n      var onNext = function onNext(_ref2) {\n        var name = _ref2.name,\n            canAdvance = _ref2.canAdvance,\n            isQueueEnd = _ref2.isQueueEnd;\n\n        if (layer.currentAnimation === animationName) {\n          // Notify that a new animation has begun\n          _this8.emit(_this8.constructor.EVENTS.playNextAnimation, {\n            layerName: layerName,\n            animationName: animationName,\n            nextQueuedAnimation: name,\n            canAdvance: canAdvance,\n            isQueueEnd: isQueueEnd\n          });\n        }\n      }; // Make the queue animation current if it wasn\'t already\n\n\n      if (layer.currentAnimation === null) {\n        layer.resumeAnimation(animation.name, transitionTime, easingFn, undefined, undefined, undefined, onNext);\n      }\n\n      return animation.next(onNext, true);\n    }\n    /**\n     * Pause the current animation on a layer.\n     *\n     * @param {string} name - Name of the layer to pause.\n     *\n     * @returns {boolean} Whether or not an animation was successfully paused.\n     */\n\n  }, {\n    key: "pauseAnimation",\n    value: function pauseAnimation(name) {\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        console.warn("Did not pause animation on layer ".concat(name, " for host ").concat(this._host.id, ". No layer exists with this name."));\n        return false;\n      }\n\n      var paused = layer.pauseAnimation(); // Notify that an animation was paused\n\n      if (paused) {\n        var animationName = layer.currentAnimation;\n        this.emit(this.constructor.EVENTS.pauseAnimation, {\n          layerName: name,\n          animationName: animationName\n        });\n      }\n\n      return paused;\n    }\n    /**\n     * Pause the currently playing animation and play a new animation from where it\n     * last left off.\n     *\n     * @param {string} layerName - Name of the layer that contains the animation.\n     * @param {string=} animationName - Name of the animation state to resume. Defaults\n     * to the name of the current animation for the layer.\n     * @param {number=} seconds - The number of seconds it should take to transition\n     * to the new animation. Default is zero and will set immediately.\n     * @param {Function=} easingFn - The easing function to use while transitioning\n     * between animations. Default is Easing.Linear.InOut.\n     *\n     * @returns {Deferred} - Resolves once the animation reaches the end of its\n     * timeline. Looping animations can only resolve if they are interrupted or\n     * manually stopped.\n     */\n\n  }, {\n    key: "resumeAnimation",\n    value: function resumeAnimation(layerName, animationName, seconds, easingFn) {\n      var _this9 = this;\n\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        var e = "Cannot resume animation ".concat(animationName, " on layer ").concat(layerName, " for host ").concat(this._host.id, ". No layer exists with this name.");\n        return core_Deferred.reject(e);\n      } // Notify that an animation was resumed\n\n\n      this.emit(this.constructor.EVENTS.resumeAnimation, {\n        layerName: layerName,\n        animationName: animationName\n      });\n      return layer.resumeAnimation(animationName, seconds, easingFn, function () {\n        // Notify that an animation has stopped\n        _this9.emit(_this9.constructor.EVENTS.stopAnimation, {\n          layerName: layerName,\n          animationName: animationName\n        });\n      }, undefined, function () {\n        // Notify that an animation has been interrupted\n        _this9.emit(_this9.constructor.EVENTS.interruptAnimation, {\n          layerName: layerName,\n          animationName: animationName\n        });\n      }, function (_ref3) {\n        var name = _ref3.name,\n            canAdvance = _ref3.canAdvance,\n            isQueueEnd = _ref3.isQueueEnd;\n\n        if (layer.currentAnimation === animationName) {\n          // Notify that a new animation has begun\n          _this9.emit(_this9.constructor.EVENTS.playNextAnimation, {\n            layerName: layerName,\n            animationName: animationName,\n            nextQueuedAnimation: name,\n            canAdvance: canAdvance,\n            isQueueEnd: isQueueEnd\n          });\n        }\n      });\n    }\n    /**\n     * Stop the current animation on a layer. Stop rewinds the animation to the\n     * beginning and prevents it from progressing forward.\n     *\n     * @param {string} name - Name of the layer that contains the animation.\n     *\n     * @returns {boolean} Whether or not an animation was successfully stopped.\n     */\n\n  }, {\n    key: "stopAnimation",\n    value: function stopAnimation(name) {\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        console.warn("Did not stop animation on layer ".concat(name, " for host ").concat(this._host.id, ". No layer exists with this name."));\n        return false;\n      }\n\n      return layer.stopAnimation();\n    }\n    /**\n     * Pause current animation and weight interpolation animation on all layers.\n      * @returns {boolean} - Whether or not there was an existing interpolation or\n     * current animations to pause.\n     */\n\n  }, {\n    key: "pause",\n    value: function pause() {\n      this._paused = true;\n      var paused = false;\n\n      this._layers.forEach(function (l) {\n        if (l.pause()) {\n          paused = true;\n        }\n      });\n\n      return paused;\n    }\n    /**\n     * Resume current animation and weight interpolation animation on all layers.\n      * @returns {boolean} - Whether or not there was an existing interpolation or\n     * current animations to resume.\n     */\n\n  }, {\n    key: "resume",\n    value: function resume() {\n      this._paused = false;\n      var resumed = false;\n\n      this._layers.forEach(function (l) {\n        if (l.resume()) {\n          resumed = true;\n        }\n      });\n\n      return resumed;\n    }\n    /**\n     * Adds a namespace to the host with the name of the feature to contain properties\n     * and methods from the feature that users of the host need access to.\n     *\n     * @see AnimationFeature\n     */\n\n  }, {\n    key: "installApi",\n    value: function installApi() {\n      var _this10 = this;\n\n      /**\n       * @inner\n       * @namespace AnimationFeature\n       */\n      var api = AnimationFeature_get(AnimationFeature_getPrototypeOf(AnimationFeature.prototype), "installApi", this).call(this);\n\n      Object.defineProperties(api, {\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @see core/AnimationFeature#paused\n         */\n        paused: {\n          get: function get() {\n            return _this10.paused;\n          }\n        },\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @see core/AnimationFeature#layers\n         */\n        layers: {\n          get: function get() {\n            return _this10.layers;\n          }\n        }\n      });\n      Object.assign(api, {\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#addLayer\n         */\n        addLayer: this.addLayer.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#removeLayer\n         */\n        removeLayer: this.removeLayer.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#moveLayer\n         */\n        moveLayer: this.moveLayer.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#renameLayer\n         */\n        renameLayer: this.renameLayer.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#getLayerWeight\n         */\n        getLayerWeight: this.getLayerWeight.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#setLayerWeight\n         */\n        setLayerWeight: this.setLayerWeight.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#pauseLayerWeight\n         */\n        pauseLayerWeight: this.pauseLayerWeight.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#resumeLayerWeight\n         */\n        resumeLayerWeight: this.resumeLayerWeight.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#pauseLayer\n         */\n        pauseLayer: this.pauseLayer.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#resumeLayer\n         */\n        resumeLayer: this.resumeLayer.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#getTransitioning\n         */\n        getTransitioning: this.getTransitioning.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#getAnimations\n         */\n        getAnimations: this.getAnimations.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#getCurrentAnimation\n         */\n        getCurrentAnimation: this.getCurrentAnimation.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#getPaused\n         */\n        getPaused: this.getPaused.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#getAnimationType\n         */\n        getAnimationType: this.getAnimationType.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#addAnimation\n         */\n        addAnimation: this.addAnimation.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#removeAnimation\n         */\n        removeAnimation: this.removeAnimation.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#renameAnimation\n         */\n        renameAnimation: this.renameAnimation.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#getAnimationBlendNames\n         */\n        getAnimationBlendNames: this.getAnimationBlendNames.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#getAnimationBlendWeight\n         */\n        getAnimationBlendWeight: this.getAnimationBlendWeight.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#setAnimationBlendWeight\n         */\n        setAnimationBlendWeight: this.setAnimationBlendWeight.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#playAnimation\n         */\n        playAnimation: this.playAnimation.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#playNextAnimation\n         */\n        playNextAnimation: this.playNextAnimation.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#pauseAnimation\n         */\n        pauseAnimation: this.pauseAnimation.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#resumeAnimation\n         */\n        resumeAnimation: this.resumeAnimation.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#stopAnimation\n         */\n        stopAnimation: this.stopAnimation.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#pause\n         */\n        pause: this.pause.bind(this),\n\n        /**\n         * @memberof AnimationFeature\n         * @instance\n         * @method\n         * @see core/AnimationFeature#resume\n         */\n        resume: this.resume.bind(this)\n      });\n    }\n    /**\n     * Update each animation layer.\n     *\n     * @param {number} deltaTime - Time since the last update.\n     */\n\n  }, {\n    key: "update",\n    value: function update(deltaTime) {\n      if (!this._layers.length) {\n        return;\n      }\n\n      if (this._paused) {\n        deltaTime = 0;\n      } // Re-evaluate internal weights for layers\n\n\n      this._updateInternalWeights(); // Update layers\n\n\n      this._layers.forEach(function (layer) {\n        layer.update(deltaTime);\n      });\n\n      AnimationFeature_get(AnimationFeature_getPrototypeOf(AnimationFeature.prototype), "update", this).call(this, deltaTime);\n    }\n  }, {\n    key: "discard",\n    value: function discard() {\n      this._layers.forEach(function (layer) {\n        layer.discard();\n      });\n\n      delete this._layers;\n      delete this._layerMap;\n\n      AnimationFeature_get(AnimationFeature_getPrototypeOf(AnimationFeature.prototype), "discard", this).call(this);\n    }\n  }]);\n\n  return AnimationFeature;\n}(core_AbstractHostFeature);\n\nObject.defineProperty(AnimationFeature, \'EVENTS\', {\n  value: AnimationFeature_objectSpread(AnimationFeature_objectSpread({}, Object.getPrototypeOf(core_AbstractHostFeature).EVENTS), {}, {\n    addLayer: \'onAddLayerEvent\',\n    removeLayer: \'onRemoveLayerEvent\',\n    renameLayer: \'onRenameLayerEvent\',\n    addAnimation: \'onAddAnimationEvent\',\n    removeAnimation: \'onRemovedAnimationEvent\',\n    renameAnimation: \'onRenameAnimationEvent\',\n    playAnimation: \'onPlayEvent\',\n    playNextAnimation: \'onNextEvent\',\n    pauseAnimation: \'onPauseEvent\',\n    resumeAnimation: \'onResumeEvent\',\n    interruptAnimation: \'onInterruptEvent\',\n    stopAnimation: \'onStopEvent\'\n  })\n});\n/* harmony default export */ const animpack_AnimationFeature = (AnimationFeature);\n;// CONCATENATED MODULE: ./src/core/PointOfInterestFeature.js\nfunction PointOfInterestFeature_typeof(obj) { "@babel/helpers - typeof"; return PointOfInterestFeature_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, PointOfInterestFeature_typeof(obj); }\n\nfunction PointOfInterestFeature_slicedToArray(arr, i) { return PointOfInterestFeature_arrayWithHoles(arr) || PointOfInterestFeature_iterableToArrayLimit(arr, i) || PointOfInterestFeature_unsupportedIterableToArray(arr, i) || PointOfInterestFeature_nonIterableRest(); }\n\nfunction PointOfInterestFeature_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction PointOfInterestFeature_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction PointOfInterestFeature_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction PointOfInterestFeature_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction PointOfInterestFeature_toConsumableArray(arr) { return PointOfInterestFeature_arrayWithoutHoles(arr) || PointOfInterestFeature_iterableToArray(arr) || PointOfInterestFeature_unsupportedIterableToArray(arr) || PointOfInterestFeature_nonIterableSpread(); }\n\nfunction PointOfInterestFeature_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction PointOfInterestFeature_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return PointOfInterestFeature_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return PointOfInterestFeature_arrayLikeToArray(o, minLen); }\n\nfunction PointOfInterestFeature_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction PointOfInterestFeature_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return PointOfInterestFeature_arrayLikeToArray(arr); }\n\nfunction PointOfInterestFeature_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction PointOfInterestFeature_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction PointOfInterestFeature_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction PointOfInterestFeature_createClass(Constructor, protoProps, staticProps) { if (protoProps) PointOfInterestFeature_defineProperties(Constructor.prototype, protoProps); if (staticProps) PointOfInterestFeature_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction PointOfInterestFeature_get() { if (typeof Reflect !== "undefined" && Reflect.get) { PointOfInterestFeature_get = Reflect.get; } else { PointOfInterestFeature_get = function _get(target, property, receiver) { var base = PointOfInterestFeature_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return PointOfInterestFeature_get.apply(this, arguments); }\n\nfunction PointOfInterestFeature_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = PointOfInterestFeature_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction PointOfInterestFeature_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) PointOfInterestFeature_setPrototypeOf(subClass, superClass); }\n\nfunction PointOfInterestFeature_setPrototypeOf(o, p) { PointOfInterestFeature_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return PointOfInterestFeature_setPrototypeOf(o, p); }\n\nfunction PointOfInterestFeature_createSuper(Derived) { var hasNativeReflectConstruct = PointOfInterestFeature_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = PointOfInterestFeature_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = PointOfInterestFeature_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return PointOfInterestFeature_possibleConstructorReturn(this, result); }; }\n\nfunction PointOfInterestFeature_possibleConstructorReturn(self, call) { if (call && (PointOfInterestFeature_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return PointOfInterestFeature_assertThisInitialized(self); }\n\nfunction PointOfInterestFeature_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction PointOfInterestFeature_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction PointOfInterestFeature_getPrototypeOf(o) { PointOfInterestFeature_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return PointOfInterestFeature_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable no-underscore-dangle */\n\n/* eslint-disable no-unused-vars */\n\n\n\n\n\n\n\n/**\n * Enum for axis directions.\n *\n * @readonly\n * @enum {Class}\n */\n\nvar AxisMap = {\n  PositiveX: [1, 0, 0],\n  NegativeX: [-1, 0, 0],\n  PositiveY: [0, 1, 0],\n  NegativeY: [0, -1, 0],\n  PositiveZ: [0, 0, 1],\n  NegativeZ: [0, 0, -1]\n};\nvar FaceTargetTypes = {\n  EyeCenter: 0,\n  EyeLeft: 1,\n  EyeRight: 2,\n  Mouth: 3\n}; // Average distance between pupils is .064m, golden ratio says that the distance\n// from center of the pupils to the center of the mouth should be about the same.\n\nvar FaceVectors = [[0, 0, 0], [-0.032, 0, 0], [0.032, 0, 0], [0, -0.064, 0]]; // Time ranges to use when choosing a new random wait time between saccades\n\nvar MicroSaccadeWaitRanges = {\n  "default": [0.8, 1.75],\n  postMacro: [0.6, 1.3125]\n};\nvar MacroSaccadeWaitRanges = {\n  "default": [5.0, 8.0],\n  mouthTarget: [0.2, 0.75],\n  // Look away from a mouth target the fastest\n  eyeTarget: [1.5, 4.0]\n}; // Minimum angle in degrees the eye direction must change to trigger a blink animation\n\nvar BlinkThreshold = 35; // Maximum number of milliseconds to use for calculating look speed\n\nvar MaxDelta = 100 / 3;\n/**\n * PointOfInterest controls the gaze direction of the host. Given one or more\n * animations of type Blend2dState, it calculates the angles between the lookTracker\n * object (generally a joint in the host\'s skeleton) and the lookTarget (the object\n * the host should look at) and drives the managed Blend2dStates\' X and Y blend\n * values using the result. You can optionally add saccadic movement to any managed\n * animation to help make the host\'s eyes appear alive when focused on the same\n * point for exteded periods of time. If blink animations are specified, a blink\n * will be played during large changes in gaze direction.\n *\n * @extends AbstractHostFeature\n * @alias core/PointOfInterestFeature\n * @implements SSMLSpeechmarkInterface\n * @implements ManagedAnimationLayerInterface\n */\n\nvar PointOfInterestFeature = /*#__PURE__*/function (_AbstractHostFeature$) {\n  PointOfInterestFeature_inherits(PointOfInterestFeature, _AbstractHostFeature$);\n\n  var _super = PointOfInterestFeature_createSuper(PointOfInterestFeature);\n\n  /**\n   * @constructor\n   *\n   * @param {core/HostObject} host - Host that owns the feature.\n   * @param {Object=} options - Options for the feature.\n   * @param {Object=} target - 3D transformation node that the host should try to\n   * look at.\n   * @param {Object} options.lookTracker - 3D transformation node that represents\n   * the direction the host is currently looking during animation.\n   * @param {Object=} options.scene - Engine-specific scene object that contains\n   * the host. This object must be defined if using \'setTargetByName\' or \'SetTargetById\'\n   * methods.\n   * @param {Object=} lookOptions - Options for the look animation layers.\n   * @param {number} [lookOptions.blendTime=0.1] - Default amount of time it will\n   * take to manipulate the weights of the look layers.\n   * @param {number} [lookOptions.easingFn=Quadratic.InOut] - Default easing function\n   * to use when manipulating look layer weights.\n   * @param {Array.<Object>} [lookOptions.layers=[]] - An array of layer options\n   * objects to register as look layers.\n   * @param {Object=} blinkOptions - Options for the blink animation layers.\n   * @param {number} [blinkOptions.blendTime=0.075] - Default amount of time it\n   * will take to manipulate the weights of the blink layers.\n   * @param {number} [blinkOptions.easingFn=Quadratic.InOut] - Default easing function\n   * to use when manipulating blink layer weights.\n   * @param {Array.<Object>} [blinkOptions.layers=[]] - An array of layer options\n   * objects to register as blink layers.\n   */\n  function PointOfInterestFeature(host) {\n    var _this;\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        target = _ref.target,\n        lookTracker = _ref.lookTracker,\n        scene = _ref.scene;\n\n    var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref2$blendTime = _ref2.blendTime,\n        lookBlendTime = _ref2$blendTime === void 0 ? 0.1 : _ref2$blendTime,\n        _ref2$easingFn = _ref2.easingFn,\n        lookEasingFn = _ref2$easingFn === void 0 ? Quadratic.InOut : _ref2$easingFn,\n        _ref2$layers = _ref2.layers,\n        lookLayers = _ref2$layers === void 0 ? [] : _ref2$layers;\n\n    var _ref3 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n        _ref3$blendTime = _ref3.blendTime,\n        blinkBlendTime = _ref3$blendTime === void 0 ? 0.075 : _ref3$blendTime,\n        _ref3$easingFn = _ref3.easingFn,\n        blinkEasingFn = _ref3$easingFn === void 0 ? Quadratic.InOut : _ref3$easingFn,\n        _ref3$layers = _ref3.layers,\n        blinkLayers = _ref3$layers === void 0 ? [] : _ref3$layers;\n\n    PointOfInterestFeature_classCallCheck(this, PointOfInterestFeature);\n\n    _this = _super.call(this, host);\n\n    if (!_this.constructor._validateTransformObject(lookTracker)) {\n      throw new Error("Cannot initialize PointOfInterestFeature on host ".concat(_this._host.id, ". LookTracker must be defined as a valid transformation object."));\n    }\n\n    _this._lookTracker = lookTracker;\n    _this._scene = scene;\n    _this._target = target || null;\n    _this._prevTargetPos = [0, 0, 0];\n    _this._isTargetMoving = false;\n    _this._lookLayers = _this._lookLayers || {};\n    _this._trackingConfigs = _this._trackingConfigs || [];\n    _this._blinkLayers = _this._blinkLayers || {}; // Register the look layers\n\n    lookLayers.forEach(function (_ref4) {\n      var name = _ref4.name,\n          animation = _ref4.animation,\n          maxSpeed = _ref4.maxSpeed,\n          reference = _ref4.reference,\n          forwardAxis = _ref4.forwardAxis,\n          hasSaccade = _ref4.hasSaccade,\n          blendTime = _ref4.blendTime,\n          easingFn = _ref4.easingFn;\n\n      _this.registerLookLayer(name, {\n        animation: animation,\n        maxSpeed: maxSpeed,\n        reference: reference,\n        forwardAxis: forwardAxis,\n        hasSaccade: hasSaccade,\n        blendTime: blendTime !== undefined ? blendTime : lookBlendTime,\n        easingFn: easingFn !== undefined ? easingFn : lookEasingFn\n      });\n    }); // Register the blink layers\n\n    blinkLayers.forEach(function (_ref5) {\n      var name = _ref5.name,\n          animation = _ref5.animation,\n          blendTime = _ref5.blendTime,\n          easingFn = _ref5.easingFn;\n\n      _this.registerBlinkLayer(name, {\n        animation: animation,\n        blendTime: blendTime !== undefined ? blendTime : blinkBlendTime,\n        easingFn: easingFn !== undefined ? easingFn : blinkEasingFn\n      });\n    });\n    return _this;\n  }\n  /**\n   * Gets and sets the target object the host should look at.\n   *\n   * @type {Object|null}\n   */\n\n\n  PointOfInterestFeature_createClass(PointOfInterestFeature, [{\n    key: "target",\n    get: function get() {\n      return this._target;\n    },\n    set: function set(target) {\n      this._target = target || null;\n    }\n    /**\n     * Return a vector representing the global position of an object. Should be\n     * overloaded for each rendering engine implementation.\n     *\n     * @private\n     *\n     * @param {any} _obj - Engine-specific 3D transform object.\n     *\n     * @returns {Array.<number>} - An array consisting of three numbers representing\n     * x, y and z coordinates.\n     */\n\n  }, {\n    key: "_onLayerAdded",\n    value: function _onLayerAdded(_ref6) {\n      var name = _ref6.name;\n      this._lookLayers = this._lookLayers || {};\n      this._blinkLayers = this._blinkLayers || {};\n\n      PointOfInterestFeature_get(PointOfInterestFeature_getPrototypeOf(PointOfInterestFeature.prototype), "_onLayerAdded", this).call(this, {\n        name: name\n      }); // Validate the look animation\n\n\n      if (this._lookLayers[name] !== undefined) {\n        this._registerLookAnimation(name, this._lookLayers[name]);\n      }\n    }\n  }, {\n    key: "_onAnimationAdded",\n    value: function _onAnimationAdded(_ref7) {\n      var layerName = _ref7.layerName,\n          animationName = _ref7.animationName;\n      this._lookLayers = this._lookLayers || {};\n      this._blinkLayers = this._blinkLayers || {};\n\n      PointOfInterestFeature_get(PointOfInterestFeature_getPrototypeOf(PointOfInterestFeature.prototype), "_onAnimationAdded", this).call(this, {\n        layerName: layerName\n      }); // Validate the look animation\n\n\n      if (this._lookLayers[layerName] === animationName) {\n        this._registerLookAnimation(layerName, animationName);\n      }\n    }\n    /**\n     * Ensure that registered look animations are Blend2dStates.\n     *\n     * @private\n     *\n     * @param {string} layerName - Name of the layer that contains the look animation.\n     * @param {string} animationName - Name of the animation.\n     */\n\n  }, {\n    key: "_registerLookAnimation",\n    value: function _registerLookAnimation(layerName, animationName) {\n      if (this._managedLayers[layerName].animations[animationName].isActive) {\n        if (AnimationTypes[this._host.AnimationFeature.getAnimationType(layerName, animationName)] !== AnimationTypes.blend2d) {\n          // Warn and deactivate if the registered state is not blend2d\n          console.warn("Cannot register Point of Interest look animation ".concat(animationName, " on layer ").concat(layerName, " for host ").concat(this._host.id, ". Look animations must be of type \'blend2d\'."));\n          this._managedLayers[layerName].animations[animationName].isActive = false;\n        }\n      }\n    }\n    /**\n     * Check if the given object is not of an engine-specific type. Should\n     * be overloaded for each rendering engine implementation.\n     *\n     * @private\n     *\n     * @param {any} obj - Object to validate.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "_addTrackingConfig",\n    value:\n    /**\n     * Check if the given configuration object has already been stored as a tracking\n     * config. If it has, return the stored configuration. Otherwise, store and\n     * return it.\n     *\n     * @private\n     *\n     * @param {Object} config - Object containing tracker, reference and forwardAxis\n     * properties.\n     *\n     * @returns {Object}\n     */\n    function _addTrackingConfig(config) {\n      var trackingConfig = this._trackingConfigs.find(function (c) {\n        return c.reference === config.reference && c.forwardAxis === config.forwardAxis;\n      });\n\n      if (trackingConfig) {\n        return trackingConfig;\n      } else {\n        config.angles = {\n          h: 0,\n          v: 0\n        };\n        config.prevAngles = {\n          h: 0,\n          v: 0\n        };\n\n        this._trackingConfigs.push(config);\n\n        return config;\n      }\n    }\n    /**\n     * Return the distance between the look tracker and the look target.\n     *\n     * @private\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: "_getTargetDistance",\n    value: function _getTargetDistance() {\n      // Find the vector between the global positions of tracker and target\n      var sourcePosition = this.constructor._getWorldPosition(this._lookTracker);\n\n      var targetPosition = this.constructor._getWorldPosition(this._target);\n\n      var lookVector = [targetPosition[0] - sourcePosition[0], targetPosition[1] - sourcePosition[1], targetPosition[2] - sourcePosition[2]];\n      return core_MathUtils.getVectorMagnitude(lookVector);\n    }\n    /**\n     * Reset all stored tracking angles to 0.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_resetLookAngles",\n    value: function _resetLookAngles() {\n      this._trackingConfigs.forEach(function (_ref8) {\n        var angles = _ref8.angles;\n        angles.h = 0;\n        angles.v = 0;\n      });\n    }\n    /**\n     * Store the difference in horizontal and vertical rotation for the tracker\'s\n     * reference rotation and the direction of the target from the tracker.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_setLookAngles",\n    value: function _setLookAngles() {\n      var _this2 = this;\n\n      // Get the current positions of the tracker and target objects\n      var targetPos = this.constructor._getWorldPosition(this._target);\n\n      var trackerPos = this.constructor._getWorldPosition(this._lookTracker); // Check if the target has moved\n\n\n      this._isTargetMoving = core_MathUtils.getVectorMagnitude([targetPos[0] - this._prevTargetPos[0], targetPos[1] - this._prevTargetPos[1], targetPos[2] - this._prevTargetPos[2]]) > 0;\n      Object.assign(this._prevTargetPos, targetPos); // Calculate the horizontal and vertical angles to rotate to the target\n\n      var targetSpherical = core_MathUtils.cartesianToSpherical(targetPos[0] - trackerPos[0], targetPos[1] - trackerPos[1], targetPos[2] - trackerPos[2]);\n\n      var targetAngles = this.constructor._sphericalToBlendValue(targetSpherical[1], targetSpherical[2]); // Calculate angles relative to the reference objects\n\n\n      this._trackingConfigs.forEach(function (_ref9) {\n        var reference = _ref9.reference,\n            forwardAxis = _ref9.forwardAxis,\n            angles = _ref9.angles;\n\n        // Calculate the horizontal and vertical angles to rotate to the direction of the tracker\n        var refDirection = _this2.constructor._getObjectDirection(reference, forwardAxis);\n\n        var refSpherical = core_MathUtils.cartesianToSpherical.apply(core_MathUtils, PointOfInterestFeature_toConsumableArray(refDirection));\n\n        var refAngles = _this2.constructor._sphericalToBlendValue(refSpherical[1], refSpherical[2]); // Store the difference\n\n\n        angles.h = targetAngles.h - refAngles.h;\n        angles.v = targetAngles.v - refAngles.v;\n      });\n    }\n    /**\n     * Return the horizontal and vertical angles it would require to simulate looking\n     * at the given type of face target\n     *\n     * @private\n     *\n     * @param {number} targetType - Integer representing the FaceTargetType.\n     *\n     * @returns {Object}- An object with signature {r: number, h: number, v: number}\n     * where \'r\' represents radius, h represents the horizontal/azimuthal angle and\n     * v represents the vertical/polar angle.\n     */\n\n  }, {\n    key: "_getFaceTargetAngles",\n    value: function _getFaceTargetAngles(targetType) {\n      // No offset when the target is the center of the eyes\n      if (targetType === 0) {\n        return {\n          h: 0,\n          v: 0\n        };\n      } // Build a vector to the face target type using the current distance to the target\n\n\n      var distance = this._getTargetDistance(this._lookTracker);\n\n      var faceVector = PointOfInterestFeature_toConsumableArray(FaceVectors[targetType]);\n\n      faceVector[2] = distance;\n      var spherical = core_MathUtils.cartesianToSpherical.apply(core_MathUtils, PointOfInterestFeature_toConsumableArray(faceVector)); // Make sure values are clamped within the range of motion of the human eye, in case the target is very close\n\n      var blendValues = this.constructor._sphericalToBlendValue(spherical[1], spherical[2]);\n\n      blendValues.h = core_MathUtils.clamp(blendValues.h, -35, 35);\n      blendValues.v = core_MathUtils.clamp(blendValues.v, -25, 30);\n      return blendValues;\n    }\n    /**\n     * Updated the stored speed and duration variables for a layer based on the\n     * change in horizontal and vertical angles of the tracker.\n     *\n     * @private\n     *\n     * @param {string} layerName - Name of the layer to store values on.\n     * @param {number} h - Change in horizontal angle, in degrees.\n     * @param {number} v - Change in vertical angle, in degrees.\n     */\n\n  }, {\n    key: "_updateLayerSpeed",\n    value: function _updateLayerSpeed(layerName, h, v) {\n      var layer = this._managedLayers[layerName]; // From "Realistic Avatar and head Animation Using a Neurobiological Model of Visual Attention", Itti, Dhavale, Pighin\n\n      layer.maxHSpeed = 473 * (1 - Math.exp(-h / 7.8));\n      layer.maxVSpeed = 473 * (1 - Math.exp(-v / 7.8)); // From "Eyes Alive", Lee, Badler\n\n      var D0 = 0.025;\n      var d = 0.00235;\n      layer.hDuration = D0 + d * h;\n      layer.vDuration = D0 + d * v;\n    }\n    /**\n     * Set the microSaccade object with new randomized values.\n     *\n     * @private\n     *\n     * @param {string} layerName - Name of the layer that owns the saccade motion.\n     */\n\n  }, {\n    key: "_setMicroSaccade",\n    value: function _setMicroSaccade(layerName) {\n      var layer = this._managedLayers[layerName];\n      var microSaccade = layer.microSaccade;\n\n      if (this._target) {\n        // Micro movements should be smaller when focused on a target\n        microSaccade.h = core_Utils.getRandomFloat(0.01, 0.15);\n        microSaccade.v = core_Utils.getRandomFloat(0.01, 0.15);\n      } else {\n        // Microsaccades. Encyclopedia of Neuroscience. (2009) Springer, Berlin, Heidelberg. https://doi.org/10.1007/978-3-540-29678-2_3492\n        microSaccade.h = core_Utils.getRandomFloat(0.01, 0.3);\n        microSaccade.v = core_Utils.getRandomFloat(0.01, 0.3);\n      }\n\n      this._updateLayerSpeed(layerName, microSaccade.h, microSaccade.v); // Restart the timer\n\n\n      this._initializeMicroTimer.apply(this, [layerName].concat(PointOfInterestFeature_toConsumableArray(MicroSaccadeWaitRanges["default"])));\n    }\n    /**\n     * Set the macroSaccade object with new randomized values.\n     *\n     * @private\n     *\n     * @param {string} layerName - Name of the layer that owns the saccade motion.\n     */\n\n  }, {\n    key: "_setMacroSaccade",\n    value: function _setMacroSaccade(layerName) {\n      var layer = this._managedLayers[layerName];\n      var macroSaccade = layer.macroSaccade;\n      var macroSaccadeWaitRange; // Increase random value range when not focused on a target\n\n      if (!this._target) {\n        macroSaccadeWaitRange = MacroSaccadeWaitRanges["default"]; // Normal human horizontal eye rotation limit is about 35 degrees\n\n        var hLimit = core_Utils.getRandomFloat(0.143, 0.286);\n        var hFactor = core_Utils.getRandomFloat(-hLimit, hLimit);\n        macroSaccade.h = hFactor * 35; // Normal human vertical eye rotation limit is about 25 degrees upward and 30 degrees downward\n\n        var vLimit = core_Utils.getRandomFloat(0.093, 0.186);\n        var vFactor = core_Utils.getRandomFloat(-vLimit, vLimit);\n        macroSaccade.v = vFactor > 0 ? vFactor * 25 : vFactor * 30;\n      } // Pick a new face target\n      else {\n        // Social triangle - saccade between eyes and mouth, weighted to look at eyes more often\n        switch (layer.saccadeTarget) {\n          case 1:\n            macroSaccadeWaitRange = MacroSaccadeWaitRanges.eyeTarget;\n            layer.saccadeTarget = Math.random() < 0.75 ? FaceTargetTypes.EyeRight : FaceTargetTypes.Mouth;\n            break;\n\n          case 2:\n            macroSaccadeWaitRange = MacroSaccadeWaitRanges.eyeTarget;\n            layer.saccadeTarget = Math.random() < 0.75 ? FaceTargetTypes.EyeLeft : FaceTargetTypes.Mouth;\n            break;\n\n          case 3:\n            macroSaccadeWaitRange = MacroSaccadeWaitRanges.mouthTarget;\n            layer.saccadeTarget = Math.random() < 0.5 ? FaceTargetTypes.EyeLeft : FaceTargetTypes.EyeRight;\n            break;\n\n          case 0:\n          default:\n            macroSaccadeWaitRange = MacroSaccadeWaitRanges.eyeTarget;\n            layer.saccadeTarget = Math.random() < 0.5 ? FaceTargetTypes.EyeLeft : FaceTargetTypes.EyeRight;\n            break;\n        }\n\n        var _this$_getFaceTargetA = this._getFaceTargetAngles(layer.saccadeTarget),\n            h = _this$_getFaceTargetA.h,\n            v = _this$_getFaceTargetA.v;\n\n        macroSaccade.h = h;\n        macroSaccade.v = v;\n      }\n\n      this._updateLayerSpeed(layerName, macroSaccade.h, macroSaccade.v); // Restart the timers\n\n\n      this._initializeMicroTimer.apply(this, [layerName].concat(PointOfInterestFeature_toConsumableArray(MicroSaccadeWaitRanges.postMacro)));\n\n      this._initializeMacroTimer.apply(this, [layerName].concat(PointOfInterestFeature_toConsumableArray(macroSaccadeWaitRange)));\n    }\n    /**\n     * Start a new wait timer that will set a new micro saccade movement when it\n     * resolves.\n     *\n     * @private\n     *\n     * @param {string} layerName - Name of the layer that owns the saccade motion.\n     * @param {number} minWaitTime - Minimum number of seconds before a new saccade\n     * will be triggered.\n     * @param {number} maxWaitTime - Maximum number of seconds before a new saccade\n     * will be triggered.\n     */\n\n  }, {\n    key: "_initializeMicroTimer",\n    value: function _initializeMicroTimer(layerName, minWaitTime, maxWaitTime) {\n      var _this3 = this;\n\n      var layer = this._managedLayers[layerName];\n      var waitTime = core_Utils.getRandomFloat(minWaitTime, maxWaitTime);\n\n      if (layer.microSaccadeTimer) {\n        layer.microSaccadeTimer.cancel();\n      }\n\n      layer.microSaccadeTimer = core_Utils.wait(waitTime, {\n        onFinish: function onFinish() {\n          _this3._setMicroSaccade(layerName);\n        }\n      });\n    }\n    /**\n     * Start a new wait timer that will set a new macro saccade movement when it\n     * resolves.\n     *\n     * @private\n     *\n     * @param {string} layerName - Name of the layer that owns the saccade motion.\n     * @param {number} minWaitTime - Minimum number of seconds before a new saccade\n     * will be triggered.\n     * @param {number} maxWaitTime - Maximum number of seconds before a new saccade\n     * will be triggered.\n     */\n\n  }, {\n    key: "_initializeMacroTimer",\n    value: function _initializeMacroTimer(layerName, minWaitTime, maxWaitTime) {\n      var _this4 = this;\n\n      var layer = this._managedLayers[layerName];\n      var waitTime = core_Utils.getRandomFloat(minWaitTime, maxWaitTime);\n\n      if (layer.macroSaccadeTimer) {\n        layer.macroSaccadeTimer.cancel();\n      }\n\n      layer.macroSaccadeTimer = core_Utils.wait(waitTime, {\n        onFinish: function onFinish() {\n          _this4._setMacroSaccade(layerName);\n        }\n      });\n    }\n    /**\n     * Sets a new target to look at.\n     *\n     * @param {Object|null} target - The new target to look at.\n     */\n\n  }, {\n    key: "setTarget",\n    value: function setTarget(target) {\n      this.target = target;\n    }\n    /**\n     * Finds an object given its name and sets it as the new target to look at.\n     * Should be overloaded for each rendering engine implementation.\n     *\n     * @param {string} target - Name to search for.\n     */\n\n  }, {\n    key: "setTargetByName",\n    value: function setTargetByName(name) {\n      if (!name) {\n        this._target = null;\n      }\n\n      if (!this._scene) {\n        throw new Error("Cannot set PointOfInterestFeature target using name ".concat(name, " on host ").concat(this._host.id, ". Scene must be defined."));\n      }\n    }\n    /**\n     * Finds an object given its id and sets it as the new target to look at.\n     * Should be overloaded for each rendering engine implementation.\n     *\n     * @param {string|number} target - Id to search for.\n     */\n\n  }, {\n    key: "setTargetById",\n    value: function setTargetById(id) {\n      if (!id) {\n        this._target = null;\n      }\n\n      if (!this._scene) {\n        throw new Error("Cannot set PointOfInterestFeature target using id ".concat(id, " on host ").concat(this._host.id, ". Scene must be defined."));\n      }\n    }\n    /**\n     * Start keeping track of an animation layer that owns a blend2d animation with\n     * blendWeights corresponding to horizontal and vertical look angles.\n     *\n     * @param {string} layerName - Name of the layer to keep track of.\n     * @param {Object=} options - Options for the layer.\n     * @param {string} [options.animation = \'look\'] - Name of the animation on the\n     * layer whose blendWeights will be driven based on the angle between the lookTracker\n     * and the lookTarget. This animation must be of type blend2d.\n     * @param {number} [options.maxSpeed = 25] - The maximum speed at which the blend2d\n     * blendWeights can be manipulated.\n     * @param {string} [options.forwardAxis = \'PositiveZ\'] - Axis pointing from the\n     * front of the lookReference object. Valid options are \'PositiveX\', \'NegativeX\',\n     * \'PositiveY\', \'NegativeY\', \'PositiveZ\', \'NegativeZ\'.\n     * @param {Object=} options.lookReference - 3D transformation node that the lookTracker\n     * rotation limits should be calculated relative to. Defaults to the host owner.\n     * @param {number} [options.hasSaccade = false] - Whether or not to include\n     * saccadic motion onto the blendWeight animation. This should only be set to\n     * true for blend2d animations representing eye animation.\n     * @param {number=} [options.blendTime=[PointOfInterestFeature.DEFAULT_LAYER_OPTIONS.blendTime]{@link PointOfInterestFeature#DEFAULT_LAYER_OPTIONS#blendTime}] -\n     * Default amount of time to use when manipulating layer weight.\n     * @param {Function=} options.easingFn - Default easing function to use when\n     * manipulating layer weight.\n     */\n\n  }, {\n    key: "registerLookLayer",\n    value: function registerLookLayer(layerName) {\n      var _ref10 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref10$animation = _ref10.animation,\n          animation = _ref10$animation === void 0 ? \'look\' : _ref10$animation,\n          _ref10$maxSpeed = _ref10.maxSpeed,\n          maxSpeed = _ref10$maxSpeed === void 0 ? 25 : _ref10$maxSpeed,\n          reference = _ref10.reference,\n          _ref10$forwardAxis = _ref10.forwardAxis,\n          forwardAxis = _ref10$forwardAxis === void 0 ? \'PositiveZ\' : _ref10$forwardAxis,\n          _ref10$hasSaccade = _ref10.hasSaccade,\n          hasSaccade = _ref10$hasSaccade === void 0 ? false : _ref10$hasSaccade,\n          _ref10$blendTime = _ref10.blendTime,\n          blendTime = _ref10$blendTime === void 0 ? PointOfInterestFeature.DEFAULT_LAYER_OPTIONS.blendTime : _ref10$blendTime,\n          easingFn = _ref10.easingFn;\n\n      // Validate reference object\n      reference = reference || this._host.owner;\n\n      if (!this.constructor._validateTransformObject(reference)) {\n        throw new Error("Cannot initialize register look layer ".concat(layerName, " for PointOfInterestFeature on host ").concat(this._host.id, ". Reference must be defined as a valid transformation object."));\n      } // Find vector associated with axis string\n\n\n      forwardAxis = AxisMap[forwardAxis] !== undefined ? AxisMap[forwardAxis] : AxisMap.PositiveZ; // Store tracking configuration\n\n      var trackingConfig = this._addTrackingConfig({\n        reference: reference,\n        forwardAxis: forwardAxis\n      }); // Register the layer and animation\n\n\n      this.registerLayer(layerName, {\n        trackingConfig: trackingConfig,\n        maxSpeed: maxSpeed,\n        maxHSpeed: undefined,\n        maxVSpeed: undefined,\n        hDuration: undefined,\n        vDuration: undefined,\n        hVelocity: [0, 0],\n        vVelocity: [0, 0],\n        hasSaccade: hasSaccade,\n        blendTime: blendTime,\n        easingFn: easingFn,\n        microSaccade: {\n          h: 0,\n          v: 0\n        },\n        macroSaccade: {\n          h: 0,\n          v: 0\n        },\n        saccadeTarget: FaceTargetTypes.EyeCenter,\n        animations: PointOfInterestFeature_defineProperty({}, animation, {})\n      });\n      this._lookLayers[layerName] = animation; // Validate the look animation\n\n      this._registerLookAnimation(layerName, animation); // Initialize saccade timers\n\n\n      if (hasSaccade) {\n        var macroSaccadeWaitRange = this._target ? MacroSaccadeWaitRanges.eyeTarget : MacroSaccadeWaitRanges["default"];\n\n        this._initializeMicroTimer.apply(this, [layerName].concat(PointOfInterestFeature_toConsumableArray(MicroSaccadeWaitRanges["default"])));\n\n        this._initializeMacroTimer.apply(this, [layerName].concat(PointOfInterestFeature_toConsumableArray(macroSaccadeWaitRange)));\n      }\n    }\n    /**\n     * Start keeping track of an animation layer that owns a blink animation. Blink\n     * animations can be of any type, but if it is of type randomAnimation then a\n     * it will be randomized each time a blink is called.\n     *\n     * @param {string} layerName - Name of the layer to keep track of.\n     * @param {Object=} options - Options for the layer.\n     * @param {string} [options.animation = \'blink\'] - Name of the blink animation\n     * on the layer.\n     * @param {number} [options.blendTime=[PointOfInterestFeature.DEFAULT_LAYER_OPTIONS.blendTime]{@link PointOfInterestFeature#DEFAULT_LAYER_OPTIONS#blendTime}] -\n     * Default amount of time to use when manipulating the layer\'s weight.\n     * @param {Function=} options.easingFn - Default easing function to use when\n     * manipulating the layer\'s weight.\n     */\n\n  }, {\n    key: "registerBlinkLayer",\n    value: function registerBlinkLayer(layerName) {\n      var _ref11 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref11$animation = _ref11.animation,\n          animation = _ref11$animation === void 0 ? \'blink\' : _ref11$animation,\n          _ref11$blendTime = _ref11.blendTime,\n          blendTime = _ref11$blendTime === void 0 ? PointOfInterestFeature.DEFAULT_LAYER_OPTIONS.blendTime : _ref11$blendTime,\n          easingFn = _ref11.easingFn;\n\n      // Register the layer and animation\n      this.registerLayer(layerName, {\n        blendTime: blendTime,\n        easingFn: easingFn,\n        animations: PointOfInterestFeature_defineProperty({}, animation, {})\n      });\n      this._blinkLayers[layerName] = animation;\n    }\n  }, {\n    key: "update",\n    value: function update(deltaTime) {\n      var _this5 = this;\n\n      PointOfInterestFeature_get(PointOfInterestFeature_getPrototypeOf(PointOfInterestFeature.prototype), "update", this).call(this, deltaTime); // Update the look angles\n\n\n      if (this._target) {\n        this._setLookAngles();\n      } else {\n        this._resetLookAngles();\n      }\n\n      var deltaSeconds = Math.min(deltaTime, MaxDelta) / 1000;\n      var triggerBlink = false; // Set look blend values\n\n      Object.entries(this._lookLayers).forEach(function (_ref12) {\n        var _ref13 = PointOfInterestFeature_slicedToArray(_ref12, 2),\n            layerName = _ref13[0],\n            animName = _ref13[1];\n\n        var options = _this5._managedLayers[layerName]; // Increment the saccade timers\n\n        if (options.isActive && options.hasSaccade) {\n          options.microSaccadeTimer.execute(deltaTime);\n          options.macroSaccadeTimer.execute(deltaTime);\n        } // Set the blend values\n\n\n        if (options.animations[animName].isActive) {\n          var currentH = _this5._host.AnimationFeature.getAnimationBlendWeight(layerName, animName, \'X\');\n\n          var currentV = _this5._host.AnimationFeature.getAnimationBlendWeight(layerName, animName, \'Y\');\n\n          var targetH = options.trackingConfig.angles.h;\n          var targetV = options.trackingConfig.angles.v; // Check if the look angle has changed enough to trigger a blink\n\n          if (_this5._isTargetMoving && !triggerBlink) {\n            var prevTargetH = options.trackingConfig.prevAngles.h;\n            var prevTargetV = options.trackingConfig.prevAngles.v;\n            var changeAmount = core_MathUtils.toDegrees(core_MathUtils.getAngleBetween([prevTargetH, prevTargetV], [targetH, targetV]));\n\n            if (changeAmount >= BlinkThreshold) {\n              triggerBlink = true;\n            }\n          }\n\n          options.trackingConfig.prevAngles.h = targetH;\n          options.trackingConfig.prevAngles.v = targetV; // Add in the saccade movement\n\n          if (options.hasSaccade) {\n            core_MathUtils.dampValue(0, options.macroSaccade.h + options.macroSaccade.h, options.hVelocity, options.hDuration, options.maxHSpeed);\n            targetH += options.hVelocity[0];\n            core_MathUtils.dampValue(0, options.macroSaccade.v + options.macroSaccade.v, options.vVelocity, options.vDuration, options.maxVSpeed);\n            targetV += options.vVelocity[0];\n          } // Clamp to max speed\n\n\n          var factor = core_MathUtils.clamp(deltaSeconds * options.maxSpeed, 0, 1);\n          targetH = core_MathUtils.lerp(currentH, targetH, factor);\n          targetV = core_MathUtils.lerp(currentV, targetV, factor); // Update the blend values\n\n          _this5._host.AnimationFeature.setAnimationBlendWeight(layerName, animName, \'X\', targetH);\n\n          _this5._host.AnimationFeature.setAnimationBlendWeight(layerName, animName, \'Y\', targetV);\n        }\n      });\n\n      if (!triggerBlink || !this._isTargetMoving) {\n        return;\n      } // Execute blink\n\n\n      Object.entries(this._blinkLayers).forEach(function (_ref14) {\n        var _ref15 = PointOfInterestFeature_slicedToArray(_ref14, 2),\n            layerName = _ref15[0],\n            animName = _ref15[1];\n\n        var animation = _this5._managedLayers[layerName].animations[animName];\n\n        if (animation.isActive) {\n          _this5._host.AnimationFeature.playAnimation(layerName, animName);\n        }\n      });\n    }\n  }, {\n    key: "installApi",\n    value: function installApi() {\n      var _this6 = this;\n\n      /**\n       * @inner\n       * @namespace PointOfInterestFeature\n       */\n      var api = PointOfInterestFeature_get(PointOfInterestFeature_getPrototypeOf(PointOfInterestFeature.prototype), "installApi", this).call(this);\n\n      Object.defineProperties(api, {\n        /**\n         * @memberof PointOfInterestFeature\n         * @instance\n         * @see core/PointOfInterestFeature#target\n         */\n        target: {\n          get: function get() {\n            return _this6.target;\n          },\n          set: function set(target) {\n            _this6.target = target;\n          }\n        }\n      });\n      Object.assign(api, {\n        /**\n         * @memberof PointOfInterestFeature\n         * @instance\n         * @method\n         * @see core/PointOfInterestFeature#registerLookLayer\n         */\n        registerLookLayer: this.registerLookLayer.bind(this),\n\n        /**\n         * @memberof PointOfInterestFeature\n         * @instance\n         * @method\n         * @see core/PointOfInterestFeature#registerBlinkLayer\n         */\n        registerBlinkLayer: this.registerBlinkLayer.bind(this),\n\n        /**\n         * @memberof PointOfInterestFeature\n         * @instance\n         * @method\n         * @see core/PointOfInterestFeature#setTarget\n         */\n        setTarget: this.setTarget.bind(this),\n\n        /**\n         * @memberof PointOfInterestFeature\n         * @instance\n         * @method\n         * @see core/PointOfInterestFeature#setTargetByName\n         */\n        setTargetByName: this.setTargetByName.bind(this),\n\n        /**\n         * @memberof PointOfInterestFeature\n         * @instance\n         * @method\n         * @see core/PointOfInterestFeature#setTargetById\n         */\n        setTargetById: this.setTargetById.bind(this)\n      });\n      return api;\n    }\n  }], [{\n    key: "_getWorldPosition",\n    value: function _getWorldPosition(obj) {\n      return [0, 0, 0];\n    }\n    /**\n     * Return a matrix representing the global transformation matrix of an object.\n     * Should be overloaded for each rendering engine implementation.\n     *\n     * @private\n     *\n     * @param {any} obj - Engine-specific 3D transform object.\n     *\n     * @returns {Array.<number>} - An array consisting of 16 numbers representing\n     * the 3d transformation.\n     */\n\n  }, {\n    key: "_getWorldMatrix",\n    value: function _getWorldMatrix(obj) {\n      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n    }\n    /**\n     * Rotate the given local direction vector by the object\'s world rotation matrix.\n     *\n     * @private\n     *\n     * @param {any} obj - Engine-specific 3D transform object.\n     * @param {Array.<number>} forwardVector - Unit vector representing the local\n     * forward direction of the object.\n     *\n     * @returns {Array.<number>}\n     */\n\n  }, {\n    key: "_getObjectDirection",\n    value: function _getObjectDirection(obj) {\n      var forwardVector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AxisMap.PositiveZ;\n      var rotation = core_MathUtils.getRotationMatrix(this._getWorldMatrix(obj));\n      return core_MathUtils.rotateVector(forwardVector, rotation);\n    }\n    /**\n     * Calculate horizontal and vertical look angles in degrees given spherical theta\n     * and phi angles in radians.\n     *\n     * @param {number} theta - Vertical/polar angle in radians where 0 points directly\n     * along positive Y axis.\n     * @param {number} phi - Horizontal/azimuthal angle in radians.\n     *\n     * @returns {Object} - An object with the signature {h: number, v: number} where\n     * h represents horizontal rotation in degrees and v represents vertical rotation\n     * in degrees.\n     */\n\n  }, {\n    key: "_sphericalToBlendValue",\n    value: function _sphericalToBlendValue(theta, phi) {\n      var h = core_MathUtils.toDegrees(phi); // Offset the vertical angle so 0 is pointing forward instead of up\n\n      var v = core_MathUtils.toDegrees(theta) - 90; // Convert vertical angle to -180, 180 range\n\n      return {\n        h: h,\n        v: v\n      };\n    }\n  }, {\n    key: "_validateTransformObject",\n    value: function _validateTransformObject(obj) {\n      return obj instanceof Object;\n    }\n  }]);\n\n  return PointOfInterestFeature;\n}(core_AbstractHostFeature.mix(awspack_SSMLSpeechmarkInterface.Mixin, animpack_ManagedAnimationLayerInterface.Mixin));\n\n/* harmony default export */ const core_PointOfInterestFeature = (PointOfInterestFeature);\n\n;// CONCATENATED MODULE: ./src/core/animpack/index.js\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\n * @module core/animpack\n */\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @namespace\n */\n\nvar Easing = {\n  /**\n   * @see Linear\n   */\n  Linear: Linear,\n\n  /**\n   * @see Quadratic\n   */\n  Quadratic: Quadratic,\n\n  /**\n   * @see Cubic\n   */\n  Cubic: Cubic,\n\n  /**\n   * @see Quartic\n   */\n  Quartic: Quartic,\n\n  /**\n   * @see Quintic\n   */\n  Quintic: Quintic,\n\n  /**\n   * @see Sinusoidal\n   */\n  Sinusoidal: Sinusoidal,\n\n  /**\n   * @see Exponential\n   */\n  Exponential: Exponential,\n\n  /**\n   * @see Circular\n   */\n  Circular: Circular,\n\n  /**\n   * @see Elastic\n   */\n  Elastic: Elastic,\n\n  /**\n   * @see Back\n   */\n  Back: Back,\n\n  /**\n   * @see Bounce\n   */\n  Bounce: Bounce\n};\n/* harmony default export */ const animpack = ({\n  /**\n   * @see core/AnimationFeature\n   */\n  AnimationFeature: animpack_AnimationFeature,\n\n  /**\n   * @see AnimationLayer\n   */\n  AnimationLayer: animpack_AnimationLayer,\n\n  /**\n   * @see core/SingleState\n   */\n  SingleState: state_SingleState,\n\n  /**\n   * @see TransitionState\n   */\n  TransitionState: state_TransitionState,\n\n  /**\n   * @see FreeBlendState\n   */\n  FreeBlendState: state_FreeBlendState,\n\n  /**\n   * @see QueueState\n   */\n  QueueState: state_QueueState,\n\n  /**\n   * @see RandomAnimationState\n   */\n  RandomAnimationState: state_RandomAnimationState,\n\n  /**\n   * @see Blend1dState\n   */\n  Blend1dState: state_Blend1dState,\n\n  /**\n   * @see Blend2dState\n   */\n  Blend2dState: state_Blend2dState,\n\n  /**\n   * @see AnimationUtils\n   */\n  AnimationUtils: animpack_AnimationUtils,\n  Easing: Easing,\n\n  /**\n   * @see LayerBlendModes\n   */\n  LayerBlendModes: LayerBlendModes,\n\n  /**\n   * @see DefaultLayerBlendMode\n   */\n  DefaultLayerBlendMode: DefaultLayerBlendMode,\n\n  /**\n   * @see AnimationTypes\n   */\n  AnimationTypes: AnimationTypes\n});\n;// CONCATENATED MODULE: ./src/core/awspack/TextToSpeechUtils.js\nfunction TextToSpeechUtils_toConsumableArray(arr) { return TextToSpeechUtils_arrayWithoutHoles(arr) || TextToSpeechUtils_iterableToArray(arr) || TextToSpeechUtils_unsupportedIterableToArray(arr) || TextToSpeechUtils_nonIterableSpread(); }\n\nfunction TextToSpeechUtils_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction TextToSpeechUtils_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction TextToSpeechUtils_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return TextToSpeechUtils_arrayLikeToArray(arr); }\n\nfunction TextToSpeechUtils_slicedToArray(arr, i) { return TextToSpeechUtils_arrayWithHoles(arr) || TextToSpeechUtils_iterableToArrayLimit(arr, i) || TextToSpeechUtils_unsupportedIterableToArray(arr, i) || TextToSpeechUtils_nonIterableRest(); }\n\nfunction TextToSpeechUtils_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction TextToSpeechUtils_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return TextToSpeechUtils_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return TextToSpeechUtils_arrayLikeToArray(o, minLen); }\n\nfunction TextToSpeechUtils_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction TextToSpeechUtils_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction TextToSpeechUtils_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction TextToSpeechUtils_typeof(obj) { "@babel/helpers - typeof"; return TextToSpeechUtils_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, TextToSpeechUtils_typeof(obj); }\n\nfunction TextToSpeechUtils_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction TextToSpeechUtils_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction TextToSpeechUtils_createClass(Constructor, protoProps, staticProps) { if (protoProps) TextToSpeechUtils_defineProperties(Constructor.prototype, protoProps); if (staticProps) TextToSpeechUtils_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\n * A collection of useful text-to-speech functions.\n *\n * @hideconstructor\n */\n\nvar TextToSpeechUtils = /*#__PURE__*/function () {\n  function TextToSpeechUtils() {\n    TextToSpeechUtils_classCallCheck(this, TextToSpeechUtils);\n  }\n\n  TextToSpeechUtils_createClass(TextToSpeechUtils, null, [{\n    key: "autoGenerateSSMLMarks",\n    value:\n    /**\n     * Returns a new string with SSML marks inserted based on\n     * matches between the input string and the input map. The\n     * word matches are case-insensitive. Words within existing\n     * SSML tags will not be affected. Input text will be surrounded\n     * by <speak></speak> tags if needed.\n     *\n     * @param {string} text - Input string.\n     * @param {object} map - Input object that maps mark keys\n     * to arrays of words. Example:\n     *\n     *  {\n     *    \'mark:sad\' : [\'sad\', \'blue\', \'down\'],\n     *    \'mark:happy\' : [\'joy\', \'glad\', \'great\'],\n     *    \'mark:no\' : [\'no\', \'nah\', \'nay\', \'sure\']\n     *  }\n     * @param {Array.<string>} [randomMarks = []] - If there are sentences that don\'t\n     * match any words from the map object, marks from this array will be randomly\n     * chosen and inserted.\n     *\n     * @returns {string} - Updated input string.\n     */\n    function autoGenerateSSMLMarks(text, map) {\n      var _this = this;\n\n      var randomMarks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n      if (TextToSpeechUtils_typeof(map) !== \'object\' || map === null) {\n        throw new Error("Cannot generate SSML marks for text \\"".concat(text, "\\" because map is not an object."));\n      } // process the input map into an internal format\n\n\n      var internalMap = this._processInputMap(map);\n\n      var speakTags = [\'<speak>\', \'</speak>\'];\n      var ssmlMarkRegex = /<mark name=(?:"|\')(.*?)(?:"|\')\\/>/;\n      var ssmlTagRegex = /<[^>]*>/g; // Identify any existing SSML tags\n\n      var existingTags = [];\n      var result = ssmlTagRegex.exec(text);\n\n      while (result !== null) {\n        existingTags.push({\n          start: result.index,\n          end: result.index + result[0].length,\n          text: result[0]\n        });\n        result = ssmlTagRegex.exec(text);\n      }\n\n      var chunks = [];\n      var index = 0;\n      var ssmlMarkResult;\n      var duplicateMarkToCheck = [];\n      existingTags.forEach(function (existingTag) {\n        var substr = text.slice(index, existingTag.start);\n\n        if (substr !== \'\') {\n          // auto-mark non-tag text\n          chunks.push(_this._insertMarks(substr, internalMap, duplicateMarkToCheck));\n          duplicateMarkToCheck = [];\n        }\n\n        ssmlMarkResult = ssmlMarkRegex.exec(existingTag.text);\n\n        if (ssmlMarkResult !== null) {\n          var markText = ssmlMarkResult[1];\n          duplicateMarkToCheck.push(markText);\n        } else if (!speakTags.includes(existingTag.text)) {\n          chunks.push(existingTag.text);\n        } // advance the index\n\n\n        index = existingTag.end;\n      });\n      chunks.push(this._insertMarks(text.slice(index), internalMap, duplicateMarkToCheck));\n      var markedText = chunks.join(\'\');\n\n      if (randomMarks && randomMarks.length > 0) {\n        // add random marks to any unmarked sentences\n        markedText = this.addMarksToUnmarkedSentences(markedText, randomMarks);\n      }\n\n      return TextToSpeechUtils.validateText(markedText);\n    }\n    /**\n     * Returns a new string with a random SSML mark inserted at each sentence that\n     * does not already contain an SSML mark.\n     *\n     * @param {string} text - Input string.\n     * @param {Array.<string>} marks - Any array of random SSML marks to choose from\n     * when modifying the text.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: "addMarksToUnmarkedSentences",\n    value: function addMarksToUnmarkedSentences(text, marks) {\n      if (!marks || marks.length === 0) return text;\n      var ssmlMarkRegex = /<mark name=(?:"|\')(.*?)(?:"|\')\\/>/g;\n      var ssmlTagRegex = /<[^>]*>/g; // Find the indices of any marks in the text\n\n      var markIndices = [];\n      var markResult = ssmlMarkRegex.exec(text);\n\n      while (markResult !== null) {\n        markIndices.push(markResult.index);\n        markResult = ssmlMarkRegex.exec(text);\n      } // Find all SSML tags in the text\n\n\n      var existingTags = [];\n      var ssmlResult = ssmlTagRegex.exec(text);\n\n      while (ssmlResult !== null) {\n        existingTags.push({\n          start: ssmlResult.index,\n          end: ssmlResult.index + ssmlResult[0].length,\n          text: ssmlResult[0]\n        });\n        ssmlResult = ssmlTagRegex.exec(text);\n      } // Create a copy of the text with all SSML marks replaces with whitespace\n\n\n      var cleanedText = text.slice();\n      existingTags.forEach(function (existingSsml) {\n        var whitespace = new Array(existingSsml.text.length + 1).join(\' \');\n        cleanedText = [cleanedText.slice(0, existingSsml.start), whitespace, cleanedText.slice(existingSsml.end)].join(\'\');\n      });\n\n      var sentenceEndIndices = this._getSentenceEnds(cleanedText); // Only insert random marks into sentences that don\'t already have any\n\n\n      var prevIndex = 0;\n      var targetIndices = sentenceEndIndices.filter(function (index) {\n        var containsMark = markIndices.findIndex(function (markIndex) {\n          return prevIndex <= markIndex && index > markIndex;\n        }) !== -1;\n        prevIndex = index;\n        return !containsMark;\n      });\n\n      var randomMarkedText = this._insertRandomMarksAt(text, targetIndices, marks);\n\n      return randomMarkedText;\n    }\n    /**\n     * Generate a version of given text that is enclosed by Polly ssml speak tags.\n     *\n     * @param {string} text - The text to validate.\n     *\n     * @returns {string} - Updated input string.\n     */\n\n  }, {\n    key: "validateText",\n    value: function validateText(text) {\n      if (!text) {\n        text = \'<speak></speak>\';\n      } else {\n        text = text.replace(/(^\\s*<\\s*speak\\s*)>\\s*|(^\\s*)/, \'<speak>\').replace(/(\\s*<\\s*\\/\\s*speak\\s*>\\s*$|\\s*$)/, \'</speak>\');\n      }\n\n      return text;\n    }\n    /**\n     * Parse an input string and insert SSML marks based on\n     * word matches in a map.\n     *\n     * @private\n     *\n     * @param {string} text - Input string.\n     * @param {Array.<number>} [indices = []] - An array of indices in the text input\n     * where random marks should be inserted.\n     * @param {Array.<string>} [marks = []] - An array of mark strings to choose\n     * from when inserting random marks.\n     *\n     * @returns {string} - Updated input string.\n     */\n\n  }, {\n    key: "_insertRandomMarksAt",\n    value: function _insertRandomMarksAt(text) {\n      var indices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var marks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n      if (!marks || marks.length === 0 || !indices || indices.length === 0) {\n        return text;\n      }\n\n      var offset = 0;\n      indices.forEach(function (index) {\n        var randomMark = "<mark name=\'".concat(marks[core_Utils.getRandomInt(0, marks.length)], "\'/>");\n        text = [text.slice(0, index + offset), randomMark, text.slice(index + offset)].join(\'\');\n        offset += randomMark.length;\n      });\n      return text;\n    }\n    /**\n     * Parses a string of text and returns an array containing the indices\n     * of the last character in a sentence that is not in the following list:\n     *  (\'.\', \'?\', \'!\')\n     *\n     * @private\n     *\n     * @param {string} text - Text to process for end of sentence\n     * indices.\n     *\n     * @returns {Array.<number>} - Array of end of sentence indices.\n     */\n\n  }, {\n    key: "_getSentenceEnds",\n    value: function _getSentenceEnds(text) {\n      var sentenceRegex = /[^.!?]+[.!?]+/g;\n      var endSentenceRegex = /[.!?]+/;\n      var result = sentenceRegex.exec(text);\n      var sentenceEnds = [];\n\n      while (result !== null) {\n        // find the last non-punctuation character\n        var punctResult = endSentenceRegex.exec(result[0]);\n        sentenceEnds.push(result.index + result[0].length - punctResult[0].length);\n        result = sentenceRegex.exec(text);\n      }\n\n      return sentenceEnds;\n    }\n    /**\n     * Parse an input string and insert SSML marks based on\n     * word matches in a map.\n     *\n     * @private\n     *\n     * @param {string} text - Input string.\n     * @param {Map} map - Mapping of words to mark values that\n     * will be inserted as the value for a mark\'s \'name\' attribute.\n     * @param {Array} duplicatesToCheck - A list of mark values to check for duplicate against the first word\n     *\n     * @returns {string} - Updated input string.\n     */\n\n  }, {\n    key: "_insertMarks",\n    value: function _insertMarks(text, map, duplicatesToCheck) {\n      if (text === \'\') return text;\n      var wordRegex = /\\w+|\\s+|[^\\s\\w]+/g;\n      var lowerCaseWord;\n      var checkDuplicate = true;\n      var markedWords = text.match(wordRegex).map(function (word) {\n        lowerCaseWord = word.toLowerCase();\n\n        if (map.has(lowerCaseWord)) {\n          var marks = map.get(lowerCaseWord).map(function (mark) {\n            if (checkDuplicate) {\n              checkDuplicate = false;\n              return duplicatesToCheck.includes(mark) ? \'\' : "<mark name=\'".concat(mark, "\'/>");\n            } else {\n              return "<mark name=\'".concat(mark, "\'/>");\n            }\n          });\n          return "".concat(marks.join(\'\')).concat(word);\n        } else {\n          checkDuplicate = false;\n          return word;\n        }\n      });\n      var existingMarks = duplicatesToCheck.map(function (mark) {\n        return "<mark name=\'".concat(mark, "\'/>");\n      });\n      return "".concat(existingMarks.join(\'\')).concat(markedWords.join(\'\'));\n    }\n    /**\n     * Processes an input object for mapping an array\n     * of words to specific mark keys. Converts the input\n     * map into a Map with a more efficient format for\n     * performing mark injection.\n     *\n     * @private\n     *\n     * @param {object} map - Input object that maps mark keys\n     * to arrays of words.\n     *\n     * @returns {Map} - Map for internal use.\n     */\n\n  }, {\n    key: "_processInputMap",\n    value: function _processInputMap(map) {\n      var internalMap = new Map();\n      var list = [];\n      Object.entries(map).forEach(function (_ref) {\n        var _ref2 = TextToSpeechUtils_slicedToArray(_ref, 2),\n            key = _ref2[0],\n            value = _ref2[1];\n\n        if (!Array.isArray(value)) {\n          throw new Error("Cannot generate SSML marks from map \\"".concat(map, "\\" because value for key \'").concat(key, "\' is not an array."));\n        }\n\n        value.forEach(function (word) {\n          var lowerCaseWord = word.toLowerCase();\n          list = internalMap.get(lowerCaseWord);\n\n          if (list !== undefined && !list.includes(key)) {\n            internalMap.set(lowerCaseWord, [].concat(TextToSpeechUtils_toConsumableArray(list), [key]));\n          } else {\n            internalMap.set(lowerCaseWord, [key]);\n          }\n        });\n      });\n      return internalMap;\n    }\n  }]);\n\n  return TextToSpeechUtils;\n}();\n\n/* harmony default export */ const awspack_TextToSpeechUtils = (TextToSpeechUtils);\n;// CONCATENATED MODULE: ./src/core/awspack/AbstractSpeech.js\nfunction AbstractSpeech_toConsumableArray(arr) { return AbstractSpeech_arrayWithoutHoles(arr) || AbstractSpeech_iterableToArray(arr) || AbstractSpeech_unsupportedIterableToArray(arr) || AbstractSpeech_nonIterableSpread(); }\n\nfunction AbstractSpeech_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction AbstractSpeech_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return AbstractSpeech_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return AbstractSpeech_arrayLikeToArray(o, minLen); }\n\nfunction AbstractSpeech_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction AbstractSpeech_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return AbstractSpeech_arrayLikeToArray(arr); }\n\nfunction AbstractSpeech_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction AbstractSpeech_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AbstractSpeech_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AbstractSpeech_createClass(Constructor, protoProps, staticProps) { if (protoProps) AbstractSpeech_defineProperties(Constructor.prototype, protoProps); if (staticProps) AbstractSpeech_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\n * Class that can play back audio generated by AWS Polly and synchronized emit\n * speechmark messages.\n *\n * @abstract\n */\n\nvar AbstractSpeech = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   *\n   * @param {core/TextToSpeechFeature} speaker - The feature that owns the Speech and\n   * will emit speechmark messages.\n   * @param {string} text - The text of the speech.\n   * @param {Array.<Object>} [speechmarks=[]] - An array of speechmark objects representing\n   * the text and timing of the speech.\n   */\n  function AbstractSpeech(speaker, text) {\n    var speechmarks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n    AbstractSpeech_classCallCheck(this, AbstractSpeech);\n\n    this._speaker = speaker;\n    this._text = text;\n    this._speechmarks = speechmarks;\n    this._speechmarkOffset = 0;\n\n    this._reset();\n  }\n  /**\n   * Reset tracking properties.\n   *\n   * @private\n   *\n   * @param {number} [currentTime=0] - Time to use for _startTime.\n   */\n\n\n  AbstractSpeech_createClass(AbstractSpeech, [{\n    key: "_reset",\n    value: function _reset() {\n      var currentTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      this._startTime = currentTime;\n      this._localTime = 0;\n      this._pauseTime = 0;\n      this._playing = false;\n      this._markIter = this._speechmarks.values();\n\n      var _this$_markIter$next = this._markIter.next(),\n          value = _this$_markIter$next.value,\n          done = _this$_markIter$next.done;\n\n      this._currentMark = value;\n      this._endTime = this._speechmarks.length ? this._speechmarks[this._speechmarks.length - 1].time : 0;\n      this._done = done;\n      this._promise = null;\n    }\n    /**\n     * Create a new promise that will stop playback and emit messages for this speech.\n     *\n     * @param {Function=} onFinish - Funciton to execute once the speech stops.\n     * @param {onError=} onError - Function to execute if the speech encounters an\n     * error.\n     * @param {Function=} onInterrupt - Function to execute if the speech is canceled.\n     *\n     * @returns {Deferred}\n     *\n     * @private\n     */\n\n  }, {\n    key: "_createPromise",\n    value: function _createPromise(onFinish, onError, onInterrupt) {\n      var _this = this;\n\n      var onResolve = function onResolve(value) {\n        _this._playing = false;\n\n        _this._speaker.emit(_this._speaker.constructor.EVENTS.stop, _this);\n\n        _this._speaker.constructor.emit(_this._speaker.constructor.EVENTS.stop, _this);\n\n        if (typeof onFinish === \'function\') {\n          onFinish(value);\n        }\n      };\n\n      var onReject = function onReject(e) {\n        _this._playing = false;\n\n        _this._speaker.emit(_this._speaker.constructor.EVENTS.stop, _this);\n\n        _this._speaker.constructor.emit(_this._speaker.constructor.EVENTS.stop, _this);\n\n        console.error("".concat(_this.constructor.name, " encountered an unexpected error: ").concat(e));\n\n        if (typeof onError === \'function\') {\n          onError(e);\n        }\n      };\n\n      var onCancel = function onCancel(value) {\n        _this._playing = false;\n\n        _this._speaker.emit(_this._speaker.constructor.EVENTS.interrupt, _this);\n\n        _this._speaker.constructor.emit(_this._speaker.constructor.EVENTS.interrupt, _this);\n\n        if (typeof onInterrupt === \'function\') {\n          onInterrupt(value);\n        }\n      };\n\n      this._promise = new core_Deferred(undefined, onResolve, onReject, onCancel);\n      return this._promise;\n    }\n    /**\n     * Return whether or not the speech has reached it\'s end.\n     *\n     * @private\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "_checkFinished",\n    value: function _checkFinished() {\n      return this._done && this._localTime >= this._endTime;\n    }\n    /**\n     * Gets the playback state of the audio.\n     *\n     * @readonly\n     * @type {boolean}\n     */\n\n  }, {\n    key: "playing",\n    get: function get() {\n      return this._playing;\n    }\n    /**\n     * Gets the text of the speech.\n     *\n     * @readonly\n     * @type {string}\n     */\n\n  }, {\n    key: "text",\n    get: function get() {\n      return this._text;\n    }\n    /**\n     * Gets a shallow copy of the speechmarks array for the speech.\n     *\n     * @readonly\n     * @type {Array.<Object>}\n     */\n\n  }, {\n    key: "speechmarks",\n    get: function get() {\n      return AbstractSpeech_toConsumableArray(this._speechmarks);\n    }\n    /**\n     * Gets and sets the number of seconds to offset speechmark emission.\n     * @type {number}\n     */\n\n  }, {\n    key: "speechmarkOffset",\n    get: function get() {\n      return this._speechmarkOffset / 1000;\n    },\n    set: function set(offset) {\n      this._speechmarkOffset = offset * 1000; // Store as milliseconds\n    }\n    /**\n     * Emit speechmark messages as they are encountered in sync with audio.\n     *\n     * @param {number} currentTime - Current global time when update was called.\n     */\n\n  }, {\n    key: "update",\n    value: function update(currentTime) {\n      if (!this._playing) {\n        return;\n      } // Update local audio time\n\n\n      this._localTime = currentTime - this._startTime;\n\n      if (!this._done) {\n        // Emit speechmark messages for marks up to the current time\n        while (!this._done && this._currentMark.time + this._speechmarkOffset <= this._localTime) {\n          this._speaker.emit(this._speaker.constructor.EVENTS[this._currentMark.type], {\n            speech: this,\n            mark: this._currentMark\n          });\n\n          var _this$_markIter$next2 = this._markIter.next(),\n              value = _this$_markIter$next2.value,\n              done = _this$_markIter$next2.done;\n\n          this._currentMark = value;\n          this._done = done;\n        }\n      } // End playback\n\n\n      if (this._checkFinished()) {\n        this.stop();\n\n        this._reset();\n      }\n    }\n    /**\n     * Play the speech from the beginning.\n     *\n     * @param {number} currentTime - Current global time when play was called.\n     * @param {Function=} onFinish - Optional function to execute once the speech\n     * promise resolves.\n     * @param {Function=} onError - Optional function to execute if the speech\n     * encounters and error during playback.\n     * @param {Function=} onInterrupt - Optional function to execute if the speech\n     * is canceled.\n     *\n     * @returns {Deferred} Resolves once the speech reaches the end of playback.\n     */\n\n  }, {\n    key: "play",\n    value: function play(currentTime, onFinish, onError, onInterrupt) {\n      this._reset(currentTime);\n\n      this._playing = true;\n\n      this._speaker.emit(this._speaker.constructor.EVENTS.play, this);\n\n      this._speaker.constructor.emit(this._speaker.constructor.EVENTS.play, this);\n\n      return this._createPromise(onFinish, onError, onInterrupt);\n    }\n    /**\n     * Pause the speech at the current time.\n     *\n     * @param {number} currentTime - Current global time when pause was called.\n     */\n\n  }, {\n    key: "pause",\n    value: function pause(currentTime) {\n      this._playing = false;\n      this._pauseTime = currentTime;\n\n      this._speaker.emit(this._speaker.constructor.EVENTS.pause, this);\n\n      this._speaker.constructor.emit(this._speaker.constructor.EVENTS.pause, this);\n    }\n    /**\n     * Resume the speech at the current time.\n     *\n     * @param {number} currentTime - Current global time when resume was called.\n     * @param {Function=} onFinish - Optional function to execute once the speech\n     * promise resolves.\n     * @param {Function=} onError - Optional function to execute if the speech\n     * encounters and error during playback.\n     * @param {Function=} onInterrupt - Optional function to execute if the speech\n     * is canceled.\n     *\n     * @returns {Deferred} Resolves once the speech reaches the end of playback.\n     */\n\n  }, {\n    key: "resume",\n    value: function resume(currentTime, onFinish, onError, onInterrupt) {\n      // Play from the beginning if the speech hasn\'t played yet\n      if (!this._promise) {\n        this._reset(currentTime);\n\n        this._createPromise(onFinish, onError, onInterrupt);\n      }\n\n      this._playing = true;\n      this._startTime += currentTime - this._pauseTime;\n\n      this._speaker.emit(this._speaker.constructor.EVENTS.resume, this);\n\n      this._speaker.constructor.emit(this._speaker.constructor.EVENTS.resume, this);\n\n      return this._promise;\n    }\n    /**\n     * Cancels playback of the speech at the current time. Cancel the speech promise.\n     */\n\n  }, {\n    key: "cancel",\n    value: function cancel() {\n      if (this._promise) {\n        this._promise.cancel();\n\n        this._promise = null;\n      }\n\n      this._playing = false;\n    }\n    /**\n     * Stop the speech and reset time to the beginning. Resolve the speech promise.\n     */\n\n  }, {\n    key: "stop",\n    value: function stop() {\n      if (this._promise) {\n        this._promise.resolve();\n\n        this._promise = null;\n      }\n\n      this._playing = false;\n    }\n  }]);\n\n  return AbstractSpeech;\n}();\n\n/* harmony default export */ const awspack_AbstractSpeech = (AbstractSpeech);\n;// CONCATENATED MODULE: ./src/core/awspack/Speech.js\nfunction Speech_typeof(obj) { "@babel/helpers - typeof"; return Speech_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, Speech_typeof(obj); }\n\nfunction Speech_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Speech_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Speech_createClass(Constructor, protoProps, staticProps) { if (protoProps) Speech_defineProperties(Constructor.prototype, protoProps); if (staticProps) Speech_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction Speech_get() { if (typeof Reflect !== "undefined" && Reflect.get) { Speech_get = Reflect.get; } else { Speech_get = function _get(target, property, receiver) { var base = Speech_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return Speech_get.apply(this, arguments); }\n\nfunction Speech_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Speech_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Speech_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) Speech_setPrototypeOf(subClass, superClass); }\n\nfunction Speech_setPrototypeOf(o, p) { Speech_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Speech_setPrototypeOf(o, p); }\n\nfunction Speech_createSuper(Derived) { var hasNativeReflectConstruct = Speech_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Speech_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Speech_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Speech_possibleConstructorReturn(this, result); }; }\n\nfunction Speech_possibleConstructorReturn(self, call) { if (call && (Speech_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return Speech_assertThisInitialized(self); }\n\nfunction Speech_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Speech_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction Speech_getPrototypeOf(o) { Speech_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Speech_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\n * The built-in class for asynchronous Promises.\n * @external Audio\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLAudioElement/Audio\n */\n\n/**\n * @extends AbstractSpeech\n * @alias core/Speech\n */\n\nvar Speech = /*#__PURE__*/function (_AbstractSpeech) {\n  Speech_inherits(Speech, _AbstractSpeech);\n\n  var _super = Speech_createSuper(Speech);\n\n  /**\n   * @constructor\n   *\n   * @param {TextToSpeech} speaker - The owner of the Speech that will emit speechmark\n   * messages.\n   * @param {string} text - The text of the speech.\n   * @param {Array.<Object>} [speechmarks=[]] - An array of speechmark objects representing\n   * the text and timing of the speech.\n   * @param {Object} audioConfig - Object containing audio and url.\n   * @param {external:Audio} audioConfig.audio - Playable audio object.\n   */\n  function Speech(speaker, text) {\n    var _this;\n\n    var speechmarks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var audioConfig = arguments.length > 3 ? arguments[3] : undefined;\n\n    Speech_classCallCheck(this, Speech);\n\n    _this = _super.call(this, speaker, text, speechmarks);\n    _this._audio = audioConfig.audio; // Keep track of whether the audio has finished playing through\n\n    _this._audio.onended = function () {\n      _this._audioFinished = true;\n    };\n\n    _this._audioFinished = true;\n    return _this;\n  }\n\n  Speech_createClass(Speech, [{\n    key: "_checkFinished",\n    value: function _checkFinished() {\n      return this._audioFinished && Speech_get(Speech_getPrototypeOf(Speech.prototype), "_checkFinished", this).call(this);\n    }\n    /**\n     * Gets the playable audio for the speech.\n     *\n     * @readonly\n     * @type {external:Audio}\n     */\n\n  }, {\n    key: "audio",\n    get: function get() {\n      return this._audio;\n    }\n    /**\n     * Gets the audio volume for the speech.\n     *\n     * @type {number}\n     */\n\n  }, {\n    key: "volume",\n    get: function get() {\n      return this._audio.volume;\n    }\n    /**\n     * Sets the audio volume for the speech.\n     */\n    ,\n    set: function set(volume) {\n      this._audio.volume = volume;\n    }\n    /**\n     * Set the audio\'s current local time and play it.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_playAudio",\n    value: function _playAudio() {\n      var _this2 = this;\n\n      if (this._speechmarkOffset < 0) {\n        this._audio.currentTime = this._speechmarkOffset;\n        setTimeout(function () {\n          if (_this2._playing) {\n            _this2._audio.currentTime = (_this2._localTime + _this2._speechmarkOffset) / 1000;\n\n            _this2._audio.play();\n          }\n        }, -this._speechmarkOffset);\n      } else {\n        this._audio.currentTime = 0;\n\n        this._audio.play();\n      }\n    }\n    /**\n     * Pause the audio once it is playable.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_pauseAudio",\n    value: function _pauseAudio() {\n      var _this3 = this;\n\n      this._audio.play().then(function () {\n        if (!_this3._playing) {\n          _this3._audio.pause();\n        }\n      });\n    }\n  }, {\n    key: "play",\n    value: function play(currentTime, onFinish, onError, onInterrupt) {\n      this._audioFinished = false;\n\n      this._playAudio();\n\n      return Speech_get(Speech_getPrototypeOf(Speech.prototype), "play", this).call(this, currentTime, onFinish, onError, onInterrupt);\n    }\n  }, {\n    key: "pause",\n    value: function pause(currentTime) {\n      this._pauseAudio();\n\n      Speech_get(Speech_getPrototypeOf(Speech.prototype), "pause", this).call(this, currentTime);\n    }\n  }, {\n    key: "resume",\n    value: function resume(currentTime, onFinish, onError, onInterrupt) {\n      this._audioFinished = false;\n\n      this._audio.play();\n\n      return Speech_get(Speech_getPrototypeOf(Speech.prototype), "resume", this).call(this, currentTime, onFinish, onError, onInterrupt);\n    }\n  }, {\n    key: "cancel",\n    value: function cancel() {\n      this._pauseAudio();\n\n      Speech_get(Speech_getPrototypeOf(Speech.prototype), "cancel", this).call(this);\n    }\n  }, {\n    key: "stop",\n    value: function stop() {\n      this._pauseAudio();\n\n      this._audio.currentTime = 0;\n\n      Speech_get(Speech_getPrototypeOf(Speech.prototype), "stop", this).call(this);\n    }\n  }]);\n\n  return Speech;\n}(awspack_AbstractSpeech);\n\n/* harmony default export */ const awspack_Speech = (Speech);\n;// CONCATENATED MODULE: ./src/core/awspack/AbstractTextToSpeechFeature.js\nfunction AbstractTextToSpeechFeature_typeof(obj) { "@babel/helpers - typeof"; return AbstractTextToSpeechFeature_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, AbstractTextToSpeechFeature_typeof(obj); }\n\nfunction AbstractTextToSpeechFeature_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction AbstractTextToSpeechFeature_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? AbstractTextToSpeechFeature_ownKeys(Object(source), !0).forEach(function (key) { AbstractTextToSpeechFeature_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : AbstractTextToSpeechFeature_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction AbstractTextToSpeechFeature_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction AbstractTextToSpeechFeature_slicedToArray(arr, i) { return AbstractTextToSpeechFeature_arrayWithHoles(arr) || AbstractTextToSpeechFeature_iterableToArrayLimit(arr, i) || AbstractTextToSpeechFeature_unsupportedIterableToArray(arr, i) || AbstractTextToSpeechFeature_nonIterableRest(); }\n\nfunction AbstractTextToSpeechFeature_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction AbstractTextToSpeechFeature_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction AbstractTextToSpeechFeature_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction AbstractTextToSpeechFeature_toConsumableArray(arr) { return AbstractTextToSpeechFeature_arrayWithoutHoles(arr) || AbstractTextToSpeechFeature_iterableToArray(arr) || AbstractTextToSpeechFeature_unsupportedIterableToArray(arr) || AbstractTextToSpeechFeature_nonIterableSpread(); }\n\nfunction AbstractTextToSpeechFeature_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction AbstractTextToSpeechFeature_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return AbstractTextToSpeechFeature_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return AbstractTextToSpeechFeature_arrayLikeToArray(o, minLen); }\n\nfunction AbstractTextToSpeechFeature_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction AbstractTextToSpeechFeature_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return AbstractTextToSpeechFeature_arrayLikeToArray(arr); }\n\nfunction AbstractTextToSpeechFeature_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction AbstractTextToSpeechFeature_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AbstractTextToSpeechFeature_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AbstractTextToSpeechFeature_createClass(Constructor, protoProps, staticProps) { if (protoProps) AbstractTextToSpeechFeature_defineProperties(Constructor.prototype, protoProps); if (staticProps) AbstractTextToSpeechFeature_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction AbstractTextToSpeechFeature_get() { if (typeof Reflect !== "undefined" && Reflect.get) { AbstractTextToSpeechFeature_get = Reflect.get; } else { AbstractTextToSpeechFeature_get = function _get(target, property, receiver) { var base = AbstractTextToSpeechFeature_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return AbstractTextToSpeechFeature_get.apply(this, arguments); }\n\nfunction AbstractTextToSpeechFeature_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = AbstractTextToSpeechFeature_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction AbstractTextToSpeechFeature_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) AbstractTextToSpeechFeature_setPrototypeOf(subClass, superClass); }\n\nfunction AbstractTextToSpeechFeature_setPrototypeOf(o, p) { AbstractTextToSpeechFeature_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return AbstractTextToSpeechFeature_setPrototypeOf(o, p); }\n\nfunction AbstractTextToSpeechFeature_createSuper(Derived) { var hasNativeReflectConstruct = AbstractTextToSpeechFeature_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = AbstractTextToSpeechFeature_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = AbstractTextToSpeechFeature_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return AbstractTextToSpeechFeature_possibleConstructorReturn(this, result); }; }\n\nfunction AbstractTextToSpeechFeature_possibleConstructorReturn(self, call) { if (call && (AbstractTextToSpeechFeature_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return AbstractTextToSpeechFeature_assertThisInitialized(self); }\n\nfunction AbstractTextToSpeechFeature_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction AbstractTextToSpeechFeature_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction AbstractTextToSpeechFeature_getPrototypeOf(o) { AbstractTextToSpeechFeature_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return AbstractTextToSpeechFeature_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n\n\n/**\n * The Amazon Polly service object.\n * @external Polly\n * @see https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/Polly.html\n */\n\n/**\n * The presigner object that can be used to generate presigned urls for the Polly service.\n * @external Presigner\n * @see https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/Polly/Presigner.html\n */\n// Available options for Polly\n\nvar engines = [\'standard\', \'neural\'];\nvar audioFormats = [\'mp3\', \'ogg_vorbis\', \'pcm\'];\nvar speechmarkTypes = [\'sentence\', \'ssml\', \'viseme\', \'word\'];\nvar sampleRates = {\n  mp3: {\n    rates: [\'8000\', \'16000\', \'22050\', \'24000\'],\n    defaults: {\n      standard: \'2050\',\n      neural: \'2400\'\n    }\n  },\n  pcm: {\n    rates: [\'8000\', \'16000\'],\n    defaults: {\n      standard: \'1600\',\n      neural: \'1600\'\n    }\n  }\n};\nsampleRates.ogg_vorbis = sampleRates.mp3;\nvar awsVersion;\n/**\n * Base class for turning text input into playable audio. There should be one instance\n * per speaker, each instance can play only one piece of text at a time.\n *\n * @extends AbstractHostFeature\n * @abstract\n *\n * @property {(number|undefined)} AWS_VERSION - Gets the version of AWS SDK being\n * used. Will be undefined until [initializeService]{@link AbstractTextToSpeechFeature.initializeService}\n * has been successfully executed.\n * @property {string} [POLLY_MIN_NEURAL_VERSION=\'2.503\'] - Gets the minimum version\n * of the AWS SDK that is necessary to use neural voices with AWS Polly.\n * @property {Object} POLLY_DEFAULTS - Default values to use with calls to {@link external:Polly}.\n * @property {string} [POLLY_DEFAULTS.Engine=\'standard\']\n * @property {Array.<string>} [POLLY_DEFAULTS.LexiconNames=[]]\n * @property {string} [POLLY_DEFAULTS.OutputFormat=\'mp3\']\n * @property {string} [POLLY_DEFAULTS.SampleRate=\'22050\']\n * @property {string} [POLLY_DEFAULTS.Text=\'\']\n * @property {string} [POLLY_DEFAULTS.TextType=\'ssml\']\n * @property {string} [POLLY_DEFAULTS.VoiceId=\'Amy\']\n * @property {string} [POLLY_DEFAULTS.LanguageCode=\'en-GB\']\n * @property {string} [POLLY_DEFAULTS.LanguageName=\'British English\']\n * @property {Array.<string>} [POLLY_VOICES=[]] - An array of voices available in\n * Polly. Will be empty until [initializeService]{@link AbstractTextToSpeechFeature.initializeService}\n * has been successfully executed. See [Polly Documentation]{@link https://docs.aws.amazon.com/polly/latest/dg/voicelist.html}\n * for a full list of available voices.\n * @property {Object} [POLLY_LANGUAGES={}] - An object that maps language names\n * to language codes that are available in Polly. Will be empty until\n * [initializeService]{@link AbstractTextToSpeechFeature.initializeService}\n * has been successfully executed. See [Polly Documentation]{@link https://docs.aws.amazon.com/polly/latest/dg/SupportedLanguage.html}\n * for a full list of available languages and corresponding codes.\n * @property {Object} [POLLY_LANGUAGE_CODES={}] - An object that maps language codes\n * to language names that are available in Polly. Will be empty until\n * [initializeService]{@link AbstractTextToSpeechFeature.initializeService}\n * has been successfully executed. See [Polly Documentation]{@link https://docs.aws.amazon.com/polly/latest/dg/SupportedLanguage.html}\n * for a full list of available languages and corresponding codes.\n * @property {Object} EVENTS - Built-in messages that the feature emits. When the\n * feature is added to a {@link core/HostObject}, event names will be prefixed by the\n * name of the feature class + \'.\'.\n * @property {string} [EVENTS.ready=onReadyEvent] - Message that is emitted after\n * [initializeService]{@link AbstractTextToSpeechFeature.initializeService} has been\n * successfully executed.\n * @property {string} [EVENTS.play=onPlayEvent] - Message that is emitted after\n * each call to [play]{@link AbstractTextToSpeechFeature#play}. The speech that was played\n * is supplied as an argument to listener functions.\n * @property {string} [EVENTS.pause=onPauseEvent] - Message that is emitted after\n * each call to [pause]{@link AbstractTextToSpeechFeature#pause}. The speech that was paused\n * is supplied as an argument to listener functions.\n * @property {string} [EVENTS.resume=onResumeEvent] - Message that is emitted after\n * each call to [resume]{@link AbstractTextToSpeechFeature#resume}. The speech that was\n * resumed is supplied as an argument to listener functions.\n * @property {string} [EVENTS.interrupt=onInterruptEvent] - Message that is emitted\n * if there is a current speech in progress and [play]{@link AbstractTextToSpeechFeature#play}\n * or [resume]{@link AbstractTextToSpeechFeature#resume} are executed for a new speech.\n * The speech that was interrupted is supplied as an argument to listener functions.\n * @property {string} [EVENTS.stop=onStopEvent] - Message that is emitted after\n * each call to [stop]{@link AbstractTextToSpeechFeature#stop} and when a speech reaches\n * the end of playback. The speech that was stopped is supplied as an argument\n * to listener functions.\n * @property {string} [EVENTS.sentence=onSentenceEvent] - Message that is emitted\n * each time a sentence speechmark is encountered whose timestamp matches up with\n * the speech audio\'s current time. The sentence speechmark object is supplied as\n * an argument to listener functions.\n * @property {string} [EVENTS.word=onWordEvent] - Message that is emitted\n * each time a word speechmark is encountered whose timestamp matches up with\n * the speech audio\'s current time. The word speechmark object is supplied as\n * an argument to listener functions.\n * @property {string} [EVENTS.viseme=onVisemeEvent] - Message that is emitted\n * each time a viseme speechmark is encountered whose timestamp matches up with\n * the speech audio\'s current time. The viseme speechmark object is supplied as\n * an argument to listener functions.\n * @property {string} [EVENTS.ssml=onSsmlEvent] - Message that is emitted\n * each time a ssml speechmark is encountered whose timestamp matches up with\n * the speech audio\'s current time. The ssml speechmark object is supplied as\n * an argument to listener functions.\n * @property {Object} SERVICES - AWS services that are necessary for the feature\n * to function.\n * @property {external:Polly} SERVICES.polly - The Polly service that is used\n * to synthesize speechmarks. Will be undefined until [initializeService]{@link AbstractTextToSpeechFeature.initializeService}\n * has been successfully executed\n * @property {external:Presigner} SERVICES.presigner - The Polly Presigner\n * object that is used to synthesize speech audio. Will be undefined until\n * [initializeService]{@link AbstractTextToSpeechFeature.initializeService}\n * has been successfully executed.\n */\n\nvar AbstractTextToSpeechFeature = /*#__PURE__*/function (_AbstractHostFeature) {\n  AbstractTextToSpeechFeature_inherits(AbstractTextToSpeechFeature, _AbstractHostFeature);\n\n  var _super = AbstractTextToSpeechFeature_createSuper(AbstractTextToSpeechFeature);\n\n  /**\n   * @constructor\n   *\n   * @param {core/HostObject} host - Host object managing the feature.\n   * @param {Object=} options - Options that will be sent to Polly for each speech.\n   * @param {string=} options.voice - The name of the Polly voice to use for all speech.\n   * @param {string=} options.engine - The name of the Polly engine to use for all speech.\n   * @param {string=} options.language - The name of the language to use for all speech.\n   * @param {audioFormat} [options.audioFormat=\'mp3\'] - The format to use for generated\n   * audio for all speeches.\n   * @param {string=} options.sampleRate - The sample rate for audio files for all\n   * speeches.\n   * @param {number} [options.speechmarkOffset=0] - Amount of time in seconds to\n   * offset speechmark event emission from the audio.\n   * @param {number} [options.minEndMarkDuration=.05] - The minimum amount of time\n   * in seconds that the last speechmark of each type in a speech can have its\n   * duration property set to.\n   * @param {number} [options.volume=1] - The default volume to play speech audio\n   * with.\n   * @param {boolean} [options.isGlobal=false] - Whether the audio source should default\n   * to global regardless of whether or not it is attached to an object.\n   */\n  function AbstractTextToSpeechFeature(host) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      voice: undefined,\n      engine: undefined,\n      language: undefined,\n      audioFormat: \'mp3\',\n      sampleRate: undefined,\n      speechmarkOffset: 0,\n      minEndMarkDuration: 0.05,\n      volume: 1,\n      isGlobal: false\n    };\n\n    AbstractTextToSpeechFeature_classCallCheck(this, AbstractTextToSpeechFeature);\n\n    _this = _super.call(this, host);\n    _this._speechCache = {};\n    _this._currentSpeech = null;\n    _this._currentPromise = null;\n    _this._isValidated = false;\n    _this.speechmarkOffset = Number.isNaN(Number(options.speechmarkOffset)) ? 0 : Number(options.speechmarkOffset);\n    _this.minEndMarkDuration = Number.isNaN(Number(options.minEndMarkDuration)) ? 0 : Number(options.minEndMarkDuration);\n    _this.volume = Number.isNaN(Number(options.volume)) ? 1 : Number(options.volume);\n    _this._isGlobal = options.isGlobal || false;\n    _this._promises = {\n      volume: core_Deferred.resolve()\n    };\n    _this._volumePaused = false; // Set default options for each speech\n\n    _this._voice = options.voice || _this.constructor.POLLY_DEFAULTS.VoiceId;\n    _this._language = options.language || _this.constructor.POLLY_DEFAULTS.LanguageName;\n    _this._engine = engines.includes(options.engine) ? options.engine : _this.constructor.POLLY_DEFAULTS.Engine;\n    _this._audioFormat = audioFormats.includes(options.audioFormat) ? options.audioFormat : _this.constructor.POLLY_DEFAULTS.OutputFormat;\n    _this._sampleRate = sampleRates[_this._audioFormat].rates.includes(options.sampleRate) ? options.sampleRate : _this.constructor.POLLY_DEFAULTS.SampleRate;\n    return _this;\n  }\n  /**\n   * Store Polly, Presigner and AWS SDK Version for use across all instances.\n   *\n   * @param {external:Polly} polly - Polly instance to use to generate speechmarks.\n   * @param {external:Presigner} presigner - Presigner instance to use to generate\n   * audio URLs.\n   * @param {string} version - Version of the AWS SDK to use to validate voice options.\n   */\n\n\n  AbstractTextToSpeechFeature_createClass(AbstractTextToSpeechFeature, [{\n    key: "currentSpeech",\n    get:\n    /**\n     * Gets the text of the currently playing speech.\n     *\n     * @readonly\n     * @type {string}\n     */\n    function get() {\n      if (this._currentSpeech) {\n        return this._currentSpeech.text;\n      } else {\n        return null;\n      }\n    }\n    /**\n     * Gets and sets the number of seconds to offset speechmark emission.\n     *\n     * @type {number}\n     */\n\n  }, {\n    key: "speechmarkOffset",\n    get: function get() {\n      return this._speechmarkOffset;\n    },\n    set: function set(offset) {\n      this._speechmarkOffset = offset;\n\n      if (this._currentSpeech) {\n        this._currentSpeech.speechmarkOffset = offset;\n      }\n    }\n    /**\n     * Gets and sets the The minimum amount of time in seconds that the last\n     * speechmark of each type in a speech can have its duration property set to.\n     *\n     * @type number\n     */\n\n  }, {\n    key: "minEndMarkDuration",\n    get: function get() {\n      return this._minEndMarkDuration / 1000;\n    },\n    set: function set(duration) {\n      this._minEndMarkDuration = duration * 1000;\n    }\n    /**\n     * Appends the Sumerian Hosts custom user-agent to a string if it is not\n     * already present.\n     *\n     * @private\n     *\n     * @param {string} currentUserAgent - String to append to if needed.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: "_validateEngine",\n    value:\n    /**\n     * Checks if a given engine type is compatible with the AWS SDK version. If it\n     * is, return the original value. Otherwise return a default.\n     *\n     * @private\n     *\n     * @param {string} engine - The type of Polly voice engine to validate.\n     *\n     * @returns {string}\n     */\n    function _validateEngine(engine) {\n      // Default to the standard engine if neural is not available for this version\n      if (engine === undefined || this.constructor.AWS_VERSION < this.constructor.POLLY_MIN_NEURAL_VERSION) {\n        engine = this.constructor.POLLY_DEFAULTS.Engine;\n      }\n\n      return engine;\n    }\n    /**\n     * Checks if a given audio format type is compatible with Polly. If it is, return\n     * the original value. Otherwise return a default.\n     *\n     * @private\n     *\n     * @param {string} engine - The type of Polly voice engine to validate.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: "_validateFormat",\n    value: function _validateFormat(format) {\n      if (format === undefined || !audioFormats.includes(format)) {\n        format = this.constructor.POLLY_DEFAULTS.OutputFormat;\n      }\n\n      return format;\n    }\n    /**\n     * Checks if a given audio sampling rate is compatible with the current audio\n     * format. If it is, return the original value. Otherwise return a default.\n     *\n     * @private\n     *\n     * @param {string} engine - The type of Polly voice engine to validate.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: "_validateRate",\n    value: function _validateRate(rate) {\n      // Use default if specified sample rate is not valid for the audio format\n      if (rate === undefined || !sampleRates[this._audioFormat].rates.includes(rate)) {\n        rate = sampleRates[this._audioFormat].defaults[this._engine];\n      }\n\n      return rate;\n    }\n    /**\n     * Checks if a given Polly voice id is compatible with the current Polly engine.\n     * If it is, return the original value. Otherwise return a default.\n     *\n     * @private\n     *\n     * @param {string} engine - The type of Polly voice engine to validate.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: "_validateVoice",\n    value: function _validateVoice(voiceId) {\n      var voice = this.constructor.POLLY_VOICES.find(function (v) {\n        return v.Id === voiceId;\n      }); // Use the default voice if the voice isn\'t supported by the engine\n\n      if (voice === undefined || !voice.SupportedEngines.includes(this._engine)) {\n        voiceId = this.constructor.POLLY_DEFAULTS.VoiceId;\n      }\n\n      return voiceId;\n    }\n    /**\n     * Checks if a given Polly language is compatible with the current Polly voice.\n     * If it is, return the original value. Otherwise return a default.\n     *\n     * @private\n     *\n     * @param {string} engine - The type of Polly voice engine to validate.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: "_validateLanguage",\n    value: function _validateLanguage(language) {\n      var _this2 = this;\n\n      var voice = this.constructor.POLLY_VOICES.find(function (v) {\n        return v.Id === _this2._voice;\n      });\n      var languageCode = this.constructor.POLLY_LANGUAGES[language]; // Find the languages available for the current voice\n\n      var availableCodes = [voice.LanguageCode];\n\n      if (voice.AdditionalLanguageCodes) {\n        availableCodes.push.apply(availableCodes, AbstractTextToSpeechFeature_toConsumableArray(voice.AdditionalLanguageCodes));\n      } // If the current voice doesn\'t support the language, use its default\n\n\n      if (!availableCodes.includes(languageCode)) {\n        language = this.constructor.POLLY_LANGUAGE_CODES[voice.LanguageCode];\n      }\n\n      return language;\n    }\n    /**\n     * Validate the current Polly options to make sure they are compatible with each\n     * other.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_validate",\n    value: function _validate() {\n      // Validate speech parameters\n      this._engine = this._validateEngine(this._engine);\n      this._audioFormat = this._validateFormat(this._audioFormat);\n      this._sampleRate = this._validateRate(this._sampleRate);\n      this._voice = this._validateVoice(this._voice);\n      this._language = this._validateLanguage(this._language);\n      this._isValidated = true;\n    }\n    /**\n     * Return an object containing parameters compatible with Polly.synthesizeSpeech.\n     *\n     * @private\n     *\n     * @returns {Object}\n     */\n\n  }, {\n    key: "_getConfig",\n    value: function _getConfig() {\n      // Make sure parameters have been validated\n      if (this.constructor.isReady && !this._isValidated) {\n        this._validate();\n      } // Create a config object compatible with Polly\n\n\n      return {\n        Engine: this._engine,\n        OutputFormat: this._audioFormat,\n        SampleRate: this._sampleRate,\n        VoiceId: this._voice,\n        LanguageCode: this.constructor.POLLY_LANGUAGES[this._language]\n      };\n    }\n    /**\n     * Update Polly parameters with options from a given config. All stored speeches\n     * will be updated to use the new parameters, unless the speech text is contained\n     * in the \'skipSpeeches\' parameter.\n     *\n     * @private\n     *\n     * @param {Object} config - Polly parameter options to overwrite.\n     * @param {Array.<string>} skipSpeeches - Text of any speeches that should not\n     * have parameters updated.\n     *\n     * @returns {Object}\n     */\n\n  }, {\n    key: "_updateConfig",\n    value: function _updateConfig(config) {\n      var _this3 = this;\n\n      var skipSpeeches = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n      var currentConfig = this._getConfig();\n\n      if (!config) {\n        return currentConfig;\n      }\n\n      this._isValidated = false;\n      var currentConfigStr = JSON.stringify(currentConfig); // Update options\n\n      if (config.Engine) {\n        this._engine = config.Engine;\n      }\n\n      if (config.audioFormat) {\n        this._audioFormat = config.audioFormat;\n      }\n\n      if (config.SampleRate) {\n        this._sampleRate = config.SampleRate;\n      }\n\n      if (config.VoiceId) {\n        this._voice = config.VoiceId;\n      }\n\n      if (config.Language) {\n        this._language = config.Language;\n      } // Validate the config\n\n\n      var validConfig = this._getConfig(); // Exit if nothing has changed\n\n\n      var configStr = JSON.stringify(validConfig);\n\n      if (currentConfigStr === configStr) {\n        this._isValidated = true;\n        return validConfig;\n      } // Update all cached configs\n\n\n      Object.entries(this._speechCache).forEach(function (_ref) {\n        var _ref2 = AbstractTextToSpeechFeature_slicedToArray(_ref, 2),\n            text = _ref2[0],\n            speech = _ref2[1];\n\n        // Check if this is a skipped speech\n        if (skipSpeeches.includes(text)) {\n          return;\n        }\n\n        var speechConfigStr = JSON.stringify(speech.config); // Update the speech with new parameters\n\n        if (speechConfigStr !== configStr) {\n          _this3._updateSpeech(text, validConfig);\n        }\n      });\n      return validConfig;\n    }\n    /**\n     * Update an existing speech, or add a new speech with new Polly parameters with\n     * options from a given config.\n     *\n     * @private\n     *\n     * @param {string} text - The text of the speech to update.\n     * @param {Object} config - Polly parameter options to update.\n     * @param {boolean} [force=false] - Whether to force the speech to be updated\n     * if no parameters have changes.\n     *\n     * @returns {AbstractSpeech}\n     */\n\n  }, {\n    key: "_updateSpeech",\n    value: function _updateSpeech(text, config) {\n      var _this4 = this;\n\n      var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var speech = this._speechCache[text] || {}; // Exit if nothing has changed and force is false\n\n      if (!force && config !== undefined && speech.config && JSON.stringify(config) === JSON.stringify(speech.config)) {\n        return speech;\n      } // Create separate parameters for audio and speechmark generation\n\n\n      var audioParams = AbstractTextToSpeechFeature_objectSpread(AbstractTextToSpeechFeature_objectSpread({}, config), {}, {\n        Text: text,\n        TextType: \'ssml\'\n      });\n\n      var speechmarkParams = AbstractTextToSpeechFeature_objectSpread(AbstractTextToSpeechFeature_objectSpread({}, audioParams), {}, {\n        OutputFormat: \'json\',\n        SpeechMarkTypes: speechmarkTypes\n      }); // Generate audio and speechmarks\n\n\n      speech.config = config;\n      speech.promise = Promise.all([this._synthesizeSpeechmarks(speechmarkParams), this._synthesizeAudio(audioParams)]).then(function (results) {\n        return _this4._createSpeech.apply(_this4, [text].concat(AbstractTextToSpeechFeature_toConsumableArray(results)));\n      });\n      this._speechCache[text] = speech;\n      return speech;\n    }\n    /**\n     * Create a new Speech object for the speaker.\n     *\n     * @private\n     *\n     * @param {TextToSpeech} speaker - The TextToSpeech instance that will own the speech.\n     * @param {string} text - Text of the speech.\n     * @param {Object} speechmarks - Speechmarks for the speech.\n     * @param {Object} audioConfig - Audio for the speech.\n     *\n     * @returns {AbstractSpeech}\n     */\n\n  }, {\n    key: "_createSpeech",\n    value: function _createSpeech(text, speechmarks, audioConfig) {\n      return new awspack_AbstractSpeech(this, text, speechmarks, audioConfig);\n    }\n    /**\n     * Create presigned URL of speech audio for the given speech text.\n     *\n     * @private\n     *\n     * @param {Object} params - Parameters object compatible with Polly.synthesizeSpeech.\n     *\n     * @returns {Deferred} Resolves with an object containing the audio URL.\n     */\n\n  }, {\n    key: "_synthesizeAudio",\n    value: function _synthesizeAudio(params) {\n      var _this5 = this;\n\n      return new core_Deferred(function (resolve, reject) {\n        _this5.constructor.SERVICES.presigner.getSynthesizeSpeechUrl(params, function (error, url) {\n          if (!error) {\n            resolve({\n              url: url\n            });\n          } else {\n            reject(error);\n          }\n        });\n      });\n    }\n    /**\n     * Retrieves and parses speechmarks for the given speech text.\n     *\n     * @private\n     *\n     * @param {Object} params - Parameters object compatible with Polly.synthesizeSpeech.\n     *\n     * @returns {Deferred} Resolves with an array of speechmark objects\n     */\n\n  }, {\n    key: "_synthesizeSpeechmarks",\n    value: function _synthesizeSpeechmarks(params) {\n      var _this6 = this;\n\n      return this.constructor.SERVICES.polly.synthesizeSpeech(params).promise().then(function (result) {\n        // Convert charcodes to string\n        var jsonString = JSON.stringify(result.AudioStream);\n        var json = JSON.parse(jsonString);\n        var dataStr = json.data.map(function (c) {\n          return String.fromCharCode(c);\n        }).join(\'\');\n        var markTypes = {\n          sentence: [],\n          word: [],\n          viseme: [],\n          ssml: []\n        };\n        var endMarkTypes = {\n          sentence: null,\n          word: null,\n          viseme: null,\n          ssml: null\n        }; // Split by enclosing {} to create speechmark objects\n\n        var speechMarks = AbstractTextToSpeechFeature_toConsumableArray(dataStr.matchAll(/\\{.*?\\}(?=\\n|$)/gm)).map(function (match) {\n          var mark = JSON.parse(match[0]); // Set the duration of the last speechmark stored matching this one\'s type\n\n          var numMarks = markTypes[mark.type].length;\n\n          if (numMarks > 0) {\n            var lastMark = markTypes[mark.type][numMarks - 1];\n            lastMark.duration = mark.time - lastMark.time;\n          }\n\n          markTypes[mark.type].push(mark);\n          endMarkTypes[mark.type] = mark;\n          return mark;\n        }); // Find the time of the latest speechmark\n\n\n        var endTimes = [];\n\n        if (endMarkTypes.sentence) {\n          endTimes.push(endMarkTypes.sentence.time);\n        }\n\n        if (endMarkTypes.word) {\n          endTimes.push(endMarkTypes.word.time);\n        }\n\n        if (endMarkTypes.viseme) {\n          endTimes.push(endMarkTypes.viseme.time);\n        }\n\n        if (endMarkTypes.ssml) {\n          endTimes.push(endMarkTypes.ssml.time);\n        }\n\n        var endTime = Math.max.apply(Math, endTimes); // Calculate duration for the ending speechMarks of each type\n\n        if (endMarkTypes.sentence) {\n          endMarkTypes.sentence.duration = Math.max(_this6._minEndMarkDuration, endTime - endMarkTypes.sentence.time);\n        }\n\n        if (endMarkTypes.word) {\n          endMarkTypes.word.duration = Math.max(_this6._minEndMarkDuration, endTime - endMarkTypes.word.time);\n        }\n\n        if (endMarkTypes.viseme) {\n          endMarkTypes.viseme.duration = Math.max(_this6._minEndMarkDuration, endTime - endMarkTypes.viseme.time);\n        }\n\n        if (endMarkTypes.ssml) {\n          endMarkTypes.ssml.duration = Math.max(_this6._minEndMarkDuration, endTime - endMarkTypes.ssml.time);\n        }\n\n        return speechMarks;\n      });\n    }\n    /**\n     * Returns a Speech object that has the given text.\n     *\n     * @private\n     *\n     * @param {string} text - The text content of the Speech.\n     * @param {Object=} config - Options to update the Speech with.\n     *\n     * @returns {Deferred} Resolves with Speech or null;\n     */\n\n  }, {\n    key: "_getSpeech",\n    value: function _getSpeech(text, config) {\n      // Make sure AWS services exist\n      if (!this.constructor.isReady) {\n        var e = \'AWS services have not been initialized.\';\n        return core_Deferred.reject(e);\n      } // Make sure its possible to generate speeches\n\n\n      if (!text) {\n        var _e2 = \'Cannot play a speech with no text.\';\n        return core_Deferred.reject(_e2);\n      } // Update the speech with options\n\n\n      text = awspack_TextToSpeechUtils.validateText(text);\n      config = this._updateConfig(config, text);\n      return this._updateSpeech(text, config).promise;\n    }\n    /**\n     * Adds a namespace to the host with the name of the feature to contain properties\n     * and methods from the feature that users of the host need access to.\n     *\n     * @see TextToSpeechFeature\n     */\n\n  }, {\n    key: "installApi",\n    value: function installApi() {\n      var _this7 = this;\n\n      /**\n       * @inner\n       * @namespace TextToSpeechFeature\n       */\n      var api = AbstractTextToSpeechFeature_get(AbstractTextToSpeechFeature_getPrototypeOf(AbstractTextToSpeechFeature.prototype), "installApi", this).call(this);\n\n      Object.assign(api, {\n        /**\n         * @memberof TextToSpeechFeature\n         * @instance\n         * @method\n         * @see AbstractTextToSpeechFeature#play\n         */\n        play: this.play.bind(this),\n\n        /**\n         * @memberof TextToSpeechFeature\n         * @instance\n         * @method\n         * @see AbstractTextToSpeechFeature#pause\n         */\n        pause: this.pause.bind(this),\n\n        /**\n         * @memberof TextToSpeechFeature\n         * @instance\n         * @method\n         * @see AbstractTextToSpeechFeature#resume\n         */\n        resume: this.resume.bind(this),\n\n        /**\n         * @memberof TextToSpeechFeature\n         * @instance\n         * @method\n         * @see AbstractTextToSpeechFeature#stop\n         */\n        stop: this.stop.bind(this),\n\n        /**\n         * @memberof TextToSpeechFeature\n         * @instance\n         * @method\n         * @see AbstractTextToSpeechFeature#getVolume\n         */\n        getVolume: this.getVolume.bind(this),\n\n        /**\n         * @memberof TextToSpeechFeature\n         * @instance\n         * @method\n         * @see AbstractTextToSpeechFeature#setVolume\n         */\n        setVolume: this.setVolume.bind(this),\n\n        /**\n         * @memberof TextToSpeechFeature\n         * @instance\n         * @method\n         * @see AbstractTextToSpeechFeature#pauseVolume\n         */\n        pauseVolume: this.pauseVolume.bind(this),\n\n        /**\n         * @memberof TextToSpeechFeature\n         * @instance\n         * @method\n         * @see AbstractTextToSpeechFeature#resumeVolume\n         */\n        resumeVolume: this.resumeVolume.bind(this)\n      });\n      Object.defineProperties(api, {\n        /**\n         * @memberof TextToSpeechFeature\n         * @instance\n         * @see AbstractTextToSpeechFeature#speechmarkOffset\n         */\n        speechmarkOffset: {\n          get: function get() {\n            return _this7.speechmarkOffset;\n          },\n          set: function set(offset) {\n            _this7.speechmarkOffset = offset;\n          }\n        }\n      });\n      return api;\n    }\n    /**\n     * Gets and sets the volume used for all audio clips played by the speaker.\n     *\n     * @type {number}\n     */\n\n  }, {\n    key: "volume",\n    get: function get() {\n      return this._volume;\n    }\n    /**\n     * Gets whether or not the speaker\'s volume value is currently being tweened.\n     *\n     * @readonly\n     * @type {boolean}\n     */\n    ,\n    set: function set(volume) {\n      this._volume = core_MathUtils.clamp(volume);\n    }\n  }, {\n    key: "volumePending",\n    get: function get() {\n      return this._promises.volume && this._promises.volume.pending;\n    }\n    /**\n     * Gets the volume used for all audio clips played by the speaker.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: "getVolume",\n    value: function getVolume() {\n      return this.volume;\n    }\n    /**\n     * Updates the volume used for all audio clips played by the speaker over time.\n     *\n     * @param {number} volume - Target volume value.\n     * @param {number} [seconds=0] - Amount of time it will take to reach the target\n     * volume.\n     * @param {Function=} easingFn - Easing function used for interpolation.\n     *\n     * @returns {Deferred}\n     */\n\n  }, {\n    key: "setVolume",\n    value: function setVolume(volume) {\n      var seconds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var easingFn = arguments.length > 2 ? arguments[2] : undefined;\n\n      if (this.volumePending) {\n        this._promises.volume.cancel();\n      }\n\n      volume = core_MathUtils.clamp(volume);\n      this._promises.volume = animpack_AnimationUtils.interpolateProperty(this, \'volume\', volume, {\n        seconds: seconds,\n        easingFn: easingFn\n      });\n      return this._promises.volume;\n    }\n    /**\n     * Pause interpolation happening on the speaker\'s volume property.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "pauseVolume",\n    value: function pauseVolume() {\n      this._volumePaused = true;\n      return this.volumePending;\n    }\n    /**\n     * Resume any interpolation happening on the speaker\'s volume property.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: "resumeVolume",\n    value: function resumeVolume() {\n      this._volumePaused = false;\n      return this.volumePending;\n    }\n    /**\n     * Update the currently playing speech.\n     *\n     * @param {number} deltaTime - Time since the last update.\n     */\n\n  }, {\n    key: "update",\n    value: function update(deltaTime) {\n      if (!this._volumePaused) {\n        this._promises.volume.execute(deltaTime);\n      }\n\n      if (this._currentSpeech && this._currentSpeech.playing) {\n        this._currentSpeech.volume = this._volume;\n\n        this._currentSpeech.update(this._host.now);\n\n        AbstractTextToSpeechFeature_get(AbstractTextToSpeechFeature_getPrototypeOf(AbstractTextToSpeechFeature.prototype), "update", this).call(this, deltaTime);\n      }\n    }\n    /**\n     * Set the current speech to a new asset and update the speech\'s speechmark\n     * offset value to match that of the feature.\n     *\n     * @private\n     *\n     * @param {AbstractSpeech} speech - Speech to set as current.\n     */\n\n  }, {\n    key: "_setCurrentSpeech",\n    value: function _setCurrentSpeech(speech) {\n      speech.speechmarkOffset = this._speechmarkOffset;\n      this._currentSpeech = speech;\n    }\n    /**\n     * Create a promise that will play/resume a speech with the given text after\n     * the audio context attempts to resume and speech audio is retrieved from Polly.\n     *\n     * @private\n     *\n     * @param {string} text - The text of the new speech to play.\n     * @param {Object=} config - Optional parameters for the speech.\n     * @param {string} [playMethod = \'play\'] - Method to execute on the resulting\n     * Speech object. Valid options are \'play\' and \'resume\'.\n     */\n\n  }, {\n    key: "_startSpeech",\n    value: function _startSpeech(text, config) {\n      var _this8 = this;\n\n      var playMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \'play\';\n\n      // If no text is provided, try to use the current speech\n      if (text === undefined && playMethod === \'resume\' && this._currentSpeech) {\n        text = this._currentSpeech.text;\n      }\n\n      var currentPromise = this._currentPromise || {\n        play: new core_Deferred(undefined, function () {\n          currentPromise.speech.cancel();\n        }, function () {\n          currentPromise.speech.cancel();\n        }, function () {\n          currentPromise.speech.cancel();\n        }),\n        speech: new core_Deferred()\n      };\n      this._currentPromise = currentPromise;\n\n      this._getSpeech(text, config).then(function (speech) {\n        // Exit if the promise is no longer pending because of user interaction\n        if (!currentPromise.play.pending) {\n          return;\n        } else if (_this8._currentPromise !== currentPromise) {\n          // Cancel if another call to play has already been made\n          currentPromise.play.cancel();\n          return;\n        } // Reset current speech when the speech ends\n\n\n        var onFinish = function onFinish() {\n          _this8._currentSpeech = null;\n          _this8._currentPromise = null;\n        }; // Cancel the currently playing speech\n\n\n        if (_this8._currentSpeech && _this8._currentSpeech.playing) {\n          if (playMethod === \'play\') {\n            _this8._currentSpeech.cancel();\n          } else if (playMethod === \'resume\' && _this8._currentSpeech.audio !== speech.audio) {\n            _this8._currentSpeech.cancel();\n          }\n        }\n\n        _this8._setCurrentSpeech(speech); // Play the speech\n\n\n        currentPromise.speech = speech[playMethod](_this8._host.now, onFinish, onFinish, onFinish);\n        currentPromise.speech.then(function () {\n          if (currentPromise.speech.resolved) {\n            currentPromise.play.resolve();\n          } else {\n            currentPromise.play.cancel();\n          }\n        })["catch"](function (error) {\n          currentPromise.play.reject(error);\n        });\n      })["catch"](function (e) {\n        e = "Cannot ".concat(playMethod, " speech ").concat(text, " on host ").concat(_this8.host.id, ". ").concat(e);\n        currentPromise.play.reject(e);\n      });\n\n      return currentPromise.play;\n    }\n    /**\n     * Stop any speeches currently playing and play a new speech from the beginning.\n     *\n     * @param {string} text - The text of the new speech to play.\n     * @param {Object=} config - Optional parameters for the speech.\n     *\n     * @returns {Deferred}\n     */\n\n  }, {\n    key: "play",\n    value: function play(text, config) {\n      return this._startSpeech(text, config, \'play\');\n    }\n    /**\n     * If a speech is currently playing, pause it at the current time.\n     */\n\n  }, {\n    key: "pause",\n    value: function pause() {\n      if (this._currentSpeech && this._currentSpeech.playing) {\n        this._currentSpeech.pause(this._host.now);\n      } else {\n        console.warn("Cannot pause speech on host ".concat(this.host.id, ". No speech is currently playing"));\n      }\n    }\n    /**\n     * Stop any speeches currently playing and resume a new speech from the current\n     * time.\n     *\n     * @param {string=} text - The text of the new speech to play. If undefined and\n     * there is a current speech that is paused, the current speech will be resumed.\n     * @param {Object=} config - Optional parameters for the speech.\n     *\n     * @returns {Deferred}\n     */\n\n  }, {\n    key: "resume",\n    value: function resume(text, config) {\n      return this._startSpeech(text, config, \'resume\');\n    }\n    /**\n     * If a speech is currently playing, stop playback and reset time.\n     */\n\n  }, {\n    key: "stop",\n    value: function stop() {\n      if (this._currentSpeech && this._currentSpeech.playing) {\n        this._currentSpeech.stop();\n\n        this._currentSpeech = null;\n      } else {\n        console.warn("Cannot stop speech on host ".concat(this.host.id, ". No speech is currently playing."));\n      }\n    }\n  }, {\n    key: "discard",\n    value: function discard() {\n      if (this._currentSpeech && this._currentSpeech.playing) {\n        this._currentSpeech.stop();\n      }\n\n      delete this._speechCache;\n\n      AbstractTextToSpeechFeature_get(AbstractTextToSpeechFeature_getPrototypeOf(AbstractTextToSpeechFeature.prototype), "discard", this).call(this);\n    }\n  }], [{\n    key: "initializeService",\n    value: function initializeService(polly, presigner, version) {\n      var _this9 = this;\n\n      // Make sure all were defined\n      if (polly === undefined || presigner === undefined || version === undefined) {\n        throw new Error(\'Cannot initialize TextToSpeech feature. All arguments must be defined.\');\n      } // Add sumerian hosts user-agent\n\n\n      if (polly.config) {\n        polly.config.customUserAgent = this._withCustomUserAgent(polly.config.customUserAgent);\n      }\n\n      if (presigner.service && presigner.service.config) {\n        presigner.service.config.customUserAgent = this._withCustomUserAgent(presigner.service.config.customUserAgent);\n      }\n\n      this._isReady = false; // Store parameters\n\n      this.SERVICES.polly = polly;\n      this.SERVICES.presigner = presigner;\n      awsVersion = version; // Clear the current polly objects\n\n      var availableVoices = this.POLLY_VOICES;\n      availableVoices.length = 0;\n      var availableLanguages = this.POLLY_LANGUAGES;\n      Object.keys(availableLanguages).forEach(function (name) {\n        delete availableLanguages[name];\n      });\n      var availableLanguageCodes = this.POLLY_LANGUAGE_CODES;\n      Object.keys(availableLanguageCodes).forEach(function (name) {\n        delete availableLanguageCodes[name];\n      }); // Re-populate according to version\n\n      var minNeuralSdk = this.POLLY_MIN_NEURAL_VERSION;\n      return this.SERVICES.polly.describeVoices().promise().then(function (response) {\n        var allCodes = {};\n        response.Voices.forEach(function (voice) {\n          if (voice.SupportedEngines.includes(\'standard\') || version >= minNeuralSdk) {\n            availableVoices.push(voice);\n          }\n\n          availableVoices.forEach(function (voice) {\n            availableLanguages[voice.LanguageName] = voice.LanguageCode;\n            allCodes[voice.LanguageCode] = voice.LanguageName;\n          });\n        });\n        Object.entries(availableLanguages).forEach(function (_ref3) {\n          var _ref4 = AbstractTextToSpeechFeature_slicedToArray(_ref3, 2),\n              name = _ref4[0],\n              code = _ref4[1];\n\n          availableLanguageCodes[code] = name;\n        }); // Notify that we\'re ready to generate speeches\n\n        _this9._isReady = true;\n\n        _this9.emit(_this9.EVENTS.ready);\n      });\n    }\n    /**\n     * Indicates whether or not the class is capable of generating speech audio. Polly,\n     * Presigner and AWS SDK version number must have been defined using\n     * [initializeService]{@link AbstractTextToSpeechFeature.initializeService}.\n     *\n     * @readonly\n     * @type {boolean}\n     */\n\n  }, {\n    key: "isReady",\n    get: function get() {\n      return this._isReady;\n    }\n  }, {\n    key: "_withCustomUserAgent",\n    value: function _withCustomUserAgent(currentUserAgent) {\n      var sumerianHostsUserAgent = \'request-source/SumerianHosts\';\n\n      if (currentUserAgent == null) {\n        return sumerianHostsUserAgent;\n      }\n\n      if (currentUserAgent.indexOf(sumerianHostsUserAgent) !== -1) {\n        return currentUserAgent;\n      }\n\n      return currentUserAgent.concat(\' \', sumerianHostsUserAgent);\n    }\n  }]);\n\n  return AbstractTextToSpeechFeature;\n}(core_AbstractHostFeature);\n\nObject.defineProperties(AbstractTextToSpeechFeature, {\n  AWS_VERSION: {\n    get: function get() {\n      return awsVersion;\n    }\n  },\n  POLLY_MIN_NEURAL_VERSION: {\n    value: \'2.503\',\n    writable: false\n  },\n  POLLY_DEFAULTS: {\n    value: {\n      Engine: \'standard\',\n      LexiconNames: [],\n      OutputFormat: \'mp3\',\n      SampleRate: \'22050\',\n      Text: \'\',\n      TextType: \'ssml\',\n      VoiceId: \'Amy\',\n      LanguageCode: \'en-GB\',\n      LanguageName: \'British English\'\n    },\n    writable: false\n  },\n  POLLY_VOICES: {\n    value: [],\n    writable: false\n  },\n  POLLY_LANGUAGES: {\n    value: {},\n    writable: false\n  },\n  POLLY_LANGUAGE_CODES: {\n    value: {},\n    writable: false\n  },\n  _isReady: {\n    value: false,\n    writable: true\n  },\n  EVENTS: {\n    value: AbstractTextToSpeechFeature_objectSpread(AbstractTextToSpeechFeature_objectSpread({}, Object.getPrototypeOf(AbstractTextToSpeechFeature).EVENTS), {}, {\n      ready: \'onReadyEvent\',\n      play: \'onPlayEvent\',\n      pause: \'onPauseEvent\',\n      resume: \'onResumeEvent\',\n      interrupt: \'onInterruptEvent\',\n      stop: \'onStopEvent\',\n      sentence: \'onSentenceEvent\',\n      word: \'onWordEvent\',\n      viseme: \'onVisemeEvent\',\n      ssml: \'onSsmlEvent\'\n    })\n  },\n  SERVICES: {\n    value: AbstractTextToSpeechFeature_objectSpread(AbstractTextToSpeechFeature_objectSpread({}, Object.getPrototypeOf(AbstractTextToSpeechFeature).SERVICES), {}, {\n      polly: undefined,\n      presigner: undefined\n    })\n  }\n});\n/* harmony default export */ const awspack_AbstractTextToSpeechFeature = (AbstractTextToSpeechFeature);\n;// CONCATENATED MODULE: ./src/core/awspack/TextToSpeechFeature.js\nfunction TextToSpeechFeature_typeof(obj) { "@babel/helpers - typeof"; return TextToSpeechFeature_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, TextToSpeechFeature_typeof(obj); }\n\nfunction TextToSpeechFeature_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction TextToSpeechFeature_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction TextToSpeechFeature_createClass(Constructor, protoProps, staticProps) { if (protoProps) TextToSpeechFeature_defineProperties(Constructor.prototype, protoProps); if (staticProps) TextToSpeechFeature_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction TextToSpeechFeature_get() { if (typeof Reflect !== "undefined" && Reflect.get) { TextToSpeechFeature_get = Reflect.get; } else { TextToSpeechFeature_get = function _get(target, property, receiver) { var base = TextToSpeechFeature_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return TextToSpeechFeature_get.apply(this, arguments); }\n\nfunction TextToSpeechFeature_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = TextToSpeechFeature_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction TextToSpeechFeature_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) TextToSpeechFeature_setPrototypeOf(subClass, superClass); }\n\nfunction TextToSpeechFeature_setPrototypeOf(o, p) { TextToSpeechFeature_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return TextToSpeechFeature_setPrototypeOf(o, p); }\n\nfunction TextToSpeechFeature_createSuper(Derived) { var hasNativeReflectConstruct = TextToSpeechFeature_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = TextToSpeechFeature_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = TextToSpeechFeature_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return TextToSpeechFeature_possibleConstructorReturn(this, result); }; }\n\nfunction TextToSpeechFeature_possibleConstructorReturn(self, call) { if (call && (TextToSpeechFeature_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return TextToSpeechFeature_assertThisInitialized(self); }\n\nfunction TextToSpeechFeature_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction TextToSpeechFeature_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction TextToSpeechFeature_getPrototypeOf(o) { TextToSpeechFeature_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return TextToSpeechFeature_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n/**\n * @extends AbstractTextToSpeechFeature\n * @alias core/TextToSpeechFeature\n */\n\nvar TextToSpeechFeature = /*#__PURE__*/function (_AbstractTextToSpeech) {\n  TextToSpeechFeature_inherits(TextToSpeechFeature, _AbstractTextToSpeech);\n\n  var _super = TextToSpeechFeature_createSuper(TextToSpeechFeature);\n\n  function TextToSpeechFeature() {\n    var _this;\n\n    TextToSpeechFeature_classCallCheck(this, TextToSpeechFeature);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this._enabled = false;\n\n    _this._setAudioContext();\n\n    _this._observeAudioContext();\n\n    return _this;\n  }\n  /**\n   * Store the audio context that will be used to ensure audio can be played.\n   *\n   * @private\n   */\n\n\n  TextToSpeechFeature_createClass(TextToSpeechFeature, [{\n    key: "_setAudioContext",\n    value: function _setAudioContext() {\n      this._audioContext = new AudioContext();\n    }\n    /**\n     * Listen for state changes on the audio context to determine whether the feature\n     * is enabled.\n     *\n     * @private\n     */\n\n  }, {\n    key: "_observeAudioContext",\n    value: function _observeAudioContext() {\n      var _this2 = this;\n\n      if (this._audioContext) {\n        this._audioContext.onstatechange = function () {\n          if (_this2._audioContext.state === \'running\') {\n            _this2._enabled = true;\n          } else {\n            _this2._enabled = false;\n            console.warn(\'The audio context is not running. Speech will not be able to be played until it is resumed. Use the "TextToSpeechFeature.resumeAudio" method to try to resume it after a user gesture.\');\n          }\n        };\n\n        this._audioContext.onstatechange();\n      }\n    }\n    /**\n     * Create an Audio object of speech audio for the given speech text.\n     *\n     * @private\n     *\n     * @param {Object} params - Parameters object compatible with Polly.synthesizeSpeech.\n     *\n     * @returns {Promise} Resolves with an object containing the audio URL and Audio\n     * object.\n     */\n\n  }, {\n    key: "_synthesizeAudio",\n    value: function _synthesizeAudio(params) {\n      var _this3 = this;\n\n      return TextToSpeechFeature_get(TextToSpeechFeature_getPrototypeOf(TextToSpeechFeature.prototype), "_synthesizeAudio", this).call(this, params).then(function (result) {\n        var url = result.url; // Create an Audio object that points to the presigned url\n\n        var audio = new Audio(url);\n        audio.loop = _this3.loop;\n        audio.crossOrigin = \'anonymous\';\n        audio.preload = \'auto\';\n        result.audio = audio;\n        return new Promise(function (resolve) {\n          // Resolve once the minimum amount is loaded\n          audio.addEventListener(\'canplaythrough\', function () {\n            resolve(result);\n          }); // Start loading the audio\n\n          document.body.appendChild(audio);\n          audio.load();\n        });\n      });\n    }\n    /**\n     * Create a new Speech object for the speaker.\n     *\n     * @private\n     *\n     * @param {TextToSpeech} speaker - The TextToSpeech instance that will own the speech.\n     * @param {string} text - Text of the speech.\n     * @param {Object} speechmarks - Speechmarks for the speech.\n     * @param {Object} audioConfig - Audio for the speech.\n     *\n     * @returns {AbstractSpeech}\n     */\n\n  }, {\n    key: "_createSpeech",\n    value: function _createSpeech(text, speechmarks, audioConfig) {\n      return new awspack_Speech(this, text, speechmarks, audioConfig);\n    }\n    /**\n     * Gets whether or not the audio context is running and speech can be played.\n     *\n     * @readonly\n     * @type {boolean}\n     */\n\n  }, {\n    key: "enabled",\n    get: function get() {\n      return this._enabled;\n    }\n    /**\n     * Try to resume the audio context. This will be automatically executed each time\n     * speech is played or resumed. If using manually, it should be called after a\n     * user interaction occurs.\n     *\n     * @returns {Deferred} - Resolves once the audio context has resumed.\n     */\n\n  }, {\n    key: "resumeAudio",\n    value: function resumeAudio() {\n      var _this4 = this;\n\n      var promise = new core_Deferred(function (resolve, reject) {\n        _this4._audioContext.resume().then(function () {\n          _this4._enabled = true;\n          resolve();\n        })["catch"](function (e) {\n          _this4._enabled = false;\n          reject(e);\n        });\n      });\n      return promise;\n    }\n  }, {\n    key: "_startSpeech",\n    value: function _startSpeech(text, config) {\n      var _this5 = this;\n\n      var playMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \'play\';\n      var currentPromise = {\n        play: new core_Deferred(undefined, function () {\n          currentPromise.speech.cancel();\n        }, function () {\n          currentPromise.speech.cancel();\n        }, function () {\n          currentPromise.speech.cancel();\n        }),\n        speech: new core_Deferred()\n      };\n      this._currentPromise = currentPromise; // Try to start the audio context\n\n      this.resumeAudio().then(function () {\n        // Exit if the promise is no longer pending because of user interaction\n        if (!currentPromise.play.pending) {\n          return;\n        } // Cancel if another call to play has already been made\n        else if (_this5._currentPromise !== currentPromise) {\n          currentPromise.play.cancel();\n          return;\n        } // The audio context is running so the speech can be played\n\n\n        if (_this5._enabled) {\n          TextToSpeechFeature_get(TextToSpeechFeature_getPrototypeOf(TextToSpeechFeature.prototype), "_startSpeech", _this5).call(_this5, text, config, playMethod);\n        } // Reject if the audio context is not running\n        else {\n          currentPromise.reject(new Error("Cannot ".concat(playMethod, " speech on host ").concat(_this5._host.id, ". The audio context is not running. Use the \\"TextToSpeechFeature.resumeAudio\\" method to try to resume it after a user gesture.")));\n        }\n      });\n      return currentPromise.play;\n    }\n  }, {\n    key: "play",\n    value: function play(text, config) {\n      return this._startSpeech(text, config, \'play\');\n    }\n  }, {\n    key: "resume",\n    value: function resume(text, config) {\n      return this._startSpeech(text, config, \'resume\');\n    }\n  }, {\n    key: "installApi",\n    value: function installApi() {\n      var _this6 = this;\n\n      var api = TextToSpeechFeature_get(TextToSpeechFeature_getPrototypeOf(TextToSpeechFeature.prototype), "installApi", this).call(this);\n\n      Object.defineProperties(api, {\n        /**\n         * @memberof TextToSpeechFeature\n         * @instance\n         * @see core/TextToSpeechFeature#enabled\n         */\n        enabled: {\n          get: function get() {\n            return _this6._enabled;\n          }\n        }\n      });\n      return api;\n    }\n  }]);\n\n  return TextToSpeechFeature;\n}(awspack_AbstractTextToSpeechFeature);\n\n/* harmony default export */ const awspack_TextToSpeechFeature = (TextToSpeechFeature);\n;// CONCATENATED MODULE: ./src/core/awspack/index.js\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n\n/**\n * @module core/awspack\n */\n\n/* harmony default export */ const awspack = ({\n  /**\n   * @see AbstractTextToSpeechFeature\n   */\n  AbstractTextToSpeechFeature: awspack_AbstractTextToSpeechFeature,\n\n  /**\n   * @see core/TextToSpeechFeature\n   */\n  TextToSpeechFeature: awspack_TextToSpeechFeature,\n\n  /**\n   * @see TextToSpeechUtils\n   */\n  TextToSpeechUtils: awspack_TextToSpeechUtils,\n\n  /**\n   * @see AbstractSpeech\n   */\n  AbstractSpeech: awspack_AbstractSpeech,\n\n  /**\n   * @see core/Speech\n   */\n  Speech: awspack_Speech\n});\n;// CONCATENATED MODULE: ./src/core/index.js\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\n * @module hosts/core\n */\n\n\n\n\n\n\n\n\n\n\nvar core_Easing = animpack.Easing,\n    core_AnimationFeature = animpack.AnimationFeature,\n    core_AnimationTypes = animpack.AnimationTypes,\n    core_AnimationLayer = animpack.AnimationLayer,\n    core_LayerBlendModes = animpack.LayerBlendModes,\n    core_DefaultLayerBlendMode = animpack.DefaultLayerBlendMode,\n    core_SingleState = animpack.SingleState,\n    core_TransitionState = animpack.TransitionState,\n    core_FreeBlendState = animpack.FreeBlendState,\n    core_QueueState = animpack.QueueState,\n    core_RandomAnimationState = animpack.RandomAnimationState,\n    core_Blend1dState = animpack.Blend1dState,\n    core_Blend2dState = animpack.Blend2dState,\n    core_AnimationUtils = animpack.AnimationUtils;\n\nvar core_AbstractTextToSpeechFeature = awspack.AbstractTextToSpeechFeature,\n    core_TextToSpeechFeature = awspack.TextToSpeechFeature,\n    core_TextToSpeechUtils = awspack.TextToSpeechUtils,\n    core_AbstractSpeech = awspack.AbstractSpeech,\n    core_Speech = awspack.Speech;\n/* harmony default export */ const core = ({\n  /**\n   * @see env\n   */\n  env: env,\n\n  /**\n   * @see Utils\n   */\n  Utils: core_Utils,\n\n  /**\n   * @see MathUtils\n   */\n  MathUtils: core_MathUtils,\n\n  /**\n   * @see Deferred\n   */\n  Deferred: core_Deferred,\n\n  /**\n   * @see core/Messenger\n   */\n  Messenger: core_Messenger,\n\n  /**\n   * @see core/HostObject\n   */\n  HostObject: core_HostObject,\n\n  /**\n   * @see LipsyncFeature\n   */\n  LipsyncFeature: core_LipsyncFeature,\n\n  /**\n   * @see GestureFeature\n   */\n  GestureFeature: core_GestureFeature,\n\n  /**\n   * @see PointOfInterestFeature\n   */\n  PointOfInterestFeature: core_PointOfInterestFeature,\n\n  /**\n   * @see DefaultVisemeMap\n   */\n  DefaultVisemeMap: DefaultVisemeMap,\n\n  /**\n   * @see DefaultGestureWords\n   */\n  DefaultGestureWords: DefaultGestureWords,\n\n  /**\n   * @see AxisMap\n   */\n  AxisMap: AxisMap,\n  // Amnimpack\n\n  /**\n   * @see module:core/animpack.Easing\n   */\n  Easing: core_Easing,\n\n  /**\n   * @see module:core/animpack.AnimationFeature\n   */\n  AnimationFeature: core_AnimationFeature,\n\n  /**\n   * @see module:core/animpack.AnimationLayer\n   */\n  AnimationLayer: core_AnimationLayer,\n\n  /**\n   * @see module:core/animpack.SingleState\n   */\n  SingleState: core_SingleState,\n\n  /**\n   * @see module:core/animpack.TransitionState\n   */\n  TransitionState: core_TransitionState,\n\n  /**\n   * @see module:core/animpack.FreeBlendState\n   */\n  FreeBlendState: core_FreeBlendState,\n\n  /**\n   * @see module:core/animpack.QueueState\n   */\n  QueueState: core_QueueState,\n\n  /**\n   * @see module:core/animpack.RandomAnimationState\n   */\n  RandomAnimationState: core_RandomAnimationState,\n\n  /**\n   * @see module:core/animpack.Blend1dState\n   */\n  Blend1dState: core_Blend1dState,\n\n  /**\n   * @see module:core/animpack.Blend2dState\n   */\n  Blend2dState: core_Blend2dState,\n\n  /**\n   * @see module:core/animpack.AnimationUtils\n   */\n  AnimationUtils: core_AnimationUtils,\n\n  /**\n   * @see module:core/animpack.LayerBlendModes\n   */\n  LayerBlendModes: core_LayerBlendModes,\n\n  /**\n   * @see module:core/animpack.DefaultLayerBlendMode\n   */\n  DefaultLayerBlendMode: core_DefaultLayerBlendMode,\n\n  /**\n   * @see module:core/animpack.AnimationTypes\n   */\n  AnimationTypes: core_AnimationTypes,\n  // AWS Pack\n\n  /**\n   * @see module:core/awspack.AbstractTextToSpeechFeature\n   */\n  AbstractTextToSpeechFeature: core_AbstractTextToSpeechFeature,\n\n  /**\n   * @see module:core/awspack.TextToSpeechFeature\n   */\n  TextToSpeechFeature: core_TextToSpeechFeature,\n\n  /**\n   * @see module:core/awspack.TextToSpeechUtils\n   */\n  TextToSpeechUtils: core_TextToSpeechUtils,\n\n  /**\n   * @see module:core/awspack.AbstractSpeech\n   */\n  AbstractSpeech: core_AbstractSpeech,\n\n  /**\n   * @see module:core/awspack.Speech\n   */\n  Speech: core_Speech\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0VpSixFQUFBQSxlQUFlLEVBQWZBLG9CQWxHYTs7QUFtR2I7QUFDRjtBQUNBO0FBQ0VHLEVBQUFBLHFCQUFxQixFQUFyQkEsMEJBdEdhOztBQXVHYjtBQUNGO0FBQ0E7QUFDRTJCLEVBQUFBLGNBQWMsRUFBZEEsbUJBMUdhO0FBNEdiOztBQUNBO0FBQ0Y7QUFDQTtBQUNFMlEsRUFBQUEsMkJBQTJCLEVBQTNCQSxnQ0FoSGE7O0FBaUhiO0FBQ0Y7QUFDQTtBQUNFM2lCLEVBQUFBLG1CQUFtQixFQUFuQkEsd0JBcEhhOztBQXFIYjtBQUNGO0FBQ0E7QUFDRTJjLEVBQUFBLGlCQUFpQixFQUFqQkEsc0JBeEhhOztBQXlIYjtBQUNGO0FBQ0E7QUFDRXFELEVBQUFBLGNBQWMsRUFBZEEsbUJBNUhhOztBQTZIYjtBQUNGO0FBQ0E7QUFDRXFCLEVBQUFBLE1BQU0sRUFBTkEsV0FBTUE7QUFoSU8sQ0FBZiIsInNvdXJjZXMiOlsid2VicGFjazovL0hPU1QvLi9zcmMvY29yZS9EZWZlcnJlZC5qcz82ODhlIiwid2VicGFjazovL0hPU1QvLi9zcmMvY29yZS9VdGlscy5qcz9iZjI0Iiwid2VicGFjazovL0hPU1QvLi9zcmMvY29yZS9NYXRoVXRpbHMuanM/ODFlNyIsIndlYnBhY2s6Ly9IT1NULy4vc3JjL2NvcmUvSG9zdEVudmlyb25tZW50LmpzPzE1MWQiLCJ3ZWJwYWNrOi8vSE9TVC8uL3NyYy9jb3JlL01lc3Nlbmdlci5qcz9kMDA2Iiwid2VicGFjazovL0hPU1QvLi9zcmMvY29yZS9BYnN0cmFjdEhvc3RGZWF0dXJlLmpzPzIzNmUiLCJ3ZWJwYWNrOi8vSE9TVC8uL3NyYy9jb3JlL0hvc3RPYmplY3QuanM/NzVlNyIsIndlYnBhY2s6Ly9IT1NULy4vc3JjL2NvcmUvYW5pbXBhY2svRWFzaW5nLmpzPzU4NmMiLCJ3ZWJwYWNrOi8vSE9TVC8uL3NyYy9jb3JlL0ZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UuanM/MDZiYiIsIndlYnBhY2s6Ly9IT1NULy4vc3JjL2NvcmUvYW5pbXBhY2svQW5pbWF0aW9uRmVhdHVyZURlcGVuZGVudEludGVyZmFjZS5qcz82ZTYzIiwid2VicGFjazovL0hPU1QvLi9zcmMvY29yZS9hbmltcGFjay9NYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2UuanM/NDdkNSIsIndlYnBhY2s6Ly9IT1NULy4vc3JjL2NvcmUvYXdzcGFjay9UZXh0VG9TcGVlY2hGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlLmpzP2JjYWQiLCJ3ZWJwYWNrOi8vSE9TVC8uL3NyYy9jb3JlL0xpcHN5bmNGZWF0dXJlLmpzPzhkM2EiLCJ3ZWJwYWNrOi8vSE9TVC8uL3NyYy9jb3JlL2F3c3BhY2svU1NNTFNwZWVjaG1hcmtJbnRlcmZhY2UuanM/Y2E3NCIsIndlYnBhY2s6Ly9IT1NULy4vc3JjL2NvcmUvR2VzdHVyZUZlYXR1cmUuanM/ZGIzOSIsIndlYnBhY2s6Ly9IT1NULy4vc3JjL2NvcmUvYW5pbXBhY2svQW5pbWF0aW9uVXRpbHMuanM/MTE0OCIsIndlYnBhY2s6Ly9IT1NULy4vc3JjL2NvcmUvYW5pbXBhY2svc3RhdGUvQWJzdHJhY3RTdGF0ZS5qcz8yZjg3Iiwid2VicGFjazovL0hPU1QvLi9zcmMvY29yZS9hbmltcGFjay9zdGF0ZS9UcmFuc2l0aW9uU3RhdGUuanM/OWU3NyIsIndlYnBhY2s6Ly9IT1NULy4vc3JjL2NvcmUvYW5pbXBhY2svQW5pbWF0aW9uUGxheWVySW50ZXJmYWNlLmpzPzczM2UiLCJ3ZWJwYWNrOi8vSE9TVC8uL3NyYy9jb3JlL2FuaW1wYWNrL3N0YXRlL1N0YXRlQ29udGFpbmVySW50ZXJmYWNlLmpzPzI2NTkiLCJ3ZWJwYWNrOi8vSE9TVC8uL3NyYy9jb3JlL2FuaW1wYWNrL3N0YXRlL1F1ZXVlU3RhdGUuanM/MGM0YSIsIndlYnBhY2s6Ly9IT1NULy4vc3JjL2NvcmUvYW5pbXBhY2svc3RhdGUvQWJzdHJhY3RCbGVuZFN0YXRlLmpzPzY2OTciLCJ3ZWJwYWNrOi8vSE9TVC8uL3NyYy9jb3JlL2FuaW1wYWNrL3N0YXRlL0ZyZWVCbGVuZFN0YXRlLmpzP2Q2NzUiLCJ3ZWJwYWNrOi8vSE9TVC8uL3NyYy9jb3JlL2FuaW1wYWNrL3N0YXRlL0JsZW5kMWRTdGF0ZS5qcz9hNzQyIiwid2VicGFjazovL0hPU1QvLi9zcmMvY29yZS9hbmltcGFjay9zdGF0ZS9CbGVuZDJkU3RhdGUuanM/ODE2MyIsIndlYnBhY2s6Ly9IT1NULy4vc3JjL2NvcmUvYW5pbXBhY2svQW5pbWF0aW9uTGF5ZXIuanM/YmVlYyIsIndlYnBhY2s6Ly9IT1NULy4vc3JjL2NvcmUvYW5pbXBhY2svc3RhdGUvU2luZ2xlU3RhdGUuanM/NGYxNCIsIndlYnBhY2s6Ly9IT1NULy4vc3JjL2NvcmUvYW5pbXBhY2svc3RhdGUvUmFuZG9tQW5pbWF0aW9uU3RhdGUuanM/NDQ5MyIsIndlYnBhY2s6Ly9IT1NULy4vc3JjL2NvcmUvYW5pbXBhY2svQW5pbWF0aW9uRmVhdHVyZS5qcz9lYmRlIiwid2VicGFjazovL0hPU1QvLi9zcmMvY29yZS9Qb2ludE9mSW50ZXJlc3RGZWF0dXJlLmpzP2RlZTUiLCJ3ZWJwYWNrOi8vSE9TVC8uL3NyYy9jb3JlL2FuaW1wYWNrL2luZGV4LmpzPzlhMTIiLCJ3ZWJwYWNrOi8vSE9TVC8uL3NyYy9jb3JlL2F3c3BhY2svVGV4dFRvU3BlZWNoVXRpbHMuanM/NzU1ZCIsIndlYnBhY2s6Ly9IT1NULy4vc3JjL2NvcmUvYXdzcGFjay9BYnN0cmFjdFNwZWVjaC5qcz83ZjFjIiwid2VicGFjazovL0hPU1QvLi9zcmMvY29yZS9hd3NwYWNrL1NwZWVjaC5qcz8yYTQxIiwid2VicGFjazovL0hPU1QvLi9zcmMvY29yZS9hd3NwYWNrL0Fic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZS5qcz8zNDFmIiwid2VicGFjazovL0hPU1QvLi9zcmMvY29yZS9hd3NwYWNrL1RleHRUb1NwZWVjaEZlYXR1cmUuanM/NWE4NSIsIndlYnBhY2s6Ly9IT1NULy4vc3JjL2NvcmUvYXdzcGFjay9pbmRleC5qcz8zYWUwIiwid2VicGFjazovL0hPU1QvLi9zcmMvY29yZS9pbmRleC5qcz9jN2IyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXG5cbi8qKlxuICogVGhlIGJ1aWx0LWluIGNsYXNzIGZvciBhc3luY2hyb25vdXMgUHJvbWlzZXMuXG4gKiBAZXh0ZXJuYWwgUHJvbWlzZVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm9taXNlXG4gKi9cblxuLyoqXG4gKiBBIFByb21pc2Ugb2JqZWN0IHRoYXQgY2FuIGJlIHJlc29sdmVkLCByZWplY3RlZCBvciBjYW5jZWxlZCBhdCBhbnkgdGltZSBieSB0aGVcbiAqIHVzZXIuXG4gKlxuICogQGV4dGVuZHMgZXh0ZXJuYWw6UHJvbWlzZVxuICovXG5jbGFzcyBEZWZlcnJlZCBleHRlbmRzIFByb21pc2Uge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtleGVjdXRhYmxlPSgpID0+IHt9XSAtIFRoZSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBieSB0aGVcbiAgICogY29uc3RydWN0b3IsIGR1cmluZyB0aGUgcHJvY2VzcyBvZiBjb25zdHJ1Y3RpbmcgdGhlIHByb21pc2UuIFRoZSBzaWduYXR1cmVcbiAgICogb2YgdGhpcyBpcyBleHBlY3RlZCB0byBiZTogZXhlY3V0YWJsZSggIHJlc29sdXRpb25GdW5jLCByZWplY3Rpb25GdW5jLCBjYW5jZWxsYXRpb25GdW5jICkuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvblJlc29sdmUgLSBPcHRpb25hbCBmdW5jdGlvbiB0byBleGVjdXRlIG9uY2UgdGhlIHByb21pc2VcbiAgICogaXMgcmVzb2x2ZWQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvblJlamVjdCAtIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb25jZSB0aGUgcHJvbWlzZVxuICAgKiBpcyByZWplY3RlZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uQ2FuY2VsIC0gT3B0aW9uYWwgZnVuY3Rpb24gdG8gZXhlY3V0ZSBpZiB0aGUgdXNlciBjYW5jZWxzXG4gICAqIHRoZSBwcm9taXNlLiBDYW5jZWxpbmcgcmVzdWx0cyBpbiB0aGUgcHJvbWlzZSBoYXZpbmcgYSBzdGF0dXMgb2YgJ3Jlc29sdmVkJy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGV4ZWN1dGFibGUgPSAoKSA9PiB7fSwgb25SZXNvbHZlLCBvblJlamVjdCwgb25DYW5jZWwpIHtcbiAgICBpZiAodHlwZW9mIGV4ZWN1dGFibGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBjcmVhdGUgbmV3IERlZmVycmVkLiBFeGVjdXRhYmxlIG11c3QgYmUgYSBmdW5jdGlvbi5gXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb25SZXNvbHZlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygb25SZXNvbHZlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgY3JlYXRlIG5ldyBEZWZlcnJlZC4gT25SZXNvbHZlIG11c3QgYmUgYSBmdW5jdGlvbi5gXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb25SZWplY3QgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBvblJlamVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGNyZWF0ZSBuZXcgRGVmZXJyZWQuIE9uUmVqZWN0IG11c3QgYmUgYSBmdW5jdGlvbi5gXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb25DYW5jZWwgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBvbkNhbmNlbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGNyZWF0ZSBuZXcgRGVmZXJyZWQuIE9uQ2FuY2VsIG11c3QgYmUgYSBmdW5jdGlvbi5gXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCByZXM7XG4gICAgbGV0IHJlajtcbiAgICBsZXQgY2FuY2VsO1xuICAgIGNvbnN0IHN0YXR1cyA9IHtcbiAgICAgIHJlc29sdmVkOiBmYWxzZSxcbiAgICAgIHJlamVjdGVkOiBmYWxzZSxcbiAgICAgIGNhbmNlbGVkOiBmYWxzZSxcbiAgICAgIHBlbmRpbmc6IHRydWUsXG4gICAgfTtcblxuICAgIHN1cGVyKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIC8vIFN0b3JlIHRoZSByZXNvbHZlclxuICAgICAgcmVzID0gdmFsdWUgPT4ge1xuICAgICAgICBpZiAoc3RhdHVzLnBlbmRpbmcpIHtcbiAgICAgICAgICBzdGF0dXMucmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgIHN0YXR1cy5wZW5kaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIG9uUmVzb2x2ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFsdWUgPSBvblJlc29sdmUodmFsdWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gU3RvcmUgdGhlIHJlamVjdGVyXG4gICAgICByZWogPSB2YWx1ZSA9PiB7XG4gICAgICAgIGlmIChzdGF0dXMucGVuZGluZykge1xuICAgICAgICAgIHN0YXR1cy5yZWplY3RlZCA9IHRydWU7XG4gICAgICAgICAgc3RhdHVzLnBlbmRpbmcgPSBmYWxzZTtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygb25SZWplY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gb25SZWplY3QodmFsdWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZWplY3QodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBTdG9yZSB0aGUgY2FuY2VsZXJcbiAgICAgIGNhbmNlbCA9IHZhbHVlID0+IHtcbiAgICAgICAgaWYgKHN0YXR1cy5wZW5kaW5nKSB7XG4gICAgICAgICAgc3RhdHVzLmNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgICAgICBzdGF0dXMucGVuZGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBvbkNhbmNlbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFsdWUgPSBvbkNhbmNlbCh2YWx1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBSdW4gdGhlIGV4ZWN1dGFibGUgd2l0aCBjdXN0b20gcmVzb2x2ZXIgYW5kIHJlamVjdGVyXG4gICAgICBleGVjdXRhYmxlKHJlcywgcmVqLCBjYW5jZWwpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMuX3Jlc29sdmUgPSByZXM7XG4gICAgdGhpcy5fcmVqZWN0ID0gcmVqO1xuICAgIHRoaXMuX2NhbmNlbCA9IGNhbmNlbDtcbiAgICB0aGlzLl9leGVjdXRhYmxlID0gZXhlY3V0YWJsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSByZXNvbHZlZCBzdGF0ZSBvZiB0aGUgcHJvbWlzZS5cbiAgICpcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcmVzb2x2ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXR1cy5yZXNvbHZlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSByZWplY3RlZCBzdGF0ZSBvZiB0aGUgcHJvbWlzZS5cbiAgICpcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcmVqZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXR1cy5yZWplY3RlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjYW5jZWxlZCBzdGF0ZSBvZiB0aGUgcHJvbWlzZS5cbiAgICpcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgY2FuY2VsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXR1cy5jYW5jZWxlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBwZW5kaW5nIHN0YXRlIG9mIHRoZSBwcm9taXNlLlxuICAgKlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBwZW5kaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0dXMucGVuZGluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjZSB0aGUgcHJvbWlzZSB0byByZXNvbHZlLlxuICAgKlxuICAgKiBAcGFyYW0ge2FueT19IHZhbHVlIC0gVmFsdWUgdG8gcGFzcyB0byB0aGUgcmVzb2x2ZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHthbnl9IC0gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcmVzb2x2ZXIgZnVuY3Rpb24uXG4gICAqL1xuICByZXNvbHZlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmUodmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNlIHRoZSBwcm9taXNlIHRvIHJlamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHthbnk9fSB2YWx1ZSAtIFZhbHVlIHRvIHBhc3MgdG8gdGhlIHJlamVjdGVyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7YW55fSAtIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHJlamVjdGVyIGZ1bmN0aW9uLlxuICAgKi9cbiAgcmVqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlamVjdCh2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogRm9yY2UgdGhlIHByb21pc2UgdG8gcmVzb2x2ZSBhbmQgc2V0IHRoZSBjYW5jZWxlZCBzdGF0ZSB0byB0cnVlLlxuICAgKlxuICAgKiBAcGFyYW0ge2FueT19IHZhbHVlIC0gVmFsdWUgdG8gcGFzcyB0byB0aGUgY2FuY2VsbGVyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7YW55fSAtIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGNhbmNlbGxlciBmdW5jdGlvbi5cbiAgICovXG4gIGNhbmNlbCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9jYW5jZWwodmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1biB0aGUgcHJvbWlzZSBmdW5jdGlvbiB0byB0cnkgdG8gcmVzb2x2ZSB0aGUgcHJvbWlzZS4gUHJvbWlzZSBtdXN0IGJlXG4gICAqIHBlbmRpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7Li4uYW55fSBhcmdzIC0gT3B0aW9uYWwgYXJndW1lbnRzIHRvIHBhc3MgYWZ0ZXIgcmVzb2x2ZSBhbmQgcmVqZWN0LlxuICAgKi9cbiAgZXhlY3V0ZSguLi5hcmdzKSB7XG4gICAgaWYgKHRoaXMucGVuZGluZykge1xuICAgICAgdGhpcy5fZXhlY3V0YWJsZSh0aGlzLl9yZXNvbHZlLCB0aGlzLl9yZWplY3QsIHRoaXMuX2NhbmNlbCwgLi4uYXJncyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGNhbmNlbGVkIGRlZmVycmVkIHByb21pc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7YW55PX0gdmFsdWUgLSBWYWx1ZSB0byBjYW5jZWwgdGhlIHByb21pc2Ugd2l0aC5cbiAgICpcbiAgICogQHJldHVybnMge0RlZmVycmVkfVxuICAgKi9cbiAgc3RhdGljIGNhbmNlbCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgRGVmZXJyZWQoKF9yZXNvbHZlLCBfcmVqZWN0LCBjYW5jZWwpID0+IHtcbiAgICAgIGNhbmNlbCh2YWx1ZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgbmV3IERlZmVycmVkIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgb3IgcmVqZWN0IG9uY2UgYWxsIHByb21pc2VzXG4gICAqIGluIHRoZSBpbnB1dCBhcnJheSBoYXZlIGJlZW4gcmVzb2x2ZWQgb3Igb25lIHByb21pc2UgaXMgY2FuY2VsZWQgb3IgcmVqZWN0ZWQuXG4gICAqIFByb21pc2VzIGluIHRoZSBhcnJheSB0aGF0IGFyZSBEZWZlcnJlZCBwcm9taXNlcyB3aWxsIGJlIG1hbnVhbGx5IHJlc29sdmVkLFxuICAgKiByZWplY3RlZCBvciBjYW5jZWxlZCB3aGVuIGNhbGxpbmcgcmVzb2x2ZSwgcmVqZWN0IG9yIGNhbmNlbCBvbiB0aGUgcmV0dXJuIHByb21pc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXkuPGFueT59IGl0ZXJhYmxlIC0gQW4gaXRlcmFibGUgc3VjaCBhcyBhbiBhcnJheS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uUmVzb2x2ZSAtIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb25jZSB0aGUgcHJvbWlzZVxuICAgKiBpcyByZXNvbHZlZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uUmVqZWN0IC0gT3B0aW9uYWwgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbmNlIHRoZSBwcm9taXNlXG4gICAqIGlzIHJlamVjdGVkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25DYW5jZWwgLSBPcHRpb25hbCBmdW5jdGlvbiB0byBleGVjdXRlIGlmIHRoZSB1c2VyIGNhbmNlbHNcbiAgICogdGhlIHByb21pc2UuIENhbmNlbGluZyByZXN1bHRzIGluIHRoZSBwcm9taXNlIGhhdmluZyBhIHN0YXR1cyBvZiAnY2FuY2VsZWQnLlxuICAgKlxuICAgKiBAcmV0dXJucyBEZWZlcnJlZFxuICAgKi9cbiAgc3RhdGljIGFsbChpdGVyYWJsZSwgb25SZXNvbHZlLCBvblJlamVjdCwgb25DYW5jZWwpIHtcbiAgICBpZiAoaXRlcmFibGUgPT0gbnVsbCB8fCB0eXBlb2YgaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbGV0IGUgPSBgQ2Fubm90IGV4ZWN1dGUgRGVmZXJyZWQuYWxsLiBGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGl0ZXJhYmxlLmA7XG5cbiAgICAgIGlmICh0eXBlb2Ygb25SZWplY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZSA9IG9uUmVqZWN0KGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gRGVmZXJyZWQucmVqZWN0KGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGFycmF5ID0gWy4uLml0ZXJhYmxlXTtcbiAgICBjb25zdCBkZWZlcnJlZCA9IGFycmF5LmZpbHRlcihpdGVtID0+IGl0ZW0gaW5zdGFuY2VvZiBEZWZlcnJlZCk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBuZXcgRGVmZXJyZWQoXG4gICAgICB1bmRlZmluZWQsXG4gICAgICByZXNvbHZlVmFsdWUgPT4ge1xuICAgICAgICBkZWZlcnJlZC5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgIGl0ZW0ucmVzb2x2ZShyZXNvbHZlVmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmZXJyZWQubGVuZ3RoID0gMDtcblxuICAgICAgICBpZiAodHlwZW9mIG9uUmVzb2x2ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBvblJlc29sdmUocmVzb2x2ZVZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZVZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZXJyb3IgPT4ge1xuICAgICAgICBkZWZlcnJlZC5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgIGl0ZW0ucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZmVycmVkLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvblJlamVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBvblJlamVjdChlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FuY2VsVmFsdWUgPT4ge1xuICAgICAgICBkZWZlcnJlZC5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgIGl0ZW0uY2FuY2VsKGNhbmNlbFZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZmVycmVkLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvbkNhbmNlbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBvbkNhbmNlbChjYW5jZWxWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNhbmNlbFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcblxuICAgIGNvbnN0IG51bUl0ZW1zID0gYXJyYXkubGVuZ3RoO1xuICAgIGNvbnN0IGl0ZW1UcmFja2VyID0ge1xuICAgICAgZmFpbGVkOiBmYWxzZSxcbiAgICAgIG51bVJlc29sdmVkOiAwLFxuICAgICAgcmVzb2x1dGlvbnM6IFtdLFxuICAgIH07XG5cbiAgICBhcnJheS5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGl0ZW1UcmFja2VyLmZhaWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKCEoaXRlbSBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgICAgIGl0ZW1UcmFja2VyLnJlc29sdXRpb25zW2luZGV4XSA9IGl0ZW07XG4gICAgICAgIGl0ZW1UcmFja2VyLm51bVJlc29sdmVkICs9IDE7XG5cbiAgICAgICAgaWYgKGl0ZW1UcmFja2VyLm51bVJlc29sdmVkID09PSBudW1JdGVtcykge1xuICAgICAgICAgIHJlc3VsdC5yZXNvbHZlKGl0ZW1UcmFja2VyLnJlc29sdXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGl0ZW0udGhlbihcbiAgICAgICAgdmFsdWUgPT4ge1xuICAgICAgICAgIGlmICghaXRlbVRyYWNrZXIuZmFpbGVkICYmICFpdGVtLmNhbmNlbGVkKSB7XG4gICAgICAgICAgICBpdGVtVHJhY2tlci5yZXNvbHV0aW9uc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGl0ZW1UcmFja2VyLm51bVJlc29sdmVkICs9IDE7XG5cbiAgICAgICAgICAgIGlmIChpdGVtVHJhY2tlci5udW1SZXNvbHZlZCA9PT0gbnVtSXRlbXMpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnJlc29sdmUoaXRlbVRyYWNrZXIucmVzb2x1dGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoIWl0ZW1UcmFja2VyLmZhaWxlZCkge1xuICAgICAgICAgICAgaXRlbVRyYWNrZXIuZmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc3VsdC5jYW5jZWwodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3IgPT4ge1xuICAgICAgICAgIGlmICghaXRlbVRyYWNrZXIuZmFpbGVkKSB7XG4gICAgICAgICAgICBpdGVtVHJhY2tlci5mYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmVzdWx0LnJlamVjdChlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEZWZlcnJlZDtcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXG5pbXBvcnQgRGVmZXJyZWQgZnJvbSAnY29yZS9EZWZlcnJlZCc7XG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIHVzZWZ1bCBnZW5lcmljIGZ1bmN0aW9ucy5cbiAqXG4gKiBAaGlkZWNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIFV0aWxzIHtcbiAgLyoqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogR2VuZXJhdGUgYSB1bmlxdWUgaWRcbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVJZCgpIHtcbiAgICByZXR1cm4gJ3h4eHh4eHh4eHh4eDR4eHh5eHh4eHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGMgPT4ge1xuICAgICAgY29uc3QgcmFuZG9tTnVtYmVyID0gTWF0aC5mbG9vcigoRGF0ZS5ub3coKSArIE1hdGgucmFuZG9tKCkgKiAxNikgJSAxNik7XG4gICAgICBpZiAoYyA9PT0gJ3gnKSB7XG4gICAgICAgIHJldHVybiByYW5kb21OdW1iZXIudG9TdHJpbmcoMTYpO1xuICAgICAgfVxuICAgICAgLy8gU2V0IGJpdCA2IGFuZCA3IHRvIDAgYW5kIDFcbiAgICAgIHJldHVybiAoKHJhbmRvbU51bWJlciAmIDB4MykgfCAweDgpLnRvU3RyaW5nKDE2KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIENoZWNrIGEgbmFtZSBzdHJpbmcgYWdhaW5zdCBhbiBhcnJheSBvZiBzdHJpbmdzIHRvIGRldGVybWluZSBpZiBpdCBpcyB1bmlxdWUuXG4gICAqIElmIGl0IGlzbid0LCBhcHBlbmQgaW5jcmVtZW50ZWQgdHJhaWxpbmcgaW50ZWdlcnMgdG8gdGhlIGVuZCBvZiB0aGUgbmFtZVxuICAgKiB1bnRpbCBpdCBpcyB1bmlxdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gU3RyaW5nIG5hbWUgdG8gbWFrZSB1bmlxdWUuXG4gICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz49fSBuYW1lQXJyYXkgLSBBcnJheSBvZiBzdHJpbmcgbmFtZXMgdG8gY2hlY2sgYWdhaW5zLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldFVuaXF1ZU5hbWUobmFtZSwgbmFtZUFycmF5ID0gW10pIHtcbiAgICAvLyBJZiB0aGUgbmFtZSBpc24ndCBpbiB0aGUgYXJyYXkgcmV0dXJuIGl0IHJpZ2h0IGF3YXlcbiAgICBpZiAoIW5hbWVBcnJheS5pbmNsdWRlcyhuYW1lKSkge1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuXG4gICAgY29uc3QgbmFtZVNldCA9IG5ldyBTZXQobmFtZUFycmF5KTtcblxuICAgIC8vIFNlcGFyYXRlIHRoZSBuYW1lIGludG8gc3RyaW5nIGFuZCB0cmFpbGluZyBudW1iZXJzXG4gICAgY29uc3QgbWF0Y2hHcm91cCA9IG5hbWUubWF0Y2goL1xcZCokLyk7XG4gICAgY29uc3Qge2luZGV4fSA9IG1hdGNoR3JvdXA7XG4gICAgY29uc3QgYmFzZU5hbWUgPSBuYW1lLnNsaWNlKDAsIGluZGV4KTtcbiAgICBsZXQgaW5jcmVtZW50ID0gTnVtYmVyKG1hdGNoR3JvdXBbMF0pO1xuXG4gICAgLy8gRmluZCB0aGUgaGlnaGVzdCB0cmFpbGluZyBudW1iZXIgdmFsdWUgZm9yIHRoZSBiYXNlIG9mIHRoZSBuYW1lXG4gICAgbmFtZVNldC5mb3JFYWNoKHNldE5hbWUgPT4ge1xuICAgICAgY29uc3Qgc2V0TWF0Y2hHcm91cCA9IHNldE5hbWUubWF0Y2goL1xcZCokLyk7XG5cbiAgICAgIGlmIChzZXROYW1lLnNsaWNlKDAsIHNldE1hdGNoR3JvdXAuaW5kZXgpID09PSBiYXNlTmFtZSkge1xuICAgICAgICBjb25zdCBzZXRJbmNyZW1lbnQgPSBOdW1iZXIoc2V0TWF0Y2hHcm91cFswXSk7XG5cbiAgICAgICAgaWYgKHNldEluY3JlbWVudCA+IGluY3JlbWVudCkge1xuICAgICAgICAgIGluY3JlbWVudCA9IHNldEluY3JlbWVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gSW5jcmVtZW50IHRoZSBoaWdoZXN0IHRyYWlsaW5nIG51bWJlciBhbmQgYXBwZW5kIHRvIHRoZSBuYW1lXG4gICAgcmV0dXJuIGAke2Jhc2VOYW1lfSR7aW5jcmVtZW50ICsgMX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGRlZmVycmVkIHByb21pc2UgdGhhdCB3aWxsIHdhaXQgYSBnaXZlbiBudW1iZXIgb2Ygc2Vjb25kcyBiZWZvcmVcbiAgICogcmVzb2x2aW5nLiBQYXNzIGRlbHRhIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHRvIHRoZSBkZWZlcnJlZCBwcm9taXNlJ3MgZXhlY3V0ZVxuICAgKiBtZXRob2QgaW4gYW4gdXBkYXRlIGxvb3AgdG8gcHJvZ3Jlc3MgdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzZWNvbmRzPTBdIC0gTnVtYmVyIG9mIHNlY29uZHMgdG8gd2FpdCBiZWZvcmUgcmVzb2x2aW5nLlxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgLSBPcHRpb25hbCBvcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbkZpbmlzaF0gLSBDYWxsYmFjayB0byBleGVjdXRlIG9uY2UgdGhlIHdhaXQgdGltZVxuICAgKiBpcyBtZXQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvcHRpb25zLm9uUHJvZ3Jlc3MgLSBDYWxsYmFjayB0byBleGVjdXRlIGVhY2ggdGltZSB0aGUgd2FpdFxuICAgKiB0aW1lIHByb2dyZXNzZXMgdG93YXJkcyB0aGUgdGFyZ2V0IG51bWJlciBvZiBzZWNvbmRzLiBUaGUgYW1vdW50IG9mIHByb2dyZXNzXG4gICAqIGFzIGEgMC0xIHBlcmNlbnRhZ2UgaXMgcGFzc2VkIGFzIGFuIGFyZ3VtZW50LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb3B0aW9ucy5vbkNhbmNlbCAtIENhbGxiYWNrIHRvIGV4ZWN1dGUgaWYgdGhlIHVzZXIgY2FuY2Vsc1xuICAgKiB0aGUgd2FpdCBiZWZvcmUgY29tcGxldGlvbi5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9wdGlvbnMub25FcnJvciAtIENhbGxiYWNrIHRvIGV4ZWN1dGUgaWYgdGhlIHdhaXQgc3RvcHNcbiAgICogYmVjYXVzZSBhbiBlcnJvciBpcyBlbmNvdW50ZXJlZC4gVGhlIGVycm9yIG1lc3NhZ2UgaXMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9XG4gICAqL1xuICBzdGF0aWMgd2FpdChzZWNvbmRzID0gMCwge29uRmluaXNoLCBvblByb2dyZXNzLCBvbkNhbmNlbCwgb25FcnJvcn0gPSB7fSkge1xuICAgIC8vIE1ha2Ugc3VyZSBzZWNvbmRzIGlzIG51bWVyaWNcbiAgICBpZiAodHlwZW9mIHNlY29uZHMgIT09ICdudW1iZXInKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBJbnZhbGlkIHNlY29uZHMgdmFsdWUgJHtzZWNvbmRzfSBmb3Igd2FpdC4gRGVmYXVsdGluZyB0byAwLmBcbiAgICAgICk7XG5cbiAgICAgIHNlY29uZHMgPSAwO1xuICAgIH1cblxuICAgIC8vIFJlc29sdmUgaW1tZWRpYXRlbHkgaWYgdGhlIHdhaXQgdGltZSBpcyBub3QgZ3JlYXRlciB0aGFuIDBcbiAgICBpZiAoc2Vjb25kcyA8PSAwKSB7XG4gICAgICBpZiAodHlwZW9mIG9uRmluaXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9uRmluaXNoKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBEZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgbGV0IGN1cnJlbnRUaW1lID0gMDtcbiAgICBjb25zdCB0b3RhbFRpbWUgPSBzZWNvbmRzICogMTAwMDsgLy8gY29udmVydCB0byBtaWxsaXNlY29uZHNcblxuICAgIC8vIEV4ZWN1dGFibGUgdG8gcGFzcyB0byBEZWZlcnJlZCwgbWVhbnQgdG8gYmUgcnVuIGluIGFuIHVwZGF0ZSBsb29wXG4gICAgY29uc3Qgb25VcGRhdGUgPSAocmVzb2x2ZSwgcmVqZWN0LCBfY2FuY2VsLCBkZWx0YVRpbWUgPSAwKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGRlbHRhVGltZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uc3QgZSA9IG5ldyBFcnJvcihcbiAgICAgICAgICBgSW52YWxpZCBwcm9wZXJ0eSB3YWl0IGRlbHRhVGltZS4gRGVsdGFUaW1lIG11c3QgYmUgYSBudW1iZXIuYFxuICAgICAgICApO1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gTWFrZSBzdXJlIHRpbWUgaGFzIHBhc3NlZFxuICAgICAgaWYgKGRlbHRhVGltZSA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFNpZ25hbCBwcm9ncmVzc1xuICAgICAgY3VycmVudFRpbWUgKz0gZGVsdGFUaW1lO1xuICAgICAgaWYgKGN1cnJlbnRUaW1lIDwgMCkge1xuICAgICAgICBjdXJyZW50VGltZSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygb25Qcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvblByb2dyZXNzKE1hdGgubWluKGN1cnJlbnRUaW1lIC8gdG90YWxUaW1lLCAxKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNpZ25hbCBjb21wbGV0aW9uIG9uY2UgdGltZSBpcyB1cFxuICAgICAgaWYgKGN1cnJlbnRUaW1lID49IHRvdGFsVGltZSkge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBuZXcgRGVmZXJyZWQob25VcGRhdGUsIG9uRmluaXNoLCBvbkVycm9yLCBvbkNhbmNlbCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgcmFuZG9tIGZsb2F0IG51bWJlciBiZXR3ZWVuIGEgbWluIChpbmNsdXNpdmUpIGFuZCBtYXggKGV4Y2x1c2l2ZSkgdmFsdWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBtaW5pbXVtIHZhbHVlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggbWF4aW11bSB2YWx1ZVxuICAgKiBAcmV0dXJucyB7ZmxvYXR9XG4gICAqL1xuICBzdGF0aWMgZ2V0UmFuZG9tRmxvYXQobWluLCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHJhbmRvbSBpbnRlZ2VyIG51bWJlciBiZXR3ZWVuIGEgbWluIChpbmNsdXNpdmUpIGFuZCBtYXggKGV4Y2x1c2l2ZSkgdmFsdWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBtaW5pbXVtIHZhbHVlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggbWF4aW11bSB2YWx1ZVxuICAgKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAgICovXG4gIHN0YXRpYyBnZXRSYW5kb21JbnQobWluLCBtYXgpIHtcbiAgICBtaW4gPSBNYXRoLmNlaWwobWluKTtcbiAgICBtYXggPSBNYXRoLmZsb29yKG1heCk7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pKSArIG1pbjtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBVdGlscztcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXG5jb25zdCBSYWRpYW5Ub0RlZ3JlZSA9IDE4MCAvIE1hdGguUEk7XG5jb25zdCBEZWdyZWVUb1JhZGlhbiA9IE1hdGguUEkgLyAxODA7XG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIHVzZWZ1bCBtYXRoIGZ1bmN0aW9ucy5cbiAqXG4gKiBAaGlkZWNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIE1hdGhVdGlscyB7XG4gIC8qKlxuICAgKiBDb252ZXJ0IHRoZSBnaXZlbiBhbmdsZSBmcm9tIHJhZGlhbnMgdG8gZGVncmVlcy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbnMgLSBBbmdsZSBpbiByYWRpYW5zLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIEFuZ2xlIGluIGRlZ3JlZXMuXG4gICAqL1xuICBzdGF0aWMgdG9EZWdyZWVzKHJhZGlhbnMpIHtcbiAgICByZXR1cm4gcmFkaWFucyAqIFJhZGlhblRvRGVncmVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgdGhlIGdpdmVuIGFuZ2xlIGZyb20gZGVncmVlcyB0byByYWRpYW5zLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVncmVlcyAtIEFuZ2xlIGluIGRlZ3JlZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gQW5nbGUgaW4gcmFkaWFucy5cbiAgICovXG4gIHN0YXRpYyB0b1JhZGlhbnMoZGVncmVlcykge1xuICAgIHJldHVybiBkZWdyZWVzICogRGVncmVlVG9SYWRpYW47XG4gIH1cblxuICAvKipcbiAgICogTGluZWFybHkgaW50ZXJwb2xhdGUgYmV0d2VlbiB0d28gdmFsdWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbSAtIFN0YXJ0IHZhbHVlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdG8gLSBUYXJnZXQgdmFsdWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmYWN0b3IgLSAwLTEgYW1vdW50IHRvIGludGVycG9sYXRlIGJldHdlZW4gZnJvbSBhbmQgdG8uXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBzdGF0aWMgbGVycChmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgcmV0dXJuIGZyb20gKyAodG8gLSBmcm9tKSAqIGZhY3RvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGFtcCBhIG51bWJlciBiZXR3ZWVuIDIgdmFsdWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBWYWx1ZSB0byBjbGFtcC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFttaW49MF0gLSBNaW51bXVtIHZhbHVlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW21heD0xXSAtIE1heGltdW0gdmFsdWUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBzdGF0aWMgY2xhbXAodmFsdWUsIG1pbiA9IDAsIG1heCA9IDEpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbih2YWx1ZSwgbWF4KSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgY2xvc2VzdCBwb2ludCBvbiBhIGdpdmVuIDJEIGxpbmUgc2VnZW1lbnRcbiAgICogZnJvbSBhIGdpdmVuIDJEIHBvaW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBhIC0gRmlyc3QgcG9pbnQgb24gbGluZSBzZWdtZW50LlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBiIC0gU2Vjb25kIHBvaW50IG9uIGxpbmUgc2VnbWVudC5cbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcCAtIDJEIHBvaW50LlxuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICBzdGF0aWMgY2xvc2VzdFBvaW50T25MaW5lKGEsIGIsIHApIHtcbiAgICBjb25zdCBkaXN0U3FyID0gTWF0aFV0aWxzLmRpc3RhbmNlU3F1YXJlZChhLCBiKTtcblxuICAgIC8vIExpbmUgc2VnbWVudCBpcyBhIHNpbmdsZSBwb2ludFxuICAgIGlmIChkaXN0U3FyID09PSAwKSB7XG4gICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICBjb25zdCB0ID1cbiAgICAgICgocFswXSAtIGFbMF0pICogKGJbMF0gLSBhWzBdKSArIChwWzFdIC0gYVsxXSkgKiAoYlsxXSAtIGFbMV0pKSAvIGRpc3RTcXI7XG5cbiAgICBsZXQgcG9pbnQgPSBbLi4uYV07XG4gICAgaWYgKHQgPiAxKSB7XG4gICAgICBwb2ludCA9IFsuLi5iXTtcbiAgICB9IGVsc2UgaWYgKHQgPiAwKSB7XG4gICAgICBwb2ludCA9IFthWzBdICsgdCAqIChiWzBdIC0gYVswXSksIGFbMV0gKyB0ICogKGJbMV0gLSBhWzFdKV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvaW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGRpc3RhbmNlIHNxdWFyZWQgZm9yIHR3byAyRCBwb2ludHMuXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGEgLSAyRCBwb2ludC5cbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYiAtIDJEIHBvaW50LlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgc3RhdGljIGRpc3RhbmNlU3F1YXJlZChhLCBiKSB7XG4gICAgcmV0dXJuIChhWzBdIC0gYlswXSkgKiAoYVswXSAtIGJbMF0pICsgKGFbMV0gLSBiWzFdKSAqIChhWzFdIC0gYlsxXSk7XG4gIH1cblxuICAvKipcbiAgICogVHJpYW5ndWxhdGVzIGEgc2V0IG9mIDJEIHBvaW50cyB1c2luZyBhbiBpbXBsZW1lbnRhdGlvblxuICAgKiBvZiB0aGUgQm93eWVyLVdhdHNvbiBpbmNyZW1lbnRhbCBEZWxhdW5heSB0cmlhbmd1bGF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IHZlcnRpY2VzIC0gQXJyYXkgb2YgMkQgcG9pbnRzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXkuPEFycmF5PG51bWJlcj4+fSAtIEFycmF5IG9mIHRyaWFuZ2xlIGluZGljZXMuXG4gICAqL1xuICBzdGF0aWMgZ2V0RGVsYXVuYXlUcmlhbmd1bGF0aW9uKHZlcnRpY2VzKSB7XG4gICAgaWYgKCF2ZXJ0aWNlcyB8fCB2ZXJ0aWNlcy5sZW5ndGggPCAzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgZ2V0IGRlbGF1bmF5IHRyaWFuZ3VsYXRpb24gZm9yIHBvaW50cyAke3ZlcnRpY2VzfS4gSW5wdXQgbXVzdCBjb250YWluIGF0IGxlYXN0IHRocmVlIHBvaW50cy5gXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCBtaW5YID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGxldCBtaW5ZID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGxldCBtYXhYID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIGxldCBtYXhZID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuXG4gICAgdmVydGljZXMuZm9yRWFjaCh2ID0+IHtcbiAgICAgIG1pblggPSB2WzBdIDwgbWluWCA/IHZbMF0gOiBtaW5YO1xuICAgICAgbWluWSA9IHZbMV0gPCBtaW5ZID8gdlsxXSA6IG1pblk7XG4gICAgICBtYXhYID0gdlswXSA+IG1heFggPyB2WzBdIDogbWF4WDtcbiAgICAgIG1heFkgPSB2WzFdID4gbWF4WSA/IHZbMV0gOiBtYXhZO1xuICAgIH0pO1xuXG4gICAgY29uc3QgZFggPSBtYXhYIC0gbWluWDtcbiAgICBjb25zdCBkWSA9IG1heFkgLSBtaW5ZO1xuICAgIGNvbnN0IG1pZFggPSAobWluWCArIG1heFgpIC8gMjtcbiAgICBjb25zdCBtaWRZID0gKG1pblkgKyBtYXhZKSAvIDI7XG4gICAgY29uc3QgZE1heCA9IGRYID4gZFkgPyBkWCA6IGRZO1xuXG4gICAgY29uc3Qgc3VwZXJJbmRpY2VzID0gW1xuICAgICAgdmVydGljZXMubGVuZ3RoLFxuICAgICAgdmVydGljZXMubGVuZ3RoICsgMSxcbiAgICAgIHZlcnRpY2VzLmxlbmd0aCArIDIsXG4gICAgXTtcblxuICAgIGNvbnN0IHZlcnRzV2l0aFN1cGVyID0gW1xuICAgICAgLi4udmVydGljZXMsXG4gICAgICBbbWlkWCAtIDIwICogZE1heCwgbWlkWSAtIGRNYXhdLFxuICAgICAgW21pZFgsIG1pZFkgKyAyMCAqIGRNYXhdLFxuICAgICAgW21pZFggKyAyMCAqIGRNYXgsIG1pZFkgLSBkTWF4XSxcbiAgICBdO1xuXG4gICAgY29uc3Qgc3VwZXJTb3J0ZWRJbmRpY2VzID0gTWF0aFV0aWxzLnNvcnRQb2ludHNDQ1coXG4gICAgICBzdXBlckluZGljZXMsXG4gICAgICB2ZXJ0c1dpdGhTdXBlclxuICAgICk7XG5cbiAgICBjb25zdCBzdXBlclRyaWFuZ2xlID0ge1xuICAgICAgaW5kaWNlczogc3VwZXJTb3J0ZWRJbmRpY2VzLFxuICAgICAgZWRnZXM6IFtcbiAgICAgICAgW3N1cGVyU29ydGVkSW5kaWNlc1swXSwgc3VwZXJTb3J0ZWRJbmRpY2VzWzFdXSxcbiAgICAgICAgW3N1cGVyU29ydGVkSW5kaWNlc1sxXSwgc3VwZXJTb3J0ZWRJbmRpY2VzWzJdXSxcbiAgICAgICAgW3N1cGVyU29ydGVkSW5kaWNlc1syXSwgc3VwZXJTb3J0ZWRJbmRpY2VzWzBdXSxcbiAgICAgIF0sXG4gICAgfTtcblxuICAgIGNvbnN0IHRyaWFuZ2xlcyA9IFtzdXBlclRyaWFuZ2xlXTtcblxuICAgIHZlcnRzV2l0aFN1cGVyLmZvckVhY2goKG5ld1ZlcnQsIG5ld0luZGV4KSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkVHJpYW5nbGVzID0gW107XG4gICAgICB0cmlhbmdsZXMuZm9yRWFjaCh0cmlhbmdsZSA9PiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBNYXRoVXRpbHMuaXNQb2ludEluQ2lyY3VtQ2lyY2xlKFxuICAgICAgICAgICAgdmVydHNXaXRoU3VwZXJbdHJpYW5nbGUuaW5kaWNlc1swXV0sXG4gICAgICAgICAgICB2ZXJ0c1dpdGhTdXBlclt0cmlhbmdsZS5pbmRpY2VzWzFdXSxcbiAgICAgICAgICAgIHZlcnRzV2l0aFN1cGVyW3RyaWFuZ2xlLmluZGljZXNbMl1dLFxuICAgICAgICAgICAgbmV3VmVydFxuICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgaW52YWxpZFRyaWFuZ2xlcy5wdXNoKHRyaWFuZ2xlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGJvdW5kaW5nUG9seSA9IFtdO1xuICAgICAgaW52YWxpZFRyaWFuZ2xlcy5mb3JFYWNoKHRyaWFuZ2xlID0+IHtcbiAgICAgICAgdHJpYW5nbGUuZWRnZXMuZm9yRWFjaChlZGdlID0+IHtcbiAgICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICAgIGludmFsaWRUcmlhbmdsZXMuZm9yRWFjaChvdGhlclRyaWFuZ2xlID0+IHtcbiAgICAgICAgICAgIGlmICh0cmlhbmdsZSAhPT0gb3RoZXJUcmlhbmdsZSkge1xuICAgICAgICAgICAgICBvdGhlclRyaWFuZ2xlLmVkZ2VzLmZvckVhY2gob3RoZXJFZGdlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAoZWRnZVswXSA9PT0gb3RoZXJFZGdlWzBdICYmIGVkZ2VbMV0gPT09IG90aGVyRWRnZVsxXSkgfHxcbiAgICAgICAgICAgICAgICAgIChlZGdlWzFdID09PSBvdGhlckVkZ2VbMF0gJiYgZWRnZVswXSA9PT0gb3RoZXJFZGdlWzFdKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChjb3VudCA9PT0gMCkgYm91bmRpbmdQb2x5LnB1c2goZWRnZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGludmFsaWRUcmlhbmdsZXMuZm9yRWFjaCh0cmlhbmdsZSA9PiB7XG4gICAgICAgIHRyaWFuZ2xlcy5zcGxpY2UodHJpYW5nbGVzLmluZGV4T2YodHJpYW5nbGUpLCAxKTtcbiAgICAgIH0pO1xuXG4gICAgICBib3VuZGluZ1BvbHkuZm9yRWFjaChlZGdlID0+IHtcbiAgICAgICAgY29uc3Qgc29ydGVkSW5kaWNlcyA9IE1hdGhVdGlscy5zb3J0UG9pbnRzQ0NXKFxuICAgICAgICAgIFtlZGdlWzBdLCBlZGdlWzFdLCBuZXdJbmRleF0sXG4gICAgICAgICAgdmVydHNXaXRoU3VwZXJcbiAgICAgICAgKTtcblxuICAgICAgICB0cmlhbmdsZXMucHVzaCh7XG4gICAgICAgICAgaW5kaWNlczogc29ydGVkSW5kaWNlcyxcbiAgICAgICAgICBlZGdlczogW1xuICAgICAgICAgICAgW3NvcnRlZEluZGljZXNbMF0sIHNvcnRlZEluZGljZXNbMV1dLFxuICAgICAgICAgICAgW3NvcnRlZEluZGljZXNbMV0sIHNvcnRlZEluZGljZXNbMl1dLFxuICAgICAgICAgICAgW3NvcnRlZEluZGljZXNbMl0sIHNvcnRlZEluZGljZXNbMF1dLFxuICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCB0cmlhbmdsZXNUb1JlbW92ZSA9IFtdO1xuICAgIHRyaWFuZ2xlcy5mb3JFYWNoKHRyaWFuZ2xlID0+IHtcbiAgICAgIHRyaWFuZ2xlLmluZGljZXMuZm9yRWFjaChpbmRleCA9PiB7XG4gICAgICAgIGlmIChzdXBlckluZGljZXMuaW5jbHVkZXMoaW5kZXgpKSB7XG4gICAgICAgICAgdHJpYW5nbGVzVG9SZW1vdmUucHVzaCh0cmlhbmdsZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdHJpYW5nbGVzVG9SZW1vdmUuZm9yRWFjaCh0cmlhbmdsZSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IHRyaWFuZ2xlcy5pbmRleE9mKHRyaWFuZ2xlKTtcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdHJpYW5nbGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdHJpYW5nbGVzLm1hcCh0cmlhbmdsZSA9PiB0cmlhbmdsZS5pbmRpY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gMkQgcG9pbnQgaXMgd2l0aGluIHRoZSBjaWNydW1jaXJjbGVcbiAgICogZGVmaW5lZCBieSB0aHJlZSAyRCBwb2ludHMuIFRoZSB0cmlhbmdsZSBwb2ludHMgbXVzdCBiZSBpblxuICAgKiBjb3VudGVyLWNsb2Nrd2lzZSBvcmRlciBhIC0+IGIgLT4gYy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYSAtIEZpcnN0IHRyaWFuZ2xlIHBvaW50LlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBiIC0gU2Vjb25kIHRyaWFuZ2xlIHBvaW50LlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBjIC0gVGhpcmQgdHJpYW5nbGUgcG9pbnQuXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHAgLSAyRCBwb2ludC5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNQb2ludEluQ2lyY3VtQ2lyY2xlKGEsIGIsIGMsIHApIHtcbiAgICBjb25zdCBheCA9IGFbMF0gLSBwWzBdO1xuICAgIGNvbnN0IGF5ID0gYVsxXSAtIHBbMV07XG4gICAgY29uc3QgYnggPSBiWzBdIC0gcFswXTtcbiAgICBjb25zdCBieSA9IGJbMV0gLSBwWzFdO1xuICAgIGNvbnN0IGN4ID0gY1swXSAtIHBbMF07XG4gICAgY29uc3QgY3kgPSBjWzFdIC0gcFsxXTtcblxuICAgIHJldHVybiAoXG4gICAgICAoYXggKiBheCArIGF5ICogYXkpICogKGJ4ICogY3kgLSBjeCAqIGJ5KSAtXG4gICAgICAgIChieCAqIGJ4ICsgYnkgKiBieSkgKiAoYXggKiBjeSAtIGN4ICogYXkpICtcbiAgICAgICAgKGN4ICogY3ggKyBjeSAqIGN5KSAqIChheCAqIGJ5IC0gYnggKiBheSkgPlxuICAgICAgMFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIDJEIHBvaW50IGlzIHdpdGhpbiBhIGdpdmVuIHRyaWFuZ2xlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBhIC0gRmlyc3QgdHJpYW5nbGUgcG9pbnQuXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGIgLSBTZWNvbmQgdHJpYW5nbGUgcG9pbnQuXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGMgLSBUaGlyZCB0cmlhbmdsZSBwb2ludC5cbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcCAtIDJEIHBvaW50LlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc1BvaW50SW5UcmlhbmdsZShhLCBiLCBjLCBwKSB7XG4gICAgY29uc3QgZGVub20gPSAoYlsxXSAtIGNbMV0pICogKGFbMF0gLSBjWzBdKSArIChjWzBdIC0gYlswXSkgKiAoYVsxXSAtIGNbMV0pO1xuICAgIGNvbnN0IGFWYWwgPVxuICAgICAgKChiWzFdIC0gY1sxXSkgKiAocFswXSAtIGNbMF0pICsgKGNbMF0gLSBiWzBdKSAqIChwWzFdIC0gY1sxXSkpIC8gZGVub207XG4gICAgY29uc3QgYlZhbCA9XG4gICAgICAoKGNbMV0gLSBhWzFdKSAqIChwWzBdIC0gY1swXSkgKyAoYVswXSAtIGNbMF0pICogKHBbMV0gLSBjWzFdKSkgLyBkZW5vbTtcbiAgICBjb25zdCBjVmFsID0gMSAtIGFWYWwgLSBiVmFsO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIGFWYWwgPj0gMCAmJiBhVmFsIDw9IDEgJiYgYlZhbCA+PSAwICYmIGJWYWwgPD0gMSAmJiBjVmFsID49IDAgJiYgY1ZhbCA8PSAxXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzb3J0ZWQgaW5kaWNlcyBvZiBhIGdpdmVuIHNldCBvZiAyRCBwb2ludHMgaW5cbiAgICogY291bnRlci1jbG9ja3dpc2Ugb3JkZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGluZGljZXMgLSBMaXN0IG9mIGluZGljZXMuXG4gICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gdmVydGljZXMgLSBMaXN0IG9mIDJEIHBvaW50cy5cbiAgICpcbiAgICogQHJldHVybnMge0FycmF5LjxBcnJheS48bnVtYmVyPj59IC0gTGlzdCBvZiBzb3J0ZWQgaW5kaWNlcy5cbiAgICovXG4gIHN0YXRpYyBzb3J0UG9pbnRzQ0NXKGluZGljZXMsIHZlcnRpY2VzKSB7XG4gICAgY29uc3QgY2VudHJvaWQgPSBbMCwgMF07XG4gICAgaW5kaWNlcy5mb3JFYWNoKGluZGV4ID0+IHtcbiAgICAgIGNlbnRyb2lkWzBdICs9IHZlcnRpY2VzW2luZGV4XVswXTtcbiAgICAgIGNlbnRyb2lkWzFdICs9IHZlcnRpY2VzW2luZGV4XVsxXTtcbiAgICB9KTtcbiAgICBjZW50cm9pZFswXSAvPSBpbmRpY2VzLmxlbmd0aDtcbiAgICBjZW50cm9pZFsxXSAvPSBpbmRpY2VzLmxlbmd0aDtcblxuICAgIGluZGljZXMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgY29uc3QgYlZhbCA9IE1hdGguYXRhbjIoXG4gICAgICAgIHZlcnRpY2VzW2JdWzFdIC0gY2VudHJvaWRbMV0sXG4gICAgICAgIHZlcnRpY2VzW2JdWzBdIC0gY2VudHJvaWRbMF1cbiAgICAgICk7XG4gICAgICBjb25zdCBhVmFsID0gTWF0aC5hdGFuMihcbiAgICAgICAgdmVydGljZXNbYV1bMV0gLSBjZW50cm9pZFsxXSxcbiAgICAgICAgdmVydGljZXNbYV1bMF0gLSBjZW50cm9pZFswXVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIGFWYWwgLSBiVmFsO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGluZGljZXM7XG4gIH1cblxuICAvKipcbiAgICogQ2FjbHVhdGVzIHRoZSBhcmVhIG9mIGEgdHJpYW5nbGVcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYSAtIEZpcnN0IHRyaWFuZ2xlIHBvaW50LlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBiIC0gU2Vjb25kIHRyaWFuZ2xlIHBvaW50LlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBjIC0gVGhpcmQgdHJpYW5nbGUgcG9pbnQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBzdGF0aWMgdHJpYW5nbGVBcmVhKGEsIGIsIGMpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoXG4gICAgICAoYVswXSAqIChiWzFdIC0gY1sxXSkgKyBiWzBdICogKGNbMV0gLSBhWzFdKSArIGNbMF0gKiAoYVsxXSAtIGJbMV0pKSAqIDAuNVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBtYWduaXR1ZGUgb2YgYSBnaXZlbiB2ZWN0b3IgYXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHZlY3RvciAtIEFycmF5IGNvbnNpc3Rpbmcgb2YgbnVtYmVycy5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIHN0YXRpYyBnZXRWZWN0b3JNYWduaXR1ZGUodmVjdG9yKSB7XG4gICAgaWYgKCEodmVjdG9yIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgZ2V0IG1hZ25pdHVkZSBmb3IgdmVjdG9yICR7dmVjdG9yfS4gSW5wdXQgbXVzdCBiZSBhbiBBcnJheSBudW1iZXJzLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVkdWNlciA9IChhY2N1bXVsYXRvciwgY3VycmVudFZhbHVlKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGN1cnJlbnRWYWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBDYW5ub3QgZ2V0IG1hZ25pdHVkZSBmb3IgdmVjdG9yICR7dmVjdG9yfS4gQWxsIGl0ZW1zIGluIHRoZSBpbnB1dCBBcnJheSBtdXN0IGJlIG51bWJlcnMuYFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWNjdW11bGF0b3IgKyBjdXJyZW50VmFsdWUgKiogMjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE1hdGguc3FydCh2ZWN0b3IucmVkdWNlKHJlZHVjZXIsIDApKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGRvdCBwcm9kdWN0IGJldHdlZW4gdHdvIHZlY3RvcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHZlY3RvckEgLSBBcnJheSBjb25zaXN0aW5nIG9mIG51bWJlcnMuXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHZlY3RvckIgLSBBcnJheSBjb25zaXN0aW5nIG9mIG51bWJlcnMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0RG90UHJvZHVjdCh2ZWN0b3JBLCB2ZWN0b3JCKSB7XG4gICAgaWYgKFxuICAgICAgISh2ZWN0b3JBIGluc3RhbmNlb2YgQXJyYXkpIHx8XG4gICAgICAhKHZlY3RvckIgaW5zdGFuY2VvZiBBcnJheSkgfHxcbiAgICAgIHZlY3RvckEubGVuZ3RoICE9PSB2ZWN0b3JCLmxlbmd0aFxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGdldCBkb3QgcHJvZHVjdCBiZXR3ZWVuICR7dmVjdG9yQX0gYW5kICR7dmVjdG9yQn0uIElucHV0cyBtdXN0IGJlIHZlY3RvcnMgb2YgdGhlIHNhbWUgbGVuZ3RoLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgdmVjdG9yQS5mb3JFYWNoKCh2YWx1ZUEsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZUIgPSB2ZWN0b3JCW2luZGV4XTtcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZUEgIT09ICdudW1iZXInIHx8IHR5cGVvZiB2YWx1ZUIgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQ2Fubm90IGdldCBkb3QgcHJvZHVjdCBiZXR3ZWVuICR7dmVjdG9yQX0gYW5kICR7dmVjdG9yQn0uIFZlY3RvcnMgbXVzdCBvbmx5IGNvbnNpc3Qgb2YgbnVtZXJpYyB2YWx1ZXMuYFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQgKz0gdmFsdWVBICogdmFsdWVCO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGFuZ2xlIGluIHJhZGlhbnMgYmV0d2VlbiB2ZWN0b3JBIGFuZCB2ZWN0b3JCLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2ZWN0b3JBIC0gQXJyYXkgY29uc2lzdGluZyBvZiBudW1iZXJzLlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2ZWN0b3JCIC0gQXJyYXkgY29uc2lzdGluZyBvZiBudW1iZXJzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgc3RhdGljIGdldEFuZ2xlQmV0d2Vlbih2ZWN0b3JBLCB2ZWN0b3JCKSB7XG4gICAgY29uc3Qgbm9ybWFsQSA9IHRoaXMubm9ybWFsaXplVmVjdG9yKFsuLi52ZWN0b3JBXSk7XG4gICAgY29uc3Qgbm9ybWFsQiA9IHRoaXMubm9ybWFsaXplVmVjdG9yKFsuLi52ZWN0b3JCXSk7XG4gICAgY29uc3QgZG90ID0gdGhpcy5nZXREb3RQcm9kdWN0KG5vcm1hbEEsIG5vcm1hbEIpO1xuXG4gICAgcmV0dXJuIE1hdGguYWNvcyh0aGlzLmNsYW1wKGRvdCwgLTEsIDEpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNdWx0aXBseSBhIDN4MyByb3RhdGlvbiBtYXRyaXggd2l0aCBhIHZlY3RvcjMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHZlY3RvcjMgLSBBcnJheSBjb25zaXN0aW5nIG9mIDMgbnVtYmVycyByZXByZXNlbnRpbmdcbiAgICogYSBkaXJlY3Rpb24gdmVjdG9yLlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtYXRyaXgzIC0gQW4gYXJyYXkgb2YgOSBudW1iZXJzIHJlcHJlc2VudGluZyBhIHJvd1xuICAgKiBtYWpvciByb3RhdGlvbiBtYXRyaXguXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheS48bnVtYmVyPn0gLSBBbiBhcnJheSBvZiAzIG51bWJlcnMgcmVwcmVzZW50aW5nIHRoZSBuZXcgZGlyZWN0aW9uXG4gICAqIG9mIHRoZSB2ZWN0b3IuXG4gICAqL1xuICBzdGF0aWMgcm90YXRlVmVjdG9yKHZlY3RvcjMsIG1hdHJpeDMpIHtcbiAgICBpZiAoXG4gICAgICAhKHZlY3RvcjMgaW5zdGFuY2VvZiBBcnJheSkgfHxcbiAgICAgIHZlY3RvcjMubGVuZ3RoICE9PSAzIHx8XG4gICAgICAhdmVjdG9yMy5ldmVyeSh2ID0+IHR5cGVvZiB2ID09PSAnbnVtYmVyJylcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCByb3RhdGUgdmVjdG9yICR7dmVjdG9yM30gYnkgcm90YXRpb24gbWF0cml4ICR7bWF0cml4M30uIElucHV0IHZlY3RvciBtdXN0IGJlIGFuIGFycmF5IG9mIDMgbnVtYmVycy5gXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgICEobWF0cml4MyBpbnN0YW5jZW9mIEFycmF5KSB8fFxuICAgICAgbWF0cml4My5sZW5ndGggIT09IDkgfHxcbiAgICAgICFtYXRyaXgzLmV2ZXJ5KHYgPT4gdHlwZW9mIHYgPT09ICdudW1iZXInKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IHJvdGF0ZSB2ZWN0b3IgJHt2ZWN0b3IzfSBieSByb3RhdGlvbiBtYXRyaXggJHttYXRyaXgzfS4gSW5wdXQgbWF0cml4MyBtdXN0IGJlIGFuIGFycmF5IG9mIDkgbnVtYmVycy5gXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHggPVxuICAgICAgbWF0cml4M1swXSAqIHZlY3RvcjNbMF0gK1xuICAgICAgbWF0cml4M1szXSAqIHZlY3RvcjNbMV0gK1xuICAgICAgbWF0cml4M1s2XSAqIHZlY3RvcjNbMl07XG4gICAgY29uc3QgeSA9XG4gICAgICBtYXRyaXgzWzFdICogdmVjdG9yM1swXSArXG4gICAgICBtYXRyaXgzWzRdICogdmVjdG9yM1sxXSArXG4gICAgICBtYXRyaXgzWzddICogdmVjdG9yM1syXTtcbiAgICBjb25zdCB6ID1cbiAgICAgIG1hdHJpeDNbMl0gKiB2ZWN0b3IzWzBdICtcbiAgICAgIG1hdHJpeDNbNV0gKiB2ZWN0b3IzWzFdICtcbiAgICAgIG1hdHJpeDNbOF0gKiB2ZWN0b3IzWzJdO1xuXG4gICAgcmV0dXJuIFt4LCB5LCB6XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemUgYSBnaXZlbiB2ZWN0b3IgYXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHZlY3RvciAtIEFycmF5IGNvbnNpc3Rpbmcgb2YgbnVtYmVycy5cbiAgICpcbiAgICogQHJldHVybnMge0FycmF5LjxudW1iZXI+fSBUaGUgb3JpZ2luYWwgdmVjdG9yIHdpdGggbm9ybWFsaXplZCB2YWx1ZXMsIGZvciBjaGFpbmluZy5cbiAgICovXG4gIHN0YXRpYyBub3JtYWxpemVWZWN0b3IodmVjdG9yKSB7XG4gICAgY29uc3QgbWFnbml0dWRlID0gdGhpcy5nZXRWZWN0b3JNYWduaXR1ZGUodmVjdG9yKTtcblxuICAgIGlmIChtYWduaXR1ZGUgPT09IDApIHtcbiAgICAgIHZlY3Rvci5maWxsKDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2ZWN0b3IuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgIHZlY3RvcltpbmRleF0gPSB2YWx1ZSAvIG1hZ25pdHVkZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB2ZWN0b3I7XG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdCB0aGUgM3gzIHJvdGF0aW9uIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gNHg0IHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF0cml4NCAtIEFuIGFycmF5IG9mIDE2IG51bWJlcnMgcmVwcmVzZW50aW5nIGEgcm93XG4gICAqIG1ham9yIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cbiAgICpcbiAgICogQHJldHVybnMge0FycmF5LjxudW1iZXI+fSAtIEFuIGFycmF5IG9mIDkgbnVtYmVycyByZXByZXNlbnRpbmcgYSByb3cgbWFqb3JcbiAgICogcm90YXRpb24gbWF0cml4LlxuICAgKi9cbiAgc3RhdGljIGdldFJvdGF0aW9uTWF0cml4KG1hdHJpeDQpIHtcbiAgICBpZiAoXG4gICAgICAhKG1hdHJpeDQgaW5zdGFuY2VvZiBBcnJheSkgfHxcbiAgICAgIG1hdHJpeDQubGVuZ3RoICE9PSAxNiB8fFxuICAgICAgIW1hdHJpeDQuZXZlcnkodiA9PiB0eXBlb2YgdiA9PT0gJ251bWJlcicpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgY29udmVydCBtYXRyaXggJHttYXRyaXg0fSB0byBhIHJvdGF0aW9uIG1hdHJpeC4gSW5wdXQgbWF0cml4IG11c3QgYmUgYW4gYXJyYXkgb2YgMTYgbnVtYmVycy5gXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEV4dHJhY3Qgc2NhbGVcbiAgICBjb25zdCBzY2FsZVggPSAxIC8gKHRoaXMuZ2V0VmVjdG9yTWFnbml0dWRlKG1hdHJpeDQuc2xpY2UoMCwgNCkpIHx8IDEpO1xuICAgIGNvbnN0IHNjYWxlWSA9IDEgLyAodGhpcy5nZXRWZWN0b3JNYWduaXR1ZGUobWF0cml4NC5zbGljZSg0LCA4KSkgfHwgMSk7XG4gICAgY29uc3Qgc2NhbGVaID0gMSAvICh0aGlzLmdldFZlY3Rvck1hZ25pdHVkZShtYXRyaXg0LnNsaWNlKDgsIDEyKSkgfHwgMSk7XG5cbiAgICByZXR1cm4gW1xuICAgICAgbWF0cml4NFswXSAqIHNjYWxlWCxcbiAgICAgIG1hdHJpeDRbMV0gKiBzY2FsZVgsXG4gICAgICBtYXRyaXg0WzJdICogc2NhbGVYLFxuICAgICAgbWF0cml4NFs0XSAqIHNjYWxlWSxcbiAgICAgIG1hdHJpeDRbNV0gKiBzY2FsZVksXG4gICAgICBtYXRyaXg0WzZdICogc2NhbGVZLFxuICAgICAgbWF0cml4NFs4XSAqIHNjYWxlWixcbiAgICAgIG1hdHJpeDRbOV0gKiBzY2FsZVosXG4gICAgICBtYXRyaXg0WzEwXSAqIHNjYWxlWixcbiAgICBdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBjb250YWluaW5nIHRoZSBzcGhlcmljYWwgY29vcmRpbmF0ZXMgb2YgdGhlIGdpdmVuIGNhcnRlc2lhblxuICAgKiB4eXogY29vcmRpbmF0ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gUG9zaXRpb24gYWxvbmcgdGhlIHggYXhpcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBQb3NpdGlvbiBhbG9uZyB0aGUgeSBheGlzLlxuICAgKiBAcGFyYW0ge251bWJlcn0geiAtIFBvc2l0aW9uIGFsb25nIHRoZSB6IGF4aXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheS48bnVtYmVyPn0gLSBBbiBhcnJheSBjb25zaXN0aW5nIG9mIHRocmVlIG51bWJlcmVzIHdoZXJlIGluZGV4XG4gICAqIDAgcmVwcmVzZW50cyB0aGUgcmFkaXVzLCBpbmRleCAxIHJlcHJlc2VudHMgdGhlIHZlcnRpY2FsL3BvbGFyIGFuZ2xlIGluIHJhZGlhbnNcbiAgICogYW5kIGluZGV4IDIgcmVwcmVzZW50cyB0aGUgaG9yaXpvbnRhbC9hemltdXRoYWwgYW5nbGUgaW4gcmFkaWFucy5cbiAgICovXG4gIHN0YXRpYyBjYXJ0ZXNpYW5Ub1NwaGVyaWNhbCh4LCB5LCB6KSB7XG4gICAgY29uc3QgciA9IHRoaXMuZ2V0VmVjdG9yTWFnbml0dWRlKFt4LCB5LCB6XSk7XG5cbiAgICAvLyBSZXR1cm4gaWRlbnRpdHkgaWYgdGhlIHZlY3RvciBoYXMgbm8gbGVuZ3RoXG4gICAgaWYgKHIgPT09IDApIHtcbiAgICAgIHJldHVybiBbMCwgMCwgMF07XG4gICAgfVxuXG4gICAgcmV0dXJuIFtyLCBNYXRoLmFjb3ModGhpcy5jbGFtcCh5IC8gciwgLTEsIDEpKSwgTWF0aC5hdGFuMih4LCB6KV07XG4gIH1cblxuICAvKipcbiAgICogR3JhZHVhbGx5IGNoYW5nZSBhIHZhbHVlIG9mIGEgbnVtZXJpYyBwcm9wZXJ0eSB0b3dhcmRzIGEgZ29hbCBvdmVyIHRpbWUgdXNpbmdcbiAgICogYSBjcml0aWNhbGx5IGRhbXBlZCBzcHJpbmcgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50VmFsdWUgLSBUaGUgc3RhcnRpbmcgdmFsdWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXRWYWx1ZS0gVGhlIGdvYWwgdmFsdWUuXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFt2YWx1ZVN0b3JlID0gWzAsIDBdXSAtIEFuIEFycmF5IGNvbnNpc3Rpbmcgb2YgdHdvXG4gICAqIG51bWJlcnMgd2hlcmUgdGhlIGZpcnN0IG51bWJlciBob2xkcyB0aGUgcmVzdWx0IHZhbHVlIGFuZCB0aGUgc2Vjb25kIGhvbGRzXG4gICAqIHRoZSB2ZWxvY2l0eSB0aGF0IHJlc3VsdGVkIGluIHRoYXQgdmFsdWUuIFRoZSBzYW1lIGFycmF5IHNob3VsZCBiZSBwcm92aWRlZFxuICAgKiB3aXRoIGVhY2ggY2FsbCB0byB0aGlzIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RlbHRhVGltZSA9IDFlLTddIC0gVGhlIHRpbWUgc2luY2UgdGhlIGxhc3QgY2FsbCB0byB0aGlzIGZ1bmN0aW9uXG4gICAqIGluIHNlY29uZHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc21vb3RoVGltZSA9IDAuM10gLSBUaGUgYXBwcm94aW1hdGUgYW1vdW50IG9mIHRpbWUgaW4gc2Vjb25kc1xuICAgKiBpdCBzaG91bGQgdGFrZSB0byByZWFjaCB0aGUgdGFyZ2V0IHZhbHVlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW21heFNwZWVkID0gMWU3XSAtIEEgY2xhbXBpbmcgdmFsdWUgZm9yIHRoZSBtYXhpbXVtIHNwZWVkIHRoZVxuICAgKiB2YWx1ZSBjYW4gY2hhbmdlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59IC0gVGhlIHZhbHVlU3RvcmUgYXJyYXkuXG4gICAqL1xuICBzdGF0aWMgZGFtcFZhbHVlKFxuICAgIGN1cnJlbnRWYWx1ZSxcbiAgICB0YXJnZXRWYWx1ZSxcbiAgICB2YWx1ZVN0b3JlID0gWzAsIDBdLFxuICAgIGRlbHRhVGltZSA9IDFlLTcsXG4gICAgc21vb3RoVGltZSA9IDAuMyxcbiAgICBtYXhTcGVlZCA9IDFlN1xuICApIHtcbiAgICBzbW9vdGhUaW1lID0gTWF0aC5tYXgoMC4wMDAxLCBzbW9vdGhUaW1lKTtcbiAgICBkZWx0YVRpbWUgPSBNYXRoLm1heCgxZS03LCBkZWx0YVRpbWUpO1xuXG4gICAgLy8gRmluZCB0aGUgZGVsdGEgYmV0d2VlbiB2YWx1ZXMgYW5kIHVzZSBpdCB0byBlc3RpbWF0ZSB0aGUgcHJldmlvdXMgdmFsdWVcbiAgICBjb25zdCBjbGFtcFRpbWUgPSBtYXhTcGVlZCAqIHNtb290aFRpbWU7XG4gICAgY29uc3QgZGVsdGFWYWx1ZSA9IGN1cnJlbnRWYWx1ZSAtIHRhcmdldFZhbHVlO1xuICAgIGNvbnN0IGNsYW1wRGVsdGFWYWx1ZSA9IHRoaXMuY2xhbXAoZGVsdGFWYWx1ZSwgLWNsYW1wVGltZSwgY2xhbXBUaW1lKTtcbiAgICBjb25zdCBsYXN0VmFsdWUgPSBjdXJyZW50VmFsdWUgLSBjbGFtcERlbHRhVmFsdWU7XG5cbiAgICAvLyBDYWxjdWxhdGUgZGFtcGluZyBmYWN0b3JzXG4gICAgY29uc3QgZDEgPSAyIC8gc21vb3RoVGltZTtcbiAgICBjb25zdCBkMiA9IGQxICogZGVsdGFUaW1lO1xuICAgIGNvbnN0IGQzID0gMSAvICgxICsgZDIgKyAwLjUgKiBkMiAqKiAyICsgMC4yNSAqIGQyICoqIDMpO1xuICAgIGNvbnN0IGQ0ID0gKHZhbHVlU3RvcmVbMV0gKyBkMSAqIGNsYW1wRGVsdGFWYWx1ZSkgKiBkZWx0YVRpbWU7XG5cbiAgICAvLyBEYW1wIHRoZSB0YXJnZXQgdmFsdWUgYW5kIHVwZGF0ZSB0aGUgdmVsb2NpdHlcbiAgICB2YWx1ZVN0b3JlWzBdID0gbGFzdFZhbHVlICsgKGNsYW1wRGVsdGFWYWx1ZSArIGQ0KSAqIGQzO1xuICAgIHZhbHVlU3RvcmVbMV0gPSAodmFsdWVTdG9yZVsxXSAtIGQxICogZDQpICogZDM7XG5cbiAgICAvLyBQcmV2ZW50IG92ZXJzaG9vdGluZ1xuICAgIGlmICh0YXJnZXRWYWx1ZSAtIGN1cnJlbnRWYWx1ZSA+IDAgPT09IHZhbHVlU3RvcmVbMF0gPiB0YXJnZXRWYWx1ZSkge1xuICAgICAgdmFsdWVTdG9yZVswXSA9IHRhcmdldFZhbHVlO1xuICAgICAgdmFsdWVTdG9yZVsxXSA9ICh2YWx1ZVN0b3JlWzBdIC0gdGFyZ2V0VmFsdWUpIC8gZGVsdGFUaW1lO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZVN0b3JlO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1hdGhVdGlscztcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXG4vKiBlc2xpbnQtZGlzYWJsZSBpbXBvcnQvcHJlZmVyLWRlZmF1bHQtZXhwb3J0ICovXG5cbi8qKlxuICogSW5kaWNhdGVzIHRoZSB0eXBlIG9mIGhvc3QgYnVpbGQuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuY29uc3QgZW52ID0gJ2NvcmUnO1xuXG5leHBvcnQge2Vudn07XG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZXJzY29yZS1kYW5nbGUgKi9cbmltcG9ydCBVdGlscyBmcm9tICcuL1V0aWxzJztcblxuLyoqXG4gKiBDbGFzcyB0aGF0IGNhbiBleGVjdXRlIGZ1bmN0aW9ucyB3aGVuIGxvY2FsIG1lc3NhZ2VzIGFyZSByZWNlaXZlZC4gTG9jYWwgbWVzc2FnZXNcbiAqIGFyZSBwcmVmaXhlZCB3aXRoIHRoZSBpbnN0YW5jZSdzIGlkLlxuICpcbiAqIEBhbGlhcyBjb3JlL01lc3NlbmdlclxuICpcbiAqIEBwcm9wZXJ0eSB7Y29yZS9NZXNzZW5nZXJ9IEdsb2JhbE1lc3NlbmdlciAtIEEgbWVzc2VuZ2VyIHRoYXQgY2FuIGJlIHVzZWQgZm9yXG4gKiBnbG9iYWwgbWVzc2FnaW5nLiBXaGVuIHVzaW5nIHN0YXRpYyBsaXN0ZW4gYW5kIGVtaXQgbWV0aG9kcyB0aGV5IGFyZSBleGVjdXRlZFxuICogb24gdGhpcyBtZXNzZW5nZXIuXG4gKiBAcHJvcGVydHkge09iamVjdH0gRVZFTlRTIC0gQnVpbHQtaW4gZXZlbnRzIHRoYXQgdGhlIE1lc3NlbmdlciBlbWl0cy5cbiAqL1xuY2xhc3MgTWVzc2VuZ2VyIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0ge2FueT19IGlkIC0gSWQgZm9yIHRoZSBvYmplY3QuIElmIG5vbmUgaXMgcHJvdmlkZWQgYSBuZXcgaWQgd2lsbFxuICAgKiBiZSBjcmVhdGVkLiBJZCBzaG91bGQgYmUgYWJsZSB0byBiZSByZXByZXNlbnRlZCBhcyBhIHN0cmluZy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGlkKSB7XG4gICAgdGhpcy5faWQgPSBpZCAhPT0gdW5kZWZpbmVkID8gaWQgOiBVdGlscy5jcmVhdGVJZCgpO1xuICAgIHRoaXMuX2Rpc3BhdGNoZXIgPSB3aW5kb3c7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XG4gICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnMgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzdHJpbmcgaWQgb2YgdGhlIG9iamVjdC5cbiAgICpcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lkO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZWZpeCBhIG1lc3NhZ2Ugd2l0aCB0aGUgaW5zdGFuY2UgaWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBfY3JlYXRlTG9jYWxNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5pZH0uJHttZXNzYWdlfWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGNhbGwgYSBjYWxsYmFjayBmdW5jdGlvbiBhbmQgc3VwcGx5IHRoZSBldmVudCdzXG4gICAqIGRldGFpbCBwcm9wZXJ0eSBhcyBhbiBhcmd1bWVudC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICpcbiAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgKi9cbiAgX2NyZWF0ZUxpc3RlbmVyKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGUgPT4ge1xuICAgICAgbGV0IHZhbHVlO1xuXG4gICAgICBpZiAoZS5kZXRhaWwgIT09IG51bGwpIHtcbiAgICAgICAgdmFsdWUgPSBlLmRldGFpbDtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sodmFsdWUpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGV2ZW50IG9iamVjdCBhbmQgc2VuZCBpdCB0byBsaXN0ZW5lcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gRXZlbnQgdHlwZSBuYW1lLlxuICAgKiBAcGFyYW0ge2FueT19IHZhbHVlIC0gVmFsdWUgdG8gc2VuZCB0byBsaXN0ZW5lcnMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtDdXN0b21FdmVudH1cbiAgICovXG4gIF9jcmVhdGVFdmVudChtZXNzYWdlLCB2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgQ3VzdG9tRXZlbnQobWVzc2FnZSwge2RldGFpbDogdmFsdWV9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhbiBldmVudC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBFdmVudCB0eXBlIG5hbWUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIC0gQSBsaXN0ZW5lciBmdW5jdGlvbiBnZW5lcmF0ZWQgdXNpbmcgX2NyZWF0ZUxpc3RlbmVyLlxuICAgKi9cbiAgX2FkZExpc3RlbmVyKG1lc3NhZ2UsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fZGlzcGF0Y2hlci5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgdGhpcy5fY3JlYXRlTG9jYWxNZXNzYWdlKG1lc3NhZ2UpLFxuICAgICAgbGlzdGVuZXJcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucmVnaXN0ZXIgYW4gZXZlbnQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gRXZlbnQgdHlwZSBuYW1lLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciAtIEEgbGlzdGVuZXIgZnVuY3Rpb24gZ2VuZXJhdGVkIHVzaW5nIF9jcmVhdGVMaXN0ZW5lci5cbiAgICovXG4gIF9yZW1vdmVMaXN0ZW5lcihtZXNzYWdlLCBsaXN0ZW5lcikge1xuICAgIHRoaXMuX2Rpc3BhdGNoZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgIHRoaXMuX2NyZWF0ZUxvY2FsTWVzc2FnZShtZXNzYWdlKSxcbiAgICAgIGxpc3RlbmVyXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGEgZnVuY3Rpb24gd2hlbiBhIG1lc3NhZ2UgaXMgcmVjZWl2ZWQgZm9yIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIFRoZSBtZXNzYWdlIHRvIGxpc3RlbiBmb3IuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBvbmNlIHRoZSBtZXNzYWdlIGlzIHJlY2VpdmVkLlxuICAgKi9cbiAgbGlzdGVuVG8obWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgYWRkIGxpc3RlbmVyIGZvciAke21lc3NhZ2V9IG9uICR7dGhpcy5pZH0uIENhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbi5gXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jYWxsYmFja3NbbWVzc2FnZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fY2FsbGJhY2tzW21lc3NhZ2VdID0gW107XG4gICAgICB0aGlzLl9ldmVudExpc3RlbmVyc1ttZXNzYWdlXSA9IFtdO1xuICAgIH1cblxuICAgIGNvbnN0IGxpc3RlbmVyID0gdGhpcy5fY3JlYXRlTGlzdGVuZXIoY2FsbGJhY2spO1xuICAgIHRoaXMuX2NhbGxiYWNrc1ttZXNzYWdlXS5wdXNoKGNhbGxiYWNrKTtcbiAgICB0aGlzLl9ldmVudExpc3RlbmVyc1ttZXNzYWdlXS5wdXNoKGxpc3RlbmVyKTtcblxuICAgIHRoaXMuX2FkZExpc3RlbmVyKG1lc3NhZ2UsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmV2ZW50IGEgZnVuY3Rpb24gZnJvbSBiZWluZyBleGVjdXRlZCB3aGVuIGEgbWVzc2FnZSBpcyByZWNlaXZlZCBmb3IgdGhpc1xuICAgKiBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gVGhlIG1lc3NhZ2UgdG8gc3RvcCBsaXN0ZW5pbmcgZm9yLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gY2FsbGJhY2sgLSBPcHRpb25hbCBjYWxsYmFjayB0byByZW1vdmUuIElmIG5vbmUgaXMgZGVmaW5lZCxcbiAgICogcmVtb3ZlIGFsbCBjYWxsYmFja3MgZm9yIHRoZSBtZXNzYWdlLlxuICAgKi9cbiAgc3RvcExpc3RlbmluZyhtZXNzYWdlLCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLl9jYWxsYmFja3NbbWVzc2FnZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgd2FzIGRlZmluZWQsIGNhbGwgc3RvcExpc3RlbmluZyBvbiBhbGwgY2FsbGJhY2tzIGZvciB0aGUgbWVzc2FnZVxuICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX2NhbGxiYWNrc1ttZXNzYWdlXS5sZW5ndGggLSAxOyBpID4gLTE7IGktLSkge1xuICAgICAgICB0aGlzLnN0b3BMaXN0ZW5pbmcobWVzc2FnZSwgdGhpcy5fY2FsbGJhY2tzW21lc3NhZ2VdW2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIGEgY2FsbGJhY2sgd2FzIGRlZmluZWQsIG1ha2Ugc3VyZSBpdCdzIGEgbGlzdGVuZXJcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX2NhbGxiYWNrc1ttZXNzYWdlXS5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbGlzdGVuZXIgPSB0aGlzLl9ldmVudExpc3RlbmVyc1ttZXNzYWdlXVtpbmRleF07XG4gICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXIobWVzc2FnZSwgbGlzdGVuZXIpO1xuXG4gICAgdGhpcy5fY2FsbGJhY2tzW21lc3NhZ2VdLnNwbGljZShpbmRleCwgMSk7XG4gICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnNbbWVzc2FnZV0uc3BsaWNlKGluZGV4LCAxKTtcblxuICAgIGlmICh0aGlzLl9jYWxsYmFja3NbbWVzc2FnZV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzW21lc3NhZ2VdO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50TGlzdGVuZXJzW21lc3NhZ2VdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZS1yZWdpc3RlciBjYWxsYmFjayhzKSBmcm9tIGJlaW5nIGV4ZWN1dGVkIHdoZW4gbWVzc2FnZXMgbWF0Y2hpbmcgdGhlIGdpdmVuXG4gICAqIHJlZ3VsYXIgZXhwcmVzc2lvbiBhcmUgcmVjZWl2ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVnZXhwfSByZWdleHAgLSByZWdleHAgLSBUaGUgcmVndWxhciBleHByZXNzaW9uIHRvIGZpbHRlciBtZXNzYWdlcyB3aXRoLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gY2FsbGJhY2sgLSBPcHRpb25hbCBjYWxsYmFjayB0byByZW1vdmUuIElmIG5vbmUgaXMgZGVmaW5lZCxcbiAgICogcmVtb3ZlIGFsbCBjYWxsYmFja3MgZm9yIG1lc3NhZ2VzIG1hdGNoaW5nIHRoZSByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAqL1xuICBzdG9wTGlzdGVuaW5nQnlSZWdleHAocmVnZXhwLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gT2JqZWN0LmtleXModGhpcy5fY2FsbGJhY2tzKS5maWx0ZXIobWVzc2FnZSA9PlxuICAgICAgcmVnZXhwLnRlc3QobWVzc2FnZSlcbiAgICApO1xuXG4gICAgbWVzc2FnZXMuZm9yRWFjaChtZXNzYWdlID0+IHtcbiAgICAgIHRoaXMuc3RvcExpc3RlbmluZyhtZXNzYWdlLCBjYWxsYmFjayk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUHJldmVudCBhbnkgZnVuY3Rpb25zIGZyb20gYmVpbmcgZXhlY3V0ZWQgd2hlbiBhbnkgbWVzc2FnZSBpcyByZWNlaXZlZCBmb3JcbiAgICogdGhpcyBvYmplY3QuXG4gICAqL1xuICBzdG9wTGlzdGVuaW5nVG9BbGwoKSB7XG4gICAgY29uc3QgbWVzc2FnZXMgPSBPYmplY3Qua2V5cyh0aGlzLl9jYWxsYmFja3MpO1xuXG4gICAgZm9yIChsZXQgaSA9IG1lc3NhZ2VzLmxlbmd0aCAtIDE7IGkgPiAtMTsgaS0tKSB7XG4gICAgICB0aGlzLnN0b3BMaXN0ZW5pbmcobWVzc2FnZXNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgbWVzc2FnZSwgY2F1c2luZyBsaXN0ZW5lciBmdW5jdGlvbnMgZm9yIHRoZSBtZXNzYWdlIG9uIHRoaXMgb2JqZWN0XG4gICAqIHRvIGJlIGV4ZWN1dGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIFRoZSBtZXNzYWdlIHRvIGVtaXQuXG4gICAqIEBwYXJhbSB7YW55PX0gdmFsdWUgLSBPcHRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGxpc3RlbmVyIGNhbGxiYWNrcy5cbiAgICovXG4gIGVtaXQobWVzc2FnZSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy5fY2FsbGJhY2tzW21lc3NhZ2VdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBtZXNzYWdlID0gdGhpcy5fY3JlYXRlTG9jYWxNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5fY3JlYXRlRXZlbnQobWVzc2FnZSwgdmFsdWUpO1xuICAgIHRoaXMuX2Rpc3BhdGNoZXIuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSBhIGZ1bmN0aW9uIHdoZW4gYSBtZXNzYWdlIGlzIHJlY2VpdmVkIGZvciB0aGUgZ2xvYmFsIE1lc3NlbmdlciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIFRoZSBtZXNzYWdlIHRvIGxpc3RlbiBmb3IuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBvbmNlIHRoZSBtZXNzYWdlIGlzIHJlY2VpdmVkLlxuICAgKi9cbiAgc3RhdGljIGxpc3RlblRvKG1lc3NhZ2UsIGNhbGxiYWNrLCBtZXNzZW5nZXIpIHtcbiAgICB0aGlzLkdsb2JhbE1lc3Nlbmdlci5saXN0ZW5UbyhtZXNzYWdlLCBjYWxsYmFjaywgbWVzc2VuZ2VyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmV2ZW50IGEgZnVuY3Rpb24gZnJvbSBiZWluZyBleGVjdXRlZCB3aGVuIGEgbWVzc2FnZSBpcyByZWNlaXZlZCBmb3IgdGhlXG4gICAqIGdsb2JhbCBNZXNzZW5nZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0byBzdG9wIGxpc3RlbmluZyBmb3IuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBjYWxsYmFjayAtIE9wdGlvbmFsIGNhbGxiYWNrIHRvIHJlbW92ZS4gSWYgbm9uZSBpcyBkZWZpbmVkLFxuICAgKiByZW1vdmUgYWxsIGNhbGxiYWNrcyBmb3IgdGhlIG1lc3NhZ2UuXG4gICAqL1xuICBzdGF0aWMgc3RvcExpc3RlbmluZyhtZXNzYWdlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuR2xvYmFsTWVzc2VuZ2VyLnN0b3BMaXN0ZW5pbmcobWVzc2FnZSwgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIERlLXJlZ2lzdGVyIGNhbGxiYWNrKHMpIGZyb20gYmVpbmcgZXhlY3V0ZWQgb24gdGhlIGdsb2JhbCBtZXNzZW5nZXJyIGluc3RhbmNlXG4gICAqIHdoZW4gbWVzc2FnZXMgbWF0Y2hpbmcgdGhlIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbiBhcmUgcmVjZWl2ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVnZXhwfSByZWdleHAgLSByZWdleHAgLSBUaGUgcmVndWxhciBleHByZXNzaW9uIHRvIGZpbHRlciBtZXNzYWdlcyB3aXRoLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gY2FsbGJhY2sgLSBPcHRpb25hbCBjYWxsYmFjayB0byByZW1vdmUuIElmIG5vbmUgaXMgZGVmaW5lZCxcbiAgICogcmVtb3ZlIGFsbCBjYWxsYmFja3MgZm9yIG1lc3NhZ2VzIG1hdGNoaW5nIHRoZSByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAqL1xuICBzdGF0aWMgc3RvcExpc3RlbmluZ0J5UmVnZXhwKHJlZ2V4cCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBtZXNzYWdlcyA9IE9iamVjdC5rZXlzKFxuICAgICAgdGhpcy5HbG9iYWxNZXNzZW5nZXIuX2NhbGxiYWNrc1xuICAgICkuZmlsdGVyKG1lc3NhZ2UgPT4gcmVnZXhwLnRlc3QobWVzc2FnZSkpO1xuXG4gICAgbWVzc2FnZXMuZm9yRWFjaChtZXNzYWdlID0+IHtcbiAgICAgIHRoaXMuc3RvcExpc3RlbmluZyhtZXNzYWdlLCBjYWxsYmFjayk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUHJldmVudCBhbnkgZnVuY3Rpb25zIGZyb20gYmVpbmcgZXhlY3V0ZWQgd2hlbiBhbnkgbWVzc2FnZSBpcyByZWNlaXZlZCBmb3JcbiAgICogdGhlIGdsb2JhbCBNZXNzZW5nZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIHN0YXRpYyBzdG9wTGlzdGVuaW5nVG9BbGwoKSB7XG4gICAgdGhpcy5HbG9iYWxNZXNzZW5nZXIuc3RvcExpc3RlbmluZ1RvQWxsKCk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIG1lc3NhZ2UsIGNhdXNpbmcgbGlzdGVuZXIgZnVuY3Rpb25zIGZvciB0aGUgbWVzc2FnZSBvbiB0aGUgZ2xvYmFsIE1lc3NlbmdlclxuICAgKiBpbnN0YW5jZSB0byBiZSBleGVjdXRlZC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIFRoZSBtZXNzYWdlIHRvIGVtaXQuXG4gICAqIEBwYXJhbSB7YW55PX0gdmFsdWUgLSBPcHRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGxpc3RlbmVyIGNhbGxiYWNrcy5cbiAgICovXG4gIHN0YXRpYyBlbWl0KG1lc3NhZ2UsIHZhbHVlKSB7XG4gICAgdGhpcy5HbG9iYWxNZXNzZW5nZXIuZW1pdChtZXNzYWdlLCB2YWx1ZSk7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTWVzc2VuZ2VyLCB7XG4gIEdsb2JhbE1lc3Nlbmdlcjoge1xuICAgIHZhbHVlOiBuZXcgTWVzc2VuZ2VyKCksXG4gICAgd3JpdGFibGU6IGZhbHNlLFxuICB9LFxuICBFVkVOVFM6IHtcbiAgICB2YWx1ZToge30sXG4gICAgd3JpdGFibGU6IGZhbHNlLFxuICB9LFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IE1lc3NlbmdlcjtcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXG5pbXBvcnQgTWVzc2VuZ2VyIGZyb20gJ2NvcmUvTWVzc2VuZ2VyJztcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBhbGwgaG9zdCBmZWF0dXJlcy4gS2VlcHMgYSByZWZlcmVuY2UgdG8gdGhlIGhvc3Qgb2JqZWN0IG1hbmFnaW5nXG4gKiB0aGUgZmVhdHVyZS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqXG4gKiBAcHJvcGVydHkge09iamVjdH0gRVZFTlRTIC0gQnVpbHQtaW4gbWVzc2FnZXMgdGhhdCB0aGUgZmVhdHVyZSBlbWl0cy4gV2hlbiB0aGVcbiAqIGZlYXR1cmUgaXMgYWRkZWQgdG8gYSB7QGxpbmsgY29yZS9Ib3N0T2JqZWN0fSwgZXZlbnQgbmFtZXMgd2lsbCBiZSBwcmVmaXhlZCBieSB0aGVcbiAqIG5hbWUgb2YgdGhlIGZlYXR1cmUgY2xhc3MgKyAnLicuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UUy51cGRhdGU9b25VcGRhdGVdIC0gTWVzc2FnZSB0aGF0IGlzIGVtaXR0ZWQgYWZ0ZXJcbiAqIGVhY2ggY2FsbCB0byBbdXBkYXRlXXtAbGluayBBYnN0cmFjdEhvc3RGZWF0dXJlI3VwZGF0ZX0uXG4gKiBAcHJvcGVydHkge09iamVjdH0gU0VSVklDRVMgLSBBbnkgQVdTIHNlcnZpY2VzIHRoYXQgYXJlIG5lY2Vzc2FyeSBmb3IgdGhlXG4gKiBmZWF0dXJlIHRvIGZ1bmN0aW9uLlxuICovXG5jbGFzcyBBYnN0cmFjdEhvc3RGZWF0dXJlIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0ge2NvcmUvSG9zdE9iamVjdH0gaG9zdCAtIFRoZSBIb3N0T2JqZWN0IG1hbmFnaW5nIHRoZSBmZWF0dXJlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoaG9zdCkge1xuICAgIHRoaXMuX2hvc3QgPSBob3N0O1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBuYW1lc3BhY2UgdG8gdGhlIGhvc3Qgd2l0aCB0aGUgbmFtZSBvZiB0aGUgZmVhdHVyZSB0byBjb250YWluIHByb3BlcnRpZXNcbiAgICogYW5kIG1ldGhvZHMgZnJvbSB0aGUgZmVhdHVyZSB0aGF0IHVzZXJzIG9mIHRoZSBob3N0IG5lZWQgYWNjZXNzIHRvLlxuICAgKi9cbiAgaW5zdGFsbEFwaSgpIHtcbiAgICBjb25zdCBldmVudHMgPSB7fTtcbiAgICBjb25zdCBhcGkgPSB7RVZFTlRTOiBldmVudHN9O1xuXG4gICAgLy8gQWRkIHRoZSBjbGFzcyBuYW1lIHRvIGV2ZW50IG5hbWVzXG4gICAgT2JqZWN0LmVudHJpZXModGhpcy5jb25zdHJ1Y3Rvci5FVkVOVFMpLmZvckVhY2goKFtuYW1lLCB2YWx1ZV0pID0+IHtcbiAgICAgIGV2ZW50c1tuYW1lXSA9IGAke3RoaXMuY29uc3RydWN0b3IubmFtZX0uJHt2YWx1ZX1gO1xuICAgIH0pO1xuXG4gICAgdGhpcy5faG9zdFt0aGlzLmNvbnN0cnVjdG9yLm5hbWVdID0gYXBpO1xuXG4gICAgcmV0dXJuIGFwaTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBob3N0IHRoYXQgbWFuYWdlcyB0aGUgZmVhdHVyZS5cbiAgICpcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgaG9zdCgpIHtcbiAgICByZXR1cm4gdGhpcy5faG9zdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBlbmdpbmUgb3duZXIgb2JqZWN0IG9mIHRoZSBob3N0LlxuICAgKlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBvd25lcigpIHtcbiAgICByZXR1cm4gdGhpcy5faG9zdC5vd25lcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gYSBmZWF0dXJlIG1lc3NhZ2UgZnJvbSB0aGUgaG9zdCBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gTWVzc2FnZSB0byBsaXN0ZW4gZm9yLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gdGhlIG1lc3NhZ2UgaXMgcmVjZWl2ZWQuXG4gICAqL1xuICBsaXN0ZW5UbyhtZXNzYWdlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX2hvc3QubGlzdGVuVG8obWVzc2FnZSwgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3RlbiB0byBhIGZlYXR1cmUgbWVzc2FnZSBmcm9tIHRoZSBnbG9iYWwgbWVzc2VuZ2VyLiBGZWF0dXJlIG1lc3NhZ2VzIHdpbGxcbiAgICogYmUgcHJlZml4ZWQgd2l0aCB0aGUgY2xhc3MgbmFtZSBvZiB0aGUgZmVhdHVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBNZXNzYWdlIHRvIGxpc3RlbiBmb3IuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiB0aGUgbWVzc2FnZSBpcyByZWNlaXZlZC5cbiAgICovXG4gIHN0YXRpYyBsaXN0ZW5UbyhtZXNzYWdlLCBjYWxsYmFjaykge1xuICAgIG1lc3NhZ2UgPSBgJHt0aGlzLm5hbWV9LiR7bWVzc2FnZX1gO1xuICAgIE1lc3Nlbmdlci5saXN0ZW5UbyhtZXNzYWdlLCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCBsaXN0ZW5pbmcgdG8gYSBtZXNzYWdlIGZyb20gdGhlIGhvc3Qgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIE1lc3NhZ2UgdG8gc3RvcCBsaXN0ZW5pbmcgZm9yLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gY2FsbGJhY2sgLSBPcHRpb25hbCBjYWxsYmFjayB0byByZW1vdmUuIElmIG5vbmUgaXMgZGVmaW5lZCxcbiAgICogcmVtb3ZlIGFsbCBjYWxsYmFja3MgZm9yIHRoZSBtZXNzYWdlLlxuICAgKi9cbiAgc3RvcExpc3RlbmluZyhtZXNzYWdlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX2hvc3Quc3RvcExpc3RlbmluZyhtZXNzYWdlLCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCBsaXN0ZW5pbmcgdG8gYSBtZXNzYWdlIGZyb20gdGhlIGdsb2JhbCBtZXNzZW5nZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gTWVzc2FnZSB0byBzdG9wIGxpc3RlbmluZyBmb3IuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBjYWxsYmFjayAtIE9wdGlvbmFsIGNhbGxiYWNrIHRvIHJlbW92ZS4gSWYgbm9uZSBpcyBkZWZpbmVkLFxuICAgKiByZW1vdmUgYWxsIGNhbGxiYWNrcyBmb3IgdGhlIG1lc3NhZ2UuXG4gICAqL1xuICBzdGF0aWMgc3RvcExpc3RlbmluZyhtZXNzYWdlLCBjYWxsYmFjaykge1xuICAgIG1lc3NhZ2UgPSBgJHt0aGlzLm5hbWV9LiR7bWVzc2FnZX1gO1xuICAgIE1lc3Nlbmdlci5zdG9wTGlzdGVuaW5nKG1lc3NhZ2UsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIGxpc3RlbmluZyB0byBhIG1lc3NhZ2UgbWF0Y2hpbmcgdGhlIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbiBmcm9tIHRoZVxuICAgKiBob3N0IG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWdleHB9IHJlZ2V4cCAtIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gdG8gc3RvcCBsaXN0ZW5pbmcgZm9yLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gY2FsbGJhY2sgLSBPcHRpb25hbCBjYWxsYmFjayB0byByZW1vdmUuIElmIG5vbmUgaXMgZGVmaW5lZCxcbiAgICogcmVtb3ZlIGFsbCBjYWxsYmFja3MgZm9yIHRoZSBtZXNzYWdlLlxuICAgKi9cbiAgc3RvcExpc3RlbmluZ0J5UmVnZXhwKHJlZ2V4cCwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl9ob3N0LnN0b3BMaXN0ZW5pbmdCeVJlZ2V4cChyZWdleHAsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIGxpc3RlbmluZyB0byBhIG1lc3NhZ2UgbWF0Y2hpbmcgdGhlIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbiBmcm9tIHRoZVxuICAgKiBnbG9iYWwgbWVzc2VuZ2VyLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlZ2V4cH0gcmVnZXhwIC0gVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBzdG9wIGxpc3RlbmluZyBmb3IuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBjYWxsYmFjayAtIE9wdGlvbmFsIGNhbGxiYWNrIHRvIHJlbW92ZS4gSWYgbm9uZSBpcyBkZWZpbmVkLFxuICAgKiByZW1vdmUgYWxsIGNhbGxiYWNrcyBmb3IgdGhlIG1lc3NhZ2UuXG4gICAqL1xuICBzdGF0aWMgc3RvcExpc3RlbmluZ0J5UmVnZXhwKHJlZ2V4cCwgY2FsbGJhY2spIHtcbiAgICByZWdleHAgPSBuZXcgUmVnRXhwKGBeJHt0aGlzLm5hbWV9LiR7cmVnZXhwLnNvdXJjZS5yZXBsYWNlKC9cXF4vLCAnJyl9YCk7XG4gICAgTWVzc2VuZ2VyLnN0b3BMaXN0ZW5pbmdCeVJlZ2V4cChyZWdleHAsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIGxpc3RlbmluZyB0byBhbGwgbWVzc2FnZXMuXG4gICAqL1xuICBzdG9wTGlzdGVuaW5nVG9BbGwoKSB7XG4gICAgdGhpcy5faG9zdC5zdG9wTGlzdGVuaW5nVG9BbGwoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIGxpc3RlbmluZyB0byBhbGwgZmVhdHVyZSBtZXNzYWdlcy5cbiAgICovXG4gIHN0YXRpYyBzdG9wTGlzdGVuaW5nVG9BbGwoKSB7XG4gICAgTWVzc2VuZ2VyLnN0b3BMaXN0ZW5pbmdCeVJlZ2V4cChuZXcgUmVnRXhwKGBeJHt0aGlzLm5hbWV9LmApKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0IGZlYXR1cmUgbWVzc2FnZXMgZnJvbSB0aGUgaG9zdC4gRmVhdHVyZSBtZXNzYWdlcyB3aWxsIGJlIHByZWZpeGVkIHdpdGhcbiAgICogdGhlIGNsYXNzIG5hbWUgb2YgdGhlIGZlYXR1cmUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gVGhlIG1lc3NhZ2UgdG8gZW1pdC5cbiAgICogQHBhcmFtIHthbnk9fSB2YWx1ZSAtIE9wdGlvbmFsIHBhcmFtZXRlciB0byBwYXNzIHRvIGxpc3RlbmVyIGNhbGxiYWNrcy5cbiAgICovXG4gIGVtaXQobWVzc2FnZSwgdmFsdWUpIHtcbiAgICBtZXNzYWdlID0gYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfS4ke21lc3NhZ2V9YDtcbiAgICB0aGlzLl9ob3N0LmVtaXQobWVzc2FnZSwgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXQgZmVhdHVyZSBtZXNzYWdlcyBmcm9tIHRoZSBnbG9iYWwgbWVzc2VuZ2VyLiBGZWF0dXJlIG1lc3NhZ2VzIHdpbGwgYmUgcHJlZml4ZWRcbiAgICogd2l0aCB0aGUgY2xhc3MgbmFtZSBvZiB0aGUgZmVhdHVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0byBlbWl0LlxuICAgKiBAcGFyYW0ge2FueT19IHZhbHVlIC0gT3B0aW9uYWwgcGFyYW1ldGVyIHRvIHBhc3MgdG8gbGlzdGVuZXIgY2FsbGJhY2tzLlxuICAgKi9cbiAgc3RhdGljIGVtaXQobWVzc2FnZSwgdmFsdWUpIHtcbiAgICBtZXNzYWdlID0gYCR7dGhpcy5uYW1lfS4ke21lc3NhZ2V9YDtcbiAgICBNZXNzZW5nZXIuZW1pdChtZXNzYWdlLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgZWFjaCB0aW1lIHRoZSBob3N0IGlzIHVwZGF0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVRpbWUgLSBBbW91bnQgb2YgdGltZSBzaW5jZSB0aGUgbGFzdCBob3N0IHVwZGF0ZSB3YXNcbiAgICogY2FsbGVkLlxuICAgKi9cbiAgdXBkYXRlKGRlbHRhVGltZSkge1xuICAgIHRoaXMuZW1pdCh0aGlzLmNvbnN0cnVjdG9yLkVWRU5UUy51cGRhdGUsIGRlbHRhVGltZSk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW4gdXAgb25jZSB0aGUgZmVhdHVyZSBpcyBubyBsb25nZXIgaW4gdXNlLiBSZW1vdmUgdGhlIGZlYXR1cmUgbmFtZXNwYWNlXG4gICAqIGZyb20gdGhlIGhvc3QgYW5kIHJlbW92ZSByZWZlcmVuY2UgdG8gdGhlIGhvc3QuXG4gICAqL1xuICBkaXNjYXJkKCkge1xuICAgIE9iamVjdC5rZXlzKHRoaXMuX2hvc3RbdGhpcy5jb25zdHJ1Y3Rvci5uYW1lXSkuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ob3N0W3RoaXMuY29uc3RydWN0b3IubmFtZV1bbmFtZV07XG4gICAgfSk7XG5cbiAgICBkZWxldGUgdGhpcy5faG9zdFt0aGlzLmNvbnN0cnVjdG9yLm5hbWVdO1xuICAgIGRlbGV0ZSB0aGlzLl9ob3N0O1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgYSBzZXF1ZW5jZSBvZiBtaXhpbiBjbGFzcyBmYWN0b3J5IGZ1bmN0aW9ucyB0byB0aGlzIGNsYXNzIGFuZFxuICAgKiByZXR1cm5zIHRoZSByZXN1bHQuIEVhY2ggZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gcmV0dXJuIGEgY2xhc3MgdGhhdFxuICAgKiBleHRlbmRzIHRoZSBjbGFzcyBpdCB3YXMgZ2l2ZW4uIFRoZSBmdW5jdGlvbnMgYXJlIGFwcGxpZWQgaW4gdGhlIG9yZGVyXG4gICAqIHRoYXQgcGFyYW1ldGVycyBhcmUgZ2l2ZW4sIG1lYW5pbmcgdGhhdCB0aGUgZmlyc3QgZmFjdG9yeSB3aWxsXG4gICAqIGV4dGVuZCB0aGlzIGJhc2UgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IG1peGluQ2xhc3NGYWN0b3JpZXMgQ2xhc3MgZmFjdG9yeSBmdW5jdGlvbnMgdGhhdCB3aWxsXG4gICAqIGJlIGFwcGxpZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtDbGFzc30gQSBjbGFzcyB0aGF0IGlzIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIGZhY3RvcnkgZnVuY3Rpb25zLlxuICAgKiBUaGUgcmVzdWx0aW5nIGNsYXNzIHdpbGwgYWx3YXlzIGluaGVyaXQgZnJvbSBBYnN0cmFjdEhvc3RGZWF0dXJlLlxuICAgKi9cbiAgc3RhdGljIG1peCguLi5taXhpbkNsYXNzRmFjdG9yaWVzKSB7XG4gICAgbGV0IFJlc3VsdENsYXNzID0gdGhpcztcblxuICAgIG1peGluQ2xhc3NGYWN0b3JpZXMuZm9yRWFjaChtaXhpbkNsYXNzRmFjdG9yeSA9PiB7XG4gICAgICBSZXN1bHRDbGFzcyA9IG1peGluQ2xhc3NGYWN0b3J5KFJlc3VsdENsYXNzKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBSZXN1bHRDbGFzcztcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhBYnN0cmFjdEhvc3RGZWF0dXJlLCB7XG4gIEVWRU5UUzoge1xuICAgIHZhbHVlOiB7XG4gICAgICB1cGRhdGU6ICdvblVwZGF0ZScsXG4gICAgfSxcbiAgICB3cml0YWJsZTogZmFsc2UsXG4gIH0sXG4gIFNFUlZJQ0VTOiB7XG4gICAgdmFsdWU6IHt9LFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgfSxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBBYnN0cmFjdEhvc3RGZWF0dXJlO1xuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcbmltcG9ydCBNZXNzZW5nZXIgZnJvbSAnY29yZS9NZXNzZW5nZXInO1xuaW1wb3J0IEFic3RyYWN0SG9zdEZlYXR1cmUgZnJvbSAnLi9BYnN0cmFjdEhvc3RGZWF0dXJlJztcbmltcG9ydCBVdGlscyBmcm9tICcuL1V0aWxzJztcblxuLyoqXG4gKiBPYmplY3QgdGhhdCBtYW5hZ2VzIGFjY2VzcyB0byBhbGwgSG9zdCBmZWF0dXJlcy4gQ29udGFpbnMgYSByZWZlcmVuY2UgdG9cbiAqIGVuZ2luZS1zcGVjaWZpYyB2aXN1YWxzIGlmIGFwcGxpY2FibGUuXG4gKlxuICogQGV4dGVuZHMgY29yZS9NZXNzZW5nZXJcbiAqIEBhbGlhcyBjb3JlL0hvc3RPYmplY3RcbiAqXG4gKiBAcHJvcGVydHkge09iamVjdH0gRVZFTlRTIC0gQnVpbHQtaW4gbWVzc2FnZXMgdGhhdCB0aGUgTWVzc2VuZ2VyIGVtaXRzLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVFMudXBkYXRlPSdvblVwZGF0ZSddIC0gTWVzc2FnZSB0aGF0IGlzIGVtaXR0ZWQgYWZ0ZXJcbiAqIGVhY2ggY2FsbCB0byBbdXBkYXRlXXtAbGluayBjb3JlL0hvc3RPYmplY3QjdXBkYXRlfS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLmFkZEZlYXR1cmU9J29uQWRkRmVhdHVyZSddIC0gTWVzc2FnZSB0aGF0IGlzIGVtaXR0ZWRcbiAqIGFmdGVyIGVhY2ggY2FsbCB0byBbYWRkRmVhdHVyZV17QGxpbmsgY29yZS9Ib3N0T2JqZWN0I2FkZEZlYXR1cmV9LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVFMucmVtb3ZlRmVhdHVyZT0nb25SZW1vdmVGZWF0dXJlJ10gLSBNZXNzYWdlIHRoYXQgaXMgZW1pdHRlZFxuICogYWZ0ZXIgZWFjaCBjYWxsIHRvIFtyZW1vdmVGZWF0dXJlXXtAbGluayBjb3JlL0hvc3RPYmplY3QjcmVtb3ZlRmVhdHVyZX0uXG4gKi9cbmNsYXNzIEhvc3RPYmplY3QgZXh0ZW5kcyBNZXNzZW5nZXIge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBob3N0LlxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMub3duZXIgLSBPcHRpb25hbCBlbmdpbmUtc3BlY2lmaWMgb3duZXIgb2YgdGhlIGhvc3QuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7b3duZXIgPSB7fX0gPSB7fSkge1xuICAgIC8vIElmIGFuIG93bmVyIGlzIHNwZWNpZmllZCwgdXNlIGl0cyBpZCBmb3IgbWVzc2FnaW5nXG4gICAgc3VwZXIob3duZXIuaWQpO1xuXG4gICAgdGhpcy5fb3duZXIgPSBvd25lcjtcbiAgICB0aGlzLl9mZWF0dXJlcyA9IHt9O1xuICAgIHRoaXMuX3dhaXRzID0gW107XG4gICAgdGhpcy5fbGFzdFVwZGF0ZSA9IHRoaXMubm93O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGVuZ2luZSBvd25lciBvYmplY3Qgb2YgdGhlIGhvc3QuXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0IG93bmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9vd25lcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHRpbWUgaW4gbWlsbGlzZWNvbmRzLlxuICAgKlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBub3coKSB7XG4gICAgcmV0dXJuIERhdGUubm93KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgYW1vdW50IG9mIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHNpbmNlIHVwZGF0ZSB3YXMgbGFzdCBjYWxsZWQuXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRlbHRhVGltZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ub3cgLSB0aGlzLl9sYXN0VXBkYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCBpbiB0aGUgZW5naW5lJ3MgcmVuZGVyIGxvb3AuIEV4ZWN1dGVzIHVwZGF0ZVxuICAgKiBsb29wcyBmb3IgYWxsIGZlYXR1cmVzLlxuICAgKi9cbiAgdXBkYXRlKCkge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gdGhpcy5ub3c7XG4gICAgY29uc3QgZHQgPSB0aGlzLmRlbHRhVGltZTtcblxuICAgIC8vIFByb2dyZXNzIHN0b3JlZCB3YWl0c1xuICAgIHRoaXMuX3dhaXRzLmZvckVhY2god2FpdCA9PiB7XG4gICAgICB3YWl0LmV4ZWN1dGUoZHQpO1xuICAgIH0pO1xuXG4gICAgLy8gVXBkYXRlIGFsbCBmZWF0dXJlc1xuICAgIE9iamVjdC52YWx1ZXModGhpcy5fZmVhdHVyZXMpLmZvckVhY2goZmVhdHVyZSA9PiB7XG4gICAgICBmZWF0dXJlLnVwZGF0ZShkdCk7XG4gICAgfSk7XG5cbiAgICAvLyBOb3RpZnkgbGlzdGVuZXJzIGFuIHVwZGF0ZSBvY2N1cmVkXG4gICAgdGhpcy5lbWl0KHRoaXMuY29uc3RydWN0b3IuRVZFTlRTLnVwZGF0ZSwgZHQpO1xuXG4gICAgdGhpcy5fbGFzdFVwZGF0ZSA9IGN1cnJlbnRUaW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGRlZmVycmVkIHByb21pc2UgdGhhdCB3aWxsIHdhaXQgYSBnaXZlbiBudW1iZXIgb2Ygc2Vjb25kcyBiZWZvcmVcbiAgICogcmVzb2x2aW5nLiBUaGUgaG9zdCB3aWxsIGNvbnRpbnVvdXNseSB1cGRhdGUgdGhlIHdhaXQgcHJvbWlzZSBkdXJpbmcgdGhlXG4gICAqIHVwZGF0ZSBsb29wIHVudGlsIGl0IHJlc29sdmVzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NlY29uZHM9MF0gLSBOdW1iZXIgb2Ygc2Vjb25kcyB0byB3YWl0IGJlZm9yZSByZXNvbHZpbmcuXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyAtIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uRmluaXNoXSAtIENhbGxiYWNrIHRvIGV4ZWN1dGUgb25jZSB0aGUgd2FpdCB0aW1lXG4gICAqIGlzIG1ldC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9wdGlvbnMub25Qcm9ncmVzcyAtIENhbGxiYWNrIHRvIGV4ZWN1dGUgZWFjaCB0aW1lIHRoZSB3YWl0XG4gICAqIHRpbWUgcHJvZ3Jlc3NlcyB0b3dhcmRzIHRoZSB0YXJnZXQgbnVtYmVyIG9mIHNlY29uZHMuIFRoZSBhbW91bnQgb2YgcHJvZ3Jlc3NcbiAgICogYXMgYSAwLTEgcGVyY2VudGFnZSBpcyBwYXNzZWQgYXMgYW4gYXJndW1lbnQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvcHRpb25zLm9uQ2FuY2VsIC0gQ2FsbGJhY2sgdG8gZXhlY3V0ZSBpZiB0aGUgdXNlciBjYW5jZWxzXG4gICAqIHRoZSB3YWl0IGJlZm9yZSBjb21wbGV0aW9uLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb3B0aW9ucy5vbkVycm9yIC0gQ2FsbGJhY2sgdG8gZXhlY3V0ZSBpZiB0aGUgd2FpdCBzdG9wc1xuICAgKiBiZWNhdXNlIGFuIGVycm9yIGlzIGVuY291bnRlcmVkLiBUaGUgZXJyb3IgbWVzc2FnZSBpcyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH1cbiAgICovXG4gIHdhaXQoc2Vjb25kcywge29uRmluaXNoLCBvblByb2dyZXNzLCBvbkNhbmNlbCwgb25FcnJvcn0gPSB7fSkge1xuICAgIGNvbnN0IHdhaXQgPSBVdGlscy53YWl0KHNlY29uZHMsIHtvbkZpbmlzaCwgb25Qcm9ncmVzcywgb25DYW5jZWwsIG9uRXJyb3J9KTtcbiAgICB0aGlzLl93YWl0cy5wdXNoKHdhaXQpO1xuXG4gICAgLy8gT25jZSB0aGUgd2FpdCBwcm9taXNlIGlzIG5vIGxvbmdlciBwZW5kaW5nIHJlbW92ZSBpdCBmcm9tIHRoZSB3YWl0cyBhcnJheVxuICAgIGNvbnN0IG9uQ29tcGxldGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLl93YWl0cy5zcGxpY2UodGhpcy5fd2FpdHMuaW5kZXhPZih3YWl0KSwgMSk7XG4gICAgfTtcbiAgICB3YWl0LnRoZW4ob25Db21wbGV0ZSwgb25Db21wbGV0ZSk7XG5cbiAgICByZXR1cm4gd2FpdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZSBhIG5ldyBIb3N0IGZlYXR1cmUgYW5kIHN0b3JlIGl0LiBGZWF0dXJlcyBtdXN0IGluaGVyaXQgZnJvbVxuICAgKiBBYnN0cmFjdEhvc3RGZWF0dXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge0NsYXNzfSBGZWF0dXJlQ2xhc3MgLSBDbGFzcyB0aGF0IHdpbGwgaW5zdGFudGlhdGUgdGhlIGZlYXR1cmUuIE11c3RcbiAgICogZXh0ZW5kIHtAbGluayBBYnN0cmFjdEhvc3RGZWF0dXJlfS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbZm9yY2U9ZmFsc2VdIC0gV2hldGhlciBvciBub3QgdG8gb3ZlcndyaXRlIGFuIGV4aXN0aW5nXG4gICAqIGZlYXR1cmUgaWYgb25lIG9mIHRoaXMgdHlwZSBhbHJlYWR5IGV4aXN0cyBvbiB0aGUgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3MgLSBBZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBGZWF0dXJlQ2xhc3NcbiAgICogY29uc3RydWN0b3IuIFRoZSBIb3N0T2JqZWN0IHdpbGwgYWx3YXlzIGJlIHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAtIFdoZXRoZXIgb3Igbm90IGEgZmVhdHVyZSB3YXMgc3VjY2Vzc2Z1bGx5IGFkZGVkLlxuICAgKi9cbiAgYWRkRmVhdHVyZShGZWF0dXJlQ2xhc3MsIGZvcmNlID0gZmFsc2UsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBpbnB1dFR5cGUgPSB0eXBlb2YgRmVhdHVyZUNsYXNzO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBGZWF0dXJlQ2xhc3MgY2FuIGJlIGV4ZWN1dGVkXG4gICAgaWYgKGlucHV0VHlwZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGFkZCBmZWF0dXJlIHRvIGhvc3QgJHt0aGlzLmlkfS4gRmVhdHVyZUNsYXNzIG11c3QgYmUgYSBjbGFzcy5gXG4gICAgICApO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgdGhlIGZlYXR1cmUgaXMgYSBob3N0IGZlYXR1cmVcbiAgICBlbHNlIGlmICghKEZlYXR1cmVDbGFzcy5wcm90b3R5cGUgaW5zdGFuY2VvZiBBYnN0cmFjdEhvc3RGZWF0dXJlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGFkZCBmZWF0dXJlICR7RmVhdHVyZUNsYXNzLm5hbWV9IHRvIGhvc3QgJHt0aGlzLmlkfS4gRmVhdHVyZUNsYXNzIG11c3QgZXh0ZW5kIEFic3RyYWN0SG9zdEZlYXR1cmUuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgRmVhdHVyZUNsYXNzIGFscmVhZHkgZXhpc3RzIG9uIHRoaXMgb2JqZWN0XG4gICAgaWYgKHRoaXMuX2ZlYXR1cmVzW0ZlYXR1cmVDbGFzcy5uYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZm9yY2UpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBGZWF0dXJlICR7RmVhdHVyZUNsYXNzLm5hbWV9IGFscmVhZHkgZXhpc3RzIG9uIGhvc3QgJHt0aGlzLmlkfS4gRXhpc3RpbmcgZmVhdHVyZSB3aWxsIGJlIG92ZXJ3cml0dGVuLmBcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRmVhdHVyZSAke0ZlYXR1cmVDbGFzcy5uYW1lfSBhbHJlYWR5IGV4aXN0cyBvbiBob3N0ICR7dGhpcy5pZH0uIFVzZSAnZm9yY2UnIGFyZ3VtZW50IHRvIG92ZXJ3cml0ZSB0aGUgZmVhdHVyZS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgZmVhdHVyZVxuICAgIGNvbnN0IGZlYXR1cmUgPSBuZXcgRmVhdHVyZUNsYXNzKHRoaXMsIC4uLmFyZ3MpO1xuICAgIGZlYXR1cmUuaW5zdGFsbEFwaSgpO1xuXG4gICAgdGhpcy5fZmVhdHVyZXNbRmVhdHVyZUNsYXNzLm5hbWVdID0gZmVhdHVyZTtcbiAgICB0aGlzLmVtaXQodGhpcy5jb25zdHJ1Y3Rvci5FVkVOVFMuYWRkRmVhdHVyZSwgRmVhdHVyZUNsYXNzLm5hbWUpO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgZmVhdHVyZSBmcm9tIHRoZSBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlTmFtZSAtIE5hbWUgb2YgdGhlIHR5cGUgb2YgZmVhdHVyZSB0byByZW1vdmUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAtIFdoZXRoZXIgb3Igbm90IGEgZmVhdHVyZSB3YXMgc3VjY2Vzc2Z1bGx5IHJlbW92ZWQuXG4gICAqL1xuICByZW1vdmVGZWF0dXJlKHR5cGVOYW1lKSB7XG4gICAgaWYgKHRoaXMuX2ZlYXR1cmVzW3R5cGVOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBGZWF0dXJlIG9mIHR5cGUgJHt0eXBlTmFtZX0gZG9lcyBub3QgZXhpc3Qgb24gaG9zdCAke3RoaXMuaWR9LiBObyBmZWF0dXJlIHdpbGwgYmUgcmVtb3ZlZC5gXG4gICAgICApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZW1vdmUgdGhlIGZlYXR1cmVcbiAgICAgIHRoaXMuZW1pdCh0aGlzLmNvbnN0cnVjdG9yLkVWRU5UUy5yZW1vdmVGZWF0dXJlLCB0eXBlTmFtZSk7XG4gICAgICB0aGlzLl9mZWF0dXJlc1t0eXBlTmFtZV0uZGlzY2FyZCgpO1xuICAgICAgZGVsZXRlIHRoaXMuX2ZlYXR1cmVzW3R5cGVOYW1lXTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlIHdoZXRoZXIgYSBzcGVjaWZpZWQgZmVhdHVyZSBpcyBpbnN0YWxsZWQgb24gdGhlIGhvc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlTmFtZSAtIE5hbWUgb2YgdGhlIHR5cGUgb2YgZmVhdHVyZSB0byBsb29rIGZvci5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBoYXNGZWF0dXJlKHR5cGVOYW1lKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZmVhdHVyZXNbdHlwZU5hbWVdO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3QgdGhlIG5hbWVzIG9mIHRoZSBmZWF0dXJlcyBpbnN0YWxsZWQgb24gdGhlIGhvc3QuXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheS48c3RyaW5nPn1cbiAgICovXG4gIGxpc3RGZWF0dXJlcygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fZmVhdHVyZXMpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShIb3N0T2JqZWN0LCAnRVZFTlRTJywge1xuICB2YWx1ZToge1xuICAgIC4uLk9iamVjdC5nZXRQcm90b3R5cGVPZihIb3N0T2JqZWN0KS5FVkVOVFMsXG4gICAgdXBkYXRlOiAnb25VcGRhdGUnLFxuICAgIGFkZEZlYXR1cmU6ICdvbkFkZEZlYXR1cmUnLFxuICAgIHJlbW92ZUZlYXR1cmU6ICdvblJlbW92ZUZlYXR1cmUnLFxuICB9LFxuICB3cml0YWJsZTogZmFsc2UsXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgSG9zdE9iamVjdDtcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEVhc2luZ09iamVjdCBPYmplY3QgY29udGFpbmluZyBlYXNpbmcgZnVuY3Rpb25zXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBJbiAtIEVhc2luZyAnSW4nIGZ1bmN0aW9uLiBTaG91bGQgdXNlIHRoZSBzaWduYXR1cmUgKGs6bnVtYmVyKTpudW1iZXIuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBPdXQgLSBFYXNpbmcgJ091dCcgZnVuY3Rpb24uIFNob3VsZCB1c2UgdGhlIHNpZ25hdHVyZSAoazpudW1iZXIpOm51bWJlci5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IEluT3V0IC0gRWFzaW5nICdJbk91dCcgZnVuY3Rpb24uIFNob3VsZCB1c2UgdGhlIHNpZ25hdHVyZSAoazpudW1iZXIpOm51bWJlci5cbiAqL1xuXG4vKipcbiAqIExpbmVhciBFYXNpbmdcbiAqIEB0eXBlIHtFYXNpbmdPYmplY3R9XG4gKi9cbmV4cG9ydCBjb25zdCBMaW5lYXIgPSB7XG4gIE5vbmUoaykge1xuICAgIHJldHVybiBrO1xuICB9LFxuICBJbihrKSB7XG4gICAgcmV0dXJuIGs7XG4gIH0sXG4gIE91dChrKSB7XG4gICAgcmV0dXJuIGs7XG4gIH0sXG4gIEluT3V0KGspIHtcbiAgICByZXR1cm4gaztcbiAgfSxcbn07XG5cbi8qKlxuICogUXVhZHJhdGljIEVhc2luZ1xuICogQHR5cGUge0Vhc2luZ09iamVjdH1cbiAqL1xuZXhwb3J0IGNvbnN0IFF1YWRyYXRpYyA9IHtcbiAgSW4oaykge1xuICAgIHJldHVybiBrICogaztcbiAgfSxcbiAgT3V0KGspIHtcbiAgICByZXR1cm4gayAqICgyIC0gayk7XG4gIH0sXG4gIEluT3V0KGspIHtcbiAgICBrICo9IDI7XG4gICAgaWYgKGsgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogayAqIGs7XG4gICAgfVxuICAgIHJldHVybiAtMC41ICogKC0tayAqIChrIC0gMikgLSAxKTtcbiAgfSxcbn07XG5cbi8qKlxuICogQ3ViaWMgRWFzaW5nXG4gKiBAdHlwZSB7RWFzaW5nT2JqZWN0fVxuICovXG5leHBvcnQgY29uc3QgQ3ViaWMgPSB7XG4gIEluKGspIHtcbiAgICByZXR1cm4gayAqIGsgKiBrO1xuICB9LFxuICBPdXQoaykge1xuICAgIHJldHVybiAtLWsgKiBrICogayArIDE7XG4gIH0sXG4gIEluT3V0KGspIHtcbiAgICBrICo9IDI7XG4gICAgaWYgKGsgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrO1xuICAgIH1cblxuICAgIGsgLT0gMjtcbiAgICByZXR1cm4gMC41ICogKGsgKiBrICogayArIDIpO1xuICB9LFxufTtcblxuLyoqXG4gKiBRdWFydGljIEVhc2luZ1xuICogQHR5cGUge0Vhc2luZ09iamVjdH1cbiAqL1xuZXhwb3J0IGNvbnN0IFF1YXJ0aWMgPSB7XG4gIEluKGspIHtcbiAgICByZXR1cm4gayAqIGsgKiBrICogaztcbiAgfSxcbiAgT3V0KGspIHtcbiAgICByZXR1cm4gMSAtIC0tayAqIGsgKiBrICogaztcbiAgfSxcbiAgSW5PdXQoaykge1xuICAgIGsgKj0gMjtcbiAgICBpZiAoayA8IDEpIHtcbiAgICAgIHJldHVybiAwLjUgKiBrICogayAqIGsgKiBrO1xuICAgIH1cblxuICAgIGsgLT0gMjtcbiAgICByZXR1cm4gLTAuNSAqIChrICogayAqIGsgKiBrIC0gMik7XG4gIH0sXG59O1xuXG4vKipcbiAqIFF1aW50aWMgRWFzaW5nXG4gKiBAdHlwZSB7RWFzaW5nT2JqZWN0fVxuICovXG5leHBvcnQgY29uc3QgUXVpbnRpYyA9IHtcbiAgSW4oaykge1xuICAgIHJldHVybiBrICogayAqIGsgKiBrICogaztcbiAgfSxcbiAgT3V0KGspIHtcbiAgICByZXR1cm4gLS1rICogayAqIGsgKiBrICogayArIDE7XG4gIH0sXG4gIEluT3V0KGspIHtcbiAgICBrICo9IDI7XG4gICAgaWYgKGsgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrICogayAqIGs7XG4gICAgfVxuXG4gICAgayAtPSAyO1xuICAgIHJldHVybiAwLjUgKiAoayAqIGsgKiBrICogayAqIGsgKyAyKTtcbiAgfSxcbn07XG5cbi8qKlxuICogU2ludXNvaWRhbCBFYXNpbmdcbiAqIEB0eXBlIHtFYXNpbmdPYmplY3R9XG4gKi9cbmV4cG9ydCBjb25zdCBTaW51c29pZGFsID0ge1xuICBJbihrKSB7XG4gICAgcmV0dXJuIDEgLSBNYXRoLmNvcygoayAqIE1hdGguUEkpIC8gMik7XG4gIH0sXG4gIE91dChrKSB7XG4gICAgcmV0dXJuIE1hdGguc2luKChrICogTWF0aC5QSSkgLyAyKTtcbiAgfSxcbiAgSW5PdXQoaykge1xuICAgIHJldHVybiAwLjUgKiAoMSAtIE1hdGguY29zKE1hdGguUEkgKiBrKSk7XG4gIH0sXG59O1xuXG4vKipcbiAqIEV4cG9uZW50aWFsIEVhc2luZ1xuICogQHR5cGUge0Vhc2luZ09iamVjdH1cbiAqL1xuZXhwb3J0IGNvbnN0IEV4cG9uZW50aWFsID0ge1xuICBJbihrKSB7XG4gICAgcmV0dXJuIGsgPT09IDAgPyAwIDogMTAyNCAqKiAoayAtIDEpO1xuICB9LFxuICBPdXQoaykge1xuICAgIHJldHVybiBrID09PSAxID8gMSA6IDEgLSAyICoqICgtMTAgKiBrKTtcbiAgfSxcbiAgSW5PdXQoaykge1xuICAgIGlmIChrID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKGsgPT09IDEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGsgKj0gMjtcbiAgICBpZiAoayA8IDEpIHtcbiAgICAgIHJldHVybiAwLjUgKiAxMDI0ICoqIChrIC0gMSk7XG4gICAgfVxuICAgIHJldHVybiAwLjUgKiAoLSgyICoqICgtMTAgKiAoayAtIDEpKSkgKyAyKTtcbiAgfSxcbn07XG5cbi8qKlxuICogQ2lyY3VsYXIgRWFzaW5nXG4gKiBAdHlwZSB7RWFzaW5nT2JqZWN0fVxuICovXG5leHBvcnQgY29uc3QgQ2lyY3VsYXIgPSB7XG4gIEluKGspIHtcbiAgICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gayAqIGspO1xuICB9LFxuICBPdXQoaykge1xuICAgIHJldHVybiBNYXRoLnNxcnQoMSAtIC0tayAqIGspO1xuICB9LFxuICBJbk91dChrKSB7XG4gICAgayAqPSAyO1xuICAgIGlmIChrIDwgMSkge1xuICAgICAgcmV0dXJuIC0wLjUgKiAoTWF0aC5zcXJ0KDEgLSBrICogaykgLSAxKTtcbiAgICB9XG5cbiAgICBrIC09IDI7XG4gICAgcmV0dXJuIDAuNSAqIChNYXRoLnNxcnQoMSAtIGsgKiBrKSArIDEpO1xuICB9LFxufTtcblxuLyoqXG4gKiBFbGFzdGljIEVhc2luZ1xuICogQHR5cGUge0Vhc2luZ09iamVjdH1cbiAqL1xuZXhwb3J0IGNvbnN0IEVsYXN0aWMgPSB7XG4gIEluKGspIHtcbiAgICBsZXQgcztcbiAgICBsZXQgYSA9IDAuMTtcbiAgICBjb25zdCBwID0gMC40O1xuXG4gICAgaWYgKGsgPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChrID09PSAxKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBpZiAoIWEgfHwgYSA8IDEpIHtcbiAgICAgIGEgPSAxO1xuICAgICAgcyA9IHAgLyA0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzID0gKHAgKiBNYXRoLmFzaW4oMSAvIGEpKSAvICgyICogTWF0aC5QSSk7XG4gICAgfVxuXG4gICAgayAtPSAxO1xuICAgIHJldHVybiAtKGEgKiAyICoqICgxMCAqIGspICogTWF0aC5zaW4oKChrIC0gcykgKiAoMiAqIE1hdGguUEkpKSAvIHApKTtcbiAgfSxcbiAgT3V0KGspIHtcbiAgICBsZXQgcztcbiAgICBsZXQgYSA9IDAuMTtcbiAgICBjb25zdCBwID0gMC40O1xuXG4gICAgaWYgKGsgPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChrID09PSAxKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBpZiAoIWEgfHwgYSA8IDEpIHtcbiAgICAgIGEgPSAxO1xuICAgICAgcyA9IHAgLyA0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzID0gKHAgKiBNYXRoLmFzaW4oMSAvIGEpKSAvICgyICogTWF0aC5QSSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGEgKiAyICoqICgtMTAgKiBrKSAqIE1hdGguc2luKCgoayAtIHMpICogKDIgKiBNYXRoLlBJKSkgLyBwKSArIDE7XG4gIH0sXG4gIEluT3V0KGspIHtcbiAgICBsZXQgcztcbiAgICBsZXQgYSA9IDAuMTtcbiAgICBjb25zdCBwID0gMC40O1xuXG4gICAgaWYgKGsgPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChrID09PSAxKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBpZiAoIWEgfHwgYSA8IDEpIHtcbiAgICAgIGEgPSAxO1xuICAgICAgcyA9IHAgLyA0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzID0gKHAgKiBNYXRoLmFzaW4oMSAvIGEpKSAvICgyICogTWF0aC5QSSk7XG4gICAgfVxuXG4gICAgayAqPSAyO1xuICAgIGlmIChrIDwgMSkge1xuICAgICAgayAtPSAxO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgLTAuNSAqIChhICogMiAqKiAoMTAgKiBrKSAqIE1hdGguc2luKCgoayAtIHMpICogKDIgKiBNYXRoLlBJKSkgLyBwKSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgayAtPSAxO1xuICAgIHJldHVybiAoXG4gICAgICBhICogMiAqKiAoLTEwICogaykgKiBNYXRoLnNpbigoKGsgLSBzKSAqICgyICogTWF0aC5QSSkpIC8gcCkgKiAwLjUgKyAxXG4gICAgKTtcbiAgfSxcbn07XG5cbi8qKlxuICogQmFjayBFYXNpbmdcbiAqIEB0eXBlIHtFYXNpbmdPYmplY3R9XG4gKi9cbmV4cG9ydCBjb25zdCBCYWNrID0ge1xuICBJbihrKSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuIGsgKiBrICogKChzICsgMSkgKiBrIC0gcyk7XG4gIH0sXG4gIE91dChrKSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuIC0tayAqIGsgKiAoKHMgKyAxKSAqIGsgKyBzKSArIDE7XG4gIH0sXG4gIEluT3V0KGspIHtcbiAgICBjb25zdCBzID0gMS43MDE1OCAqIDEuNTI1O1xuICAgIGsgKj0gMjtcbiAgICBpZiAoayA8IDEpIHtcbiAgICAgIHJldHVybiAwLjUgKiAoayAqIGsgKiAoKHMgKyAxKSAqIGsgLSBzKSk7XG4gICAgfVxuXG4gICAgayAtPSAyO1xuICAgIHJldHVybiAwLjUgKiAoayAqIGsgKiAoKHMgKyAxKSAqIGsgKyBzKSArIDIpO1xuICB9LFxufTtcblxuLyoqXG4gKiBCb3VuY2UgRWFzaW5nXG4gKiBAdHlwZSB7RWFzaW5nT2JqZWN0fVxuICovXG5leHBvcnQgY29uc3QgQm91bmNlID0ge1xuICBJbihrKSB7XG4gICAgcmV0dXJuIDEgLSBCb3VuY2UuT3V0KDEgLSBrKTtcbiAgfSxcbiAgT3V0KGspIHtcbiAgICBpZiAoayA8IDEgLyAyLjc1KSB7XG4gICAgICByZXR1cm4gNy41NjI1ICogayAqIGs7XG4gICAgfSBlbHNlIGlmIChrIDwgMiAvIDIuNzUpIHtcbiAgICAgIGsgLT0gMS41O1xuICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC8gMi43NSkgKiBrICsgMC43NTtcbiAgICB9IGVsc2UgaWYgKGsgPCAyLjUgLyAyLjc1KSB7XG4gICAgICBrIC09IDIuMjU7XG4gICAgICByZXR1cm4gNy41NjI1ICogKGsgLyAyLjc1KSAqIGsgKyAwLjkzNzU7XG4gICAgfVxuICAgIGsgLT0gMi42MjU7XG4gICAgcmV0dXJuIDcuNTYyNSAqIChrIC8gMi43NSkgKiBrICsgMC45ODQzNzU7XG4gIH0sXG4gIEluT3V0KGspIHtcbiAgICBpZiAoayA8IDAuNSkge1xuICAgICAgcmV0dXJuIEJvdW5jZS5JbihrICogMikgKiAwLjU7XG4gICAgfVxuICAgIHJldHVybiBCb3VuY2UuT3V0KGsgKiAyIC0gMSkgKiAwLjUgKyAwLjU7XG4gIH0sXG59O1xuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1jbGFzc2VzLXBlci1maWxlICovXG5pbXBvcnQgSG9zdE9iamVjdCBmcm9tICdjb3JlL0hvc3RPYmplY3QnO1xuXG4vKipcbiAqIENsYXNzIGZhY3RvcnkgaW50ZXJmYWNlIGZvciBmZWF0dXJlcyB0aGF0IGFyZSBkZXBlbmRlbnQgb24gb3RoZXIgZmVhdHVyZXMgYmVpbmdcbiAqIHByZXNlbnQgb24gdGhlIGhvc3QuIEV2ZW50IGRlcGVuZGVuY2llcyB3aWxsIGJlIGxpc3RlbmVkIGZvciB3aGVuIGEgZmVhdHVyZSBvZlxuICogbWF0Y2hpbmcgdHlwZSBpcyBhZGRlZCB0byB0aGUgaG9zdCBhbmQgd2lsbCBzdG9wIGJlaW5nIGxpc3RlbmVkIGZvciB3aGVuIG9uZVxuICogaXMgcmVtb3ZlZC4gSWYgdGhlIGZlYXR1cmUgaXMgYWxyZWFkeSBwcmVzZW50IHdoZW4gY29uc3RydWN0ZWQsIGV2ZW50cyB3aWxsXG4gKiBiZSBsaXN0ZW5lZCBmb3IgcmlnaHQgYXdheS5cbiAqXG4gKiBAaW50ZXJmYWNlXG4gKlxuICogQHByb3BlcnR5IHtPYmplY3R9IEVWRU5UX0RFUEVOREVOQ0lFUyAtIEV2ZW50cyB0aGF0IHRoZSBmZWF0dXJlIHNob3VsZCBzdGFydC9zdG9wXG4gKiBsaXN0ZW5pbmcgZm9yIHdoZW4gYSBmZWF0dXJlIG9mIHR5cGUgRmVhdHVyZU5hbWUgaXMgYWRkZWQvcmVtb3ZlZCBmcm9tIHRoZSBob3N0LlxuICogRXZlbnQgZGVwZW5kZW5jaWVzIHNob3VsZCBmb2xsb3cgdGhlIHNpZ25hdHVyZTpcbiAqICB7IEZlYXR1cmVOYW1lOiB7IGV2ZW50TmFtZTogY2FsbGJhY2tOYW1lLCAuLi4gfSwgLi4uIH1cbiAqL1xuY2xhc3MgRmVhdHVyZURlcGVuZGVudEludGVyZmFjZSB7XG4gIC8qKlxuICAgKiBTdGFydCBsaXN0ZW5pbmcgZm9yIGV2ZW50IGRlcGVuZGVuY2llcyB0aGF0IG1hdGNoIHRoZSBnaXZlbiBmZWF0dXJlIHR5cGUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlTmFtZSAtIHR5cGUgb2YgZmVhdHVyZSB0byBsaXN0ZW4gZm9yLlxuICAgKi9cbiAgX29uRmVhdHVyZUFkZGVkKHR5cGVOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBTdG9wIGxpc3RlbmluZyBmb3IgZXZlbnQgZGVwZW5kZW5jaWVzIHRoYXQgbWF0Y2ggdGhlIGdpdmVuIGZlYXR1cmUgdHlwZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVOYW1lIC0gdHlwZSBvZiBmZWF0dXJlIHRvIHN0b3AgbGlzdGVuaW5nIGZvci5cbiAgICovXG4gIF9vbkZlYXR1cmVSZW1vdmVkKHR5cGVOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBAYXVnbWVudHMge0BsaW5rIEFic3RyYWN0SG9zdEZlYXR1cmUjZGlzY2FyZH1cbiAgICovXG4gIGRpc2NhcmQoKSB7fVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY2xhc3MgdGhhdCBpbXBsZW1lbnRzIHtAbGluayBGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlfSBhbmQgZXh0ZW5kc1xuICAgKiBhIHNwZWNpZmllZCBiYXNlIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge0NsYXNzfSBCYXNlQ2xhc3MgLSBUaGUgY2xhc3MgdG8gZXh0ZW5kLlxuICAgKlxuICAgKiBAcmV0dXJuIHtDbGFzc30gQSBjbGFzcyB0aGF0IGV4dGVuZHMgYEJhc2VDbGFzc2AgYW5kIGltcGxlbWVudHMge0BsaW5rIEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2V9LlxuICAgKi9cbiAgc3RhdGljIE1peGluKEJhc2VDbGFzcykge1xuICAgIGNvbnN0IEZlYXR1cmVEZXBlbmRlbnRNaXhpbiA9IGNsYXNzIGV4dGVuZHMgQmFzZUNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKGhvc3QpIHtcbiAgICAgICAgc3VwZXIoaG9zdCk7XG4gICAgICAgIHRoaXMuX2hvc3QgPSBob3N0O1xuXG4gICAgICAgIC8vIE5vIG5lZWQgdG8gbGlzdGVuIGZvciBldmVudHMgaWYgdGhlIG1peGluIGlzIGluIHRoZSBwcm90b3R5cGUgY2hhaW4gbXVsdGlwbGUgdGltZXNcbiAgICAgICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgICAgICAgIC8vIFN0YXJ0IGxpc3RlbmluZyBmb3IgZmVhdHVyZSBldmVudHNcbiAgICAgICAgICB0aGlzLl9vbkZlYXR1cmVBZGRlZCA9IHRoaXMuX29uRmVhdHVyZUFkZGVkLmJpbmQodGhpcyk7XG4gICAgICAgICAgdGhpcy5fb25GZWF0dXJlUmVtb3ZlZCA9IHRoaXMuX29uRmVhdHVyZVJlbW92ZWQuYmluZCh0aGlzKTtcblxuICAgICAgICAgIHRoaXMuX2hvc3QubGlzdGVuVG8oXG4gICAgICAgICAgICBIb3N0T2JqZWN0LkVWRU5UUy5hZGRGZWF0dXJlLFxuICAgICAgICAgICAgdGhpcy5fb25GZWF0dXJlQWRkZWRcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuX2hvc3QubGlzdGVuVG8oXG4gICAgICAgICAgICBIb3N0T2JqZWN0LkVWRU5UUy5yZW1vdmVGZWF0dXJlLFxuICAgICAgICAgICAgdGhpcy5fb25GZWF0dXJlUmVtb3ZlZFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBSZWdpc3RlciBmZWF0dXJlcyB0aGF0IGFscmVhZHkgZXhpc3RcbiAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmNvbnN0cnVjdG9yLkVWRU5UX0RFUEVOREVOQ0lFUykuZm9yRWFjaCh0eXBlTmFtZSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5faG9zdFt0eXBlTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aGlzLl9vbkZlYXR1cmVBZGRlZCh0eXBlTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX29uRmVhdHVyZUFkZGVkKHR5cGVOYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLkVWRU5UX0RFUEVOREVOQ0lFU1t0eXBlTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMuY29uc3RydWN0b3IuRVZFTlRfREVQRU5ERU5DSUVTW3R5cGVOYW1lXTtcblxuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGV2ZW50cykuZm9yRWFjaCgoW2V2ZW50TmFtZSwgY2FsbGJhY2tdKSA9PiB7XG4gICAgICAgICAgICB0aGlzW2NhbGxiYWNrXSA9IHRoaXNbY2FsbGJhY2tdLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9ob3N0Lmxpc3RlblRvKFxuICAgICAgICAgICAgICB0aGlzLl9ob3N0W3R5cGVOYW1lXS5FVkVOVFNbZXZlbnROYW1lXSxcbiAgICAgICAgICAgICAgdGhpc1tjYWxsYmFja11cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX29uRmVhdHVyZVJlbW92ZWQodHlwZU5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuRVZFTlRfREVQRU5ERU5DSUVTW3R5cGVOYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29uc3QgZXZlbnRzID0gdGhpcy5jb25zdHJ1Y3Rvci5FVkVOVF9ERVBFTkRFTkNJRVNbdHlwZU5hbWVdO1xuXG4gICAgICAgICAgT2JqZWN0LmVudHJpZXMoZXZlbnRzKS5mb3JFYWNoKChbZXZlbnROYW1lLCBjYWxsYmFja10pID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2hvc3Quc3RvcExpc3RlbmluZyhcbiAgICAgICAgICAgICAgdGhpcy5faG9zdFt0eXBlTmFtZV0uRVZFTlRTW2V2ZW50TmFtZV0sXG4gICAgICAgICAgICAgIHRoaXNbY2FsbGJhY2tdXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRpc2NhcmQoKSB7XG4gICAgICAgIC8vIFN0b3AgbGlzdGVuaW5nIGZvciBmZWF0dXJlIGV2ZW50c1xuICAgICAgICB0aGlzLl9ob3N0LnN0b3BMaXN0ZW5pbmcoXG4gICAgICAgICAgSG9zdE9iamVjdC5FVkVOVFMuYWRkRmVhdHVyZSxcbiAgICAgICAgICB0aGlzLl9vbkZlYXR1cmVBZGRlZFxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9ob3N0LnN0b3BMaXN0ZW5pbmcoXG4gICAgICAgICAgSG9zdE9iamVjdC5FVkVOVFMucmVtb3ZlRmVhdHVyZSxcbiAgICAgICAgICB0aGlzLl9vbkZlYXR1cmVSZW1vdmVkXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gU3RvcCBsaXN0ZW5pbmcgdG8gZmVhdHVyZS1zcGVjaWZpYyBldmVudHNcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5jb25zdHJ1Y3Rvci5FVkVOVF9ERVBFTkRFTkNJRVMpLmZvckVhY2godHlwZU5hbWUgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLl9ob3N0W3R5cGVOYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkZlYXR1cmVSZW1vdmVkKHR5cGVOYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHN1cGVyLmRpc2NhcmQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgRVZFTlRfREVQRU5ERU5DSUVTID0gQmFzZUNsYXNzLkVWRU5UX0RFUEVOREVOQ0lFUyB8fCB7fTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEZlYXR1cmVEZXBlbmRlbnRNaXhpbiwge1xuICAgICAgRVZFTlRfREVQRU5ERU5DSUVTOiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgLi4uRVZFTlRfREVQRU5ERU5DSUVTLFxuICAgICAgICB9LFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIEZlYXR1cmVEZXBlbmRlbnRNaXhpbjtcbiAgfVxufVxuXG4vKipcbiAqIEV2ZW50IGRlcGVuZGVuY2llcyBzaG91bGQgZm9sbG93IHRoZSBzaWduYXR1cmU6XG4gKiB7XG4gKiAgRmVhdHVyZU5hbWU6IHtcbiAqICAgIC8vIEV2ZW50cyB0aGF0IHRoZSBmZWF0dXJlIHNob3VsZCBzdGFydC9zdG9wIGxpc3RlbmluZyBmb3Igd2hlbiBhIGZlYXR1cmVcbiAqICAgIC8vIG9mIHR5cGUgRmVhdHVyZU5hbWUgaXMgYWRkZWQvcmVtb3ZlZCBmcm9tIHRoZSBob3N0XG4gKiAgICB7XG4gKiAgICAgIGV2ZW50TmFtZTogY2FsbGJhY2tOYW1lLFxuICogICAgICAuLi5cbiAqICAgIH0sXG4gKiAgfVxuICogfVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlLCB7XG4gIEVWRU5UX0RFUEVOREVOQ0lFUzoge1xuICAgIHZhbHVlOiB7fSxcbiAgICB3cml0YWJsZTogZmFsc2UsXG4gIH0sXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgRmVhdHVyZURlcGVuZGVudEludGVyZmFjZTtcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtY2xhc3Nlcy1wZXItZmlsZSAqL1xuaW1wb3J0IEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UgZnJvbSAnY29yZS9GZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlJztcblxuLyoqXG4gKiBDbGFzcyBmYWN0b3J5IGludGVyZmFjZSBmb3IgZmVhdHVyZXMgdGhhdCBhcmUgZGVwZW5kZW50IG9uIHRoZSBBbmltYXRpb25GZWF0dXJlXG4gKiBiZWluZyBwcmVzZW50IG9uIHRoZSBob3N0LiBMYXllciBhbmQgYW5pbWF0aW9uIGV2ZW50cyB3aWxsIGF1dG9tYXRpY2FsbHkgYmVcbiAqIGxpc3RlbmVkIGZvciBvbmNlIGEgQW5pbWF0aW9uRmVhdHVyZSBpcyBhZGRlZCB0byB0aGUgaG9zdCBhbmQgc3RvcHBlZCBvbmNlIGl0XG4gKiBpcyByZW1vdmVkLlxuICpcbiAqIEBpbnRlcmZhY2VcbiAqIEBleHRlbmRzIEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2VcbiAqXG4gKiBAcHJvcGVydHkge09iamVjdH0gRVZFTlRfREVQRU5ERU5DSUVTIC0gRXZlbnRzIHRoYXQgdGhlIGZlYXR1cmUgc2hvdWxkIHN0YXJ0L3N0b3BcbiAqIGxpc3RlbmluZyBmb3Igd2hlbiBhIGZlYXR1cmUgb2YgdHlwZSBGZWF0dXJlTmFtZSBpcyBhZGRlZC9yZW1vdmVkIGZyb20gdGhlIGhvc3QuXG4gKiBAcHJvcGVydHkge09iamVjdH0gRVZFTlRfREVQRU5ERU5DSUVTLkFuaW1hdGlvbkZlYXR1cmUgLSBFdmVudHMgdGhhdCBhcmVcbiAqIHNwZWNpZmljIHRvIHRoZSBBbmltYXRpb25GZWF0dXJlLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVF9ERVBFTkRFTkNJRVMuQW5pbWF0aW9uRmVhdHVyZS5hZGRMYXllcj0nX29uTGF5ZXJBZGRlZCddIC1cbiAqIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gQW5pbWF0aW9uRmVhdHVyZSBhZGRMYXllclxuICogZXZlbnRzIGFyZSBlbWl0dGVkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVF9ERVBFTkRFTkNJRVMuQW5pbWF0aW9uRmVhdHVyZS5yZW1vdmVMYXllcj0nX29uTGF5ZXJSZW1vdmVkJ10gLVxuICogVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBBbmltYXRpb25GZWF0dXJlIHJlbW92ZUxheWVyXG4gKiBldmVudHMgYXJlIGVtaXR0ZWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UX0RFUEVOREVOQ0lFUy5BbmltYXRpb25GZWF0dXJlLnJlbmFtZUxheWVyPSdfb25MYXllclJlbmFtZWQnXSAtXG4gKiBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIEFuaW1hdGlvbkZlYXR1cmUgcmVuYW1lTGF5ZXJcbiAqIGV2ZW50cyBhcmUgZW1pdHRlZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRfREVQRU5ERU5DSUVTLkFuaW1hdGlvbkZlYXR1cmUuYWRkQW5pbWF0aW9uPSdfb25BbmltYXRpb25BZGRlZCddIC1cbiAqIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gQW5pbWF0aW9uRmVhdHVyZSBhZGRBbmltYXRpb25cbiAqIGV2ZW50cyBhcmUgZW1pdHRlZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRfREVQRU5ERU5DSUVTLkFuaW1hdGlvbkZlYXR1cmUucmVtb3ZlQW5pbWF0aW9uPSdfb25BbmltYXRpb25SZW1vdmVkJ10gLVxuICogVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBBbmltYXRpb25GZWF0dXJlIHJlbW92ZUFuaW1hdGlvblxuICogZXZlbnRzIGFyZSBlbWl0dGVkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVF9ERVBFTkRFTkNJRVMuQW5pbWF0aW9uRmVhdHVyZS5yZW5hbWVBbmltYXRpb249J19vbkFuaW1hdGlvblJlbmFtZWQnXSAtXG4gKiBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIEFuaW1hdGlvbkZlYXR1cmUgcmVuYW1lQW5pbWF0aW9uXG4gKiBldmVudHMgYXJlIGVtaXR0ZWQuXG4gKi9cbmNsYXNzIEFuaW1hdGlvbkZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UgZXh0ZW5kcyBGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlIHtcbiAgLyoqXG4gICAqIEV4ZWN1dGVkIHdoZW4gYW5pbWF0aW9uIGxheWVyIGFkZGVkIGV2ZW50cyBhcmUgY2F1Z2h0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRoYXQgd2FzIGFkZGVkLlxuICAgKi9cbiAgX29uTGF5ZXJBZGRlZCh7bmFtZX0pIHt9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVkIHdoZW4gYW5pbWF0aW9uIGxheWVyIHJlbW92ZWQgZXZlbnRzIGFyZSBjYXVnaHQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCB3YXMgcmVtb3ZlZC5cbiAgICovXG4gIF9vbkxheWVyUmVtb3ZlZCh7bmFtZX0pIHt9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVkIHdoZW4gYW5pbWF0aW9uIGxheWVyIHJlbmFtZWQgZXZlbnRzIGFyZSBjYXVnaHQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvbGROYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCB3YXMgcmVuYW1lZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5ld05hbWUgLSBOZXcgbmFtZSBvZiB0aGUgbGF5ZXIuXG4gICAqL1xuICBfb25MYXllclJlbmFtZWQoe29sZE5hbWUsIG5ld05hbWV9KSB7fVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlZCB3aGVuIGFuaW1hdGlvbiBhZGRlZCBldmVudHMgYXJlIGNhdWdodC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRoYXQgYW4gYW5pbWF0aW9uIHdhcyBhZGRlZCB0by5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFuaW1hdGlvbk5hbWUgLSBOYW1lIG9mIHRoZSBhbmltYXRpb24gdGhhdCB3YXMgYWRkZWQuXG4gICAqL1xuICBfb25BbmltYXRpb25BZGRlZCh7bGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lfSkge31cblxuICAvKipcbiAgICogRXhlY3V0ZWQgd2hlbiBhbmltYXRpb24gcmVtb3ZlZCBldmVudHMgYXJlIGNhdWdodC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRoYXQgYW4gYW5pbWF0aW9uIHdhcyByZW1vdmVkIGZyb20uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbmltYXRpb25OYW1lIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRoYXQgd2FzIHJlbW92ZWQuXG4gICAqL1xuICBfb25BbmltYXRpb25SZW1vdmVkKHtsYXllck5hbWUsIGFuaW1hdGlvbk5hbWV9KSB7fVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlZCB3aGVuIGFuaW1hdGlvbiByZW5hbWVkIGV2ZW50cyBhcmUgY2F1Z2h0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCBhbiBhbmltYXRpb24gYmVsb25ncyB0by5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9sZE5hbWUgLSBOYW1lIG9mIHRoZSBhbmltYXRpb24gdGhhdCB3YXMgcmVuYW1lZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5ld05hbWUgLSBOZXcgbmFtZSBvZiB0aGUgYW5pbWF0aW9uLlxuICAgKi9cbiAgX29uQW5pbWF0aW9uUmVuYW1lZCh7bGF5ZXJOYW1lLCBvbGROYW1lLCBuZXdOYW1lfSkge31cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNsYXNzIHRoYXQgaW1wbGVtZW50cyB7QGxpbmsgQW5pbWF0aW9uRmVhdHVyZURlcGVuZGVudEludGVyZmFjZX1cbiAgICogYW5kIGV4dGVuZHMgYSBzcGVjaWZpZWQgYmFzZSBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtDbGFzc30gQmFzZUNsYXNzIC0gVGhlIGNsYXNzIHRvIGV4dGVuZC5cbiAgICpcbiAgICogQHJldHVybiB7Q2xhc3N9IEEgY2xhc3MgdGhhdCBleHRlbmRzIGBCYXNlQ2xhc3NgIGFuZCBpbXBsZW1lbnRzIHtAbGluayBBbmltYXRpb25GZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlfS5cbiAgICovXG4gIHN0YXRpYyBNaXhpbihCYXNlQ2xhc3MpIHtcbiAgICBjb25zdCBQYXJlbnRDbGFzcyA9IEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UuTWl4aW4oQmFzZUNsYXNzKTtcbiAgICBjb25zdCBBbmltYXRpb25GZWF0dXJlRGVwZW5kZW50TWl4aW4gPSBjbGFzcyBleHRlbmRzIFBhcmVudENsYXNzIHtcbiAgICAgIF9vbkxheWVyQWRkZWQoe25hbWV9KSB7fVxuXG4gICAgICBfb25MYXllclJlbW92ZWQoe25hbWV9KSB7fVxuXG4gICAgICBfb25MYXllclJlbmFtZWQoe29sZE5hbWUsIG5ld05hbWV9KSB7fVxuXG4gICAgICBfb25BbmltYXRpb25BZGRlZCh7bGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lfSkge31cblxuICAgICAgX29uQW5pbWF0aW9uUmVtb3ZlZCh7bGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lfSkge31cblxuICAgICAgX29uQW5pbWF0aW9uUmVuYW1lZCh7bGF5ZXJOYW1lLCBvbGROYW1lLCBuZXdOYW1lfSkge31cbiAgICB9O1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQW5pbWF0aW9uRmVhdHVyZURlcGVuZGVudE1peGluLCB7XG4gICAgICBFVkVOVF9ERVBFTkRFTkNJRVM6IHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAuLi5QYXJlbnRDbGFzcy5FVkVOVF9ERVBFTkRFTkNJRVMsXG4gICAgICAgICAgLi4uQW5pbWF0aW9uRmVhdHVyZURlcGVuZGVudEludGVyZmFjZS5FVkVOVF9ERVBFTkRFTkNJRVMsXG4gICAgICAgIH0sXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICByZXR1cm4gQW5pbWF0aW9uRmVhdHVyZURlcGVuZGVudE1peGluO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEFuaW1hdGlvbkZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UsIHtcbiAgRVZFTlRfREVQRU5ERU5DSUVTOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIEFuaW1hdGlvbkZlYXR1cmU6IHtcbiAgICAgICAgYWRkTGF5ZXI6ICdfb25MYXllckFkZGVkJyxcbiAgICAgICAgcmVtb3ZlTGF5ZXI6ICdfb25MYXllclJlbW92ZWQnLFxuICAgICAgICByZW5hbWVMYXllcjogJ19vbkxheWVyUmVuYW1lZCcsXG4gICAgICAgIGFkZEFuaW1hdGlvbjogJ19vbkFuaW1hdGlvbkFkZGVkJyxcbiAgICAgICAgcmVtb3ZlQW5pbWF0aW9uOiAnX29uQW5pbWF0aW9uUmVtb3ZlZCcsXG4gICAgICAgIHJlbmFtZUFuaW1hdGlvbjogJ19vbkFuaW1hdGlvblJlbmFtZWQnLFxuICAgICAgfSxcbiAgICB9LFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgfSxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBBbmltYXRpb25GZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlO1xuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1jbGFzc2VzLXBlci1maWxlICovXG5pbXBvcnQgQW5pbWF0aW9uRmVhdHVyZURlcGVuZGVudEludGVyZmFjZSBmcm9tICdjb3JlL2FuaW1wYWNrL0FuaW1hdGlvbkZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UnO1xuXG4vKipcbiAqIENsYXNzIGZhY3RvcnkgaW50ZXJmYWNlIGZvciB0aGF0IGtlZXBzIHRyYWNrIG9mIGxheWVycyBhbmQgYW5pbWF0aW9ucyBvbiBhIGhvc3QuXG4gKiBUcmFja2VkIGFzc2V0cyBhcmUgbWFya2VkIGFzIGluYWN0aXZlIHVudGlsIGxheWVycyBhbmQgYW5pbWF0aW9ucyB3aXRoIG1hdGNoaW5nXG4gKiBuYW1lcyBhcmUgZGV0ZWN0ZWQgYXMgcHJlc2VudCBvbiB0aGUgaG9zdC5cbiAqXG4gKiBAaW50ZXJmYWNlXG4gKiBAZXh0ZW5kcyBBbmltYXRpb25GZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlXG4gKlxuICogQHByb3BlcnR5IHtPYmplY3R9IERFRkFVTFRfTEFZRVJfT1BUSU9OUyAtIERlZmF1bHQgb3B0aW9ucyB0byB1c2Ugd2hlbiBleGVjdXRpbmdcbiAqIHtAbGluayBBbmltYXRpb25MYXllcn0gbWV0aG9kcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbREVGQVVMVF9MQVlFUl9PUFRJT05TLmJsZW5kVGltZT0wLjVdIC0gRGVmYXVsdCB0aW1lIGluIHNlY29uZHNcbiAqIHRvIHVzZSB3aGVuIGV4ZWN1dGluZyB7QGxpbmsgQW5pbWF0aW9uTGF5ZXIuc2V0QmxlbmRXZWlnaHR9LlxuICogQHByb3BlcnR5IHtPYmplY3R9IFtERUZBVUxUX0xBWUVSX09QVElPTlMuYW5pbWF0aW9ucz17fV0gLSBNYXBzIGFuaW1hdGlvbiBuYW1lc1xuICogdG8gZGVmYXVsdCBvcHRpb25zIG9iamVjdHMgdG8gdXNlIGZvciBtYW5hZ2VkIGFuaW1hdGlvbnMuXG4gKi9cbmNsYXNzIE1hbmFnZWRBbmltYXRpb25MYXllckludGVyZmFjZSBleHRlbmRzIEFuaW1hdGlvbkZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2Uge1xuICAvKipcbiAgICogU3RhcnQgdHJhY2tpbmcga2VlcGluZyB0cmFjayBvZiB3aGV0aGVyIGEgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpcyBwcmVzZW50XG4gICAqIG9uIHRoZSBob3N0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRvIGtlZXAgdHJhY2sgb2YuXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBsYXllci5cbiAgICogQHBhcmFtIHtudW1iZXI9fSBvcHRpb25zLmJsZW5kVGltZSAtIERlZmF1bHQgYW1vdW50IG9mIHRpbWUgdG8gdXNlIHdoZW5cbiAgICogbWFuaXB1bGF0aW5nIGxheWVyIHdlaWdodHMgb24gdGhpcyBsYXllci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9wdGlvbnMuZWFzaW5nRm4gLSBEZWZhdWx0IGVhc2luZyBmdW5jdGlvbiB0byB1c2Ugd2hlblxuICAgKiBtYW5pcHVsYXRpbmcgbGF5ZXIgd2VpZ2h0cyBvbiB0aGlzIGxheWVyLlxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMuYW5pbWF0aW9ucyAtIEFuaW1hdGlvbnMgdG8ga2VlcCB0cmFjayBvZiBvbiB0aGUgbGF5ZXIuXG4gICAqIEFuaW1hdGlvbnMgYXJlIHJlcHJlc2VudGVkIGFzIGtleS92YWx1ZSBwYWlycyBvZiBhbmltYXRpb24gbmFtZXMgYW5kIHRoZWlyXG4gICAqIG9wdGlvbnMuXG4gICAqL1xuICByZWdpc3RlckxheWVyKG5hbWUsIG9wdGlvbnMgPSB7fSkge31cblxuICAvKipcbiAgICogU3RhcnQgdHJhY2tpbmcga2VlcGluZyB0cmFjayBvZiB3aGV0aGVyIGFuIGFuaW1hdGlvbiB3aXRoIHRoZSBnaXZlbiBuYW1lIGlzXG4gICAqIHByZXNlbnQgb24gdGhlIGhvc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0aGF0IHdpbGwgb3duIHRoZSBhbmltYXRpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbmltYXRpb25OYW1lIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRvIGtlZXAgdHJhY2sgb2YuXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBhbmltYXRpb24uXG4gICAqL1xuICByZWdpc3RlckFuaW1hdGlvbihsYXllck5hbWUsIGFuaW1hdGlvbk5hbWUsIG9wdGlvbnMgPSB7fSkge31cblxuICAvKipcbiAgICogU2V0IGxheWVyIHdlaWdodHMgb24gdHJhY2tlZCBsYXllcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBuYW1lRmlsdGVyIC0gUHJlZGljYXRlIGZ1bmN0aW9uIHRvIHRlc3QgZWFjaCB0cmFja2VkIGxheWVyXG4gICAqIHdpdGguIEJ5IGRlZmF1bHQgYWxsIGxheWVycyB3aWxsIHBhc3MuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3ZWlnaHQgLSBXZWlnaHQgdmFsdWUgdG8gc2V0IG9uIGxheWVycy5cbiAgICogQHBhcmFtIHtudW1iZXI9fSBzZWNvbmRzIC0gTnVtYmVyIG9mIHNlY29uZHMgaXQgd2lsbCB0YWtlIHRvIHJlYWNoIHRoZSB3ZWlnaHRcbiAgICogb24gZWFjaCBsYXllci4gSWYgdW5kZWZpbmVkLCBlYWNoIGxheWVycycgYmxlbmRUaW1lIG9wdGlvbiBpcyB1c2VkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gZWFzaW5nRm4gLSBFYXNpbmcgZnVuY3Rpb24gdG8gdXNlIHdoZW4gc2V0dGluZyB3ZWlnaHRcbiAgICogb24gZWFjaCBsYXllci4gSWYgdW5kZWZpbmVkLCBlYWNoIGxheWVycycgZWFzaW5nRm4gb3B0aW9uIGlzIHVzZWQuXG4gICAqL1xuICBzZXRMYXllcldlaWdodHMobmFtZUZpbHRlciA9ICgpID0+IHRydWUsIHdlaWdodCwgc2Vjb25kcywgZWFzaW5nRm4pIHt9XG5cbiAgLyoqXG4gICAqIFNldCBhbGwgdHJhY2tlZCBsYXllcnMnIHdlaWdodHMgdG8gMS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXI9fSBzZWNvbmRzIC0gTnVtYmVyIG9mIHNlY29uZHMgaXQgd2lsbCB0YWtlIHRvIHJlYWNoIHRoZSB3ZWlnaHRcbiAgICogb24gZWFjaCBsYXllci4gSWYgdW5kZWZpbmVkLCBlYWNoIGxheWVycycgYmxlbmRUaW1lIG9wdGlvbiBpcyB1c2VkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gZWFzaW5nRm4gLSBFYXNpbmcgZnVuY3Rpb24gdG8gdXNlIHdoZW4gc2V0dGluZyB3ZWlnaHRcbiAgICogb24gZWFjaCBsYXllci4gSWYgdW5kZWZpbmVkLCBlYWNoIGxheWVycycgZWFzaW5nRm4gb3B0aW9uIGlzIHVzZWQuXG4gICAqL1xuICBlbmFibGUoc2Vjb25kcywgZWFzaW5nRm4pIHt9XG5cbiAgLyoqXG4gICAqIFNldCBhbGwgdHJhY2tlZCBsYXllcnMnIHdlaWdodHMgdG8gMC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXI9fSBzZWNvbmRzIC0gTnVtYmVyIG9mIHNlY29uZHMgaXQgd2lsbCB0YWtlIHRvIHJlYWNoIHRoZSB3ZWlnaHRcbiAgICogb24gZWFjaCBsYXllci4gSWYgdW5kZWZpbmVkLCBlYWNoIGxheWVycycgYmxlbmRUaW1lIG9wdGlvbiBpcyB1c2VkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gZWFzaW5nRm4gLSBFYXNpbmcgZnVuY3Rpb24gdG8gdXNlIHdoZW4gc2V0dGluZyB3ZWlnaHRcbiAgICogb24gZWFjaCBsYXllci4gSWYgdW5kZWZpbmVkLCBlYWNoIGxheWVycycgZWFzaW5nRm4gb3B0aW9uIGlzIHVzZWQuXG4gICAqL1xuICBkaXNhYmxlKHNlY29uZHMsIGVhc2luZ0ZuKSB7fVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY2xhc3MgdGhhdCBpbXBsZW1lbnRzIHtAbGluayBNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2V9XG4gICAqIGFuZCBleHRlbmRzIGEgc3BlY2lmaWVkIGJhc2UgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2xhc3N9IEJhc2VDbGFzcyAtIFRoZSBjbGFzcyB0byBleHRlbmQuXG4gICAqXG4gICAqIEByZXR1cm4ge0NsYXNzfSBBIGNsYXNzIHRoYXQgZXh0ZW5kcyBgQmFzZUNsYXNzYCBhbmQgaW1wbGVtZW50cyB7QGxpbmsgTWFuYWdlZEFuaW1hdGlvbkxheWVySW50ZXJmYWNlfS5cbiAgICovXG4gIHN0YXRpYyBNaXhpbihCYXNlQ2xhc3MpIHtcbiAgICBjb25zdCBQYXJlbnRDbGFzcyA9IEFuaW1hdGlvbkZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UuTWl4aW4oQmFzZUNsYXNzKTtcbiAgICBjb25zdCBNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJNaXhpbiA9IGNsYXNzIGV4dGVuZHMgUGFyZW50Q2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcblxuICAgICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzID0ge307XG4gICAgICB9XG5cbiAgICAgIF9vbkZlYXR1cmVBZGRlZCh0eXBlTmFtZSkge1xuICAgICAgICBzdXBlci5fb25GZWF0dXJlQWRkZWQodHlwZU5hbWUpO1xuXG4gICAgICAgIGlmICh0eXBlTmFtZSAhPT0gJ0FuaW1hdGlvbkZlYXR1cmUnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWFuYWdlZExheWVycyA9IHRoaXMuX21hbmFnZWRMYXllcnMgfHwge307XG5cbiAgICAgICAgLy8gRGV0ZWN0IG5ldyBsYXllcnNcbiAgICAgICAgdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlLmxheWVycy5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICAgIHRoaXMuX29uTGF5ZXJBZGRlZCh7bmFtZX0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgX29uRmVhdHVyZVJlbW92ZWQodHlwZU5hbWUpIHtcbiAgICAgICAgc3VwZXIuX29uRmVhdHVyZVJlbW92ZWQodHlwZU5hbWUpO1xuXG4gICAgICAgIGlmICh0eXBlTmFtZSAhPT0gJ0FuaW1hdGlvbkZlYXR1cmUnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWFuYWdlZExheWVycyA9IHRoaXMuX21hbmFnZWRMYXllcnMgfHwge307XG5cbiAgICAgICAgLy8gRGVhY3RpdmF0ZSB0aGUgbGF5ZXJzXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX21hbmFnZWRMYXllcnMpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgICAgdGhpcy5fb25MYXllclJlbW92ZWQoe25hbWV9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIF9vbkxheWVyQWRkZWQoe25hbWV9KSB7XG4gICAgICAgIC8vIE1hcmsgdGhlIGxheWVyIGFzIGFjdGl2ZSBpZiBpdCBpcyBtYW5hZ2VkXG4gICAgICAgIGlmICh0aGlzLl9tYW5hZ2VkTGF5ZXJzW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzW25hbWVdLmlzQWN0aXZlID0gdHJ1ZTtcblxuICAgICAgICAgIC8vIERldGVjdCBuZXcgYW5pbWF0aW9uc1xuICAgICAgICAgIHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5nZXRBbmltYXRpb25zKG5hbWUpLmZvckVhY2goYW5pbU5hbWUgPT4ge1xuICAgICAgICAgICAgdGhpcy5fb25BbmltYXRpb25BZGRlZCh7bGF5ZXJOYW1lOiBuYW1lLCBhbmltYXRpb25OYW1lOiBhbmltTmFtZX0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9vbkxheWVyUmVtb3ZlZCh7bmFtZX0pIHtcbiAgICAgICAgLy8gRGVhY3RpdmF0ZSB0aGUgbGF5ZXIgaWYgaXQgaXMgbWFuYWdlZFxuICAgICAgICBpZiAodGhpcy5fbWFuYWdlZExheWVyc1tuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5fbWFuYWdlZExheWVyc1tuYW1lXS5pc0FjdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgLy8gRGVhY3RpdmF0ZSB0aGUgYW5pbWF0aW9uc1xuICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX21hbmFnZWRMYXllcnNbbmFtZV0uYW5pbWF0aW9ucykuZm9yRWFjaChcbiAgICAgICAgICAgIGFuaW1OYW1lID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5fb25BbmltYXRpb25SZW1vdmVkKHtcbiAgICAgICAgICAgICAgICBsYXllck5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uTmFtZTogYW5pbU5hbWUsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX29uTGF5ZXJSZW5hbWVkKHtvbGROYW1lLCBuZXdOYW1lfSkge1xuICAgICAgICBjb25zdCBsYXllck9wdGlvbnMgPSB0aGlzLl9tYW5hZ2VkTGF5ZXJzW29sZE5hbWVdO1xuXG4gICAgICAgIC8vIFJlcGxhY2UgdGhlIGxheWVyIGtleSB3aXRoIHRoZSBuZXcgbmFtZVxuICAgICAgICBpZiAobGF5ZXJPcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fbWFuYWdlZExheWVyc1tvbGROYW1lXTtcbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzW25ld05hbWVdID0gbGF5ZXJPcHRpb25zO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9vbkFuaW1hdGlvbkFkZGVkKHtsYXllck5hbWUsIGFuaW1hdGlvbk5hbWV9KSB7XG4gICAgICAgIC8vIE1hcmsgdGhlIGFuaW1hdGlvbiBhcyBhY3RpdmUgaWYgaXQgaXMgbWFuYWdlZFxuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0uYW5pbWF0aW9uc1thbmltYXRpb25OYW1lXSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICkge1xuICAgICAgICAgIHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXS5hbmltYXRpb25zW1xuICAgICAgICAgICAgYW5pbWF0aW9uTmFtZVxuICAgICAgICAgIF0uaXNBY3RpdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9vbkFuaW1hdGlvblJlbW92ZWQoe2xheWVyTmFtZSwgYW5pbWF0aW9uTmFtZX0pIHtcbiAgICAgICAgLy8gRGVhY3RpdmF0ZSB0aGUgYW5pbWF0aW9uIGlmIGl0IGlzIG1hbmFnZWRcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdLmFuaW1hdGlvbnNbYW5pbWF0aW9uTmFtZV0gIT09IHVuZGVmaW5lZFxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0uYW5pbWF0aW9uc1tcbiAgICAgICAgICAgIGFuaW1hdGlvbk5hbWVcbiAgICAgICAgICBdLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX29uQW5pbWF0aW9uUmVuYW1lZCh7bGF5ZXJOYW1lLCBvbGROYW1lLCBuZXdOYW1lfSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0uYW5pbWF0aW9uc1tvbGROYW1lXSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIGFuaW1hdGlvbiBrZXkgd2l0aCB0aGUgbmV3IG5hbWVcbiAgICAgICAgICBjb25zdCBhbmltT3B0aW9ucyA9IHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXS5hbmltYXRpb25zW1xuICAgICAgICAgICAgb2xkTmFtZVxuICAgICAgICAgIF07XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXS5hbmltYXRpb25zW29sZE5hbWVdO1xuICAgICAgICAgIHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXS5hbmltYXRpb25zW25ld05hbWVdID0gYW5pbU9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVnaXN0ZXJMYXllcihuYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgLy8gU3RhcnQgd2l0aCBkZWZhdWx0IG9wdGlvbnMgZm9yIGVhY2ggbmV3IGxheWVyXG4gICAgICAgIGlmICh0aGlzLl9tYW5hZ2VkTGF5ZXJzW25hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzW25hbWVdID0ge1xuICAgICAgICAgICAgLi4udGhpcy5jb25zdHJ1Y3Rvci5ERUZBVUxUX0xBWUVSX09QVElPTlMsXG4gICAgICAgICAgICBhbmltYXRpb25zOiB7fSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIGFsbCBvcHRpb25zIGV4Y2VwdCBhbmltYXRpb25zXG4gICAgICAgIGNvbnN0IGxheWVyT3B0aW9ucyA9IHRoaXMuX21hbmFnZWRMYXllcnNbbmFtZV07XG4gICAgICAgIG9wdGlvbnMgPSB7Li4ub3B0aW9uc307XG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBvcHRpb25zLmFuaW1hdGlvbnMgfHwge307XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmFuaW1hdGlvbnM7XG4gICAgICAgIE9iamVjdC5hc3NpZ24obGF5ZXJPcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBsYXllciBjYW4gYmUgbWFuaXB1bGF0ZWQgbm93XG4gICAgICAgIGxheWVyT3B0aW9ucy5pc0FjdGl2ZSA9XG4gICAgICAgICAgdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICB0aGlzLl9ob3N0LkFuaW1hdGlvbkZlYXR1cmUubGF5ZXJzLmluY2x1ZGVzKG5hbWUpO1xuXG4gICAgICAgIC8vIFJlZ2lzdGVyIHRoZSBhbmltYXRpb25zXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGFuaW1hdGlvbk9wdGlvbnMpLmZvckVhY2goKFthbmltTmFtZSwgYW5pbU9wdGlvbnNdKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZWdpc3RlckFuaW1hdGlvbihuYW1lLCBhbmltTmFtZSwgYW5pbU9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmVnaXN0ZXJBbmltYXRpb24obGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgLy8gUmVnaXN0ZXIgdGhlIGxheWVyIGlmIGl0IGhhc24ndCBiZWVuIHJlZ2lzdGVyZWQgeWV0XG4gICAgICAgIGlmICh0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMucmVnaXN0ZXJMYXllcihsYXllck5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIGFuaW1hdGlvbiBvcHRpb25zXG4gICAgICAgIGNvbnN0IGFuaW1PcHRpb25zID1cbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0uYW5pbWF0aW9uc1thbmltYXRpb25OYW1lXSB8fCB7fTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhbmltT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXS5hbmltYXRpb25zW2FuaW1hdGlvbk5hbWVdID0gYW5pbU9wdGlvbnM7XG5cbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgYW5pbWF0aW9uIGNhbiBiZSBtYW5pcHVsYXRlZCBub3dcbiAgICAgICAgdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdLmFuaW1hdGlvbnNbYW5pbWF0aW9uTmFtZV0uaXNBY3RpdmUgPVxuICAgICAgICAgIHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXS5pc0FjdGl2ZSAmJlxuICAgICAgICAgIHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5nZXRBbmltYXRpb25zKGxheWVyTmFtZSkuaW5jbHVkZXMoXG4gICAgICAgICAgICBhbmltYXRpb25OYW1lXG4gICAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgc2V0TGF5ZXJXZWlnaHRzKG5hbWVGaWx0ZXIgPSAoKSA9PiB0cnVlLCB3ZWlnaHQsIHNlY29uZHMsIGVhc2luZ0ZuKSB7XG4gICAgICAgIGNvbnN0IGxheWVyTmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLl9tYW5hZ2VkTGF5ZXJzKS5maWx0ZXIobmFtZUZpbHRlcik7XG5cbiAgICAgICAgbGF5ZXJOYW1lcy5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICAgIGNvbnN0IGxheWVyT3B0aW9ucyA9IHRoaXMuX21hbmFnZWRMYXllcnNbbmFtZV07XG5cbiAgICAgICAgICBpZiAobGF5ZXJPcHRpb25zLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLl9ob3N0LkFuaW1hdGlvbkZlYXR1cmUuc2V0TGF5ZXJXZWlnaHQoXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIHdlaWdodCxcbiAgICAgICAgICAgICAgc2Vjb25kcyAhPT0gdW5kZWZpbmVkID8gc2Vjb25kcyA6IGxheWVyT3B0aW9ucy5ibGVuZFRpbWUsXG4gICAgICAgICAgICAgIGVhc2luZ0ZuIHx8IGxheWVyT3B0aW9ucy5lYXNpbmdGblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBlbmFibGUoc2Vjb25kcywgZWFzaW5nRm4pIHtcbiAgICAgICAgdGhpcy5zZXRMYXllcldlaWdodHModW5kZWZpbmVkLCAxLCBzZWNvbmRzLCBlYXNpbmdGbik7XG4gICAgICB9XG5cbiAgICAgIGRpc2FibGUoc2Vjb25kcywgZWFzaW5nRm4pIHtcbiAgICAgICAgdGhpcy5zZXRMYXllcldlaWdodHModW5kZWZpbmVkLCAwLCBzZWNvbmRzLCBlYXNpbmdGbik7XG4gICAgICB9XG5cbiAgICAgIGluc3RhbGxBcGkoKSB7XG4gICAgICAgIGNvbnN0IGFwaSA9IHN1cGVyLmluc3RhbGxBcGkoKTtcblxuICAgICAgICBPYmplY3QuYXNzaWduKGFwaSwge1xuICAgICAgICAgIHJlZ2lzdGVyTGF5ZXI6IHRoaXMucmVnaXN0ZXJMYXllci5iaW5kKHRoaXMpLFxuICAgICAgICAgIHJlZ2lzdGVyQW5pbWF0aW9uOiB0aGlzLnJlZ2lzdGVyQW5pbWF0aW9uLmJpbmQodGhpcyksXG4gICAgICAgICAgc2V0TGF5ZXJXZWlnaHRzOiB0aGlzLnNldExheWVyV2VpZ2h0cy5iaW5kKHRoaXMpLFxuICAgICAgICAgIGVuYWJsZTogdGhpcy5lbmFibGUuYmluZCh0aGlzKSxcbiAgICAgICAgICBkaXNhYmxlOiB0aGlzLmRpc2FibGUuYmluZCh0aGlzKSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGFwaTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTWFuYWdlZEFuaW1hdGlvbkxheWVyTWl4aW4sIHtcbiAgICAgIERFRkFVTFRfTEFZRVJfT1BUSU9OUzoge1xuICAgICAgICB2YWx1ZTogTWFuYWdlZEFuaW1hdGlvbkxheWVySW50ZXJmYWNlLkRFRkFVTFRfTEFZRVJfT1BUSU9OUyxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIHJldHVybiBNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJNaXhpbjtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2UsIHtcbiAgREVGQVVMVF9MQVlFUl9PUFRJT05TOiB7XG4gICAgdmFsdWU6IHtibGVuZFRpbWU6IDAuNSwgYW5pbWF0aW9uczoge319LFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgfSxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2U7XG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtY2xhc3Nlcy1wZXItZmlsZSAqL1xuaW1wb3J0IEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UgZnJvbSAnY29yZS9GZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlJztcblxuLyoqXG4gKiBDbGFzcyBmYWN0b3J5IGludGVyZmFjZSBmb3IgZmVhdHVyZXMgdGhhdCBhcmUgZGVwZW5kZW50IG9uIHRoZSBUZXh0VG9TcGVlY2hGZWF0dXJlXG4gKiBiZWluZyBwcmVzZW50IG9uIHRoZSBob3N0LiBTcGVlY2ggZXZlbnRzIHdpbGwgYXV0b21hdGljYWxseSBiZSBsaXN0ZW5lZCBmb3Igb25jZSBhXG4gKiBUZXh0VG9TcGVlY2hGZWF0dXJlIGlzIGFkZGVkIHRvIHRoZSBob3N0IGFuZCBzdG9wcGVkIG9uY2UgaXQgaXMgcmVtb3ZlZC5cbiAqXG4gKiBAaW50ZXJmYWNlXG4gKiBAZXh0ZW5kcyBGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlXG4gKlxuICogQHByb3BlcnR5IHtPYmplY3R9IEVWRU5UX0RFUEVOREVOQ0lFUyAtIEV2ZW50cyB0aGF0IHRoZSBmZWF0dXJlIHNob3VsZCBzdGFydC9zdG9wXG4gKiBsaXN0ZW5pbmcgZm9yIHdoZW4gYSBmZWF0dXJlIG9mIHR5cGUgRmVhdHVyZU5hbWUgaXMgYWRkZWQvcmVtb3ZlZCBmcm9tIHRoZSBob3N0LlxuICogQHByb3BlcnR5IHtPYmplY3R9IEVWRU5UX0RFUEVOREVOQ0lFUy5UZXh0VG9TcGVlY2hGZWF0dXJlIC0gRXZlbnRzIHRoYXQgYXJlXG4gKiBzcGVjaWZpYyB0byB0aGUgVGV4dFRvU3BlZWNoRmVhdHVyZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRfREVQRU5ERU5DSUVTLlRleHRUb1NwZWVjaEZlYXR1cmUucGxheT0nX29uUGxheSddIC1cbiAqIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gVGV4dFRvU3BlZWNoRmVhdHVyZSBwbGF5XG4gKiBldmVudHMgYXJlIGVtaXR0ZWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UX0RFUEVOREVOQ0lFUy5UZXh0VG9TcGVlY2hGZWF0dXJlLnBhdXNlPSdfb25QYXVzZSddIC1cbiAqIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gVGV4dFRvU3BlZWNoRmVhdHVyZSBwYXVzZVxuICogZXZlbnRzIGFyZSBlbWl0dGVkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVF9ERVBFTkRFTkNJRVMuVGV4dFRvU3BlZWNoRmVhdHVyZS5yZXN1bWU9J19vblJlc3VtZSddIC1cbiAqIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gVGV4dFRvU3BlZWNoRmVhdHVyZSByZXN1bWVcbiAqIGV2ZW50cyBhcmUgZW1pdHRlZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRfREVQRU5ERU5DSUVTLlRleHRUb1NwZWVjaEZlYXR1cmUuc3RvcD0nX29uU3RvcCddIC1cbiAqIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gVGV4dFRvU3BlZWNoRmVhdHVyZSBzdG9wXG4gKiBldmVudHMgYXJlIGVtaXR0ZWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UX0RFUEVOREVOQ0lFUy5UZXh0VG9TcGVlY2hGZWF0dXJlLnNlbnRlbmNlPSdfb25TZW50ZW5jZSddIC1cbiAqIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gVGV4dFRvU3BlZWNoRmVhdHVyZSBzZW50ZW5jZVxuICogZXZlbnRzIGFyZSBlbWl0dGVkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVF9ERVBFTkRFTkNJRVMuVGV4dFRvU3BlZWNoRmVhdHVyZS53b3JkPSdfb25Xb3JkJ10gLVxuICogVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBUZXh0VG9TcGVlY2hGZWF0dXJlIHdvcmRcbiAqIGV2ZW50cyBhcmUgZW1pdHRlZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRfREVQRU5ERU5DSUVTLlRleHRUb1NwZWVjaEZlYXR1cmUudmlzZW1lPSdfb25WaXNlbWUnXSAtXG4gKiBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIFRleHRUb1NwZWVjaEZlYXR1cmUgdmlzZW1lXG4gKiBldmVudHMgYXJlIGVtaXR0ZWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UX0RFUEVOREVOQ0lFUy5UZXh0VG9TcGVlY2hGZWF0dXJlLnNzbWw9J19vblNzbWwnXSAtXG4gKiBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIFRleHRUb1NwZWVjaEZlYXR1cmUgc3NtbFxuICogZXZlbnRzIGFyZSBlbWl0dGVkLlxuICovXG5jbGFzcyBUZXh0VG9TcGVlY2hGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlIGV4dGVuZHMgRmVhdHVyZURlcGVuZGVudEludGVyZmFjZSB7XG4gIC8qKlxuICAgKiBFeGVjdXRlZCB3aGVuIHNwZWVjaCBwbGF5IGV2ZW50cyBhcmUgY2F1Z2h0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uUGxheSgpIHt9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVkIHdoZW4gc3BlZWNoIHBhdXNlIGV2ZW50cyBhcmUgY2F1Z2h0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uUGF1c2UoKSB7fVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlZCB3aGVuIHNwZWVjaCByZXN1bWUgZXZlbnRzIGFyZSBjYXVnaHQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25SZXN1bWUoKSB7fVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlZCB3aGVuIHNwZWVjaCBzdG9wIGV2ZW50cyBhcmUgY2F1Z2h0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uU3RvcCgpIHt9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVkIHdoZW4gc3BlZWNoIHNlbnRlbmNlIGV2ZW50cyBhcmUgY2F1Z2h0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uU2VudGVuY2UoKSB7fVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlZCB3aGVuIHNwZWVjaCB3b3JkIGV2ZW50cyBhcmUgY2F1Z2h0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uV29yZCgpIHt9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVkIHdoZW4gc3BlZWNoIHZpc2VtZSBldmVudHMgYXJlIGNhdWdodC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblZpc2VtZSgpIHt9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVkIHdoZW4gc3BlZWNoIHNzbWwgZXZlbnRzIGFyZSBjYXVnaHQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Tc21sKCkge31cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNsYXNzIHRoYXQgaW1wbGVtZW50cyB7QGxpbmsgVGV4dFRvU3BlZWNoRmVhdHVyZURlcGVuZGVudEludGVyZmFjZX1cbiAgICogYW5kIGV4dGVuZHMgYSBzcGVjaWZpZWQgYmFzZSBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtDbGFzc30gQmFzZUNsYXNzIC0gVGhlIGNsYXNzIHRvIGV4dGVuZC5cbiAgICpcbiAgICogQHJldHVybiB7Q2xhc3N9IEEgY2xhc3MgdGhhdCBleHRlbmRzIGBCYXNlQ2xhc3NgIGFuZCBpbXBsZW1lbnRzIHtAbGluayBUZXh0VG9TcGVlY2hGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlfS5cbiAgICovXG4gIHN0YXRpYyBNaXhpbihCYXNlQ2xhc3MpIHtcbiAgICBjb25zdCBQYXJlbnRDbGFzcyA9IEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UuTWl4aW4oQmFzZUNsYXNzKTtcbiAgICBjb25zdCBUZXh0VG9TcGVlY2hGZWF0dXJlRGVwZW5kZW50TWl4aW4gPSBjbGFzcyBleHRlbmRzIFBhcmVudENsYXNzIHtcbiAgICAgIF9vblBsYXkoKSB7fVxuXG4gICAgICBfb25QYXVzZSgpIHt9XG5cbiAgICAgIF9vblJlc3VtZSgpIHt9XG5cbiAgICAgIF9vblN0b3AoKSB7fVxuXG4gICAgICBfb25TZW50ZW5jZSgpIHt9XG5cbiAgICAgIF9vbldvcmQoKSB7fVxuXG4gICAgICBfb25WaXNlbWUoKSB7fVxuXG4gICAgICBfb25Tc21sKCkge31cbiAgICB9O1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVGV4dFRvU3BlZWNoRmVhdHVyZURlcGVuZGVudE1peGluLCB7XG4gICAgICBFVkVOVF9ERVBFTkRFTkNJRVM6IHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAuLi5QYXJlbnRDbGFzcy5FVkVOVF9ERVBFTkRFTkNJRVMsXG4gICAgICAgICAgLi4uVGV4dFRvU3BlZWNoRmVhdHVyZURlcGVuZGVudEludGVyZmFjZS5FVkVOVF9ERVBFTkRFTkNJRVMsXG4gICAgICAgIH0sXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICByZXR1cm4gVGV4dFRvU3BlZWNoRmVhdHVyZURlcGVuZGVudE1peGluO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFRleHRUb1NwZWVjaEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UsIHtcbiAgRVZFTlRfREVQRU5ERU5DSUVTOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIFRleHRUb1NwZWVjaEZlYXR1cmU6IHtcbiAgICAgICAgcGxheTogJ19vblBsYXknLFxuICAgICAgICBwYXVzZTogJ19vblBhdXNlJyxcbiAgICAgICAgcmVzdW1lOiAnX29uUmVzdW1lJyxcbiAgICAgICAgc3RvcDogJ19vblN0b3AnLFxuICAgICAgICBzZW50ZW5jZTogJ19vblNlbnRlbmNlJyxcbiAgICAgICAgd29yZDogJ19vbldvcmQnLFxuICAgICAgICB2aXNlbWU6ICdfb25WaXNlbWUnLFxuICAgICAgICBzc21sOiAnX29uU3NtbCcsXG4gICAgICB9LFxuICAgIH0sXG4gICAgd3JpdGFibGU6IGZhbHNlLFxuICB9LFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IFRleHRUb1NwZWVjaEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2U7XG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxuaW1wb3J0IE1hdGhVdGlscyBmcm9tICcuL01hdGhVdGlscyc7XG5pbXBvcnQge1F1YWRyYXRpY30gZnJvbSAnLi9hbmltcGFjay9FYXNpbmcnO1xuaW1wb3J0IE1hbmFnZWRBbmltYXRpb25MYXllckludGVyZmFjZSBmcm9tICcuL2FuaW1wYWNrL01hbmFnZWRBbmltYXRpb25MYXllckludGVyZmFjZSc7XG5pbXBvcnQgVGV4dFRvU3BlZWNoRmVhdHVyZURlcGVuZGVudEludGVyZmFjZSBmcm9tICcuL2F3c3BhY2svVGV4dFRvU3BlZWNoRmVhdHVyZURlcGVuZGVudEludGVyZmFjZSc7XG5pbXBvcnQgQWJzdHJhY3RIb3N0RmVhdHVyZSBmcm9tICcuL0Fic3RyYWN0SG9zdEZlYXR1cmUnO1xuXG4vKipcbiAqIERlZmF1bHQgbWFwcGluZyBvZiBQb2xseSB2aXNlbWUgbmFtZXMgdG8gYW5pbWF0aW9uIG9wdGlvbnMgb2JqZWN0cy5cbiAqXG4gKiBAcHJvcGVydHkge09iamVjdH0gW3NpbD17bmFtZTogJ3NpbCd9XVxuICogQHByb3BlcnR5IHtPYmplY3R9IFtwPXtuYW1lOiAncCcsIG92ZXJyaWRlV2VpZ2h0OiAwLjl9XVxuICogQHByb3BlcnR5IHtPYmplY3R9IFt0PXtuYW1lOiAndCcsIGJsZW5kVGltZTogMC4yfV1cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbUz17bmFtZTogJ1MnfV1cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbVD17bmFtZTogJ1QnfV1cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbZj17bmFtZTogJ2YnLCBvdmVycmlkZVdlaWdodDogMC43NX1dXG4gKiBAcHJvcGVydHkge09iamVjdH0gW2s9e25hbWU6ICdrJ31dXG4gKiBAcHJvcGVydHkge09iamVjdH0gW2k9e25hbWU6ICdpJ31dXG4gKiBAcHJvcGVydHkge09iamVjdH0gW3I9e25hbWU6ICdyJ31dXG4gKiBAcHJvcGVydHkge09iamVjdH0gW3M9e25hbWU6ICdzJywgYmxlbmRUaW1lOiAwLjI1fV1cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbdT17bmFtZTogJ3UnfV1cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbQD17bmFtZTogJ0AnfV1cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbYT17bmFtZTogJ2EnfV1cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbZT17bmFtZTogJ2UnLCBibGVuZFRpbWU6IDAuMn1dXG4gKiBAcHJvcGVydHkge09iamVjdH0gW0U9e25hbWU6ICdFJ31dXG4gKiBAcHJvcGVydHkge09iamVjdH0gW289e25hbWU6ICdvJ31dXG4gKiBAcHJvcGVydHkge09iamVjdH0gW089e25hbWU6ICdPJ31dXG4gKi9cbmNvbnN0IERlZmF1bHRWaXNlbWVNYXAgPSB7XG4gIHNpbDoge25hbWU6ICdzaWwnfSxcbiAgcDoge25hbWU6ICdwJywgb3ZlcnJpZGVXZWlnaHQ6IDAuOX0sXG4gIHQ6IHtuYW1lOiAndCcsIGJsZW5kVGltZTogMC4yfSxcbiAgUzoge25hbWU6ICdTJ30sXG4gIFQ6IHtuYW1lOiAnVCd9LFxuICBmOiB7bmFtZTogJ2YnLCBvdmVycmlkZVdlaWdodDogMC43NX0sXG4gIGs6IHtuYW1lOiAnayd9LFxuICBpOiB7bmFtZTogJ2knfSxcbiAgcjoge25hbWU6ICdyJ30sXG4gIHM6IHtuYW1lOiAncycsIGJsZW5kVGltZTogMC4yNX0sXG4gIHU6IHtuYW1lOiAndSd9LFxuICAnQCc6IHtuYW1lOiAnQCd9LFxuICBhOiB7bmFtZTogJ2EnfSxcbiAgZToge25hbWU6ICdlJywgYmxlbmRUaW1lOiAwLjJ9LFxuICBFOiB7bmFtZTogJ0UnfSxcbiAgbzoge25hbWU6ICdvJ30sXG4gIE86IHtuYW1lOiAnTyd9LFxufTtcblxuLyoqXG4gKiBMaXBzeW5jIGNvbnRyb2xzIHR3byB0eXBlcyBvZiBtb3ZlbWVudDogaWRsZSBhbmltYXRpb24gdGhhdCBzaG91bGQgcGxheSB3aGlsZVxuICogc3BlZWNoIGlzIHBsYXlpbmcgYW5kIHZpc2VtZSBhbmltYXRpb25zIGNvcnJlc3BvbmRpbmcgdG8gUG9sbHkgdmlzZW1lcyB3aG9zZVxuICogd2VpZ2h0cyBzaG91bGQgYmUgdHVybmVkIG9uIGFuZCBvZmYgYXMgdGhleSBhcmUgZW5jb3VudGVyZWQgaW4gdGhlIFBvbGx5IFNTTUxcbiAqIHRyYW5zY3JpcHQuIExheWVycyBvd25lZCBieSB0aGlzIGZlYXR1cmUgd2lsbCBiZSBlbmFibGVkIHdoaWxlIHNwZWVjaCBpcyBwbGF5aW5nXG4gKiBhbmQgZGlzYWJsZWQgb25jZSBpdCBzdG9wcy5cbiAqXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEhvc3RGZWF0dXJlXG4gKiBAYWxpYXMgY29yZS9MaXBzeW5jRmVhdHVyZVxuICogQGltcGxlbWVudHMgVGV4dFRvU3BlZWNoRmVhdHVyZURlcGVuZGVudEludGVyZmFjZVxuICogQGltcGxlbWVudHMgTWFuYWdlZEFuaW1hdGlvbkxheWVySW50ZXJmYWNlXG4gKi9cbmNsYXNzIExpcHN5bmNGZWF0dXJlIGV4dGVuZHMgQWJzdHJhY3RIb3N0RmVhdHVyZS5taXgoXG4gIFRleHRUb1NwZWVjaEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UuTWl4aW4sXG4gIE1hbmFnZWRBbmltYXRpb25MYXllckludGVyZmFjZS5NaXhpblxuKSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtIHtjb3JlL0hvc3RPYmplY3R9IGhvc3QgLSBIb3N0IHRoYXQgb3ducyB0aGUgZmVhdHVyZS5cbiAgICogQHBhcmFtIHtPYmplY3Q9fSB2aXNlbWVPcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIHZpc2VtZSBsYXllcnMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdmlzZW1lT3B0aW9ucy5ibGVuZFRpbWU9MC4xNV0gLSBEZWZhdWx0IGFtb3VudCBvZiB0aW1lIGl0XG4gICAqIHdpbGwgdGFrZSB0byBtYW5pcHVsYXRlIGVhY2ggZnJlZUJsZW5kIHdlaWdodCBvbiB0aGUgdmlzZW1lIHN0YXRlcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IFt2aXNlbWVPcHRpb25zLmRlY2F5UmF0ZT17YW1vdW50OiAuNSwgc2Vjb25kczogLjV9XSAtIEFuIG9iamVjdFxuICAgKiBkZXNjcmliaW5nIHRoZSAwLTEgZmFjdG9yIHZpc2VtZSB3ZWlnaHQgd2lsbCBkZWNheSBpZiB0aGUgdmlzZW1lIGR1cmF0aW9uIGlzXG4gICAqIGxvbmdlciB0aGFuIHRoZSBibGVuZFRpbWUgYW5kIHRoZSBudW1iZXIgb2Ygc2Vjb25kcyBpdCB3b3VsZCB0YWtlIHRvIGRlY2F5XG4gICAqIGJ5IHRoYXQgZmFjdG9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3Zpc2VtZU9wdGlvbnMuZWFzaW5nRm49UXVhZHJhdGljLkluT3V0XSAtIERlZmF1bHQgZWFzaW5nIGZ1bmN0aW9uXG4gICAqIHRvIHVzZSB3aGVuIG1hbmlwdWxhdGluZyB2aXNlbWUgZnJlZUJsZW5kIHdlaWdodHMuXG4gICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IFt2aXNlbWVPcHRpb25zLi5sYXllcnM9W11dIC0gQW4gYXJyYXkgb2YgbGF5ZXIgb3B0aW9uc1xuICAgKiBvYmplY3RzIHRvIHJlZ2lzdGVyIGFzIHZpc2VtZSBsYXllcnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gdGFsa2luZ09wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgdGFsa2luZyBsYXllcnMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdGFsa2luZ09wdGlvbnMuYmxlbmRUaW1lPTAuNzVdIC0gRGVmYXVsdCBhbW91bnQgb2YgdGltZSB0b1xuICAgKiBlbmFibGUgYW5kIGRpc2FibGUgdGhlIHRhbGtpbmcgaWRsZSBsYXllcnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0YWxraW5nT3B0aW9ucy5lYXNpbmdGbj1RdWFkcmF0aWMuSW5PdXRdIC0gRGVmYXVsdCBlYXNpbmdcbiAgICogZnVuY3Rpb24gdG8gdXNlIHdoZW4gbWFuaXB1bGF0aW5nIHdlaWdodHMgb24gdGhlIHRhbGtpbmcgaWRsZSBsYXllcnMuXG4gICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IFt0YWxraW5nT3B0aW9ucy5sYXllcnM9W11dIC0gQW4gYXJyYXkgb2YgbGF5ZXIgb3B0aW9uc1xuICAgKiBvYmplY3RzIHRvIHJlZ2lzdGVyIGFzIHRhbGtpbmcgbGF5ZXJzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3Zpc2VtZUxlYWRUaW1lPS4wNjddIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRvIGluc3RydWN0IHRoZVxuICAgKiBUZXh0VG9TcGVlY2hGZWF0dXJlIHRvIGVtaXQgc3BlZWNobWFya3MgYmVmb3JlIGVhY2ggb25lJ3MgYWN0dWFsIHRpbWVzdGFtcFxuICAgKiBpcyByZWFjaGVkLiBUaGlzIHdpbGwgc2V0IHRoZSAnc3BlZWNoTWFya09mZnNldCcgdmFyaWFibGUgb24gdGhlIFRleHRUb1NwZWVjaEZlYXR1cmUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBob3N0LFxuICAgIHtcbiAgICAgIGJsZW5kVGltZTogdmlzZW1lQmxlbmRUaW1lID0gMC4xNSxcbiAgICAgIGRlY2F5UmF0ZToge2Ftb3VudCA9IDAuNSwgc2Vjb25kcyA9IDAuNX0gPSB7fSxcbiAgICAgIGVhc2luZ0ZuOiB2aXNlbWVFYXNpbmdGbiA9IFF1YWRyYXRpYy5Jbk91dCxcbiAgICAgIGxheWVyczogdmlzZW1lTGF5ZXJzID0gW10sXG4gICAgfSA9IHt9LFxuICAgIHtcbiAgICAgIGJsZW5kVGltZTogdGFsa2luZ0JsZW5kVGltZSA9IDAuNzUsXG4gICAgICBlYXNpbmdGbjogdGFsa2luZ0Vhc2luZ0ZuID0gUXVhZHJhdGljLkluT3V0LFxuICAgICAgbGF5ZXJzOiB0YWxraW5nTGF5ZXJzID0gW10sXG4gICAgfSA9IHt9LFxuICAgIHZpc2VtZUxlYWRUaW1lID0gMC4wNjdcbiAgKSB7XG4gICAgc3VwZXIoaG9zdCk7XG5cbiAgICB0aGlzLl92aXNlbWVMYXllcnMgPSB7fTtcbiAgICB0aGlzLl90YWxraW5nTGF5ZXJzID0ge307XG4gICAgdGhpcy52aXNlbWVMZWFkVGltZSA9IHZpc2VtZUxlYWRUaW1lO1xuXG4gICAgLy8gUmVnaXN0ZXIgdGhlIHZpc2VtZSBsYXllcnNcbiAgICB2aXNlbWVMYXllcnMuZm9yRWFjaCgoe25hbWUsIGFuaW1hdGlvbiwgdmlzZW1lTWFwID0gRGVmYXVsdFZpc2VtZU1hcH0pID0+IHtcbiAgICAgIHRoaXMucmVnaXN0ZXJWaXNlbWVMYXllcihuYW1lLCB7XG4gICAgICAgIGFuaW1hdGlvbixcbiAgICAgICAgdmlzZW1lTWFwLFxuICAgICAgICBkZWNheVJhdGU6IHthbW91bnQsIHNlY29uZHN9LFxuICAgICAgICBibGVuZFRpbWU6IHZpc2VtZUJsZW5kVGltZSxcbiAgICAgICAgZWFzaW5nRm46IHZpc2VtZUVhc2luZ0ZuLFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBSZWdpc3RlciB0aGUgdGFsa2luZyBsYXllcnNcbiAgICB0YWxraW5nTGF5ZXJzLmZvckVhY2goKHtuYW1lLCBhbmltYXRpb259KSA9PiB7XG4gICAgICB0aGlzLnJlZ2lzdGVyVGFsa2luZ0xheWVyKG5hbWUsIHtcbiAgICAgICAgYW5pbWF0aW9uLFxuICAgICAgICBibGVuZFRpbWU6IHRhbGtpbmdCbGVuZFRpbWUsXG4gICAgICAgIGVhc2luZ0ZuOiB0YWxraW5nRWFzaW5nRm4sXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnN1cmUgdGhhdCByZWdpc3RlcmVkIHZpc2VtZSBhbmltYXRpb25zIGFyZSBGcmVlQmxlbmRTdGF0ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0aGF0IGNvbnRhaW5zIHRoZSB2aXNlbWUgYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYW5pbWF0aW9uTmFtZSAtIE5hbWUgb2YgdGhlIGFuaW1hdGlvbi5cbiAgICovXG4gIF9yZWdpc3RlclZpc2VtZUFuaW1hdGlvbihsYXllck5hbWUsIGFuaW1hdGlvbk5hbWUpIHtcbiAgICBpZiAodGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdLmFuaW1hdGlvbnNbYW5pbWF0aW9uTmFtZV0uaXNBY3RpdmUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlLmdldEFuaW1hdGlvblR5cGUoXG4gICAgICAgICAgbGF5ZXJOYW1lLFxuICAgICAgICAgIGFuaW1hdGlvbk5hbWVcbiAgICAgICAgKSAhPT0gJ2ZyZWVCbGVuZCdcbiAgICAgICkge1xuICAgICAgICAvLyBXYXJuIGFuZCBkZWFjdGl2YXRlIGlmIHRoZSByZWdpc3RlcmVkIHN0YXRlIGlzIG5vdCBmcmVlQmxlbmRcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBDYW5ub3QgcmVnaXN0ZXIgTGlwc3luYyB2aXNlbWUgYW5pbWF0aW9uICR7YW5pbWF0aW9uTmFtZX0gb24gbGF5ZXIgJHtsYXllck5hbWV9IGZvciBob3N0ICR7dGhpcy5faG9zdC5pZH0uIFZpc2VtZSBhbmltYXRpb25zIG11c3QgYmUgb2YgdHlwZSAnZnJlZUJsZW5kJy5gXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXS5hbmltYXRpb25zW1xuICAgICAgICAgIGFuaW1hdGlvbk5hbWVcbiAgICAgICAgXS5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGJsZW5kV2VpZ2h0cyBjYW4gYmUgbWFuaXB1bGF0ZWQgbm93XG4gICAgICAgIGNvbnN0IHdlaWdodE5hbWVzID0gdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlLmdldEFuaW1hdGlvbkJsZW5kTmFtZXMoXG4gICAgICAgICAgbGF5ZXJOYW1lLFxuICAgICAgICAgIGFuaW1hdGlvbk5hbWVcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3Qge3Zpc2VtZU1hcH0gPSB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0uYW5pbWF0aW9uc1tcbiAgICAgICAgICBhbmltYXRpb25OYW1lXG4gICAgICAgIF07XG5cbiAgICAgICAgT2JqZWN0LnZhbHVlcyh2aXNlbWVNYXApLmZvckVhY2godmlzZW1lT3B0aW9ucyA9PiB7XG4gICAgICAgICAgdmlzZW1lT3B0aW9ucy5pc0FjdGl2ZSA9IHdlaWdodE5hbWVzLmluY2x1ZGVzKHZpc2VtZU9wdGlvbnMubmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGUgYWRkZWQgZmVhdHVyZSBpcyBUZXh0VG9TcGVlY2gsIHVwZGF0ZSBpdHMgc3BlZWNoTWFya09mZnNldCB2YXJpYWJsZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVOYW1lIC0gTmFtZSBvZiB0aGUgdHlwZSBvZiBmZWF0dXJlIHRoYXQgd2FzIGFkZGVkLlxuICAgKi9cbiAgX29uRmVhdHVyZUFkZGVkKHR5cGVOYW1lKSB7XG4gICAgdGhpcy5fdmlzZW1lTGF5ZXJzID0gdGhpcy5fdmlzZW1lTGF5ZXJzIHx8IHt9O1xuICAgIHRoaXMuX3RhbGtpbmdMYXllcnMgPSB0aGlzLl90YWxraW5nTGF5ZXJzIHx8IHt9O1xuXG4gICAgc3VwZXIuX29uRmVhdHVyZUFkZGVkKHR5cGVOYW1lKTtcblxuICAgIGlmICh0eXBlTmFtZSA9PT0gJ1RleHRUb1NwZWVjaEZlYXR1cmUnKSB7XG4gICAgICB0aGlzLl9ob3N0LlRleHRUb1NwZWVjaEZlYXR1cmUuc3BlZWNobWFya09mZnNldCA9XG4gICAgICAgIC10aGlzLl92aXNlbWVMZWFkVGltZSB8fCAwO1xuICAgIH1cbiAgfVxuXG4gIF9vbkxheWVyQWRkZWQoe25hbWV9KSB7XG4gICAgc3VwZXIuX29uTGF5ZXJBZGRlZCh7bmFtZX0pO1xuXG4gICAgLy8gVmFsaWRhdGUgdGhlIHZpc2VtZSBhbmltYXRpb25cbiAgICBpZiAodGhpcy5fdmlzZW1lTGF5ZXJzW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3JlZ2lzdGVyVmlzZW1lQW5pbWF0aW9uKG5hbWUsIHRoaXMuX3Zpc2VtZUxheWVyc1tuYW1lXSk7XG4gICAgfVxuICB9XG5cbiAgX29uQW5pbWF0aW9uQWRkZWQoe2xheWVyTmFtZSwgYW5pbWF0aW9uTmFtZX0pIHtcbiAgICBzdXBlci5fb25BbmltYXRpb25BZGRlZCh7bGF5ZXJOYW1lfSk7XG5cbiAgICAvLyBWYWxpZGF0ZSB0aGUgdmlzZW1lIGFuaW1hdGlvblxuICAgIGlmICh0aGlzLl92aXNlbWVMYXllcnNbbGF5ZXJOYW1lXSA9PT0gYW5pbWF0aW9uTmFtZSkge1xuICAgICAgdGhpcy5fcmVnaXN0ZXJWaXNlbWVBbmltYXRpb24obGF5ZXJOYW1lLCB0aGlzLl92aXNlbWVMYXllcnNbbGF5ZXJOYW1lXSk7XG4gICAgfVxuICB9XG5cbiAgX29uUGxheSgpIHtcbiAgICAvLyBUdXJuIG9uIHRoZSBsYXllciB3ZWlnaHRzXG4gICAgdGhpcy5lbmFibGUoKTtcblxuICAgIC8vIFNldCB0aGUgY3VycmVudCBhbmltYXRpb25zXG4gICAgW3RoaXMuX3Zpc2VtZUxheWVycywgdGhpcy5fdGFsa2luZ0xheWVyc10uZm9yRWFjaChsYXllcnMgPT4ge1xuICAgICAgT2JqZWN0LmVudHJpZXMobGF5ZXJzKS5mb3JFYWNoKChbbGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lXSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdLmFuaW1hdGlvbnNbYW5pbWF0aW9uTmFtZV0uaXNBY3RpdmUpIHtcbiAgICAgICAgICB0aGlzLl9ob3N0LkFuaW1hdGlvbkZlYXR1cmUucmVzdW1lQW5pbWF0aW9uKGxheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgX29uUGF1c2UoKSB7XG4gICAgdGhpcy5fb25TdG9wKCk7XG4gIH1cblxuICBfb25SZXN1bWUoKSB7XG4gICAgdGhpcy5fb25QbGF5KCk7XG4gIH1cblxuICBfb25TdG9wKCkge1xuICAgIC8vIFR1cm4gb2ZmIHRoZSBsYXllciB3ZWlnaHRzXG4gICAgdGhpcy5kaXNhYmxlKCk7XG5cbiAgICAvLyBQYXVzZSB0aGUgY3VycmVudCBhbmltYXRpb25zXG4gICAgW3RoaXMuX3Zpc2VtZUxheWVycywgdGhpcy5fdGFsa2luZ0xheWVyc10uZm9yRWFjaChsYXllcnMgPT4ge1xuICAgICAgT2JqZWN0LmVudHJpZXMobGF5ZXJzKS5mb3JFYWNoKChbbGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lXSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdLmFuaW1hdGlvbnNbYW5pbWF0aW9uTmFtZV0uaXNBY3RpdmUpIHtcbiAgICAgICAgICB0aGlzLl9ob3N0LkFuaW1hdGlvbkZlYXR1cmUucGF1c2VBbmltYXRpb24obGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogV2hlbiB2aXNlbWUgZXZlbnRzIGFyZSBjYXVnaHQsIHR1cm4gb24gd2VpZ2h0IG9mIHRoZSBuZXcgdmlzZW1lIGZvciB0aGUgZHVyYXRpb25cbiAgICogb2YgdGhlIHNwZWVjaCBtYXJrLCB0aGVuIHR1cm4gd2VpZ2h0IGJhY2sgb2ZmLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBFdmVudCBkYXRhIHBhc3NlZCBmcm9tIHRoZSBzcGVlY2guXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5tYXJrIC0gU3BlZWNobWFyayBvYmplY3QuXG4gICAqL1xuICBhc3luYyBfb25WaXNlbWUoe21hcmt9KSB7XG4gICAgT2JqZWN0LmVudHJpZXModGhpcy5fdmlzZW1lTGF5ZXJzKS5mb3JFYWNoKChbbGF5ZXJOYW1lLCBhbmltTmFtZV0pID0+IHtcbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgbGF5ZXIgY2FuIGJlIG1hbmlwdWxhdGVkXG4gICAgICBjb25zdCB7aXNBY3RpdmUsIHZpc2VtZU1hcH0gPSB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0uYW5pbWF0aW9uc1tcbiAgICAgICAgYW5pbU5hbWVcbiAgICAgIF07XG5cbiAgICAgIGlmICghaXNBY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBUYWtlIHZhcmlhYmxlcyBmcm9tIHRoZSB2aXNlbWUgaWYgdGhleSBleGlzdCBhbmQgZGVmYXVsdCB0byB0aGUgbGF5ZXJcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmFtZTogdmlzZW1lLFxuICAgICAgICBpc0FjdGl2ZTogaXNWaXNlbWVBY3RpdmUsXG4gICAgICAgIGRlY2F5UmF0ZSxcbiAgICAgICAgYmxlbmRUaW1lLFxuICAgICAgICBlYXNpbmdGbixcbiAgICAgICAgb3ZlcnJpZGVXZWlnaHQsXG4gICAgICB9ID0ge1xuICAgICAgICAuLi50aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0sXG4gICAgICAgIC4uLnZpc2VtZU1hcFttYXJrLnZhbHVlXSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHZpc2VtZU5hbWVzID0gdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlLmdldEFuaW1hdGlvbkJsZW5kTmFtZXMoXG4gICAgICAgIGxheWVyTmFtZSxcbiAgICAgICAgYW5pbU5hbWVcbiAgICAgICk7XG5cbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgbmV3IHZpc2VtZSBoYXMgYW4gYWN0aXZlIGZyZWVCbGVuZCB3ZWlnaHRcbiAgICAgIGlmICghaXNWaXNlbWVBY3RpdmUgfHwgIXZpc2VtZU5hbWVzLmluY2x1ZGVzKHZpc2VtZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBGaW5kIHRoZSBwZWFrIHdlaWdodCBmb3IgdGhlIHZpc2VtZSBhbmQgdGhlIGFtb3VudCBvZiB0aW1lIGl0IHNob3VsZFxuICAgICAgLy8gdGFrZSB0byByZWFjaCBpdFxuICAgICAgbGV0IHdlaWdodCA9IDE7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IG1hcmsuZHVyYXRpb24gLyAxMDAwO1xuICAgICAgaWYgKGR1cmF0aW9uIDwgYmxlbmRUaW1lKSB7XG4gICAgICAgIGNvbnN0IGxlcnBGYWN0b3IgPSBibGVuZFRpbWUgPiAwID8gZHVyYXRpb24gLyBibGVuZFRpbWUgOiAxO1xuICAgICAgICB3ZWlnaHQgPVxuICAgICAgICAgIG92ZXJyaWRlV2VpZ2h0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gb3ZlcnJpZGVXZWlnaHRcbiAgICAgICAgICAgIDogTWF0aFV0aWxzLmxlcnAoMCwgMSwgbGVycEZhY3Rvcik7XG4gICAgICB9XG4gICAgICBjb25zdCBibGVuZEluVGltZSA9IE1hdGgubWluKGR1cmF0aW9uLCBibGVuZFRpbWUpO1xuXG4gICAgICAvLyBGaW5kIHRoZSBhbW91bnQgYW5kIHRpbWUgdmlzZW1lIHdpbGwgYmUgaGVsZCBmb3JcbiAgICAgIGNvbnN0IGhvbGRUaW1lID0gZHVyYXRpb24gLSBibGVuZFRpbWU7XG5cbiAgICAgIGlmIChob2xkVGltZSA8IDApIHtcbiAgICAgICAgLy8gUGVyZm9ybSBpbiAtPiBvdXQgYW5pbWF0aW9uXG4gICAgICAgIHRoaXMuX2FuaW1hdGVTaW1wbGVWaXNlbWUoXG4gICAgICAgICAgbGF5ZXJOYW1lLFxuICAgICAgICAgIGFuaW1OYW1lLFxuICAgICAgICAgIHZpc2VtZSxcbiAgICAgICAgICB3ZWlnaHQsXG4gICAgICAgICAgYmxlbmRJblRpbWUsXG4gICAgICAgICAgYmxlbmRUaW1lLFxuICAgICAgICAgIGVhc2luZ0ZuXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBsZXJwRmFjdG9yID1cbiAgICAgICAgICBkZWNheVJhdGUuc2Vjb25kcyA+IDAgPyBob2xkVGltZSAvIGRlY2F5UmF0ZS5zZWNvbmRzIDogMTtcbiAgICAgICAgLy8gUGVyZm9ybSBpbiAtPiBob2xkIC0+IG91dCBhbmltYXRpb25cbiAgICAgICAgY29uc3QgZGVjYXlXZWlnaHQgPSBNYXRoVXRpbHMubGVycChcbiAgICAgICAgICB3ZWlnaHQsXG4gICAgICAgICAgd2VpZ2h0ICogZGVjYXlSYXRlLmFtb3VudCxcbiAgICAgICAgICBNYXRoLm1pbigxLCBsZXJwRmFjdG9yKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9hbmltYXRlSGVsZFZpc2VtZShcbiAgICAgICAgICBsYXllck5hbWUsXG4gICAgICAgICAgYW5pbU5hbWUsXG4gICAgICAgICAgdmlzZW1lLFxuICAgICAgICAgIHdlaWdodCxcbiAgICAgICAgICBkZWNheVdlaWdodCxcbiAgICAgICAgICBibGVuZEluVGltZSxcbiAgICAgICAgICBob2xkVGltZSxcbiAgICAgICAgICBibGVuZFRpbWUsXG4gICAgICAgICAgZWFzaW5nRm5cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbmltYXRlIGEgdmlzZW1lIGJsZW5kIHdlaWdodCB0b3dhcmRzIGEgdmFsdWUgYW5kIHRoZW4gYmFjayB0byB6ZXJvLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCBjb250YWlucyB0aGUgdmlzZW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYW5pbU5hbWUgLSBOYW1lIG9mIHRoZSBmcmVlYmxlbmQgYW5pbWF0aW9uIHRoYXQgY29udGFpbnNcbiAgICogdGhlIHZpc2VtZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpc2VtZU5hbWUgLSBOYW1lIG9mIHRoZSBibGVuZCB3ZWlnaHQgdG8gbWFuaXB1bGF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHdlaWdodCAtIFBlYWsgd2VpZ2h0IHRvIGFuaW1hdGUgdG93YXJkcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGJsZW5kSW5UaW1lIC0gQW1vdW50IG9mIHRpbWUgaXQgc2hvdWxkIHRha2UgdG8gcmVhY2ggdGhlXG4gICAqIHBlYWsgd2VpZ2h0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gYmxlbmRPdXRUaW1lIC0gQW1vdW50IG9mIHRpbWUgaXQgc2hvdWxkIHRha2UgdG8gYW5pbWF0ZSBiYWNrXG4gICAqIHRvIHplcm8gYWZ0ZXIgcmVhY2hpbmcgdGhlIHBlYWsgd2VpZ2h0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYXNpbmdGbiAtIEVhc2luZyBmdW5jdGlvbiB0byB1c2UgZHVyaW5nIGFuaW1hdGlvbi5cbiAgICovXG4gIF9hbmltYXRlU2ltcGxlVmlzZW1lKFxuICAgIGxheWVyTmFtZSxcbiAgICBhbmltTmFtZSxcbiAgICB2aXNlbWVOYW1lLFxuICAgIHBlYWtXZWlnaHQsXG4gICAgYmxlbmRJblRpbWUsXG4gICAgYmxlbmRPdXRUaW1lLFxuICAgIGVhc2luZ0ZuXG4gICkge1xuICAgIC8vIEFuaW1hdGUgdG93YXJkcyB0aGUgcGVhayB2YWx1ZVxuICAgIGNvbnN0IHdlaWdodFByb21pc2UgPSB0aGlzLl9ob3N0LkFuaW1hdGlvbkZlYXR1cmUuc2V0QW5pbWF0aW9uQmxlbmRXZWlnaHQoXG4gICAgICBsYXllck5hbWUsXG4gICAgICBhbmltTmFtZSxcbiAgICAgIHZpc2VtZU5hbWUsXG4gICAgICBwZWFrV2VpZ2h0LFxuICAgICAgYmxlbmRJblRpbWUsXG4gICAgICBlYXNpbmdGblxuICAgICk7XG5cbiAgICAvLyBBbmltYXRlIGJhY2sgdG8gemVybyBpZiB0aGVyZSB3YXMgbm8gd2VpZ2h0IGludGVycnVwdGlvblxuICAgIHdlaWdodFByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICBpZiAoIXdlaWdodFByb21pc2UuY2FuY2VsZWQpIHtcbiAgICAgICAgdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlLnNldEFuaW1hdGlvbkJsZW5kV2VpZ2h0KFxuICAgICAgICAgIGxheWVyTmFtZSxcbiAgICAgICAgICBhbmltTmFtZSxcbiAgICAgICAgICB2aXNlbWVOYW1lLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgYmxlbmRPdXRUaW1lLFxuICAgICAgICAgIGVhc2luZ0ZuXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQW5pbWF0ZSBhIHZpc2VtZSBibGVuZCB3ZWlnaHQgdG93YXJkcyBhIHZhbHVlIGFuZCB0aGVuIGJhY2sgdG8gemVyby5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRoYXQgY29udGFpbnMgdGhlIHZpc2VtZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFuaW1OYW1lIC0gTmFtZSBvZiB0aGUgZnJlZWJsZW5kIGFuaW1hdGlvbiB0aGF0IGNvbnRhaW5zXG4gICAqIHRoZSB2aXNlbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2aXNlbWVOYW1lIC0gTmFtZSBvZiB0aGUgYmxlbmQgd2VpZ2h0IHRvIG1hbmlwdWxhdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwZWFrV2VpZ2h0IC0gUGVhayB3ZWlnaHQgdG8gYW5pbWF0ZSB0b3dhcmRzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVjYXlXZWlnaHQgLSBXZWlnaHQgdG8gYW5pbWF0ZSB0b3dhcmRzIGFmdGVyIHJlYWNoaW5nIHRoZVxuICAgKiBwZWFrIHdlaWdodC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGJsZW5kSW5UaW1lIC0gQW1vdW50IG9mIHRpbWUgaXQgc2hvdWxkIHRha2UgdG8gcmVhY2ggdGhlXG4gICAqIHBlYWsgd2VpZ2h0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaG9sZFRpbWUgLSBBbW91bnQgb2YgdGltZSBpdCBzaG91bGQgdGFrZSB0byByZWFjaCB0aGUgZGVjYXlcbiAgICogd2VpZ2h0IGFmdGVyIHRoZSBwZWFrIHdlaWdodCBoYXMgYmVlbiByZWFjaGVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gYmxlbmRPdXRUaW1lIC0gQW1vdW50IG9mIHRpbWUgaXQgc2hvdWxkIHRha2UgdG8gYW5pbWF0ZSBiYWNrXG4gICAqIHRvIHplcm8gYWZ0ZXIgcmVhY2hpbmcgdGhlIGRlY2F5IHdlaWdodC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFzaW5nRm4gLSBFYXNpbmcgZnVuY3Rpb24gdG8gdXNlIGR1cmluZyBhbmltYXRpb24uXG4gICAqL1xuICBhc3luYyBfYW5pbWF0ZUhlbGRWaXNlbWUoXG4gICAgbGF5ZXJOYW1lLFxuICAgIGFuaW1OYW1lLFxuICAgIHZpc2VtZU5hbWUsXG4gICAgcGVha1dlaWdodCxcbiAgICBkZWNheVdlaWdodCxcbiAgICBibGVuZEluVGltZSxcbiAgICBob2xkVGltZSxcbiAgICBibGVuZE91dFRpbWUsXG4gICAgZWFzaW5nRm5cbiAgKSB7XG4gICAgLy8gQW5pbWF0ZSB0b3dhcmRzIHRoZSBwZWFrIHZhbHVlXG4gICAgY29uc3Qgc3RhcnRQcm9taXNlID0gdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlLnNldEFuaW1hdGlvbkJsZW5kV2VpZ2h0KFxuICAgICAgbGF5ZXJOYW1lLFxuICAgICAgYW5pbU5hbWUsXG4gICAgICB2aXNlbWVOYW1lLFxuICAgICAgcGVha1dlaWdodCxcbiAgICAgIGJsZW5kSW5UaW1lLFxuICAgICAgZWFzaW5nRm5cbiAgICApO1xuXG4gICAgYXdhaXQgc3RhcnRQcm9taXNlO1xuXG4gICAgaWYgKCFzdGFydFByb21pc2UuY2FuY2VsZWQpIHtcbiAgICAgIC8vIEFuaW1hdGUgdG93YXJkcyB0aGUgZGVjYXkgdmFsdWUgaWYgdGhlcmUgd2FzIG5vIHdlaWdodCBpbnRlcnJ1cHRpb25cbiAgICAgIGNvbnN0IGhvbGRQcm9taXNlID0gdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlLnNldEFuaW1hdGlvbkJsZW5kV2VpZ2h0KFxuICAgICAgICBsYXllck5hbWUsXG4gICAgICAgIGFuaW1OYW1lLFxuICAgICAgICB2aXNlbWVOYW1lLFxuICAgICAgICBkZWNheVdlaWdodCxcbiAgICAgICAgaG9sZFRpbWUsXG4gICAgICAgIGVhc2luZ0ZuXG4gICAgICApO1xuXG4gICAgICBhd2FpdCBob2xkUHJvbWlzZTtcblxuICAgICAgaWYgKCFob2xkUHJvbWlzZS5jYW5jZWxlZCkge1xuICAgICAgICAvLyBBbmltYXRlIGJhY2sgdG8gemVybyBpZiB0aGVyZSB3YXMgbm8gd2VpZ2h0IGludGVycnVwdGlvblxuICAgICAgICB0aGlzLl9ob3N0LkFuaW1hdGlvbkZlYXR1cmUuc2V0QW5pbWF0aW9uQmxlbmRXZWlnaHQoXG4gICAgICAgICAgbGF5ZXJOYW1lLFxuICAgICAgICAgIGFuaW1OYW1lLFxuICAgICAgICAgIHZpc2VtZU5hbWUsXG4gICAgICAgICAgMCxcbiAgICAgICAgICBibGVuZE91dFRpbWUsXG4gICAgICAgICAgZWFzaW5nRm5cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbmQgc2V0cyB0aGUgYW1vdW50IG9mIHRpbWUgaW4gc2Vjb25kcyB0byBuZWdhdGl2ZWx5IG9mZnNldCBzcGVlY2htYXJrXG4gICAqIGVtaXNzaW9uIGJ5LlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHZpc2VtZUxlYWRUaW1lKCkge1xuICAgIHJldHVybiB0aGlzLl92aXNlbWVMZWFkVGltZTtcbiAgfVxuXG4gIHNldCB2aXNlbWVMZWFkVGltZShzZWNvbmRzKSB7XG4gICAgdGhpcy5fdmlzZW1lTGVhZFRpbWUgPSBzZWNvbmRzO1xuXG4gICAgaWYgKHRoaXMuX2hvc3QuVGV4dFRvU3BlZWNoRmVhdHVyZSkge1xuICAgICAgdGhpcy5faG9zdC5UZXh0VG9TcGVlY2hGZWF0dXJlLnNwZWVjaG1hcmtPZmZzZXQgPSAtc2Vjb25kcztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQga2VlcGluZyB0cmFjayBvZiBhbiBhbmltYXRpb24gbGF5ZXIgdGhhdCBvd25zIGEgZnJlZUJsZW5kIGFuaW1hdGlvblxuICAgKiB3aXRoIGJsZW5kV2VpZ2h0cyBjb3JyZXNwb25kaW5nIHRvIHZpc2VtZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0byBrZWVwIHRyYWNrIG9mLlxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgbGF5ZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb249J3Zpc2VtZXMnXSAtIE5hbWUgb2YgdGhlIGFuaW1hdGlvbiBvbiB0aGVcbiAgICogbGF5ZXIgdGhhdCB3aWxsIGJlIHBsYXllZCBkdXJpbmcgc3BlZWNoLiBUaGlzIGFuaW1hdGlvbiBtdXN0IGJlIG9mIHR5cGVcbiAgICogZnJlZUJsZW5kLlxuICAgKiBAcGFyYW0ge09iamVjdD19IGRlY2F5UmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RlY2F5UmF0ZS5hbW91bnQ9MC41XSAtIFRoZSBwZXJjZW50YWdlIHRvIGRlY3JlYXNlIHRoZSB2aXNlbWUnc1xuICAgKiBwZWFrIHZhbHVlIGJ5IG92ZXIgdGltZSBvbmNlIHRoZSBwZWFrIHZhbHVlIGhhcyBiZWVuIHJlYWNoZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVjYXlSYXRlLnNlY29uZHM9MC41XSAtIFRoZSBhbW91bnQgb2YgdGltZSBpbiBzZWNvbmRzIHRvXG4gICAqIGRlY3JlYXNlIHRoZSB2aXNlbWUncyB3ZWlnaHQgb25jZSBpdCBoYXMgcmVhY2hlZCBpdHMgcGVhayB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXI9fSBbb3B0aW9ucy5ibGVuZFRpbWU9W0xpcHN5bmNGZWF0dXJlLkRFRkFVTFRfTEFZRVJfT1BUSU9OUy5ibGVuZFRpbWVde0BsaW5rIExpcHN5bmNGZWF0dXJlI0RFRkFVTFRfTEFZRVJfT1BUSU9OUyNibGVuZFRpbWV9XSAtXG4gICAqIERlZmF1bHQgYW1vdW50IG9mIHRpbWUgdG8gdXNlIHdoZW4gbWFuaXB1bGF0aW5nIGFuaW1hdGlvbiBibGVuZFdlaWdodHMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvcHRpb25zLmVhc2luZ0ZuIC0gRGVmYXVsdCBlYXNpbmcgZnVuY3Rpb24gdG8gdXNlIHdoZW5cbiAgICogbWFuaXB1bGF0aW5nIGFuaW1hdGlvbiBibGVuZFdlaWdodHMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy52aXNlbWVNYXA9RGVmYXVsdFZpc2VtZU1hcF0gLSBPYmplY3QgY29udGFpbmluZyBrZXkvdmFsdWUgcGFpcnMgb2ZcbiAgICogUG9sbHkgdmlzZW1lIG5hbWVzIG1hcHBlZCB0byBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIG5hbWUgb2YgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICogYW5pbWF0aW9uIGJsZW5kV2VpZ2h0IGFuZCBhbnkgb3RoZXIgYW5pbWF0aW9uIG9wdGlvbnMgdG8gdXNlIHN1Y2ggYXMgdmlzZW1lXG4gICAqIHNwZWNpZmljIGJsZW5kIHRpbWVzIGFuZCBlYXNpbmcgZnVuY3Rpb25zLlxuICAgKi9cbiAgcmVnaXN0ZXJWaXNlbWVMYXllcihcbiAgICBsYXllck5hbWUsXG4gICAge1xuICAgICAgYW5pbWF0aW9uID0gJ3Zpc2VtZXMnLFxuICAgICAgZGVjYXlSYXRlID0ge2Ftb3VudDogMC41LCBzZWNvbmRzOiAwLjV9LFxuICAgICAgYmxlbmRUaW1lID0gTGlwc3luY0ZlYXR1cmUuREVGQVVMVF9MQVlFUl9PUFRJT05TLmJsZW5kVGltZSxcbiAgICAgIGVhc2luZ0ZuLFxuICAgICAgdmlzZW1lTWFwID0gRGVmYXVsdFZpc2VtZU1hcCxcbiAgICB9ID0ge31cbiAgKSB7XG4gICAgLy8gUmVnaXN0ZXIgdGhlIGxheWVyIGFuZCBhbmltYXRpb25cbiAgICB0aGlzLnJlZ2lzdGVyTGF5ZXIobGF5ZXJOYW1lLCB7XG4gICAgICBkZWNheVJhdGUsXG4gICAgICBibGVuZFRpbWUsXG4gICAgICBlYXNpbmdGbixcbiAgICAgIGFuaW1hdGlvbnM6IHtbYW5pbWF0aW9uXToge3Zpc2VtZU1hcH19LFxuICAgIH0pO1xuICAgIHRoaXMuX3Zpc2VtZUxheWVyc1tsYXllck5hbWVdID0gYW5pbWF0aW9uO1xuXG4gICAgLy8gVmFsaWRhdGUgdGhlIHZpc2VtZSBhbmltYXRpb25cbiAgICB0aGlzLl9yZWdpc3RlclZpc2VtZUFuaW1hdGlvbihsYXllck5hbWUsIGFuaW1hdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQga2VlcGluZyB0cmFjayBvZiBhbiBhbmltYXRpb24gbGF5ZXIgdGhhdCBjb250YWlucyBhIGxvb3BpbmcgYW5pbWF0aW9uXG4gICAqIHRvIGJlIHBsYXllZCBkdXJpbmcgc3BlZWNoLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdG8ga2VlcCB0cmFjayBvZi5cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGxheWVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uPSdzdGFuZF90YWxrJ10gLSBOYW1lIG9mIHRoZSBhbmltYXRpb24gb24gdGhlXG4gICAqIGxheWVyIHRoYXQgd2lsbCBiZSBwbGF5ZWQgZHVyaW5nIHNwZWVjaC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmJsZW5kVGltZT1bTGlwc3luY0ZlYXR1cmUuREVGQVVMVF9MQVlFUl9PUFRJT05TLmJsZW5kVGltZV17QGxpbmsgTGlwc3luY0ZlYXR1cmUjREVGQVVMVF9MQVlFUl9PUFRJT05TI2JsZW5kVGltZX1dIC1cbiAgICogRGVmYXVsdCBhbW91bnQgb2YgdGltZSB0byB1c2Ugd2hlbiBtYW5pcHVsYXRpbmcgdGhlIGxheWVyJ3Mgd2VpZ2h0cy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9wdGlvbnMuZWFzaW5nRm4gLSBEZWZhdWx0IGVhc2luZyBmdW5jdGlvbiB0byB1c2Ugd2hlblxuICAgKiBtYW5pcHVsYXRpbmcgdGhlIGxheWVyJ3Mgd2VpZ2h0cy5cbiAgICovXG4gIHJlZ2lzdGVyVGFsa2luZ0xheWVyKFxuICAgIGxheWVyTmFtZSxcbiAgICB7XG4gICAgICBhbmltYXRpb24gPSAnc3RhbmRfdGFsaycsXG4gICAgICBibGVuZFRpbWUgPSBMaXBzeW5jRmVhdHVyZS5ERUZBVUxUX0xBWUVSX09QVElPTlMuYmxlbmRUaW1lLFxuICAgICAgZWFzaW5nRm4sXG4gICAgfSA9IHt9XG4gICkge1xuICAgIC8vIFJlZ2lzdGVyIHRoZSBsYXllciBhbmQgYW5pbWF0aW9uXG4gICAgdGhpcy5yZWdpc3RlckxheWVyKGxheWVyTmFtZSwge1xuICAgICAgYmxlbmRUaW1lLFxuICAgICAgZWFzaW5nRm4sXG4gICAgICBhbmltYXRpb25zOiB7W2FuaW1hdGlvbl06IHt9fSxcbiAgICB9KTtcbiAgICB0aGlzLl90YWxraW5nTGF5ZXJzW2xheWVyTmFtZV0gPSBhbmltYXRpb247XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIG5hbWVzcGFjZSB0byB0aGUgaG9zdCB3aXRoIHRoZSBuYW1lIG9mIHRoZSBmZWF0dXJlIHRvIGNvbnRhaW4gcHJvcGVydGllc1xuICAgKiBhbmQgbWV0aG9kcyBmcm9tIHRoZSBmZWF0dXJlIHRoYXQgdXNlcnMgb2YgdGhlIGhvc3QgbmVlZCBhY2Nlc3MgdG8uXG4gICAqXG4gICAqIEBzZWUgTGlwc3luY0ZlYXR1cmVcbiAgICovXG4gIGluc3RhbGxBcGkoKSB7XG4gICAgLyoqXG4gICAgICogQGlubmVyXG4gICAgICogQG5hbWVzcGFjZSBMaXBzeW5jRmVhdHVyZVxuICAgICAqL1xuICAgIGNvbnN0IGFwaSA9IHN1cGVyLmluc3RhbGxBcGkoKTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBMaXBzeW5jRmVhdHVyZVxuICAgICAqIEBuYW1lIHJlZ2lzdGVyTGF5ZXJcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHNlZSBNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2UjcmVnaXN0ZXJMYXllclxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIExpcHN5bmNGZWF0dXJlXG4gICAgICogQG5hbWUgcmVnaXN0ZXJBbmltYXRpb25cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHNlZSBNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2UjcmVnaXN0ZXJBbmltYXRpb25cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBMaXBzeW5jRmVhdHVyZVxuICAgICAqIEBuYW1lIHNldExheWVyV2VpZ2h0c1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAc2VlIE1hbmFnZWRBbmltYXRpb25MYXllckludGVyZmFjZSNzZXRMYXllcldlaWdodHNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBMaXBzeW5jRmVhdHVyZVxuICAgICAqIEBuYW1lIGVuYWJsZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAc2VlIE1hbmFnZWRBbmltYXRpb25MYXllckludGVyZmFjZSNlbmFibGVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBMaXBzeW5jRmVhdHVyZVxuICAgICAqIEBuYW1lIGRpc2FibGVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHNlZSBNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2UjZGlzYWJsZVxuICAgICAqL1xuXG4gICAgT2JqZWN0LmFzc2lnbihhcGksIHtcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlcm9mIExpcHN5bmNGZWF0dXJlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEBtZXRob2RcbiAgICAgICAqIEBzZWUgY29yZS9MaXBzeW5jRmVhdHVyZSNyZWdpc3RlclZpc2VtZUxheWVyXG4gICAgICAgKi9cbiAgICAgIHJlZ2lzdGVyVmlzZW1lTGF5ZXI6IHRoaXMucmVnaXN0ZXJWaXNlbWVMYXllci5iaW5kKHRoaXMpLFxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgTGlwc3luY0ZlYXR1cmVcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQG1ldGhvZFxuICAgICAgICogQHNlZSBjb3JlL0xpcHN5bmNGZWF0dXJlI3JlZ2lzdGVyVGFsa2luZ0xheWVyXG4gICAgICAgKi9cbiAgICAgIHJlZ2lzdGVyVGFsa2luZ0xheWVyOiB0aGlzLnJlZ2lzdGVyVGFsa2luZ0xheWVyLmJpbmQodGhpcyksXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgTGlwc3luY0ZlYXR1cmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbmFtZSB2aXNlbWVMZWFkVGltZVxuICAgICAqIEBzZWUgY29yZS9MaXBzeW5jRmVhdHVyZSN2aXNlbWVMZWFkVGltZVxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcGksICd2aXNlbWVMZWFkVGltZScsIHtcbiAgICAgIGdldDogKCkgPT4gdGhpcy52aXNlbWVMZWFkVGltZSxcbiAgICAgIHNldDogc2Vjb25kcyA9PiB7XG4gICAgICAgIHRoaXMudmlzZW1lTGVhZFRpbWUgPSBzZWNvbmRzO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIHJldHVybiBhcGk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTGlwc3luY0ZlYXR1cmU7XG5leHBvcnQge0RlZmF1bHRWaXNlbWVNYXB9O1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1jbGFzc2VzLXBlci1maWxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1lbXB0eSAqL1xuaW1wb3J0IFRleHRUb1NwZWVjaEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UgZnJvbSAnY29yZS9hd3NwYWNrL1RleHRUb1NwZWVjaEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UnO1xuXG4vKipcbiAqIENsYXNzIGZhY3RvcnkgaW50ZXJmYWNlIGZvciB0aGF0IHJlZ2lzdGVycyBjYWxsYmFjayBtZXRob2Qgd2hlbiBhIHNzbWwgc3BlZWNobWFyayBldmVudCBpcyBlbWl0dGVkLlxuICpcbiAqIEBpbnRlcmZhY2VcbiAqIEBleHRlbmRzIFRleHRUb1NwZWVjaEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2VcbiAqL1xuY2xhc3MgU1NNTFNwZWVjaG1hcmtJbnRlcmZhY2UgZXh0ZW5kcyBUZXh0VG9TcGVlY2hGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlIHtcbiAgLyoqXG4gICAqIFdoZW4gc3NtbCBldmVudHMgYXJlIGNhdWdodCwgdGhpcyB3aWxsIHRyeSB0byBwYXJzZSB0aGUgc3BlZWNoIG1hcmsgdmFsdWUgYW5kIGV4ZWN1dGUgYW55IGZ1bmN0aW9uIHdoaWNoIG1lZXRzIGNyaXRlcmlhIGRlZmluZWQgaW4gdGhlIHZhbHVlLlxuICAgKiBTcGVlY2ggbWFyayB2YWx1ZSB3aWxsIGJlIHRyZWF0ZWQgYXMgc3RyaW5naWZpZWQganNvbiBmb3JtYXQgY29udGFpbmluZyByZXF1aXJlZCBmZWF0dXJlIG5hbWUsIGZ1bmN0aW9uIG5hbWUgYW5kIGFyZ3VtZW50IGFycmF5IHRvIHBhc3MgaW4uXG4gICAqIEV4YW1wbGUgc3BlZWNoIG1hcmsgdmFsdWUgbWlnaHQgbG9vayBsaWtlOiAne1wiZmVhdHVyZVwiOlwiR2VzdHVyZUZlYXR1cmVcIiwgXCJtZXRob2RcIjpcInN3aXRjaFRvR2VzdHVyZVwiLCBcImFyZ3NcIjpbXCJnZW5yaWNBXCIsIDAuNV19J1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBFdmVudCBkYXRhIHBhc3NlZCBmcm9tIHRoZSBzcGVlY2guXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5tYXJrIC0gU3BlZWNobWFyayBvYmplY3QuXG4gICAqL1xuICBfb25Tc21sKHttYXJrfSkge31cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNsYXNzIHRoYXQgaW1wbGVtZW50cyB7QGxpbmsgU1NNTFNwZWVjaG1hcmtJbnRlcmZhY2V9XG4gICAqIGFuZCBleHRlbmRzIGEgc3BlY2lmaWVkIGJhc2UgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2xhc3N9IEJhc2VDbGFzcyAtIFRoZSBjbGFzcyB0byBleHRlbmQuXG4gICAqXG4gICAqIEByZXR1cm4ge0NsYXNzfSBBIGNsYXNzIHRoYXQgZXh0ZW5kcyBgQmFzZUNsYXNzYCBhbmQgaW1wbGVtZW50cyB7QGxpbmsgU1NNTFNwZWVjaG1hcmtJbnRlcmZhY2V9LlxuICAgKi9cbiAgc3RhdGljIE1peGluKEJhc2VDbGFzcykge1xuICAgIGNvbnN0IFBhcmVudENsYXNzID0gVGV4dFRvU3BlZWNoRmVhdHVyZURlcGVuZGVudEludGVyZmFjZS5NaXhpbihCYXNlQ2xhc3MpO1xuICAgIGNvbnN0IFNTTUxTcGVlY2hNYXJrTWl4aW4gPSBjbGFzcyBleHRlbmRzIFBhcmVudENsYXNzIHtcbiAgICAgIF9vblNzbWwoe21hcmt9KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qge2ZlYXR1cmUsIG1ldGhvZCwgYXJnc30gPSBKU09OLnBhcnNlKG1hcmsudmFsdWUpO1xuICAgICAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLm5hbWUgPT09IGZlYXR1cmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpc1ttZXRob2RdO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrICYmIHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICBgRnVuY3Rpb24gJHttZXRob2R9IGRvZXMgbm90IGV4aXN0IHdpdGhpbiBmZWF0dXJlICR7ZmVhdHVyZX1gXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gU1NNTFNwZWVjaE1hcmtNaXhpbjtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTU01MU3BlZWNobWFya0ludGVyZmFjZTtcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXG5pbXBvcnQgTWFuYWdlZEFuaW1hdGlvbkxheWVySW50ZXJmYWNlIGZyb20gJy4vYW5pbXBhY2svTWFuYWdlZEFuaW1hdGlvbkxheWVySW50ZXJmYWNlJztcbmltcG9ydCBTU01MU3BlZWNobWFya0ludGVyZmFjZSBmcm9tICcuL2F3c3BhY2svU1NNTFNwZWVjaG1hcmtJbnRlcmZhY2UnO1xuaW1wb3J0IEFic3RyYWN0SG9zdEZlYXR1cmUgZnJvbSAnLi9BYnN0cmFjdEhvc3RGZWF0dXJlJztcbmltcG9ydCBEZWZlcnJlZCBmcm9tICcuL0RlZmVycmVkJztcbmltcG9ydCBVdGlscyBmcm9tICcuL1V0aWxzJztcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqL1xuY29uc3QgRGVmYXVsdEdlc3R1cmVXb3JkcyA9IHtcbiAgYmlnOiBbXG4gICAgJ2FkZCcsXG4gICAgJ2Fib3ZlJyxcbiAgICAnYXV0aG9yaXR5JyxcbiAgICAnYmlnJyxcbiAgICAnY292ZXInLFxuICAgICdmdWxsJyxcbiAgICAnZmx5JyxcbiAgICAnZ3JvdycsXG4gICAgJ2dyb3d0aCcsXG4gICAgJ2hpZ2gnLFxuICAgICdodWdlJyxcbiAgICAnaW5jcmVhc2UnLFxuICAgICdtYWpvcicsXG4gICAgJ21ham9yaXR5JyxcbiAgICAnbGFyZ2UnLFxuICAgICdsZWFkZXInLFxuICAgICdsb3QnLFxuICAgICdyYWlzZScsXG4gICAgJ3Jpc2UnLFxuICAgICd0YWxsJyxcbiAgXSxcbiAgaGVhcnQ6IFtcbiAgICAnYWNjZXB0JyxcbiAgICAnYWRtaXQnLFxuICAgICdiZWxpZXZlJyxcbiAgICAnY2FyZScsXG4gICAgJ2ZlZWxpbmcnLFxuICAgICdmZWVsJyxcbiAgICAnZnJpZW5kJyxcbiAgICAnZ3JhdGVmdWwnLFxuICAgICdoYXBweScsXG4gICAgJ2hlYXJ0JyxcbiAgICAnaHVtYW4nLFxuICAgICdwYWluJyxcbiAgICAnc2F2ZScsXG4gICAgJ3NhZmUnLFxuICAgICdraW5kJyxcbiAgICAnbG92ZScsXG4gIF0sXG4gIGluOiBbXG4gICAgJ2luY2x1ZGUnLFxuICAgICdpbmNsdWRpbmcnLFxuICAgICdpbnNpZGUnLFxuICAgICdpbnRvJyxcbiAgICAnbm93JyxcbiAgICAnbmVhcicsXG4gICAgJ25lYXJlc3QnLFxuICAgICdjbG9zZXN0JyxcbiAgICAndGhlcmVpbicsXG4gICAgJ3dpdGhpbicsXG4gIF0sXG4gIG1hbnk6IFtcbiAgICAnYWxsJyxcbiAgICAnYWx3YXlzJyxcbiAgICAnYW55JyxcbiAgICAnYW55b25lJyxcbiAgICAnYW1vbmcnLFxuICAgICdhcmVhJyxcbiAgICAnYXJvdW5kJyxcbiAgICAnYmVhdXRpZnVsJyxcbiAgICAnZW50aXJlJyxcbiAgICAnZW52aXJvbm1lbnQnLFxuICAgICdlbnZpcm9ubWVudHMnLFxuICAgICdlbnZpcm9ubWVudGFsJyxcbiAgICAnZXZlcnlib2R5JyxcbiAgICAnZXZlcnlvbmUnLFxuICAgICdldmVyeXRoaW5nJyxcbiAgICAnYXVkaWVuY2UnLFxuICAgICd0b3RhbCcsXG4gICAgJ2dyb3VwJyxcbiAgICAnZ3JvdXBzJyxcbiAgICAnbWlsbGlvbicsXG4gICAgJ21pbGxpb25zJyxcbiAgICAnb3RoZXJzJyxcbiAgICAnYmlsbGlvbicsXG4gICAgJ2JpbGxpb25zJyxcbiAgICAnaHVuZHJlZCcsXG4gICAgJ2h1bmRyZWRzJyxcbiAgICAnbWFueScsXG4gICAgJ3Rob3VzYW5kJyxcbiAgICAndGhvdXNhbmRzJyxcbiAgICAnd29ybGQnLFxuICAgICd3b3JsZHMnLFxuICAgICdvdXRzaWRlJyxcbiAgICAncmV2ZWFsJyxcbiAgXSxcbiAgbW92ZW1lbnQ6IFtcbiAgICAnYXdheScsXG4gICAgJ2Fjcm9zcycsXG4gICAgJ2FoZWFkJyxcbiAgICAnYWxvbmcnLFxuICAgICdmYXInLFxuICAgICdmYXN0JyxcbiAgICAnZm9sbG93JyxcbiAgICAnZ28nLFxuICAgICdsZWF2ZScsXG4gICAgJ21vdmUnLFxuICAgICdtb3ZlbWVudCcsXG4gICAgJ3Rocm91Z2gnLFxuICAgICd0aHJvdWdob3V0JyxcbiAgICAndG93YXJkJyxcbiAgICAndHJhdmVsJyxcbiAgICAndHVybmVkJyxcbiAgICAncGFzc2VkJyxcbiAgXSxcbiAgb25lOiBbXG4gICAgJ3NpbmdsZScsXG4gICAgJ29uZScsXG4gICAgJ29uY2UnLFxuICAgICdmaXJzdCcsXG4gICAgJ2ZpcnN0bHknLFxuICAgICdvbmx5JyxcbiAgICAnc29sbycsXG4gICAgJ3dhcm5lZCcsXG4gICAgJ3RydWx5JyxcbiAgICAndXAnLFxuICAgICdhbG9uZScsXG4gIF0sXG4gIGFnZ3Jlc3NpdmU6IFtcbiAgICAncG93ZXInLFxuICAgICdwb3dlcnMnLFxuICAgICdwb3dlcmZ1bCcsXG4gICAgJ2Fzc2VydCcsXG4gICAgJ2Fzc2VydGl2ZScsXG4gICAgJ3N0cm9uZycsXG4gICAgJ3N0cm9uZ2VyJyxcbiAgICAnc3Ryb25nZXN0JyxcbiAgICAnc3RyZW5ndGgnLFxuICAgICdmbGV4JyxcbiAgICAnZGFuZycsXG4gICAgJ2RhbW4nLFxuICAgICdkYW1uaXQnLFxuICAgICdkYXJuJyxcbiAgICAnc2h1Y2tzJyxcbiAgICAnZG9oJyxcbiAgICAnZHJhdCcsXG4gICAgJ2FuZ3J5JyxcbiAgICAnYW5ncmllcicsXG4gICAgJ2FuZ3JpZXN0JyxcbiAgICAnYWdncmVzc2l2ZScsXG4gICAgJ2Fubm95ZWQnLFxuICAgICdhbm5veWluZycsXG4gICAgJ2F0dGFjaycsXG4gICAgJ2F0dGFja2luZycsXG4gICAgJ29mZmVuc2UnLFxuICAgICdvZmZlbnNpdmUnLFxuICAgICdiYXR0bGUnLFxuICBdLFxuICB5b3U6IFsneW91JywgJ3lhbGwnLCBcInknYWxsXCIsICd5b3VyJywgJ3lvdXJzJywgJ3Rob3UnLCAndGh5J10sXG4gIGRlZmVuc2U6IFtcbiAgICAnZGVmZW5zZScsXG4gICAgJ2ZlYXInLFxuICAgICdyZXB1bHNlZCcsXG4gICAgJ3NjYXJlZCcsXG4gICAgJ3NjYXJ5JyxcbiAgICAnc2NhcmllcicsXG4gICAgJ3NjYXJpZXN0JyxcbiAgICAnZmVhcmZ1bCcsXG4gICAgJ2FmcmFpZCcsXG4gICAgJ2Nvd2VyJyxcbiAgICAnY293ZXJzJyxcbiAgICAnY293ZXJpbmcnLFxuICAgICdoaWRlb3VzJyxcbiAgICAnZG9vbWVkJyxcbiAgICAndGVycmlmaWVkJyxcbiAgICAndGVycmlmeScsXG4gICAgJ3RlcnJpZnlpbmcnLFxuICAgICd0ZXJyaWZpZXMnLFxuICAgICdzcG9va3knLFxuICAgICdzcG9va2llcicsXG4gICAgJ3Nwb29raWVzdCcsXG4gIF0sXG4gIHdhdmU6IFtcbiAgICAnaGVsbG8nLFxuICAgICdoaScsXG4gICAgJ2hpeWEnLFxuICAgICdob3dkeScsXG4gICAgJ3dlbGNvbWUnLFxuICAgICdhbG9oYScsXG4gICAgJ2hleWEnLFxuICAgICdoZXknLFxuICAgICdieWUnLFxuICAgICdnb29kYnllJyxcbiAgICAnaG9sYScsXG4gICAgJ2FkaW9zJyxcbiAgICAnY2hhbycsXG4gIF0sXG4gIHNlbGY6IFsnbXknLCAnSScsICdteXNlbGYnLCAnc2VsZicsIFwiSSd2ZVwiLCAnSXZlJywgJ21lJywgJ21pbmUnLCAnb3duJ10sXG59O1xuXG4vKipcbiAqIEdlc3R1cmUgYWxsb3dzIHlvdSB0byBwbGF5IGFuaW1hdGlvbnMgb24gZGVtYW5kIG9uIG9uZSBvciBtb3JlIGxheWVycyBmcm9tIHNjcmlwdFxuICogb3Igc3NtbC4gSWYgZ2VzdHVyZSBpcyBwbGF5ZWQgdGhhdCBpcyBhIFF1ZXVlU3RhdGUsIHRoZSBxdWV1ZSB3aWxsIGF1dG9tYXRpY2FsbHlcbiAqIGJlIHByb2dyZXNzZWQgYWZ0ZXIgYSBnaXZlbiBob2xkIHRpbWUgaWYgYSBsb29waW5nIHF1ZXVlZCBzdGF0ZSBpcyByZWFjaGVkLiBHZXN0dXJlXG4gKiBsYXllcnMgY2FuIG9wdGlvbmFsbHkgYmUgYXV0b21hdGljYWxseSBkaXNhYmxlZCB3aGVuIG5vIGdlc3R1cmUgYW5pbWF0aW9uIGlzXG4gKiBpbiBwcm9ncmVzcy5cbiAqXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEhvc3RGZWF0dXJlXG4gKiBAaW1wbGVtZW50cyBTU01MU3BlZWNobWFya0ludGVyZmFjZVxuICogQGltcGxlbWVudHMgTWFuYWdlZEFuaW1hdGlvbkxheWVySW50ZXJmYWNlXG4gKi9cbmNsYXNzIEdlc3R1cmVGZWF0dXJlIGV4dGVuZHMgQWJzdHJhY3RIb3N0RmVhdHVyZS5taXgoXG4gIFNTTUxTcGVlY2htYXJrSW50ZXJmYWNlLk1peGluLFxuICBNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2UuTWl4aW5cbikge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7Y29yZS9Ib3N0T2JqZWN0fSBob3N0IC0gSG9zdCBvYmplY3QgdGhhdCBvd25zIHRoZSBmZWF0dXJlLlxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgLSBPcHRpb25hbCBvcHRpb25zIGZvciB0aGUgZmVhdHVyZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmhvbGRUaW1lID0gM10gLSBBbW91bnQgb2YgdGltZSBpbiBzZWNvbmRzIHRoYXQgbXVzdFxuICAgKiBlbGFwc2UgYmVmb3JlIGFkdmFuY2luZyBhIGdlc3R1cmUgdGhhdCdzIGEge0BsaW5rIFF1ZXVlU3RhdGV9IHdoZW4gdGhlIGN1cnJlbnRcbiAgICogc3RhdGUgaW4gdGhlIHF1ZXVlIGlzIHNldCB0byBsb29wIGluZmluaXRlbHkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5taW5pbXVtSW50ZXJ2YWwgPSAwLjI1XSAtIFRoZSBtaW5pbXVtIGFtb3VudCBvZiB0aW1lXG4gICAqIGluIHNlY29uZHMgdGhhdCBtdXN0IGVsYXBzZSBiZWZvcmUgYW5vdGhlciBnZXN0dXJlIGNhbiBiZSBwbGF5ZWQuXG4gICAqIEBwYXJhbSAge09iamVjdH0gbGF5ZXJzIC0gQW4gb2JqZWN0IHRoYXQgbWFwcyBsYXllciBuYW1lcyB0byBsYXllciBvcHRpb25zLlxuICAgKiBUaGVzZSBhcmUgdGhlIGxheWVycyB0aGF0IHdpbGwgYmUgcmVnaXN0ZXJlZCBhcyB0cmFja2VkIGdlc3R1cmUgbGF5ZXJzLiBTZWVcbiAgICoge0BsaW5rIE1hbmFnZWRBbmltYXRpb25MYXllckludGVyZmFjZSNyZWdpc3RlckxheWVyfSBmb3IgbW9yZSBpbmZvcm1hdGlvblxuICAgKiBvbiBleHBlY3RlZCBmb3JtYXQgZm9yIGVhY2ggbGF5ZXIgb3B0aW9ucyBvYmplY3QuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihob3N0LCB7aG9sZFRpbWUgPSAzLCBtaW5pbXVtSW50ZXJ2YWwgPSAxLCBsYXllcnMgPSB7fX0gPSB7fSkge1xuICAgIHN1cGVyKGhvc3QpO1xuXG4gICAgdGhpcy5ob2xkVGltZSA9IGhvbGRUaW1lO1xuICAgIHRoaXMubWluaW11bUludGVydmFsID0gbWluaW11bUludGVydmFsO1xuXG4gICAgLy8gUmVnaXN0ZXIgdGhlIGdlc3R1cmUgbGF5ZXJzXG4gICAgT2JqZWN0LmVudHJpZXMobGF5ZXJzKS5mb3JFYWNoKChbbmFtZSwgb3B0aW9ucyA9IHt9XSkgPT4ge1xuICAgICAgdGhpcy5yZWdpc3RlckxheWVyKG5hbWUsIG9wdGlvbnMpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIHZhbGlkIGhvbGQgdGltZSB2YWx1ZS4gSWYgaG9sZCB0aW1lIGlzbid0IGRlZmluZWQgZm9yIHRoZSBhbmltYXRpb24sXG4gICAqIHRyeSB0byB1c2UgdGhlIGhvbGQgdGltZSBmb3IgdGhlIGxheWVyLiBJZiB0aGF0J3Mgbm90IGRlZmluZWQsIGZhbGwgYmFjayB0b1xuICAgKiB0aGUgaG9sZCB0aW1lIGZvciB0aGUgZmVhdHVyZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGxheWVyIC0gTWFuYWdlZCBsYXllciBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGFuaW1hdGlvbiAtIE1hbmFnZWQgYW5pbWF0aW9uIG9wdGlvbnMgb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgX2dldEhvbGRUaW1lKGxheWVyLCBhbmltYXRpb24pIHtcbiAgICBjb25zdCBsYXllckhvbGRUaW1lID1cbiAgICAgIGxheWVyLmhvbGRUaW1lICE9PSB1bmRlZmluZWQgPyBsYXllci5ob2xkVGltZSA6IHRoaXMuaG9sZFRpbWU7XG5cbiAgICByZXR1cm4gYW5pbWF0aW9uLmhvbGRUaW1lICE9PSB1bmRlZmluZWRcbiAgICAgID8gYW5pbWF0aW9uLmhvbGRUaW1lXG4gICAgICA6IGxheWVySG9sZFRpbWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgdmFsaWQgbWluaW11bSBpbnRlcnZhbCB2YWx1ZS4gSWYgbWluaW11bSBpbnRlcnZhbCBpc24ndCBkZWZpbmVkIGZvclxuICAgKiB0aGUgYW5pbWF0aW9uLCB0cnkgdG8gdXNlIHRoZSBtaW5pbXVtIGludGVydmFsIGZvciB0aGUgbGF5ZXIuIElmIHRoYXQncyBub3RcbiAgICogZGVmaW5lZCwgZmFsbCBiYWNrIHRvIHRoZSBtaW5pbXVtIGludGVydmFsIGZvciB0aGUgZmVhdHVyZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGxheWVyIC0gTWFuYWdlZCBsYXllciBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGFuaW1hdGlvbiAtIE1hbmFnZWQgYW5pbWF0aW9uIG9wdGlvbnMgb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgX2dldE1pbmltdW1JbnRlcnZhbChsYXllciwgYW5pbWF0aW9uKSB7XG4gICAgY29uc3QgbGF5ZXJNaW5pbXVtSW50ZXJ2YWwgPVxuICAgICAgbGF5ZXIubWluaW11bUludGVydmFsICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBsYXllci5taW5pbXVtSW50ZXJ2YWxcbiAgICAgICAgOiB0aGlzLm1pbmltdW1JbnRlcnZhbDtcblxuICAgIHJldHVybiBhbmltYXRpb24ubWluaW11bUludGVydmFsICE9PSB1bmRlZmluZWRcbiAgICAgID8gYW5pbWF0aW9uLm1pbmltdW1JbnRlcnZhbFxuICAgICAgOiBsYXllck1pbmltdW1JbnRlcnZhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmb3Ige0BsaW5rIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNwbGF5TmV4dEFuaW1hdGlvbn0gZXZlbnQuIElmIHRoZVxuICAgKiBldmVudCBpcyBlbWl0dGVkIGZvciBhIG1hbmFnZWQgYW5pbWF0aW9uIGFuZCB0aGUgbmV3IHF1ZXVlZCBzdGF0ZSBjYW5ub3RcbiAgICogYWR2YW5jZSBvbiBpdHMgb3duLCBzdGFydCBhIG5ldyB0aW1lciBwcm9taXNlIHRoYXQgd2lsbCBhZHZhbmNlIHRoZSBxdWV1ZVxuICAgKiBvbmNlIGl0IHJlc29sdmVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgb2JqZWN0IHBhc3NlZCBmcm9tIHBsYXlOZXh0QW5pbWF0aW9uIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCBvd25zIHRoZSBxdWV1ZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFuaW1hdGlvbk5hbWUgLSBOYW1lIG9mIHRoZSBxdWV1ZSBzdGF0ZSBhbmltYXRpb24uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2FuQWR2YW5jZSAtIFdoZXRoZXIgb3Igbm90IHRoZSBjdXJyZW50IHN0YXRlIGluIHRoZSBxdWV1ZVxuICAgKiBjYW4gYWR2YW5jZSBvbiBpdHMgb3duLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzUXVldWVFbmQgLSBXaGV0aGVyIHRoZSBjdXJyZW50IHN0YXRlIGluIHRoZSBxdWV1ZSBpcyB0aGUgbGFzdFxuICAgKiBzdGF0ZSBpbiB0aGUgcXVldWUuXG4gICAqL1xuICBfb25OZXh0KHtsYXllck5hbWUsIGFuaW1hdGlvbk5hbWUsIGNhbkFkdmFuY2UsIGlzUXVldWVFbmR9KSB7XG4gICAgLy8gRXhpdCBpZiB0aGlzIGlzbid0IGEgbWFuYWdlZCBsYXllclxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdO1xuICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRXhpdCBpZiBpdCBpc24ndCBhIG1hbmFnZWQgYW5pbWF0aW9uXG4gICAgY29uc3QgYW5pbWF0aW9uID0gbGF5ZXIuYW5pbWF0aW9uc1thbmltYXRpb25OYW1lXTtcbiAgICBpZiAoYW5pbWF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTdGFydCBhIG5ldyB0aW1lciBmb3IgbG9vcGluZyBzdGF0ZXMgdGhhdCBhcmVuJ3QgdGhlIGVuZCBvZiB0aGUgcXVldWVcbiAgICBpZiAoIWNhbkFkdmFuY2UgJiYgIWlzUXVldWVFbmQgJiYgbGF5ZXIuY3VycmVudEdlc3R1cmUgPT09IGFuaW1hdGlvbk5hbWUpIHtcbiAgICAgIGNvbnN0IGhvbGRUaW1lID0gdGhpcy5fZ2V0SG9sZFRpbWUobGF5ZXIsIGFuaW1hdGlvbik7XG4gICAgICBsYXllci5ob2xkVGltZXIuY2FuY2VsKCk7XG5cbiAgICAgIC8vIFNraXAgdG8gdGhlIG5leHQgYW5pbWF0aW9uIHJpZ2h0IGF3YXkgaWYgaG9sZCB0aW1lIGlzIHplcm9cbiAgICAgIGlmIChob2xkVGltZSA8PSAwKSB7XG4gICAgICAgIHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5wbGF5TmV4dEFuaW1hdGlvbihsYXllck5hbWUsIGFuaW1hdGlvbk5hbWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBXYWl0IGZvciB0aGUgZ2l2ZW4gaG9sZCB0aW1lIGJlZm9yZSBwcm9ncmVzc2luZ1xuICAgICAgZWxzZSB7XG4gICAgICAgIGxheWVyLmhvbGRUaW1lciA9IFV0aWxzLndhaXQoaG9sZFRpbWUsIHtcbiAgICAgICAgICBvbkZpbmlzaDogKCkgPT4ge1xuICAgICAgICAgICAgLy8gQWR2YW5jZSB0aGUgcXVldWUgdG8gdGhlIG5leHQgc3RhdGVcbiAgICAgICAgICAgIGlmIChsYXllci5jdXJyZW50R2VzdHVyZSA9PT0gYW5pbWF0aW9uTmFtZSkge1xuICAgICAgICAgICAgICB0aGlzLl9ob3N0LkFuaW1hdGlvbkZlYXR1cmUucGxheU5leHRBbmltYXRpb24oXG4gICAgICAgICAgICAgICAgbGF5ZXJOYW1lLFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbk5hbWVcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgZm9yIHtAbGluayBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjc3RvcEFuaW1hdGlvbn0gZXZlbnQuIElmIHRoZVxuICAgKiBldmVudCBpcyBlbWl0dGVkIGZvciBhIG1hbmFnZWQgYW5pbWF0aW9uIGNhbmNlbCB0aGUgbGF5ZXIncyBzdG9yZWQgdGltZXJzLlxuICAgKiBJZiB0aGUgbGF5ZXIgaXMgc2V0IHRvIGF1dG8tZGlzYWJsZSBzZXQgaXRzIHdlaWdodCB0byAwLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgb2JqZWN0IHBhc3NlZCBmcm9tIHBsYXlOZXh0QW5pbWF0aW9uIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCBvd25zIHRoZSBzdG9wcGVkIGFuaW1hdGlvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFuaW1hdGlvbk5hbWUgLSBOYW1lIG9mIHRoZSBhbmltYXRpb24gdGhhdCB3YXMgc3RvcHBlZC5cbiAgICovXG4gIF9vblN0b3Aoe2xheWVyTmFtZSwgYW5pbWF0aW9uTmFtZX0pIHtcbiAgICAvLyBNYWtlIHN1cmUgdGhlIGxheWVyIGlzIG1hbmFnZWRcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXTtcbiAgICBpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgYW5pbWF0aW9uIGlzIG1hbmFnZWRcbiAgICBjb25zdCBhbmltYXRpb24gPSBsYXllci5hbmltYXRpb25zW2FuaW1hdGlvbk5hbWVdO1xuICAgIGlmIChhbmltYXRpb24gIT09IHVuZGVmaW5lZCAmJiBhbmltYXRpb25OYW1lID09PSBsYXllci5jdXJyZW50R2VzdHVyZSkge1xuICAgICAgbGF5ZXIuY3VycmVudEdlc3R1cmUgPSBudWxsO1xuICAgICAgbGF5ZXIucGxheVRpbWVyID0gbnVsbDtcbiAgICAgIGxheWVyLmhvbGRUaW1lci5jYW5jZWwoKTtcblxuICAgICAgLy8gVHVybiBvZmYgbGF5ZXIgd2VpZ2h0XG4gICAgICBpZiAobGF5ZXIuYXV0b0Rpc2FibGUpIHtcbiAgICAgICAgdGhpcy5zZXRMYXllcldlaWdodHMobmFtZSA9PiBuYW1lID09PSBsYXllck5hbWUsIDApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9vbkFuaW1hdGlvbkFkZGVkKHtsYXllck5hbWUsIGFuaW1hdGlvbk5hbWV9KSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV07XG5cbiAgICBpZiAobGF5ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgYW5pbWF0aW9uID0gbGF5ZXIuYW5pbWF0aW9uc1thbmltYXRpb25OYW1lXTtcblxuICAgICAgLy8gUmVnaXN0ZXIgdGhlIGFuaW1hdGlvbiBhcyBhY3RpdmUgaWYgaXQgaXMgdW5tYW5hZ2VkXG4gICAgICBpZiAoYW5pbWF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlckFuaW1hdGlvbihsYXllck5hbWUsIGFuaW1hdGlvbk5hbWUpO1xuICAgICAgfVxuICAgICAgLy8gTWFyayB0aGUgYW5pbWF0aW9uIGFzIGFjdGl2ZSBpZiBpdCBpcyBtYW5hZ2VkXG4gICAgICBlbHNlIHtcbiAgICAgICAgYW5pbWF0aW9uLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZWdpc3RlckxheWVyKG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyLnJlZ2lzdGVyTGF5ZXIobmFtZSwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhvbGRUaW1lcjogRGVmZXJyZWQucmVzb2x2ZSgpLFxuICAgICAgcGxheVRpbWVyOiBudWxsLFxuICAgICAgY3VycmVudEdlc3R1cmU6IG51bGwsXG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5fbWFuYWdlZExheWVyc1tuYW1lXS5pc0FjdGl2ZSkge1xuICAgICAgdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlLmdldEFuaW1hdGlvbnMobmFtZSkuZm9yRWFjaChhbmltID0+IHtcbiAgICAgICAgLy8gQXV0b21hdGljYWxseSByZWdpc3RlciBhbGwgYW5pbWF0aW9ucyBvbiB0aGUgbGF5ZXJcbiAgICAgICAgaWYgKHRoaXMuX21hbmFnZWRMYXllcnNbbmFtZV0uYW5pbWF0aW9uc1thbmltXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5yZWdpc3RlckFuaW1hdGlvbihcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBhbmltLFxuICAgICAgICAgICAgdGhpcy5fbWFuYWdlZExheWVyc1tuYW1lXS5hbmltYXRpb25zW2FuaW1dXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmVnaXN0ZXJBbmltYXRpb24obGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICAvLyBUcnkgdG8gZmFsbCBiYWNrIHRvIGEgZGVmYXVsdCB3b3JkIGFycmF5XG4gICAgaWYgKCEob3B0aW9ucy53b3JkcyBpbnN0YW5jZW9mIEFycmF5KSAmJiAhKG9wdGlvbnMud29yZHMgaW5zdGFuY2VvZiBTZXQpKSB7XG4gICAgICBvcHRpb25zLndvcmRzID0gRGVmYXVsdEdlc3R1cmVXb3Jkc1thbmltYXRpb25OYW1lXSB8fCBbXTtcbiAgICB9XG5cbiAgICBzdXBlci5yZWdpc3RlckFuaW1hdGlvbihsYXllck5hbWUsIGFuaW1hdGlvbk5hbWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBvYmplY3QgdGhhdCBtYXBzIHNzbWwgbWFyayBzeW50YXggcmVxdWlyZWQgdG8gcGxheSBlYWNoIGdlc3R1cmUgdG9cbiAgICogdGhlIHdvcmRzIGFycmF5IGFzc29jaWF0ZWQgd2l0aCBlYWNoIGdlc3R1cmUuIFdvcmRzIGFycmF5cyBhcmUgZGVmaW5lZCBhdCB3aGVuXG4gICAqIHRoZSBnZXN0dXJlIGFuaW1hdGlvbiBpcyByZWdpc3RlcmVkLiBHZXN0dXJlcyB3aXRob3V0IGFzc29jaWF0ZWQgd29yZHMgd2lsbFxuICAgKiBiZSBleGNsdWRlZCBmcm9tIHRoZSByZXN1bHQuIFRoZSByZXN1bHRpbmcgb2JqZWN0IGNhbiBiZSB1c2VkIGFzIGFuIGlucHV0XG4gICAqIGZvciB7QGxpbmsgVGV4dFRvU3BlZWNoVXRpbHMuYXV0b0dlbmVyYXRlU1NNTE1hcmtzfSB0byB1cGRhdGUgYSBzcGVlY2ggc3RyaW5nXG4gICAqIHdpdGggdGhlIG1hcmt1cCByZXF1aXJlZCB0byBwbGF5IGdlc3R1cmVzIHRpbWVkIHdpdGggdGhlaXIgYXNzb2NpYXRlZCB3b3Jkcy5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIGNyZWF0ZUdlc3R1cmVNYXAoKSB7XG4gICAgY29uc3QgZ2VzdHVyZU1hcCA9IHt9O1xuXG4gICAgT2JqZWN0LmVudHJpZXModGhpcy5fbWFuYWdlZExheWVycykuZm9yRWFjaCgoW2xheWVyTmFtZSwge2FuaW1hdGlvbnN9XSkgPT4ge1xuICAgICAgT2JqZWN0LmVudHJpZXMoYW5pbWF0aW9ucykuZm9yRWFjaChcbiAgICAgICAgKFtcbiAgICAgICAgICBhbmltYXRpb25OYW1lLFxuICAgICAgICAgIHtob2xkVGltZSwgbWluaW11bUludGVydmFsLCB3b3JkcywgdHJhbnNpdGlvblRpbWV9LFxuICAgICAgICBdKSA9PiB7XG4gICAgICAgICAgLy8gT25seSBzdG9yZSBnZXN0dXJlcyB0aGF0IGhhdmUgYW55IGFzc29jaWF0ZWQgd29yZHNcbiAgICAgICAgICBpZiAod29yZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAuLi4oaG9sZFRpbWUgJiYge2hvbGRUaW1lfSksXG4gICAgICAgICAgICAgIC4uLihtaW5pbXVtSW50ZXJ2YWwgJiYge21pbmltdW1JbnRlcnZhbH0pLFxuICAgICAgICAgICAgICAuLi4odHJhbnNpdGlvblRpbWUgJiYge3RyYW5zaXRpb25UaW1lfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qga2V5ID0ge1xuICAgICAgICAgICAgICBmZWF0dXJlOiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUsXG4gICAgICAgICAgICAgIG1ldGhvZDogJ3BsYXlHZXN0dXJlJyxcbiAgICAgICAgICAgICAgYXJnczogW2xheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSwgb3B0aW9uc10sXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBnZXN0dXJlTWFwW0pTT04uc3RyaW5naWZ5KGtleSldID0gd29yZHM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGdlc3R1cmVNYXA7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgc3NtbCBtYXJrIHN5bnRheCByZXF1aXJlZCB0byBwbGF5IGVhY2ggZ2VzdHVyZVxuICAgKiB0aGF0IGRvZXMgbm90IGhhdmUgYW55IGFzc29jaWF0ZWQgd29yZHMuIFRoZSByZXN1bHRpbmcgYXJyYXkgY2FuIGJlIHVzZWQgYXNcbiAgICogYW4gaW5wdXQgZm9yIHtAbGluayBUZXh0VG9TcGVlY2hVdGlscy5hdXRvR2VuZXJhdGVTU01MTWFya3N9IG9yXG4gICAqIHtAbGluayBUZXh0VG9TcGVlY2hVdGlscy5hZGRNYXJrc1RvVW5tYXJrZWRTZW50ZW5jZXN9IHRvIHVwZGF0ZSBhIHNwZWVjaFxuICAgKiBzdHJpbmcgd2l0aCB0aGUgbWFya3VwIHJlcXVpcmVkIHRvIHBsYXkgcmFuZG9tIGdlc3R1cmVzIGF0IGVhY2ggdW5tYXJrZWRcbiAgICogc2VudGVuY2UgaW4gdGhlIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPj19IGxheWVycyAtIEFuIGFycmF5IG9mIG5hbWVzIG9mIG1hbmFnZWQgbGF5ZXJzIHRvIGdlbmVyYXRlXG4gICAqIG1hcmtzIGZvci4gSWYgdW5kZWZpbmVkLCB1c2UgYWxsIG1hbmFnZWQgbGF5ZXJzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZz59XG4gICAqL1xuICBjcmVhdGVHZW5lcmljR2VzdHVyZUFycmF5KGxheWVycykge1xuICAgIGNvbnN0IGdlbmVyaWNHZXN0dXJlcyA9IFtdO1xuICAgIGxheWVycyA9IGxheWVycyB8fCBPYmplY3Qua2V5cyh0aGlzLl9tYW5hZ2VkTGF5ZXJzKTtcblxuICAgIGxheWVycy5mb3JFYWNoKGxheWVyTmFtZSA9PiB7XG4gICAgICBjb25zdCBsYXllciA9IHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXTtcblxuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBsYXllciBpcyBtYW5hZ2VkXG4gICAgICBpZiAoIWxheWVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmVudHJpZXMobGF5ZXIuYW5pbWF0aW9ucykuZm9yRWFjaChcbiAgICAgICAgKFtcbiAgICAgICAgICBhbmltYXRpb25OYW1lLFxuICAgICAgICAgIHtob2xkVGltZSwgbWluaW11bUludGVydmFsLCB3b3JkcywgdHJhbnNpdGlvblRpbWV9LFxuICAgICAgICBdKSA9PiB7XG4gICAgICAgICAgLy8gT25seSBzdG9yZSBnZXN0dXJlcyB0aGF0IGRvbid0IGhhdmUgYW55IGFzc29jaWF0ZWQgd29yZHNcbiAgICAgICAgICBpZiAoIXdvcmRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgLi4uKGhvbGRUaW1lICYmIHtob2xkVGltZX0pLFxuICAgICAgICAgICAgICAuLi4obWluaW11bUludGVydmFsICYmIHttaW5pbXVtSW50ZXJ2YWx9KSxcbiAgICAgICAgICAgICAgLi4uKHRyYW5zaXRpb25UaW1lICYmIHt0cmFuc2l0aW9uVGltZX0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgZmVhdHVyZTogdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLFxuICAgICAgICAgICAgICBtZXRob2Q6ICdwbGF5R2VzdHVyZScsXG4gICAgICAgICAgICAgIGFyZ3M6IFtsYXllck5hbWUsIGFuaW1hdGlvbk5hbWUsIG9wdGlvbnNdLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghZ2VuZXJpY0dlc3R1cmVzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgZ2VuZXJpY0dlc3R1cmVzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZ2VuZXJpY0dlc3R1cmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFBsYXkgYSBtYW5hZ2VkIGdlc3R1cmUgYW5pbWF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGxheWVyIHRoYXQgY29udGFpbnMgdGhlIGdlc3R1cmVcbiAgICogYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYW5pbWF0aW9uTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBnZXN0dXJlIGFuaW1hdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIC0gT3B0aW9uYWwgZ2VzdHVyZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge251bWJlcj19IG9wdGlvbnMuaG9sZFRpbWUgLSBUaGlzIG9wdGlvbiBvbmx5IGFwcGxpZXMgdG8ge0BsaW5rIFF1ZXVlU3RhdGV9XG4gICAqIGdlc3R1cmVzLiBXaGVuIGEgUXVldWVTdGF0ZSBnZXN0dXJlIHByb2dyZXNzZXMgdG8gYSBsb29waW5nIHN0YXRlLCB0aGlzIG9wdGlvblxuICAgKiBkZWZpbmVzIGhvdyBtYW55IHNlY29uZHMgc2hvdWxkIGVsYXBzZSBiZWZvcmUgbW92aW5nIHRoZSBxdWV1ZSBmb3J3YXJkLiBJZlxuICAgKiB1bmRlZmluZWQsIGl0IHdpbGwgZmFsbCBiYWNrIGZpcnN0IHRvIHRoZSBob2xkVGltZSBkZWZpbmVkIGluIHRoZSBvcHRpb25zIHdoZW5cbiAgICogdGhlIGdlc3R1cmUgYW5pbWF0aW9uIHdhcyByZWdpc3RlcmVkIGFuZCB0aGVuIHRvIHRoZSBob2xkVGltZSBkZWZpbmVkIG9uIHRoZVxuICAgKiBmZWF0dXJlLlxuICAgKiBAcGFyYW0ge251bWJlcj19IG9wdGlvbnMubWluaW11bUludGVydmFsIC0gVGhlIG1pbmltdW0gYW1vdW50IG9mIHRpbWUgdGhhdFxuICAgKiBtdXN0IGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIGEgZ2VzdHVyZSB3YXMgcGxheWVkLlxuICAgKi9cbiAgcGxheUdlc3R1cmUoXG4gICAgbGF5ZXJOYW1lLFxuICAgIGFuaW1hdGlvbk5hbWUsXG4gICAge2hvbGRUaW1lLCBtaW5pbXVtSW50ZXJ2YWwsIHRyYW5zaXRpb25UaW1lLCBmb3JjZSA9IGZhbHNlfSA9IHt9XG4gICkge1xuICAgIC8vIE1ha2Ugc3VyZSB0aGUgYW5pbWF0aW9uIGlzIHJlZ2lzdGVyZWRcbiAgICBpZiAoXG4gICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0gPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdLmFuaW1hdGlvbnNbYW5pbWF0aW9uTmFtZV0gPT09IHVuZGVmaW5lZFxuICAgICkge1xuICAgICAgdGhpcy5yZWdpc3RlckFuaW1hdGlvbihsYXllck5hbWUsIGFuaW1hdGlvbk5hbWUsIHtcbiAgICAgICAgaG9sZFRpbWUsXG4gICAgICAgIG1pbmltdW1JbnRlcnZhbCxcbiAgICAgICAgdHJhbnNpdGlvblRpbWUsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBsYXllciA9IHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXTtcbiAgICBjb25zdCBhbmltYXRpb24gPSBsYXllci5hbmltYXRpb25zW2FuaW1hdGlvbk5hbWVdO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBhbmltYXRpb24gaXMgYWN0aXZlXG4gICAgaWYgKCFhbmltYXRpb24uaXNBY3RpdmUpIHtcbiAgICAgIC8vIENyZWF0ZSB3YXJuaW5nIG1lc3NhZ2UgYmFzZWQgb24gd2hpY2ggb2JqZWN0IGRvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBjb25zdCB0eXBlTmFtZSA9IGxheWVyLmlzQWN0aXZlID8gJ2FuaW1hdGlvbicgOiAnbGF5ZXInO1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBTa2lwcGluZyBnZXN0dXJlICR7YW5pbWF0aW9uTmFtZX0gb24gbGF5ZXIgJHtsYXllck5hbWV9IGZvciBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5vICR7dHlwZU5hbWV9IGV4aXN0cyB3aXRoIHRoaXMgbmFtZSB5ZXQuYDtcblxuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgICAgcmV0dXJuIERlZmVycmVkLmNhbmNlbCh7cmVhc29uOiAnaW5hY3RpdmUnLCB2YWx1ZTogdHlwZU5hbWV9KTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgZ2VzdHVyZSBpcyBhbHJlYWR5IHBsYXlpbmdcbiAgICBjb25zdCB7Y3VycmVudEdlc3R1cmV9ID0gbGF5ZXI7XG4gICAgaWYgKGN1cnJlbnRHZXN0dXJlID09PSBhbmltYXRpb25OYW1lICYmICFmb3JjZSkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBTa2lwcGluZyBnZXN0dXJlICR7YW5pbWF0aW9uTmFtZX0gb24gbGF5ZXIgJHtsYXllck5hbWV9IGZvciBob3N0ICR7dGhpcy5faG9zdC5pZH0uIFRoZSBnZXN0dXJlIGlzIGFscmVhZHkgcGxheWluZy4gVXNlIG9wdGlvbnMuZm9yY2UgdG8gZm9yY2UgdGhlIGdlc3R1cmUgcmVwbGF5LCB3aGljaCBtYXkgcmVzdWx0IGluIGEgaGFyZCB0cmFuc2l0aW9uLmA7XG5cbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICAgIHJldHVybiBEZWZlcnJlZC5jYW5jZWwoe3JlYXNvbjogJ3BsYXlpbmcnLCB2YWx1ZTogYW5pbWF0aW9uTmFtZX0pO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBhbmltYXRpb24gb3B0aW9uc1xuICAgIGlmIChob2xkVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhbmltYXRpb24uaG9sZFRpbWUgPSBob2xkVGltZTtcbiAgICB9XG5cbiAgICBpZiAobWluaW11bUludGVydmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGFuaW1hdGlvbi5taW5pbXVtSW50ZXJ2YWwgPSBtaW5pbXVtSW50ZXJ2YWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pbmltdW1JbnRlcnZhbCA9IHRoaXMuX2dldE1pbmltdW1JbnRlcnZhbChsYXllciwgYW5pbWF0aW9uKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayB0aGUgaW50ZXJ2YWxcbiAgICBpZiAoXG4gICAgICAhZm9yY2UgJiZcbiAgICAgIGxheWVyLnBsYXlUaW1lciAhPT0gbnVsbCAmJlxuICAgICAgbGF5ZXIucGxheVRpbWVyIDwgbWluaW11bUludGVydmFsXG4gICAgKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBTa2lwcGluZyBnZXN0dXJlICR7YW5pbWF0aW9uTmFtZX0gb24gbGF5ZXIgJHtsYXllck5hbWV9IGZvciBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE1pbmltdW0gaW50ZXJ2YWwgJHttaW5pbXVtSW50ZXJ2YWx9IGhhcyBub3QgYmVlbiBtZXQuYFxuICAgICAgKTtcbiAgICAgIHJldHVybiBEZWZlcnJlZC5jYW5jZWwoe1xuICAgICAgICByZWFzb246ICdtaW5pbXVtSW50ZXJ2YWwnLFxuICAgICAgICB2YWx1ZTogbWluaW11bUludGVydmFsIC0gbGF5ZXIucGxheVRpbWVyLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gUGxheSB0aGUgYW5pbWF0aW9uXG4gICAgbGF5ZXIuY3VycmVudEdlc3R1cmUgPSBhbmltYXRpb25OYW1lO1xuICAgIGxheWVyLnBsYXlUaW1lciA9IDA7XG4gICAgbGF5ZXIuaG9sZFRpbWVyLmNhbmNlbCgpO1xuICAgIGlmIChsYXllci5hdXRvRGlzYWJsZSkge1xuICAgICAgdGhpcy5zZXRMYXllcldlaWdodHMobmFtZSA9PiBuYW1lID09PSBsYXllck5hbWUsIDEpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9ob3N0LkFuaW1hdGlvbkZlYXR1cmUucGxheUFuaW1hdGlvbihcbiAgICAgIGxheWVyTmFtZSxcbiAgICAgIGFuaW1hdGlvbk5hbWUsXG4gICAgICB0cmFuc2l0aW9uVGltZVxuICAgICk7XG4gIH1cblxuICB1cGRhdGUoZGVsdGFUaW1lKSB7XG4gICAgc3VwZXIudXBkYXRlKGRlbHRhVGltZSk7XG5cbiAgICAvLyBJbmNyZW1lbnQgdGhlIHRpbWVyc1xuICAgIE9iamVjdC5lbnRyaWVzKHRoaXMuX21hbmFnZWRMYXllcnMpLmZvckVhY2goKFtuYW1lLCBvcHRpb25zXSkgPT4ge1xuICAgICAgaWYgKG9wdGlvbnMuaXNBY3RpdmUgJiYgIXRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5nZXRQYXVzZWQobmFtZSkpIHtcbiAgICAgICAgb3B0aW9ucy5ob2xkVGltZXIuZXhlY3V0ZShkZWx0YVRpbWUpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnBsYXlUaW1lciAhPT0gbnVsbCkge1xuICAgICAgICAgIG9wdGlvbnMucGxheVRpbWVyICs9IGRlbHRhVGltZSAvIDEwMDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGluc3RhbGxBcGkoKSB7XG4gICAgLyoqXG4gICAgICogQGlubmVyXG4gICAgICogQG5hbWVzcGFjZSBHZXN0dXJlRmVhdHVyZVxuICAgICAqL1xuICAgIGNvbnN0IGFwaSA9IHN1cGVyLmluc3RhbGxBcGkoKTtcblxuICAgIE9iamVjdC5hc3NpZ24oYXBpLCB7XG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBHZXN0dXJlRmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAc2VlIEdlc3R1cmVGZWF0dXJlI2NyZWF0ZUdlc3R1cmVNYXBcbiAgICAgICAqL1xuICAgICAgY3JlYXRlR2VzdHVyZU1hcDogdGhpcy5jcmVhdGVHZXN0dXJlTWFwLmJpbmQodGhpcyksXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBHZXN0dXJlRmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAc2VlIEdlc3R1cmVGZWF0dXJlI2NyZWF0ZUdlbmVyaWNHZXN0dXJlQXJyYXlcbiAgICAgICAqL1xuICAgICAgY3JlYXRlR2VuZXJpY0dlc3R1cmVBcnJheTogdGhpcy5jcmVhdGVHZW5lcmljR2VzdHVyZUFycmF5LmJpbmQodGhpcyksXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBHZXN0dXJlRmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAc2VlIEdlc3R1cmVGZWF0dXJlI3BsYXlHZXN0dXJlXG4gICAgICAgKi9cbiAgICAgIHBsYXlHZXN0dXJlOiB0aGlzLnBsYXlHZXN0dXJlLmJpbmQodGhpcyksXG4gICAgfSk7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoR2VzdHVyZUZlYXR1cmUsIHtcbiAgREVGQVVMVF9MQVlFUl9PUFRJT05TOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIC4uLkdlc3R1cmVGZWF0dXJlLkRFRkFVTFRfTEFZRVJfT1BUSU9OUyxcbiAgICAgIGF1dG9EaXNhYmxlOiB0cnVlLFxuICAgIH0sXG4gICAgd3JpdGFibGU6IGZhbHNlLFxuICB9LFxuICBFVkVOVF9ERVBFTkRFTkNJRVM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgLi4uR2VzdHVyZUZlYXR1cmUuRVZFTlRfREVQRU5ERU5DSUVTLFxuICAgICAgQW5pbWF0aW9uRmVhdHVyZToge1xuICAgICAgICAuLi5HZXN0dXJlRmVhdHVyZS5FVkVOVF9ERVBFTkRFTkNJRVMuQW5pbWF0aW9uRmVhdHVyZSxcbiAgICAgICAgcGxheU5leHRBbmltYXRpb246ICdfb25OZXh0JyxcbiAgICAgICAgc3RvcEFuaW1hdGlvbjogJ19vblN0b3AnLFxuICAgICAgICBpbnRlcnJ1cHRBbmltYXRpb246ICdfb25TdG9wJyxcbiAgICAgIH0sXG4gICAgfSxcbiAgfSxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBHZXN0dXJlRmVhdHVyZTtcbmV4cG9ydCB7RGVmYXVsdEdlc3R1cmVXb3Jkc307XG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxuaW1wb3J0IERlZmVycmVkIGZyb20gJ2NvcmUvRGVmZXJyZWQnO1xuaW1wb3J0IFV0aWxzIGZyb20gJ2NvcmUvVXRpbHMnO1xuaW1wb3J0IE1hdGhVdGlscyBmcm9tICdjb3JlL01hdGhVdGlscyc7XG5pbXBvcnQge0xpbmVhcn0gZnJvbSAnLi9FYXNpbmcnO1xuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiB1c2VmdWwgYW5pbWF0aW9uIGZ1bmN0aW9ucy5cbiAqXG4gKiBAaGlkZWNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIEFuaW1hdGlvblV0aWxzIHtcbiAgc3RhdGljIGxlcnAoZnJvbSwgdG8sIGZhY3Rvcikge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGBBbmltYXRpb25VdGlscy5sZXJwIGlzIGJlaW5nIGRlcHJlY2F0ZWQuIFVzZSBNYXRoVXRpbHMubGVycCBpbnN0ZWFkLmBcbiAgICApO1xuXG4gICAgcmV0dXJuIE1hdGhVdGlscy5sZXJwKGZyb20sIHRvLCBmYWN0b3IpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsYW1wIGEgbnVtYmVyIGJldHdlZW4gMiB2YWx1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFZhbHVlIHRvIGNsYW1wLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW21pbj0wXSAtIE1pbnVtdW0gdmFsdWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4PTFdIC0gTWF4aW11bSB2YWx1ZS5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIHN0YXRpYyBjbGFtcCh2YWx1ZSwgbWluID0gMCwgbWF4ID0gMSkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGBBbmltYXRpb25VdGlscy5jbGFtcCBpcyBiZWluZyBkZXByZWNhdGVkLiBVc2UgTWF0aFV0aWxzLmNsYW1wIGluc3RlYWQuYFxuICAgICk7XG5cbiAgICByZXR1cm4gTWF0aFV0aWxzLmNsYW1wKHZhbHVlLCBtaW4sIG1heCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgZGVmZXJyZWQgcHJvbWlzZSB0aGF0IGNhbiBiZSB1c2VkIHRvIHVwZGF0ZSB0aGUgdmFsdWUgb2YgYSBudW1lcmljXG4gICAqIHByb3BlcnR5IG9mIHRoaXMgb2JqZWN0IG92ZXIgdGltZS4gUGFzcyBkZWx0YSB0aW1lIGluIG1pbGxpc2Vjb25kcyB0byB0aGVcbiAgICogZGVmZXJyZWQgcHJvbWlzZSdzIGV4ZWN1dGUgbWV0aG9kIGluIGFuIHVwZGF0ZSBsb29wIHRvIGFuaW1hdGUgdGhlIHByb3BlcnR5XG4gICAqIHRvd2FyZHMgdGhlIHRhcmdldCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnR5T3duZXIgLSBPYmplY3QgdGhhdCBjb250YWlucyB0aGUgcHJvcGVydHkgdG8gYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lIC0gTmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gYW5pbWF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldFZhbHVlIC0gVGFyZ2V0IHZhbHVlIHRvIHJlYWNoLlxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgLSBPcHRpb25hbCBvcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc2Vjb25kcz0wXSAtIE51bWJlciBvZiBzZWNvbmRzIGl0IHdpbGwgdGFrZSB0byByZWFjaFxuICAgKiB0aGUgdGFyZ2V0IHZhbHVlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5lYXNpbmdGbj1MaW5lYXIuSW5PdXRdIC0gRWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSBmb3IgYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbkZpbmlzaF0gLSBDYWxsYmFjayB0byBleGVjdXRlIG9uY2UgdGhlIGFuaW1hdGlvbiBjb21wbGV0ZXMuXG4gICAqIFRoZSB0YXJnZXQgdmFsdWUgaXMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb3B0aW9ucy5vblByb2dyZXNzIC0gQ2FsbGJhY2sgdG8gZXhlY3V0ZSBlYWNoIHRpbWUgdGhlIGFuaW1hdGlvblxuICAgKiBwcm9wZXJ0eSBpcyB1cGRhdGVkIGR1cmluZyB0aGUgYW5pbWF0aW9uLiBUaGUgcHJvcGVydHkncyB2YWx1ZSBhdCB0aGUgdGltZSBvZlxuICAgKiB0aGUgdXBkYXRlIGlzIHBhc3NlZCBhcyBhIHBhcmFtZXRlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9wdGlvbnMub25DYW5jZWwgLSBDYWxsYmFjayB0byBleGVjdXRlIGlmIHRoZSB1c2VyIGNhbmNlbHMgdGhlXG4gICAqIGFuaW1hdGlvbiBiZWZvcmUgY29tcGxldGlvbi4gVGhlIGFuaW1hdGlvbiBwcm9wZXJ0eSdzIHZhbHVlIGF0IHRoZSB0aW1lIG9mXG4gICAqIGNhbmNlbCBpcyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvcHRpb25zLm9uRXJyb3IgLSBDYWxsYmFjayB0byBleGVjdXRlIGlmIHRoZSBhbmltYXRpb24gc3RvcHNcbiAgICogYmVjYXVzZSBhbiBlcnJvciBpcyBlbmNvdW50ZXJlZC4gVGhlIGVycm9yIG1lc3NhZ2UgaXMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9IFJlc29sdmVzIHdpdGggdGhlIHByb3BlcnR5J3MgdmFsdWUgb25jZSBpdCByZWFjaGVzIHRoZVxuICAgKiB0YXJnZXQgdmFsdWUuXG4gICAqL1xuICBzdGF0aWMgaW50ZXJwb2xhdGVQcm9wZXJ0eShcbiAgICBwcm9wZXJ0eU93bmVyLFxuICAgIHByb3BlcnR5TmFtZSxcbiAgICB0YXJnZXRWYWx1ZSxcbiAgICB7c2Vjb25kcyA9IDAsIGVhc2luZ0ZuLCBvbkZpbmlzaCwgb25Qcm9ncmVzcywgb25DYW5jZWwsIG9uRXJyb3J9ID0ge31cbiAgKSB7XG4gICAgLy8gTWFrZSBzdXJlIHByb3BlcnR5IGlzIGFuIG9iamVjdFxuICAgIGlmICghKHByb3BlcnR5T3duZXIgaW5zdGFuY2VvZiBPYmplY3QpKSB7XG4gICAgICBjb25zdCBlID0gbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGludGVycG9sYXRlIHByb3BlcnR5ICR7cHJvcGVydHlOYW1lfS4gUHJvcGVydHkgb3duZXIgbXVzdCBiZSBhbiBvYmplY3QuYFxuICAgICAgKTtcblxuICAgICAgaWYgKHR5cGVvZiBvbkVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9uRXJyb3IoZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBEZWZlcnJlZC5yZWplY3QoZSk7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIHByb3BlcnR5IGlzIG51bWVyaWNcbiAgICBpZiAoTnVtYmVyLmlzTmFOKE51bWJlcihwcm9wZXJ0eU93bmVyW3Byb3BlcnR5TmFtZV0pKSkge1xuICAgICAgY29uc3QgZSA9IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBpbnRlcnBvbGF0ZSBwcm9wZXJ0eSAke3Byb3BlcnR5TmFtZX0uIFByb3BlcnR5IG11c3QgYmUgbnVtZXJpYy5gXG4gICAgICApO1xuXG4gICAgICBpZiAodHlwZW9mIG9uRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb25FcnJvcihlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIERlZmVycmVkLnJlamVjdChlKTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlIHRhcmdldCB2YWx1ZSBpcyBudW1lcmljXG4gICAgaWYgKE51bWJlci5pc05hTihOdW1iZXIodGFyZ2V0VmFsdWUpKSkge1xuICAgICAgY29uc3QgZSA9IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBpbnRlcnBvbGF0ZSBwcm9wZXJ0eSAke3Byb3BlcnR5TmFtZX0gdG8gdmFsdWUgJHt0YXJnZXRWYWx1ZX0uIFRhcmdldCB2YWx1ZSBtdXN0IGJlIG51bWVyaWMuYFxuICAgICAgKTtcblxuICAgICAgaWYgKHR5cGVvZiBvbkVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9uRXJyb3IoZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBEZWZlcnJlZC5yZWplY3QoZSk7XG4gICAgfVxuXG4gICAgLy8gUmVzb2x2ZSBpbW1lZGlhdGVseSBpZiB0aGUgdGFyZ2V0IGhhcyBhbHJlYWR5IGJlZW4gcmVhY2hlZFxuICAgIGNvbnN0IHN0YXJ0VmFsdWUgPSBwcm9wZXJ0eU93bmVyW3Byb3BlcnR5TmFtZV07XG5cbiAgICBpZiAoc3RhcnRWYWx1ZSA9PT0gdGFyZ2V0VmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2Ygb25GaW5pc2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb25GaW5pc2godGFyZ2V0VmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gRGVmZXJyZWQucmVzb2x2ZSh0YXJnZXRWYWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCB0byBsaW5lYXIgaW50ZXJwb2xhdGlvblxuICAgIGlmICh0eXBlb2YgZWFzaW5nRm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChlYXNpbmdGbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgSW52YWxpZCBwcm9wZXJ0eSBpbnRlcnBvbGF0aW9uIGVhc2luZ0ZuLiBEZWZhdWx0aW5nIHRvIGxpbmVhciBpbnRlcnBvbGF0aW9uLmBcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgZWFzaW5nRm4gPSBMaW5lYXIuSW5PdXQ7XG4gICAgfVxuXG4gICAgY29uc3QgaW50ZXJwb2xhdG9yID0gVXRpbHMud2FpdChzZWNvbmRzLCB7XG4gICAgICBvbkZpbmlzaDogKCkgPT4ge1xuICAgICAgICBwcm9wZXJ0eU93bmVyW3Byb3BlcnR5TmFtZV0gPSB0YXJnZXRWYWx1ZTtcblxuICAgICAgICBpZiAodHlwZW9mIG9uRmluaXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgb25GaW5pc2godGFyZ2V0VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25DYW5jZWw6ICgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBvbkNhbmNlbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG9uQ2FuY2VsKHByb3BlcnR5T3duZXJbcHJvcGVydHlOYW1lXSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvblByb2dyZXNzOiBwcm9ncmVzcyA9PiB7XG4gICAgICAgIGlmIChwcm9wZXJ0eU93bmVyW3Byb3BlcnR5TmFtZV0gIT09IHRhcmdldFZhbHVlKSB7XG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBsZXJwIGZhY3RvclxuICAgICAgICAgIGNvbnN0IGVhc2VGYWN0b3IgPSBlYXNpbmdGbihwcm9ncmVzcyk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGVhc2VGYWN0b3IgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBjb25zdCBlID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgSW52YWxpZCBwcm9wZXJ0eSBpbnRlcnBvbGF0aW9uIGVhc2luZ0ZuLiBFYXNpbmdGbiBtdXN0IHJldHVybiBhIG51bWJlci5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaW50ZXJwb2xhdG9yLnJlamVjdChlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIHZhbHVlXG4gICAgICAgICAgcHJvcGVydHlPd25lcltwcm9wZXJ0eU5hbWVdID0gTWF0aFV0aWxzLmxlcnAoXG4gICAgICAgICAgICBzdGFydFZhbHVlLFxuICAgICAgICAgICAgdGFyZ2V0VmFsdWUsXG4gICAgICAgICAgICBlYXNlRmFjdG9yXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNpZ25hbCBwcm9ncmVzc1xuICAgICAgICBpZiAodHlwZW9mIG9uUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBvblByb2dyZXNzKHByb3BlcnR5T3duZXJbcHJvcGVydHlOYW1lXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaWduYWwgY29tcGxldGlvbiBvbmNlIHRpbWUgaXMgdXBcbiAgICAgICAgaWYgKHByb2dyZXNzID09PSAxKSB7XG4gICAgICAgICAgcHJvcGVydHlPd25lcltwcm9wZXJ0eU5hbWVdID0gdGFyZ2V0VmFsdWU7XG4gICAgICAgICAgaW50ZXJwb2xhdG9yLnJlc29sdmUodGFyZ2V0VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25FcnJvcixcbiAgICB9KTtcblxuICAgIHJldHVybiBpbnRlcnBvbGF0b3I7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQW5pbWF0aW9uVXRpbHM7XG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxuaW1wb3J0IERlZmVycmVkIGZyb20gJ2NvcmUvRGVmZXJyZWQnO1xuaW1wb3J0IE1hdGhVdGlscyBmcm9tICdjb3JlL01hdGhVdGlscyc7XG5pbXBvcnQgQW5pbWF0aW9uVXRpbHMgZnJvbSAnLi4vQW5pbWF0aW9uVXRpbHMnO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGEgc3RhdGUgaW4gb3VyIGFuaW1hdGlvbiBzeXN0ZW0uXG4gKlxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIEFic3RyYWN0U3RhdGUge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBhbmltYXRpb24gc3RhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0aW9ucy5uYW1lIC0gTmFtZSBmb3IgdGhlIGFuaW1hdGlvbiBzdGF0ZS4gTmFtZXMgbXVzdCBiZVxuICAgKiB1bmlxdWUgZm9yIHRoZSBjb250YWluZXIgdGhlIHN0YXRlIGlzIGFwcGxpZWQgdG8gYW5kIHNob3VsZCBiZSB2YWxpZGF0ZWQgYXRcbiAgICogdGhlIGNvbnRhaW5lciBsZXZlbC4gSWYgbm8gbmFtZSBpcyBnaXZlbiBpdCB3aWxsIGRlZmF1bHQgdG8gdGhlIGNvbnN0cnVjdG9yXG4gICAqIG5hbWUuXG4gICAqIEBwYXJhbSB7d2VpZ2h0fSBbb3B0aW9ucy53ZWlnaHQ9MF0gLSBUaGUgMC0xIGFtb3VudCBvZiBpbmZsdWVuY2UgdGhlIHN0YXRlIHdpbGwgaGF2ZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMubmFtZSA9XG4gICAgICBvcHRpb25zLm5hbWUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubmFtZSA6IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICB0aGlzLl93ZWlnaHQgPVxuICAgICAgb3B0aW9ucy53ZWlnaHQgIT09IHVuZGVmaW5lZCA/IE1hdGhVdGlscy5jbGFtcChvcHRpb25zLndlaWdodCwgMCwgMSkgOiAwO1xuICAgIHRoaXMuX2ludGVybmFsV2VpZ2h0ID0gdGhpcy5fd2VpZ2h0O1xuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5fcHJvbWlzZXMgPSB7XG4gICAgICBmaW5pc2g6IERlZmVycmVkLnJlc29sdmUoKSxcbiAgICAgIHdlaWdodDogRGVmZXJyZWQucmVzb2x2ZSgpLFxuICAgICAgcGxheTogRGVmZXJyZWQucmVzb2x2ZSgpLFxuICAgIH07XG5cbiAgICB0aGlzLl9wbGF5Q2FsbGJhY2tzID0ge1xuICAgICAgb25GaW5pc2g6IHVuZGVmaW5lZCxcbiAgICAgIG9uRXJyb3I6IHVuZGVmaW5lZCxcbiAgICAgIG9uQ2FuY2VsOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHdoZXRoZXIgb3Igbm90IHRoZSBzdGF0ZSBpcyBjdXJyZW50bHkgcGF1c2VkLlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHBhdXNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGF1c2VkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW5kIHNldHMgdGhlIHVzZXIgZGVmaW5lZCB3ZWlnaHQuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2VpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl93ZWlnaHQ7XG4gIH1cblxuICBzZXQgd2VpZ2h0KHdlaWdodCkge1xuICAgIHRoaXMuX3dlaWdodCA9IE1hdGhVdGlscy5jbGFtcCh3ZWlnaHQsIDAsIDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgd2hldGhlciBvciBub3QgdGhlIHdlaWdodCBpcyBjdXJyZW50bHkgYmVpbmcgYW5pbWF0ZWQuXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCB3ZWlnaHRQZW5kaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm9taXNlcy53ZWlnaHQgJiYgdGhpcy5fcHJvbWlzZXMud2VpZ2h0LnBlbmRpbmc7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgdXNlciBkZWZpbmVkIHdlaWdodCBvdmVyIHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3ZWlnaHQgLSBUaGUgdGFyZ2V0IHdlaWdodCB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzZWNvbmRzPTBdIC0gVGhlIGFtb3VudCBvZiB0aW1lIGl0IHdpbGwgdGFrZSB0byByZWFjaCB0aGVcbiAgICogdGFyZ2V0IHdlaWdodC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGVhc2luZ0ZuIC0gVGhlIGVhc2luZyBmdW5jdGlvbiB0byB1c2UgZm9yIGludGVycG9sYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH1cbiAgICovXG4gIHNldFdlaWdodCh3ZWlnaHQsIHNlY29uZHMgPSAwLCBlYXNpbmdGbikge1xuICAgIHRoaXMuX3Byb21pc2VzLndlaWdodC5jYW5jZWwoKTtcbiAgICB3ZWlnaHQgPSBNYXRoVXRpbHMuY2xhbXAod2VpZ2h0KTtcblxuICAgIHRoaXMuX3Byb21pc2VzLndlaWdodCA9IEFuaW1hdGlvblV0aWxzLmludGVycG9sYXRlUHJvcGVydHkoXG4gICAgICB0aGlzLFxuICAgICAgJ3dlaWdodCcsXG4gICAgICB3ZWlnaHQsXG4gICAgICB7c2Vjb25kcywgZWFzaW5nRm59XG4gICAgKTtcblxuICAgIHJldHVybiB0aGlzLl9wcm9taXNlcy53ZWlnaHQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgaW50ZXJuYWwgd2VpZ2h0LlxuICAgKlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBpbnRlcm5hbFdlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxXZWlnaHQ7XG4gIH1cblxuICAvKipcbiAgICogTXVsdGlwbGllcyB0aGUgdXNlciB3ZWlnaHQgYnkgYSBmYWN0b3IgdG8gZGV0ZXJtaW5lIHRoZSBpbnRlcm5hbCB3ZWlnaHQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmYWN0b3IgLSAwLTEgbXVsdGlwbGllciB0byBhcHBseSB0byB0aGUgdXNlciB3ZWlnaHQuXG4gICAqL1xuICB1cGRhdGVJbnRlcm5hbFdlaWdodChmYWN0b3IpIHtcbiAgICB0aGlzLl9pbnRlcm5hbFdlaWdodCA9IHRoaXMuX3dlaWdodCAqIGZhY3RvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgYW55IHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgZXZhbHVhdGVkIGV2ZXJ5IGZyYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFUaW1lIC0gVGltZSBpbiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGxhc3QgdXBkYXRlLlxuICAgKi9cbiAgdXBkYXRlKGRlbHRhVGltZSkge1xuICAgIGlmICghdGhpcy5fcGF1c2VkKSB7XG4gICAgICBPYmplY3QudmFsdWVzKHRoaXMuX3Byb21pc2VzKS5mb3JFYWNoKHByb21pc2UgPT4ge1xuICAgICAgICBwcm9taXNlLmV4ZWN1dGUoZGVsdGFUaW1lKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBwbGF5YmFjayBvZiB0aGUgc3RhdGUgZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25GaW5pc2ggLSBGdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIHN0YXRlIGZpbmlzaGVzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25FcnJvciAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgaWYgdGhlIHN0YXRlIGVuY291bnRlcnNcbiAgICogYW4gZXJyb3IgZHVyaW5nIHBsYXliYWNrLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25DYW5jZWwgLSBGdW5jdGlvbiB0byBleGVjdXRlIGlmIHBsYXliYWNrIGlzIGNhbmNlbGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9XG4gICAqL1xuICBwbGF5KG9uRmluaXNoLCBvbkVycm9yLCBvbkNhbmNlbCkge1xuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BsYXlDYWxsYmFja3Mub25GaW5pc2ggPSBvbkZpbmlzaDtcbiAgICB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uRXJyb3IgPSBvbkVycm9yO1xuICAgIHRoaXMuX3BsYXlDYWxsYmFja3Mub25DYW5jZWwgPSBvbkNhbmNlbDtcblxuICAgIHRoaXMuX3Byb21pc2VzLnBsYXkgPSBuZXcgRGVmZXJyZWQodW5kZWZpbmVkLCBvbkZpbmlzaCwgb25FcnJvciwgb25DYW5jZWwpO1xuICAgIHRoaXMuX3Byb21pc2VzLmZpbmlzaCA9IERlZmVycmVkLmFsbChbXG4gICAgICB0aGlzLl9wcm9taXNlcy5wbGF5LFxuICAgICAgdGhpcy5fcHJvbWlzZXMud2VpZ2h0LFxuICAgIF0pO1xuXG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VzLmZpbmlzaDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXVzZSBwbGF5YmFjayBvZiB0aGUgc3RhdGUuIFRoaXMgcHJldmVudHMgcGVuZGluZyBwcm9taXNlcyBmcm9tIGJlaW5nIGV4ZWN1dGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHBhdXNlKCkge1xuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUmVzdW1lIHBsYXliYWNrIG9mIHRoZSBzdGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uRmluaXNoIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHRoZSBzdGF0ZSBmaW5pc2hlcy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uRXJyb3IgLSBGdW5jdGlvbiB0byBleGVjdXRlIGlmIHRoZSBzdGF0ZSBlbmNvdW50ZXJzXG4gICAqIGFuIGVycm9yIGR1cmluZyBwbGF5YmFjay5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uQ2FuY2VsIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBpZiBwbGF5YmFjayBpcyBjYW5jZWxlZC5cbiAgICpcbiAgICogQHJldHVybnMge0RlZmVycmVkfVxuICAgKi9cbiAgcmVzdW1lKG9uRmluaXNoLCBvbkVycm9yLCBvbkNhbmNlbCkge1xuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuXG4gICAgaWYgKCF0aGlzLl9wcm9taXNlcy5wbGF5LnBlbmRpbmcpIHtcbiAgICAgIHRoaXMuX3BsYXlDYWxsYmFja3Mub25GaW5pc2ggPSBvbkZpbmlzaCB8fCB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uRmluaXNoO1xuICAgICAgdGhpcy5fcGxheUNhbGxiYWNrcy5vbkVycm9yID0gb25FcnJvciB8fCB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uRXJyb3I7XG4gICAgICB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uQ2FuY2VsID0gb25DYW5jZWwgfHwgdGhpcy5fcGxheUNhbGxiYWNrcy5vbkNhbmNlbDtcblxuICAgICAgdGhpcy5fcHJvbWlzZXMucGxheSA9IG5ldyBEZWZlcnJlZChcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uRmluaXNoLFxuICAgICAgICB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uRXJyb3IsXG4gICAgICAgIHRoaXMuX3BsYXlDYWxsYmFja3Mub25DYW5jZWxcbiAgICAgICk7XG4gICAgICB0aGlzLl9wcm9taXNlcy5maW5pc2ggPSBEZWZlcnJlZC5hbGwoW1xuICAgICAgICB0aGlzLl9wcm9taXNlcy5wbGF5LFxuICAgICAgICB0aGlzLl9wcm9taXNlcy53ZWlnaHQsXG4gICAgICBdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZXMuZmluaXNoO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbCBwbGF5YmFjayBvZiB0aGUgc3RhdGUgYW5kIGNhbmNlbCBhbnkgcGVuZGluZyBwcm9taXNlcy5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBjYW5jZWwoKSB7XG4gICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcblxuICAgIE9iamVjdC52YWx1ZXModGhpcy5fcHJvbWlzZXMpLmZvckVhY2gocHJvbWlzZSA9PiB7XG4gICAgICBwcm9taXNlLmNhbmNlbCgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCBwbGF5YmFjayBvZiB0aGUgc3RhdGUgYW5kIHJlc29sdmUgYW55IHBlbmRpbmcgcHJvbWlzZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RvcCgpIHtcbiAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuXG4gICAgT2JqZWN0LnZhbHVlcyh0aGlzLl9wcm9taXNlcykuZm9yRWFjaChwcm9taXNlID0+IHtcbiAgICAgIHByb21pc2UucmVzb2x2ZSgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VsIGFueSBwZW5kaW5nIHByb21pc2VzIGFuZCByZW1vdmUgcmVmZXJlbmNlIHRvIHRoZW0uXG4gICAqL1xuICBkaXNjYXJkKCkge1xuICAgIHRoaXMuY2FuY2VsKCk7XG5cbiAgICBkZWxldGUgdGhpcy5fcHJvbWlzZXM7XG4gIH1cblxuICAvKipcbiAgICogRm9yY2UgdGhlIGludGVybmFsIHdlaWdodCB0byAwLiBTaG91bGQgYmUgY2FsbGVkIGJlZm9yZSBzd2l0Y2hpbmcgb3IgdHJhbnNpdGlvbmluZ1xuICAgKiB0byBhIG5ldyBzdGF0ZS5cbiAgICovXG4gIGRlYWN0aXZhdGUoKSB7XG4gICAgdGhpcy51cGRhdGVJbnRlcm5hbFdlaWdodCgwKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBYnN0cmFjdFN0YXRlO1xuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcbmltcG9ydCBEZWZlcnJlZCBmcm9tICdjb3JlL0RlZmVycmVkJztcbmltcG9ydCBBYnN0cmFjdFN0YXRlIGZyb20gJy4vQWJzdHJhY3RTdGF0ZSc7XG5cbi8qKlxuICogQ2xhc3MgZm9yIHNtb290aCB0cmFuc2l0aW9uaW5nIGJldHdlZW4gc3RhdGVzIG9uIGFuIGFuaW1hdGlvbiBsYXllci5cbiAqXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFN0YXRlXG4gKi9cbmNsYXNzIFRyYW5zaXRpb25TdGF0ZSBleHRlbmRzIEFic3RyYWN0U3RhdGUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihvcHRpb25zKTtcblxuICAgIHRoaXMuX3RvID0gbnVsbDtcbiAgICB0aGlzLl9mcm9tID0gW107XG4gICAgdGhpcy5fd2VpZ2h0UHJvbWlzZSA9IERlZmVycmVkLnJlc29sdmUoKTtcbiAgfVxuXG4gIGdldCBpbnRlcm5hbFdlaWdodCgpIHtcbiAgICAvLyBGaW5kIHRoZSBjb21iaW5lZCB3ZWlnaHQgb2YgYWxsIHN1Yi1zdGF0ZXNcbiAgICBsZXQgdG90YWxXZWlnaHQgPSAwO1xuXG4gICAgaWYgKHRoaXMuX3RvKSB7XG4gICAgICB0b3RhbFdlaWdodCArPSB0aGlzLl90by53ZWlnaHQ7XG4gICAgfVxuXG4gICAgdGhpcy5fZnJvbS5mb3JFYWNoKHN0YXRlID0+IHtcbiAgICAgIHRvdGFsV2VpZ2h0ICs9IHN0YXRlLndlaWdodDtcbiAgICB9KTtcblxuICAgIHJldHVybiB0b3RhbFdlaWdodCAqIHRoaXMuX2ludGVybmFsV2VpZ2h0O1xuICB9XG5cbiAgdXBkYXRlSW50ZXJuYWxXZWlnaHQoZmFjdG9yKSB7XG4gICAgc3VwZXIudXBkYXRlSW50ZXJuYWxXZWlnaHQoZmFjdG9yKTtcblxuICAgIHRoaXMuX2Zyb20uZm9yRWFjaChzdGF0ZSA9PiB7XG4gICAgICBzdGF0ZS51cGRhdGVJbnRlcm5hbFdlaWdodCh0aGlzLl9pbnRlcm5hbFdlaWdodCk7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5fdG8pIHtcbiAgICAgIHRoaXMuX3RvLnVwZGF0ZUludGVybmFsV2VpZ2h0KHRoaXMuX2ludGVybmFsV2VpZ2h0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHN1Yi1zdGF0ZXMgdGhlIHRyYW5zaXRpb24gaXMgY29udHJvbGxpbmcgYW5kIHN0YXJ0IG5ldyB3ZWlnaHRcbiAgICogYW5pbWF0aW9ucyBvbiBlYWNoIG9uZS4gVGhpcyBzaG91bGQgYmUgY2FsbGVkIGVhY2ggdGltZSB0aGUgY3VycmVudCBzdGF0ZSBvZlxuICAgKiBhbiBhbmltYXRpb24gbGF5ZXIgZ2V0cyB1cGRhdGVkIHRvIGEgbmV3IHZhbHVlIGFuZCBhIHRyYW5zaXRpb24gdGltZSBncmVhdGVyXG4gICAqIHRoYXQgemVybyBpcyBzcGVjaWZpZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXkuPEFic3RyYWN0U3RhdGU+fSBbY3VycmVudFN0YXRlcz1bXV0gLSBTdGF0ZXMgd2hvc2Ugd2VpZ2h0IHZhbHVlc1xuICAgKiB3aWxsIGJlIGFuaW1hdGVkIHRvIDAuXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RTdGF0ZT19IHRhcmdldFN0YXRlIC0gU3RhdGUgd2hvc2Ugd2VpZ2h0IHdpbGwgYmUgYW5pbWF0ZWRcbiAgICogdG8gMS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHRyYW5zaXRpb25UaW1lIC0gQW1vdW50IG9mIHRpbWUgaXQgd2lsbCBpbiBzZWNvbmRzIHRha2UgZm9yXG4gICAqIHdlaWdodCBhbmltYXRpb25zIHRvIGNvbXBsZXRlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gZWFzaW5nRm4gLSBFYXNpbmcgZnVuY3Rpb24gdG8gdXNlIGZvciB3ZWlnaHQgYW5pbWF0aW9ucy5cbiAgICogRGVmYXVsdCBpcyBFYXNpbmcuTGluZWFyLkluT3V0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25Db21wbGV0ZSAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgb25jZSBhbGwgd2VpZ2h0IGFuaW1hdGlvbnNcbiAgICogY29tcGxldGUuXG4gICAqL1xuICBjb25maWd1cmUoXG4gICAgY3VycmVudFN0YXRlcyA9IFtdLFxuICAgIHRhcmdldFN0YXRlLFxuICAgIHRyYW5zaXRpb25UaW1lLFxuICAgIGVhc2luZ0ZuLFxuICAgIG9uQ29tcGxldGVcbiAgKSB7XG4gICAgLy8gRGVhY3RpdmF0ZSBhbnkgc3RhdGVzIHRoYXQgYXJlbid0IGluIHRoZSBuZXcgY29uZmlndXJhdGlvblxuICAgIGlmICh0aGlzLl90byA9PT0gdGFyZ2V0U3RhdGUgfHwgY3VycmVudFN0YXRlcy5pbmNsdWRlcyh0aGlzLl90bykpIHtcbiAgICAgIHRoaXMuX3RvID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fZnJvbSA9IHRoaXMuX2Zyb20uZmlsdGVyKFxuICAgICAgc3RhdGUgPT4gc3RhdGUgIT09IHRhcmdldFN0YXRlICYmICFjdXJyZW50U3RhdGVzLmluY2x1ZGVzKHN0YXRlKVxuICAgICk7XG4gICAgdGhpcy5kZWFjdGl2YXRlKCk7XG5cbiAgICB0aGlzLl9mcm9tID0gY3VycmVudFN0YXRlcztcbiAgICB0aGlzLl90byA9IHRhcmdldFN0YXRlO1xuICAgIHRoaXMucmVzZXQodHJhbnNpdGlvblRpbWUsIGVhc2luZ0ZuLCBvbkNvbXBsZXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBuZXcgd2VpZ2h0IGFuaW1hdGlvbnMgc3RhdGUgdGhlIHRyYW5zaXRpb24gY29udHJvbHMuIFRoaXMgc2hvdWxkIGJlIGNhbGxlZFxuICAgKiBpZiBhbiBhbmltYXRpb24gaXMgcGxheWVkIHdpdGggYSB0cmFuc2l0aW9uIHRpbWUgZ3JlYXRlciB0aGFuIHplcm8gYW5kIGEgdHJhbnN0aW9uXG4gICAqIHRvIHRoYXQgYW5pbWF0aW9uIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdHJhbnNpdGlvblRpbWUgLSBBbW91bnQgb2YgdGltZSBpdCB3aWxsIGluIHNlY29uZHMgdGFrZSBmb3JcbiAgICogd2VpZ2h0IGFuaW1hdGlvbnMgdG8gY29tcGxldGUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBlYXNpbmdGbiAtIEVhc2luZyBmdW5jdGlvbiB0byB1c2UgZm9yIHdlaWdodCBhbmltYXRpb25zLlxuICAgKiBEZWZhdWx0IGlzIEVhc2luZy5MaW5lYXIuSW5PdXQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkNvbXBsZXRlIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBvbmNlIGFsbCB3ZWlnaHQgYW5pbWF0aW9uc1xuICAgKiBjb21wbGV0ZS5cbiAgICovXG4gIHJlc2V0KHRyYW5zaXRpb25UaW1lLCBlYXNpbmdGbiwgb25Db21wbGV0ZSkge1xuICAgIC8vIFN0b3AgYW55IHBlbmRpbmcgcHJvbWlzZXNcbiAgICB0aGlzLl93ZWlnaHRQcm9taXNlLmNhbmNlbCgpO1xuXG4gICAgLy8gU3RhcnQgdHdlZW5pbmcgd2VpZ2h0IHRvIDAgZm9yIHRoZSBjdXJyZW50IHN0YXRlc1xuICAgIGNvbnN0IHdlaWdodFByb21pc2VzID0gdGhpcy5fZnJvbS5tYXAoc3RhdGUgPT5cbiAgICAgIHN0YXRlLnNldFdlaWdodCgwLCB0cmFuc2l0aW9uVGltZSwgZWFzaW5nRm4pXG4gICAgKTtcblxuICAgIC8vIFN0YXJ0IHR3ZWVuaW5nIHdlaWdodCB0byAxIGZvciB0aGUgdGFyZ2V0IHN0YXRlXG4gICAgaWYgKHRoaXMuX3RvKSB7XG4gICAgICB3ZWlnaHRQcm9taXNlcy5wdXNoKHRoaXMuX3RvLnNldFdlaWdodCgxLCB0cmFuc2l0aW9uVGltZSwgZWFzaW5nRm4pKTtcbiAgICAgIHRoaXMubmFtZSA9IHRoaXMuX3RvLm5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5fd2VpZ2h0UHJvbWlzZSA9IERlZmVycmVkLmFsbCh3ZWlnaHRQcm9taXNlcywgKCkgPT4ge1xuICAgICAgdGhpcy5fZnJvbS5mb3JFYWNoKHN0YXRlID0+IHtcbiAgICAgICAgc3RhdGUuY2FuY2VsKCk7XG4gICAgICAgIHN0YXRlLmRlYWN0aXZhdGUoKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiBvbkNvbXBsZXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHBsYXkob25GaW5pc2gsIG9uRXJyb3IsIG9uQ2FuY2VsLCBvbk5leHQpIHtcbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uRmluaXNoID0gb25GaW5pc2g7XG4gICAgdGhpcy5fcGxheUNhbGxiYWNrcy5vbkVycm9yID0gb25FcnJvcjtcbiAgICB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uQ2FuY2VsID0gb25DYW5jZWw7XG5cbiAgICBjb25zdCBwcm9taXNlcyA9IFt0aGlzLl93ZWlnaHRQcm9taXNlXTtcblxuICAgIHRoaXMuX2Zyb20uZm9yRWFjaChzdGF0ZSA9PiB7XG4gICAgICBzdGF0ZS5yZXN1bWUoKTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLl90bykge1xuICAgICAgdGhpcy5fcHJvbWlzZXMucGxheSA9IHRoaXMuX3RvLnBsYXkoXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIG9uTmV4dFxuICAgICAgKTtcbiAgICAgIHByb21pc2VzLnB1c2godGhpcy5fcHJvbWlzZXMucGxheSk7XG4gICAgfVxuXG4gICAgdGhpcy5fcHJvbWlzZXMuZmluaXNoID0gRGVmZXJyZWQuYWxsKHByb21pc2VzLCBvbkZpbmlzaCwgb25FcnJvciwgb25DYW5jZWwpO1xuICAgIHJldHVybiB0aGlzLl9wcm9taXNlcy5maW5pc2g7XG4gIH1cblxuICBwYXVzZSgpIHtcbiAgICB0aGlzLl9mcm9tLmZvckVhY2goc3RhdGUgPT4ge1xuICAgICAgc3RhdGUucGF1c2UoKTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLl90bykge1xuICAgICAgdGhpcy5fdG8ucGF1c2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIucGF1c2UoKTtcbiAgfVxuXG4gIHJlc3VtZShvbkZpbmlzaCwgb25FcnJvciwgb25DYW5jZWwsIG9uTmV4dCkge1xuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuXG4gICAgaWYgKCF0aGlzLl9wcm9taXNlcy5wbGF5LnBlbmRpbmcpIHtcbiAgICAgIHRoaXMuX3BsYXlDYWxsYmFja3Mub25GaW5pc2ggPSBvbkZpbmlzaCB8fCB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uRmluaXNoO1xuICAgICAgdGhpcy5fcGxheUNhbGxiYWNrcy5vbkVycm9yID0gb25FcnJvciB8fCB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uRXJyb3I7XG4gICAgICB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uQ2FuY2VsID0gb25DYW5jZWwgfHwgdGhpcy5fcGxheUNhbGxiYWNrcy5vbkNhbmNlbDtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9taXNlcyA9IFt0aGlzLl93ZWlnaHRQcm9taXNlXTtcblxuICAgIHRoaXMuX2Zyb20uZm9yRWFjaChzdGF0ZSA9PiB7XG4gICAgICBzdGF0ZS5yZXN1bWUoKTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLl90bykge1xuICAgICAgdGhpcy5fcHJvbWlzZXMucGxheSA9IHRoaXMuX3RvLnJlc3VtZShcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgb25OZXh0XG4gICAgICApO1xuICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLl9wcm9taXNlcy5wbGF5KTtcbiAgICB9XG5cbiAgICB0aGlzLl9wcm9taXNlcy5maW5pc2ggPSBEZWZlcnJlZC5hbGwoXG4gICAgICBwcm9taXNlcyxcbiAgICAgIHRoaXMuX3BsYXlDYWxsYmFja3Mub25GaW5pc2gsXG4gICAgICB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uRXJyb3IsXG4gICAgICB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uQ2FuY2VsXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZXMuZmluaXNoO1xuICB9XG5cbiAgY2FuY2VsKCkge1xuICAgIHRoaXMuX2Zyb20uZm9yRWFjaChzdGF0ZSA9PiB7XG4gICAgICBzdGF0ZS5wYXVzZSgpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuX3RvKSB7XG4gICAgICB0aGlzLl90by5jYW5jZWwoKTtcbiAgICB9XG5cbiAgICB0aGlzLl93ZWlnaHRQcm9taXNlLmNhbmNlbCgpO1xuXG4gICAgcmV0dXJuIHN1cGVyLmNhbmNlbCgpO1xuICB9XG5cbiAgc3RvcCgpIHtcbiAgICB0aGlzLl9mcm9tLmZvckVhY2goc3RhdGUgPT4ge1xuICAgICAgc3RhdGUucGF1c2UoKTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLl90bykge1xuICAgICAgdGhpcy5fdG8uc3RvcCgpO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5zdG9wKCk7XG4gIH1cblxuICB1cGRhdGUoZGVsdGFUaW1lKSB7XG4gICAgc3VwZXIudXBkYXRlKGRlbHRhVGltZSk7XG5cbiAgICB0aGlzLl9mcm9tLmZvckVhY2goc3RhdGUgPT4ge1xuICAgICAgc3RhdGUudXBkYXRlKGRlbHRhVGltZSk7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5fdG8pIHtcbiAgICAgIHRoaXMuX3RvLnVwZGF0ZShkZWx0YVRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIGRpc2NhcmQoKSB7XG4gICAgc3VwZXIuZGlzY2FyZCgpO1xuXG4gICAgdGhpcy5fd2VpZ2h0UHJvbWlzZS5jYW5jZWwoKTtcbiAgICBkZWxldGUgdGhpcy5fd2VpZ2h0UHJvbWlzZTtcbiAgICB0aGlzLl90byA9IG51bGw7XG4gICAgdGhpcy5fZnJvbS5sZW5ndGggPSAwO1xuICB9XG5cbiAgZGVhY3RpdmF0ZSgpIHtcbiAgICBpZiAodGhpcy5fdG8pIHtcbiAgICAgIHRoaXMuX3RvLmRlYWN0aXZhdGUoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9mcm9tLmZvckVhY2goc3RhdGUgPT4ge1xuICAgICAgc3RhdGUuZGVhY3RpdmF0ZSgpO1xuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRyYW5zaXRpb25TdGF0ZTtcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtY2xhc3Nlcy1wZXItZmlsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLWVtcHR5LWZ1bmN0aW9uICovXG4vKiBlc2xpbnQtZGlzYWJsZSBnZXR0ZXItcmV0dXJuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11c2VsZXNzLWNvbnN0cnVjdG9yICovXG5pbXBvcnQgVHJhbnNpdGlvblN0YXRlIGZyb20gJy4vc3RhdGUvVHJhbnNpdGlvblN0YXRlJztcbmltcG9ydCBEZWZlcnJlZCBmcm9tICcuLi9EZWZlcnJlZCc7XG5cbi8qKlxuICogQ2xhc3MgZmFjdG9yeSBpbnRlcmZhY2UgZm9yIGNvbnRyb2xsaW5nIHBsYXliYWNrIG9mIGEgY29sbGVjdGlvbiBvZiBhbmltYXRpb25zLlxuICogT25lIGFuaW1hdGlvbiBjYW4gYmUgcGxheWVkIGF0IGFueSBnaXZlbiB0aW1lLCBjcm9zc2ZhZGluZyBiZXR3ZWVuIGFuaW1hdGlvbnNcbiAqIHdpbGwgcmVzdWx0IGluIHBsYXlpbmcgYSB7QGxpbmsgVHJhbnNpdGlvblN0YXRlfS5cbiAqXG4gKiBAaW50ZXJmYWNlXG4gKi9cbmNsYXNzIEFuaW1hdGlvblBsYXllckludGVyZmFjZSB7XG4gIC8qKlxuICAgKiBHZXRzIHdoZXRoZXIgb3Igbm90IHRoZSBwbGF5ZXIgaXMgdXBkYXRpbmcgc3RhdGVzLlxuICAgKlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgcGF1c2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXVzZWQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbmQgc2V0cyB0aGUgZGVmYXVsdCBudW1iZXIgb2Ygc2Vjb25kcyBpdCB0YWtlcyB0byB0cmFuc2l0aW9uIHRvIGEgbmV3XG4gICAqIGFuaW1hdGlvbi5cbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB0cmFuc2l0aW9uVGltZSgpIHt9XG5cbiAgc2V0IHRyYW5zaXRpb25UaW1lKHNlY29uZHMpIHt9XG5cbiAgLyoqXG4gICAqIEdldHMgYW5kIHNldHMgdGhlIGRlZmF1bHQgZWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSB3aGVuIHRyYW5zaXRpb25pbmcgYW5kXG4gICAqIHNldHRpbmcgd2VpZ2h0cy5cbiAgICpcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgZ2V0IGVhc2luZ0ZuKCkge31cblxuICBzZXQgZWFzaW5nRm4oZm4pIHt9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHN0YXRlIHRoZSBsYXllciBpcyBjdXJyZW50bHkgaW4gY29udHJvbCBvZi5cbiAgICpcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtBYnN0cmFjdFN0YXRlfVxuICAgKi9cbiAgZ2V0IGN1cnJlbnRTdGF0ZSgpIHt9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG5hbWUgb2YgdGhlIHN0YXRlIHRoZSBsYXllciBpcyBjdXJyZW50bHkgaW4gY29udHJvbCBvZi5cbiAgICpcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgY3VycmVudEFuaW1hdGlvbigpIHt9XG5cbiAgLyoqXG4gICAqIEdldHMgd2hldGhlciBvciBub3QgdGhlIGxheWVyIGlzIGN1cnJlbnRseSB0cmFuc2l0aW9uaW5nIHRvIGEgbmV3IGFuaW1hdGlvbi5cbiAgICpcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzVHJhbnNpdGlvbmluZygpIHt9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgbGF5ZXIncyBjdXJyZW50IHN0YXRlIHRvIGEgbmV3IHZhbHVlLiBJZiB0cmFuc2l0aW9uVGltZSBpcyBkZWZpbmVkXG4gICAqIGFuZCBncmVhdGVyIHRoYW4gemVybywgcGVyZm9ybSBhIHNtb290aCBibGVuZCBiZXR3ZWVuIGFueSBzdGF0ZXMgdGhhdCBjdXJyZW50bHlcbiAgICogaGF2ZSBub24temVybyB3ZWlnaHQgdmFsdWVzIGFuZCB0aGUgbmV3IHN0YXRlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0geyhzdHJpbmd8bnVsbCl9IG5hbWUgLSBOYW1lIG9mIHRoZSBzdGF0ZSB0byB0cmFuc2l0aW9uIHRvLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGxheU1ldGhvZCAtIE5hbWUgb2YgdGhlIG9wZXJhdGlvbiBiZWluZyBwcmVwYXJlZCBmb3IsIHRvIGJlXG4gICAqIHVzZWQgaW4gZXJyb3IgbWVzc2FnaW5nLlxuICAgKiBAcGFyYW0ge251bWJlcj19IHRyYW5zaXRpb25UaW1lIC0gQW1vdW50IG9mIHRpbWUgaW4gc2Vjb25kcyBpdCB3aWxsIHRha2UgdG9cbiAgICogc3dpdGNoIHRvIHRoZSBuZXcgc3RhdGUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBlYXNpbmdGbiAtIEVhc2luZyBmdW5jdGlvbiB0byB1c2Ugd2hlbiB0cmFuc2l0aW9uaW5nIHRvIGFcbiAgICogbmV3IHN0YXRlIG92ZXIgdGltZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uRXJyb3IgLSBGdW5jdGlvbiB0byBleGVjdXRlIGlmIGFuIGVycm9yIGlzIGVuY291bnRlcmVkLlxuICAgKi9cbiAgX3ByZXBhcmVDdXJyZW50U3RhdGUobmFtZSwgcGxheU1ldGhvZCwgdHJhbnNpdGlvblRpbWUsIGVhc2luZ0ZuLCBvbkVycm9yKSB7fVxuXG4gIC8qKlxuICAgKiBTdGFydCBwbGF5YmFjayBhbiBhbmltYXRpb24gZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIGFuaW1hdGlvbiB0byBwbGF5LlxuICAgKiBAcGFyYW0ge251bWJlcj19IHRyYW5zaXRpb25UaW1lIC0gQW1vdW50IG9mIHRpbWUgaXQgd2lsbCB0YWtlIGJlZm9yZSB0aGVcbiAgICogbmV3IHN0YXRlIGhhcyBmdWxsIGluZmx1ZW5jZSBmb3IgdGhlIGxheWVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gZWFzaW5nRm4gLSBFYXNpbmcgZnVuY3Rpb24gdG8gdXNlIGZvciBibGVuZGluZyBpZiB0cmFuc2l0aW9uVGltZVxuICAgKiBpcyBncmVhdGVyIHRoYW4gemVyby5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uRmluaXNoIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHRoZSBhbmltYXRpb24gZmluaXNoZXMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkVycm9yIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBpZiB0aGUgYW5pbWF0aW9uIGVuY291bnRlcnNcbiAgICogYW4gZXJyb3IgZHVyaW5nIHBsYXliYWNrLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25DYW5jZWwgLSBGdW5jdGlvbiB0byBleGVjdXRlIGlmIHBsYXliYWNrIGlzIGNhbmNlbGVkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25OZXh0IC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBpZiBhbiBhbmltYXRpb24gcXVldWUgaXNcbiAgICogcGxheWVkIGFuZCBpdCBhZHZhbmNlcyB0byB0aGUgbmV4dCBhbmltYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH1cbiAgICovXG4gIHBsYXlBbmltYXRpb24oXG4gICAgbmFtZSxcbiAgICB0cmFuc2l0aW9uVGltZSxcbiAgICBlYXNpbmdGbixcbiAgICBvbkZpbmlzaCxcbiAgICBvbkVycm9yLFxuICAgIG9uQ2FuY2VsLFxuICAgIG9uTmV4dFxuICApIHt9XG5cbiAgLyoqXG4gICAqIENhbmNlbCBwbGF5YmFjayBvZiB0aGUgY3VycmVudCBhbmltYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgY2FuY2VsQW5pbWF0aW9uKCkge31cblxuICAvKipcbiAgICogUGF1c2UgcGxheWJhY2sgb2YgdGhlIGN1cnJlbnQgYW5pbWF0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHBhdXNlQW5pbWF0aW9uKCkge31cblxuICAvKipcbiAgICogUmVzdW1lIHBsYXliYWNrIG9mIGFuIGFuaW1hdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBuYW1lIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRvIHJlc3VtZSBwbGF5YmFjayBmb3IuIERlZmF1bHRcbiAgICogaXMgdGhlIGxheWVyJ3MgY3VycmVudCBhbmltYXRpb24gbmFtZS5cbiAgICogQHBhcmFtIHtudW1iZXI9fSB0cmFuc2l0aW9uVGltZSAtIEFtb3VudCBvZiB0aW1lIGl0IHdpbGwgdGFrZSBiZWZvcmUgdGhlXG4gICAqIG5ldyBzdGF0ZSBoYXMgZnVsbCBpbmZsdWVuY2UgZm9yIHRoZSBsYXllci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uRmluaXNoIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHRoZSBzdGF0ZSBmaW5pc2hlcy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uRXJyb3IgLSBGdW5jdGlvbiB0byBleGVjdXRlIGlmIHRoZSBzdGF0ZSBlbmNvdW50ZXJzXG4gICAqIGFuIGVycm9yIGR1cmluZyBwbGF5YmFjay5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uQ2FuY2VsIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBpZiBwbGF5YmFjayBpcyBjYW5jZWxlZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uTmV4dCAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgaWYgYW4gYW5pbWF0aW9uIHF1ZXVlIGlzXG4gICAqIHBsYXllZCBhbmQgaXQgYWR2YW5jZXMgdG8gdGhlIG5leHQgYW5pbWF0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9XG4gICAqL1xuICByZXN1bWVBbmltYXRpb24oXG4gICAgbmFtZSxcbiAgICB0cmFuc2l0aW9uVGltZSxcbiAgICBlYXNpbmdGbixcbiAgICBvbkZpbmlzaCxcbiAgICBvbkVycm9yLFxuICAgIG9uQ2FuY2VsLFxuICAgIG9uTmV4dFxuICApIHt9XG5cbiAgLyoqXG4gICAqIFN0b3AgcGxheWJhY2sgb2YgdGhlIGN1cnJlbnQgYW5pbWF0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0b3BBbmltYXRpb24oKSB7fVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGN1cnJlbnQgYW5pbWF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFUaW1lIC0gVGltZSBpbiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGxhc3QgdXBkYXRlLlxuICAgKi9cbiAgdXBkYXRlKGRlbHRhVGltZSkge31cblxuICAvKipcbiAgICogRGlzY2FyZCB0aGUgdHJhbnNpdGlvbiBzdGF0ZS5cbiAgICovXG4gIGRpc2NhcmQoKSB7fVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY2xhc3MgdGhhdCBpbXBsZW1lbnRzIHtAbGluayBBbmltYXRpb25QbGF5ZXJJbnRlcmZhY2V9IGFuZCBleHRlbmRzXG4gICAqIGEgc3BlY2lmaWVkIGJhc2UgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2xhc3N9IFtCYXNlQ2xhc3MgPSBjbGFzc3t9XSAtIFRoZSBjbGFzcyB0byBleHRlbmQuXG4gICAqXG4gICAqIEByZXR1cm4ge0NsYXNzfSBBIGNsYXNzIHRoYXQgZXh0ZW5kcyBgQmFzZUNsYXNzYCBhbmQgaW1wbGVtZW50cyB7QGxpbmsgQW5pbWF0aW9uUGxheWVySW50ZXJmYWNlfS5cbiAgICovXG4gIHN0YXRpYyBNaXhpbihCYXNlQ2xhc3MgPSBjbGFzcyB7fSkge1xuICAgIGNvbnN0IEFuaW1hdGlvblBsYXllck1peGluID0gY2xhc3MgZXh0ZW5kcyBCYXNlQ2xhc3Mge1xuICAgICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9LCAuLi5hcmdzKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMsIC4uLmFyZ3MpO1xuXG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25TdGF0ZSA9IG5ldyBUcmFuc2l0aW9uU3RhdGUoKTtcbiAgICAgICAgdGhpcy5fc3RhdGVzID0gdGhpcy5fc3RhdGVzICE9PSB1bmRlZmluZWQgPyB0aGlzLl9zdGF0ZXMgOiBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25UaW1lID1cbiAgICAgICAgICBOdW1iZXIob3B0aW9ucy50cmFuc2l0aW9uVGltZSkgPj0gMFxuICAgICAgICAgICAgPyBOdW1iZXIob3B0aW9ucy50cmFuc2l0aW9uVGltZSlcbiAgICAgICAgICAgIDogMDtcblxuICAgICAgICB0aGlzLl9lYXNpbmdGbiA9XG4gICAgICAgICAgdHlwZW9mIG9wdGlvbnMuZWFzaW5nRm4gPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLmVhc2luZ0ZuIDogdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBnZXQgcGF1c2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGF1c2VkO1xuICAgICAgfVxuXG4gICAgICBnZXQgdHJhbnNpdGlvblRpbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2l0aW9uVGltZTtcbiAgICAgIH1cblxuICAgICAgc2V0IHRyYW5zaXRpb25UaW1lKHNlY29uZHMpIHtcbiAgICAgICAgc2Vjb25kcyA9IE51bWJlcihzZWNvbmRzKTtcblxuICAgICAgICBpZiAoIShzZWNvbmRzID49IDApKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYENhbm5vdCBzZXQgdHJhbnNpdGlvbiB0aW1lIGZvciAke3RoaXMuY29uc3RydWN0b3IubmFtZX0gdG8gJHtzZWNvbmRzfS4gU2Vjb25kcyBtdXN0IGJlIGEgbnVtZXJpYyB2YWx1ZSBncmVhdGhlciB0aGFuIG9yIGVxdWFsIHRvIHplcm8uYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90cmFuc2l0aW9uVGltZSA9IHNlY29uZHM7XG4gICAgICB9XG5cbiAgICAgIGdldCBlYXNpbmdGbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vhc2luZ0ZuO1xuICAgICAgfVxuXG4gICAgICBzZXQgZWFzaW5nRm4oZm4pIHtcbiAgICAgICAgdGhpcy5fZWFzaW5nRm4gPSBmbjtcbiAgICAgIH1cblxuICAgICAgZ2V0IGN1cnJlbnRTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRTdGF0ZTtcbiAgICAgIH1cblxuICAgICAgZ2V0IGN1cnJlbnRBbmltYXRpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50U3RhdGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFN0YXRlLm5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgZ2V0IGlzVHJhbnNpdGlvbmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRTdGF0ZSA9PT0gdGhpcy5fdHJhbnNpdGlvblN0YXRlO1xuICAgICAgfVxuXG4gICAgICBfcHJlcGFyZUN1cnJlbnRTdGF0ZShcbiAgICAgICAgbmFtZSxcbiAgICAgICAgcGxheU1ldGhvZCxcbiAgICAgICAgdHJhbnNpdGlvblRpbWUsXG4gICAgICAgIGVhc2luZ0ZuLFxuICAgICAgICBvbkVycm9yXG4gICAgICApIHtcbiAgICAgICAgaWYgKG5hbWUgIT09IG51bGwgJiYgIXRoaXMuX3N0YXRlcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICBjb25zdCBlID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgYENhbm5vdCAke3BsYXlNZXRob2R9IGFuaW1hdGlvbiAke25hbWV9LiBObyBhbmltYXRpb24gZXhpc3RzIHdpdGggdGhpcyBuYW1lLmBcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBvbkVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvbkVycm9yKGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0YXJnZXRTdGF0ZSA9IG5hbWUgIT09IG51bGwgPyB0aGlzLl9zdGF0ZXMuZ2V0KG5hbWUpIDogbnVsbDtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIG5ldyBzdGF0ZSBpc24ndCBhbHJlYWR5IHBsYXlpbmdcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEFuaW1hdGlvbiAhPT0gbmFtZSkge1xuICAgICAgICAgIC8vIFN3aXRjaCB0byB0aGUgbmV3IHN0YXRlIGltbWVkaWF0ZWx5XG4gICAgICAgICAgaWYgKHRyYW5zaXRpb25UaW1lIDw9IDApIHtcbiAgICAgICAgICAgIC8vIENhbmNlbCB0aGUgY3VycmVudCBzdGF0ZSBhbmQgc2V0IGl0cyB3ZWlnaHQgdG8gMFxuICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRTdGF0ZSkge1xuICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50U3RhdGUuY2FuY2VsKCk7XG4gICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZS53ZWlnaHQgPSAwO1xuICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50U3RhdGUuZGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50U3RhdGUgPSB0YXJnZXRTdGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQmxlbmQgdG8gdGhlIG5ldyBzdGF0ZSBvdmVyIHRpbWVcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0byB0cmFuc2l0aW9uIG91dCBvZiBhbnkgc3RhdGVzIHdpdGggbm9uLXplcm8gd2VpZ2h0XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U3RhdGVzID0gWy4uLnRoaXMuX3N0YXRlcy52YWx1ZXMoKV0uZmlsdGVyKFxuICAgICAgICAgICAgICBzID0+IHMgIT09IHRhcmdldFN0YXRlICYmIChzLndlaWdodCB8fCBzLndlaWdodFBlbmRpbmcpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHRyYW5zaXRpb24gc3RhdGUgd2l0aCBuZXcgaW5wdXRzXG4gICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uU3RhdGUuY29uZmlndXJlKFxuICAgICAgICAgICAgICBjdXJyZW50U3RhdGVzLFxuICAgICAgICAgICAgICB0YXJnZXRTdGF0ZSxcbiAgICAgICAgICAgICAgdHJhbnNpdGlvblRpbWUsXG4gICAgICAgICAgICAgIGVhc2luZ0ZuLFxuICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFN0YXRlID0gdGFyZ2V0U3RhdGU7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvblN0YXRlLndlaWdodCA9IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZSA9IHRoaXMuX3RyYW5zaXRpb25TdGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocGxheU1ldGhvZCA9PT0gJ3BsYXknKSB7XG4gICAgICAgICAgdGhpcy5fY3VycmVudFN0YXRlLmNhbmNlbCgpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRTdGF0ZSA9PT0gdGhpcy5fdHJhbnNpdGlvblN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uU3RhdGUucmVzZXQodHJhbnNpdGlvblRpbWUsIGVhc2luZ0ZuLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZSA9IHRhcmdldFN0YXRlO1xuICAgICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uU3RhdGUud2VpZ2h0ID0gMDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSB3ZWlnaHQgZm9yIHRoZSBuZXcgY3VycmVudCBzdGF0ZSBzbyBpdCBoYXMgZnVsbCBpbmZsdWVuY2UgZm9yIHRoZSBwbGF5ZXJcbiAgICAgICAgdGhpcy5fY3VycmVudFN0YXRlLndlaWdodCA9IDE7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZS51cGRhdGVJbnRlcm5hbFdlaWdodCh0aGlzLl9pbnRlcm5hbFdlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIHBsYXlBbmltYXRpb24oXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHRyYW5zaXRpb25UaW1lLFxuICAgICAgICBlYXNpbmdGbixcbiAgICAgICAgb25GaW5pc2gsXG4gICAgICAgIG9uRXJyb3IsXG4gICAgICAgIG9uQ2FuY2VsLFxuICAgICAgICBvbk5leHRcbiAgICAgICkge1xuICAgICAgICBsZXQgZXJyb3I7XG4gICAgICAgIGxldCByZWplY3QgPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLl9wcmVwYXJlQ3VycmVudFN0YXRlKFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICdwbGF5JyxcbiAgICAgICAgICAgIHRyYW5zaXRpb25UaW1lICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyB0cmFuc2l0aW9uVGltZVxuICAgICAgICAgICAgICA6IHRoaXMuX3RyYW5zaXRpb25UaW1lLFxuICAgICAgICAgICAgZWFzaW5nRm4gIT09IHVuZGVmaW5lZCA/IGVhc2luZ0ZuIDogdGhpcy5fZWFzaW5nRm4sXG4gICAgICAgICAgICBvbkVycm9yXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGVycm9yID0gZTtcbiAgICAgICAgICByZWplY3QgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlamVjdCkge1xuICAgICAgICAgIHJldHVybiBEZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRTdGF0ZS5wbGF5KG9uRmluaXNoLCBvbkVycm9yLCBvbkNhbmNlbCwgb25OZXh0KTtcbiAgICAgIH1cblxuICAgICAgcGF1c2VBbmltYXRpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50U3RhdGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFN0YXRlLnBhdXNlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlc3VtZUFuaW1hdGlvbihcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdHJhbnNpdGlvblRpbWUsXG4gICAgICAgIGVhc2luZ0ZuLFxuICAgICAgICBvbkZpbmlzaCxcbiAgICAgICAgb25FcnJvcixcbiAgICAgICAgb25DYW5jZWwsXG4gICAgICAgIG9uTmV4dFxuICAgICAgKSB7XG4gICAgICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQgJiYgdGhpcy5fY3VycmVudFN0YXRlKSB7XG4gICAgICAgICAgbmFtZSA9IHRoaXMuX2N1cnJlbnRTdGF0ZS5uYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGVycm9yO1xuICAgICAgICBsZXQgcmVqZWN0ID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5fcHJlcGFyZUN1cnJlbnRTdGF0ZShcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAncmVzdW1lJyxcbiAgICAgICAgICAgIHRyYW5zaXRpb25UaW1lICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyB0cmFuc2l0aW9uVGltZVxuICAgICAgICAgICAgICA6IHRoaXMuX3RyYW5zaXRpb25UaW1lLFxuICAgICAgICAgICAgZWFzaW5nRm4gIT09IHVuZGVmaW5lZCA/IGVhc2luZ0ZuIDogdGhpcy5fZWFzaW5nRm4sXG4gICAgICAgICAgICBvbkVycm9yXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGVycm9yID0gZTtcbiAgICAgICAgICByZWplY3QgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlamVjdCkge1xuICAgICAgICAgIHJldHVybiBEZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRTdGF0ZS5yZXN1bWUob25GaW5pc2gsIG9uRXJyb3IsIG9uQ2FuY2VsLCBvbk5leHQpO1xuICAgICAgfVxuXG4gICAgICBjYW5jZWxBbmltYXRpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50U3RhdGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFN0YXRlLmNhbmNlbCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdG9wQW5pbWF0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudFN0YXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRTdGF0ZS5zdG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZShkZWx0YVRpbWUpIHtcbiAgICAgICAgaWYgKHN1cGVyLnVwZGF0ZSkge1xuICAgICAgICAgIHN1cGVyLnVwZGF0ZShkZWx0YVRpbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRTdGF0ZSkge1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZS51cGRhdGUoZGVsdGFUaW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkaXNjYXJkKCkge1xuICAgICAgICBpZiAoc3VwZXIuZGlzY2FyZCkge1xuICAgICAgICAgIHN1cGVyLmRpc2NhcmQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25TdGF0ZS5kaXNjYXJkKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl90cmFuc2l0aW9uU3RhdGU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBBbmltYXRpb25QbGF5ZXJNaXhpbjtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBbmltYXRpb25QbGF5ZXJJbnRlcmZhY2U7XG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxuLyogZXNsaW50LWRpc2FibGUgbWF4LWNsYXNzZXMtcGVyLWZpbGUgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1lbXB0eS1mdW5jdGlvbiAqL1xuLyogZXNsaW50LWRpc2FibGUgZ2V0dGVyLXJldHVybiAqL1xuXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vLi4vVXRpbHMnO1xuXG4vKipcbiAqIENsYXNzIGZhY3RvcnkgaW50ZXJmYWNlIGZvciBtYW5pcHVsYXRpbmcgYSBjb2xsZWN0aW9uIG9mIHtAbGluayBBYnN0cmFjdFN0YXRlfS5cbiAqXG4gKiBAaW50ZXJmYWNlXG4gKi9cbmNsYXNzIFN0YXRlQ29udGFpbmVySW50ZXJmYWNlIHtcbiAgLyoqXG4gICAqIFJldHVybiB0aGUgc3RhdGUgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBzdGF0ZS5cbiAgICpcbiAgICogQHJldHVybnMge0Fic3RyYWN0U3RhdGV9XG4gICAqL1xuICBnZXRTdGF0ZShuYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuIGFycmF5IG9mIHRoZSBuYW1lcyBvZiBhbGwgc3RhdGVzIGluIHRoZSBjb250YWluZXIuXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAgICovXG4gIGdldFN0YXRlTmFtZXMoKSB7fVxuXG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgc3RhdGUgdG8gYmUgY29udHJvbGxlZCBieSB0aGUgY29udGFpbmVyLiBTdGF0ZXMgYXJlIHN0b3JlZCBrZXllZFxuICAgKiBieSB0aGVpciBuYW1lIHByb3BlcnR5LCB3aGljaCBtdXN0IGJlIHVuaXF1ZS4gSWYgaXQgaXNuJ3QsIGEgbnVtYmVyIHdpbGxcbiAgICogYmUgYWRkZWQgb3IgaW5jcmVtZW50ZWQgdW50aWwgYSB1bmlxdWUga2V5IGlzIGdlbmVyYXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtBYnN0cmFjdFN0YXRlfSBzdGF0ZSAtIFN0YXRlIHRvIGFkZCB0byB0aGUgY29udGFpbmVyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIFVuaXF1ZSBuYW1lIG9mIHRoZSBzdGF0ZS5cbiAgICovXG4gIGFkZFN0YXRlKHN0YXRlKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgc3RhdGUgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBmcm9tIHRoZSBjb250YWluZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgc3RhdGUgdG8gcmVtb3ZlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBXaGV0aGVyIG9yIG5vdCBhIHN0YXRlIHdhcyByZW1vdmVkLlxuICAgKi9cbiAgcmVtb3ZlU3RhdGUobmFtZSkge31cblxuICAvKipcbiAgICogUmVuYW1lcyBhIHN0YXRlIHdpdGggdGhlIGdpdmVuIG5hbWUgaW4gdGhlIGNvbnRhaW5lci4gTmFtZSBtdXN0IGJlIHVuaXF1ZVxuICAgKiB0byB0aGUgY29udGFpbmVyLCBpZiBpdCBpc24ndCB0aGUgbmFtZSB3aWxsIGJlIGluY3JlbWVudGVkIHVudGlsIGl0IGlzIHVuaXF1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGN1cnJlbnROYW1lIC0gTmFtZSBvZiB0aGUgc3RhdGUgdG8gcmVuYW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3TmFtZSAtIE5hbWUgdG8gdXBkYXRlIHRoZSBzdGF0ZSB3aXRoLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIFVwZGF0ZWQgbmFtZSBmb3IgdGhlIHN0YXRlLlxuICAgKi9cbiAgcmVuYW1lU3RhdGUoY3VycmVudE5hbWUsIG5ld05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIERpc2NhcmRzIGFsbCBzdGF0ZXMuXG4gICAqL1xuICBkaXNjYXJkU3RhdGVzKCkge31cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNsYXNzIHRoYXQgaW1wbGVtZW50cyB7QGxpbmsgU3RhdGVDb250YWluZXJJbnRlcmZhY2V9IGFuZCBleHRlbmRzXG4gICAqIGEgc3BlY2lmaWVkIGJhc2UgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2xhc3N9IFtCYXNlQ2xhc3MgPSBjbGFzc3t9XSAtIFRoZSBjbGFzcyB0byBleHRlbmQuXG4gICAqXG4gICAqIEByZXR1cm4ge0NsYXNzfSBBIGNsYXNzIHRoYXQgZXh0ZW5kcyBgQmFzZUNsYXNzYCBhbmQgaW1wbGVtZW50cyB7QGxpbmsgU3RhdGVDb250YWluZXJJbnRlcmZhY2V9LlxuICAgKi9cbiAgc3RhdGljIE1peGluKEJhc2VDbGFzcyA9IGNsYXNzIHt9KSB7XG4gICAgLyoqXG4gICAgICogVGhpcyBtaXhpbiBhZGRzIGZ1bmN0aW9uYWxpdHkgZm9yIG1hbmlwdWxhdGluZyB1bmlxdWVseS1uYW1lZCBhbmltYXRpb24gc3RhdGVzIGluXG4gICAgICogYSBtYXAuXG4gICAgICovXG4gICAgY29uc3QgU3RhdGVDb250YWluZXJNaXhpbiA9IGNsYXNzIGV4dGVuZHMgQmFzZUNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSwgLi4uYXJncykge1xuICAgICAgICBzdXBlcihvcHRpb25zLCAuLi5hcmdzKTtcblxuICAgICAgICB0aGlzLl9zdGF0ZXMgPSB0aGlzLl9zdGF0ZXMgIT09IHVuZGVmaW5lZCA/IHRoaXMuX3N0YXRlcyA6IG5ldyBNYXAoKTtcbiAgICAgIH1cblxuICAgICAgZ2V0U3RhdGUobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGVzLmdldChuYW1lKTtcbiAgICAgIH1cblxuICAgICAgZ2V0U3RhdGVOYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIFsuLi50aGlzLl9zdGF0ZXMua2V5cygpXTtcbiAgICAgIH1cblxuICAgICAgYWRkU3RhdGUoc3RhdGUpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBzdGF0ZSBpcyBub3QgYWxyZWFkeSBpbiB0aGlzIGNvbnRhaW5lclxuICAgICAgICBpZiAoWy4uLnRoaXMuX3N0YXRlcy52YWx1ZXMoKV0uaW5jbHVkZXMoc3RhdGUpKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgYENhbm5vdCBhZGQgYW5pbWF0aW9uIHRvIHN0YXRlICR7dGhpcy5uYW1lfS4gQW5pbWF0aW9uIHdhcyBhbHJlYWR5IGFkZGVkLmBcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBzdGF0ZS5uYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBzdGF0ZSBuYW1lIGlzIHVuaXF1ZVxuICAgICAgICBjb25zdCB1bmlxdWVOYW1lID0gVXRpbHMuZ2V0VW5pcXVlTmFtZShzdGF0ZS5uYW1lLCBbXG4gICAgICAgICAgLi4udGhpcy5fc3RhdGVzLmtleXMoKSxcbiAgICAgICAgXSk7XG5cbiAgICAgICAgaWYgKHN0YXRlLm5hbWUgIT09IHVuaXF1ZU5hbWUpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBgQW5pbWF0aW9uIG5hbWUgJHtzdGF0ZS5uYW1lfSBpcyBub3QgdW5pcXVlIGZvciBzdGF0ZSAke3RoaXMubmFtZX0uIE5ldyBhbmltYXRpb24gd2lsbCBiZSBhZGRlZCB3aXRoIG5hbWUgJHt1bmlxdWVOYW1lfS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzdGF0ZS5uYW1lID0gdW5pcXVlTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3N0YXRlcy5zZXQoc3RhdGUubmFtZSwgc3RhdGUpO1xuXG4gICAgICAgIHJldHVybiBzdGF0ZS5uYW1lO1xuICAgICAgfVxuXG4gICAgICByZW1vdmVTdGF0ZShuYW1lKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBzdGF0ZSBpcyBpbiB0aGlzIGNvbnRhaW5lclxuICAgICAgICBpZiAoIXRoaXMuX3N0YXRlcyB8fCAhdGhpcy5fc3RhdGVzLmhhcyhuYW1lKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIGBEaWQgbm90IHJlbW92ZSBhbmltYXRpb24gJHtuYW1lfSBmcm9tIHN0YXRlICR7dGhpcy5uYW1lfS4gTm8gYW5pbWF0aW9uIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zdGF0ZXMuZ2V0KG5hbWUpLmRpc2NhcmQoKTtcbiAgICAgICAgdGhpcy5fc3RhdGVzLmRlbGV0ZShuYW1lKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJlbmFtZVN0YXRlKGN1cnJlbnROYW1lLCBuZXdOYW1lKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgc3RhdGUgaXMgaW4gdGhpcyBjb250YWluZXJcbiAgICAgICAgaWYgKCF0aGlzLl9zdGF0ZXMgfHwgIXRoaXMuX3N0YXRlcy5oYXMoY3VycmVudE5hbWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYENhbm5vdCByZW5hbWUgYW5pbWF0aW9uICR7Y3VycmVudE5hbWV9IGluICR7dGhpcy5uYW1lfS4gTm8gYW5pbWF0aW9uIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGVzLmdldChjdXJyZW50TmFtZSk7XG5cbiAgICAgICAgLy8gRXhpdCBpZiB0aGUgbmFtZXMgYXJlIHRoZSBzYW1lXG4gICAgICAgIGlmIChjdXJyZW50TmFtZSA9PT0gbmV3TmFtZSkge1xuICAgICAgICAgIHJldHVybiBjdXJyZW50TmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgbmFtZSBpcyB1bmlxdWVcbiAgICAgICAgY29uc3QgdW5pcXVlTmFtZSA9IFV0aWxzLmdldFVuaXF1ZU5hbWUoXG4gICAgICAgICAgbmV3TmFtZSxcbiAgICAgICAgICBbLi4udGhpcy5fc3RhdGVzLmtleXMoKV0uZmlsdGVyKHMgPT4gcy5uYW1lICE9PSBjdXJyZW50TmFtZSlcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAobmV3TmFtZSAhPT0gdW5pcXVlTmFtZSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIGBBbmltYXRpb24gbmFtZSAke25ld05hbWV9IGlzIG5vdCB1bmlxdWUgaW4gc3RhdGUgJHt0aGlzLm5hbWV9LiBBbmltYXRpb24gd2lsbCBiZSByZW5hbWVkIHRvICR7dW5pcXVlTmFtZX0uYFxuICAgICAgICAgICk7XG4gICAgICAgICAgbmV3TmFtZSA9IHVuaXF1ZU5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5uYW1lID0gbmV3TmFtZTtcbiAgICAgICAgdGhpcy5fc3RhdGVzLmRlbGV0ZShjdXJyZW50TmFtZSk7XG4gICAgICAgIHRoaXMuX3N0YXRlcy5zZXQoc3RhdGUubmFtZSwgc3RhdGUpO1xuXG4gICAgICAgIHJldHVybiBzdGF0ZS5uYW1lO1xuICAgICAgfVxuXG4gICAgICBkaXNjYXJkU3RhdGVzKCkge1xuICAgICAgICB0aGlzLl9zdGF0ZXMuZm9yRWFjaChzdGF0ZSA9PiB7XG4gICAgICAgICAgc3RhdGUuZGlzY2FyZCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBkZWxldGUgdGhpcy5fc3RhdGVzO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN0YXRlQ29udGFpbmVyTWl4aW47XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IFN0YXRlQ29udGFpbmVySW50ZXJmYWNlO1xuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcbmltcG9ydCBBYnN0cmFjdFN0YXRlIGZyb20gJy4vQWJzdHJhY3RTdGF0ZSc7XG5pbXBvcnQgQW5pbWF0aW9uUGxheWVySW50ZXJmYWNlIGZyb20gJy4uL0FuaW1hdGlvblBsYXllckludGVyZmFjZSc7XG5pbXBvcnQgU3RhdGVDb250YWluZXJJbnRlcmZhY2UgZnJvbSAnLi9TdGF0ZUNvbnRhaW5lckludGVyZmFjZSc7XG5cbi8qKlxuICogQ2xhc3MgZm9yIHBsYXlpbmcgYW4gb3JkZXJlZCBhcnJheSBvZiBhbmltYXRpb24gc3RhdGVzIGluIHNlcXVlbmNlLlxuICpcbiAqIEBleHRlbmRzIEFic3RyYWN0U3RhdGVcbiAqIEBpbXBsZW1lbnRzIEBBbmltYXRpb25QbGF5ZXJJbnRlcmZhY2VcbiAqL1xuY2xhc3MgUXVldWVTdGF0ZSBleHRlbmRzIEFuaW1hdGlvblBsYXllckludGVyZmFjZS5NaXhpbihcbiAgU3RhdGVDb250YWluZXJJbnRlcmZhY2UuTWl4aW4oQWJzdHJhY3RTdGF0ZSlcbikge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gLSBPcHRpb25zIGZvciB0aGUgc3RhdGUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYXV0b0FkdmFuY2U9dHJ1ZV0gLSBXaGV0aGVyIHRvIGF1dG1hdGljYWxseSBhZHZhbmNlXG4gICAqIHRvIHRoZSBuZXh0IHN0YXRlIGluIHRoZSBxdWV1ZSBhcyBlYWNoIHN0YXRlIGNvbXBsZXRlcy5cbiAgICogQHBhcmFtIHtBcnJheS48QWJzdHJhY3RTdGF0ZT59IFtxdWV1ZVN0YXRlcz1bXV0gLSBBcnJheSBvZiBzdGF0ZXMgdG8gYmUgcGxheWVkXG4gICAqIGluIG9yZGVyLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9LCBxdWV1ZVN0YXRlcyA9IFtdKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICBxdWV1ZVN0YXRlcy5mb3JFYWNoKHN0YXRlID0+IHtcbiAgICAgIHRoaXMuYWRkU3RhdGUoc3RhdGUpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fcXVldWUgPSB0aGlzLl9zdGF0ZXMua2V5cygpO1xuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgd2hldGhlciB0aGUgYW5pbWF0aW9uIHF1ZXVlIGhhcyByZWFjaGVkIHRoZSBlbmQuXG4gICAqL1xuICBnZXQgZG9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZG9uZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBpbnRlcm5hbCB3ZWlnaHQuXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGludGVybmFsV2VpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50U3RhdGVcbiAgICAgID8gdGhpcy5fY3VycmVudFN0YXRlLmludGVybmFsV2VpZ2h0ICogdGhpcy5faW50ZXJuYWxXZWlnaHRcbiAgICAgIDogMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN0YXJ0IHRoZSBxdWV1ZSBpdGVyYXRvci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZXNldCgpIHtcbiAgICB0aGlzLl9xdWV1ZSA9IHRoaXMuX3N0YXRlcy5rZXlzKCk7XG4gICAgY29uc3Qge3ZhbHVlLCBkb25lfSA9IHRoaXMuX3F1ZXVlLm5leHQoKTtcbiAgICB0aGlzLl9kb25lID0gZG9uZTtcblxuICAgIHJldHVybiB2YWx1ZSB8fCBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIE11bHRpcGxpZXMgdGhlIHVzZXIgd2VpZ2h0IGJ5IGEgZmFjdG9yIHRvIGRldGVybWluZSB0aGUgaW50ZXJuYWwgd2VpZ2h0LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZmFjdG9yIC0gMC0xIG11bHRpcGxpZXIgdG8gYXBwbHkgdG8gdGhlIHVzZXIgd2VpZ2h0LlxuICAgKi9cbiAgdXBkYXRlSW50ZXJuYWxXZWlnaHQoZmFjdG9yKSB7XG4gICAgc3VwZXIudXBkYXRlSW50ZXJuYWxXZWlnaHQoZmFjdG9yKTtcblxuICAgIGlmICh0aGlzLl9jdXJyZW50U3RhdGUpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZS51cGRhdGVJbnRlcm5hbFdlaWdodCh0aGlzLl9pbnRlcm5hbFdlaWdodCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHRoZSBuZXh0IGFuaW1hdGlvbiBpbiB0aGUgcXVldWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbk5leHQgLSBGdW5jdGlvbiB0byBleGVjdXRlIGVhY2ggdGltZSBhbiBhbmltYXRpb24gY29tcGxldGVzXG4gICAqIGFuZCB0aGUgcXVldWUgbW92ZXMgdG8gdGhlIG5leHQgYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt3cmFwPWZhbHNlXSAtIFdoZXRoZXIgb3Igbm90IHRvIHN0YXJ0IHRoZSBxdWV1ZSBmcm9tIHRoZVxuICAgKiBiZWdpbm5pbmcgYWdhaW4gaWYgdGhlIGVuZCBoYXMgYmVlbiByZWFjaGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9XG4gICAqL1xuICBuZXh0KG9uTmV4dCwgd3JhcCA9IGZhbHNlKSB7XG4gICAgLy8gTW92ZSB0aGUgcXVldWUgZm9yd2FyZFxuICAgIGNvbnN0IHt2YWx1ZTogbmFtZSwgZG9uZX0gPSB0aGlzLl9xdWV1ZS5uZXh0KCk7XG4gICAgdGhpcy5fZG9uZSA9IGRvbmU7XG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG5cbiAgICAvLyBUaGUgcXVldWUgaGFzIHJlYWNoZWQgdGhlIGVuZFxuICAgIGlmIChkb25lKSB7XG4gICAgICAvLyBTdGFydCB0aGUgcXVldWUgb3ZlclxuICAgICAgaWYgKHdyYXApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGxheShcbiAgICAgICAgICB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uRmluaXNoLFxuICAgICAgICAgIHRoaXMuX3BsYXlDYWxsYmFja3Mub25FcnJvcixcbiAgICAgICAgICB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uQ2FuY2VsLFxuICAgICAgICAgIG9uTmV4dFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgLy8gU3RvcCB0aGUgcXVldWVcbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9wcm9taXNlcy5maW5pc2gucmVzb2x2ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvbWlzZXMuZmluaXNoO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNpZ25hbCB0aGUgbmV4dCBhbmltYXRpb24gaXMgc3RhcnRpbmdcbiAgICBpZiAodHlwZW9mIG9uTmV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3QgbGFzdE5hbWUgPSBbLi4udGhpcy5fc3RhdGVzLmtleXMoKV1bdGhpcy5fc3RhdGVzLnNpemUgLSAxXTtcbiAgICAgIGNvbnN0IGlzUXVldWVFbmQgPSBuYW1lID09PSBsYXN0TmFtZTtcbiAgICAgIG9uTmV4dCh7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGNhbkFkdmFuY2U6IHRoaXMuZ2V0U3RhdGUobmFtZSkubG9vcENvdW50ICE9PSBJbmZpbml0eSAmJiAhaXNRdWV1ZUVuZCxcbiAgICAgICAgaXNRdWV1ZUVuZCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFN0YXJ0IHRoZSBuZXh0IGFuaW1hdGlvblxuICAgIHRoaXMucGxheUFuaW1hdGlvbihcbiAgICAgIG5hbWUsXG4gICAgICB0aGlzLl90cmFuc2l0aW9uVGltZSxcbiAgICAgIHRoaXMuX2Vhc2luZ0ZuLFxuICAgICAgKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuX3BhdXNlZCAmJiAhdGhpcy5pc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgICAgICB0aGlzLm5leHQob25OZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRoaXMuX3BsYXlDYWxsYmFja3Mub25FcnJvclxuICAgICk7XG5cbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZXMuZmluaXNoO1xuICB9XG5cbiAgcGxheShvbkZpbmlzaCwgb25FcnJvciwgb25DYW5jZWwsIG9uTmV4dCkge1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9yZXNldCgpO1xuICAgIHN1cGVyLnBsYXkob25GaW5pc2gsIG9uRXJyb3IsIG9uQ2FuY2VsKTtcblxuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICB0aGlzLl9wcm9taXNlcy5maW5pc2gucmVzb2x2ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTaWduYWwgdGhlIG5leHQgYW5pbWF0aW9uIGlzIHN0YXJ0aW5nXG4gICAgICBpZiAobmFtZSAhPT0gdGhpcy5jdXJyZW50QW5pbWF0aW9uICYmIHR5cGVvZiBvbk5leHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgbGFzdE5hbWUgPSBbLi4udGhpcy5fc3RhdGVzLmtleXMoKV1bdGhpcy5fc3RhdGVzLnNpemUgLSAxXTtcbiAgICAgICAgY29uc3QgaXNRdWV1ZUVuZCA9IG5hbWUgPT09IGxhc3ROYW1lO1xuICAgICAgICBvbk5leHQoe1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgY2FuQWR2YW5jZTogbmFtZVxuICAgICAgICAgICAgPyB0aGlzLmdldFN0YXRlKG5hbWUpLmxvb3BDb3VudCAhPT0gSW5maW5pdHkgJiYgIWlzUXVldWVFbmRcbiAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICBpc1F1ZXVlRW5kOiAhbmFtZSB8fCBpc1F1ZXVlRW5kLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gU3RhcnQgdGhlIG5leHQgYW5pbWF0aW9uXG4gICAgICB0aGlzLnBsYXlBbmltYXRpb24oXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZSA/IHRoaXMuX3RyYW5zaXRpb25UaW1lIDogMCxcbiAgICAgICAgdGhpcy5fZWFzaW5nRm4sXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBpZiAoIXRoaXMuX3BhdXNlZCAmJiAhdGhpcy5pc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dChvbk5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvclxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZXMuZmluaXNoO1xuICB9XG5cbiAgcGF1c2UoKSB7XG4gICAgY29uc3QgcGF1c2VkID0gc3VwZXIucGF1c2UoKTtcbiAgICB0aGlzLnBhdXNlQW5pbWF0aW9uKCk7XG5cbiAgICByZXR1cm4gcGF1c2VkO1xuICB9XG5cbiAgcmVzdW1lKG9uRmluaXNoLCBvbkVycm9yLCBvbkNhbmNlbCwgb25OZXh0KSB7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBsYXkob25GaW5pc2gsIG9uRXJyb3IsIG9uQ2FuY2VsLCBvbk5leHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlci5yZXN1bWUob25GaW5pc2gsIG9uRXJyb3IsIG9uQ2FuY2VsKTtcblxuICAgICAgdGhpcy5yZXN1bWVBbmltYXRpb24oXG4gICAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZS5uYW1lLFxuICAgICAgICB0aGlzLl90cmFuc2l0aW9uVGltZSxcbiAgICAgICAgdGhpcy5fZWFzaW5nRm4sXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBpZiAoIXRoaXMuX3BhdXNlZCAmJiAhdGhpcy5pc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dChvbk5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvclxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHRoaXMuX3Byb21pc2VzLmZpbmlzaDtcbiAgICB9XG4gIH1cblxuICBjYW5jZWwoKSB7XG4gICAgY29uc3QgY2FuY2VsZWQgPSBzdXBlci5jYW5jZWwoKTtcblxuICAgIGlmICh0aGlzLl9jdXJyZW50U3RhdGUpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZS5jYW5jZWwoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FuY2VsZWQ7XG4gIH1cblxuICBzdG9wKCkge1xuICAgIGNvbnN0IHN0b3BwZWQgPSBzdXBlci5zdG9wKCk7XG4gICAgdGhpcy5zdG9wQW5pbWF0aW9uKCk7XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG5cbiAgICByZXR1cm4gc3RvcHBlZDtcbiAgfVxuXG4gIGRpc2NhcmQoKSB7XG4gICAgc3VwZXIuZGlzY2FyZCgpO1xuXG4gICAgdGhpcy5kaXNjYXJkU3RhdGVzKCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUXVldWVTdGF0ZTtcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXG5pbXBvcnQgRGVmZXJyZWQgZnJvbSAnY29yZS9EZWZlcnJlZCc7XG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gJ2NvcmUvTWF0aFV0aWxzJztcbmltcG9ydCBBYnN0cmFjdFN0YXRlIGZyb20gJy4vQWJzdHJhY3RTdGF0ZSc7XG5pbXBvcnQgU3RhdGVDb250YWluZXJJbnRlcmZhY2UgZnJvbSAnLi9TdGF0ZUNvbnRhaW5lckludGVyZmFjZSc7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYSBzdGF0ZSB0aGF0IGJsZW5kcyBhIGNvbGxlY3Rpb24gb2Yge0BsaW5rIEFic3RyYWN0U3RhdGV9LlxuICpcbiAqIEBhYnN0cmFjdFxuICogQGltcGxlbWVudHMgU3RhdGVDb250YWluZXJJbnRlcmZhY2VcbiAqL1xuY2xhc3MgQWJzdHJhY3RCbGVuZFN0YXRlIGV4dGVuZHMgU3RhdGVDb250YWluZXJJbnRlcmZhY2UuTWl4aW4oQWJzdHJhY3RTdGF0ZSkge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30sIGJsZW5kU3RhdGVzID0gW10sIC4uLmFyZ3MpIHtcbiAgICBzdXBlcihvcHRpb25zLCAuLi5hcmdzKTtcbiAgICBibGVuZFN0YXRlcy5mb3JFYWNoKHN0YXRlID0+IHtcbiAgICAgIHRoaXMuYWRkU3RhdGUoc3RhdGUpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHN1bSBvZiBpbnRlcm5hbCB3ZWlnaHRzIG9mIHRoZSBzdWItc3RhdGVzLlxuICAgKlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBpbnRlcm5hbFdlaWdodCgpIHtcbiAgICBsZXQgYmxlbmRXZWlnaHRzID0gMDtcbiAgICB0aGlzLl9zdGF0ZXMuZm9yRWFjaChzdGF0ZSA9PiB7XG4gICAgICBibGVuZFdlaWdodHMgKz0gc3RhdGUuaW50ZXJuYWxXZWlnaHQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIGJsZW5kV2VpZ2h0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3ZWlnaHQgb2YgYSBzdGF0ZSBjb250cm9sbGVkIGJ5IHRoZSBjb250YWluZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgc3RhdGUgdG8gcmV0dXJuIHRoZSB3ZWlnaHQgZnJvbS5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlcn0gLSBXZWlnaHQgb2YgdGhlIHN0YXRlLlxuICAgKi9cbiAgZ2V0QmxlbmRXZWlnaHQobmFtZSkge1xuICAgIC8vIE1ha2Ugc3VyZSB0aGUgbmFtZSBpcyB2YWxpZFxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRTdGF0ZShuYW1lKTtcbiAgICBpZiAoc3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGdldCB3ZWlnaHQgb2Ygc3RhdGUgJHtuYW1lfSBmcm9tIEJsZW5kU3RhdGUgJHt0aGlzLm5hbWV9LiBObyBzdGF0ZSBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdGUud2VpZ2h0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHdlaWdodCBvZiBhIHN0YXRlIGNvbnRyb2xsZWQgYnkgdGhlIGNvbnRhaW5lci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBzdGF0ZSB0byBzZXQgdGhlIHdlaWdodCBvZi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHdlaWdodCAtIFdlaWdodCB2YWx1ZSB0byBzZXQgb24gdGhlIHN0YXRlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9XG4gICAqL1xuICBzZXRCbGVuZFdlaWdodChuYW1lLCB3ZWlnaHQsIHNlY29uZHMgPSAwLCBlYXNpbmdGbikge1xuICAgIC8vIE1ha2Ugc3VyZSB0aGUgbmFtZSBpcyB2YWxpZFxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRTdGF0ZShuYW1lKTtcblxuICAgIGlmIChzdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3Qgc2V0IHdlaWdodCBvZiBzdGF0ZSAke25hbWV9IGZyb20gQmxlbmRTdGF0ZSAke3RoaXMubmFtZX0uIE5vIHN0YXRlIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gXG4gICAgICApO1xuICAgIH1cblxuICAgIHdlaWdodCA9IE1hdGhVdGlscy5jbGFtcCh3ZWlnaHQpO1xuICAgIHJldHVybiBzdGF0ZS5zZXRXZWlnaHQod2VpZ2h0LCBzZWNvbmRzLCBlYXNpbmdGbik7XG4gIH1cblxuICAvKipcbiAgICogTXVsdGlwbGllcyB0aGUgd2VpZ2h0IG9mIGVhY2ggc3ViLXN0YXRlIGJ5IGEgZmFjdG9yIHRvIGRldGVybWluZSB0aGUgaW50ZXJuYWwgd2VpZ2h0LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZmFjdG9yIC0gMC0xIG11bHRpcGxpZXIgdG8gYXBwbHkgdG8gdGhlIHVzZXIgd2VpZ2h0LlxuICAgKi9cbiAgdXBkYXRlSW50ZXJuYWxXZWlnaHQoZmFjdG9yKSB7XG4gICAgc3VwZXIudXBkYXRlSW50ZXJuYWxXZWlnaHQoZmFjdG9yKTtcblxuICAgIHRoaXMuX3N0YXRlcy5mb3JFYWNoKHN0YXRlID0+IHtcbiAgICAgIHN0YXRlLnVwZGF0ZUludGVybmFsV2VpZ2h0KHRoaXMuX2ludGVybmFsV2VpZ2h0KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgYW55IHZhbHVlcyBvZiB0aGUgc3ViLXN0YXRlcyB0aGF0IG5lZWQgdG8gYmUgZXZhbHVhdGVkIGV2ZXJ5IGZyYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFUaW1lIC0gVGltZSBpbiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGxhc3QgdXBkYXRlLlxuICAgKi9cbiAgdXBkYXRlKGRlbHRhVGltZSkge1xuICAgIHN1cGVyLnVwZGF0ZShkZWx0YVRpbWUpO1xuXG4gICAgdGhpcy5fc3RhdGVzLmZvckVhY2goc3RhdGUgPT4ge1xuICAgICAgc3RhdGUudXBkYXRlKGRlbHRhVGltZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgcGxheWJhY2sgb2YgdGhlIHN1Yi1zdGF0ZXMgZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25GaW5pc2ggLSBGdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIHN0YXRlIGZpbmlzaGVzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25FcnJvciAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgaWYgdGhlIHN0YXRlIGVuY291bnRlcnNcbiAgICogYW4gZXJyb3IgZHVyaW5nIHBsYXliYWNrLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25DYW5jZWwgLSBGdW5jdGlvbiB0byBleGVjdXRlIGlmIHBsYXliYWNrIGlzIGNhbmNlbGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9XG4gICAqL1xuICBwbGF5KG9uRmluaXNoLCBvbkVycm9yLCBvbkNhbmNlbCkge1xuICAgIGNvbnN0IHByb21pc2VzID0gW3N1cGVyLnBsYXkoKV07XG5cbiAgICB0aGlzLl9zdGF0ZXMuZm9yRWFjaChzdGF0ZSA9PiB7XG4gICAgICBwcm9taXNlcy5wdXNoKHN0YXRlLnBsYXkoKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIERlZmVycmVkLmFsbChwcm9taXNlcywgb25GaW5pc2gsIG9uRXJyb3IsIG9uQ2FuY2VsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXVzZSBwbGF5YmFjayBvZiB0aGUgc3ViLXN0YXRlcy4gVGhpcyBwcmV2ZW50cyBwZW5kaW5nIHByb21pc2VzIGZyb20gYmVpbmcgZXhlY3V0ZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgcGF1c2UoKSB7XG4gICAgdGhpcy5fc3RhdGVzLmZvckVhY2goc3RhdGUgPT4ge1xuICAgICAgc3RhdGUucGF1c2UoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gc3VwZXIucGF1c2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN1bWUgcGxheWJhY2sgb2YgdGhlIHN1Yi1zdGF0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkZpbmlzaCAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgc3RhdGUgZmluaXNoZXMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkVycm9yIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBpZiB0aGUgc3RhdGUgZW5jb3VudGVyc1xuICAgKiBhbiBlcnJvciBkdXJpbmcgcGxheWJhY2suXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkNhbmNlbCAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgaWYgcGxheWJhY2sgaXMgY2FuY2VsZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH1cbiAgICovXG4gIHJlc3VtZShvbkZpbmlzaCwgb25FcnJvciwgb25DYW5jZWwpIHtcbiAgICBjb25zdCBwcm9taXNlcyA9IFtzdXBlci5yZXN1bWUoKV07XG5cbiAgICB0aGlzLl9zdGF0ZXMuZm9yRWFjaChzdGF0ZSA9PiB7XG4gICAgICBwcm9taXNlcy5wdXNoKHN0YXRlLnJlc3VtZSgpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gRGVmZXJyZWQuYWxsKHByb21pc2VzLCBvbkZpbmlzaCwgb25FcnJvciwgb25DYW5jZWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbCBwbGF5YmFjayBvZiB0aGUgc3ViLXN0YXRlcyBhbmQgY2FuY2VsIGFueSBwZW5kaW5nIHByb21pc2VzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGNhbmNlbCgpIHtcbiAgICB0aGlzLl9zdGF0ZXMuZm9yRWFjaChzdGF0ZSA9PiB7XG4gICAgICBzdGF0ZS5jYW5jZWwoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gc3VwZXIuY2FuY2VsKCk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCBwbGF5YmFjayBvZiB0aGUgc3ViLXN0YXRlcyBhbmQgcmVzb2x2ZSBhbnkgcGVuZGluZyBwcm9taXNlcy5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdG9wKCkge1xuICAgIHRoaXMuX3N0YXRlcy5mb3JFYWNoKHN0YXRlID0+IHtcbiAgICAgIHN0YXRlLnN0b3AoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gc3VwZXIuc3RvcCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc2NhcmRzIGFsbCBzdWItc3RhdGUgcmVzb3VyY2VzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGRpc2NhcmQoKSB7XG4gICAgc3VwZXIuZGlzY2FyZCgpO1xuXG4gICAgdGhpcy5kaXNjYXJkU3RhdGVzKCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQWJzdHJhY3RCbGVuZFN0YXRlO1xuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcbmltcG9ydCBBYnN0cmFjdEJsZW5kU3RhdGUgZnJvbSAnLi9BYnN0cmFjdEJsZW5kU3RhdGUnO1xuXG4vKipcbiAqIENsYXNzIGZvciBibGVuZGluZyBOIG51bWJlciBvZiBibGVuZCBzdGF0ZXMuXG4gKlxuICogQGV4dGVuZHMgQWJzdHJhY3RCbGVuZFN0YXRlXG4gKi9cbmNsYXNzIEZyZWVCbGVuZFN0YXRlIGV4dGVuZHMgQWJzdHJhY3RCbGVuZFN0YXRlIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIC0gT3B0aW9ucyBmb3IgdGhlIGNvbnRhaW5lciBzdGF0ZS5cbiAgICogQHBhcmFtIHtBcnJheS48QWJzdHJhY3RTdGF0ZT59IFtibGVuZFN0YXRlcz1bXV0gLSBCbGVuZCBzdGF0ZXMgdG8gYmUgY29udHJvbGxlZCBieVxuICAgKiB0aGlzIGNvbnRhaW5lci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSwgYmxlbmRTdGF0ZXMgPSBbXSkge1xuICAgIHN1cGVyKG9wdGlvbnMsIGJsZW5kU3RhdGVzKTtcbiAgfVxuXG4gIHVwZGF0ZUludGVybmFsV2VpZ2h0KGZhY3Rvcikge1xuICAgIHN1cGVyLnVwZGF0ZUludGVybmFsV2VpZ2h0KGZhY3Rvcik7XG5cbiAgICAvLyBEZXRlcm1pbmUgdGhlIHRvdGFsIGFjdGl2ZSB3ZWlnaHQgb2YgYmxlbmQgc3RhdGVzXG4gICAgbGV0IHN1bVdlaWdodHMgPSAwO1xuXG4gICAgdGhpcy5fc3RhdGVzLmZvckVhY2goc3RhdGUgPT4ge1xuICAgICAgc3VtV2VpZ2h0cyArPSBzdGF0ZS53ZWlnaHQ7XG4gICAgfSk7XG5cbiAgICAvLyBFbnN1cmUgdGhlIHN1bSBvZiBibGVuZCBzdGF0ZSBpbnRlcm5hbCB3ZWlnaHRzIGRvZXMgbm90IGV4Y2VlZCBjb250YWluZXIgaW50ZXJuYWwgd2VpZ2h0XG4gICAgZmFjdG9yIC89IE1hdGgubWF4KHN1bVdlaWdodHMsIDEpO1xuXG4gICAgLy8gU3VtIG9mIGJsZW5kIHN0YXRlIGludGVybmFsIHdlaWdodHMgc2hvdWxkIG5vdCBleGNlZWQgY29udGFpbmVyIGludGVybmFsIHdlaWdodFxuICAgIHRoaXMuX3N0YXRlcy5mb3JFYWNoKHN0YXRlID0+IHtcbiAgICAgIHN0YXRlLnVwZGF0ZUludGVybmFsV2VpZ2h0KGZhY3RvciAqIHRoaXMuX3dlaWdodCk7XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRnJlZUJsZW5kU3RhdGU7XG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxuaW1wb3J0IERlZmVycmVkIGZyb20gJ2NvcmUvRGVmZXJyZWQnO1xuaW1wb3J0IEFic3RyYWN0QmxlbmRTdGF0ZSBmcm9tICcuL0Fic3RyYWN0QmxlbmRTdGF0ZSc7XG5pbXBvcnQgQW5pbWF0aW9uVXRpbHMgZnJvbSAnLi4vQW5pbWF0aW9uVXRpbHMnO1xuXG4vKipcbiAqIENsYXNzIGZvciBibGVuZGluZyBOIG51bWJlciBvZiBibGVuZCBzdGF0ZXMgYmFzZWQgb24gYSBzaW5nbGVcbiAqIHBhcmFtZXRlci5cbiAqXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEJsZW5kU3RhdGVcbiAqL1xuY2xhc3MgQmxlbmQxZFN0YXRlIGV4dGVuZHMgQWJzdHJhY3RCbGVuZFN0YXRlIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucyBmb3IgdGhlIGNvbnRhaW5lciBzdGF0ZVxuICAgKiBAcGFyYW0ge0FycmF5LjxBYnN0cmFjdEJsZW5kU3RhdGU+fSBbYmxlbmRTdGF0ZXM9W11dIC0gQmxlbmQgc3RhdGVzIHRvIGJlXG4gICAqIGNvbnRyb2xsZWQgYnkgdGhpcyBjb250YWluZXIuXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtibGVuZFRocmVzaG9sZHM9W11dIC0gVGhyZXNob2xkIHZhbHVlcyBmb3IgYWN0aXZhdGluZ1xuICAgKiBlYWNoIGJsZW5kIHN0YXRlLlxuICAgKiBAcGFyYW0ge0FycmF5Ljxib29sZWFuPn0gW3BoYXNlTWF0Y2hlcz1bXV0gLSBCb29sZWFucyBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90XG4gICAqIGVhY2ggYmxlbmQgc3RhdGUgc2hvdWxkIGJlIHBoYXNlIG1hdGNoZWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBvcHRpb25zID0ge30sXG4gICAgYmxlbmRTdGF0ZXMgPSBbXSxcbiAgICBibGVuZFRocmVzaG9sZHMgPSBbXSxcbiAgICBwaGFzZU1hdGNoZXMgPSBbXVxuICApIHtcbiAgICBzdXBlcihvcHRpb25zLCBibGVuZFN0YXRlcyk7XG5cbiAgICB0aGlzLl9ibGVuZFZhbHVlID0gMDtcbiAgICB0aGlzLl9wcm9taXNlcyA9IHtcbiAgICAgIC4uLnRoaXMuX3Byb21pc2VzLFxuICAgICAgYmxlbmRWYWx1ZTogRGVmZXJyZWQucmVzb2x2ZSgpLFxuICAgIH07XG5cbiAgICAvLyBWYWxpZGF0ZSB0aGVyZSBhcmUgbm8gZHVwbGljYXRlIHRocmVzaG9sZHNcbiAgICBjb25zdCBub25aZXJvRGlmZmVyZW50U2l6ZSA9XG4gICAgICBibGVuZFN0YXRlcy5sZW5ndGggIT09IDAgJiYgYmxlbmRTdGF0ZXMubGVuZ3RoICE9PSBibGVuZFRocmVzaG9sZHMubGVuZ3RoO1xuICAgIGlmIChub25aZXJvRGlmZmVyZW50U2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGNyZWF0ZSBCbGVuZDFkU3RhdGUgd2l0aCBibGVuZFRocmVzaG9sZHMgJHtibGVuZFRocmVzaG9sZHN9LiBCbGVuZFRocmVzaG9sZHMgY291bnQgZG9lcyBub3QgbWF0Y2ggYmxlbmRTdGF0ZXMgY291bnQuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb250YWluc0R1cGxpY2F0ZXMgPVxuICAgICAgbmV3IFNldChibGVuZFRocmVzaG9sZHMpLnNpemUgIT09IGJsZW5kVGhyZXNob2xkcy5sZW5ndGg7XG4gICAgaWYgKGNvbnRhaW5zRHVwbGljYXRlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGNyZWF0ZSBCbGVuZDFkU3RhdGUgd2l0aCBibGVuZFRocmVzaG9sZHMgJHtibGVuZFRocmVzaG9sZHN9LiBCbGVuZFRocmVzaG9sZHMgY29udGFpbnMgZHVwbGljYXRlIHZhbHVlc2BcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgdGhyZXNob2xkcyBtYXBcbiAgICB0aGlzLl90aHJlc2hvbGRzID0gW107XG4gICAgWy4uLnRoaXMuX3N0YXRlcy52YWx1ZXMoKV0uZm9yRWFjaCgoc3RhdGUsIGluZGV4KSA9PiB7XG4gICAgICB0aGlzLl90aHJlc2hvbGRzLnB1c2goe1xuICAgICAgICB2YWx1ZTogYmxlbmRUaHJlc2hvbGRzW2luZGV4XSxcbiAgICAgICAgbmFtZTogc3RhdGUubmFtZSxcbiAgICAgICAgcGhhc2VNYXRjaDogcGhhc2VNYXRjaGVzW2luZGV4XSB8fCBmYWxzZSxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fc29ydFRocmVzaG9sZHMoKTtcbiAgICB0aGlzLl9mb3JjZU5vVGhyZXNob2xkRHVwZXMgPSB0cnVlO1xuXG4gICAgdGhpcy5fcGhhc2VMZWFkU3RhdGUgPSBudWxsO1xuXG4gICAgdGhpcy5fdXBkYXRlQmxlbmRXZWlnaHRzKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbmQgc2V0cyB0aGUgYmxlbmQgcGFyYW1ldGVyIHZhbHVlLlxuICAgKi9cbiAgZ2V0IGJsZW5kVmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JsZW5kVmFsdWU7XG4gIH1cblxuICBzZXQgYmxlbmRWYWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMuX2JsZW5kVmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHdoZXRoZXIgb3Igbm90IHRoZSBibGVuZCB2YWx1ZSBpcyBjdXJyZW50bHkgYmVpbmcgYW5pbWF0ZWQuXG4gICAqL1xuICBnZXQgYmxlbmRWYWx1ZVBlbmRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VzLmJsZW5kVmFsdWUgJiYgdGhpcy5fcHJvbWlzZXMuYmxlbmRWYWx1ZS5wZW5kaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHVzZXIgZGVmaW5lZCB3ZWlnaHQgb3ZlciB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge251bGx9IG5hbWUgLSBVbnVzZWQgcGFyYW1ldGVyLlxuICAgKiBAcGFyYW0ge251bWJlcn0gd2VpZ2h0IC0gVGhlIHRhcmdldCB3ZWlnaHQgdmFsdWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2Vjb25kcz0wXSAtIFRoZSBhbW91bnQgb2YgdGltZSBpdCB3aWxsIHRha2UgdG8gcmVhY2ggdGhlXG4gICAqIHRhcmdldCB3ZWlnaHQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBlYXNpbmdGbiAtIFRoZSBlYXNpbmcgZnVuY3Rpb24gdG8gdXNlIGZvciBpbnRlcnBvbGF0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9XG4gICAqL1xuICBzZXRCbGVuZFdlaWdodChuYW1lLCB2YWx1ZSwgc2Vjb25kcyA9IDAsIGVhc2luZ0ZuKSB7XG4gICAgdGhpcy5fcHJvbWlzZXMuYmxlbmRWYWx1ZS5jYW5jZWwoKTtcblxuICAgIHRoaXMuX3Byb21pc2VzLmJsZW5kVmFsdWUgPSBBbmltYXRpb25VdGlscy5pbnRlcnBvbGF0ZVByb3BlcnR5KFxuICAgICAgdGhpcyxcbiAgICAgICdibGVuZFZhbHVlJyxcbiAgICAgIHZhbHVlLFxuICAgICAge1xuICAgICAgICBzZWNvbmRzLFxuICAgICAgICBlYXNpbmdGbixcbiAgICAgICAgb25Qcm9ncmVzczogKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZUJsZW5kV2VpZ2h0cygpO1xuICAgICAgICB9LFxuICAgICAgICBvbkZpbmlzaDogKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZUJsZW5kV2VpZ2h0cygpO1xuICAgICAgICB9LFxuICAgICAgfVxuICAgICk7XG5cbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZXMuYmxlbmRWYWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB1c2VyIGRlZmluZWQgd2VpZ2h0LlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0QmxlbmRXZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmxlbmRWYWx1ZTtcbiAgfVxuXG4gIGFkZFN0YXRlKHN0YXRlLCB0aHJlc2hvbGRWYWx1ZSA9IDAsIHBoYXNlTWF0Y2ggPSBmYWxzZSkge1xuICAgIHRoaXMuX3RocmVzaG9sZHMgPSB0aGlzLl90aHJlc2hvbGRzIHx8IFtdO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoZXJlIGlzIG5vdCBhbHJlYWR5IGEgc3RhdGUgd2l0aCB0aGlzIHRocmVzaG9sZFxuICAgIGNvbnN0IHNhbWVWYWx1ZSA9IHRoaXMuX3RocmVzaG9sZHMuZmluZChcbiAgICAgIHRocmVzaG9sZCA9PiB0aHJlc2hvbGQudmFsdWUgPT09IHRocmVzaG9sZFZhbHVlXG4gICAgKTtcbiAgICBpZiAodGhpcy5fZm9yY2VOb1RocmVzaG9sZER1cGVzICYmIHNhbWVWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3Qgc2V0IGJsZW5kIHRocmVzaG9sZCBvZiAke3RocmVzaG9sZFZhbHVlfSBmb3Igc3RhdGUgJHtzdGF0ZS5uYW1lfSBvbiAke3RoaXMubmFtZX0uIEEgc3RhdGUgYWxyZWFkeSBleGlzdHMgd2l0aCB0aGF0IHRocmVzaG9sZC5gXG4gICAgICApO1xuICAgIH1cblxuICAgIHN1cGVyLmFkZFN0YXRlKHN0YXRlKTtcbiAgICB0aGlzLl90aHJlc2hvbGRzLnB1c2goe1xuICAgICAgdmFsdWU6IHRocmVzaG9sZFZhbHVlLFxuICAgICAgbmFtZTogc3RhdGUubmFtZSxcbiAgICAgIHBoYXNlTWF0Y2g6IHBoYXNlTWF0Y2ggfHwgZmFsc2UsXG4gICAgfSk7XG5cbiAgICB0aGlzLl9zb3J0VGhyZXNob2xkcygpO1xuXG4gICAgcmV0dXJuIHN0YXRlLm5hbWU7XG4gIH1cblxuICByZW1vdmVTdGF0ZShuYW1lKSB7XG4gICAgY29uc3QgcmVtb3ZlZCA9IHN1cGVyLnJlbW92ZVN0YXRlKG5hbWUpO1xuXG4gICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fdGhyZXNob2xkcy5maW5kSW5kZXgoXG4gICAgICAgIHRocmVzaG9sZCA9PiB0aHJlc2hvbGQubmFtZSA9PT0gbmFtZVxuICAgICAgKTtcbiAgICAgIHRoaXMuX3RocmVzaG9sZHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVtb3ZlZDtcbiAgfVxuXG4gIHJlbmFtZVN0YXRlKGN1cnJlbnROYW1lLCBuZXdOYW1lKSB7XG4gICAgbmV3TmFtZSA9IHN1cGVyLnJlbmFtZVN0YXRlKGN1cnJlbnROYW1lLCBuZXdOYW1lKTtcblxuICAgIGNvbnN0IHRocmVzaG9sZCA9IHRoaXMuX3RocmVzaG9sZHMuZmluZChcbiAgICAgIHRocmVzaG9sZCA9PiB0aHJlc2hvbGQubmFtZSA9PT0gY3VycmVudE5hbWVcbiAgICApO1xuICAgIHRocmVzaG9sZC5uYW1lID0gbmV3TmFtZTtcblxuICAgIHJldHVybiBuZXdOYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHRocmVzaG9sZCB2YWx1ZSBvZiBhIGJsZW5kIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBibGVuZCB0byBnZXQgdGhlIHRocmVzaG9sZCBvZi5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlcn0gVGhyZWhvbGQgdmFsdWUuXG4gICAqL1xuICBnZXRCbGVuZFRocmVzaG9sZChuYW1lKSB7XG4gICAgY29uc3QgdGhyZXNob2xkID0gdGhpcy5fdGhyZXNob2xkcy5maW5kKFxuICAgICAgdGhyZXNob2xkID0+IHRocmVzaG9sZC5uYW1lID09PSBuYW1lXG4gICAgKTtcblxuICAgIGlmICh0aHJlc2hvbGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGdldCBibGVuZCB0aHJlc2hvbGQgb2Ygc3RhdGUgJHtuYW1lfSBvbiAke3RoaXMubmFtZX0uIE5vIHN0YXRlIGV4aXN0cyB3aXRoIHRoYXQgbmFtZS5gXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB0aHJlc2hvbGQudmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdGhyZXNob2xkIHZhbHVlIG9mIGEgYmxlbmQgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIGJsZW5kIHRvIHNldCB0aGUgdGhyZXNob2xkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBWYWx1ZSBvZiB0aGUgdGhyZXNob2xkIHRvIHNldC5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlcn0gU2V0IHRocmVzaG9sZCB2YWx1ZS5cbiAgICovXG4gIHNldEJsZW5kVGhyZXNob2xkKG5hbWUsIHZhbHVlKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoZXJlIGlzIG5vdCBhbHJlYWR5IGEgc3RhdGUgd2l0aCB0aGlzIHRocmVzaG9sZFxuICAgIGNvbnN0IHNhbWVWYWx1ZSA9IHRoaXMuX3RocmVzaG9sZHMuZmluZChcbiAgICAgIHRocmVzaG9sZCA9PiB0aHJlc2hvbGQudmFsdWUgPT09IHZhbHVlXG4gICAgKTtcbiAgICBpZiAoc2FtZVZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBzZXQgYmxlbmQgdGhyZXNob2xkIG9mICR7dmFsdWV9IGZvciBzdGF0ZSAke25hbWV9IG9uICR7dGhpcy5uYW1lfS4gQSBzdGF0ZSBhbHJlYWR5IGV4aXN0cyB3aXRoIHRoYXQgdGhyZXNob2xkLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgdGhyZXNob2xkID0gdGhpcy5fdGhyZXNob2xkcy5maW5kKFxuICAgICAgdGhyZXNob2xkID0+IHRocmVzaG9sZC5uYW1lID09PSBuYW1lXG4gICAgKTtcblxuICAgIGlmICh0aHJlc2hvbGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IHNldCBibGVuZCB0aHJlc2hvbGQgb2Ygc3RhdGUgJHtuYW1lfSBvbiAke3RoaXMubmFtZX0uIE5vIHN0YXRlIGV4aXN0cyB3aXRoIHRoYXQgbmFtZS5gXG4gICAgICApO1xuICAgIH1cblxuICAgIHRocmVzaG9sZC52YWx1ZSA9IHZhbHVlO1xuXG4gICAgdGhpcy5fc29ydFRocmVzaG9sZHMoKTtcblxuICAgIHJldHVybiB0aHJlc2hvbGQudmFsdWU7XG4gIH1cblxuICB1cGRhdGVJbnRlcm5hbFdlaWdodChmYWN0b3IpIHtcbiAgICBzdXBlci51cGRhdGVJbnRlcm5hbFdlaWdodChmYWN0b3IpO1xuXG4gICAgaWYgKHRoaXMuX3BoYXNlTGVhZFN0YXRlKSB7XG4gICAgICB0aGlzLl9zdGF0ZXMuZm9yRWFjaChzdGF0ZSA9PiB7XG4gICAgICAgIGlmIChzdGF0ZS53ZWlnaHQgIT09IDApIHtcbiAgICAgICAgICBzdGF0ZS5ub3JtYWxpemVkVGltZSA9IHRoaXMuX3BoYXNlTGVhZFN0YXRlLm5vcm1hbGl6ZWRUaW1lO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgYmxlbmQgd2VpZ2h0cyBiYXNlZCBvbiB0aGVpciBjb3JyZXNwb25kaW5nIHRocmVzaG9sZCB2YWx1ZXNcbiAgICogYW5kIHRoZSBjdXJyZW50IGJsZW5kVmFsdWUuIEFkZGl0aW9uYWxseSwgc2V0cyBhIGxlYWQgcGhhc2Ugc3RhdGUgaWYgdGhlXG4gICAqIGNvbmRpdGlvbnMgZm9yIHBoYXNlLW1hdGNoaW5nIGhhdmUgYmVlbiBzYXRpc2ZpZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlQmxlbmRXZWlnaHRzKCkge1xuICAgIGlmICh0aGlzLl90aHJlc2hvbGRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgaWYgKHRoaXMuX3RocmVzaG9sZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlcy5nZXQodGhpcy5fdGhyZXNob2xkc1swXS5uYW1lKTtcbiAgICAgIHN0YXRlLnNldFdlaWdodCgxKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsbHkgc2V0IGFsbCBzdWItc3RhdGUgd2VpZ2h0cyB0byB6ZXJvXG4gICAgdGhpcy5fc3RhdGVzLmZvckVhY2goc3RhdGUgPT4ge1xuICAgICAgc3RhdGUuc2V0V2VpZ2h0KDApO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fcGhhc2VMZWFkU3RhdGUgPSBudWxsO1xuXG4gICAgLy8gRmluZCB0aGUgZmlyc3QgdGhyZXNob2xkIHRoYXQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwYXJhbWV0ZXIgdmFsdWVcbiAgICBsZXQgdGFyZ2V0SW5kZXggPSB0aGlzLl90aHJlc2hvbGRzLmZpbmRJbmRleCh0aHJlc2hvbGQgPT4ge1xuICAgICAgcmV0dXJuIHRocmVzaG9sZC52YWx1ZSA+PSB0aGlzLl9ibGVuZFZhbHVlO1xuICAgIH0pO1xuXG4gICAgaWYgKHRhcmdldEluZGV4ID09PSAwIHx8IHRhcmdldEluZGV4ID09PSAtMSkge1xuICAgICAgLy8gR2l2ZSBvbmUgc3RhdGUgZnVsbCBpbmZsdWVuY2VcbiAgICAgIHRhcmdldEluZGV4ID0gdGFyZ2V0SW5kZXggPT09IC0xID8gdGhpcy5fdGhyZXNob2xkcy5sZW5ndGggLSAxIDogMDtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGVzLmdldCh0aGlzLl90aHJlc2hvbGRzW3RhcmdldEluZGV4XS5uYW1lKTtcbiAgICAgIHN0YXRlLnNldFdlaWdodCgxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGluZWFyIGludGVycG9sYXRlIGluZmx1ZW5jZSBiZXR3ZWVuIHR3byBzdGF0ZXNcbiAgICAgIGNvbnN0IHRocmVzaG9sZEEgPSB0aGlzLl90aHJlc2hvbGRzW3RhcmdldEluZGV4IC0gMV07XG4gICAgICBjb25zdCB0aHJlc2hvbGRCID0gdGhpcy5fdGhyZXNob2xkc1t0YXJnZXRJbmRleF07XG5cbiAgICAgIGNvbnN0IGZhY3RvckIgPVxuICAgICAgICAodGhpcy5ibGVuZFZhbHVlIC0gdGhyZXNob2xkQS52YWx1ZSkgL1xuICAgICAgICAodGhyZXNob2xkQi52YWx1ZSAtIHRocmVzaG9sZEEudmFsdWUpO1xuICAgICAgY29uc3QgZmFjdG9yQSA9IDEgLSBmYWN0b3JCO1xuXG4gICAgICBjb25zdCBzdGF0ZUEgPSB0aGlzLl9zdGF0ZXMuZ2V0KHRocmVzaG9sZEEubmFtZSk7XG4gICAgICBjb25zdCBzdGF0ZUIgPSB0aGlzLl9zdGF0ZXMuZ2V0KHRocmVzaG9sZEIubmFtZSk7XG5cbiAgICAgIHN0YXRlQS5zZXRXZWlnaHQoZmFjdG9yQSk7XG4gICAgICBzdGF0ZUIuc2V0V2VpZ2h0KGZhY3RvckIpO1xuXG4gICAgICAvLyBTZXQgcGhhc2UtbWF0Y2hpbmcgaWYgbmVlZGVkXG4gICAgICBpZiAodGhyZXNob2xkQS5waGFzZU1hdGNoICYmIHRocmVzaG9sZEIucGhhc2VNYXRjaCkge1xuICAgICAgICB0aGlzLl9waGFzZUxlYWRTdGF0ZSA9IGZhY3RvckEgPiBmYWN0b3JCID8gc3RhdGVBIDogc3RhdGVCO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTb3J0cyB0aGUgdGhyZXNob2xkcyBmcm9tIGxvdyB0byBoaWdoIGJhc2VkIG9uIHZhbHVlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NvcnRUaHJlc2hvbGRzKCkge1xuICAgIHRoaXMuX3RocmVzaG9sZHMuc29ydCgoYSwgYikgPT4gYS52YWx1ZSAtIGIudmFsdWUpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJsZW5kMWRTdGF0ZTtcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlcnNjb3JlLWRhbmdsZSAqL1xuaW1wb3J0IERlZmVycmVkIGZyb20gJ2NvcmUvRGVmZXJyZWQnO1xuaW1wb3J0IE1hdGhVdGlscyBmcm9tICdjb3JlL01hdGhVdGlscyc7XG5pbXBvcnQgQWJzdHJhY3RCbGVuZFN0YXRlIGZyb20gJy4vQWJzdHJhY3RCbGVuZFN0YXRlJztcbmltcG9ydCBBbmltYXRpb25VdGlscyBmcm9tICcuLi9BbmltYXRpb25VdGlscyc7XG5cbi8qKlxuICogQ2xhc3MgZm9yIGJsZW5kaW5nIE4gbnVtYmVyIG9mIGJsZW5kIHN0YXRlcyBiYXNlZCBvbiB0d29cbiAqIHBhcmFtdGVycy5cbiAqXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEJsZW5kU3RhdGVcbiAqL1xuY2xhc3MgQmxlbmQyZFN0YXRlIGV4dGVuZHMgQWJzdHJhY3RCbGVuZFN0YXRlIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucyBmb3IgdGhlIGNvbnRhaW5lciBzdGF0ZVxuICAgKiBAcGFyYW0ge0FycmF5LjxBYnN0cmFjdEJsZW5kU3RhdGU+fSBbYmxlbmRTdGF0ZXM9W11dIC0gQmxlbmQgc3RhdGVzIHRvIGJlXG4gICAqIGNvbnRyb2xsZWQgYnkgdGhpcyBjb250YWluZXIuXG4gICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gW2JsZW5kVGhyZXNob2xkcz1bXV0gLSBUaHJlc2hvbGQgdmFsdWVzIGZvciBhY3RpdmF0aW5nXG4gICAqIGVhY2ggYmxlbmQgc3RhdGUuXG4gICAqIEBwYXJhbSB7QXJyYXkuPGJvb2xlYW4+fSBbcGhhc2VNYXRjaGVzPVtdXSAtIEJvb2xlYW5zIGluZGljYXRpbmcgd2hldGhlciBvciBub3RcbiAgICogZWFjaCBibGVuZCBzdGF0ZSBzaG91bGQgYmUgcGhhc2UgbWF0Y2hlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIG9wdGlvbnMgPSB7fSxcbiAgICBibGVuZFN0YXRlcyA9IFtdLFxuICAgIGJsZW5kVGhyZXNob2xkcyA9IFtdLFxuICAgIHBoYXNlTWF0Y2hlcyA9IFtdXG4gICkge1xuICAgIHN1cGVyKG9wdGlvbnMsIGJsZW5kU3RhdGVzKTtcblxuICAgIGlmIChibGVuZFN0YXRlcy5sZW5ndGggIT09IGJsZW5kVGhyZXNob2xkcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBjcmVhdGUgQmxlbmQyZFN0YXRlIHdpdGggYmxlbmRTdGF0ZXMgJHtibGVuZFN0YXRlc30gYW5kIGJsZW5kVGhyZXNob2xkcyAke2JsZW5kVGhyZXNob2xkc30uIENvdW50IG9mIGJsZW5kU3RhdGVzIG11c3QgbWF0Y2ggY291bnQgb2YgYmxlbmRUaHJlc2hvbGRzLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgYmxlbmRUaHJlc2hvbGRzXG4gICAgICAuc2xpY2UoMCwgYmxlbmRUaHJlc2hvbGRzLmxlbmd0aCAtIDEpXG4gICAgICAuZm9yRWFjaCgodGhyZXNob2xkLCBpbmRleCkgPT4ge1xuICAgICAgICBibGVuZFRocmVzaG9sZHMuc2xpY2UoaW5kZXggKyAxKS5mb3JFYWNoKG90aGVyVGhyZXNob2xkID0+IHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aHJlc2hvbGRbMF0gPT09IG90aGVyVGhyZXNob2xkWzBdICYmXG4gICAgICAgICAgICB0aHJlc2hvbGRbMV0gPT09IG90aGVyVGhyZXNob2xkWzFdXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBDYW5ub3QgY3JlYXRlIEJsZW5kMmRTdGF0ZSB3aXRoIGJsZW5kVGhyZXNob2xkcyAke2JsZW5kVGhyZXNob2xkc30uIE5vIGR1cGxpY2F0ZSB2YWx1ZXMgYWxsb3dlZCBpbiBibGVuZFRocmVzaG9sZHMuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICB0aGlzLl9ibGVuZFZhbHVlWCA9IDA7XG4gICAgdGhpcy5fYmxlbmRWYWx1ZVkgPSAwO1xuXG4gICAgdGhpcy5fcHJvbWlzZXMgPSB7XG4gICAgICAuLi50aGlzLl9wcm9taXNlcyxcbiAgICAgIGJsZW5kVmFsdWVYOiBEZWZlcnJlZC5yZXNvbHZlKCksXG4gICAgICBibGVuZFZhbHVlWTogRGVmZXJyZWQucmVzb2x2ZSgpLFxuICAgIH07XG5cbiAgICB0aGlzLl90aHJlc2hvbGRzID0gW107XG4gICAgWy4uLnRoaXMuX3N0YXRlcy52YWx1ZXMoKV0uZm9yRWFjaCgoc3RhdGUsIGluZGV4KSA9PiB7XG4gICAgICB0aGlzLl90aHJlc2hvbGRzLnB1c2goe1xuICAgICAgICBuYW1lOiBzdGF0ZS5uYW1lLFxuICAgICAgICBwaGFzZU1hdGNoOiBwaGFzZU1hdGNoZXNbaW5kZXhdIHx8IGZhbHNlLFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl92ZXJ0aWNlcyA9IGJsZW5kVGhyZXNob2xkcztcblxuICAgIGlmICh0aGlzLl92ZXJ0aWNlcy5sZW5ndGggPj0gMykge1xuICAgICAgdGhpcy5fdHJpYW5nbGVzID0gTWF0aFV0aWxzLmdldERlbGF1bmF5VHJpYW5ndWxhdGlvbih0aGlzLl92ZXJ0aWNlcyk7XG4gICAgfVxuXG4gICAgdGhpcy5fcGhhc2VMZWFkU3RhdGUgPSBudWxsO1xuXG4gICAgdGhpcy5fdXBkYXRlQmxlbmRXZWlnaHRzKCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgdXNlciBkZWZpbmVkIHdlaWdodCBvdmVyIHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBvZiBibGVuZCB3ZWlnaHQgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gd2VpZ2h0IC0gVGFyZ2V0IHdlaWdodCB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzZWNvbmRzPTBdIC0gVGhlIGFtb3VudCBvZiB0aW1lIGl0IHdpbGwgdGFrZSB0byByZWFjaCB0aGVcbiAgICogdGFyZ2V0IHZhbHVlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gZWFzaW5nRm4gLSBUaGUgZWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSBmb3IgaW50ZXJwb2xhdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMge0RlZmVycmVkfVxuICAgKi9cbiAgc2V0QmxlbmRXZWlnaHQobmFtZSwgdmFsdWUsIHNlY29uZHMgPSAwLCBlYXNpbmdGbikge1xuICAgIGNvbnN0IHByb3BlcnR5ID0gYGJsZW5kVmFsdWUke25hbWUudG9VcHBlckNhc2UoKX1gO1xuICAgIGlmIChwcm9wZXJ0eSAhPT0gJ2JsZW5kVmFsdWVYJyAmJiBwcm9wZXJ0eSAhPT0gJ2JsZW5kVmFsdWVZJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IHNldCBibGVuZCB3ZWlnaHQgZm9yICR7bmFtZX0gb24gJHt0aGlzLm5hbWV9LiBCbGVuZDJkU3RhdGUgb25seSBhY2NlcHRzICdYJyBvciAnWScgZm9yIHNldEJsZW5kV2VpZ2h0YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wcm9taXNlc1twcm9wZXJ0eV0uY2FuY2VsKCk7XG5cbiAgICB0aGlzLl9wcm9taXNlc1twcm9wZXJ0eV0gPSBBbmltYXRpb25VdGlscy5pbnRlcnBvbGF0ZVByb3BlcnR5KFxuICAgICAgdGhpcyxcbiAgICAgIHByb3BlcnR5LFxuICAgICAgdmFsdWUsXG4gICAgICB7XG4gICAgICAgIHNlY29uZHMsXG4gICAgICAgIGVhc2luZ0ZuLFxuICAgICAgICBvblByb2dyZXNzOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlQmxlbmRXZWlnaHRzKCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRmluaXNoOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlQmxlbmRXZWlnaHRzKCk7XG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgKTtcblxuICAgIHJldHVybiB0aGlzLl9wcm9taXNlc1twcm9wZXJ0eV07XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdXNlciBkZWZpbmVkIHdlaWdodC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIGJsZW5kIHdlaWdodC5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGdldEJsZW5kV2VpZ2h0KG5hbWUpIHtcbiAgICBjb25zdCBwcm9wZXJ0eSA9IG5hbWUudG9VcHBlckNhc2UoKTtcbiAgICBpZiAocHJvcGVydHkgIT09ICdYJyAmJiBwcm9wZXJ0eSAhPT0gJ1knKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgZ2V0IGJsZW5kIHdlaWdodCBmb3IgJHtuYW1lfSBvbiAke3RoaXMubmFtZX0uIEJsZW5kMmRTdGF0ZSBvbmx5IGFjY2VwdHMgJ1gnIG9yICdZJyBmb3IgZ2V0QmxlbmRXZWlnaHRgXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9wZXJ0eSA9PT0gJ1gnID8gdGhpcy5fYmxlbmRWYWx1ZVggOiB0aGlzLl9ibGVuZFZhbHVlWTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuZCBzZXRzIHRoZSB4IGJsZW5kIHdlaWdodC5cbiAgICovXG4gIGdldCBibGVuZFZhbHVlWCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmxlbmRWYWx1ZVg7XG4gIH1cblxuICBzZXQgYmxlbmRWYWx1ZVgodmFsdWUpIHtcbiAgICB0aGlzLl9ibGVuZFZhbHVlWCA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW5kIHNldHMgdGhlIHkgYmxlbmQgd2VpZ2h0LlxuICAgKi9cbiAgZ2V0IGJsZW5kVmFsdWVZKCkge1xuICAgIHJldHVybiB0aGlzLl9ibGVuZFZhbHVlWTtcbiAgfVxuXG4gIHNldCBibGVuZFZhbHVlWSh2YWx1ZSkge1xuICAgIHRoaXMuX2JsZW5kVmFsdWVZID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgeCBibGVuZCB2YWx1ZSBpcyBjdXJyZW50bHkgYmVpbmcgYW5pbWF0ZWQuXG4gICAqL1xuICBnZXQgYmxlbmRWYWx1ZVhQZW5kaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm9taXNlcy5ibGVuZFZhbHVlWCAmJiB0aGlzLl9wcm9taXNlcy5ibGVuZFZhbHVlWC5wZW5kaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgd2hldGhlciBvciBub3QgdGhlIHkgYmxlbmQgdmFsdWUgaXMgY3VycmVudGx5IGJlaW5nIGFuaW1hdGVkLlxuICAgKi9cbiAgZ2V0IGJsZW5kVmFsdWVZUGVuZGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZXMuYmxlbmRWYWx1ZVkgJiYgdGhpcy5fcHJvbWlzZXMuYmxlbmRWYWx1ZVkucGVuZGluZztcbiAgfVxuXG4gIHVwZGF0ZUludGVybmFsV2VpZ2h0KGZhY3Rvcikge1xuICAgIHN1cGVyLnVwZGF0ZUludGVybmFsV2VpZ2h0KGZhY3Rvcik7XG5cbiAgICBpZiAodGhpcy5fcGhhc2VMZWFkU3RhdGUpIHtcbiAgICAgIFsuLi50aGlzLl9zdGF0ZXMudmFsdWVzKCldLmZvckVhY2goKHN0YXRlLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoc3RhdGUud2VpZ2h0ICE9PSAwICYmIHRoaXMuX3RocmVzaG9sZHNbaW5kZXhdLnBoYXNlTWF0Y2gpIHtcbiAgICAgICAgICBzdGF0ZS5ub3JtYWxpemVkVGltZSA9IHRoaXMuX3BoYXNlTGVhZFN0YXRlLm5vcm1hbGl6ZWRUaW1lO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgYmxlbmQgd2VpZ2h0cyBiYXNlZCBvbiB0aGVpciBjb3JyZXNwb25kaW5nIHRocmVzaG9sZCB2YWx1ZXNcbiAgICogYW5kIHRoZSBjdXJyZW50IFt4LHldIGJsZW5kVmFsdWUuIEFkZGl0aW9uYWxseSwgc2V0cyBhIGxlYWQgcGhhc2Ugc3RhdGUgaWYgdGhlXG4gICAqIGNvbmRpdGlvbnMgZm9yIHBoYXNlLW1hdGNoaW5nIGhhdmUgYmVlbiBzYXRpc2ZpZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlQmxlbmRXZWlnaHRzKCkge1xuICAgIGlmICghdGhpcy5fdmVydGljZXMgfHwgdGhpcy5fdmVydGljZXMubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICBpZiAodGhpcy5fdmVydGljZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICBbLi4udGhpcy5fc3RhdGVzLnZhbHVlcygpXVswXS53ZWlnaHQgPSAxO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxseSBzZXQgYWxsIHN1Yi1zdGF0ZSB3ZWlnaHRzIHRvIHplcm9cbiAgICB0aGlzLl9zdGF0ZXMuZm9yRWFjaChzdGF0ZSA9PiB7XG4gICAgICBzdGF0ZS5zZXRXZWlnaHQoMCk7XG4gICAgfSk7XG4gICAgdGhpcy5fcGhhc2VMZWFkU3RhdGUgPSBudWxsO1xuXG4gICAgY29uc3QgcCA9IFt0aGlzLl9ibGVuZFZhbHVlWCwgdGhpcy5fYmxlbmRWYWx1ZVldO1xuXG4gICAgaWYgKHRoaXMuX3ZlcnRpY2VzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdGhpcy5fc2V0SW5mbHVlbmNlQ2xvc2VzdFBvaW50T25MaW5lKHApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0cmlhbmdsZSA9IHRoaXMuX3RyaWFuZ2xlcy5maW5kKHRyaWFuZ2xlID0+IHtcbiAgICAgICAgcmV0dXJuIE1hdGhVdGlscy5pc1BvaW50SW5UcmlhbmdsZShcbiAgICAgICAgICB0aGlzLl92ZXJ0aWNlc1t0cmlhbmdsZVswXV0sXG4gICAgICAgICAgdGhpcy5fdmVydGljZXNbdHJpYW5nbGVbMV1dLFxuICAgICAgICAgIHRoaXMuX3ZlcnRpY2VzW3RyaWFuZ2xlWzJdXSxcbiAgICAgICAgICBwXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRyaWFuZ2xlKSB7XG4gICAgICAgIHRoaXMuX3NldEluZmx1ZW5jZVRyaWFuZ2xlKHRyaWFuZ2xlLCBwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NldEluZmx1ZW5jZUNsb3Nlc3RQb2ludEluVHJpYW5nbGVzKHApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGJsZW5kIHdlaWdodHMgZm9yIHN0YXRlcyBjb3JyZXNwb25kaW5nIHRvIGFcbiAgICogdHJpYW5nbGUgb2YgdGhyZXNob2xkcyBhbmQgYSBnaXZlbiBbeCx5XSBibGVuZFZhbHVlcy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSB0cmlhbmdsZSAtIFNldCBvZiB0cmlhbmdsdWF0ZWQgaW5kaWNlc1xuICAgKiB0aGF0IGNvcnJlc3BvbmQgdG8gYmxlbmQgdGhyZXNob2xkcy5cbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcCAtIEdpdmVuIFt4LHldIGJsZW5kVmFsdWUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0SW5mbHVlbmNlVHJpYW5nbGUodHJpYW5nbGUsIHApIHtcbiAgICBjb25zdCBhcmVhQSA9IE1hdGhVdGlscy50cmlhbmdsZUFyZWEoXG4gICAgICB0aGlzLl92ZXJ0aWNlc1t0cmlhbmdsZVsxXV0sXG4gICAgICB0aGlzLl92ZXJ0aWNlc1t0cmlhbmdsZVsyXV0sXG4gICAgICBwXG4gICAgKTtcblxuICAgIGNvbnN0IGFyZWFCID0gTWF0aFV0aWxzLnRyaWFuZ2xlQXJlYShcbiAgICAgIHRoaXMuX3ZlcnRpY2VzW3RyaWFuZ2xlWzBdXSxcbiAgICAgIHRoaXMuX3ZlcnRpY2VzW3RyaWFuZ2xlWzJdXSxcbiAgICAgIHBcbiAgICApO1xuXG4gICAgY29uc3QgYXJlYUMgPSBNYXRoVXRpbHMudHJpYW5nbGVBcmVhKFxuICAgICAgdGhpcy5fdmVydGljZXNbdHJpYW5nbGVbMF1dLFxuICAgICAgdGhpcy5fdmVydGljZXNbdHJpYW5nbGVbMV1dLFxuICAgICAgcFxuICAgICk7XG5cbiAgICBjb25zdCB0b3RhbEFyZWEgPSBhcmVhQSArIGFyZWFCICsgYXJlYUM7XG5cbiAgICBjb25zdCB3ZWlnaHRBID0gYXJlYUEgLyB0b3RhbEFyZWE7XG4gICAgY29uc3Qgd2VpZ2h0QiA9IGFyZWFCIC8gdG90YWxBcmVhO1xuICAgIGNvbnN0IHdlaWdodEMgPSBhcmVhQyAvIHRvdGFsQXJlYTtcblxuICAgIGNvbnN0IHRocmVzaG9sZEEgPSB0aGlzLl90aHJlc2hvbGRzW3RyaWFuZ2xlWzBdXTtcbiAgICBjb25zdCB0aHJlc2hvbGRCID0gdGhpcy5fdGhyZXNob2xkc1t0cmlhbmdsZVsxXV07XG4gICAgY29uc3QgdGhyZXNob2xkQyA9IHRoaXMuX3RocmVzaG9sZHNbdHJpYW5nbGVbMl1dO1xuXG4gICAgY29uc3Qgc3RhdGVBID0gdGhpcy5fc3RhdGVzLmdldCh0aHJlc2hvbGRBLm5hbWUpO1xuICAgIGNvbnN0IHN0YXRlQiA9IHRoaXMuX3N0YXRlcy5nZXQodGhyZXNob2xkQi5uYW1lKTtcbiAgICBjb25zdCBzdGF0ZUMgPSB0aGlzLl9zdGF0ZXMuZ2V0KHRocmVzaG9sZEMubmFtZSk7XG5cbiAgICBzdGF0ZUEuc2V0V2VpZ2h0KHdlaWdodEEpO1xuICAgIHN0YXRlQi5zZXRXZWlnaHQod2VpZ2h0Qik7XG4gICAgc3RhdGVDLnNldFdlaWdodCh3ZWlnaHRDKTtcblxuICAgIHRoaXMuX3NldFBoYXNlTGVhZFN0YXRlKFxuICAgICAgW3N0YXRlQSwgc3RhdGVCLCBzdGF0ZUNdLFxuICAgICAgW3RocmVzaG9sZEEucGhhc2VNYXRjaCwgdGhyZXNob2xkQi5waGFzZU1hdGNoLCB0aHJlc2hvbGRDLnBoYXNlTWF0Y2hdXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBjbG9zZXN0IHBvaW50IHdpdGhpbiBhIHRyaWFuZ2xlIG9mXG4gICAqIHRocmVzaG9sZHMgYmFzZWQgb24gdGhlIGN1cnJlbnQgW3gseV0gYmxlbmRWYWx1ZXMgYW5kXG4gICAqIHRoZW4gc2V0cyBibGVuZCB3ZWlnaHRzIGZvciB0aGUgY29ycmVzcG9uZGluZyBzdGF0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHAgLSBHaXZlbiBbeCx5XSBibGVuZFZhbHVlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldEluZmx1ZW5jZUNsb3Nlc3RQb2ludEluVHJpYW5nbGVzKHApIHtcbiAgICBsZXQgZ2xvYmFsQ2xvc2VzdFBvaW50ID0gbnVsbDtcbiAgICBsZXQgZ2xvYmFsTWluRGlzdCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgY2xvc2VzdFRyaWFuZ2xlID0gLTE7XG5cbiAgICB0aGlzLl90cmlhbmdsZXMuZm9yRWFjaCgodHJpYW5nbGUsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBwb2ludEEgPSBNYXRoVXRpbHMuY2xvc2VzdFBvaW50T25MaW5lKFxuICAgICAgICB0aGlzLl92ZXJ0aWNlc1t0cmlhbmdsZVswXV0sXG4gICAgICAgIHRoaXMuX3ZlcnRpY2VzW3RyaWFuZ2xlWzFdXSxcbiAgICAgICAgcFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHBvaW50QiA9IE1hdGhVdGlscy5jbG9zZXN0UG9pbnRPbkxpbmUoXG4gICAgICAgIHRoaXMuX3ZlcnRpY2VzW3RyaWFuZ2xlWzFdXSxcbiAgICAgICAgdGhpcy5fdmVydGljZXNbdHJpYW5nbGVbMl1dLFxuICAgICAgICBwXG4gICAgICApO1xuICAgICAgY29uc3QgcG9pbnRDID0gTWF0aFV0aWxzLmNsb3Nlc3RQb2ludE9uTGluZShcbiAgICAgICAgdGhpcy5fdmVydGljZXNbdHJpYW5nbGVbMl1dLFxuICAgICAgICB0aGlzLl92ZXJ0aWNlc1t0cmlhbmdsZVswXV0sXG4gICAgICAgIHBcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGRpc3RBID0gTWF0aFV0aWxzLmRpc3RhbmNlU3F1YXJlZChwb2ludEEsIHApO1xuICAgICAgY29uc3QgZGlzdEIgPSBNYXRoVXRpbHMuZGlzdGFuY2VTcXVhcmVkKHBvaW50QiwgcCk7XG4gICAgICBjb25zdCBkaXN0QyA9IE1hdGhVdGlscy5kaXN0YW5jZVNxdWFyZWQocG9pbnRDLCBwKTtcblxuICAgICAgbGV0IGxvY2FsQ2xvc2VzdFBvaW50ID0gcG9pbnRDO1xuICAgICAgbGV0IGxvY2FsTWluRGlzdCA9IGRpc3RDO1xuXG4gICAgICBpZiAoZGlzdEEgPCBsb2NhbE1pbkRpc3QpIHtcbiAgICAgICAgbG9jYWxDbG9zZXN0UG9pbnQgPSBwb2ludEE7XG4gICAgICAgIGxvY2FsTWluRGlzdCA9IGRpc3RBO1xuICAgICAgfVxuICAgICAgaWYgKGRpc3RCIDwgbG9jYWxNaW5EaXN0KSB7XG4gICAgICAgIGxvY2FsQ2xvc2VzdFBvaW50ID0gcG9pbnRCO1xuICAgICAgICBsb2NhbE1pbkRpc3QgPSBkaXN0QjtcbiAgICAgIH1cblxuICAgICAgaWYgKGxvY2FsTWluRGlzdCA8IGdsb2JhbE1pbkRpc3QpIHtcbiAgICAgICAgZ2xvYmFsTWluRGlzdCA9IGxvY2FsTWluRGlzdDtcbiAgICAgICAgZ2xvYmFsQ2xvc2VzdFBvaW50ID0gWy4uLmxvY2FsQ2xvc2VzdFBvaW50XTtcbiAgICAgICAgY2xvc2VzdFRyaWFuZ2xlID0gaW5kZXg7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLl9zZXRJbmZsdWVuY2VUcmlhbmdsZShcbiAgICAgIHRoaXMuX3RyaWFuZ2xlc1tjbG9zZXN0VHJpYW5nbGVdLFxuICAgICAgZ2xvYmFsQ2xvc2VzdFBvaW50XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSBsaW5lIGZvcm1lZCBiZXR3ZWVuIHRoZVxuICAgKiB0d28gYmxlbmQgdGhyZXNob2xkcyBiYXNlZCBvbiB0aGUgY3VycmVudCBbeCx5XSBibGVuZFZhbHVlcyBhbmRcbiAgICogdGhlbiBzZXRzIGJsZW5kIHdlaWdodHMgZm9yIHRoZSBjb3JyZXNwb25kaW5nIHN0YXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcCAtIEdpdmVuIFt4LHldIGJsZW5kVmFsdWUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0SW5mbHVlbmNlQ2xvc2VzdFBvaW50T25MaW5lKHApIHtcbiAgICBjb25zdCBjbG9zZXN0UG9pbnQgPSBNYXRoVXRpbHMuY2xvc2VzdFBvaW50T25MaW5lKFxuICAgICAgdGhpcy5fdmVydGljZXNbWzBdXSxcbiAgICAgIHRoaXMuX3ZlcnRpY2VzW1sxXV0sXG4gICAgICBwXG4gICAgKTtcblxuICAgIGNvbnN0IGRpc3RBID0gTWF0aFV0aWxzLmRpc3RhbmNlU3F1YXJlZCh0aGlzLl92ZXJ0aWNlc1swXSwgY2xvc2VzdFBvaW50KTtcbiAgICBjb25zdCBkaXN0QiA9IE1hdGhVdGlscy5kaXN0YW5jZVNxdWFyZWQodGhpcy5fdmVydGljZXNbMV0sIGNsb3Nlc3RQb2ludCk7XG5cbiAgICBjb25zdCB3ZWlnaHRBID0gZGlzdEIgLyAoZGlzdEEgKyBkaXN0Qik7XG4gICAgY29uc3Qgd2VpZ2h0QiA9IGRpc3RBIC8gKGRpc3RBICsgZGlzdEIpO1xuXG4gICAgY29uc3QgdGhyZXNob2xkQSA9IHRoaXMuX3RocmVzaG9sZHNbMF07XG4gICAgY29uc3QgdGhyZXNob2xkQiA9IHRoaXMuX3RocmVzaG9sZHNbMV07XG5cbiAgICBjb25zdCBzdGF0ZUEgPSB0aGlzLl9zdGF0ZXMuZ2V0KHRocmVzaG9sZEEubmFtZSk7XG4gICAgY29uc3Qgc3RhdGVCID0gdGhpcy5fc3RhdGVzLmdldCh0aHJlc2hvbGRCLm5hbWUpO1xuXG4gICAgc3RhdGVBLnNldFdlaWdodCh3ZWlnaHRBKTtcbiAgICBzdGF0ZUIuc2V0V2VpZ2h0KHdlaWdodEIpO1xuXG4gICAgdGhpcy5fc2V0UGhhc2VMZWFkU3RhdGUoXG4gICAgICBbc3RhdGVBLCBzdGF0ZUJdLFxuICAgICAgW3RocmVzaG9sZEEucGhhc2VNYXRjaCwgdGhyZXNob2xkQi5waGFzZU1hdGNoXVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIGxlYWQgcGhhc2Ugc3RhdGUgaWYgdGhlIGNvbmRpdGlvbnNcbiAgICogZm9yIHBoYXNlLW1hdGNoaW5nIGFyZSBzYXRpc2ZpZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXkuPEFic3RyYWN0QmxlbmRTdGF0ZT59IHN0YXRlcyAtIFN0YXRlcyB0b1xuICAgKiBjaGVjayBwaGFzZS1tYXRjaGluZyBjcml0ZXJpYS5cbiAgICogQHBhcmFtIHtBcnJheS48Ym9vbGVhbj59IHBoYXNlTWF0Y2hlZCAtIExpc3Qgb2YgcGhhc2UtbWF0Y2ggYm9vbGVhbnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0UGhhc2VMZWFkU3RhdGUoc3RhdGVzLCBwaGFzZU1hdGNoZWQpIHtcbiAgICBsZXQgbWF4ID0gMDtcbiAgICBzdGF0ZXMuZm9yRWFjaCgoc3RhdGUsIGluZGV4KSA9PiB7XG4gICAgICBpZiAocGhhc2VNYXRjaGVkW2luZGV4XSAmJiBzdGF0ZS53ZWlnaHQgPiBtYXgpIHtcbiAgICAgICAgdGhpcy5fcGhhc2VMZWFkU3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgbWF4ID0gc3RhdGUud2VpZ2h0O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJsZW5kMmRTdGF0ZTtcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXG5pbXBvcnQgQWJzdHJhY3RCbGVuZFN0YXRlIGZyb20gJy4vc3RhdGUvQWJzdHJhY3RCbGVuZFN0YXRlJztcbmltcG9ydCBBbmltYXRpb25QbGF5ZXJJbnRlcmZhY2UgZnJvbSAnLi9BbmltYXRpb25QbGF5ZXJJbnRlcmZhY2UnO1xuaW1wb3J0IEFuaW1hdGlvblV0aWxzIGZyb20gJy4vQW5pbWF0aW9uVXRpbHMnO1xuaW1wb3J0IE1hdGhVdGlscyBmcm9tICcuLi9NYXRoVXRpbHMnO1xuaW1wb3J0IERlZmVycmVkIGZyb20gJy4uL0RlZmVycmVkJztcbmltcG9ydCBTdGF0ZUNvbnRhaW5lckludGVyZmFjZSBmcm9tICcuL3N0YXRlL1N0YXRlQ29udGFpbmVySW50ZXJmYWNlJztcblxuLyoqXG4gKiBFbnVtIGZvciB0eXBlcyBvZiB7QGxpbmsgQW5pbWF0aW9uTGF5ZXJ9IGJsZW5kaW5nLlxuICpcbiAqIEByZWFkb25seVxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IExheWVyQmxlbmRNb2RlcyA9IHtPdmVycmlkZTogJ092ZXJyaWRlJywgQWRkaXRpdmU6ICdBZGRpdGl2ZSd9O1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGJsZW5kaW5nIG1vZGUge0BsaW5rIEFuaW1hdGlvbkxheWVyfS5cbiAqXG4gKiBAcmVhZG9ubHlcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBEZWZhdWx0TGF5ZXJCbGVuZE1vZGUgPSAnT3ZlcnJpZGUnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIGJsZW5kTW9kZSBpcyBwcmVzZW50IGluIHRoZSB2YWx1ZXMgb2Yge0BsaW5rIExheWVyQmxlbmRNb2Rlc30uXG4gKiBJZiBpdCBpcywgcmV0dXJuIHRoZSBvcmlnaW5hbCB2YWx1ZSwgb3RoZXJ3aXNlIHJldHVybiB7QGxpbmsgRGVmYXVsdExheWVyQmxlbmRNb2RlfS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmxlbmRNb2RlIC0gVGhlIG5hbWUgb2YgdGhlIHR5cGUgb2YgYmxlbmRpbmcuXG4gKlxuICogQHJldHVybnMgeyhzdHJpbmd8RGVmYXVsdExheWVyQmxlbmRNb2RlKX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQmxlbmRNb2RlKGJsZW5kTW9kZSkge1xuICBpZiAoQXJyYXkuZnJvbShPYmplY3QudmFsdWVzKExheWVyQmxlbmRNb2RlcykpLmluY2x1ZGVzKGJsZW5kTW9kZSkpIHtcbiAgICByZXR1cm4gYmxlbmRNb2RlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBEZWZhdWx0TGF5ZXJCbGVuZE1vZGU7XG4gIH1cbn1cblxuLyoqXG4gKiBDbGFzcyBmb3IgbWFuYWdpbmcgYSBzZXQgb2YgYW5pbWF0aW9ucyB3aGVyZSBvbmx5IG9uZSBzdGF0ZSBjYW4gYmUgYWN0aXZlIGF0XG4gKiBhbnkgZ2l2ZW4gdGltZS5cbiAqXG4gKiBAaW1wbGVtZW50cyBBbmltYXRpb25QbGF5ZXJJbnRlcmZhY2VcbiAqIEBpbXBsZW1lbnRzIFN0YXRlQ29udGFpbmVySW50ZXJmYWNlXG4gKi9cbmNsYXNzIEFuaW1hdGlvbkxheWVyIGV4dGVuZHMgQW5pbWF0aW9uUGxheWVySW50ZXJmYWNlLk1peGluKFxuICBTdGF0ZUNvbnRhaW5lckludGVyZmFjZS5NaXhpbigpXG4pIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgLSAgT3B0aW9ucyBmb3IgdGhlIGFuaW1hdGlvbiBsYXllci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyLiBOYW1lcyBtdXN0IGJlIHVuaXF1ZSB0byB0aGVcbiAgICogYW5pbWF0aW9uIGZlYXR1cmUgdGhhdCBjb250YWlucyB0aGUgbGF5ZXIuXG4gICAqIEBwYXJhbSB7TGF5ZXJCbGVuZE1vZGVzfSBbb3B0aW9ucy5ibGVuZE1vZGU9RGVmYXVsdExheWVyQmxlbmRNb2RlXSAtXG4gICAqIFR5cGUgb2YgYmxlbmRpbmcgdG8gdXNlIGZvciBhbGwgc3RhdGVzIGNvbnRyb2xsZWQgYnkgdGhlIGxheWVyLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMud2VpZ2h0PTFdIC0gVGhlIGFtb3VudCBvZiBpbmZsdWVuY2UgdGhlIGxheWVyJ3MgY3VycmVudFxuICAgKiBhbmltYXRpb24gaGFzIG92ZXIgdGhlIHJlc3VsdCBmb3IgdGhlIGhvc3QuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy50cmFuc2l0aW9uVGltZT0wXSAtIFRoZSBkZWZhdWx0IGFtb3VudCBvZiB0aW1lIHRvIHVzZSB3aGVuXG4gICAqIHBsYXlpbmcgYW5kIHJlc3VtaW5nIGFuaW1hdGlvbnMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvcHRpb25zLmVhc2luZ0ZuIC0gVGhlIGRlZmF1bHQgZWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSB3aGVuXG4gICAqIHRyYW5zaXRpb25pbmcgYmV0d2VlbiBhbmltYXRpb25zIGFuZCBzZXR0aW5nIGxheWVyIHdlaWdodC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuXG4gICAgdGhpcy5uYW1lID0gb3B0aW9ucy5uYW1lID09PSB1bmRlZmluZWQgPyAnQW5pbWF0aW9uTGF5ZXInIDogb3B0aW9ucy5uYW1lO1xuICAgIHRoaXMuX2JsZW5kTW9kZSA9IEFycmF5LmZyb20oT2JqZWN0LnZhbHVlcyhMYXllckJsZW5kTW9kZXMpKS5pbmNsdWRlcyhcbiAgICAgIG9wdGlvbnMuYmxlbmRNb2RlXG4gICAgKVxuICAgICAgPyBvcHRpb25zLmJsZW5kTW9kZVxuICAgICAgOiBEZWZhdWx0TGF5ZXJCbGVuZE1vZGU7XG4gICAgdGhpcy5fcHJvbWlzZXMgPSB7XG4gICAgICB3ZWlnaHQ6IERlZmVycmVkLnJlc29sdmUoKSxcbiAgICB9O1xuICAgIHRoaXMuX3dlaWdodFBhdXNlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy53ZWlnaHQgPSB0eXBlb2Ygb3B0aW9ucy53ZWlnaHQgPT09ICdudW1iZXInID8gb3B0aW9ucy53ZWlnaHQgOiAxO1xuICAgIHRoaXMuX2ludGVybmFsV2VpZ2h0ID0gdGhpcy5fd2VpZ2h0O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHR5cGUgb2YgYmxlbmRpbmcgdXNlZCBmb3Igc3RhdGVzIGNvbnRyb2xsZWQgYnkgdGhlIGxheWVyLlxuICAgKlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBibGVuZE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JsZW5kTW9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuZCBzZXRzIHRoZSBhbW91bnQgb2YgaW5mbHVlbmNlIHRoZSBsYXllcidzIGN1cnJlbnQgYW5pbWF0aW9uIGhhcyBvdmVyXG4gICAqIHRoZSByZXN1bHQgZm9yIHRoZSBob3N0LlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgc2V0IHdlaWdodCh3ZWlnaHQpIHtcbiAgICB0aGlzLl93ZWlnaHQgPSBNYXRoVXRpbHMuY2xhbXAod2VpZ2h0LCAwLCAxKTtcbiAgfVxuXG4gIGdldCB3ZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlaWdodDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHdoZXRoZXIgb3Igbm90IHRoZSBsYXllcidzIHdlaWdodCB2YWx1ZSBpcyBjdXJyZW50bHkgYmVpbmcgYW5pbWF0ZWQuXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCB3ZWlnaHRQZW5kaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm9taXNlcy53ZWlnaHQgJiYgdGhpcy5fcHJvbWlzZXMud2VpZ2h0LnBlbmRpbmc7XG4gIH1cblxuICAvKipcbiAgICogUGF1c2UgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIHN0YXRlIGFuZCBhbnkgaW50ZXJwb2xhdGlvbiBoYXBwZW5pbmcgb24gdGhlIGxheWVyJ3NcbiAgICogd2VpZ2h0IHByb3BlcnR5LlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHBhdXNlKCkge1xuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgdGhpcy5fd2VpZ2h0UGF1c2VkID0gdHJ1ZTtcblxuICAgIHJldHVybiB0aGlzLnBhdXNlQW5pbWF0aW9uKCkgfHwgdGhpcy53ZWlnaHRQZW5kaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc3VtZSB0aGUgY3VycmVudCBhbmltYXRpb24gc3RhdGUgYW5kIGFueSBpbnRlcnBvbGF0aW9uIGhhcHBlbmluZyBvbiB0aGUgbGF5ZXInc1xuICAgKiB3ZWlnaHQgcHJvcGVydHkuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgcmVzdW1lKCkge1xuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dlaWdodFBhdXNlZCA9IGZhbHNlO1xuXG4gICAgY29uc3QgaXNXZWlnaHRBY3RpdmUgPSB0aGlzLndlaWdodFBlbmRpbmc7XG5cbiAgICBpZiAodGhpcy5fY3VycmVudFN0YXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXN1bWVBbmltYXRpb24oKSB8fCBpc1dlaWdodEFjdGl2ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGlzV2VpZ2h0QWN0aXZlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB1c2VyIGRlZmluZWQgd2VpZ2h0IG92ZXIgdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHdlaWdodCAtIFRoZSB0YXJnZXQgd2VpZ2h0IHZhbHVlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NlY29uZHM9MF0gLSBUaGUgYW1vdW50IG9mIHRpbWUgaXQgd2lsbCB0YWtlIHRvIHJlYWNoIHRoZVxuICAgKiB0YXJnZXQgd2VpZ2h0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gZWFzaW5nRm4gLSBUaGUgZWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSBmb3IgaW50ZXJwb2xhdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMge0RlZmVycmVkfVxuICAgKi9cbiAgc2V0V2VpZ2h0KHdlaWdodCwgc2Vjb25kcyA9IDAsIGVhc2luZ0ZuKSB7XG4gICAgaWYgKHRoaXMud2VpZ2h0UGVuZGluZykge1xuICAgICAgdGhpcy5fcHJvbWlzZXMud2VpZ2h0LmNhbmNlbCgpO1xuICAgIH1cblxuICAgIHdlaWdodCA9IE1hdGhVdGlscy5jbGFtcCh3ZWlnaHQpO1xuICAgIHRoaXMuX3Byb21pc2VzLndlaWdodCA9IEFuaW1hdGlvblV0aWxzLmludGVycG9sYXRlUHJvcGVydHkoXG4gICAgICB0aGlzLFxuICAgICAgJ3dlaWdodCcsXG4gICAgICB3ZWlnaHQsXG4gICAgICB7XG4gICAgICAgIHNlY29uZHMsXG4gICAgICAgIGVhc2luZ0ZuOiBlYXNpbmdGbiAhPT0gdW5kZWZpbmVkID8gZWFzaW5nRm4gOiB0aGlzLl9lYXNpbmdGbixcbiAgICAgIH1cbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VzLndlaWdodDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXVzZSBhbnkgaW50ZXJwb2xhdGlvbiBoYXBwZW5pbmcgb24gdGhlIGxheWVyJ3Mgd2VpZ2h0IHByb3BlcnR5LlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHBhdXNlV2VpZ2h0KCkge1xuICAgIHRoaXMuX3dlaWdodFBhdXNlZCA9IHRydWU7XG5cbiAgICByZXR1cm4gdGhpcy53ZWlnaHRQZW5kaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc3VtZSBhbnkgaW50ZXJwb2xhdGlvbiBoYXBwZW5pbmcgb24gdGhlIGxheWVyJ3Mgd2VpZ2h0IHByb3BlcnR5LlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHJlc3VtZVdlaWdodCgpIHtcbiAgICB0aGlzLl93ZWlnaHRQYXVzZWQgPSBmYWxzZTtcblxuICAgIHJldHVybiB0aGlzLndlaWdodFBlbmRpbmc7XG4gIH1cblxuICAvKipcbiAgICogTXVsdGlwbGllcyB0aGUgdXNlciB3ZWlnaHQgYnkgYSBmYWN0b3IgdG8gZGV0ZXJtaW5lIHRoZSBpbnRlcm5hbCB3ZWlnaHQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmYWN0b3IgLSAwLTEgbXVsdGlwbGllciB0byBhcHBseSB0byB0aGUgdXNlciB3ZWlnaHQuXG4gICAqL1xuICB1cGRhdGVJbnRlcm5hbFdlaWdodChmYWN0b3IpIHtcbiAgICB0aGlzLl9pbnRlcm5hbFdlaWdodCA9IHRoaXMuX3dlaWdodCAqIGZhY3RvcjtcblxuICAgIGlmICh0aGlzLl9jdXJyZW50U3RhdGUpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZS51cGRhdGVJbnRlcm5hbFdlaWdodCh0aGlzLl9pbnRlcm5hbFdlaWdodCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG5hbWVzIG9mIGJsZW5kIHN0YXRlcyBpbiBhbiBhbmltYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbmltYXRpb25OYW1lIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZz59IC0gTmFtZXMgb2YgYmxlbmQgc3RhdGVzLlxuICAgKi9cbiAgZ2V0QW5pbWF0aW9uQmxlbmROYW1lcyhhbmltYXRpb25OYW1lKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFN0YXRlKGFuaW1hdGlvbk5hbWUpO1xuXG4gICAgaWYgKHN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBnZXQgYmxlbmQgbmFtZXMgb2YgYW5pbWF0aW9uICR7YW5pbWF0aW9uTmFtZX0gb24gbGF5ZXIgJHt0aGlzLm5hbWV9LiBObyBhbmltYXRpb24gZXhpc3RzIHdpdGggdGhpcyBuYW1lLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlIGluc3RhbmNlb2YgQWJzdHJhY3RCbGVuZFN0YXRlKSB7XG4gICAgICByZXR1cm4gc3RhdGUuZ2V0U3RhdGVOYW1lcygpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDYW5ub3QgZ2V0IGJsZW5kIG5hbWVzIG9mIGFuaW1hdGlvbiAke2FuaW1hdGlvbk5hbWV9IG9uIGxheWVyICR7dGhpcy5uYW1lfS4gQW5pbWF0aW9uIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBBYnN0cmFjdEJsZW5kU3RhdGUuYFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSB3ZWlnaHQgZm9yIGEgYmxlbmQgc3RhdGUgb2YgYW4gYW5pbWF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYW5pbWF0aW9uTmFtZSAtIE5hbWUgb2YgdGhlIGFuaW1hdGlvbiBjb250YWluaW5nIHRoZSBibGVuZCBzdGF0ZVxuICAgKiB0byB1cGRhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBibGVuZE5hbWUgLSBOYW1lIG9mIHRoZSBibGVuZCBzdGF0ZSB0byB1cGRhdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3ZWlnaHQgLSBXZWlnaHQgdmFsdWUgdG8gc2V0IG9uIHRoZSBhbmltYXRpb24uIFRoaXMgbnVtYmVyIHNob3VkbGQgYmVcbiAgICogaW4gdGhlIDAtMSByYW5nZS5cbiAgICogQHBhcmFtIHtudW1iZXI9fSBzZWNvbmRzIC0gTnVtYmVyIG9mIHNlY29uZHMgaXQgc2hvdWxkIHRha2UgdG8gcmVhY2ggdGhlIG5ldyB3ZWlnaHQuXG4gICAqIERlZmF1bHQgaXMgemVybyBhbmQgd2lsbCBzZXQgaW1tZWRpYXRlbHkuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBlYXNpbmdGbiAtIEVhc2luZyBmdW5jdGlvbiB0byB1c2Ugd2hpbGUgaW50ZXJwb2xhdGluZyB0aGUgbmV3XG4gICAqIHdlaWdodC4gRGVmYXVsdCBpcyBFYXNpbmcuTGluZWFyLkluT3V0LlxuICAgKlxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9IC0gUHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSBvbmNlIHRoZSBhbmltYXRpb24ncyB3ZWlnaHQgcmVhY2hlc1xuICAgKiB0aGUgdGFyZ2V0IHZhbHVlLlxuICAgKi9cbiAgc2V0QW5pbWF0aW9uQmxlbmRXZWlnaHQoXG4gICAgYW5pbWF0aW9uTmFtZSxcbiAgICBibGVuZE5hbWUsXG4gICAgd2VpZ2h0LFxuICAgIHNlY29uZHMgPSAwLFxuICAgIGVhc2luZ0ZuXG4gICkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRTdGF0ZShhbmltYXRpb25OYW1lKTtcblxuICAgIGlmIChzdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3Qgc2V0IGJsZW5kIHdlaWdodCBvZiBhbmltYXRpb24gJHthbmltYXRpb25OYW1lfSBvbiBsYXllciAke3RoaXMubmFtZX0uIE5vIGFuaW1hdGlvbiBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUgaW5zdGFuY2VvZiBBYnN0cmFjdEJsZW5kU3RhdGUpIHtcbiAgICAgIHJldHVybiBzdGF0ZS5zZXRCbGVuZFdlaWdodChibGVuZE5hbWUsIHdlaWdodCwgc2Vjb25kcywgZWFzaW5nRm4pO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDYW5ub3Qgc2V0IGJsZW5kIHdlaWdodCBvZiBhbmltYXRpb24gJHthbmltYXRpb25OYW1lfSBvbiBsYXllciAke3RoaXMubmFtZX0uIEFuaW1hdGlvbiBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgQWJzdHJhY3RCbGVuZFN0YXRlLmBcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHdlaWdodCBmb3IgYSBibGVuZCBzdGF0ZSBvZiBhbiBhbmltYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbmltYXRpb25OYW1lIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uIGNvbnRhaW5pbmcgdGhlIGJsZW5kIHN0YXRlXG4gICAqIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGJsZW5kTmFtZSAtIE5hbWUgb2YgdGhlIGJsZW5kIHN0YXRlIHRvIHJldHJpZXZlIHRoZSB3ZWlnaHQgb2YuXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gV2VpZ2h0IG9mIHRoZSBibGVuZCBzdGF0ZS5cbiAgICovXG4gIGdldEFuaW1hdGlvbkJsZW5kV2VpZ2h0KGFuaW1hdGlvbk5hbWUsIGJsZW5kTmFtZSkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRTdGF0ZShhbmltYXRpb25OYW1lKTtcblxuICAgIGlmIChzdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgZ2V0IGJsZW5kIHdlaWdodCBvZiBhbmltYXRpb24gJHthbmltYXRpb25OYW1lfSBvbiBsYXllciAke3RoaXMubmFtZX0uIE5vIGFuaW1hdGlvbiBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUgaW5zdGFuY2VvZiBBYnN0cmFjdEJsZW5kU3RhdGUpIHtcbiAgICAgIHJldHVybiBzdGF0ZS5nZXRCbGVuZFdlaWdodChibGVuZE5hbWUpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDYW5ub3QgZ2V0IGJsZW5kIHdlaWdodCBvZiBhbmltYXRpb24gJHthbmltYXRpb25OYW1lfSBvbiBsYXllciAke3RoaXMubmFtZX0uIEFuaW1hdGlvbiBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgQWJzdHJhY3RCbGVuZFN0YXRlLmBcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhbnkgd2VpZ2h0IGludGVycG9sYXRvcnMgYW5kIHRoZSBjdXJyZW50IGFuaW1hdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhVGltZSAtIFRpbWUgaW4gbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZS5cbiAgICovXG4gIHVwZGF0ZShkZWx0YVRpbWUpIHtcbiAgICBzdXBlci51cGRhdGUoZGVsdGFUaW1lKTtcblxuICAgIGlmICghdGhpcy5fcGF1c2VkICYmICF0aGlzLl93ZWlnaHRQYXVzZWQpIHtcbiAgICAgIHRoaXMuX3Byb21pc2VzLndlaWdodC5leGVjdXRlKGRlbHRhVGltZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbCBhbnkgcGVuZGluZyBwcm9taXNlcyBhbmQgZGlzY2FyZCBzdGF0ZXMgY29udHJvbGxlZCBieSB0aGUgbGF5ZXIuXG4gICAqL1xuICBkaXNjYXJkKCkge1xuICAgIHN1cGVyLmRpc2NhcmQoKTtcblxuICAgIHRoaXMuZGlzY2FyZFN0YXRlcygpO1xuXG4gICAgdGhpcy5fcHJvbWlzZXMud2VpZ2h0LmNhbmNlbCgpO1xuICAgIGRlbGV0ZSB0aGlzLl9wcm9taXNlcztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBbmltYXRpb25MYXllcjtcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXG5pbXBvcnQgRGVmZXJyZWQgZnJvbSAnY29yZS9EZWZlcnJlZCc7XG5pbXBvcnQgQWJzdHJhY3RTdGF0ZSBmcm9tICcuL0Fic3RyYWN0U3RhdGUnO1xuaW1wb3J0IHt2YWxpZGF0ZUJsZW5kTW9kZX0gZnJvbSAnLi4vQW5pbWF0aW9uTGF5ZXInO1xuaW1wb3J0IEFuaW1hdGlvblV0aWxzIGZyb20gJy4uL0FuaW1hdGlvblV0aWxzJztcblxuLyoqXG4gKiBDbGFzcyBmb3IgcGxheWluZyBhIHNpbmdsZSBhbmltYXRpb24gY2xpcC5cbiAqXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFN0YXRlXG4gKiBAYWxpYXMgY29yZS9TaW5nbGVTdGF0ZVxuICovXG5jbGFzcyBTaW5nbGVTdGF0ZSBleHRlbmRzIEFic3RyYWN0U3RhdGUge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBhbmltYXRpb24gc3RhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0aW9ucy5uYW1lIC0gTmFtZSBmb3IgdGhlIGFuaW1hdGlvbiBzdGF0ZS4gTmFtZXMgbXVzdCBiZVxuICAgKiB1bmlxdWUgZm9yIHRoZSBsYXllciB0aGUgc3RhdGUgaXMgYXBwbGllZCB0by5cbiAgICogQHBhcmFtIHt3ZWlnaHR9IFtvcHRpb25zLndlaWdodD0wXSAtIFRoZSAwLTEgYW1vdW50IG9mIGluZmx1ZW5jZSB0aGUgc3RhdGUgd2lsbCBoYXZlLlxuICAgKiBAcGFyYW0ge3RpbWVTY2FsZX0gW29wdGlvbnMudGltZVNjYWxlPTFdIC0gRmFjdG9yIHRvIHNjYWxlIHRoZSBwbGF5YmFjayBzcGVlZCBvZiB0aGVcbiAgICogYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubG9vcENvdW50PUluZmluaXR5XSAtIE51bWJlciBvZiB0aW1lcyB0aGUgYW5pbWF0aW9uIHNob3VsZFxuICAgKiByZXBlYXQgYmVmb3JlIGZpbmlzaGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmJsZW5kTW9kZT1EZWZhdWx0TGF5ZXJCbGVuZE1vZGVdIC0gVHlwZSBvZlxuICAgKiBibGVuZGluZyB0aGUgYW5pbWF0aW9uIHNob3VsZCB1c2UuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihvcHRpb25zKTtcblxuICAgIHRoaXMuX3RpbWVTY2FsZSA9IG9wdGlvbnMudGltZVNjYWxlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnRpbWVTY2FsZSA6IDE7XG4gICAgdGhpcy5fcHJvbWlzZXMudGltZVNjYWxlID0gRGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgIHRoaXMuX2xvb3BDb3VudCA9XG4gICAgICBvcHRpb25zLmxvb3BDb3VudCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5sb29wQ291bnQgOiBJbmZpbml0eTtcbiAgICB0aGlzLl9ibGVuZE1vZGUgPSB2YWxpZGF0ZUJsZW5kTW9kZShvcHRpb25zLmJsZW5kTW9kZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbmQgc2V0cyB0aGUgbm9ybWFsaXplZCBwbGF5aW5nIHRpbWUgb2YgdGhlIGN1cnJlbnQgYW5pbWF0aW9uXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbm9ybWFsaXplZFRpbWUoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBzZXQgbm9ybWFsaXplZFRpbWUodGltZSkge31cblxuICAvKipcbiAgICogR2V0cyBhbmQgc2V0cyB0aGUgYSBmYWN0b3IgdG8gc2NhbGUgYW5pbWF0aW9uIHBsYXliYWNrIHNwZWVkIHdpdGguXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgdGltZVNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLl90aW1lU2NhbGU7XG4gIH1cblxuICBzZXQgdGltZVNjYWxlKHRpbWVTY2FsZSkge1xuICAgIHRoaXMuX3RpbWVTY2FsZSA9IHRpbWVTY2FsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHdoZXRoZXIgb3Igbm90IHRoZSB0aW1lU2NhbGUgaXMgY3VycmVudGx5IGJlaW5nIGFuaW1hdGVkLlxuICAgKlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgdGltZVNjYWxlUGVuZGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZXMudGltZVNjYWxlLnBlbmRpbmc7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgdGltZVNjYWxlIHZhbHVlIG92ZXIgdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHdlaWdodCAtIFRoZSB0YXJnZXQgdGltZVNjYWxlIHZhbHVlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NlY29uZHM9MF0gLSBUaGUgYW1vdW50IG9mIHRpbWUgaXQgd2lsbCB0YWtlIHRvIHJlYWNoIHRoZVxuICAgKiB0YXJnZXQgdGltZVNjYWxlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gZWFzaW5nRm4gLSBUaGUgZWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSBmb3IgaW50ZXJwb2xhdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMge0RlZmVycmVkfVxuICAgKi9cbiAgc2V0VGltZVNjYWxlKHRpbWVTY2FsZSwgc2Vjb25kcyA9IDAsIGVhc2luZ0ZuKSB7XG4gICAgdGhpcy5fcHJvbWlzZXMudGltZVNjYWxlLmNhbmNlbCgpO1xuXG4gICAgdGhpcy5fcHJvbWlzZXMudGltZVNjYWxlID0gQW5pbWF0aW9uVXRpbHMuaW50ZXJwb2xhdGVQcm9wZXJ0eShcbiAgICAgIHRoaXMsXG4gICAgICAndGltZVNjYWxlJyxcbiAgICAgIHRpbWVTY2FsZSxcbiAgICAgIHtzZWNvbmRzLCBlYXNpbmdGbn1cbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VzLnRpbWVTY2FsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuZCBzZXRzIHRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGFuaW1hdGlvbiB3aWxsIHJlcGVhdCBiZWZvcmUgZmluaXNoaW5nLlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGxvb3BDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9vcENvdW50O1xuICB9XG5cbiAgc2V0IGxvb3BDb3VudChsb29wQ291bnQpIHtcbiAgICB0aGlzLl9sb29wQ291bnQgPSBsb29wQ291bnQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdHlwZSBvZiBibGVuZGluZyB1c2VkIGZvciB0aGUgYW5pbWF0aW9uLlxuICAgKlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBibGVuZE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JsZW5kTW9kZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTaW5nbGVTdGF0ZTtcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXG5pbXBvcnQgQWJzdHJhY3RTdGF0ZSBmcm9tICcuL0Fic3RyYWN0U3RhdGUnO1xuaW1wb3J0IFN0YXRlQ29udGFpbmVySW50ZXJmYWNlIGZyb20gJy4vU3RhdGVDb250YWluZXJJbnRlcmZhY2UnO1xuaW1wb3J0IEFuaW1hdGlvblBsYXllckludGVyZmFjZSBmcm9tICcuLi9BbmltYXRpb25QbGF5ZXJJbnRlcmZhY2UnO1xuaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uL1V0aWxzJztcblxuLyoqXG4gKiBDbGFzcyBmb3IgcGxheWluZyByYW5kb20gYW5pbWF0aW9ucyBhdCByYW5kb20gaW50ZXJ2YWxzIHdpdGhpbiB0aGlzIHN0YXRlLlxuICpcbiAqIEBleHRlbmRzIEFic3RyYWN0U3RhdGVcbiAqIEBpbXBsZW1lbnRzIEFuaW1hdGlvblBsYXllckludGVyZmFjZVxuICogQGltcGxlbWVudHMgU3RhdGVDb250YWluZXJJbnRlcmZhY2VcbiAqL1xuY2xhc3MgUmFuZG9tQW5pbWF0aW9uU3RhdGUgZXh0ZW5kcyBBbmltYXRpb25QbGF5ZXJJbnRlcmZhY2UuTWl4aW4oXG4gIFN0YXRlQ29udGFpbmVySW50ZXJmYWNlLk1peGluKEFic3RyYWN0U3RhdGUpXG4pIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIC0gT3B0aW9ucyBmb3IgdGhlIGNvbnRhaW5lciBzdGF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnBsYXlJbnRlcnZhbD0zXSAtIFRoZSBiYXNlIGFuaW1hdGlvbiBwbGF5YmFjayBpbnRlcnZhbC5cbiAgICogQHBhcmFtIHtBcnJheS48QWJzdHJhY3RTdGF0ZT59IFtzdWJTdGF0ZXM9W11dIC0gc3RhdGVzIHRvIGJlIHJhbmRvbWx5IHBpY2tlZCB0byBwbGF5XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30sIHN1YlN0YXRlcyA9IFtdKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICB0aGlzLl9wbGF5SW50ZXJ2YWwgPSBvcHRpb25zLnBsYXlJbnRlcnZhbCA/IG9wdGlvbnMucGxheUludGVydmFsIDogMztcblxuICAgIHN1YlN0YXRlcy5mb3JFYWNoKHN0YXRlID0+IHtcbiAgICAgIHRoaXMuYWRkU3RhdGUoc3RhdGUpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW5kIHNldHMgdGhlIGJhc2UgYW5pbWF0aW9uIHBsYXkgaW50ZXJ2YWxcbiAgICpcbiAgICogQHR5cGUge2Zsb2F0fVxuICAgKi9cbiAgZ2V0IHBsYXlJbnRlcnZhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGxheUludGVydmFsO1xuICB9XG5cbiAgc2V0IHBsYXlJbnRlcnZhbChwbGF5SW50ZXJ2YWwpIHtcbiAgICB0aGlzLl9wbGF5SW50ZXJ2YWwgPSBwbGF5SW50ZXJ2YWw7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgdGhlIGludGVybmFsIHRpbWVyIGZvciBhbmltYXRpb24gcGxheSBpbnRlcnZhbFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Jlc2V0VGltZXIoKSB7XG4gICAgY29uc3QgcGxheVRpbWVyID0gVXRpbHMuZ2V0UmFuZG9tRmxvYXQoXG4gICAgICB0aGlzLl9wbGF5SW50ZXJ2YWwgLyA0LFxuICAgICAgdGhpcy5fcGxheUludGVydmFsICogMlxuICAgICk7XG4gICAgY29uc3Qgb25GaW5pc2ggPSAoKSA9PiB7XG4gICAgICB0aGlzLnBsYXlSYW5kb21BbmltYXRpb24odGhpcy5fcGxheUNhbGxiYWNrcy5vbkVycm9yKTtcbiAgICB9O1xuICAgIHRoaXMuX3Byb21pc2VzLnRpbWVyID0gVXRpbHMud2FpdChwbGF5VGltZXIsIHtvbkZpbmlzaH0pO1xuICB9XG5cbiAgdXBkYXRlSW50ZXJuYWxXZWlnaHQoZmFjdG9yKSB7XG4gICAgc3VwZXIudXBkYXRlSW50ZXJuYWxXZWlnaHQoZmFjdG9yKTtcblxuICAgIGlmICh0aGlzLl9jdXJyZW50U3RhdGUpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZS51cGRhdGVJbnRlcm5hbFdlaWdodCh0aGlzLl9pbnRlcm5hbFdlaWdodCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBpY2sgYSByYW5kb20gYW5pbWF0aW9uIGFuZCB1dGlsaXplIEFuaW1hdGlvblBsYXllckludGVyZmFjZSB0byBwbGF5IHRoYXQgYW5pbWF0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkVycm9yIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBpZiB0aGUgc3RhdGUgZW5jb3VudGVyc1xuICAgKiBhbiBlcnJvciBkdXJpbmcgcGxheWJhY2suXG4gICAqL1xuICBwbGF5UmFuZG9tQW5pbWF0aW9uKG9uRXJyb3IpIHtcbiAgICB0aGlzLl9yZXNldFRpbWVyKCk7XG5cbiAgICBjb25zdCBzdGF0ZXMgPSB0aGlzLmdldFN0YXRlTmFtZXMoKTtcbiAgICBpZiAodGhpcy5fY3VycmVudFN0YXRlKSB7XG4gICAgICBzdGF0ZXMuc3BsaWNlKHN0YXRlcy5pbmRleE9mKHRoaXMuX2N1cnJlbnRTdGF0ZS5uYW1lKSwgMSk7XG4gICAgfVxuICAgIGNvbnN0IHJhbmRvbVN0YXRlID0gc3RhdGVzW1V0aWxzLmdldFJhbmRvbUludCgwLCBzdGF0ZXMubGVuZ3RoKV07XG5cbiAgICB0aGlzLnBsYXlBbmltYXRpb24oXG4gICAgICByYW5kb21TdGF0ZSxcbiAgICAgIHRoaXMuX3RyYW5zaXRpb25UaW1lLFxuICAgICAgdGhpcy5fZWFzaW5nRm4sXG4gICAgICB1bmRlZmluZWQsXG4gICAgICBvbkVycm9yLFxuICAgICAgdW5kZWZpbmVkXG4gICAgKTtcbiAgfVxuXG4gIHBsYXkob25GaW5pc2gsIG9uRXJyb3IsIG9uQ2FuY2VsKSB7XG4gICAgdGhpcy5wbGF5UmFuZG9tQW5pbWF0aW9uKG9uRXJyb3IpO1xuICAgIHJldHVybiBzdXBlci5wbGF5KG9uRmluaXNoLCBvbkVycm9yLCBvbkNhbmNlbCk7XG4gIH1cblxuICBwYXVzZSgpIHtcbiAgICByZXR1cm4gc3VwZXIucGF1c2UoKSAmJiB0aGlzLnBhdXNlQW5pbWF0aW9uKCk7XG4gIH1cblxuICByZXN1bWUob25GaW5pc2gsIG9uRXJyb3IsIG9uQ2FuY2VsKSB7XG4gICAgaWYgKHRoaXMuX2N1cnJlbnRTdGF0ZSkge1xuICAgICAgdGhpcy5yZXN1bWVBbmltYXRpb24oXG4gICAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZS5uYW1lLFxuICAgICAgICB0aGlzLl90cmFuc2l0aW9uVGltZSxcbiAgICAgICAgdGhpcy5fZWFzaW5nRm4sXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgb25FcnJvcixcbiAgICAgICAgdW5kZWZpbmVkXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucmVzdW1lKG9uRmluaXNoLCBvbkVycm9yLCBvbkNhbmNlbCk7XG4gIH1cblxuICBjYW5jZWwoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNhbmNlbCgpICYmIHRoaXMuY2FuY2VsQW5pbWF0aW9uKCk7XG4gIH1cblxuICBzdG9wKCkge1xuICAgIHJldHVybiBzdXBlci5zdG9wKCkgJiYgdGhpcy5zdG9wQW5pbWF0aW9uKCk7XG4gIH1cblxuICBkaXNjYXJkKCkge1xuICAgIHN1cGVyLmRpc2NhcmQoKTtcbiAgICB0aGlzLmRpc2NhcmRTdGF0ZXMoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBSYW5kb21BbmltYXRpb25TdGF0ZTtcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXG5pbXBvcnQgQWJzdHJhY3RIb3N0RmVhdHVyZSBmcm9tICdjb3JlL0Fic3RyYWN0SG9zdEZlYXR1cmUnO1xuaW1wb3J0IFV0aWxzIGZyb20gJ2NvcmUvVXRpbHMnO1xuaW1wb3J0IFF1ZXVlU3RhdGUgZnJvbSAnLi9zdGF0ZS9RdWV1ZVN0YXRlJztcbmltcG9ydCBGcmVlQmxlbmRTdGF0ZSBmcm9tICcuL3N0YXRlL0ZyZWVCbGVuZFN0YXRlJztcbmltcG9ydCBCbGVuZDFkU3RhdGUgZnJvbSAnLi9zdGF0ZS9CbGVuZDFkU3RhdGUnO1xuaW1wb3J0IEJsZW5kMmRTdGF0ZSBmcm9tICcuL3N0YXRlL0JsZW5kMmRTdGF0ZSc7XG5pbXBvcnQgU2luZ2xlU3RhdGUgZnJvbSAnLi9zdGF0ZS9TaW5nbGVTdGF0ZSc7XG5pbXBvcnQgUmFuZG9tQW5pbWF0aW9uU3RhdGUgZnJvbSAnLi9zdGF0ZS9SYW5kb21BbmltYXRpb25TdGF0ZSc7XG5pbXBvcnQgQW5pbWF0aW9uTGF5ZXIsIHtMYXllckJsZW5kTW9kZXN9IGZyb20gJy4vQW5pbWF0aW9uTGF5ZXInO1xuaW1wb3J0IERlZmVycmVkIGZyb20gJy4uL0RlZmVycmVkJztcblxuLyoqXG4gKiBFbnVtIGZvciBhbmltYXRpb24gc3RhdGUgY2xhc3Nlcy5cbiAqXG4gKiBAcmVhZG9ubHlcbiAqIEBlbnVtIHtDbGFzc31cbiAqL1xuZXhwb3J0IGNvbnN0IEFuaW1hdGlvblR5cGVzID0ge1xuICBzaW5nbGU6IFNpbmdsZVN0YXRlLFxuICBmcmVlQmxlbmQ6IEZyZWVCbGVuZFN0YXRlLFxuICBxdWV1ZTogUXVldWVTdGF0ZSxcbiAgcmFuZG9tQW5pbWF0aW9uOiBSYW5kb21BbmltYXRpb25TdGF0ZSxcbiAgYmxlbmQxZDogQmxlbmQxZFN0YXRlLFxuICBibGVuZDJkOiBCbGVuZDJkU3RhdGUsXG59O1xuXG4vKipcbiAqIEZlYXR1cmUgZm9yIG1hbmFnaW5nIGFuaW1hdGlvbnMgb24gYW4gb2JqZWN0LlxuICpcbiAqIEBleHRlbmRzIEFic3RyYWN0SG9zdEZlYXR1cmVcbiAqIEBhbGlhcyBjb3JlL0FuaW1hdGlvbkZlYXR1cmVcbiAqXG4gKiBAcHJvcGVydHkge09iamVjdH0gRVZFTlRTIC0gQnVpbHQtaW4gbWVzc2FnZXMgdGhhdCB0aGUgZmVhdHVyZSBlbWl0cy4gV2hlbiB0aGVcbiAqIGZlYXR1cmUgaXMgYWRkZWQgdG8gYSB7QGxpbmsgY29yZS9Ib3N0T2JqZWN0fSwgZXZlbnQgbmFtZXMgd2lsbCBiZSBwcmVmaXhlZCBieSB0aGVcbiAqIG5hbWUgb2YgdGhlIGZlYXR1cmUgY2xhc3MgKyAnLicuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UUy5hZGRMYXllcj1vbkFkZExheWVyRXZlbnRdIC0gTWVzc2FnZSB0aGF0IGlzIGVtaXR0ZWQgYWZ0ZXJcbiAqIFthZGRMYXllcl17QGxpbmsgY29yZS9BbmltYXRpb25GZWF0dXJlI2FkZExheWVyfSBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgZXhlY3V0ZWQuXG4gKiBBbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBuYW1lIG9mIHRoZSBsYXllciB0aGF0IHdhcyBhZGRlZCBhbmQgaXRzIGluZGV4IGluXG4gKiB0aGUgbGF5ZXIgc3RhY2sgd2l0aCB0aGUgc2lnbmF0dXJlIHtuYW1lOiBzdHJpbmcsIGluZGV4OiBudW1iZXJ9IGlzIHN1cHBsaWVkXG4gKiBhcyBhbiBhcmd1bWVudCB0byBsaXN0ZW5lciBmdW5jdGlvbnMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UUy5yZW1vdmVMYXllcj1vblJlbW92ZUxheWVyRXZlbnRdIC0gTWVzc2FnZSB0aGF0IGlzXG4gKiBlbWl0dGVkIGFmdGVyIFtyZW1vdmVMYXllcl17QGxpbmsgY29yZS9BbmltYXRpb25GZWF0dXJlI3JlbW92ZUxheWVyfSBoYXMgYmVlblxuICogc3VjY2Vzc2Z1bGx5IGV4ZWN1dGVkLiBBbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBuYW1lIG9mIHRoZSBsYXllciB0aGF0IHdhc1xuICogcmVtb3ZlZCBhbmQgaXRzIGluZGV4IGluIHRoZSBsYXllciBzdGFjayB3aXRoIHRoZSBzaWduYXR1cmUge25hbWU6IHN0cmluZywgaW5kZXg6IG51bWJlcn1cbiAqIGlzIHN1cHBsaWVkIGFzIGFuIGFyZ3VtZW50IHRvIGxpc3RlbmVyIGZ1bmN0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLnJlbmFtZUxheWVyPW9uUmVuYW1lTGF5ZXJFdmVudF0gLSBNZXNzYWdlIHRoYXQgaXNcbiAqIGVtaXR0ZWQgYWZ0ZXIgW3JlbmFtZUxheWVyXXtAbGluayBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjcmVuYW1lTGF5ZXJ9IGhhcyBiZWVuXG4gKiBzdWNjZXNzZnVsbHkgZXhlY3V0ZWQuIEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIG9yaWdpbmFsIG5hbWUgb2YgdGhlIGxheWVyXG4gKiB0aGF0IHdhcyByZW5hbWVkIGFuZCBpdHMgdXBkYXRlZCBuYW1lIHdpdGggdGhlIHNpZ25hdHVyZSB7b2xkTmFtZTogc3RyaW5nLCBuZXdOYW1lOiBzdHJpbmd9XG4gKiBpcyBzdXBwbGllZCBhcyBhbiBhcmd1bWVudCB0byBsaXN0ZW5lciBmdW5jdGlvbnMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UUy5hZGRBbmltYXRpb249b25BZGRBbmltYXRpb25FdmVudF0gLSBNZXNzYWdlIHRoYXQgaXNcbiAqIGVtaXR0ZWQgYWZ0ZXIgW2FkZEFuaW1hdGlvbl17QGxpbmsgY29yZS9BbmltYXRpb25GZWF0dXJlI2FkZEFuaW1hdGlvbn0gaGFzIGJlZW5cbiAqIHN1Y2Nlc3NmdWxseSBleGVjdXRlZC4gQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgbmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCB0aGVcbiAqIGFuaW1hdGlvbiB3YXMgYWRkZWQgdG8gYW5kIHRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb24gdGhhdCB3YXMgYWRkZWQgd2l0aCB0aGVcbiAqIHNpZ25hdHVyZSB7bGF5ZXJOYW1lOiBzdHJpbmcsIGFuaW1hdGlvbk5hbWU6IHN0cmluZ30gaXMgc3VwcGxpZWQgYXMgYW4gYXJndW1lbnRcbiAqIHRvIGxpc3RlbmVyIGZ1bmN0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLnJlbW92ZUFuaW1hdGlvbj1vblJlbW92ZWRBbmltYXRpb25FdmVudF0gLSBNZXNzYWdlXG4gKiB0aGF0IGlzIGVtaXR0ZWQgYWZ0ZXIgW3JlbW92ZUFuaW1hdGlvbl17QGxpbmsgY29yZS9BbmltYXRpb25GZWF0dXJlI3JlbW92ZUFuaW1hdGlvbn1cbiAqIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBleGVjdXRlZC4gQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgbmFtZSBvZiB0aGUgbGF5ZXJcbiAqIHRoYXQgdGhlIGFuaW1hdGlvbiB3YXMgcmVtb3ZlZCBmcm9tIGFuZCB0aGUgbmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRoYXQgd2FzIHJlbW92ZWRcbiAqIHdpdGggdGhlIHNpZ25hdHVyZSB7bGF5ZXJOYW1lOiBzdHJpbmcsIGFuaW1hdGlvbk5hbWU6IHN0cmluZ30gaXMgc3VwcGxpZWQgYXNcbiAqIGFuIGFyZ3VtZW50IHRvIGxpc3RlbmVyIGZ1bmN0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLnJlbmFtZUFuaW1hdGlvbj1vblJlbmFtZUFuaW1hdGlvbkV2ZW50XSAtIE1lc3NhZ2VcbiAqIHRoYXQgaXMgZW1pdHRlZCBhZnRlciBbcmVuYW1lQW5pbWF0aW9uXXtAbGluayBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjcmVuYW1lQW5pbWF0aW9ufVxuICogaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGV4ZWN1dGVkLiBBbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBuYW1lIG9mIHRoZSBsYXllclxuICogdGhhdCBjb250YWlucyB0aGUgYW5pbWF0aW9uIHRoYXQgd2FzIHJlbmFtZWQsIHRoZSBvcmlnaW5hbCBuYW1lIG9mIHRoZSBhbmltYXRpb25cbiAqIHRoYXQgd2FzIHJlbmFtZWQgYW5kIGl0cyB1cGRhdGVkIG5hbWUgd2l0aCB0aGUgc2lnbmF0dXJlIHtsYXllck5hbWU6IHN0cmluZywgb2xkTmFtZTogc3RyaW5nLCBuZXdOYW1lOiBzdHJpbmd9XG4gKiBpcyBzdXBwbGllZCBhcyBhbiBhcmd1bWVudCB0byBsaXN0ZW5lciBmdW5jdGlvbnMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UUy5wbGF5PW9uUGxheUV2ZW50XSAtIE1lc3NhZ2UgdGhhdCBpcyBlbWl0dGVkIGFmdGVyXG4gKiBlYWNoIGNhbGwgdG8gW3BsYXlde0BsaW5rIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNwbGF5QW5pbWF0aW9ufS4gQW4gb2JqZWN0IHJlcHJlc2VudGluZ1xuICogdGhlIG5hbWUgb2YgdGhlIGxheWVyIGNvbnRhaW5zIHRoZSBhbmltYXRpb24gdGhhdCB3YXMgcGxheWVkIGFuZCB0aGUgbmFtZSBvZlxuICogdGhlIGFuaW1hdGlvbiB0aGF0IHdhcyBwbGF5ZWQgd2l0aCB0aGUgc2lnbmF0dXJlIHtsYXllck5hbWU6IHN0cmluZywgYW5pbWF0aW9uTmFtZTogc3RyaW5nfVxuICogaXMgc3VwcGxpZWQgYXMgYW4gYXJndW1lbnQgdG8gbGlzdGVuZXIgZnVuY3Rpb25zLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVFMucGF1c2U9b25QYXVzZUV2ZW50XSAtIE1lc3NhZ2UgdGhhdCBpcyBlbWl0dGVkIGFmdGVyXG4gKiBlYWNoIGNhbGwgdG8gW3BhdXNlXXtAbGluayBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjcGF1c2VBbmltYXRpb259LiBBbiBvYmplY3QgcmVwcmVzZW50aW5nXG4gKiB0aGUgbmFtZSBvZiB0aGUgbGF5ZXIgY29udGFpbnMgdGhlIGFuaW1hdGlvbiB0aGF0IHdhcyBwYXVzZWQgYW5kIHRoZSBuYW1lIG9mXG4gKiB0aGUgYW5pbWF0aW9uIHRoYXQgd2FzIHBhdXNlZCB3aXRoIHRoZSBzaWduYXR1cmUge2xheWVyTmFtZTogc3RyaW5nLCBhbmltYXRpb25OYW1lOiBzdHJpbmd9XG4gKiBpcyBzdXBwbGllZCBhcyBhbiBhcmd1bWVudCB0byBsaXN0ZW5lciBmdW5jdGlvbnMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UUy5yZXN1bWU9b25SZXN1bWVFdmVudF0gLSBNZXNzYWdlIHRoYXQgaXMgZW1pdHRlZCBhZnRlclxuICogZWFjaCBjYWxsIHRvIFtyZXN1bWVde0BsaW5rIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNyZXN1bWVBbmltYXRpb259LiBBbiBvYmplY3QgcmVwcmVzZW50aW5nXG4gKiB0aGUgbmFtZSBvZiB0aGUgbGF5ZXIgY29udGFpbnMgdGhlIGFuaW1hdGlvbiB0aGF0IHdhcyByZXN1bWVkIGFuZCB0aGUgbmFtZSBvZlxuICogdGhlIGFuaW1hdGlvbiB0aGF0IHdhcyByZXN1bWVkIHdpdGggdGhlIHNpZ25hdHVyZSB7bGF5ZXJOYW1lOiBzdHJpbmcsIGFuaW1hdGlvbk5hbWU6IHN0cmluZ31cbiAqIGlzIHN1cHBsaWVkIGFzIGFuIGFyZ3VtZW50IHRvIGxpc3RlbmVyIGZ1bmN0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLmludGVycnVwdD1vbkludGVycnVwdEV2ZW50XSAtIE1lc3NhZ2UgdGhhdCBpcyBlbWl0dGVkXG4gKiBpZiB0aGVyZSBpcyBhIGN1cnJlbnQgc3BlZWNoIGluIHByb2dyZXNzIGFuZCBbcGxheV17QGxpbmsgY29yZS9BbmltYXRpb25GZWF0dXJlI3BsYXlBbmltYXRpb259XG4gKiBvciBbcmVzdW1lXXtAbGluayBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjcmVzdW1lQW5pbWF0aW9ufSBhcmUgZXhlY3V0ZWQgZm9yIGEgbmV3IHNwZWVjaC5cbiAqIEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIG5hbWUgb2YgdGhlIGxheWVyIGNvbnRhaW5zIHRoZSBhbmltYXRpb24gdGhhdCB3YXNcbiAqIGludGVycnVwdGVkIGFuZCB0aGUgbmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRoYXQgd2FzIGludGVycnVwdGVkIHdpdGggdGhlIHNpZ25hdHVyZVxuICoge2xheWVyTmFtZTogc3RyaW5nLCBhbmltYXRpb25OYW1lOiBzdHJpbmd9IGlzIHN1cHBsaWVkIGFzIGFuIGFyZ3VtZW50IHRvIGxpc3RlbmVyXG4gKiBmdW5jdGlvbnMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UUy5zdG9wPW9uU3RvcEV2ZW50XSAtIE1lc3NhZ2UgdGhhdCBpcyBlbWl0dGVkIGFmdGVyXG4gKiBlYWNoIGNhbGwgdG8gW3N0b3Bde0BsaW5rIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNzdG9wQW5pbWF0aW9ufSBhbmQgd2hlbiBhIHNwZWVjaCByZWFjaGVzXG4gKiB0aGUgZW5kIG9mIHBsYXliYWNrLiBBbiBvYmplY3QgcmVwcmVzZW50aW5nXG4gKiB0aGUgbmFtZSBvZiB0aGUgbGF5ZXIgY29udGFpbnMgdGhlIGFuaW1hdGlvbiB0aGF0IHdhcyBzdG9wcGVkIGFuZCB0aGUgbmFtZSBvZlxuICogdGhlIGFuaW1hdGlvbiB0aGF0IHdhcyBzdG9wcGVkIHdpdGggdGhlIHNpZ25hdHVyZSB7bGF5ZXJOYW1lOiBzdHJpbmcsIGFuaW1hdGlvbk5hbWU6IHN0cmluZ31cbiAqIGlzIHN1cHBsaWVkIGFzIGFuIGFyZ3VtZW50IHRvIGxpc3RlbmVyIGZ1bmN0aW9ucy5cbiAqL1xuY2xhc3MgQW5pbWF0aW9uRmVhdHVyZSBleHRlbmRzIEFic3RyYWN0SG9zdEZlYXR1cmUge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7Y29yZS9Ib3N0T2JqZWN0fSBob3N0IC0gSG9zdCBvYmplY3QgdGhhdCBvd25zIHRoZSBmZWF0dXJlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoaG9zdCkge1xuICAgIHN1cGVyKGhvc3QpO1xuXG4gICAgdGhpcy5fbGF5ZXJzID0gW107XG4gICAgdGhpcy5fbGF5ZXJNYXAgPSB7fTtcbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIHN1cmUgYSBzdXBwbGllZCBsYXllciBpbmRleCBpcyB3aXRoaW4gdGhlIHJhbmdlIG9mIGxheWVycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2V4aXN0aW5nPXRydWVdIC0gV2hldGhlciB0aGUgaW5kZXggcmVwcmVzZW50cyBhbmQgZXhpc3RpbmdcbiAgICogbGF5ZXIgb3IgYSBuZXcgbGF5ZXIgdG8gYmUgYWRkZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXI9fVxuICAgKi9cbiAgX3ZhbGlkYXRlSW5kZXgoaW5kZXgsIGV4aXN0aW5nID0gdHJ1ZSkge1xuICAgIC8vIEluZGV4IGlzIGludmFsaWQgaWYgdGhlcmUgYXJlIG5vIGxheWVycyBhbmQgd2UncmUgY2hlY2tpbmcgZm9yIGFuIGV4aXN0aW5nIGxheWVyIGluZGV4XG4gICAgaWYgKHRoaXMuX2xheWVycy5sZW5ndGggPT09IDAgJiYgZXhpc3RpbmcpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgbGFzdEluZGV4ID0gZXhpc3RpbmcgPyB0aGlzLl9sYXllcnMubGVuZ3RoIC0gMSA6IHRoaXMuX2xheWVycy5sZW5ndGg7XG5cbiAgICAvLyBDb3VudCBmcm9tIHRoZSBlbmQgb2YgdGhlIGFycmF5IGZvciBuZWdhdGl2ZSBpbmRpY2VzXG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgaW5kZXggPSBsYXN0SW5kZXggKyBpbmRleCArIDE7XG4gICAgfVxuXG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZS1ldmFsdWF0ZSBpbnRlcm5hbCB3ZWlnaHQgdmFsdWVzIG9mIGxheWVycyBzdGFydGluZyBmcm9tIHRoZSB0b3Agb2YgdGhlXG4gICAqIHN0YWNrLiBPdmVycmlkZSBsYXllcnMnIHdlaWdodHMgYWZmZWN0IHRoZSB2YWx1ZXMgb2YgYWxsIGxheWVycyBsb3dlciBpbiB0aGVcbiAgICogc3RhY2suXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlSW50ZXJuYWxXZWlnaHRzKCkge1xuICAgIGNvbnN0IG51bUxheWVycyA9IHRoaXMuX2xheWVycy5sZW5ndGg7XG4gICAgbGV0IHdlaWdodE11bHRpcGxpZXIgPSAxO1xuXG4gICAgLy8gVXBkYXRlIGludGVybmFsIHdlaWdodCB2YWx1ZXMgb24gbGF5ZXJzIGluIHJldmVyc2Ugb3JkZXJcbiAgICBmb3IgKGxldCBpID0gbnVtTGF5ZXJzIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJzW2ldO1xuICAgICAgbGF5ZXIudXBkYXRlSW50ZXJuYWxXZWlnaHQod2VpZ2h0TXVsdGlwbGllcik7XG5cbiAgICAgIC8vIElmIHRoZSBsYXllciBpcyBvdmVycmlkZSwgdXBkYXRlIHRoZSBtdWx0aXBsaWVyIHdpdGggdGhlIHJlbWFpbmRlciBvZiB0aGUgZnVsbCB3ZWlnaHRcbiAgICAgIGlmIChsYXllci5ibGVuZE1vZGUgPT09IExheWVyQmxlbmRNb2Rlcy5PdmVycmlkZSAmJiBsYXllci5jdXJyZW50U3RhdGUpIHtcbiAgICAgICAgd2VpZ2h0TXVsdGlwbGllciAqPSAxIC0gbGF5ZXIuY3VycmVudFN0YXRlLmludGVybmFsV2VpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBuZXcgaW5zdGFuY2Ugb2YgYSBTaW5nbGVTdGF0ZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIHRvIHBhc3MgdG8gdGhlIFNpbmdsZVN0YXRlIGNvbnN0cnVjdG9yLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdGlvbnMubmFtZSAtIE5hbWUgZm9yIHRoZSBhbmltYXRpb24gc3RhdGUuIE5hbWVzIG11c3QgYmVcbiAgICogdW5pcXVlIGZvciB0aGUgbGF5ZXIgdGhlIHN0YXRlIGlzIGFwcGxpZWQgdG8uXG4gICAqIEBwYXJhbSB7d2VpZ2h0fSBbb3B0aW9ucy53ZWlnaHQ9MF0gLSBUaGUgMC0xIGFtb3VudCBvZiBpbmZsdWVuY2UgdGhlIHN0YXRlIHdpbGwgaGF2ZS5cbiAgICogQHBhcmFtIHt0aW1lU2NhbGV9IFtvcHRpb25zLnRpbWVTY2FsZT0xXSAtIEZhY3RvciB0byBzY2FsZSB0aGUgcGxheWJhY2sgc3BlZWQgb2YgdGhlXG4gICAqIGFuaW1hdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxvb3BDb3VudD1JbmZpbml0eV0gLSBOdW1iZXIgb2YgdGltZXMgdGhlIGFuaW1hdGlvbiBzaG91bGRcbiAgICogcmVwZWF0IGJlZm9yZSBmaW5pc2hpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5ibGVuZE1vZGU9TGF5ZXJCbGVuZE1vZGVzW0RlZmF1bHRMYXllckJsZW5kTW9kZV1dIC0gVHlwZSBvZlxuICAgKiBibGVuZGluZyB0aGUgYW5pbWF0aW9uIHNob3VsZCB1c2UuXG4gICAqXG4gICAqIEByZXR1cm5zIHtjb3JlL1NpbmdsZVN0YXRlfVxuICAgKi9cbiAgX2NyZWF0ZVNpbmdsZVN0YXRlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNpbmdsZVN0YXRlKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIG5ldyBpbnN0YW5jZSBvZiBhIEZyZWVCbGVuZFN0YXRlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gcGFzcyB0byB0aGUgRnJlZUJsZW5kU3RhdGUgY29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0aW9ucy5uYW1lIC0gTmFtZSBmb3IgdGhlIGFuaW1hdGlvbiBzdGF0ZS4gTmFtZXMgbXVzdCBiZVxuICAgKiB1bmlxdWUgZm9yIHRoZSBsYXllciB0aGUgc3RhdGUgaXMgYXBwbGllZCB0by5cbiAgICogQHBhcmFtIHt3ZWlnaHR9IFtvcHRpb25zLndlaWdodD0wXSAtIFRoZSAwLTEgYW1vdW50IG9mIGluZmx1ZW5jZSB0aGUgc3RhdGUgd2lsbCBoYXZlLlxuICAgKiBAcGFyYW0ge3RpbWVTY2FsZX0gW29wdGlvbnMudGltZVNjYWxlPTFdIC0gRmFjdG9yIHRvIHNjYWxlIHRoZSBwbGF5YmFjayBzcGVlZCBvZiB0aGVcbiAgICogYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubG9vcENvdW50PUluZmluaXR5XSAtIE51bWJlciBvZiB0aW1lcyB0aGUgYW5pbWF0aW9uIHNob3VsZFxuICAgKiByZXBlYXQgYmVmb3JlIGZpbmlzaGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmJsZW5kTW9kZT1MYXllckJsZW5kTW9kZXNbRGVmYXVsdExheWVyQmxlbmRNb2RlXV0gLSBUeXBlIG9mXG4gICAqIGJsZW5kaW5nIHRoZSBhbmltYXRpb24gc2hvdWxkIHVzZS5cbiAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gW29wdGlvbnMuYmxlbmRTdGF0ZU9wdGlvbnNdIC0gQXJyYXkgb2Ygb3B0aW9ucyB1c2VkIHRvIGNyZWF0ZSB0aGVcbiAgICogYmxlbmQgc3RhdGVzIGZvciB0aGlzIGNvbnRhaW5lci5cbiAgICpcbiAgICogQHJldHVybnMge0ZyZWVCbGVuZFN0YXRlfVxuICAgKi9cbiAgX2NyZWF0ZUZyZWVCbGVuZFN0YXRlKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7YmxlbmRTdGF0ZU9wdGlvbnMgPSBbXX0gPSBvcHRpb25zO1xuXG4gICAgY29uc3QgYmxlbmRTdGF0ZXMgPSBbXTtcbiAgICBibGVuZFN0YXRlT3B0aW9ucy5mb3JFYWNoKGJsZW5kT3B0aW9ucyA9PiB7XG4gICAgICBibGVuZFN0YXRlcy5wdXNoKFxuICAgICAgICB0aGlzLl9jcmVhdGVTaW5nbGVTdGF0ZSh7Li4uYmxlbmRPcHRpb25zLCBibGVuZE1vZGU6IG9wdGlvbnMuYmxlbmRNb2RlfSlcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmV3IEZyZWVCbGVuZFN0YXRlKG9wdGlvbnMsIGJsZW5kU3RhdGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBuZXcgaW5zdGFuY2Ugb2YgYSBRdWV1ZVN0YXRlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gcGFzcyB0byB0aGUgUXVldWVTdGF0ZSBjb25zdHJ1Y3Rvci5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRpb25zLm5hbWUgLSBOYW1lIGZvciB0aGUgYW5pbWF0aW9uIHN0YXRlLiBOYW1lcyBtdXN0IGJlXG4gICAqIHVuaXF1ZSBmb3IgdGhlIGxheWVyIHRoZSBzdGF0ZSBpcyBhcHBsaWVkIHRvLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMud2VpZ2h0PTBdIC0gVGhlIDAtMSBhbW91bnQgb2YgaW5mbHVlbmNlIHRoZSBzdGF0ZSB3aWxsIGhhdmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0aW9ucy50cmFuc2l0aW9uVGltZSAtIFRoZSBhbW91bnQgb2YgdGltZSBpdCB0YWtlcyB0byB0cmFuc2l0aW9uXG4gICAqIGJldHdlZW4gcXVldWVkIHN0YXRlcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmJsZW5kTW9kZT1MYXllckJsZW5kTW9kZXNbRGVmYXVsdExheWVyQmxlbmRNb2RlXV0gLSBUeXBlIG9mXG4gICAqIGJsZW5kaW5nIHRoZSBhbmltYXRpb24gc2hvdWxkIHVzZS5cbiAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gW29wdGlvbnMucXVldWVPcHRpb25zXSAtIEFycmF5IG9mIG9wdGlvbnMgdXNlZCB0byBjcmVhdGUgdGhlXG4gICAqIHF1ZXVlIHN0YXRlcyBmb3IgdGhpcyBjb250YWluZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHtRdWV1ZVN0YXRlfVxuICAgKi9cbiAgX2NyZWF0ZVF1ZXVlU3RhdGUob3B0aW9ucykge1xuICAgIGNvbnN0IHtxdWV1ZU9wdGlvbnMgPSBbXX0gPSBvcHRpb25zO1xuXG4gICAgY29uc3QgcXVldWVTdGF0ZXMgPSBxdWV1ZU9wdGlvbnMubWFwKHF1ZXVlT3B0aW9uID0+XG4gICAgICB0aGlzLl9jcmVhdGVTaW5nbGVTdGF0ZSh7XG4gICAgICAgIHRyYW5zaXRpb25UaW1lOiBvcHRpb25zLnRyYW5zaXRpb25UaW1lLFxuICAgICAgICAuLi5xdWV1ZU9wdGlvbixcbiAgICAgICAgYmxlbmRNb2RlOiBvcHRpb25zLmJsZW5kTW9kZSxcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHJldHVybiBuZXcgUXVldWVTdGF0ZShvcHRpb25zLCBxdWV1ZVN0YXRlcyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgbmV3IGluc3RhbmNlIG9mIGEgQmxlbmQxZFN0YXRlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gcGFzcyB0byB0aGUgQmxlbmQxZFN0YXRlIGNvbnN0cnVjdG9yLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdGlvbnMubmFtZSAtIE5hbWUgZm9yIHRoZSBhbmltYXRpb24gc3RhdGUuIE5hbWVzIG11c3QgYmVcbiAgICogdW5pcXVlIGZvciB0aGUgbGF5ZXIgdGhlIHN0YXRlIGlzIGFwcGxpZWQgdG8uXG4gICAqIEBwYXJhbSB7d2VpZ2h0fSBbb3B0aW9ucy53ZWlnaHQ9MF0gLSBUaGUgMC0xIGFtb3VudCBvZiBpbmZsdWVuY2UgdGhlIHN0YXRlIHdpbGwgaGF2ZS5cbiAgICogQHBhcmFtIHt0aW1lU2NhbGV9IFtvcHRpb25zLnRpbWVTY2FsZT0xXSAtIEZhY3RvciB0byBzY2FsZSB0aGUgcGxheWJhY2sgc3BlZWQgb2YgdGhlXG4gICAqIGFuaW1hdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxvb3BDb3VudD1JbmZpbml0eV0gLSBOdW1iZXIgb2YgdGltZXMgdGhlIGFuaW1hdGlvbiBzaG91bGRcbiAgICogcmVwZWF0IGJlZm9yZSBmaW5pc2hpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5ibGVuZE1vZGU9TGF5ZXJCbGVuZE1vZGVzW0RlZmF1bHRMYXllckJsZW5kTW9kZV1dIC0gVHlwZSBvZlxuICAgKiBibGVuZGluZyB0aGUgYW5pbWF0aW9uIHNob3VsZCB1c2UuXG4gICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IFtvcHRpb25zLmJsZW5kU3RhdGVPcHRpb25zXSAtIEFycmF5IG9mIG9wdGlvbnMgdXNlZCB0byBjcmVhdGUgdGhlXG4gICAqIGJsZW5kIHN0YXRlcyBmb3IgdGhpcyBjb250YWluZXIuXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtvcHRpb25zLmJsZW5kVGhyZXNob2xkc10gLSBBcnJheSBvZiBudW1iZXJzIHVzZWQgdG8gc2V0IHRoZVxuICAgKiB0aHJlc2hvbGRzIGZvciBlYWNoIGJsZW5kIHN0YXRlIGluIHRoaXMgY29udGFpbmVyLlxuICAgKiBAcGFyYW0ge0FycmF5Ljxib29sZWFuPn0gW29wdGlvbnMuYmxlbmRNYXRjaFBoYXNlcz1bXV0gLSBPcHRpb25hbCBhcnJheSBvZiBib29sZWFucyB1c2VkIHRvXG4gICAqIHNldCB3aGV0aGVyIG9yIG5vdCBlYWNoIGJsZW5kIHN0YXRlIGluIHRoaXMgY29udGFpbmVyIHdpbGwgbWF0Y2ggcGhhc2VzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7QmxlbmQxZFN0YXRlfVxuICAgKi9cbiAgX2NyZWF0ZUJsZW5kMWRTdGF0ZShvcHRpb25zKSB7XG4gICAgY29uc3Qge2JsZW5kU3RhdGVPcHRpb25zID0gW119ID0gb3B0aW9ucztcbiAgICBjb25zdCB7YmxlbmRUaHJlc2hvbGRzID0gW119ID0gb3B0aW9ucztcbiAgICBjb25zdCB7YmxlbmRNYXRjaFBoYXNlcyA9IFtdfSA9IG9wdGlvbnM7XG5cbiAgICBjb25zdCBibGVuZFN0YXRlcyA9IFtdO1xuICAgIGJsZW5kU3RhdGVPcHRpb25zLmZvckVhY2goYmxlbmRPcHRpb25zID0+IHtcbiAgICAgIGJsZW5kU3RhdGVzLnB1c2goXG4gICAgICAgIHRoaXMuX2NyZWF0ZVNpbmdsZVN0YXRlKHsuLi5ibGVuZE9wdGlvbnMsIGJsZW5kTW9kZTogb3B0aW9ucy5ibGVuZE1vZGV9KVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBuZXcgQmxlbmQxZFN0YXRlKFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGJsZW5kU3RhdGVzLFxuICAgICAgYmxlbmRUaHJlc2hvbGRzLFxuICAgICAgYmxlbmRNYXRjaFBoYXNlc1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgbmV3IGluc3RhbmNlIG9mIGEgQmxlbmQyZFN0YXRlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gcGFzcyB0byB0aGUgQmxlbmQxZFN0YXRlIGNvbnN0cnVjdG9yLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdGlvbnMubmFtZSAtIE5hbWUgZm9yIHRoZSBhbmltYXRpb24gc3RhdGUuIE5hbWVzIG11c3QgYmVcbiAgICogdW5pcXVlIGZvciB0aGUgbGF5ZXIgdGhlIHN0YXRlIGlzIGFwcGxpZWQgdG8uXG4gICAqIEBwYXJhbSB7d2VpZ2h0fSBbb3B0aW9ucy53ZWlnaHQ9MF0gLSBUaGUgMC0xIGFtb3VudCBvZiBpbmZsdWVuY2UgdGhlIHN0YXRlIHdpbGwgaGF2ZS5cbiAgICogQHBhcmFtIHt0aW1lU2NhbGV9IFtvcHRpb25zLnRpbWVTY2FsZT0xXSAtIEZhY3RvciB0byBzY2FsZSB0aGUgcGxheWJhY2sgc3BlZWQgb2YgdGhlXG4gICAqIGFuaW1hdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxvb3BDb3VudD1JbmZpbml0eV0gLSBOdW1iZXIgb2YgdGltZXMgdGhlIGFuaW1hdGlvbiBzaG91bGRcbiAgICogcmVwZWF0IGJlZm9yZSBmaW5pc2hpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5ibGVuZE1vZGU9TGF5ZXJCbGVuZE1vZGVzW0RlZmF1bHRMYXllckJsZW5kTW9kZV1dIC0gVHlwZSBvZlxuICAgKiBibGVuZGluZyB0aGUgYW5pbWF0aW9uIHNob3VsZCB1c2UuXG4gICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IFtvcHRpb25zLmJsZW5kU3RhdGVPcHRpb25zXSAtIEFycmF5IG9mIG9wdGlvbnMgdXNlZCB0byBjcmVhdGUgdGhlXG4gICAqIGJsZW5kIHN0YXRlcyBmb3IgdGhpcyBjb250YWluZXIuXG4gICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gW29wdGlvbnMuYmxlbmRUaHJlc2hvbGRzXSAtIEFycmF5IG9mIEFycmF5IG9mIG51bWJlcnMgdXNlZCB0byBzZXQgdGhlXG4gICAqIHRocmVzaG9sZHMgZm9yIGVhY2ggYmxlbmQgc3RhdGUgaW4gdGhpcyBjb250YWluZXIuXG4gICAqIEBwYXJhbSB7QXJyYXkuPGJvb2xlYW4+fSBbb3B0aW9ucy5ibGVuZE1hdGNoUGhhc2VzPVtdXSAtIE9wdGlvbmFsIGFycmF5IG9mIGJvb2xlYW5zIHVzZWQgdG9cbiAgICogc2V0IHdoZXRoZXIgb3Igbm90IGVhY2ggYmxlbmQgc3RhdGUgaW4gdGhpcyBjb250YWluZXIgd2lsbCBtYXRjaCBwaGFzZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtCbGVuZDFkU3RhdGV9XG4gICAqL1xuICBfY3JlYXRlQmxlbmQyZFN0YXRlKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7YmxlbmRTdGF0ZU9wdGlvbnMgPSBbXX0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHtibGVuZFRocmVzaG9sZHMgPSBbXX0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHtibGVuZE1hdGNoUGhhc2VzID0gW119ID0gb3B0aW9ucztcblxuICAgIGNvbnN0IGJsZW5kU3RhdGVzID0gW107XG4gICAgYmxlbmRTdGF0ZU9wdGlvbnMuZm9yRWFjaChibGVuZE9wdGlvbnMgPT4ge1xuICAgICAgYmxlbmRTdGF0ZXMucHVzaChcbiAgICAgICAgdGhpcy5fY3JlYXRlU2luZ2xlU3RhdGUoey4uLmJsZW5kT3B0aW9ucywgYmxlbmRNb2RlOiBvcHRpb25zLmJsZW5kTW9kZX0pXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyBCbGVuZDJkU3RhdGUoXG4gICAgICBvcHRpb25zLFxuICAgICAgYmxlbmRTdGF0ZXMsXG4gICAgICBibGVuZFRocmVzaG9sZHMsXG4gICAgICBibGVuZE1hdGNoUGhhc2VzXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBuZXcgaW5zdGFuY2Ugb2YgYSBSYW5kb21BbmltYXRpb25TdGF0ZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIHRvIHBhc3MgdG8gdGhlIFJhbmRvbUFuaW1hdGlvblN0YXRlIGNvbnN0cnVjdG9yLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdGlvbnMubmFtZSAtIE5hbWUgZm9yIHRoZSBhbmltYXRpb24gc3RhdGUuIE5hbWVzIG11c3QgYmVcbiAgICogdW5pcXVlIGZvciB0aGUgbGF5ZXIgdGhlIHN0YXRlIGlzIGFwcGxpZWQgdG8uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5wbGF5SW50ZXJ2YWw9M10gLSBUaGUgYmFzZSBhbmltYXRpb24gcGxheWJhY2sgaW50ZXJ2YWwuXG4gICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IFtvcHRpb25zLnN1YlN0YXRlT3B0aW9uc10gLSBBcnJheSBvZiBvcHRpb25zIHVzZWQgdG8gY3JlYXRlIHRoZVxuICAgKiBzdWIgc3RhdGVzIGZvciB0aGlzIGNvbnRhaW5lci5cbiAgICpcbiAgICogQHJldHVybnMge1JhbmRvbUFuaW1hdGlvblN0YXRlfVxuICAgKi9cbiAgX2NyZWF0ZVJhbmRvbUFuaW1hdGlvblN0YXRlKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7c3ViU3RhdGVPcHRpb25zID0gW119ID0gb3B0aW9ucztcblxuICAgIGNvbnN0IHN1YlN0YXRlcyA9IFtdO1xuICAgIHN1YlN0YXRlT3B0aW9ucy5mb3JFYWNoKHN1YlN0YXRlT3B0aW9ucyA9PiB7XG4gICAgICBzdWJTdGF0ZXMucHVzaChcbiAgICAgICAgdGhpcy5fY3JlYXRlU2luZ2xlU3RhdGUoe1xuICAgICAgICAgIC4uLnN1YlN0YXRlT3B0aW9ucyxcbiAgICAgICAgICBibGVuZE1vZGU6IG9wdGlvbnMuYmxlbmRNb2RlLFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBuZXcgUmFuZG9tQW5pbWF0aW9uU3RhdGUob3B0aW9ucywgc3ViU3RhdGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIHN1cmUgdGhlIGxheWVyIHdpdGggdGhlIGdpdmVuIG5hbWUgZXhpc3RzIGFuZCByZXR1cm4gYSB1bmlxdWUgdmVyc2lvblxuICAgKiBvZiB0aGUgYW5pbWF0aW9uIG5hbWUgc3VwcGxpZWQgZm9yIHRoYXQgbGF5ZXIuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0byBjaGVjayBhZ2FpbnN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYW5pbWF0aW9uTmFtZSAtIE5hbWUgb2YgdGhlIGFuaW1hdGlvbiB0byB2YWxpZGF0ZS5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gVmFsaWRhdGVkIGFuaW1hdGlvbiBuYW1lLlxuICAgKi9cbiAgX3ZhbGlkYXRlTmV3QW5pbWF0aW9uKGxheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSkge1xuICAgIC8vIE1ha2Ugc3VyZSB0aGUgbGF5ZXJOYW1lIGlzIHZhbGlkXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllck1hcFtsYXllck5hbWVdO1xuXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBhZGQgYW5pbWF0aW9uIHRvIGxheWVyICR7bGF5ZXJOYW1lfSBmcm9tIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTm8gbGF5ZXIgZXhpc3RzIHdpdGggdGhpcyBuYW1lLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBhbmltYXRpb25OYW1lIGlzIHVuaXF1ZVxuICAgIGNvbnN0IG5hbWUgPSBVdGlscy5nZXRVbmlxdWVOYW1lKGFuaW1hdGlvbk5hbWUsIGxheWVyLmdldFN0YXRlTmFtZXMoKSk7XG5cbiAgICBpZiAobmFtZSAhPT0gYW5pbWF0aW9uTmFtZSkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgQW5pbWF0aW9uIG5hbWUgJHthbmltYXRpb25OYW1lfSBpcyBub3QgdW5pcXVlIGZvciBsYXllciAke2xheWVyLm5hbWV9LiBBbmltYXRpb24gd2lsbCBiZSByZW5hbWVkIHRvICR7bmFtZX0uYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHdoZXRoZXIgb3Igbm90IGFsbCBhbmltYXRpb25zIGFyZSBwYXVzZWQuXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBwYXVzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhdXNlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuIGFycmF5IG9mIG5hbWVzIG9mIGFuaW1hdGlvbiBsYXllcnMuXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59XG4gICAqL1xuICBnZXQgbGF5ZXJzKCkge1xuICAgIHJldHVybiB0aGlzLl9sYXllcnMubWFwKGxheWVyID0+IGxheWVyLm5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbmQgc3RvcmUgYSBuZXcgYW5pbWF0aW9uIGxheWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW25hbWU9J05ld0xheWVyJ10gLSBOYW1lIGZvciB0aGUgbGF5ZXIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gLSBPcHRpb25zIHRvIHBhc3MgdG8ge0BsaW5rIEFuaW1hdGlvbkxheWVyI2NvbnN0cnVjdG9yfVxuICAgKiBAcGFyYW0ge2luZGV4PX0gaW5kZXggLSBJbmRleCB0byBpbnNlcnQgdGhlIG5ldyBsYXllciBhdC4gSWYgbm9uZSBpcyBwcm92aWRlZFxuICAgKiBpdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBlbmQgb2YgdGhlIHN0YWNrLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBJbmRleCBvZiB0aGUgbmV3IGxheWVyLlxuICAgKi9cbiAgYWRkTGF5ZXIobmFtZSA9ICdOZXdMYXllcicsIG9wdGlvbnMgPSB7fSwgaW5kZXgpIHtcbiAgICBjb25zdCBudW1MYXllcnMgPSB0aGlzLl9sYXllcnMubGVuZ3RoO1xuICAgIGxldCBsYXllckluZGV4ID0gaW5kZXg7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlIGdpdmVuIGluZGV4IGlzIHdpdGhpbiB0aGUgcmFuZ2Ugb2YgbGF5ZXJzXG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQgfHwgaW5kZXggPT09IC0xKSB7XG4gICAgICBsYXllckluZGV4ID0gdGhpcy5fbGF5ZXJzLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGF5ZXJJbmRleCA9IHRoaXMuX3ZhbGlkYXRlSW5kZXgoaW5kZXgsIGZhbHNlKTtcblxuICAgICAgaWYgKGxheWVySW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBJbnNlcnQgYXQgdGhlIGJlZ2lubmluZyBpZiB0aGUgdXNlciBwYXNzZWQgaW4gYSBuZWdhdGl2ZSBpbmRleFxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgbGF5ZXJJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGFwcGVuZCB0byB0aGUgZW5kXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGxheWVySW5kZXggPSB0aGlzLl9sYXllcnMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBJbmRleCAke2luZGV4fSBpcyBpbnZhbGlkIGZvciBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5ldyBsYXllciB3aWxsIGJlIGFkZGVkIGF0IHRoZSBjbG9zZXN0IHZhbGlkIGluZGV4OiAke2xheWVySW5kZXh9LmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlIGxheWVyIG5hbWUgaXMgdW5pcXVlXG4gICAgY29uc3QgbGF5ZXJOYW1lID0gVXRpbHMuZ2V0VW5pcXVlTmFtZShuYW1lLCBPYmplY3Qua2V5cyh0aGlzLl9sYXllck1hcCkpO1xuXG4gICAgaWYgKG5hbWUgIT09IGxheWVyTmFtZSkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgTGF5ZXIgbmFtZSAke25hbWV9IGlzIG5vdCB1bmlxdWUuIE5ldyBsYXllciB3aWxsIGJlIGFkZGVkIHdpdGggdGhlIG5hbWUgJHtsYXllck5hbWV9LmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgbGF5ZXIgPSBuZXcgQW5pbWF0aW9uTGF5ZXIoey4uLm9wdGlvbnMsIG5hbWU6IGxheWVyTmFtZX0pO1xuICAgIHRoaXMuX2xheWVyTWFwW2xheWVyTmFtZV0gPSBsYXllcjtcblxuICAgIGlmIChsYXllckluZGV4ID09PSBudW1MYXllcnMpIHtcbiAgICAgIHRoaXMuX2xheWVycy5wdXNoKGxheWVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbGF5ZXJzLnNwbGljZShsYXllckluZGV4LCAwLCBsYXllcik7XG4gICAgfVxuXG4gICAgLy8gTm90aWZ5IHRoYXQgYSBsYXllciBoYXMgYmVlbiBhZGRlZCB0byB0aGUgZmVhdHVyZVxuICAgIGNvbnN0IGV2ZW50RGF0YSA9IHtuYW1lOiBsYXllck5hbWUsIGluZGV4OiBsYXllckluZGV4fTtcbiAgICB0aGlzLmVtaXQodGhpcy5jb25zdHJ1Y3Rvci5FVkVOVFMuYWRkTGF5ZXIsIGV2ZW50RGF0YSk7XG5cbiAgICByZXR1cm4gZXZlbnREYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBhbmltYXRpb24gbGF5ZXIgZnJvbSB0aGUgc3RhY2suIEFuaW1hdGlvbnMgb24gdGhpcyBsYXllciB3aWxsIG5vXG4gICAqIGxvbmdlciBiZSBldmFsdWF0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBmb3IgdGhlIGxheWVyIHRvIHJlbW92ZS5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHJlbW92YWwgd2FzIHN1Y2Nlc3NmdWwuXG4gICAqL1xuICByZW1vdmVMYXllcihuYW1lKSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllck1hcFtuYW1lXTtcblxuICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBEaWQgbm90IHJlbW92ZSBsYXllciAke25hbWV9IGZyb20gaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBsYXllciBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxuICAgICAgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsYXllci5kaXNjYXJkKCk7XG5cbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX2xheWVycy5pbmRleE9mKGxheWVyKTtcbiAgICB0aGlzLl9sYXllcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICBkZWxldGUgdGhpcy5fbGF5ZXJNYXBbbmFtZV07XG5cbiAgICAvLyBOb3RpZnkgdGhhdCBhIGxheWVyIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgZmVhdHVyZVxuICAgIHRoaXMuZW1pdCh0aGlzLmNvbnN0cnVjdG9yLkVWRU5UUy5yZW1vdmVMYXllciwge25hbWUsIGluZGV4fSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZS1vcmRlciB0aGUgbGF5ZXIgc3RhY2sgc28gdGhhdCB0aGUgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpcyBwb3NpdGlvbmVkXG4gICAqIGF0IHRoZSBnaXZlbiBpbmRleC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0byBtb3ZlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBOZXcgaW5kZXggdG8gcG9zaXRpb24gdGhlIGxheWVyIGF0LlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbmV3IGluZGV4IG9mIHRoZSBsYXllclxuICAgKi9cbiAgbW92ZUxheWVyKG5hbWUsIGluZGV4KSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBuYW1lIGlzIHZhbGlkXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllck1hcFtuYW1lXTtcblxuICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgbW92ZSBsYXllciAke25hbWV9IGZyb20gaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBsYXllciBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlIGluZGV4IGZhbGxzIGluIHRoZSByYW5nZSBvZiBleGlzdGluZyBsYXllcnNcbiAgICBjb25zdCBsYXllckluZGV4ID0gdGhpcy5fdmFsaWRhdGVJbmRleChpbmRleCwgdHJ1ZSk7XG4gICAgY29uc3QgbGFzdEluZGV4ID0gdGhpcy5fbGF5ZXJzLmxlbmd0aCAtIDE7XG5cbiAgICBpZiAobGF5ZXJJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgbW92ZSBsYXllciAke25hbWV9IGZyb20gaG9zdCAke3RoaXMuX2hvc3QuaWR9IHRvIGluZGV4ICR7aW5kZXh9LiBJbmRleCBtdXN0IGJlIGluIHRoZSAwIC0gJHtsYXN0SW5kZXh9IHJhbmdlLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgY3VycmVudEluZGV4ID0gdGhpcy5fbGF5ZXJzLmluZGV4T2YobGF5ZXIpO1xuICAgIGlmIChjdXJyZW50SW5kZXggPT09IGxheWVySW5kZXgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgZnJvbSB0aGUgY3VycmVudCBwb3NpdGlvblxuICAgIHRoaXMuX2xheWVycy5zcGxpY2UoY3VycmVudEluZGV4LCAxKTtcblxuICAgIC8vIEluc2VydCBhdCB0aGUgbmV3IHBvc2l0aW9uXG4gICAgaWYgKGxheWVySW5kZXggPT09IGxhc3RJbmRleCkge1xuICAgICAgdGhpcy5fbGF5ZXJzLnB1c2gobGF5ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9sYXllcnMuc3BsaWNlKGxheWVySW5kZXgsIDAsIGxheWVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGF5ZXJJbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIG5hbWUgb2YgYSBsYXllci4gTmFtZXMgbXVzdCBiZSB1bmlxdWUsIGlmIHRoZSBuZXcgbmFtZSBpcyBub3RcbiAgICogdW5pcXVlIGl0IHdpbGwgaGF2ZSB0cmFpbGluZyBudW1iZXJzIGFwcGVuZGVkIHVudGlsIGl0IGlzIHVuaXF1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGN1cnJlbnROYW1lIC0gQ3VycmVudCBuYW1lIG9mIHRoZSBsYXllci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5ld05hbWUgLSBOZXcgbmFtZSB0byBzZXQgb24gdGhlIGxheWVyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgbmV3IG5hbWUgb2YgdGhlIGxheWVyXG4gICAqL1xuICByZW5hbWVMYXllcihjdXJyZW50TmFtZSwgbmV3TmFtZSkge1xuICAgIC8vIE1ha2Ugc3VyZSB0aGUgbmFtZSBpcyB2YWxpZFxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJNYXBbY3VycmVudE5hbWVdO1xuXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCByZW5hbWUgbGF5ZXIgJHtjdXJyZW50TmFtZX0gZnJvbSBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5vIGxheWVyIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgbGF5ZXIgbmFtZSBpcyB1bmlxdWVcbiAgICBjb25zdCBuYW1lID0gVXRpbHMuZ2V0VW5pcXVlTmFtZShuZXdOYW1lLCBPYmplY3Qua2V5cyh0aGlzLl9sYXllck1hcCkpO1xuXG4gICAgaWYgKG5hbWUgIT09IG5ld05hbWUpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYExheWVyIG5hbWUgJHtuZXdOYW1lfSBpcyBub3QgdW5pcXVlLiBMYXllciB3aWxsIGJlIHJlbmFtZWQgdG8gJHtuYW1lfS5gXG4gICAgICApO1xuICAgIH1cblxuICAgIGRlbGV0ZSB0aGlzLl9sYXllck1hcFtjdXJyZW50TmFtZV07XG4gICAgdGhpcy5fbGF5ZXJNYXBbbmFtZV0gPSBsYXllcjtcbiAgICBsYXllci5uYW1lID0gbmFtZTtcblxuICAgIC8vIE5vdGlmeSB0aGF0IGEgbGF5ZXIgaGFzIGJlZW4gcmVuYW1lZCBvbiB0aGUgZmVhdHVyZVxuICAgIHRoaXMuZW1pdCh0aGlzLmNvbnN0cnVjdG9yLkVWRU5UUy5yZW5hbWVMYXllciwge1xuICAgICAgb2xkTmFtZTogY3VycmVudE5hbWUsXG4gICAgICBuZXdOYW1lOiBuYW1lLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB3ZWlnaHQgb2YgYW4gYW5pbWF0aW9uIGxheWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRvIHJldHVybiB3ZWlnaHQgZnJvbS5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGdldExheWVyV2VpZ2h0KG5hbWUpIHtcbiAgICAvLyBNYWtlIHN1cmUgdGhlIG5hbWUgaXMgdmFsaWRcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW25hbWVdO1xuXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBnZXQgd2VpZ2h0IG9uIGxheWVyICR7bmFtZX0gZnJvbSBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5vIGxheWVyIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBsYXllci53ZWlnaHQ7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSB3ZWlnaHQgb2YgYW4gYW5pbWF0aW9uIGxheWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBsYXllciB0byB1cGRhdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3ZWlnaHQgLSBUaGUgd2VpZ2h0IHZhbHVlIHRvIHNldCBvbiB0aGUgbGF5ZXIuIFRoaXMgbnVtYmVyXG4gICAqIHNob3VsZCBiZSBpbiB0aGUgMC0xIHJhbmdlLlxuICAgKiBAcGFyYW0ge251bWJlcj19IHNlY29uZHMgLSBUaGUgbnVtYmVyIG9mIHNlY29uZHMgaXQgc2hvdWxkIHRha2UgdG8gcmVhY2ggdGhlXG4gICAqIG5ldyB3ZWlnaHQuIERlZmF1bHQgaXMgemVybyBhbmQgd2lsbCBzZXQgaW1tZWRpYXRlbHkuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBlYXNpbmdGbiAtIFRoZSBlYXNpbmcgZnVuY3Rpb24gdG8gdXNlIHdoaWxlIGludGVycG9sYXRpbmdcbiAgICogdGhlIHdlaWdodC4gRGVmYXVsdCBpcyBFYXNpbmcuTGluZWFyLkluT3V0LlxuICAgKlxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9IEEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSBvbmNlIHRoZSBsYXllcidzIHdlaWdodCByZWFjaGVzXG4gICAqIHRoZSB0YXJnZXQgdmFsdWUuXG4gICAqL1xuICBzZXRMYXllcldlaWdodChuYW1lLCB3ZWlnaHQsIHNlY29uZHMsIGVhc2luZ0ZuKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBuYW1lIGlzIHZhbGlkXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllck1hcFtuYW1lXTtcblxuICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBlID0gYENhbm5vdCBzZXQgd2VpZ2h0IG9uIGxheWVyICR7bmFtZX0gZnJvbSBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5vIGxheWVyIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gO1xuICAgICAgcmV0dXJuIERlZmVycmVkLnJlamVjdChlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGF5ZXIuc2V0V2VpZ2h0KHdlaWdodCwgc2Vjb25kcywgZWFzaW5nRm4pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG5hbWVzIG9mIGJsZW5kIHN0YXRlcyBpbiBhbiBhbmltYXRpb24gaW4gYSBsYXllci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIGNvbnRhaW5pbmcgdGhlIGFuaW1hdGlvbiBjb250YWluaW5nXG4gICAqIHRoZSBibGVuZCBzdGF0ZSB0byB1cGRhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbmltYXRpb25OYW1lIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uIGNvbnRhaW5pbmcgdGhlIGJsZW5kIHN0YXRlXG4gICAqIHRvIHVwZGF0ZS5cbiAgICpcbiAgICogQHJldHVybnMge0FycmF5LjxzdHJpbmc+fSAtIE5hbWVzIG9mIGJsZW5kIHN0YXRlcy5cbiAgICovXG4gIGdldEFuaW1hdGlvbkJsZW5kTmFtZXMobGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lKSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllck1hcFtsYXllck5hbWVdO1xuXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBnZXQgYmxlbmQgbmFtZXMgb24gbGF5ZXIgJHtsYXllck5hbWV9IGZyb20gaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBsYXllciBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGF5ZXIuZ2V0QW5pbWF0aW9uQmxlbmROYW1lcyhhbmltYXRpb25OYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHdlaWdodCBmb3IgYSBibGVuZCBzdGF0ZSBpbiBhbiBhbmltYXRpb24gaW4gYSBsYXllci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIGNvbnRhaW5pbmcgdGhlIGFuaW1hdGlvbiBjb250YWluaW5nXG4gICAqIHRoZSBibGVuZCBzdGF0ZSB0byB1cGRhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbmltYXRpb25OYW1lIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uIGNvbnRhaW5pbmcgdGhlIGJsZW5kIHN0YXRlXG4gICAqIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGJsZW5kTmFtZSAtIE5hbWUgb2YgdGhlIGJsZW5kIHN0YXRlIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHdlaWdodCAtIFdlaWdodCB2YWx1ZSB0byBzZXQgb24gdGhlIGFuaW1hdGlvbi4gVGhpcyBudW1iZXIgc2hvdWRsZCBiZVxuICAgKiBpbiB0aGUgMC0xIHJhbmdlLlxuICAgKiBAcGFyYW0ge251bWJlcj19IHNlY29uZHMgLSBOdW1iZXIgb2Ygc2Vjb25kcyBpdCBzaG91bGQgdGFrZSB0byByZWFjaCB0aGUgbmV3IHdlaWdodC5cbiAgICogRGVmYXVsdCBpcyB6ZXJvIGFuZCB3aWxsIHNldCBpbW1lZGlhdGVseS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGVhc2luZ0ZuIC0gRWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSB3aGlsZSBpbnRlcnBvbGF0aW5nIHRoZSBuZXdcbiAgICogd2VpZ2h0LiBEZWZhdWx0IGlzIEVhc2luZy5MaW5lYXIuSW5PdXQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH0gLSBQcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIG9uY2UgdGhlIGFuaW1hdGlvbidzIHdlaWdodCByZWFjaGVzXG4gICAqIHRoZSB0YXJnZXQgdmFsdWUuXG4gICAqL1xuICBzZXRBbmltYXRpb25CbGVuZFdlaWdodChcbiAgICBsYXllck5hbWUsXG4gICAgYW5pbWF0aW9uTmFtZSxcbiAgICBibGVuZE5hbWUsXG4gICAgd2VpZ2h0LFxuICAgIHNlY29uZHMsXG4gICAgZWFzaW5nRm5cbiAgKSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllck1hcFtsYXllck5hbWVdO1xuXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGUgPSBgQ2Fubm90IHNldCBibGVuZCB3ZWlnaHQgb24gbGF5ZXIgJHtsYXllck5hbWV9IGZyb20gaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBsYXllciBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYDtcbiAgICAgIHJldHVybiBEZWZlcnJlZC5yZWplY3QoZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxheWVyLnNldEFuaW1hdGlvbkJsZW5kV2VpZ2h0KFxuICAgICAgYW5pbWF0aW9uTmFtZSxcbiAgICAgIGJsZW5kTmFtZSxcbiAgICAgIHdlaWdodCxcbiAgICAgIHNlY29uZHMsXG4gICAgICBlYXNpbmdGblxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgd2VpZ2h0IGZvciBhIGJsZW5kIHN0YXRlIGluIGFuIGFuaW1hdGlvbiBpbiBhIGxheWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgY29udGFpbmluZyB0aGUgYW5pbWF0aW9uIGNvbnRhaW5pbmdcbiAgICogdGhlIGJsZW5kIHN0YXRlIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFuaW1hdGlvbk5hbWUgLSBOYW1lIG9mIHRoZSBhbmltYXRpb24gY29udGFpbmluZyB0aGUgYmxlbmQgc3RhdGVcbiAgICogdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYmxlbmROYW1lIC0gTmFtZSBvZiB0aGUgYmxlbmQgc3RhdGUgdG8gdXBkYXRlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIFdlaWdodCBvZiB0aGUgYmxlbmQgc3RhdGUuXG4gICAqL1xuICBnZXRBbmltYXRpb25CbGVuZFdlaWdodChsYXllck5hbWUsIGFuaW1hdGlvbk5hbWUsIGJsZW5kTmFtZSkge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJNYXBbbGF5ZXJOYW1lXTtcblxuICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgZ2V0IGJsZW5kIHdlaWdodCBvbiBsYXllciAke2xheWVyTmFtZX0gZnJvbSBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5vIGxheWVyIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBsYXllci5nZXRBbmltYXRpb25CbGVuZFdlaWdodChhbmltYXRpb25OYW1lLCBibGVuZE5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdXNlIHdlaWdodCBpbnRlcnBvbGF0aW9uIGFuaW1hdGlvbiBvbiBhIGxheWVyIHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdG8gcGF1c2UuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAtIFdoZXRoZXIgb3Igbm90IHRoZXJlIHdhcyBhbiBleGlzdGluZyBpbnRlcnBvbGF0aW9uIHRvIHBhdXNlLlxuICAgKi9cbiAgcGF1c2VMYXllcldlaWdodChuYW1lKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBuYW1lIGlzIHZhbGlkXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllck1hcFtuYW1lXTtcblxuICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgcGF1c2Ugd2VpZ2h0IGludGVycG9sYXRpb24gb24gbGF5ZXIgJHtuYW1lfSBmcm9tIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTm8gbGF5ZXIgZXhpc3RzIHdpdGggdGhpcyBuYW1lLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxheWVyLnBhdXNlV2VpZ2h0KCk7XG4gIH1cblxuICAvKipcbiAgICogUmVzdW1lIHdlaWdodCBpbnRlcnBvbGF0aW9uIGFuaW1hdGlvbiBvbiBhIGxheWVyIHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdG8gcmVzdW1lLlxuICAgKlxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9IC0gUmVzb2x2ZXMgb25jZSB0aGUgbGF5ZXIncyB3ZWlnaHQgcmVhY2hlcyBpdHMgdGFyZ2V0IHZhbHVlLlxuICAgKi9cbiAgcmVzdW1lTGF5ZXJXZWlnaHQobmFtZSkge1xuICAgIC8vIE1ha2Ugc3VyZSB0aGUgbmFtZSBpcyB2YWxpZFxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJNYXBbbmFtZV07XG5cbiAgICBpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgZSA9IGBDYW5ub3QgcmVzdW1lIHdlaWdodCBpbnRlcnBvbGF0aW9uIG9uIGxheWVyICR7bmFtZX0gZnJvbSBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5vIGxheWVyIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gO1xuICAgICAgcmV0dXJuIERlZmVycmVkLnJlamVjdChlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGF5ZXIucmVzdW1lV2VpZ2h0KCk7XG4gIH1cblxuICAvKipcbiAgICogUGF1c2UgY3VycmVudCBhbmltYXRpb24gYW5kIHdlaWdodCBpbnRlcnBvbGF0aW9uIGFuaW1hdGlvbiBvbiBhIGxheWVyIHdpdGhcbiAgICogdGhlIGdpdmVuIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdG8gcGF1c2UuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAtIFdoZXRoZXIgb3Igbm90IHRoZXJlIHdhcyBhbiBleGlzdGluZyBpbnRlcnBvbGF0aW9uIG9yXG4gICAqIGN1cnJlbnQgYW5pbWF0aW9uIHRvIHBhdXNlLlxuICAgKi9cbiAgcGF1c2VMYXllcihuYW1lKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBuYW1lIGlzIHZhbGlkXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllck1hcFtuYW1lXTtcblxuICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgcGF1c2UgbGF5ZXIgJHtuYW1lfSBmcm9tIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTm8gbGF5ZXIgZXhpc3RzIHdpdGggdGhpcyBuYW1lLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxheWVyLnBhdXNlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVzdW1lIGN1cnJlbnQgYW5pbWF0aW9uIGFuZCB3ZWlnaHQgaW50ZXJwb2xhdGlvbiBhbmltYXRpb24gb24gYSBsYXllciB3aXRoXG4gICAqIHRoZSBnaXZlbiBuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRvIHJlc3VtZS5cbiAgICpcbiAgICogQHJldHVybnMge0RlZmVycmVkfSAtIFJlc29sdmVzIG9uY2UgdGhlIGxheWVyJ3Mgd2VpZ2h0IHJlYWNoZXMgaXRzIHRhcmdldCB2YWx1ZVxuICAgKiBhbmQgaXQncyBjdXJyZW50IGFuaW1hdGlvbiBmaW5pc2hlcyBwbGF5aW5nLlxuICAgKi9cbiAgcmVzdW1lTGF5ZXIobmFtZSkge1xuICAgIC8vIE1ha2Ugc3VyZSB0aGUgbmFtZSBpcyB2YWxpZFxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJNYXBbbmFtZV07XG5cbiAgICBpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgZSA9IGBDYW5ub3QgcmVzdW1lIGxheWVyICR7bmFtZX0gZnJvbSBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5vIGxheWVyIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gO1xuICAgICAgcmV0dXJuIERlZmVycmVkLnJlamVjdChlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGF5ZXIucmVzdW1lKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgb3Igbm90IHRoZSBhbmltYXRpb24gbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpcyBjdXJyZW50bHlcbiAgICogdHJhbnNpdGlvbmluZyBiZXR3ZWVuIGFuaW1hdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0byBjaGVjay5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBnZXRUcmFuc2l0aW9uaW5nKGxheWVyTmFtZSkge1xuICAgIC8vIE1ha2Ugc3VyZSB0aGUgbGF5ZXJOYW1lIGlzIHZhbGlkXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllck1hcFtsYXllck5hbWVdO1xuXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEdldCB0cmFuc2l0aW9uaW5nIG9uIGxheWVyICR7bGF5ZXJOYW1lfSBmcm9tIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTm8gbGF5ZXIgZXhpc3RzIHdpdGggdGhpcyBuYW1lLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxheWVyLmlzVHJhbnNpdGlvbmluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgdGhlIG5hbWVzIG9mIGFsbCBzdGF0ZXMgdGhlIGxheWVyIHdpdGggdGhlIGdpdmVuIG5hbWUgY29udHJvbHMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0byBzZWFyY2guXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheS48c3RyaW5nPn1cbiAgICovXG4gIGdldEFuaW1hdGlvbnMobGF5ZXJOYW1lKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBsYXllck5hbWUgaXMgdmFsaWRcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW2xheWVyTmFtZV07XG5cbiAgICBpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgR2V0IGFuaW1hdGlvbnMgb24gbGF5ZXIgJHtsYXllck5hbWV9IGZyb20gaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBsYXllciBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGF5ZXIuZ2V0U3RhdGVOYW1lcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbmFtZSBvZiB0aGUgc3RhdGUgY3VycmVudGx5IGFjdGl2ZSBvbiB0aGUgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAgICogUmV0dXJuIG51bGwgaWYgdGhlcmUgaXMgbm8gY3VycmVudCBhbmltYXRpb24gZm9yIHRoZSBsYXllci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7KHN0cmluZ3xudWxsKX1cbiAgICovXG4gIGdldEN1cnJlbnRBbmltYXRpb24obGF5ZXJOYW1lKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBsYXllck5hbWUgaXMgdmFsaWRcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW2xheWVyTmFtZV07XG5cbiAgICBpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgR2V0IGN1cnJlbnQgYW5pbWF0aW9uIG9uIGxheWVyICR7bGF5ZXJOYW1lfSBmcm9tIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTm8gbGF5ZXIgZXhpc3RzIHdpdGggdGhpcyBuYW1lLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxheWVyLmN1cnJlbnRBbmltYXRpb247XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgb3Igbm90IGEgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpcyBjdXJyZW50bHkgcGxheWluZyBhblxuICAgKiBhbmltYXRpb24gYW5kIHRoYXQgYW5pbWF0aW9uIGlzIHBhdXNlZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGdldFBhdXNlZChsYXllck5hbWUpIHtcbiAgICAvLyBNYWtlIHN1cmUgdGhlIGxheWVyTmFtZSBpcyB2YWxpZFxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJNYXBbbGF5ZXJOYW1lXTtcblxuICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBHZXQgcGF1c2VkIG9uIGxheWVyICR7bGF5ZXJOYW1lfSBmcm9tIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTm8gbGF5ZXIgZXhpc3RzIHdpdGggdGhpcyBuYW1lLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxheWVyLmN1cnJlbnRTdGF0ZSAmJiBsYXllci5jdXJyZW50U3RhdGUucGF1c2VkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgdHlwZSBuYW1lIG9mIHRoZSBnaXZlbiBhbmltYXRpb24uIEBzZWUgQW5pbWF0aW9uVHlwZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0aGF0IGNvbnRhaW5zIHRoZSBhbmltYXRpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbmltYXRpb25OYW1lIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRvIGNoZWNrLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0QW5pbWF0aW9uVHlwZShsYXllck5hbWUsIGFuaW1hdGlvbk5hbWUpIHtcbiAgICAvLyBNYWtlIHN1cmUgdGhlIGxheWVyTmFtZSBpcyB2YWxpZFxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJNYXBbbGF5ZXJOYW1lXTtcblxuICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBHZXQgYW5pbWF0aW9uIHR5cGUgb24gbGF5ZXIgJHtsYXllck5hbWV9IGZyb20gaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBsYXllciBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdGF0ZSA9IGxheWVyLmdldFN0YXRlKGFuaW1hdGlvbk5hbWUpO1xuXG4gICAgaWYgKHN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEdldCBhbmltYXRpb24gdHlwZSBmb3IgYW5pbWF0aW9uICR7YW5pbWF0aW9uTmFtZX0gb24gbGF5ZXIgJHtsYXllck5hbWV9IGZyb20gaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBhbmltYXRpb24gZXhpc3RzIHdpdGggdGhpcyBuYW1lLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3Qge2NvbnN0cnVjdG9yfSA9IHN0YXRlO1xuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKEFuaW1hdGlvblR5cGVzKS5maW5kKFxuICAgICAgdHlwZU5hbWUgPT4gQW5pbWF0aW9uVHlwZXNbdHlwZU5hbWVdID09PSBjb25zdHJ1Y3RvclxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgbmV3IGFuaW1hdGlvbiB0byBhbiBhbmltYXRpb24gbGF5ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0byBhZGQgdGhlIGFuaW1hdGlvbiB0by5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFuaW1hdGlvbk5hbWUgLSBOYW1lIHRvIHVzZSB3aGVuIGNhbGxpbmcgdGhlIGFuaW1hdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIC0gT3B0aW9ucyB0byBwYXNzIHRvIHRoZSBjb25zdHJ1Y3RvciBmb3IgdGhlIG5ld1xuICAgKiBTaW5nbGVTdGF0ZSBhbmltYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVGhlIG5hbWUgb2YgdGhlIGFuaW1hdGlvbiB0aGF0IHdhcyBhZGRlZFxuICAgKi9cbiAgYWRkQW5pbWF0aW9uKFxuICAgIGxheWVyTmFtZSxcbiAgICBhbmltYXRpb25OYW1lLFxuICAgIGFuaW1hdGlvblR5cGUgPSBBbmltYXRpb25UeXBlcy5zaW5nbGUsXG4gICAgb3B0aW9ucyA9IHt9XG4gICkge1xuICAgIG9wdGlvbnMubmFtZSA9IHRoaXMuX3ZhbGlkYXRlTmV3QW5pbWF0aW9uKGxheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSk7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlIGFuaW1hdGlvbiB0eXBlIGlzIHZhbGlkXG4gICAgaWYgKCFPYmplY3QudmFsdWVzKEFuaW1hdGlvblR5cGVzKS5pbmNsdWRlcyhhbmltYXRpb25UeXBlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGFkZCBhbmltYXRpb24gJHthbmltYXRpb25OYW1lfSB0byBsYXllciAke2xheWVyTmFtZX0gb24gaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBJbnZhbGlkIGFuaW1hdGlvbiB0eXBlLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllck1hcFtsYXllck5hbWVdO1xuICAgIG9wdGlvbnMuYmxlbmRNb2RlID0gbGF5ZXIuYmxlbmRNb2RlO1xuICAgIG9wdGlvbnMudHJhbnNpdGlvblRpbWUgPSBsYXllci50cmFuc2l0aW9uVGltZTtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXNbYF9jcmVhdGUke2FuaW1hdGlvblR5cGUubmFtZX1gXShvcHRpb25zKTtcblxuICAgIGNvbnN0IG5hbWUgPSBsYXllci5hZGRTdGF0ZShzdGF0ZSk7XG5cbiAgICAvLyBOb3RpZnkgdGhhdCBhbiBhbmltYXRpb24gaGFzIGJlZW4gYWRkZWQgdG8gdGhlIGZlYXR1cmVcbiAgICB0aGlzLmVtaXQodGhpcy5jb25zdHJ1Y3Rvci5FVkVOVFMuYWRkQW5pbWF0aW9uLCB7XG4gICAgICBsYXllck5hbWUsXG4gICAgICBhbmltYXRpb25OYW1lOiBuYW1lLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGFuaW1hdGlvbiBmcm9tIGFuIGFuaW1hdGlvbiBsYXllci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRvIHJlbW92ZSB0aGUgYW5pbWF0aW9uIGZyb20uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRvIHJlbW92ZS5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICByZW1vdmVBbmltYXRpb24obGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBuYW1lIGlzIHZhbGlkXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllck1hcFtsYXllck5hbWVdO1xuXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCByZW1vdmUgYW5pbWF0aW9uIGZyb20gbGF5ZXIgJHtsYXllck5hbWV9IGZyb20gaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBsYXllciBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCByZW1vdmVkID0gbGF5ZXIucmVtb3ZlU3RhdGUoYW5pbWF0aW9uTmFtZSk7XG5cbiAgICAvLyBOb3RpZnkgdGhhdCBhbiBhbmltYXRpb24gaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBmZWF0dXJlXG4gICAgaWYgKHJlbW92ZWQgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuZW1pdCh0aGlzLmNvbnN0cnVjdG9yLkVWRU5UUy5yZW1vdmVBbmltYXRpb24sIHtcbiAgICAgICAgbGF5ZXJOYW1lLFxuICAgICAgICBhbmltYXRpb25OYW1lLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbW92ZWQ7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBuYW1lIG9mIGFuIGFuaW1hdGlvbi4gTmFtZXMgbXVzdCBiZSB1bmlxdWUgb24gZWFjaCBsYXllciwgaWYgdGhlIG5ld1xuICAgKiBuYW1lIGlzIG5vdCB1bmlxdWUgaXQgd2lsbCBoYXZlIHRyYWlsaW5nIG51bWJlcnMgYXBwZW5kZWQgdW50aWwgaXQgaXMgdW5pcXVlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCBjb250YWlucyB0aGUgYW5pbWF0aW9uIHRoYXRcbiAgICogd2lsbCBiZSByZW5hbWVkLFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY3VycmVudEFuaW1hdGlvbk5hbWUgLSBDdXJyZW50IG5hbWUgb2YgdGhlIGFuaW1hdGlvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5ld0FuaW1hdGlvbk5hbWUgLSBOZXcgbmFtZSB0byBzZXQgb24gdGhlIGFuaW1hdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gLSBUaGUgbmV3IG5hbWUgb2YgdGhlIGFuaW1hdGlvblxuICAgKi9cbiAgcmVuYW1lQW5pbWF0aW9uKGxheWVyTmFtZSwgY3VycmVudEFuaW1hdGlvbk5hbWUsIG5ld0FuaW1hdGlvbk5hbWUpIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW2xheWVyTmFtZV07XG5cbiAgICBpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IHJlbmFtZSBhbmltYXRpb24gJHtjdXJyZW50QW5pbWF0aW9uTmFtZX0gb24gbGF5ZXIgJHtsYXllck5hbWV9IGZvciBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5vIGxheWVyIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IG5hbWUgPSBsYXllci5yZW5hbWVTdGF0ZShjdXJyZW50QW5pbWF0aW9uTmFtZSwgbmV3QW5pbWF0aW9uTmFtZSk7XG5cbiAgICAvLyBOb3RpZnkgdGhhdCBhbiBhbmltYXRpb24gaGFzIGJlZW4gcmVuYW1lZCBvbiB0aGUgZmVhdHVyZVxuICAgIHRoaXMuZW1pdCh0aGlzLmNvbnN0cnVjdG9yLkVWRU5UUy5yZW5hbWVBbmltYXRpb24sIHtcbiAgICAgIGxheWVyTmFtZSxcbiAgICAgIG9sZE5hbWU6IGN1cnJlbnRBbmltYXRpb25OYW1lLFxuICAgICAgbmV3TmFtZTogbmFtZSxcbiAgICB9KTtcblxuICAgIHJldHVybiBuYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdXNlIHRoZSBjdXJyZW50bHkgcGxheWluZyBhbmltYXRpb24gYW5kIHBsYXkgYSBuZXcgYW5pbWF0aW9uIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRoYXQgY29udGFpbnMgdGhlIGFuaW1hdGlvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFuaW1hdGlvbk5hbWUgLSBOYW1lIG9mIHRoZSBhbmltYXRpb24gc3RhdGUgdG8gcGxheS5cbiAgICogQHBhcmFtIHtudW1iZXI9fSBzZWNvbmRzIC0gVGhlIG51bWJlciBvZiBzZWNvbmRzIGl0IHNob3VsZCB0YWtlIHRvIHRyYW5zaXRpb25cbiAgICogdG8gdGhlIG5ldyBhbmltYXRpb24uIERlZmF1bHQgaXMgemVybyBhbmQgd2lsbCBzZXQgaW1tZWRpYXRlbHkuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBlYXNpbmdGbiAtIFRoZSBlYXNpbmcgZnVuY3Rpb24gdG8gdXNlIHdoaWxlIHRyYW5zaXRpb25pbmdcbiAgICogYmV0d2VlbiBhbmltYXRpb25zLiBEZWZhdWx0IGlzIEVhc2luZy5MaW5lYXIuSW5PdXQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH0gLSBSZXNvbHZlcyBvbmNlIHRoZSBhbmltYXRpb24gcmVhY2hlcyB0aGUgZW5kIG9mIGl0c1xuICAgKiB0aW1lbGluZS4gTG9vcGluZyBhbmltYXRpb25zIGNhbiBvbmx5IHJlc29sdmUgaWYgdGhleSBhcmUgaW50ZXJydXB0ZWQgb3JcbiAgICogbWFudWFsbHkgc3RvcHBlZC5cbiAgICovXG4gIHBsYXlBbmltYXRpb24obGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lLCBzZWNvbmRzLCBlYXNpbmdGbikge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJNYXBbbGF5ZXJOYW1lXTtcblxuICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBlID0gYENhbm5vdCBwbGF5IGFuaW1hdGlvbiAke2FuaW1hdGlvbk5hbWV9IG9uIGxheWVyICR7bGF5ZXJOYW1lfSBmb3IgaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBsYXllciBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYDtcbiAgICAgIHJldHVybiBEZWZlcnJlZC5yZWplY3QoZSk7XG4gICAgfVxuXG4gICAgLy8gTm90aWZ5IHRoYXQgYSBuZXcgYW5pbWF0aW9uIGhhcyBiZWd1blxuICAgIHRoaXMuZW1pdCh0aGlzLmNvbnN0cnVjdG9yLkVWRU5UUy5wbGF5QW5pbWF0aW9uLCB7XG4gICAgICBsYXllck5hbWUsXG4gICAgICBhbmltYXRpb25OYW1lLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGxheWVyLnBsYXlBbmltYXRpb24oXG4gICAgICBhbmltYXRpb25OYW1lLFxuICAgICAgc2Vjb25kcyxcbiAgICAgIGVhc2luZ0ZuLFxuICAgICAgKCkgPT4ge1xuICAgICAgICAvLyBOb3RpZnkgdGhhdCBhbiBhbmltYXRpb24gaGFzIHN0b3BwZWRcbiAgICAgICAgdGhpcy5lbWl0KHRoaXMuY29uc3RydWN0b3IuRVZFTlRTLnN0b3BBbmltYXRpb24sIHtcbiAgICAgICAgICBsYXllck5hbWUsXG4gICAgICAgICAgYW5pbWF0aW9uTmFtZSxcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgKCkgPT4ge1xuICAgICAgICAvLyBOb3RpZnkgdGhhdCBhbiBhbmltYXRpb24gaGFzIGJlZW4gaW50ZXJydXB0ZWRcbiAgICAgICAgdGhpcy5lbWl0KHRoaXMuY29uc3RydWN0b3IuRVZFTlRTLmludGVycnVwdEFuaW1hdGlvbiwge1xuICAgICAgICAgIGxheWVyTmFtZSxcbiAgICAgICAgICBhbmltYXRpb25OYW1lLFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICAoe25hbWUsIGNhbkFkdmFuY2UsIGlzUXVldWVFbmR9KSA9PiB7XG4gICAgICAgIGlmIChsYXllci5jdXJyZW50QW5pbWF0aW9uID09PSBhbmltYXRpb25OYW1lKSB7XG4gICAgICAgICAgLy8gTm90aWZ5IHRoYXQgYSBuZXcgYW5pbWF0aW9uIGhhcyBiZWd1blxuICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLmNvbnN0cnVjdG9yLkVWRU5UUy5wbGF5TmV4dEFuaW1hdGlvbiwge1xuICAgICAgICAgICAgbGF5ZXJOYW1lLFxuICAgICAgICAgICAgYW5pbWF0aW9uTmFtZSxcbiAgICAgICAgICAgIG5leHRRdWV1ZWRBbmltYXRpb246IG5hbWUsXG4gICAgICAgICAgICBjYW5BZHZhbmNlLFxuICAgICAgICAgICAgaXNRdWV1ZUVuZCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUGxheSB0aGUgbmV4dCBhbmltYXRpb24gaW4gdGhlIHF1ZXVlIG9mIGEgUXVldWVTdGF0ZSBhbmltYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0aGF0IGNvbnRhaW5zIHRoZSBxdWV1ZSBhbmltYXRpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gYW5pbWF0aW9uTmFtZSAtIE5hbWUgb2YgdGhlIGFuaW1hdGlvbiBxdWV1ZSBhbmltYXRpb24uIERlZmF1bHRzXG4gICAqIHRvIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBmb3IgdGhlIGxheWVyLlxuICAgKiBAcGFyYW0ge251bWJlcj19IHNlY29uZHMgLSBUaGUgbnVtYmVyIG9mIHNlY29uZHMgaXQgc2hvdWxkIHRha2UgdG8gdHJhbnNpdGlvblxuICAgKiB0byB0aGUgcXVldWUgYW5pbWF0aW9uIGlmIGl0J3Mgbm90IGFscmVhZHkgY3VycmVudGx5IHBsYXlpbmcuIERlZmF1bHQgaXMgemVyb1xuICAgKiBhbmQgd2lsbCBzZXQgaW1tZWRpYXRlbHkuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBlYXNpbmdGbiAtIFRoZSBlYXNpbmcgZnVuY3Rpb24gdG8gdXNlIHdoaWxlIHRyYW5zaXRpb25pbmdcbiAgICogdG8gdGhlIHF1ZXVlIGFuaW1hdGlvbiBpZiBpdCBpc24ndCBhbHJlYWR5IHBsYXlpbmcuIERlZmF1bHQgaXMgRWFzaW5nLkxpbmVhci5Jbk91dC5cbiAgICpcbiAgICogQHJldHVybnMge0RlZmVycmVkfSAtIFJlc29sdmVzIG9uY2UgdGhlIGxhc3QgYW5pbWF0aW9uIGluIHRoZSBxdWV1ZSBmaW5pc2hlc1xuICAgKiBwbGF5aW5nLlxuICAgKi9cbiAgcGxheU5leHRBbmltYXRpb24obGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lLCB0cmFuc2l0aW9uVGltZSwgZWFzaW5nRm4pIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW2xheWVyTmFtZV07XG5cbiAgICBpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgZSA9IGBDYW5ub3QgcGxheSBuZXh0IGFuaW1hdGlvbiBvbiBsYXllciAke2xheWVyTmFtZX0gZm9yIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTm8gbGF5ZXIgZXhpc3RzIHdpdGggdGhpcyBuYW1lLmA7XG4gICAgICByZXR1cm4gRGVmZXJyZWQucmVqZWN0KGUpO1xuICAgIH1cblxuICAgIGlmIChhbmltYXRpb25OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGFuaW1hdGlvbk5hbWUgPSBsYXllci5jdXJyZW50QW5pbWF0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IGFuaW1hdGlvbiA9IGxheWVyLmdldFN0YXRlKGxheWVyLmN1cnJlbnRBbmltYXRpb24pO1xuXG4gICAgaWYgKGFuaW1hdGlvbiA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgZSA9IGBDYW5ub3QgcGxheSBuZXh0IGFuaW1hdGlvbiBvbiBsYXllciAke2xheWVyTmFtZX0gZm9yIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTm8gYW5pbWF0aW9uIGV4aXN0cyB3aXRoIG5hbWUgJHthbmltYXRpb25OYW1lfS5gO1xuICAgICAgcmV0dXJuIERlZmVycmVkLnJlamVjdChlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZ2V0QW5pbWF0aW9uVHlwZShsYXllck5hbWUsIGFuaW1hdGlvbk5hbWUpICE9PSAncXVldWUnKSB7XG4gICAgICBjb25zdCBlID0gYENhbm5vdCBwbGF5IG5leHQgYW5pbWF0aW9uIG9uIGxheWVyICR7bGF5ZXJOYW1lfSBmb3IgaG9zdCAke3RoaXMuX2hvc3QuaWR9LiAke2FuaW1hdGlvbk5hbWV9IGlzIG5vdCBhIHF1ZXVlIHN0YXRlLmA7XG4gICAgICByZXR1cm4gRGVmZXJyZWQucmVqZWN0KGUpO1xuICAgIH1cblxuICAgIGNvbnN0IG9uTmV4dCA9ICh7bmFtZSwgY2FuQWR2YW5jZSwgaXNRdWV1ZUVuZH0pID0+IHtcbiAgICAgIGlmIChsYXllci5jdXJyZW50QW5pbWF0aW9uID09PSBhbmltYXRpb25OYW1lKSB7XG4gICAgICAgIC8vIE5vdGlmeSB0aGF0IGEgbmV3IGFuaW1hdGlvbiBoYXMgYmVndW5cbiAgICAgICAgdGhpcy5lbWl0KHRoaXMuY29uc3RydWN0b3IuRVZFTlRTLnBsYXlOZXh0QW5pbWF0aW9uLCB7XG4gICAgICAgICAgbGF5ZXJOYW1lLFxuICAgICAgICAgIGFuaW1hdGlvbk5hbWUsXG4gICAgICAgICAgbmV4dFF1ZXVlZEFuaW1hdGlvbjogbmFtZSxcbiAgICAgICAgICBjYW5BZHZhbmNlLFxuICAgICAgICAgIGlzUXVldWVFbmQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBNYWtlIHRoZSBxdWV1ZSBhbmltYXRpb24gY3VycmVudCBpZiBpdCB3YXNuJ3QgYWxyZWFkeVxuICAgIGlmIChsYXllci5jdXJyZW50QW5pbWF0aW9uID09PSBudWxsKSB7XG4gICAgICBsYXllci5yZXN1bWVBbmltYXRpb24oXG4gICAgICAgIGFuaW1hdGlvbi5uYW1lLFxuICAgICAgICB0cmFuc2l0aW9uVGltZSxcbiAgICAgICAgZWFzaW5nRm4sXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIG9uTmV4dFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5pbWF0aW9uLm5leHQob25OZXh0LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXVzZSB0aGUgY3VycmVudCBhbmltYXRpb24gb24gYSBsYXllci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0byBwYXVzZS5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IGFuIGFuaW1hdGlvbiB3YXMgc3VjY2Vzc2Z1bGx5IHBhdXNlZC5cbiAgICovXG4gIHBhdXNlQW5pbWF0aW9uKG5hbWUpIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW25hbWVdO1xuXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYERpZCBub3QgcGF1c2UgYW5pbWF0aW9uIG9uIGxheWVyICR7bmFtZX0gZm9yIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTm8gbGF5ZXIgZXhpc3RzIHdpdGggdGhpcyBuYW1lLmBcbiAgICAgICk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgcGF1c2VkID0gbGF5ZXIucGF1c2VBbmltYXRpb24oKTtcblxuICAgIC8vIE5vdGlmeSB0aGF0IGFuIGFuaW1hdGlvbiB3YXMgcGF1c2VkXG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgY29uc3QgYW5pbWF0aW9uTmFtZSA9IGxheWVyLmN1cnJlbnRBbmltYXRpb247XG4gICAgICB0aGlzLmVtaXQodGhpcy5jb25zdHJ1Y3Rvci5FVkVOVFMucGF1c2VBbmltYXRpb24sIHtcbiAgICAgICAgbGF5ZXJOYW1lOiBuYW1lLFxuICAgICAgICBhbmltYXRpb25OYW1lLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdXNlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXVzZSB0aGUgY3VycmVudGx5IHBsYXlpbmcgYW5pbWF0aW9uIGFuZCBwbGF5IGEgbmV3IGFuaW1hdGlvbiBmcm9tIHdoZXJlIGl0XG4gICAqIGxhc3QgbGVmdCBvZmYuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0aGF0IGNvbnRhaW5zIHRoZSBhbmltYXRpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gYW5pbWF0aW9uTmFtZSAtIE5hbWUgb2YgdGhlIGFuaW1hdGlvbiBzdGF0ZSB0byByZXN1bWUuIERlZmF1bHRzXG4gICAqIHRvIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBmb3IgdGhlIGxheWVyLlxuICAgKiBAcGFyYW0ge251bWJlcj19IHNlY29uZHMgLSBUaGUgbnVtYmVyIG9mIHNlY29uZHMgaXQgc2hvdWxkIHRha2UgdG8gdHJhbnNpdGlvblxuICAgKiB0byB0aGUgbmV3IGFuaW1hdGlvbi4gRGVmYXVsdCBpcyB6ZXJvIGFuZCB3aWxsIHNldCBpbW1lZGlhdGVseS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGVhc2luZ0ZuIC0gVGhlIGVhc2luZyBmdW5jdGlvbiB0byB1c2Ugd2hpbGUgdHJhbnNpdGlvbmluZ1xuICAgKiBiZXR3ZWVuIGFuaW1hdGlvbnMuIERlZmF1bHQgaXMgRWFzaW5nLkxpbmVhci5Jbk91dC5cbiAgICpcbiAgICogQHJldHVybnMge0RlZmVycmVkfSAtIFJlc29sdmVzIG9uY2UgdGhlIGFuaW1hdGlvbiByZWFjaGVzIHRoZSBlbmQgb2YgaXRzXG4gICAqIHRpbWVsaW5lLiBMb29waW5nIGFuaW1hdGlvbnMgY2FuIG9ubHkgcmVzb2x2ZSBpZiB0aGV5IGFyZSBpbnRlcnJ1cHRlZCBvclxuICAgKiBtYW51YWxseSBzdG9wcGVkLlxuICAgKi9cbiAgcmVzdW1lQW5pbWF0aW9uKGxheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSwgc2Vjb25kcywgZWFzaW5nRm4pIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW2xheWVyTmFtZV07XG5cbiAgICBpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgZSA9IGBDYW5ub3QgcmVzdW1lIGFuaW1hdGlvbiAke2FuaW1hdGlvbk5hbWV9IG9uIGxheWVyICR7bGF5ZXJOYW1lfSBmb3IgaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBsYXllciBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYDtcbiAgICAgIHJldHVybiBEZWZlcnJlZC5yZWplY3QoZSk7XG4gICAgfVxuXG4gICAgLy8gTm90aWZ5IHRoYXQgYW4gYW5pbWF0aW9uIHdhcyByZXN1bWVkXG4gICAgdGhpcy5lbWl0KHRoaXMuY29uc3RydWN0b3IuRVZFTlRTLnJlc3VtZUFuaW1hdGlvbiwge1xuICAgICAgbGF5ZXJOYW1lLFxuICAgICAgYW5pbWF0aW9uTmFtZSxcbiAgICB9KTtcblxuICAgIHJldHVybiBsYXllci5yZXN1bWVBbmltYXRpb24oXG4gICAgICBhbmltYXRpb25OYW1lLFxuICAgICAgc2Vjb25kcyxcbiAgICAgIGVhc2luZ0ZuLFxuICAgICAgKCkgPT4ge1xuICAgICAgICAvLyBOb3RpZnkgdGhhdCBhbiBhbmltYXRpb24gaGFzIHN0b3BwZWRcbiAgICAgICAgdGhpcy5lbWl0KHRoaXMuY29uc3RydWN0b3IuRVZFTlRTLnN0b3BBbmltYXRpb24sIHtcbiAgICAgICAgICBsYXllck5hbWUsXG4gICAgICAgICAgYW5pbWF0aW9uTmFtZSxcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgKCkgPT4ge1xuICAgICAgICAvLyBOb3RpZnkgdGhhdCBhbiBhbmltYXRpb24gaGFzIGJlZW4gaW50ZXJydXB0ZWRcbiAgICAgICAgdGhpcy5lbWl0KHRoaXMuY29uc3RydWN0b3IuRVZFTlRTLmludGVycnVwdEFuaW1hdGlvbiwge1xuICAgICAgICAgIGxheWVyTmFtZSxcbiAgICAgICAgICBhbmltYXRpb25OYW1lLFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICAoe25hbWUsIGNhbkFkdmFuY2UsIGlzUXVldWVFbmR9KSA9PiB7XG4gICAgICAgIGlmIChsYXllci5jdXJyZW50QW5pbWF0aW9uID09PSBhbmltYXRpb25OYW1lKSB7XG4gICAgICAgICAgLy8gTm90aWZ5IHRoYXQgYSBuZXcgYW5pbWF0aW9uIGhhcyBiZWd1blxuICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLmNvbnN0cnVjdG9yLkVWRU5UUy5wbGF5TmV4dEFuaW1hdGlvbiwge1xuICAgICAgICAgICAgbGF5ZXJOYW1lLFxuICAgICAgICAgICAgYW5pbWF0aW9uTmFtZSxcbiAgICAgICAgICAgIG5leHRRdWV1ZWRBbmltYXRpb246IG5hbWUsXG4gICAgICAgICAgICBjYW5BZHZhbmNlLFxuICAgICAgICAgICAgaXNRdWV1ZUVuZCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCB0aGUgY3VycmVudCBhbmltYXRpb24gb24gYSBsYXllci4gU3RvcCByZXdpbmRzIHRoZSBhbmltYXRpb24gdG8gdGhlXG4gICAqIGJlZ2lubmluZyBhbmQgcHJldmVudHMgaXQgZnJvbSBwcm9ncmVzc2luZyBmb3J3YXJkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRoYXQgY29udGFpbnMgdGhlIGFuaW1hdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IGFuIGFuaW1hdGlvbiB3YXMgc3VjY2Vzc2Z1bGx5IHN0b3BwZWQuXG4gICAqL1xuICBzdG9wQW5pbWF0aW9uKG5hbWUpIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW25hbWVdO1xuXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYERpZCBub3Qgc3RvcCBhbmltYXRpb24gb24gbGF5ZXIgJHtuYW1lfSBmb3IgaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBsYXllciBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxuICAgICAgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGF5ZXIuc3RvcEFuaW1hdGlvbigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdXNlIGN1cnJlbnQgYW5pbWF0aW9uIGFuZCB3ZWlnaHQgaW50ZXJwb2xhdGlvbiBhbmltYXRpb24gb24gYWxsIGxheWVycy5cblxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBXaGV0aGVyIG9yIG5vdCB0aGVyZSB3YXMgYW4gZXhpc3RpbmcgaW50ZXJwb2xhdGlvbiBvclxuICAgKiBjdXJyZW50IGFuaW1hdGlvbnMgdG8gcGF1c2UuXG4gICAqL1xuICBwYXVzZSgpIHtcbiAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuXG4gICAgbGV0IHBhdXNlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2xheWVycy5mb3JFYWNoKGwgPT4ge1xuICAgICAgaWYgKGwucGF1c2UoKSkge1xuICAgICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHBhdXNlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN1bWUgY3VycmVudCBhbmltYXRpb24gYW5kIHdlaWdodCBpbnRlcnBvbGF0aW9uIGFuaW1hdGlvbiBvbiBhbGwgbGF5ZXJzLlxuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAtIFdoZXRoZXIgb3Igbm90IHRoZXJlIHdhcyBhbiBleGlzdGluZyBpbnRlcnBvbGF0aW9uIG9yXG4gICAqIGN1cnJlbnQgYW5pbWF0aW9ucyB0byByZXN1bWUuXG4gICAqL1xuICByZXN1bWUoKSB7XG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG5cbiAgICBsZXQgcmVzdW1lZCA9IGZhbHNlO1xuICAgIHRoaXMuX2xheWVycy5mb3JFYWNoKGwgPT4ge1xuICAgICAgaWYgKGwucmVzdW1lKCkpIHtcbiAgICAgICAgcmVzdW1lZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdW1lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgbmFtZXNwYWNlIHRvIHRoZSBob3N0IHdpdGggdGhlIG5hbWUgb2YgdGhlIGZlYXR1cmUgdG8gY29udGFpbiBwcm9wZXJ0aWVzXG4gICAqIGFuZCBtZXRob2RzIGZyb20gdGhlIGZlYXR1cmUgdGhhdCB1c2VycyBvZiB0aGUgaG9zdCBuZWVkIGFjY2VzcyB0by5cbiAgICpcbiAgICogQHNlZSBBbmltYXRpb25GZWF0dXJlXG4gICAqL1xuICBpbnN0YWxsQXBpKCkge1xuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqIEBuYW1lc3BhY2UgQW5pbWF0aW9uRmVhdHVyZVxuICAgICAqL1xuICAgIGNvbnN0IGFwaSA9IHN1cGVyLmluc3RhbGxBcGkoKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGFwaSwge1xuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNwYXVzZWRcbiAgICAgICAqL1xuICAgICAgcGF1c2VkOiB7XG4gICAgICAgIGdldDogKCkgPT4gdGhpcy5wYXVzZWQsXG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNsYXllcnNcbiAgICAgICAqL1xuICAgICAgbGF5ZXJzOiB7XG4gICAgICAgIGdldDogKCkgPT4gdGhpcy5sYXllcnMsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmFzc2lnbihhcGksIHtcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQG1ldGhvZFxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjYWRkTGF5ZXJcbiAgICAgICAqL1xuICAgICAgYWRkTGF5ZXI6IHRoaXMuYWRkTGF5ZXIuYmluZCh0aGlzKSxcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQG1ldGhvZFxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjcmVtb3ZlTGF5ZXJcbiAgICAgICAqL1xuICAgICAgcmVtb3ZlTGF5ZXI6IHRoaXMucmVtb3ZlTGF5ZXIuYmluZCh0aGlzKSxcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQG1ldGhvZFxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjbW92ZUxheWVyXG4gICAgICAgKi9cbiAgICAgIG1vdmVMYXllcjogdGhpcy5tb3ZlTGF5ZXIuYmluZCh0aGlzKSxcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQG1ldGhvZFxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjcmVuYW1lTGF5ZXJcbiAgICAgICAqL1xuICAgICAgcmVuYW1lTGF5ZXI6IHRoaXMucmVuYW1lTGF5ZXIuYmluZCh0aGlzKSxcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNnZXRMYXllcldlaWdodFxuICAgICAgICovXG4gICAgICBnZXRMYXllcldlaWdodDogdGhpcy5nZXRMYXllcldlaWdodC5iaW5kKHRoaXMpLFxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNzZXRMYXllcldlaWdodFxuICAgICAgICovXG4gICAgICBzZXRMYXllcldlaWdodDogdGhpcy5zZXRMYXllcldlaWdodC5iaW5kKHRoaXMpLFxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNwYXVzZUxheWVyV2VpZ2h0XG4gICAgICAgKi9cbiAgICAgIHBhdXNlTGF5ZXJXZWlnaHQ6IHRoaXMucGF1c2VMYXllcldlaWdodC5iaW5kKHRoaXMpLFxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNyZXN1bWVMYXllcldlaWdodFxuICAgICAgICovXG4gICAgICByZXN1bWVMYXllcldlaWdodDogdGhpcy5yZXN1bWVMYXllcldlaWdodC5iaW5kKHRoaXMpLFxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNwYXVzZUxheWVyXG4gICAgICAgKi9cbiAgICAgIHBhdXNlTGF5ZXI6IHRoaXMucGF1c2VMYXllci5iaW5kKHRoaXMpLFxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNyZXN1bWVMYXllclxuICAgICAgICovXG4gICAgICByZXN1bWVMYXllcjogdGhpcy5yZXN1bWVMYXllci5iaW5kKHRoaXMpLFxuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEBtZXRob2RcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI2dldFRyYW5zaXRpb25pbmdcbiAgICAgICAqL1xuICAgICAgZ2V0VHJhbnNpdGlvbmluZzogdGhpcy5nZXRUcmFuc2l0aW9uaW5nLmJpbmQodGhpcyksXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEBtZXRob2RcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI2dldEFuaW1hdGlvbnNcbiAgICAgICAqL1xuICAgICAgZ2V0QW5pbWF0aW9uczogdGhpcy5nZXRBbmltYXRpb25zLmJpbmQodGhpcyksXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEBtZXRob2RcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI2dldEN1cnJlbnRBbmltYXRpb25cbiAgICAgICAqL1xuICAgICAgZ2V0Q3VycmVudEFuaW1hdGlvbjogdGhpcy5nZXRDdXJyZW50QW5pbWF0aW9uLmJpbmQodGhpcyksXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEBtZXRob2RcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI2dldFBhdXNlZFxuICAgICAgICovXG4gICAgICBnZXRQYXVzZWQ6IHRoaXMuZ2V0UGF1c2VkLmJpbmQodGhpcyksXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEBtZXRob2RcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI2dldEFuaW1hdGlvblR5cGVcbiAgICAgICAqL1xuICAgICAgZ2V0QW5pbWF0aW9uVHlwZTogdGhpcy5nZXRBbmltYXRpb25UeXBlLmJpbmQodGhpcyksXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEBtZXRob2RcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI2FkZEFuaW1hdGlvblxuICAgICAgICovXG4gICAgICBhZGRBbmltYXRpb246IHRoaXMuYWRkQW5pbWF0aW9uLmJpbmQodGhpcyksXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEBtZXRob2RcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI3JlbW92ZUFuaW1hdGlvblxuICAgICAgICovXG4gICAgICByZW1vdmVBbmltYXRpb246IHRoaXMucmVtb3ZlQW5pbWF0aW9uLmJpbmQodGhpcyksXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEBtZXRob2RcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI3JlbmFtZUFuaW1hdGlvblxuICAgICAgICovXG4gICAgICByZW5hbWVBbmltYXRpb246IHRoaXMucmVuYW1lQW5pbWF0aW9uLmJpbmQodGhpcyksXG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQG1ldGhvZFxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjZ2V0QW5pbWF0aW9uQmxlbmROYW1lc1xuICAgICAgICovXG4gICAgICBnZXRBbmltYXRpb25CbGVuZE5hbWVzOiB0aGlzLmdldEFuaW1hdGlvbkJsZW5kTmFtZXMuYmluZCh0aGlzKSxcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQG1ldGhvZFxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjZ2V0QW5pbWF0aW9uQmxlbmRXZWlnaHRcbiAgICAgICAqL1xuICAgICAgZ2V0QW5pbWF0aW9uQmxlbmRXZWlnaHQ6IHRoaXMuZ2V0QW5pbWF0aW9uQmxlbmRXZWlnaHQuYmluZCh0aGlzKSxcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQG1ldGhvZFxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjc2V0QW5pbWF0aW9uQmxlbmRXZWlnaHRcbiAgICAgICAqL1xuICAgICAgc2V0QW5pbWF0aW9uQmxlbmRXZWlnaHQ6IHRoaXMuc2V0QW5pbWF0aW9uQmxlbmRXZWlnaHQuYmluZCh0aGlzKSxcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNwbGF5QW5pbWF0aW9uXG4gICAgICAgKi9cbiAgICAgIHBsYXlBbmltYXRpb246IHRoaXMucGxheUFuaW1hdGlvbi5iaW5kKHRoaXMpLFxuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEBtZXRob2RcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI3BsYXlOZXh0QW5pbWF0aW9uXG4gICAgICAgKi9cbiAgICAgIHBsYXlOZXh0QW5pbWF0aW9uOiB0aGlzLnBsYXlOZXh0QW5pbWF0aW9uLmJpbmQodGhpcyksXG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQG1ldGhvZFxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjcGF1c2VBbmltYXRpb25cbiAgICAgICAqL1xuICAgICAgcGF1c2VBbmltYXRpb246IHRoaXMucGF1c2VBbmltYXRpb24uYmluZCh0aGlzKSxcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQG1ldGhvZFxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjcmVzdW1lQW5pbWF0aW9uXG4gICAgICAgKi9cbiAgICAgIHJlc3VtZUFuaW1hdGlvbjogdGhpcy5yZXN1bWVBbmltYXRpb24uYmluZCh0aGlzKSxcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQG1ldGhvZFxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjc3RvcEFuaW1hdGlvblxuICAgICAgICovXG4gICAgICBzdG9wQW5pbWF0aW9uOiB0aGlzLnN0b3BBbmltYXRpb24uYmluZCh0aGlzKSxcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNwYXVzZVxuICAgICAgICovXG4gICAgICBwYXVzZTogdGhpcy5wYXVzZS5iaW5kKHRoaXMpLFxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNyZXN1bWVcbiAgICAgICAqL1xuICAgICAgcmVzdW1lOiB0aGlzLnJlc3VtZS5iaW5kKHRoaXMpLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBlYWNoIGFuaW1hdGlvbiBsYXllci5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhVGltZSAtIFRpbWUgc2luY2UgdGhlIGxhc3QgdXBkYXRlLlxuICAgKi9cbiAgdXBkYXRlKGRlbHRhVGltZSkge1xuICAgIGlmICghdGhpcy5fbGF5ZXJzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9wYXVzZWQpIHtcbiAgICAgIGRlbHRhVGltZSA9IDA7XG4gICAgfVxuXG4gICAgLy8gUmUtZXZhbHVhdGUgaW50ZXJuYWwgd2VpZ2h0cyBmb3IgbGF5ZXJzXG4gICAgdGhpcy5fdXBkYXRlSW50ZXJuYWxXZWlnaHRzKCk7XG5cbiAgICAvLyBVcGRhdGUgbGF5ZXJzXG4gICAgdGhpcy5fbGF5ZXJzLmZvckVhY2gobGF5ZXIgPT4ge1xuICAgICAgbGF5ZXIudXBkYXRlKGRlbHRhVGltZSk7XG4gICAgfSk7XG5cbiAgICBzdXBlci51cGRhdGUoZGVsdGFUaW1lKTtcbiAgfVxuXG4gIGRpc2NhcmQoKSB7XG4gICAgdGhpcy5fbGF5ZXJzLmZvckVhY2gobGF5ZXIgPT4ge1xuICAgICAgbGF5ZXIuZGlzY2FyZCgpO1xuICAgIH0pO1xuXG4gICAgZGVsZXRlIHRoaXMuX2xheWVycztcbiAgICBkZWxldGUgdGhpcy5fbGF5ZXJNYXA7XG5cbiAgICBzdXBlci5kaXNjYXJkKCk7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEFuaW1hdGlvbkZlYXR1cmUsICdFVkVOVFMnLCB7XG4gIHZhbHVlOiB7XG4gICAgLi4uT2JqZWN0LmdldFByb3RvdHlwZU9mKEFic3RyYWN0SG9zdEZlYXR1cmUpLkVWRU5UUyxcbiAgICBhZGRMYXllcjogJ29uQWRkTGF5ZXJFdmVudCcsXG4gICAgcmVtb3ZlTGF5ZXI6ICdvblJlbW92ZUxheWVyRXZlbnQnLFxuICAgIHJlbmFtZUxheWVyOiAnb25SZW5hbWVMYXllckV2ZW50JyxcbiAgICBhZGRBbmltYXRpb246ICdvbkFkZEFuaW1hdGlvbkV2ZW50JyxcbiAgICByZW1vdmVBbmltYXRpb246ICdvblJlbW92ZWRBbmltYXRpb25FdmVudCcsXG4gICAgcmVuYW1lQW5pbWF0aW9uOiAnb25SZW5hbWVBbmltYXRpb25FdmVudCcsXG4gICAgcGxheUFuaW1hdGlvbjogJ29uUGxheUV2ZW50JyxcbiAgICBwbGF5TmV4dEFuaW1hdGlvbjogJ29uTmV4dEV2ZW50JyxcbiAgICBwYXVzZUFuaW1hdGlvbjogJ29uUGF1c2VFdmVudCcsXG4gICAgcmVzdW1lQW5pbWF0aW9uOiAnb25SZXN1bWVFdmVudCcsXG4gICAgaW50ZXJydXB0QW5pbWF0aW9uOiAnb25JbnRlcnJ1cHRFdmVudCcsXG4gICAgc3RvcEFuaW1hdGlvbjogJ29uU3RvcEV2ZW50JyxcbiAgfSxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBBbmltYXRpb25GZWF0dXJlO1xuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVyc2NvcmUtZGFuZ2xlICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IE1hbmFnZWRBbmltYXRpb25MYXllckludGVyZmFjZSBmcm9tICcuL2FuaW1wYWNrL01hbmFnZWRBbmltYXRpb25MYXllckludGVyZmFjZSc7XG5pbXBvcnQge0FuaW1hdGlvblR5cGVzfSBmcm9tICcuL2FuaW1wYWNrL0FuaW1hdGlvbkZlYXR1cmUnO1xuaW1wb3J0IFNTTUxTcGVlY2htYXJrSW50ZXJmYWNlIGZyb20gJy4vYXdzcGFjay9TU01MU3BlZWNobWFya0ludGVyZmFjZSc7XG5pbXBvcnQgQWJzdHJhY3RIb3N0RmVhdHVyZSBmcm9tICcuL0Fic3RyYWN0SG9zdEZlYXR1cmUnO1xuaW1wb3J0IHtRdWFkcmF0aWN9IGZyb20gJy4vYW5pbXBhY2svRWFzaW5nJztcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSAnLi9NYXRoVXRpbHMnO1xuaW1wb3J0IFV0aWxzIGZyb20gJy4vVXRpbHMnO1xuXG4vKipcbiAqIEVudW0gZm9yIGF4aXMgZGlyZWN0aW9ucy5cbiAqXG4gKiBAcmVhZG9ubHlcbiAqIEBlbnVtIHtDbGFzc31cbiAqL1xuY29uc3QgQXhpc01hcCA9IHtcbiAgUG9zaXRpdmVYOiBbMSwgMCwgMF0sXG4gIE5lZ2F0aXZlWDogWy0xLCAwLCAwXSxcbiAgUG9zaXRpdmVZOiBbMCwgMSwgMF0sXG4gIE5lZ2F0aXZlWTogWzAsIC0xLCAwXSxcbiAgUG9zaXRpdmVaOiBbMCwgMCwgMV0sXG4gIE5lZ2F0aXZlWjogWzAsIDAsIC0xXSxcbn07XG5cbmNvbnN0IEZhY2VUYXJnZXRUeXBlcyA9IHtcbiAgRXllQ2VudGVyOiAwLFxuICBFeWVMZWZ0OiAxLFxuICBFeWVSaWdodDogMixcbiAgTW91dGg6IDMsXG59O1xuXG4vLyBBdmVyYWdlIGRpc3RhbmNlIGJldHdlZW4gcHVwaWxzIGlzIC4wNjRtLCBnb2xkZW4gcmF0aW8gc2F5cyB0aGF0IHRoZSBkaXN0YW5jZVxuLy8gZnJvbSBjZW50ZXIgb2YgdGhlIHB1cGlscyB0byB0aGUgY2VudGVyIG9mIHRoZSBtb3V0aCBzaG91bGQgYmUgYWJvdXQgdGhlIHNhbWUuXG5jb25zdCBGYWNlVmVjdG9ycyA9IFtcbiAgWzAsIDAsIDBdLFxuICBbLTAuMDMyLCAwLCAwXSxcbiAgWzAuMDMyLCAwLCAwXSxcbiAgWzAsIC0wLjA2NCwgMF0sXG5dO1xuXG4vLyBUaW1lIHJhbmdlcyB0byB1c2Ugd2hlbiBjaG9vc2luZyBhIG5ldyByYW5kb20gd2FpdCB0aW1lIGJldHdlZW4gc2FjY2FkZXNcbmNvbnN0IE1pY3JvU2FjY2FkZVdhaXRSYW5nZXMgPSB7XG4gIGRlZmF1bHQ6IFswLjgsIDEuNzVdLFxuICBwb3N0TWFjcm86IFswLjYsIDEuMzEyNV0sXG59O1xuXG5jb25zdCBNYWNyb1NhY2NhZGVXYWl0UmFuZ2VzID0ge1xuICBkZWZhdWx0OiBbNS4wLCA4LjBdLFxuICBtb3V0aFRhcmdldDogWzAuMiwgMC43NV0sIC8vIExvb2sgYXdheSBmcm9tIGEgbW91dGggdGFyZ2V0IHRoZSBmYXN0ZXN0XG4gIGV5ZVRhcmdldDogWzEuNSwgNC4wXSxcbn07XG5cbi8vIE1pbmltdW0gYW5nbGUgaW4gZGVncmVlcyB0aGUgZXllIGRpcmVjdGlvbiBtdXN0IGNoYW5nZSB0byB0cmlnZ2VyIGEgYmxpbmsgYW5pbWF0aW9uXG5jb25zdCBCbGlua1RocmVzaG9sZCA9IDM1O1xuXG4vLyBNYXhpbXVtIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdXNlIGZvciBjYWxjdWxhdGluZyBsb29rIHNwZWVkXG5jb25zdCBNYXhEZWx0YSA9IDEwMCAvIDM7XG5cbi8qKlxuICogUG9pbnRPZkludGVyZXN0IGNvbnRyb2xzIHRoZSBnYXplIGRpcmVjdGlvbiBvZiB0aGUgaG9zdC4gR2l2ZW4gb25lIG9yIG1vcmVcbiAqIGFuaW1hdGlvbnMgb2YgdHlwZSBCbGVuZDJkU3RhdGUsIGl0IGNhbGN1bGF0ZXMgdGhlIGFuZ2xlcyBiZXR3ZWVuIHRoZSBsb29rVHJhY2tlclxuICogb2JqZWN0IChnZW5lcmFsbHkgYSBqb2ludCBpbiB0aGUgaG9zdCdzIHNrZWxldG9uKSBhbmQgdGhlIGxvb2tUYXJnZXQgKHRoZSBvYmplY3RcbiAqIHRoZSBob3N0IHNob3VsZCBsb29rIGF0KSBhbmQgZHJpdmVzIHRoZSBtYW5hZ2VkIEJsZW5kMmRTdGF0ZXMnIFggYW5kIFkgYmxlbmRcbiAqIHZhbHVlcyB1c2luZyB0aGUgcmVzdWx0LiBZb3UgY2FuIG9wdGlvbmFsbHkgYWRkIHNhY2NhZGljIG1vdmVtZW50IHRvIGFueSBtYW5hZ2VkXG4gKiBhbmltYXRpb24gdG8gaGVscCBtYWtlIHRoZSBob3N0J3MgZXllcyBhcHBlYXIgYWxpdmUgd2hlbiBmb2N1c2VkIG9uIHRoZSBzYW1lXG4gKiBwb2ludCBmb3IgZXh0ZWRlZCBwZXJpb2RzIG9mIHRpbWUuIElmIGJsaW5rIGFuaW1hdGlvbnMgYXJlIHNwZWNpZmllZCwgYSBibGlua1xuICogd2lsbCBiZSBwbGF5ZWQgZHVyaW5nIGxhcmdlIGNoYW5nZXMgaW4gZ2F6ZSBkaXJlY3Rpb24uXG4gKlxuICogQGV4dGVuZHMgQWJzdHJhY3RIb3N0RmVhdHVyZVxuICogQGFsaWFzIGNvcmUvUG9pbnRPZkludGVyZXN0RmVhdHVyZVxuICogQGltcGxlbWVudHMgU1NNTFNwZWVjaG1hcmtJbnRlcmZhY2VcbiAqIEBpbXBsZW1lbnRzIE1hbmFnZWRBbmltYXRpb25MYXllckludGVyZmFjZVxuICovXG5jbGFzcyBQb2ludE9mSW50ZXJlc3RGZWF0dXJlIGV4dGVuZHMgQWJzdHJhY3RIb3N0RmVhdHVyZS5taXgoXG4gIFNTTUxTcGVlY2htYXJrSW50ZXJmYWNlLk1peGluLFxuICBNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2UuTWl4aW5cbikge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7Y29yZS9Ib3N0T2JqZWN0fSBob3N0IC0gSG9zdCB0aGF0IG93bnMgdGhlIGZlYXR1cmUuXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBmZWF0dXJlLlxuICAgKiBAcGFyYW0ge09iamVjdD19IHRhcmdldCAtIDNEIHRyYW5zZm9ybWF0aW9uIG5vZGUgdGhhdCB0aGUgaG9zdCBzaG91bGQgdHJ5IHRvXG4gICAqIGxvb2sgYXQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmxvb2tUcmFja2VyIC0gM0QgdHJhbnNmb3JtYXRpb24gbm9kZSB0aGF0IHJlcHJlc2VudHNcbiAgICogdGhlIGRpcmVjdGlvbiB0aGUgaG9zdCBpcyBjdXJyZW50bHkgbG9va2luZyBkdXJpbmcgYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMuc2NlbmUgLSBFbmdpbmUtc3BlY2lmaWMgc2NlbmUgb2JqZWN0IHRoYXQgY29udGFpbnNcbiAgICogdGhlIGhvc3QuIFRoaXMgb2JqZWN0IG11c3QgYmUgZGVmaW5lZCBpZiB1c2luZyAnc2V0VGFyZ2V0QnlOYW1lJyBvciAnU2V0VGFyZ2V0QnlJZCdcbiAgICogbWV0aG9kcy5cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBsb29rT3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBsb29rIGFuaW1hdGlvbiBsYXllcnMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbG9va09wdGlvbnMuYmxlbmRUaW1lPTAuMV0gLSBEZWZhdWx0IGFtb3VudCBvZiB0aW1lIGl0IHdpbGxcbiAgICogdGFrZSB0byBtYW5pcHVsYXRlIHRoZSB3ZWlnaHRzIG9mIHRoZSBsb29rIGxheWVycy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtsb29rT3B0aW9ucy5lYXNpbmdGbj1RdWFkcmF0aWMuSW5PdXRdIC0gRGVmYXVsdCBlYXNpbmcgZnVuY3Rpb25cbiAgICogdG8gdXNlIHdoZW4gbWFuaXB1bGF0aW5nIGxvb2sgbGF5ZXIgd2VpZ2h0cy5cbiAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gW2xvb2tPcHRpb25zLmxheWVycz1bXV0gLSBBbiBhcnJheSBvZiBsYXllciBvcHRpb25zXG4gICAqIG9iamVjdHMgdG8gcmVnaXN0ZXIgYXMgbG9vayBsYXllcnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gYmxpbmtPcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGJsaW5rIGFuaW1hdGlvbiBsYXllcnMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbYmxpbmtPcHRpb25zLmJsZW5kVGltZT0wLjA3NV0gLSBEZWZhdWx0IGFtb3VudCBvZiB0aW1lIGl0XG4gICAqIHdpbGwgdGFrZSB0byBtYW5pcHVsYXRlIHRoZSB3ZWlnaHRzIG9mIHRoZSBibGluayBsYXllcnMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbYmxpbmtPcHRpb25zLmVhc2luZ0ZuPVF1YWRyYXRpYy5Jbk91dF0gLSBEZWZhdWx0IGVhc2luZyBmdW5jdGlvblxuICAgKiB0byB1c2Ugd2hlbiBtYW5pcHVsYXRpbmcgYmxpbmsgbGF5ZXIgd2VpZ2h0cy5cbiAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gW2JsaW5rT3B0aW9ucy5sYXllcnM9W11dIC0gQW4gYXJyYXkgb2YgbGF5ZXIgb3B0aW9uc1xuICAgKiBvYmplY3RzIHRvIHJlZ2lzdGVyIGFzIGJsaW5rIGxheWVycy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIGhvc3QsXG4gICAge3RhcmdldCwgbG9va1RyYWNrZXIsIHNjZW5lfSA9IHt9LFxuICAgIHtcbiAgICAgIGJsZW5kVGltZTogbG9va0JsZW5kVGltZSA9IDAuMSxcbiAgICAgIGVhc2luZ0ZuOiBsb29rRWFzaW5nRm4gPSBRdWFkcmF0aWMuSW5PdXQsXG4gICAgICBsYXllcnM6IGxvb2tMYXllcnMgPSBbXSxcbiAgICB9ID0ge30sXG4gICAge1xuICAgICAgYmxlbmRUaW1lOiBibGlua0JsZW5kVGltZSA9IDAuMDc1LFxuICAgICAgZWFzaW5nRm46IGJsaW5rRWFzaW5nRm4gPSBRdWFkcmF0aWMuSW5PdXQsXG4gICAgICBsYXllcnM6IGJsaW5rTGF5ZXJzID0gW10sXG4gICAgfSA9IHt9XG4gICkge1xuICAgIHN1cGVyKGhvc3QpO1xuXG4gICAgaWYgKCF0aGlzLmNvbnN0cnVjdG9yLl92YWxpZGF0ZVRyYW5zZm9ybU9iamVjdChsb29rVHJhY2tlcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBpbml0aWFsaXplIFBvaW50T2ZJbnRlcmVzdEZlYXR1cmUgb24gaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBMb29rVHJhY2tlciBtdXN0IGJlIGRlZmluZWQgYXMgYSB2YWxpZCB0cmFuc2Zvcm1hdGlvbiBvYmplY3QuYFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5fbG9va1RyYWNrZXIgPSBsb29rVHJhY2tlcjtcblxuICAgIHRoaXMuX3NjZW5lID0gc2NlbmU7XG4gICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0IHx8IG51bGw7XG4gICAgdGhpcy5fcHJldlRhcmdldFBvcyA9IFswLCAwLCAwXTtcbiAgICB0aGlzLl9pc1RhcmdldE1vdmluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2xvb2tMYXllcnMgPSB0aGlzLl9sb29rTGF5ZXJzIHx8IHt9O1xuICAgIHRoaXMuX3RyYWNraW5nQ29uZmlncyA9IHRoaXMuX3RyYWNraW5nQ29uZmlncyB8fCBbXTtcbiAgICB0aGlzLl9ibGlua0xheWVycyA9IHRoaXMuX2JsaW5rTGF5ZXJzIHx8IHt9O1xuXG4gICAgLy8gUmVnaXN0ZXIgdGhlIGxvb2sgbGF5ZXJzXG4gICAgbG9va0xheWVycy5mb3JFYWNoKFxuICAgICAgKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgYW5pbWF0aW9uLFxuICAgICAgICBtYXhTcGVlZCxcbiAgICAgICAgcmVmZXJlbmNlLFxuICAgICAgICBmb3J3YXJkQXhpcyxcbiAgICAgICAgaGFzU2FjY2FkZSxcbiAgICAgICAgYmxlbmRUaW1lLFxuICAgICAgICBlYXNpbmdGbixcbiAgICAgIH0pID0+IHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlckxvb2tMYXllcihuYW1lLCB7XG4gICAgICAgICAgYW5pbWF0aW9uLFxuICAgICAgICAgIG1heFNwZWVkLFxuICAgICAgICAgIHJlZmVyZW5jZSxcbiAgICAgICAgICBmb3J3YXJkQXhpcyxcbiAgICAgICAgICBoYXNTYWNjYWRlLFxuICAgICAgICAgIGJsZW5kVGltZTogYmxlbmRUaW1lICE9PSB1bmRlZmluZWQgPyBibGVuZFRpbWUgOiBsb29rQmxlbmRUaW1lLFxuICAgICAgICAgIGVhc2luZ0ZuOiBlYXNpbmdGbiAhPT0gdW5kZWZpbmVkID8gZWFzaW5nRm4gOiBsb29rRWFzaW5nRm4sXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBSZWdpc3RlciB0aGUgYmxpbmsgbGF5ZXJzXG4gICAgYmxpbmtMYXllcnMuZm9yRWFjaCgoe25hbWUsIGFuaW1hdGlvbiwgYmxlbmRUaW1lLCBlYXNpbmdGbn0pID0+IHtcbiAgICAgIHRoaXMucmVnaXN0ZXJCbGlua0xheWVyKG5hbWUsIHtcbiAgICAgICAgYW5pbWF0aW9uLFxuICAgICAgICBibGVuZFRpbWU6IGJsZW5kVGltZSAhPT0gdW5kZWZpbmVkID8gYmxlbmRUaW1lIDogYmxpbmtCbGVuZFRpbWUsXG4gICAgICAgIGVhc2luZ0ZuOiBlYXNpbmdGbiAhPT0gdW5kZWZpbmVkID8gZWFzaW5nRm4gOiBibGlua0Vhc2luZ0ZuLFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbmQgc2V0cyB0aGUgdGFyZ2V0IG9iamVjdCB0aGUgaG9zdCBzaG91bGQgbG9vayBhdC5cbiAgICpcbiAgICogQHR5cGUge09iamVjdHxudWxsfVxuICAgKi9cbiAgZ2V0IHRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0O1xuICB9XG5cbiAgc2V0IHRhcmdldCh0YXJnZXQpIHtcbiAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQgfHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBnbG9iYWwgcG9zaXRpb24gb2YgYW4gb2JqZWN0LiBTaG91bGQgYmVcbiAgICogb3ZlcmxvYWRlZCBmb3IgZWFjaCByZW5kZXJpbmcgZW5naW5lIGltcGxlbWVudGF0aW9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge2FueX0gX29iaiAtIEVuZ2luZS1zcGVjaWZpYyAzRCB0cmFuc2Zvcm0gb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59IC0gQW4gYXJyYXkgY29uc2lzdGluZyBvZiB0aHJlZSBudW1iZXJzIHJlcHJlc2VudGluZ1xuICAgKiB4LCB5IGFuZCB6IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgc3RhdGljIF9nZXRXb3JsZFBvc2l0aW9uKG9iaikge1xuICAgIHJldHVybiBbMCwgMCwgMF07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgbWF0cml4IHJlcHJlc2VudGluZyB0aGUgZ2xvYmFsIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBvZiBhbiBvYmplY3QuXG4gICAqIFNob3VsZCBiZSBvdmVybG9hZGVkIGZvciBlYWNoIHJlbmRlcmluZyBlbmdpbmUgaW1wbGVtZW50YXRpb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSBvYmogLSBFbmdpbmUtc3BlY2lmaWMgM0QgdHJhbnNmb3JtIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybnMge0FycmF5LjxudW1iZXI+fSAtIEFuIGFycmF5IGNvbnNpc3Rpbmcgb2YgMTYgbnVtYmVycyByZXByZXNlbnRpbmdcbiAgICogdGhlIDNkIHRyYW5zZm9ybWF0aW9uLlxuICAgKi9cbiAgc3RhdGljIF9nZXRXb3JsZE1hdHJpeChvYmopIHtcbiAgICByZXR1cm4gWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDFdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJvdGF0ZSB0aGUgZ2l2ZW4gbG9jYWwgZGlyZWN0aW9uIHZlY3RvciBieSB0aGUgb2JqZWN0J3Mgd29ybGQgcm90YXRpb24gbWF0cml4LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge2FueX0gb2JqIC0gRW5naW5lLXNwZWNpZmljIDNEIHRyYW5zZm9ybSBvYmplY3QuXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGZvcndhcmRWZWN0b3IgLSBVbml0IHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGxvY2FsXG4gICAqIGZvcndhcmQgZGlyZWN0aW9uIG9mIHRoZSBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIHN0YXRpYyBfZ2V0T2JqZWN0RGlyZWN0aW9uKG9iaiwgZm9yd2FyZFZlY3RvciA9IEF4aXNNYXAuUG9zaXRpdmVaKSB7XG4gICAgY29uc3Qgcm90YXRpb24gPSBNYXRoVXRpbHMuZ2V0Um90YXRpb25NYXRyaXgodGhpcy5fZ2V0V29ybGRNYXRyaXgob2JqKSk7XG5cbiAgICByZXR1cm4gTWF0aFV0aWxzLnJvdGF0ZVZlY3Rvcihmb3J3YXJkVmVjdG9yLCByb3RhdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGxvb2sgYW5nbGVzIGluIGRlZ3JlZXMgZ2l2ZW4gc3BoZXJpY2FsIHRoZXRhXG4gICAqIGFuZCBwaGkgYW5nbGVzIGluIHJhZGlhbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aGV0YSAtIFZlcnRpY2FsL3BvbGFyIGFuZ2xlIGluIHJhZGlhbnMgd2hlcmUgMCBwb2ludHMgZGlyZWN0bHlcbiAgICogYWxvbmcgcG9zaXRpdmUgWSBheGlzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGhpIC0gSG9yaXpvbnRhbC9hemltdXRoYWwgYW5nbGUgaW4gcmFkaWFucy5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gLSBBbiBvYmplY3Qgd2l0aCB0aGUgc2lnbmF0dXJlIHtoOiBudW1iZXIsIHY6IG51bWJlcn0gd2hlcmVcbiAgICogaCByZXByZXNlbnRzIGhvcml6b250YWwgcm90YXRpb24gaW4gZGVncmVlcyBhbmQgdiByZXByZXNlbnRzIHZlcnRpY2FsIHJvdGF0aW9uXG4gICAqIGluIGRlZ3JlZXMuXG4gICAqL1xuICBzdGF0aWMgX3NwaGVyaWNhbFRvQmxlbmRWYWx1ZSh0aGV0YSwgcGhpKSB7XG4gICAgY29uc3QgaCA9IE1hdGhVdGlscy50b0RlZ3JlZXMocGhpKTtcblxuICAgIC8vIE9mZnNldCB0aGUgdmVydGljYWwgYW5nbGUgc28gMCBpcyBwb2ludGluZyBmb3J3YXJkIGluc3RlYWQgb2YgdXBcbiAgICBjb25zdCB2ID0gTWF0aFV0aWxzLnRvRGVncmVlcyh0aGV0YSkgLSA5MDtcblxuICAgIC8vIENvbnZlcnQgdmVydGljYWwgYW5nbGUgdG8gLTE4MCwgMTgwIHJhbmdlXG4gICAgcmV0dXJuIHtoLCB2fTtcbiAgfVxuXG4gIF9vbkxheWVyQWRkZWQoe25hbWV9KSB7XG4gICAgdGhpcy5fbG9va0xheWVycyA9IHRoaXMuX2xvb2tMYXllcnMgfHwge307XG4gICAgdGhpcy5fYmxpbmtMYXllcnMgPSB0aGlzLl9ibGlua0xheWVycyB8fCB7fTtcblxuICAgIHN1cGVyLl9vbkxheWVyQWRkZWQoe25hbWV9KTtcblxuICAgIC8vIFZhbGlkYXRlIHRoZSBsb29rIGFuaW1hdGlvblxuICAgIGlmICh0aGlzLl9sb29rTGF5ZXJzW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3JlZ2lzdGVyTG9va0FuaW1hdGlvbihuYW1lLCB0aGlzLl9sb29rTGF5ZXJzW25hbWVdKTtcbiAgICB9XG4gIH1cblxuICBfb25BbmltYXRpb25BZGRlZCh7bGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lfSkge1xuICAgIHRoaXMuX2xvb2tMYXllcnMgPSB0aGlzLl9sb29rTGF5ZXJzIHx8IHt9O1xuICAgIHRoaXMuX2JsaW5rTGF5ZXJzID0gdGhpcy5fYmxpbmtMYXllcnMgfHwge307XG5cbiAgICBzdXBlci5fb25BbmltYXRpb25BZGRlZCh7bGF5ZXJOYW1lfSk7XG5cbiAgICAvLyBWYWxpZGF0ZSB0aGUgbG9vayBhbmltYXRpb25cbiAgICBpZiAodGhpcy5fbG9va0xheWVyc1tsYXllck5hbWVdID09PSBhbmltYXRpb25OYW1lKSB7XG4gICAgICB0aGlzLl9yZWdpc3Rlckxvb2tBbmltYXRpb24obGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW5zdXJlIHRoYXQgcmVnaXN0ZXJlZCBsb29rIGFuaW1hdGlvbnMgYXJlIEJsZW5kMmRTdGF0ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0aGF0IGNvbnRhaW5zIHRoZSBsb29rIGFuaW1hdGlvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFuaW1hdGlvbk5hbWUgLSBOYW1lIG9mIHRoZSBhbmltYXRpb24uXG4gICAqL1xuICBfcmVnaXN0ZXJMb29rQW5pbWF0aW9uKGxheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSkge1xuICAgIGlmICh0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0uYW5pbWF0aW9uc1thbmltYXRpb25OYW1lXS5pc0FjdGl2ZSkge1xuICAgICAgaWYgKFxuICAgICAgICBBbmltYXRpb25UeXBlc1tcbiAgICAgICAgICB0aGlzLl9ob3N0LkFuaW1hdGlvbkZlYXR1cmUuZ2V0QW5pbWF0aW9uVHlwZShsYXllck5hbWUsIGFuaW1hdGlvbk5hbWUpXG4gICAgICAgIF0gIT09IEFuaW1hdGlvblR5cGVzLmJsZW5kMmRcbiAgICAgICkge1xuICAgICAgICAvLyBXYXJuIGFuZCBkZWFjdGl2YXRlIGlmIHRoZSByZWdpc3RlcmVkIHN0YXRlIGlzIG5vdCBibGVuZDJkXG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgQ2Fubm90IHJlZ2lzdGVyIFBvaW50IG9mIEludGVyZXN0IGxvb2sgYW5pbWF0aW9uICR7YW5pbWF0aW9uTmFtZX0gb24gbGF5ZXIgJHtsYXllck5hbWV9IGZvciBob3N0ICR7dGhpcy5faG9zdC5pZH0uIExvb2sgYW5pbWF0aW9ucyBtdXN0IGJlIG9mIHR5cGUgJ2JsZW5kMmQnLmBcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdLmFuaW1hdGlvbnNbXG4gICAgICAgICAgYW5pbWF0aW9uTmFtZVxuICAgICAgICBdLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgbm90IG9mIGFuIGVuZ2luZS1zcGVjaWZpYyB0eXBlLiBTaG91bGRcbiAgICogYmUgb3ZlcmxvYWRlZCBmb3IgZWFjaCByZW5kZXJpbmcgZW5naW5lIGltcGxlbWVudGF0aW9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge2FueX0gb2JqIC0gT2JqZWN0IHRvIHZhbGlkYXRlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBfdmFsaWRhdGVUcmFuc2Zvcm1PYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE9iamVjdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgZ2l2ZW4gY29uZmlndXJhdGlvbiBvYmplY3QgaGFzIGFscmVhZHkgYmVlbiBzdG9yZWQgYXMgYSB0cmFja2luZ1xuICAgKiBjb25maWcuIElmIGl0IGhhcywgcmV0dXJuIHRoZSBzdG9yZWQgY29uZmlndXJhdGlvbi4gT3RoZXJ3aXNlLCBzdG9yZSBhbmRcbiAgICogcmV0dXJuIGl0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIC0gT2JqZWN0IGNvbnRhaW5pbmcgdHJhY2tlciwgcmVmZXJlbmNlIGFuZCBmb3J3YXJkQXhpc1xuICAgKiBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKi9cbiAgX2FkZFRyYWNraW5nQ29uZmlnKGNvbmZpZykge1xuICAgIGNvbnN0IHRyYWNraW5nQ29uZmlnID0gdGhpcy5fdHJhY2tpbmdDb25maWdzLmZpbmQoXG4gICAgICBjID0+XG4gICAgICAgIGMucmVmZXJlbmNlID09PSBjb25maWcucmVmZXJlbmNlICYmIGMuZm9yd2FyZEF4aXMgPT09IGNvbmZpZy5mb3J3YXJkQXhpc1xuICAgICk7XG5cbiAgICBpZiAodHJhY2tpbmdDb25maWcpIHtcbiAgICAgIHJldHVybiB0cmFja2luZ0NvbmZpZztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uZmlnLmFuZ2xlcyA9IHtoOiAwLCB2OiAwfTtcbiAgICAgIGNvbmZpZy5wcmV2QW5nbGVzID0ge2g6IDAsIHY6IDB9O1xuICAgICAgdGhpcy5fdHJhY2tpbmdDb25maWdzLnB1c2goY29uZmlnKTtcbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgbG9vayB0cmFja2VyIGFuZCB0aGUgbG9vayB0YXJnZXQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBfZ2V0VGFyZ2V0RGlzdGFuY2UoKSB7XG4gICAgLy8gRmluZCB0aGUgdmVjdG9yIGJldHdlZW4gdGhlIGdsb2JhbCBwb3NpdGlvbnMgb2YgdHJhY2tlciBhbmQgdGFyZ2V0XG4gICAgY29uc3Qgc291cmNlUG9zaXRpb24gPSB0aGlzLmNvbnN0cnVjdG9yLl9nZXRXb3JsZFBvc2l0aW9uKFxuICAgICAgdGhpcy5fbG9va1RyYWNrZXJcbiAgICApO1xuICAgIGNvbnN0IHRhcmdldFBvc2l0aW9uID0gdGhpcy5jb25zdHJ1Y3Rvci5fZ2V0V29ybGRQb3NpdGlvbih0aGlzLl90YXJnZXQpO1xuICAgIGNvbnN0IGxvb2tWZWN0b3IgPSBbXG4gICAgICB0YXJnZXRQb3NpdGlvblswXSAtIHNvdXJjZVBvc2l0aW9uWzBdLFxuICAgICAgdGFyZ2V0UG9zaXRpb25bMV0gLSBzb3VyY2VQb3NpdGlvblsxXSxcbiAgICAgIHRhcmdldFBvc2l0aW9uWzJdIC0gc291cmNlUG9zaXRpb25bMl0sXG4gICAgXTtcblxuICAgIHJldHVybiBNYXRoVXRpbHMuZ2V0VmVjdG9yTWFnbml0dWRlKGxvb2tWZWN0b3IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IGFsbCBzdG9yZWQgdHJhY2tpbmcgYW5nbGVzIHRvIDAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVzZXRMb29rQW5nbGVzKCkge1xuICAgIHRoaXMuX3RyYWNraW5nQ29uZmlncy5mb3JFYWNoKCh7YW5nbGVzfSkgPT4ge1xuICAgICAgYW5nbGVzLmggPSAwO1xuICAgICAgYW5nbGVzLnYgPSAwO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlIHRoZSBkaWZmZXJlbmNlIGluIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIHJvdGF0aW9uIGZvciB0aGUgdHJhY2tlcidzXG4gICAqIHJlZmVyZW5jZSByb3RhdGlvbiBhbmQgdGhlIGRpcmVjdGlvbiBvZiB0aGUgdGFyZ2V0IGZyb20gdGhlIHRyYWNrZXIuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0TG9va0FuZ2xlcygpIHtcbiAgICAvLyBHZXQgdGhlIGN1cnJlbnQgcG9zaXRpb25zIG9mIHRoZSB0cmFja2VyIGFuZCB0YXJnZXQgb2JqZWN0c1xuICAgIGNvbnN0IHRhcmdldFBvcyA9IHRoaXMuY29uc3RydWN0b3IuX2dldFdvcmxkUG9zaXRpb24odGhpcy5fdGFyZ2V0KTtcbiAgICBjb25zdCB0cmFja2VyUG9zID0gdGhpcy5jb25zdHJ1Y3Rvci5fZ2V0V29ybGRQb3NpdGlvbih0aGlzLl9sb29rVHJhY2tlcik7XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgdGFyZ2V0IGhhcyBtb3ZlZFxuICAgIHRoaXMuX2lzVGFyZ2V0TW92aW5nID1cbiAgICAgIE1hdGhVdGlscy5nZXRWZWN0b3JNYWduaXR1ZGUoW1xuICAgICAgICB0YXJnZXRQb3NbMF0gLSB0aGlzLl9wcmV2VGFyZ2V0UG9zWzBdLFxuICAgICAgICB0YXJnZXRQb3NbMV0gLSB0aGlzLl9wcmV2VGFyZ2V0UG9zWzFdLFxuICAgICAgICB0YXJnZXRQb3NbMl0gLSB0aGlzLl9wcmV2VGFyZ2V0UG9zWzJdLFxuICAgICAgXSkgPiAwO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5fcHJldlRhcmdldFBvcywgdGFyZ2V0UG9zKTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgYW5nbGVzIHRvIHJvdGF0ZSB0byB0aGUgdGFyZ2V0XG4gICAgY29uc3QgdGFyZ2V0U3BoZXJpY2FsID0gTWF0aFV0aWxzLmNhcnRlc2lhblRvU3BoZXJpY2FsKFxuICAgICAgdGFyZ2V0UG9zWzBdIC0gdHJhY2tlclBvc1swXSxcbiAgICAgIHRhcmdldFBvc1sxXSAtIHRyYWNrZXJQb3NbMV0sXG4gICAgICB0YXJnZXRQb3NbMl0gLSB0cmFja2VyUG9zWzJdXG4gICAgKTtcbiAgICBjb25zdCB0YXJnZXRBbmdsZXMgPSB0aGlzLmNvbnN0cnVjdG9yLl9zcGhlcmljYWxUb0JsZW5kVmFsdWUoXG4gICAgICB0YXJnZXRTcGhlcmljYWxbMV0sXG4gICAgICB0YXJnZXRTcGhlcmljYWxbMl1cbiAgICApO1xuXG4gICAgLy8gQ2FsY3VsYXRlIGFuZ2xlcyByZWxhdGl2ZSB0byB0aGUgcmVmZXJlbmNlIG9iamVjdHNcbiAgICB0aGlzLl90cmFja2luZ0NvbmZpZ3MuZm9yRWFjaCgoe3JlZmVyZW5jZSwgZm9yd2FyZEF4aXMsIGFuZ2xlc30pID0+IHtcbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgYW5nbGVzIHRvIHJvdGF0ZSB0byB0aGUgZGlyZWN0aW9uIG9mIHRoZSB0cmFja2VyXG4gICAgICBjb25zdCByZWZEaXJlY3Rpb24gPSB0aGlzLmNvbnN0cnVjdG9yLl9nZXRPYmplY3REaXJlY3Rpb24oXG4gICAgICAgIHJlZmVyZW5jZSxcbiAgICAgICAgZm9yd2FyZEF4aXNcbiAgICAgICk7XG4gICAgICBjb25zdCByZWZTcGhlcmljYWwgPSBNYXRoVXRpbHMuY2FydGVzaWFuVG9TcGhlcmljYWwoLi4ucmVmRGlyZWN0aW9uKTtcbiAgICAgIGNvbnN0IHJlZkFuZ2xlcyA9IHRoaXMuY29uc3RydWN0b3IuX3NwaGVyaWNhbFRvQmxlbmRWYWx1ZShcbiAgICAgICAgcmVmU3BoZXJpY2FsWzFdLFxuICAgICAgICByZWZTcGhlcmljYWxbMl1cbiAgICAgICk7XG5cbiAgICAgIC8vIFN0b3JlIHRoZSBkaWZmZXJlbmNlXG4gICAgICBhbmdsZXMuaCA9IHRhcmdldEFuZ2xlcy5oIC0gcmVmQW5nbGVzLmg7XG4gICAgICBhbmdsZXMudiA9IHRhcmdldEFuZ2xlcy52IC0gcmVmQW5nbGVzLnY7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBhbmdsZXMgaXQgd291bGQgcmVxdWlyZSB0byBzaW11bGF0ZSBsb29raW5nXG4gICAqIGF0IHRoZSBnaXZlbiB0eXBlIG9mIGZhY2UgdGFyZ2V0XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXRUeXBlIC0gSW50ZWdlciByZXByZXNlbnRpbmcgdGhlIEZhY2VUYXJnZXRUeXBlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fS0gQW4gb2JqZWN0IHdpdGggc2lnbmF0dXJlIHtyOiBudW1iZXIsIGg6IG51bWJlciwgdjogbnVtYmVyfVxuICAgKiB3aGVyZSAncicgcmVwcmVzZW50cyByYWRpdXMsIGggcmVwcmVzZW50cyB0aGUgaG9yaXpvbnRhbC9hemltdXRoYWwgYW5nbGUgYW5kXG4gICAqIHYgcmVwcmVzZW50cyB0aGUgdmVydGljYWwvcG9sYXIgYW5nbGUuXG4gICAqL1xuICBfZ2V0RmFjZVRhcmdldEFuZ2xlcyh0YXJnZXRUeXBlKSB7XG4gICAgLy8gTm8gb2Zmc2V0IHdoZW4gdGhlIHRhcmdldCBpcyB0aGUgY2VudGVyIG9mIHRoZSBleWVzXG4gICAgaWYgKHRhcmdldFR5cGUgPT09IDApIHtcbiAgICAgIHJldHVybiB7aDogMCwgdjogMH07XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgYSB2ZWN0b3IgdG8gdGhlIGZhY2UgdGFyZ2V0IHR5cGUgdXNpbmcgdGhlIGN1cnJlbnQgZGlzdGFuY2UgdG8gdGhlIHRhcmdldFxuICAgIGNvbnN0IGRpc3RhbmNlID0gdGhpcy5fZ2V0VGFyZ2V0RGlzdGFuY2UodGhpcy5fbG9va1RyYWNrZXIpO1xuICAgIGNvbnN0IGZhY2VWZWN0b3IgPSBbLi4uRmFjZVZlY3RvcnNbdGFyZ2V0VHlwZV1dO1xuICAgIGZhY2VWZWN0b3JbMl0gPSBkaXN0YW5jZTtcbiAgICBjb25zdCBzcGhlcmljYWwgPSBNYXRoVXRpbHMuY2FydGVzaWFuVG9TcGhlcmljYWwoLi4uZmFjZVZlY3Rvcik7XG5cbiAgICAvLyBNYWtlIHN1cmUgdmFsdWVzIGFyZSBjbGFtcGVkIHdpdGhpbiB0aGUgcmFuZ2Ugb2YgbW90aW9uIG9mIHRoZSBodW1hbiBleWUsIGluIGNhc2UgdGhlIHRhcmdldCBpcyB2ZXJ5IGNsb3NlXG4gICAgY29uc3QgYmxlbmRWYWx1ZXMgPSB0aGlzLmNvbnN0cnVjdG9yLl9zcGhlcmljYWxUb0JsZW5kVmFsdWUoXG4gICAgICBzcGhlcmljYWxbMV0sXG4gICAgICBzcGhlcmljYWxbMl1cbiAgICApO1xuICAgIGJsZW5kVmFsdWVzLmggPSBNYXRoVXRpbHMuY2xhbXAoYmxlbmRWYWx1ZXMuaCwgLTM1LCAzNSk7XG4gICAgYmxlbmRWYWx1ZXMudiA9IE1hdGhVdGlscy5jbGFtcChibGVuZFZhbHVlcy52LCAtMjUsIDMwKTtcblxuICAgIHJldHVybiBibGVuZFZhbHVlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVkIHRoZSBzdG9yZWQgc3BlZWQgYW5kIGR1cmF0aW9uIHZhcmlhYmxlcyBmb3IgYSBsYXllciBiYXNlZCBvbiB0aGVcbiAgICogY2hhbmdlIGluIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGFuZ2xlcyBvZiB0aGUgdHJhY2tlci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRvIHN0b3JlIHZhbHVlcyBvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGggLSBDaGFuZ2UgaW4gaG9yaXpvbnRhbCBhbmdsZSwgaW4gZGVncmVlcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHYgLSBDaGFuZ2UgaW4gdmVydGljYWwgYW5nbGUsIGluIGRlZ3JlZXMuXG4gICAqL1xuICBfdXBkYXRlTGF5ZXJTcGVlZChsYXllck5hbWUsIGgsIHYpIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXTtcblxuICAgIC8vIEZyb20gXCJSZWFsaXN0aWMgQXZhdGFyIGFuZCBoZWFkIEFuaW1hdGlvbiBVc2luZyBhIE5ldXJvYmlvbG9naWNhbCBNb2RlbCBvZiBWaXN1YWwgQXR0ZW50aW9uXCIsIEl0dGksIERoYXZhbGUsIFBpZ2hpblxuICAgIGxheWVyLm1heEhTcGVlZCA9IDQ3MyAqICgxIC0gTWF0aC5leHAoLWggLyA3LjgpKTtcbiAgICBsYXllci5tYXhWU3BlZWQgPSA0NzMgKiAoMSAtIE1hdGguZXhwKC12IC8gNy44KSk7XG5cbiAgICAvLyBGcm9tIFwiRXllcyBBbGl2ZVwiLCBMZWUsIEJhZGxlclxuICAgIGNvbnN0IEQwID0gMC4wMjU7XG4gICAgY29uc3QgZCA9IDAuMDAyMzU7XG4gICAgbGF5ZXIuaER1cmF0aW9uID0gRDAgKyBkICogaDtcbiAgICBsYXllci52RHVyYXRpb24gPSBEMCArIGQgKiB2O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbWljcm9TYWNjYWRlIG9iamVjdCB3aXRoIG5ldyByYW5kb21pemVkIHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRoYXQgb3ducyB0aGUgc2FjY2FkZSBtb3Rpb24uXG4gICAqL1xuICBfc2V0TWljcm9TYWNjYWRlKGxheWVyTmFtZSkge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdO1xuICAgIGNvbnN0IHttaWNyb1NhY2NhZGV9ID0gbGF5ZXI7XG5cbiAgICBpZiAodGhpcy5fdGFyZ2V0KSB7XG4gICAgICAvLyBNaWNybyBtb3ZlbWVudHMgc2hvdWxkIGJlIHNtYWxsZXIgd2hlbiBmb2N1c2VkIG9uIGEgdGFyZ2V0XG4gICAgICBtaWNyb1NhY2NhZGUuaCA9IFV0aWxzLmdldFJhbmRvbUZsb2F0KDAuMDEsIDAuMTUpO1xuICAgICAgbWljcm9TYWNjYWRlLnYgPSBVdGlscy5nZXRSYW5kb21GbG9hdCgwLjAxLCAwLjE1KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTWljcm9zYWNjYWRlcy4gRW5jeWNsb3BlZGlhIG9mIE5ldXJvc2NpZW5jZS4gKDIwMDkpIFNwcmluZ2VyLCBCZXJsaW4sIEhlaWRlbGJlcmcuIGh0dHBzOi8vZG9pLm9yZy8xMC4xMDA3Lzk3OC0zLTU0MC0yOTY3OC0yXzM0OTJcbiAgICAgIG1pY3JvU2FjY2FkZS5oID0gVXRpbHMuZ2V0UmFuZG9tRmxvYXQoMC4wMSwgMC4zKTtcbiAgICAgIG1pY3JvU2FjY2FkZS52ID0gVXRpbHMuZ2V0UmFuZG9tRmxvYXQoMC4wMSwgMC4zKTtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVMYXllclNwZWVkKGxheWVyTmFtZSwgbWljcm9TYWNjYWRlLmgsIG1pY3JvU2FjY2FkZS52KTtcblxuICAgIC8vIFJlc3RhcnQgdGhlIHRpbWVyXG4gICAgdGhpcy5faW5pdGlhbGl6ZU1pY3JvVGltZXIobGF5ZXJOYW1lLCAuLi5NaWNyb1NhY2NhZGVXYWl0UmFuZ2VzLmRlZmF1bHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbWFjcm9TYWNjYWRlIG9iamVjdCB3aXRoIG5ldyByYW5kb21pemVkIHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRoYXQgb3ducyB0aGUgc2FjY2FkZSBtb3Rpb24uXG4gICAqL1xuICBfc2V0TWFjcm9TYWNjYWRlKGxheWVyTmFtZSkge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdO1xuICAgIGNvbnN0IHttYWNyb1NhY2NhZGV9ID0gbGF5ZXI7XG4gICAgbGV0IG1hY3JvU2FjY2FkZVdhaXRSYW5nZTtcblxuICAgIC8vIEluY3JlYXNlIHJhbmRvbSB2YWx1ZSByYW5nZSB3aGVuIG5vdCBmb2N1c2VkIG9uIGEgdGFyZ2V0XG4gICAgaWYgKCF0aGlzLl90YXJnZXQpIHtcbiAgICAgIG1hY3JvU2FjY2FkZVdhaXRSYW5nZSA9IE1hY3JvU2FjY2FkZVdhaXRSYW5nZXMuZGVmYXVsdDtcblxuICAgICAgLy8gTm9ybWFsIGh1bWFuIGhvcml6b250YWwgZXllIHJvdGF0aW9uIGxpbWl0IGlzIGFib3V0IDM1IGRlZ3JlZXNcbiAgICAgIGNvbnN0IGhMaW1pdCA9IFV0aWxzLmdldFJhbmRvbUZsb2F0KDAuMTQzLCAwLjI4Nik7XG4gICAgICBjb25zdCBoRmFjdG9yID0gVXRpbHMuZ2V0UmFuZG9tRmxvYXQoLWhMaW1pdCwgaExpbWl0KTtcbiAgICAgIG1hY3JvU2FjY2FkZS5oID0gaEZhY3RvciAqIDM1O1xuXG4gICAgICAvLyBOb3JtYWwgaHVtYW4gdmVydGljYWwgZXllIHJvdGF0aW9uIGxpbWl0IGlzIGFib3V0IDI1IGRlZ3JlZXMgdXB3YXJkIGFuZCAzMCBkZWdyZWVzIGRvd253YXJkXG4gICAgICBjb25zdCB2TGltaXQgPSBVdGlscy5nZXRSYW5kb21GbG9hdCgwLjA5MywgMC4xODYpO1xuICAgICAgY29uc3QgdkZhY3RvciA9IFV0aWxzLmdldFJhbmRvbUZsb2F0KC12TGltaXQsIHZMaW1pdCk7XG4gICAgICBtYWNyb1NhY2NhZGUudiA9IHZGYWN0b3IgPiAwID8gdkZhY3RvciAqIDI1IDogdkZhY3RvciAqIDMwO1xuICAgIH1cblxuICAgIC8vIFBpY2sgYSBuZXcgZmFjZSB0YXJnZXRcbiAgICBlbHNlIHtcbiAgICAgIC8vIFNvY2lhbCB0cmlhbmdsZSAtIHNhY2NhZGUgYmV0d2VlbiBleWVzIGFuZCBtb3V0aCwgd2VpZ2h0ZWQgdG8gbG9vayBhdCBleWVzIG1vcmUgb2Z0ZW5cbiAgICAgIHN3aXRjaCAobGF5ZXIuc2FjY2FkZVRhcmdldCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgbWFjcm9TYWNjYWRlV2FpdFJhbmdlID0gTWFjcm9TYWNjYWRlV2FpdFJhbmdlcy5leWVUYXJnZXQ7XG4gICAgICAgICAgbGF5ZXIuc2FjY2FkZVRhcmdldCA9XG4gICAgICAgICAgICBNYXRoLnJhbmRvbSgpIDwgMC43NVxuICAgICAgICAgICAgICA/IEZhY2VUYXJnZXRUeXBlcy5FeWVSaWdodFxuICAgICAgICAgICAgICA6IEZhY2VUYXJnZXRUeXBlcy5Nb3V0aDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIG1hY3JvU2FjY2FkZVdhaXRSYW5nZSA9IE1hY3JvU2FjY2FkZVdhaXRSYW5nZXMuZXllVGFyZ2V0O1xuICAgICAgICAgIGxheWVyLnNhY2NhZGVUYXJnZXQgPVxuICAgICAgICAgICAgTWF0aC5yYW5kb20oKSA8IDAuNzVcbiAgICAgICAgICAgICAgPyBGYWNlVGFyZ2V0VHlwZXMuRXllTGVmdFxuICAgICAgICAgICAgICA6IEZhY2VUYXJnZXRUeXBlcy5Nb3V0aDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIG1hY3JvU2FjY2FkZVdhaXRSYW5nZSA9IE1hY3JvU2FjY2FkZVdhaXRSYW5nZXMubW91dGhUYXJnZXQ7XG4gICAgICAgICAgbGF5ZXIuc2FjY2FkZVRhcmdldCA9XG4gICAgICAgICAgICBNYXRoLnJhbmRvbSgpIDwgMC41XG4gICAgICAgICAgICAgID8gRmFjZVRhcmdldFR5cGVzLkV5ZUxlZnRcbiAgICAgICAgICAgICAgOiBGYWNlVGFyZ2V0VHlwZXMuRXllUmlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBtYWNyb1NhY2NhZGVXYWl0UmFuZ2UgPSBNYWNyb1NhY2NhZGVXYWl0UmFuZ2VzLmV5ZVRhcmdldDtcbiAgICAgICAgICBsYXllci5zYWNjYWRlVGFyZ2V0ID1cbiAgICAgICAgICAgIE1hdGgucmFuZG9tKCkgPCAwLjVcbiAgICAgICAgICAgICAgPyBGYWNlVGFyZ2V0VHlwZXMuRXllTGVmdFxuICAgICAgICAgICAgICA6IEZhY2VUYXJnZXRUeXBlcy5FeWVSaWdodDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY29uc3Qge2gsIHZ9ID0gdGhpcy5fZ2V0RmFjZVRhcmdldEFuZ2xlcyhsYXllci5zYWNjYWRlVGFyZ2V0KTtcbiAgICAgIG1hY3JvU2FjY2FkZS5oID0gaDtcbiAgICAgIG1hY3JvU2FjY2FkZS52ID0gdjtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVMYXllclNwZWVkKGxheWVyTmFtZSwgbWFjcm9TYWNjYWRlLmgsIG1hY3JvU2FjY2FkZS52KTtcblxuICAgIC8vIFJlc3RhcnQgdGhlIHRpbWVyc1xuICAgIHRoaXMuX2luaXRpYWxpemVNaWNyb1RpbWVyKGxheWVyTmFtZSwgLi4uTWljcm9TYWNjYWRlV2FpdFJhbmdlcy5wb3N0TWFjcm8pO1xuICAgIHRoaXMuX2luaXRpYWxpemVNYWNyb1RpbWVyKGxheWVyTmFtZSwgLi4ubWFjcm9TYWNjYWRlV2FpdFJhbmdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBhIG5ldyB3YWl0IHRpbWVyIHRoYXQgd2lsbCBzZXQgYSBuZXcgbWljcm8gc2FjY2FkZSBtb3ZlbWVudCB3aGVuIGl0XG4gICAqIHJlc29sdmVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCBvd25zIHRoZSBzYWNjYWRlIG1vdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pbldhaXRUaW1lIC0gTWluaW11bSBudW1iZXIgb2Ygc2Vjb25kcyBiZWZvcmUgYSBuZXcgc2FjY2FkZVxuICAgKiB3aWxsIGJlIHRyaWdnZXJlZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heFdhaXRUaW1lIC0gTWF4aW11bSBudW1iZXIgb2Ygc2Vjb25kcyBiZWZvcmUgYSBuZXcgc2FjY2FkZVxuICAgKiB3aWxsIGJlIHRyaWdnZXJlZC5cbiAgICovXG4gIF9pbml0aWFsaXplTWljcm9UaW1lcihsYXllck5hbWUsIG1pbldhaXRUaW1lLCBtYXhXYWl0VGltZSkge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdO1xuICAgIGNvbnN0IHdhaXRUaW1lID0gVXRpbHMuZ2V0UmFuZG9tRmxvYXQobWluV2FpdFRpbWUsIG1heFdhaXRUaW1lKTtcblxuICAgIGlmIChsYXllci5taWNyb1NhY2NhZGVUaW1lcikge1xuICAgICAgbGF5ZXIubWljcm9TYWNjYWRlVGltZXIuY2FuY2VsKCk7XG4gICAgfVxuICAgIGxheWVyLm1pY3JvU2FjY2FkZVRpbWVyID0gVXRpbHMud2FpdCh3YWl0VGltZSwge1xuICAgICAgb25GaW5pc2g6ICgpID0+IHtcbiAgICAgICAgdGhpcy5fc2V0TWljcm9TYWNjYWRlKGxheWVyTmFtZSk7XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGEgbmV3IHdhaXQgdGltZXIgdGhhdCB3aWxsIHNldCBhIG5ldyBtYWNybyBzYWNjYWRlIG1vdmVtZW50IHdoZW4gaXRcbiAgICogcmVzb2x2ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0aGF0IG93bnMgdGhlIHNhY2NhZGUgbW90aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluV2FpdFRpbWUgLSBNaW5pbXVtIG51bWJlciBvZiBzZWNvbmRzIGJlZm9yZSBhIG5ldyBzYWNjYWRlXG4gICAqIHdpbGwgYmUgdHJpZ2dlcmVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4V2FpdFRpbWUgLSBNYXhpbXVtIG51bWJlciBvZiBzZWNvbmRzIGJlZm9yZSBhIG5ldyBzYWNjYWRlXG4gICAqIHdpbGwgYmUgdHJpZ2dlcmVkLlxuICAgKi9cbiAgX2luaXRpYWxpemVNYWNyb1RpbWVyKGxheWVyTmFtZSwgbWluV2FpdFRpbWUsIG1heFdhaXRUaW1lKSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV07XG4gICAgY29uc3Qgd2FpdFRpbWUgPSBVdGlscy5nZXRSYW5kb21GbG9hdChtaW5XYWl0VGltZSwgbWF4V2FpdFRpbWUpO1xuXG4gICAgaWYgKGxheWVyLm1hY3JvU2FjY2FkZVRpbWVyKSB7XG4gICAgICBsYXllci5tYWNyb1NhY2NhZGVUaW1lci5jYW5jZWwoKTtcbiAgICB9XG4gICAgbGF5ZXIubWFjcm9TYWNjYWRlVGltZXIgPSBVdGlscy53YWl0KHdhaXRUaW1lLCB7XG4gICAgICBvbkZpbmlzaDogKCkgPT4ge1xuICAgICAgICB0aGlzLl9zZXRNYWNyb1NhY2NhZGUobGF5ZXJOYW1lKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIG5ldyB0YXJnZXQgdG8gbG9vayBhdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R8bnVsbH0gdGFyZ2V0IC0gVGhlIG5ldyB0YXJnZXQgdG8gbG9vayBhdC5cbiAgICovXG4gIHNldFRhcmdldCh0YXJnZXQpIHtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyBhbiBvYmplY3QgZ2l2ZW4gaXRzIG5hbWUgYW5kIHNldHMgaXQgYXMgdGhlIG5ldyB0YXJnZXQgdG8gbG9vayBhdC5cbiAgICogU2hvdWxkIGJlIG92ZXJsb2FkZWQgZm9yIGVhY2ggcmVuZGVyaW5nIGVuZ2luZSBpbXBsZW1lbnRhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldCAtIE5hbWUgdG8gc2VhcmNoIGZvci5cbiAgICovXG4gIHNldFRhcmdldEJ5TmFtZShuYW1lKSB7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aGlzLl90YXJnZXQgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fc2NlbmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBzZXQgUG9pbnRPZkludGVyZXN0RmVhdHVyZSB0YXJnZXQgdXNpbmcgbmFtZSAke25hbWV9IG9uIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gU2NlbmUgbXVzdCBiZSBkZWZpbmVkLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIGFuIG9iamVjdCBnaXZlbiBpdHMgaWQgYW5kIHNldHMgaXQgYXMgdGhlIG5ldyB0YXJnZXQgdG8gbG9vayBhdC5cbiAgICogU2hvdWxkIGJlIG92ZXJsb2FkZWQgZm9yIGVhY2ggcmVuZGVyaW5nIGVuZ2luZSBpbXBsZW1lbnRhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB0YXJnZXQgLSBJZCB0byBzZWFyY2ggZm9yLlxuICAgKi9cbiAgc2V0VGFyZ2V0QnlJZChpZCkge1xuICAgIGlmICghaWQpIHtcbiAgICAgIHRoaXMuX3RhcmdldCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9zY2VuZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IHNldCBQb2ludE9mSW50ZXJlc3RGZWF0dXJlIHRhcmdldCB1c2luZyBpZCAke2lkfSBvbiBob3N0ICR7dGhpcy5faG9zdC5pZH0uIFNjZW5lIG11c3QgYmUgZGVmaW5lZC5gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBrZWVwaW5nIHRyYWNrIG9mIGFuIGFuaW1hdGlvbiBsYXllciB0aGF0IG93bnMgYSBibGVuZDJkIGFuaW1hdGlvbiB3aXRoXG4gICAqIGJsZW5kV2VpZ2h0cyBjb3JyZXNwb25kaW5nIHRvIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGxvb2sgYW5nbGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdG8ga2VlcCB0cmFjayBvZi5cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGxheWVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uID0gJ2xvb2snXSAtIE5hbWUgb2YgdGhlIGFuaW1hdGlvbiBvbiB0aGVcbiAgICogbGF5ZXIgd2hvc2UgYmxlbmRXZWlnaHRzIHdpbGwgYmUgZHJpdmVuIGJhc2VkIG9uIHRoZSBhbmdsZSBiZXR3ZWVuIHRoZSBsb29rVHJhY2tlclxuICAgKiBhbmQgdGhlIGxvb2tUYXJnZXQuIFRoaXMgYW5pbWF0aW9uIG11c3QgYmUgb2YgdHlwZSBibGVuZDJkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4U3BlZWQgPSAyNV0gLSBUaGUgbWF4aW11bSBzcGVlZCBhdCB3aGljaCB0aGUgYmxlbmQyZFxuICAgKiBibGVuZFdlaWdodHMgY2FuIGJlIG1hbmlwdWxhdGVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZm9yd2FyZEF4aXMgPSAnUG9zaXRpdmVaJ10gLSBBeGlzIHBvaW50aW5nIGZyb20gdGhlXG4gICAqIGZyb250IG9mIHRoZSBsb29rUmVmZXJlbmNlIG9iamVjdC4gVmFsaWQgb3B0aW9ucyBhcmUgJ1Bvc2l0aXZlWCcsICdOZWdhdGl2ZVgnLFxuICAgKiAnUG9zaXRpdmVZJywgJ05lZ2F0aXZlWScsICdQb3NpdGl2ZVonLCAnTmVnYXRpdmVaJy5cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zLmxvb2tSZWZlcmVuY2UgLSAzRCB0cmFuc2Zvcm1hdGlvbiBub2RlIHRoYXQgdGhlIGxvb2tUcmFja2VyXG4gICAqIHJvdGF0aW9uIGxpbWl0cyBzaG91bGQgYmUgY2FsY3VsYXRlZCByZWxhdGl2ZSB0by4gRGVmYXVsdHMgdG8gdGhlIGhvc3Qgb3duZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5oYXNTYWNjYWRlID0gZmFsc2VdIC0gV2hldGhlciBvciBub3QgdG8gaW5jbHVkZVxuICAgKiBzYWNjYWRpYyBtb3Rpb24gb250byB0aGUgYmxlbmRXZWlnaHQgYW5pbWF0aW9uLiBUaGlzIHNob3VsZCBvbmx5IGJlIHNldCB0b1xuICAgKiB0cnVlIGZvciBibGVuZDJkIGFuaW1hdGlvbnMgcmVwcmVzZW50aW5nIGV5ZSBhbmltYXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gW29wdGlvbnMuYmxlbmRUaW1lPVtQb2ludE9mSW50ZXJlc3RGZWF0dXJlLkRFRkFVTFRfTEFZRVJfT1BUSU9OUy5ibGVuZFRpbWVde0BsaW5rIFBvaW50T2ZJbnRlcmVzdEZlYXR1cmUjREVGQVVMVF9MQVlFUl9PUFRJT05TI2JsZW5kVGltZX1dIC1cbiAgICogRGVmYXVsdCBhbW91bnQgb2YgdGltZSB0byB1c2Ugd2hlbiBtYW5pcHVsYXRpbmcgbGF5ZXIgd2VpZ2h0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb3B0aW9ucy5lYXNpbmdGbiAtIERlZmF1bHQgZWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSB3aGVuXG4gICAqIG1hbmlwdWxhdGluZyBsYXllciB3ZWlnaHQuXG4gICAqL1xuICByZWdpc3Rlckxvb2tMYXllcihcbiAgICBsYXllck5hbWUsXG4gICAge1xuICAgICAgYW5pbWF0aW9uID0gJ2xvb2snLFxuICAgICAgbWF4U3BlZWQgPSAyNSxcbiAgICAgIHJlZmVyZW5jZSxcbiAgICAgIGZvcndhcmRBeGlzID0gJ1Bvc2l0aXZlWicsXG4gICAgICBoYXNTYWNjYWRlID0gZmFsc2UsXG4gICAgICBibGVuZFRpbWUgPSBQb2ludE9mSW50ZXJlc3RGZWF0dXJlLkRFRkFVTFRfTEFZRVJfT1BUSU9OUy5ibGVuZFRpbWUsXG4gICAgICBlYXNpbmdGbixcbiAgICB9ID0ge31cbiAgKSB7XG4gICAgLy8gVmFsaWRhdGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIHJlZmVyZW5jZSA9IHJlZmVyZW5jZSB8fCB0aGlzLl9ob3N0Lm93bmVyO1xuXG4gICAgaWYgKCF0aGlzLmNvbnN0cnVjdG9yLl92YWxpZGF0ZVRyYW5zZm9ybU9iamVjdChyZWZlcmVuY2UpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgaW5pdGlhbGl6ZSByZWdpc3RlciBsb29rIGxheWVyICR7bGF5ZXJOYW1lfSBmb3IgUG9pbnRPZkludGVyZXN0RmVhdHVyZSBvbiBob3N0ICR7dGhpcy5faG9zdC5pZH0uIFJlZmVyZW5jZSBtdXN0IGJlIGRlZmluZWQgYXMgYSB2YWxpZCB0cmFuc2Zvcm1hdGlvbiBvYmplY3QuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIHZlY3RvciBhc3NvY2lhdGVkIHdpdGggYXhpcyBzdHJpbmdcbiAgICBmb3J3YXJkQXhpcyA9XG4gICAgICBBeGlzTWFwW2ZvcndhcmRBeGlzXSAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gQXhpc01hcFtmb3J3YXJkQXhpc11cbiAgICAgICAgOiBBeGlzTWFwLlBvc2l0aXZlWjtcblxuICAgIC8vIFN0b3JlIHRyYWNraW5nIGNvbmZpZ3VyYXRpb25cbiAgICBjb25zdCB0cmFja2luZ0NvbmZpZyA9IHRoaXMuX2FkZFRyYWNraW5nQ29uZmlnKHtcbiAgICAgIHJlZmVyZW5jZSxcbiAgICAgIGZvcndhcmRBeGlzLFxuICAgIH0pO1xuXG4gICAgLy8gUmVnaXN0ZXIgdGhlIGxheWVyIGFuZCBhbmltYXRpb25cbiAgICB0aGlzLnJlZ2lzdGVyTGF5ZXIobGF5ZXJOYW1lLCB7XG4gICAgICB0cmFja2luZ0NvbmZpZyxcbiAgICAgIG1heFNwZWVkLFxuICAgICAgbWF4SFNwZWVkOiB1bmRlZmluZWQsXG4gICAgICBtYXhWU3BlZWQ6IHVuZGVmaW5lZCxcbiAgICAgIGhEdXJhdGlvbjogdW5kZWZpbmVkLFxuICAgICAgdkR1cmF0aW9uOiB1bmRlZmluZWQsXG4gICAgICBoVmVsb2NpdHk6IFswLCAwXSxcbiAgICAgIHZWZWxvY2l0eTogWzAsIDBdLFxuICAgICAgaGFzU2FjY2FkZSxcbiAgICAgIGJsZW5kVGltZSxcbiAgICAgIGVhc2luZ0ZuLFxuICAgICAgbWljcm9TYWNjYWRlOiB7aDogMCwgdjogMH0sXG4gICAgICBtYWNyb1NhY2NhZGU6IHtoOiAwLCB2OiAwfSxcbiAgICAgIHNhY2NhZGVUYXJnZXQ6IEZhY2VUYXJnZXRUeXBlcy5FeWVDZW50ZXIsXG4gICAgICBhbmltYXRpb25zOiB7W2FuaW1hdGlvbl06IHt9fSxcbiAgICB9KTtcbiAgICB0aGlzLl9sb29rTGF5ZXJzW2xheWVyTmFtZV0gPSBhbmltYXRpb247XG5cbiAgICAvLyBWYWxpZGF0ZSB0aGUgbG9vayBhbmltYXRpb25cbiAgICB0aGlzLl9yZWdpc3Rlckxvb2tBbmltYXRpb24obGF5ZXJOYW1lLCBhbmltYXRpb24pO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBzYWNjYWRlIHRpbWVyc1xuICAgIGlmIChoYXNTYWNjYWRlKSB7XG4gICAgICBjb25zdCBtYWNyb1NhY2NhZGVXYWl0UmFuZ2UgPSB0aGlzLl90YXJnZXRcbiAgICAgICAgPyBNYWNyb1NhY2NhZGVXYWl0UmFuZ2VzLmV5ZVRhcmdldFxuICAgICAgICA6IE1hY3JvU2FjY2FkZVdhaXRSYW5nZXMuZGVmYXVsdDtcbiAgICAgIHRoaXMuX2luaXRpYWxpemVNaWNyb1RpbWVyKGxheWVyTmFtZSwgLi4uTWljcm9TYWNjYWRlV2FpdFJhbmdlcy5kZWZhdWx0KTtcbiAgICAgIHRoaXMuX2luaXRpYWxpemVNYWNyb1RpbWVyKGxheWVyTmFtZSwgLi4ubWFjcm9TYWNjYWRlV2FpdFJhbmdlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQga2VlcGluZyB0cmFjayBvZiBhbiBhbmltYXRpb24gbGF5ZXIgdGhhdCBvd25zIGEgYmxpbmsgYW5pbWF0aW9uLiBCbGlua1xuICAgKiBhbmltYXRpb25zIGNhbiBiZSBvZiBhbnkgdHlwZSwgYnV0IGlmIGl0IGlzIG9mIHR5cGUgcmFuZG9tQW5pbWF0aW9uIHRoZW4gYVxuICAgKiBpdCB3aWxsIGJlIHJhbmRvbWl6ZWQgZWFjaCB0aW1lIGEgYmxpbmsgaXMgY2FsbGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdG8ga2VlcCB0cmFjayBvZi5cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGxheWVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uID0gJ2JsaW5rJ10gLSBOYW1lIG9mIHRoZSBibGluayBhbmltYXRpb25cbiAgICogb24gdGhlIGxheWVyLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuYmxlbmRUaW1lPVtQb2ludE9mSW50ZXJlc3RGZWF0dXJlLkRFRkFVTFRfTEFZRVJfT1BUSU9OUy5ibGVuZFRpbWVde0BsaW5rIFBvaW50T2ZJbnRlcmVzdEZlYXR1cmUjREVGQVVMVF9MQVlFUl9PUFRJT05TI2JsZW5kVGltZX1dIC1cbiAgICogRGVmYXVsdCBhbW91bnQgb2YgdGltZSB0byB1c2Ugd2hlbiBtYW5pcHVsYXRpbmcgdGhlIGxheWVyJ3Mgd2VpZ2h0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb3B0aW9ucy5lYXNpbmdGbiAtIERlZmF1bHQgZWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSB3aGVuXG4gICAqIG1hbmlwdWxhdGluZyB0aGUgbGF5ZXIncyB3ZWlnaHQuXG4gICAqL1xuICByZWdpc3RlckJsaW5rTGF5ZXIoXG4gICAgbGF5ZXJOYW1lLFxuICAgIHtcbiAgICAgIGFuaW1hdGlvbiA9ICdibGluaycsXG4gICAgICBibGVuZFRpbWUgPSBQb2ludE9mSW50ZXJlc3RGZWF0dXJlLkRFRkFVTFRfTEFZRVJfT1BUSU9OUy5ibGVuZFRpbWUsXG4gICAgICBlYXNpbmdGbixcbiAgICB9ID0ge31cbiAgKSB7XG4gICAgLy8gUmVnaXN0ZXIgdGhlIGxheWVyIGFuZCBhbmltYXRpb25cbiAgICB0aGlzLnJlZ2lzdGVyTGF5ZXIobGF5ZXJOYW1lLCB7XG4gICAgICBibGVuZFRpbWUsXG4gICAgICBlYXNpbmdGbixcbiAgICAgIGFuaW1hdGlvbnM6IHtbYW5pbWF0aW9uXToge319LFxuICAgIH0pO1xuICAgIHRoaXMuX2JsaW5rTGF5ZXJzW2xheWVyTmFtZV0gPSBhbmltYXRpb247XG4gIH1cblxuICB1cGRhdGUoZGVsdGFUaW1lKSB7XG4gICAgc3VwZXIudXBkYXRlKGRlbHRhVGltZSk7XG5cbiAgICAvLyBVcGRhdGUgdGhlIGxvb2sgYW5nbGVzXG4gICAgaWYgKHRoaXMuX3RhcmdldCkge1xuICAgICAgdGhpcy5fc2V0TG9va0FuZ2xlcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXNldExvb2tBbmdsZXMoKTtcbiAgICB9XG5cbiAgICBjb25zdCBkZWx0YVNlY29uZHMgPSBNYXRoLm1pbihkZWx0YVRpbWUsIE1heERlbHRhKSAvIDEwMDA7XG4gICAgbGV0IHRyaWdnZXJCbGluayA9IGZhbHNlO1xuXG4gICAgLy8gU2V0IGxvb2sgYmxlbmQgdmFsdWVzXG4gICAgT2JqZWN0LmVudHJpZXModGhpcy5fbG9va0xheWVycykuZm9yRWFjaCgoW2xheWVyTmFtZSwgYW5pbU5hbWVdKSA9PiB7XG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdO1xuXG4gICAgICAvLyBJbmNyZW1lbnQgdGhlIHNhY2NhZGUgdGltZXJzXG4gICAgICBpZiAob3B0aW9ucy5pc0FjdGl2ZSAmJiBvcHRpb25zLmhhc1NhY2NhZGUpIHtcbiAgICAgICAgb3B0aW9ucy5taWNyb1NhY2NhZGVUaW1lci5leGVjdXRlKGRlbHRhVGltZSk7XG4gICAgICAgIG9wdGlvbnMubWFjcm9TYWNjYWRlVGltZXIuZXhlY3V0ZShkZWx0YVRpbWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgdGhlIGJsZW5kIHZhbHVlc1xuICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uc1thbmltTmFtZV0uaXNBY3RpdmUpIHtcbiAgICAgICAgY29uc3QgY3VycmVudEggPSB0aGlzLl9ob3N0LkFuaW1hdGlvbkZlYXR1cmUuZ2V0QW5pbWF0aW9uQmxlbmRXZWlnaHQoXG4gICAgICAgICAgbGF5ZXJOYW1lLFxuICAgICAgICAgIGFuaW1OYW1lLFxuICAgICAgICAgICdYJ1xuICAgICAgICApO1xuICAgICAgICBjb25zdCBjdXJyZW50ViA9IHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5nZXRBbmltYXRpb25CbGVuZFdlaWdodChcbiAgICAgICAgICBsYXllck5hbWUsXG4gICAgICAgICAgYW5pbU5hbWUsXG4gICAgICAgICAgJ1knXG4gICAgICAgICk7XG5cbiAgICAgICAgbGV0IHRhcmdldEggPSBvcHRpb25zLnRyYWNraW5nQ29uZmlnLmFuZ2xlcy5oO1xuICAgICAgICBsZXQgdGFyZ2V0ViA9IG9wdGlvbnMudHJhY2tpbmdDb25maWcuYW5nbGVzLnY7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGxvb2sgYW5nbGUgaGFzIGNoYW5nZWQgZW5vdWdoIHRvIHRyaWdnZXIgYSBibGlua1xuICAgICAgICBpZiAodGhpcy5faXNUYXJnZXRNb3ZpbmcgJiYgIXRyaWdnZXJCbGluaykge1xuICAgICAgICAgIGNvbnN0IHByZXZUYXJnZXRIID0gb3B0aW9ucy50cmFja2luZ0NvbmZpZy5wcmV2QW5nbGVzLmg7XG4gICAgICAgICAgY29uc3QgcHJldlRhcmdldFYgPSBvcHRpb25zLnRyYWNraW5nQ29uZmlnLnByZXZBbmdsZXMudjtcbiAgICAgICAgICBjb25zdCBjaGFuZ2VBbW91bnQgPSBNYXRoVXRpbHMudG9EZWdyZWVzKFxuICAgICAgICAgICAgTWF0aFV0aWxzLmdldEFuZ2xlQmV0d2VlbihcbiAgICAgICAgICAgICAgW3ByZXZUYXJnZXRILCBwcmV2VGFyZ2V0Vl0sXG4gICAgICAgICAgICAgIFt0YXJnZXRILCB0YXJnZXRWXVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBpZiAoY2hhbmdlQW1vdW50ID49IEJsaW5rVGhyZXNob2xkKSB7XG4gICAgICAgICAgICB0cmlnZ2VyQmxpbmsgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMudHJhY2tpbmdDb25maWcucHJldkFuZ2xlcy5oID0gdGFyZ2V0SDtcbiAgICAgICAgb3B0aW9ucy50cmFja2luZ0NvbmZpZy5wcmV2QW5nbGVzLnYgPSB0YXJnZXRWO1xuXG4gICAgICAgIC8vIEFkZCBpbiB0aGUgc2FjY2FkZSBtb3ZlbWVudFxuICAgICAgICBpZiAob3B0aW9ucy5oYXNTYWNjYWRlKSB7XG4gICAgICAgICAgTWF0aFV0aWxzLmRhbXBWYWx1ZShcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBvcHRpb25zLm1hY3JvU2FjY2FkZS5oICsgb3B0aW9ucy5tYWNyb1NhY2NhZGUuaCxcbiAgICAgICAgICAgIG9wdGlvbnMuaFZlbG9jaXR5LFxuICAgICAgICAgICAgb3B0aW9ucy5oRHVyYXRpb24sXG4gICAgICAgICAgICBvcHRpb25zLm1heEhTcGVlZFxuICAgICAgICAgICk7XG4gICAgICAgICAgdGFyZ2V0SCArPSBvcHRpb25zLmhWZWxvY2l0eVswXTtcbiAgICAgICAgICBNYXRoVXRpbHMuZGFtcFZhbHVlKFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIG9wdGlvbnMubWFjcm9TYWNjYWRlLnYgKyBvcHRpb25zLm1hY3JvU2FjY2FkZS52LFxuICAgICAgICAgICAgb3B0aW9ucy52VmVsb2NpdHksXG4gICAgICAgICAgICBvcHRpb25zLnZEdXJhdGlvbixcbiAgICAgICAgICAgIG9wdGlvbnMubWF4VlNwZWVkXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0YXJnZXRWICs9IG9wdGlvbnMudlZlbG9jaXR5WzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2xhbXAgdG8gbWF4IHNwZWVkXG4gICAgICAgIGNvbnN0IGZhY3RvciA9IE1hdGhVdGlscy5jbGFtcChkZWx0YVNlY29uZHMgKiBvcHRpb25zLm1heFNwZWVkLCAwLCAxKTtcbiAgICAgICAgdGFyZ2V0SCA9IE1hdGhVdGlscy5sZXJwKGN1cnJlbnRILCB0YXJnZXRILCBmYWN0b3IpO1xuICAgICAgICB0YXJnZXRWID0gTWF0aFV0aWxzLmxlcnAoY3VycmVudFYsIHRhcmdldFYsIGZhY3Rvcik7XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBibGVuZCB2YWx1ZXNcbiAgICAgICAgdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlLnNldEFuaW1hdGlvbkJsZW5kV2VpZ2h0KFxuICAgICAgICAgIGxheWVyTmFtZSxcbiAgICAgICAgICBhbmltTmFtZSxcbiAgICAgICAgICAnWCcsXG4gICAgICAgICAgdGFyZ2V0SFxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9ob3N0LkFuaW1hdGlvbkZlYXR1cmUuc2V0QW5pbWF0aW9uQmxlbmRXZWlnaHQoXG4gICAgICAgICAgbGF5ZXJOYW1lLFxuICAgICAgICAgIGFuaW1OYW1lLFxuICAgICAgICAgICdZJyxcbiAgICAgICAgICB0YXJnZXRWXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIXRyaWdnZXJCbGluayB8fCAhdGhpcy5faXNUYXJnZXRNb3ZpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBFeGVjdXRlIGJsaW5rXG4gICAgT2JqZWN0LmVudHJpZXModGhpcy5fYmxpbmtMYXllcnMpLmZvckVhY2goKFtsYXllck5hbWUsIGFuaW1OYW1lXSkgPT4ge1xuICAgICAgY29uc3QgYW5pbWF0aW9uID0gdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdLmFuaW1hdGlvbnNbYW5pbU5hbWVdO1xuXG4gICAgICBpZiAoYW5pbWF0aW9uLmlzQWN0aXZlKSB7XG4gICAgICAgIHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5wbGF5QW5pbWF0aW9uKGxheWVyTmFtZSwgYW5pbU5hbWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaW5zdGFsbEFwaSgpIHtcbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKiBAbmFtZXNwYWNlIFBvaW50T2ZJbnRlcmVzdEZlYXR1cmVcbiAgICAgKi9cbiAgICBjb25zdCBhcGkgPSBzdXBlci5pbnN0YWxsQXBpKCk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhhcGksIHtcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlcm9mIFBvaW50T2ZJbnRlcmVzdEZlYXR1cmVcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQHNlZSBjb3JlL1BvaW50T2ZJbnRlcmVzdEZlYXR1cmUjdGFyZ2V0XG4gICAgICAgKi9cbiAgICAgIHRhcmdldDoge1xuICAgICAgICBnZXQ6ICgpID0+IHRoaXMudGFyZ2V0LFxuICAgICAgICBzZXQ6IHRhcmdldCA9PiB7XG4gICAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmFzc2lnbihhcGksIHtcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlcm9mIFBvaW50T2ZJbnRlcmVzdEZlYXR1cmVcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQG1ldGhvZFxuICAgICAgICogQHNlZSBjb3JlL1BvaW50T2ZJbnRlcmVzdEZlYXR1cmUjcmVnaXN0ZXJMb29rTGF5ZXJcbiAgICAgICAqL1xuICAgICAgcmVnaXN0ZXJMb29rTGF5ZXI6IHRoaXMucmVnaXN0ZXJMb29rTGF5ZXIuYmluZCh0aGlzKSxcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlcm9mIFBvaW50T2ZJbnRlcmVzdEZlYXR1cmVcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQG1ldGhvZFxuICAgICAgICogQHNlZSBjb3JlL1BvaW50T2ZJbnRlcmVzdEZlYXR1cmUjcmVnaXN0ZXJCbGlua0xheWVyXG4gICAgICAgKi9cbiAgICAgIHJlZ2lzdGVyQmxpbmtMYXllcjogdGhpcy5yZWdpc3RlckJsaW5rTGF5ZXIuYmluZCh0aGlzKSxcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlcm9mIFBvaW50T2ZJbnRlcmVzdEZlYXR1cmVcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQG1ldGhvZFxuICAgICAgICogQHNlZSBjb3JlL1BvaW50T2ZJbnRlcmVzdEZlYXR1cmUjc2V0VGFyZ2V0XG4gICAgICAgKi9cbiAgICAgIHNldFRhcmdldDogdGhpcy5zZXRUYXJnZXQuYmluZCh0aGlzKSxcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlcm9mIFBvaW50T2ZJbnRlcmVzdEZlYXR1cmVcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQG1ldGhvZFxuICAgICAgICogQHNlZSBjb3JlL1BvaW50T2ZJbnRlcmVzdEZlYXR1cmUjc2V0VGFyZ2V0QnlOYW1lXG4gICAgICAgKi9cbiAgICAgIHNldFRhcmdldEJ5TmFtZTogdGhpcy5zZXRUYXJnZXRCeU5hbWUuYmluZCh0aGlzKSxcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlcm9mIFBvaW50T2ZJbnRlcmVzdEZlYXR1cmVcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQG1ldGhvZFxuICAgICAgICogQHNlZSBjb3JlL1BvaW50T2ZJbnRlcmVzdEZlYXR1cmUjc2V0VGFyZ2V0QnlJZFxuICAgICAgICovXG4gICAgICBzZXRUYXJnZXRCeUlkOiB0aGlzLnNldFRhcmdldEJ5SWQuYmluZCh0aGlzKSxcbiAgICB9KTtcblxuICAgIHJldHVybiBhcGk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUG9pbnRPZkludGVyZXN0RmVhdHVyZTtcbmV4cG9ydCB7QXhpc01hcH07XG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxuXG4vKipcbiAqIEBtb2R1bGUgY29yZS9hbmltcGFja1xuICovXG5cbmltcG9ydCB7XG4gIExpbmVhcixcbiAgUXVhZHJhdGljLFxuICBDdWJpYyxcbiAgUXVhcnRpYyxcbiAgUXVpbnRpYyxcbiAgU2ludXNvaWRhbCxcbiAgRXhwb25lbnRpYWwsXG4gIENpcmN1bGFyLFxuICBFbGFzdGljLFxuICBCYWNrLFxuICBCb3VuY2UsXG59IGZyb20gJy4vRWFzaW5nJztcbmltcG9ydCBBbmltYXRpb25GZWF0dXJlLCB7QW5pbWF0aW9uVHlwZXN9IGZyb20gJy4vQW5pbWF0aW9uRmVhdHVyZSc7XG5pbXBvcnQgQW5pbWF0aW9uTGF5ZXIsIHtcbiAgTGF5ZXJCbGVuZE1vZGVzLFxuICBEZWZhdWx0TGF5ZXJCbGVuZE1vZGUsXG59IGZyb20gJy4vQW5pbWF0aW9uTGF5ZXInO1xuaW1wb3J0IFNpbmdsZVN0YXRlIGZyb20gJy4vc3RhdGUvU2luZ2xlU3RhdGUnO1xuaW1wb3J0IFRyYW5zaXRpb25TdGF0ZSBmcm9tICcuL3N0YXRlL1RyYW5zaXRpb25TdGF0ZSc7XG5pbXBvcnQgRnJlZUJsZW5kU3RhdGUgZnJvbSAnLi9zdGF0ZS9GcmVlQmxlbmRTdGF0ZSc7XG5pbXBvcnQgUXVldWVTdGF0ZSBmcm9tICcuL3N0YXRlL1F1ZXVlU3RhdGUnO1xuaW1wb3J0IFJhbmRvbUFuaW1hdGlvblN0YXRlIGZyb20gJy4vc3RhdGUvUmFuZG9tQW5pbWF0aW9uU3RhdGUnO1xuaW1wb3J0IEJsZW5kMWRTdGF0ZSBmcm9tICcuL3N0YXRlL0JsZW5kMWRTdGF0ZSc7XG5pbXBvcnQgQmxlbmQyZFN0YXRlIGZyb20gJy4vc3RhdGUvQmxlbmQyZFN0YXRlJztcbmltcG9ydCBBbmltYXRpb25VdGlscyBmcm9tICcuL0FuaW1hdGlvblV0aWxzJztcblxuLyoqXG4gKiBAbmFtZXNwYWNlXG4gKi9cbmNvbnN0IEVhc2luZyA9IHtcbiAgLyoqXG4gICAqIEBzZWUgTGluZWFyXG4gICAqL1xuICBMaW5lYXIsXG4gIC8qKlxuICAgKiBAc2VlIFF1YWRyYXRpY1xuICAgKi9cbiAgUXVhZHJhdGljLFxuICAvKipcbiAgICogQHNlZSBDdWJpY1xuICAgKi9cbiAgQ3ViaWMsXG4gIC8qKlxuICAgKiBAc2VlIFF1YXJ0aWNcbiAgICovXG4gIFF1YXJ0aWMsXG4gIC8qKlxuICAgKiBAc2VlIFF1aW50aWNcbiAgICovXG4gIFF1aW50aWMsXG4gIC8qKlxuICAgKiBAc2VlIFNpbnVzb2lkYWxcbiAgICovXG4gIFNpbnVzb2lkYWwsXG4gIC8qKlxuICAgKiBAc2VlIEV4cG9uZW50aWFsXG4gICAqL1xuICBFeHBvbmVudGlhbCxcbiAgLyoqXG4gICAqIEBzZWUgQ2lyY3VsYXJcbiAgICovXG4gIENpcmN1bGFyLFxuICAvKipcbiAgICogQHNlZSBFbGFzdGljXG4gICAqL1xuICBFbGFzdGljLFxuICAvKipcbiAgICogQHNlZSBCYWNrXG4gICAqL1xuICBCYWNrLFxuICAvKipcbiAgICogQHNlZSBCb3VuY2VcbiAgICovXG4gIEJvdW5jZSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLyoqXG4gICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlXG4gICAqL1xuICBBbmltYXRpb25GZWF0dXJlLFxuICAvKipcbiAgICogQHNlZSBBbmltYXRpb25MYXllclxuICAgKi9cbiAgQW5pbWF0aW9uTGF5ZXIsXG4gIC8qKlxuICAgKiBAc2VlIGNvcmUvU2luZ2xlU3RhdGVcbiAgICovXG4gIFNpbmdsZVN0YXRlLFxuICAvKipcbiAgICogQHNlZSBUcmFuc2l0aW9uU3RhdGVcbiAgICovXG4gIFRyYW5zaXRpb25TdGF0ZSxcbiAgLyoqXG4gICAqIEBzZWUgRnJlZUJsZW5kU3RhdGVcbiAgICovXG4gIEZyZWVCbGVuZFN0YXRlLFxuICAvKipcbiAgICogQHNlZSBRdWV1ZVN0YXRlXG4gICAqL1xuICBRdWV1ZVN0YXRlLFxuICAvKipcbiAgICogQHNlZSBSYW5kb21BbmltYXRpb25TdGF0ZVxuICAgKi9cbiAgUmFuZG9tQW5pbWF0aW9uU3RhdGUsXG4gIC8qKlxuICAgKiBAc2VlIEJsZW5kMWRTdGF0ZVxuICAgKi9cbiAgQmxlbmQxZFN0YXRlLFxuICAvKipcbiAgICogQHNlZSBCbGVuZDJkU3RhdGVcbiAgICovXG4gIEJsZW5kMmRTdGF0ZSxcbiAgLyoqXG4gICAqIEBzZWUgQW5pbWF0aW9uVXRpbHNcbiAgICovXG4gIEFuaW1hdGlvblV0aWxzLFxuXG4gIEVhc2luZyxcbiAgLyoqXG4gICAqIEBzZWUgTGF5ZXJCbGVuZE1vZGVzXG4gICAqL1xuICBMYXllckJsZW5kTW9kZXMsXG4gIC8qKlxuICAgKiBAc2VlIERlZmF1bHRMYXllckJsZW5kTW9kZVxuICAgKi9cbiAgRGVmYXVsdExheWVyQmxlbmRNb2RlLFxuICAvKipcbiAgICogQHNlZSBBbmltYXRpb25UeXBlc1xuICAgKi9cbiAgQW5pbWF0aW9uVHlwZXMsXG59O1xuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcblxuaW1wb3J0IFV0aWxzIGZyb20gJ2NvcmUvVXRpbHMnO1xuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiB1c2VmdWwgdGV4dC10by1zcGVlY2ggZnVuY3Rpb25zLlxuICpcbiAqIEBoaWRlY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgVGV4dFRvU3BlZWNoVXRpbHMge1xuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBzdHJpbmcgd2l0aCBTU01MIG1hcmtzIGluc2VydGVkIGJhc2VkIG9uXG4gICAqIG1hdGNoZXMgYmV0d2VlbiB0aGUgaW5wdXQgc3RyaW5nIGFuZCB0aGUgaW5wdXQgbWFwLiBUaGVcbiAgICogd29yZCBtYXRjaGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlLiBXb3JkcyB3aXRoaW4gZXhpc3RpbmdcbiAgICogU1NNTCB0YWdzIHdpbGwgbm90IGJlIGFmZmVjdGVkLiBJbnB1dCB0ZXh0IHdpbGwgYmUgc3Vycm91bmRlZFxuICAgKiBieSA8c3BlYWs+PC9zcGVhaz4gdGFncyBpZiBuZWVkZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gSW5wdXQgc3RyaW5nLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbWFwIC0gSW5wdXQgb2JqZWN0IHRoYXQgbWFwcyBtYXJrIGtleXNcbiAgICogdG8gYXJyYXlzIG9mIHdvcmRzLiBFeGFtcGxlOlxuICAgKlxuICAgKiAge1xuICAgKiAgICAnbWFyazpzYWQnIDogWydzYWQnLCAnYmx1ZScsICdkb3duJ10sXG4gICAqICAgICdtYXJrOmhhcHB5JyA6IFsnam95JywgJ2dsYWQnLCAnZ3JlYXQnXSxcbiAgICogICAgJ21hcms6bm8nIDogWydubycsICduYWgnLCAnbmF5JywgJ3N1cmUnXVxuICAgKiAgfVxuICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBbcmFuZG9tTWFya3MgPSBbXV0gLSBJZiB0aGVyZSBhcmUgc2VudGVuY2VzIHRoYXQgZG9uJ3RcbiAgICogbWF0Y2ggYW55IHdvcmRzIGZyb20gdGhlIG1hcCBvYmplY3QsIG1hcmtzIGZyb20gdGhpcyBhcnJheSB3aWxsIGJlIHJhbmRvbWx5XG4gICAqIGNob3NlbiBhbmQgaW5zZXJ0ZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVXBkYXRlZCBpbnB1dCBzdHJpbmcuXG4gICAqL1xuICBzdGF0aWMgYXV0b0dlbmVyYXRlU1NNTE1hcmtzKHRleHQsIG1hcCwgcmFuZG9tTWFya3MgPSBbXSkge1xuICAgIGlmICh0eXBlb2YgbWFwICE9PSAnb2JqZWN0JyB8fCBtYXAgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBnZW5lcmF0ZSBTU01MIG1hcmtzIGZvciB0ZXh0IFwiJHt0ZXh0fVwiIGJlY2F1c2UgbWFwIGlzIG5vdCBhbiBvYmplY3QuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBwcm9jZXNzIHRoZSBpbnB1dCBtYXAgaW50byBhbiBpbnRlcm5hbCBmb3JtYXRcbiAgICBjb25zdCBpbnRlcm5hbE1hcCA9IHRoaXMuX3Byb2Nlc3NJbnB1dE1hcChtYXApO1xuXG4gICAgY29uc3Qgc3BlYWtUYWdzID0gWyc8c3BlYWs+JywgJzwvc3BlYWs+J107XG4gICAgY29uc3Qgc3NtbE1hcmtSZWdleCA9IC88bWFyayBuYW1lPSg/OlwifCcpKC4qPykoPzpcInwnKVxcLz4vO1xuICAgIGNvbnN0IHNzbWxUYWdSZWdleCA9IC88W14+XSo+L2c7XG5cbiAgICAvLyBJZGVudGlmeSBhbnkgZXhpc3RpbmcgU1NNTCB0YWdzXG4gICAgY29uc3QgZXhpc3RpbmdUYWdzID0gW107XG4gICAgbGV0IHJlc3VsdCA9IHNzbWxUYWdSZWdleC5leGVjKHRleHQpO1xuXG4gICAgd2hpbGUgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgZXhpc3RpbmdUYWdzLnB1c2goe1xuICAgICAgICBzdGFydDogcmVzdWx0LmluZGV4LFxuICAgICAgICBlbmQ6IHJlc3VsdC5pbmRleCArIHJlc3VsdFswXS5sZW5ndGgsXG4gICAgICAgIHRleHQ6IHJlc3VsdFswXSxcbiAgICAgIH0pO1xuXG4gICAgICByZXN1bHQgPSBzc21sVGFnUmVnZXguZXhlYyh0ZXh0KTtcbiAgICB9XG5cbiAgICBjb25zdCBjaHVua3MgPSBbXTtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGxldCBzc21sTWFya1Jlc3VsdDtcbiAgICBsZXQgZHVwbGljYXRlTWFya1RvQ2hlY2sgPSBbXTtcbiAgICBleGlzdGluZ1RhZ3MuZm9yRWFjaChleGlzdGluZ1RhZyA9PiB7XG4gICAgICBjb25zdCBzdWJzdHIgPSB0ZXh0LnNsaWNlKGluZGV4LCBleGlzdGluZ1RhZy5zdGFydCk7XG5cbiAgICAgIGlmIChzdWJzdHIgIT09ICcnKSB7XG4gICAgICAgIC8vIGF1dG8tbWFyayBub24tdGFnIHRleHRcbiAgICAgICAgY2h1bmtzLnB1c2goXG4gICAgICAgICAgdGhpcy5faW5zZXJ0TWFya3Moc3Vic3RyLCBpbnRlcm5hbE1hcCwgZHVwbGljYXRlTWFya1RvQ2hlY2spXG4gICAgICAgICk7XG5cbiAgICAgICAgZHVwbGljYXRlTWFya1RvQ2hlY2sgPSBbXTtcbiAgICAgIH1cblxuICAgICAgc3NtbE1hcmtSZXN1bHQgPSBzc21sTWFya1JlZ2V4LmV4ZWMoZXhpc3RpbmdUYWcudGV4dCk7XG5cbiAgICAgIGlmIChzc21sTWFya1Jlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBtYXJrVGV4dCA9IHNzbWxNYXJrUmVzdWx0WzFdO1xuICAgICAgICBkdXBsaWNhdGVNYXJrVG9DaGVjay5wdXNoKG1hcmtUZXh0KTtcbiAgICAgIH0gZWxzZSBpZiAoIXNwZWFrVGFncy5pbmNsdWRlcyhleGlzdGluZ1RhZy50ZXh0KSkge1xuICAgICAgICBjaHVua3MucHVzaChleGlzdGluZ1RhZy50ZXh0KTtcbiAgICAgIH1cblxuICAgICAgLy8gYWR2YW5jZSB0aGUgaW5kZXhcbiAgICAgIGluZGV4ID0gZXhpc3RpbmdUYWcuZW5kO1xuICAgIH0pO1xuXG4gICAgY2h1bmtzLnB1c2goXG4gICAgICB0aGlzLl9pbnNlcnRNYXJrcyh0ZXh0LnNsaWNlKGluZGV4KSwgaW50ZXJuYWxNYXAsIGR1cGxpY2F0ZU1hcmtUb0NoZWNrKVxuICAgICk7XG5cbiAgICBsZXQgbWFya2VkVGV4dCA9IGNodW5rcy5qb2luKCcnKTtcblxuICAgIGlmIChyYW5kb21NYXJrcyAmJiByYW5kb21NYXJrcy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBhZGQgcmFuZG9tIG1hcmtzIHRvIGFueSB1bm1hcmtlZCBzZW50ZW5jZXNcbiAgICAgIG1hcmtlZFRleHQgPSB0aGlzLmFkZE1hcmtzVG9Vbm1hcmtlZFNlbnRlbmNlcyhtYXJrZWRUZXh0LCByYW5kb21NYXJrcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFRleHRUb1NwZWVjaFV0aWxzLnZhbGlkYXRlVGV4dChtYXJrZWRUZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IHN0cmluZyB3aXRoIGEgcmFuZG9tIFNTTUwgbWFyayBpbnNlcnRlZCBhdCBlYWNoIHNlbnRlbmNlIHRoYXRcbiAgICogZG9lcyBub3QgYWxyZWFkeSBjb250YWluIGFuIFNTTUwgbWFyay5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBJbnB1dCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IG1hcmtzIC0gQW55IGFycmF5IG9mIHJhbmRvbSBTU01MIG1hcmtzIHRvIGNob29zZSBmcm9tXG4gICAqIHdoZW4gbW9kaWZ5aW5nIHRoZSB0ZXh0LlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGFkZE1hcmtzVG9Vbm1hcmtlZFNlbnRlbmNlcyh0ZXh0LCBtYXJrcykge1xuICAgIGlmICghbWFya3MgfHwgbWFya3MubGVuZ3RoID09PSAwKSByZXR1cm4gdGV4dDtcblxuICAgIGNvbnN0IHNzbWxNYXJrUmVnZXggPSAvPG1hcmsgbmFtZT0oPzpcInwnKSguKj8pKD86XCJ8JylcXC8+L2c7XG4gICAgY29uc3Qgc3NtbFRhZ1JlZ2V4ID0gLzxbXj5dKj4vZztcblxuICAgIC8vIEZpbmQgdGhlIGluZGljZXMgb2YgYW55IG1hcmtzIGluIHRoZSB0ZXh0XG4gICAgY29uc3QgbWFya0luZGljZXMgPSBbXTtcbiAgICBsZXQgbWFya1Jlc3VsdCA9IHNzbWxNYXJrUmVnZXguZXhlYyh0ZXh0KTtcblxuICAgIHdoaWxlIChtYXJrUmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICBtYXJrSW5kaWNlcy5wdXNoKG1hcmtSZXN1bHQuaW5kZXgpO1xuICAgICAgbWFya1Jlc3VsdCA9IHNzbWxNYXJrUmVnZXguZXhlYyh0ZXh0KTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIGFsbCBTU01MIHRhZ3MgaW4gdGhlIHRleHRcbiAgICBjb25zdCBleGlzdGluZ1RhZ3MgPSBbXTtcbiAgICBsZXQgc3NtbFJlc3VsdCA9IHNzbWxUYWdSZWdleC5leGVjKHRleHQpO1xuICAgIHdoaWxlIChzc21sUmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICBleGlzdGluZ1RhZ3MucHVzaCh7XG4gICAgICAgIHN0YXJ0OiBzc21sUmVzdWx0LmluZGV4LFxuICAgICAgICBlbmQ6IHNzbWxSZXN1bHQuaW5kZXggKyBzc21sUmVzdWx0WzBdLmxlbmd0aCxcbiAgICAgICAgdGV4dDogc3NtbFJlc3VsdFswXSxcbiAgICAgIH0pO1xuICAgICAgc3NtbFJlc3VsdCA9IHNzbWxUYWdSZWdleC5leGVjKHRleHQpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIGNvcHkgb2YgdGhlIHRleHQgd2l0aCBhbGwgU1NNTCBtYXJrcyByZXBsYWNlcyB3aXRoIHdoaXRlc3BhY2VcbiAgICBsZXQgY2xlYW5lZFRleHQgPSB0ZXh0LnNsaWNlKCk7XG4gICAgZXhpc3RpbmdUYWdzLmZvckVhY2goZXhpc3RpbmdTc21sID0+IHtcbiAgICAgIGNvbnN0IHdoaXRlc3BhY2UgPSBuZXcgQXJyYXkoZXhpc3RpbmdTc21sLnRleHQubGVuZ3RoICsgMSkuam9pbignICcpO1xuICAgICAgY2xlYW5lZFRleHQgPSBbXG4gICAgICAgIGNsZWFuZWRUZXh0LnNsaWNlKDAsIGV4aXN0aW5nU3NtbC5zdGFydCksXG4gICAgICAgIHdoaXRlc3BhY2UsXG4gICAgICAgIGNsZWFuZWRUZXh0LnNsaWNlKGV4aXN0aW5nU3NtbC5lbmQpLFxuICAgICAgXS5qb2luKCcnKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHNlbnRlbmNlRW5kSW5kaWNlcyA9IHRoaXMuX2dldFNlbnRlbmNlRW5kcyhjbGVhbmVkVGV4dCk7XG5cbiAgICAvLyBPbmx5IGluc2VydCByYW5kb20gbWFya3MgaW50byBzZW50ZW5jZXMgdGhhdCBkb24ndCBhbHJlYWR5IGhhdmUgYW55XG4gICAgbGV0IHByZXZJbmRleCA9IDA7XG4gICAgY29uc3QgdGFyZ2V0SW5kaWNlcyA9IHNlbnRlbmNlRW5kSW5kaWNlcy5maWx0ZXIoaW5kZXggPT4ge1xuICAgICAgY29uc3QgY29udGFpbnNNYXJrID1cbiAgICAgICAgbWFya0luZGljZXMuZmluZEluZGV4KG1hcmtJbmRleCA9PiB7XG4gICAgICAgICAgcmV0dXJuIHByZXZJbmRleCA8PSBtYXJrSW5kZXggJiYgaW5kZXggPiBtYXJrSW5kZXg7XG4gICAgICAgIH0pICE9PSAtMTtcbiAgICAgIHByZXZJbmRleCA9IGluZGV4O1xuICAgICAgcmV0dXJuICFjb250YWluc01hcms7XG4gICAgfSk7XG5cbiAgICBjb25zdCByYW5kb21NYXJrZWRUZXh0ID0gdGhpcy5faW5zZXJ0UmFuZG9tTWFya3NBdChcbiAgICAgIHRleHQsXG4gICAgICB0YXJnZXRJbmRpY2VzLFxuICAgICAgbWFya3NcbiAgICApO1xuXG4gICAgcmV0dXJuIHJhbmRvbU1hcmtlZFRleHQ7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB2ZXJzaW9uIG9mIGdpdmVuIHRleHQgdGhhdCBpcyBlbmNsb3NlZCBieSBQb2xseSBzc21sIHNwZWFrIHRhZ3MuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgdG8gdmFsaWRhdGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVXBkYXRlZCBpbnB1dCBzdHJpbmcuXG4gICAqL1xuICBzdGF0aWMgdmFsaWRhdGVUZXh0KHRleHQpIHtcbiAgICBpZiAoIXRleHQpIHtcbiAgICAgIHRleHQgPSAnPHNwZWFrPjwvc3BlYWs+JztcbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dCA9IHRleHRcbiAgICAgICAgLnJlcGxhY2UoLyheXFxzKjxcXHMqc3BlYWtcXHMqKT5cXHMqfCheXFxzKikvLCAnPHNwZWFrPicpXG4gICAgICAgIC5yZXBsYWNlKC8oXFxzKjxcXHMqXFwvXFxzKnNwZWFrXFxzKj5cXHMqJHxcXHMqJCkvLCAnPC9zcGVhaz4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhbiBpbnB1dCBzdHJpbmcgYW5kIGluc2VydCBTU01MIG1hcmtzIGJhc2VkIG9uXG4gICAqIHdvcmQgbWF0Y2hlcyBpbiBhIG1hcC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBJbnB1dCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtpbmRpY2VzID0gW11dIC0gQW4gYXJyYXkgb2YgaW5kaWNlcyBpbiB0aGUgdGV4dCBpbnB1dFxuICAgKiB3aGVyZSByYW5kb20gbWFya3Mgc2hvdWxkIGJlIGluc2VydGVkLlxuICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBbbWFya3MgPSBbXV0gLSBBbiBhcnJheSBvZiBtYXJrIHN0cmluZ3MgdG8gY2hvb3NlXG4gICAqIGZyb20gd2hlbiBpbnNlcnRpbmcgcmFuZG9tIG1hcmtzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIFVwZGF0ZWQgaW5wdXQgc3RyaW5nLlxuICAgKi9cbiAgc3RhdGljIF9pbnNlcnRSYW5kb21NYXJrc0F0KHRleHQsIGluZGljZXMgPSBbXSwgbWFya3MgPSBbXSkge1xuICAgIGlmICghbWFya3MgfHwgbWFya3MubGVuZ3RoID09PSAwIHx8ICFpbmRpY2VzIHx8IGluZGljZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG5cbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBpbmRpY2VzLmZvckVhY2goaW5kZXggPT4ge1xuICAgICAgY29uc3QgcmFuZG9tTWFyayA9IGA8bWFyayBuYW1lPScke1xuICAgICAgICBtYXJrc1tVdGlscy5nZXRSYW5kb21JbnQoMCwgbWFya3MubGVuZ3RoKV1cbiAgICAgIH0nLz5gO1xuICAgICAgdGV4dCA9IFtcbiAgICAgICAgdGV4dC5zbGljZSgwLCBpbmRleCArIG9mZnNldCksXG4gICAgICAgIHJhbmRvbU1hcmssXG4gICAgICAgIHRleHQuc2xpY2UoaW5kZXggKyBvZmZzZXQpLFxuICAgICAgXS5qb2luKCcnKTtcbiAgICAgIG9mZnNldCArPSByYW5kb21NYXJrLmxlbmd0aDtcbiAgICB9KTtcblxuICAgIHJldHVybiB0ZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhIHN0cmluZyBvZiB0ZXh0IGFuZCByZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGluZGljZXNcbiAgICogb2YgdGhlIGxhc3QgY2hhcmFjdGVyIGluIGEgc2VudGVuY2UgdGhhdCBpcyBub3QgaW4gdGhlIGZvbGxvd2luZyBsaXN0OlxuICAgKiAgKCcuJywgJz8nLCAnIScpXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gVGV4dCB0byBwcm9jZXNzIGZvciBlbmQgb2Ygc2VudGVuY2VcbiAgICogaW5kaWNlcy5cbiAgICpcbiAgICogQHJldHVybnMge0FycmF5LjxudW1iZXI+fSAtIEFycmF5IG9mIGVuZCBvZiBzZW50ZW5jZSBpbmRpY2VzLlxuICAgKi9cbiAgc3RhdGljIF9nZXRTZW50ZW5jZUVuZHModGV4dCkge1xuICAgIGNvbnN0IHNlbnRlbmNlUmVnZXggPSAvW14uIT9dK1suIT9dKy9nO1xuICAgIGNvbnN0IGVuZFNlbnRlbmNlUmVnZXggPSAvWy4hP10rLztcblxuICAgIGxldCByZXN1bHQgPSBzZW50ZW5jZVJlZ2V4LmV4ZWModGV4dCk7XG4gICAgY29uc3Qgc2VudGVuY2VFbmRzID0gW107XG4gICAgd2hpbGUgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgLy8gZmluZCB0aGUgbGFzdCBub24tcHVuY3R1YXRpb24gY2hhcmFjdGVyXG4gICAgICBjb25zdCBwdW5jdFJlc3VsdCA9IGVuZFNlbnRlbmNlUmVnZXguZXhlYyhyZXN1bHRbMF0pO1xuICAgICAgc2VudGVuY2VFbmRzLnB1c2goXG4gICAgICAgIHJlc3VsdC5pbmRleCArIHJlc3VsdFswXS5sZW5ndGggLSBwdW5jdFJlc3VsdFswXS5sZW5ndGhcbiAgICAgICk7XG4gICAgICByZXN1bHQgPSBzZW50ZW5jZVJlZ2V4LmV4ZWModGV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbnRlbmNlRW5kcztcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhbiBpbnB1dCBzdHJpbmcgYW5kIGluc2VydCBTU01MIG1hcmtzIGJhc2VkIG9uXG4gICAqIHdvcmQgbWF0Y2hlcyBpbiBhIG1hcC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBJbnB1dCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7TWFwfSBtYXAgLSBNYXBwaW5nIG9mIHdvcmRzIHRvIG1hcmsgdmFsdWVzIHRoYXRcbiAgICogd2lsbCBiZSBpbnNlcnRlZCBhcyB0aGUgdmFsdWUgZm9yIGEgbWFyaydzICduYW1lJyBhdHRyaWJ1dGUuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGR1cGxpY2F0ZXNUb0NoZWNrIC0gQSBsaXN0IG9mIG1hcmsgdmFsdWVzIHRvIGNoZWNrIGZvciBkdXBsaWNhdGUgYWdhaW5zdCB0aGUgZmlyc3Qgd29yZFxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIFVwZGF0ZWQgaW5wdXQgc3RyaW5nLlxuICAgKi9cbiAgc3RhdGljIF9pbnNlcnRNYXJrcyh0ZXh0LCBtYXAsIGR1cGxpY2F0ZXNUb0NoZWNrKSB7XG4gICAgaWYgKHRleHQgPT09ICcnKSByZXR1cm4gdGV4dDtcblxuICAgIGNvbnN0IHdvcmRSZWdleCA9IC9cXHcrfFxccyt8W15cXHNcXHddKy9nO1xuXG4gICAgbGV0IGxvd2VyQ2FzZVdvcmQ7XG4gICAgbGV0IGNoZWNrRHVwbGljYXRlID0gdHJ1ZTtcbiAgICBjb25zdCBtYXJrZWRXb3JkcyA9IHRleHQubWF0Y2god29yZFJlZ2V4KS5tYXAod29yZCA9PiB7XG4gICAgICBsb3dlckNhc2VXb3JkID0gd29yZC50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICBpZiAobWFwLmhhcyhsb3dlckNhc2VXb3JkKSkge1xuICAgICAgICBjb25zdCBtYXJrcyA9IG1hcC5nZXQobG93ZXJDYXNlV29yZCkubWFwKG1hcmsgPT4ge1xuICAgICAgICAgIGlmIChjaGVja0R1cGxpY2F0ZSkge1xuICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBkdXBsaWNhdGVzVG9DaGVjay5pbmNsdWRlcyhtYXJrKVxuICAgICAgICAgICAgICA/ICcnXG4gICAgICAgICAgICAgIDogYDxtYXJrIG5hbWU9JyR7bWFya30nLz5gO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYDxtYXJrIG5hbWU9JyR7bWFya30nLz5gO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBgJHttYXJrcy5qb2luKCcnKX0ke3dvcmR9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoZWNrRHVwbGljYXRlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB3b3JkO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgZXhpc3RpbmdNYXJrcyA9IGR1cGxpY2F0ZXNUb0NoZWNrLm1hcChtYXJrID0+IHtcbiAgICAgIHJldHVybiBgPG1hcmsgbmFtZT0nJHttYXJrfScvPmA7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYCR7ZXhpc3RpbmdNYXJrcy5qb2luKCcnKX0ke21hcmtlZFdvcmRzLmpvaW4oJycpfWA7XG4gIH1cblxuICAvKipcbiAgICogUHJvY2Vzc2VzIGFuIGlucHV0IG9iamVjdCBmb3IgbWFwcGluZyBhbiBhcnJheVxuICAgKiBvZiB3b3JkcyB0byBzcGVjaWZpYyBtYXJrIGtleXMuIENvbnZlcnRzIHRoZSBpbnB1dFxuICAgKiBtYXAgaW50byBhIE1hcCB3aXRoIGEgbW9yZSBlZmZpY2llbnQgZm9ybWF0IGZvclxuICAgKiBwZXJmb3JtaW5nIG1hcmsgaW5qZWN0aW9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbWFwIC0gSW5wdXQgb2JqZWN0IHRoYXQgbWFwcyBtYXJrIGtleXNcbiAgICogdG8gYXJyYXlzIG9mIHdvcmRzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7TWFwfSAtIE1hcCBmb3IgaW50ZXJuYWwgdXNlLlxuICAgKi9cbiAgc3RhdGljIF9wcm9jZXNzSW5wdXRNYXAobWFwKSB7XG4gICAgY29uc3QgaW50ZXJuYWxNYXAgPSBuZXcgTWFwKCk7XG5cbiAgICBsZXQgbGlzdCA9IFtdO1xuICAgIE9iamVjdC5lbnRyaWVzKG1hcCkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQ2Fubm90IGdlbmVyYXRlIFNTTUwgbWFya3MgZnJvbSBtYXAgXCIke21hcH1cIiBiZWNhdXNlIHZhbHVlIGZvciBrZXkgJyR7a2V5fScgaXMgbm90IGFuIGFycmF5LmBcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdmFsdWUuZm9yRWFjaCh3b3JkID0+IHtcbiAgICAgICAgY29uc3QgbG93ZXJDYXNlV29yZCA9IHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbGlzdCA9IGludGVybmFsTWFwLmdldChsb3dlckNhc2VXb3JkKTtcblxuICAgICAgICBpZiAobGlzdCAhPT0gdW5kZWZpbmVkICYmICFsaXN0LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICBpbnRlcm5hbE1hcC5zZXQobG93ZXJDYXNlV29yZCwgWy4uLmxpc3QsIGtleV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGludGVybmFsTWFwLnNldChsb3dlckNhc2VXb3JkLCBba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGludGVybmFsTWFwO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRleHRUb1NwZWVjaFV0aWxzO1xuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcbmltcG9ydCBEZWZlcnJlZCBmcm9tICdjb3JlL0RlZmVycmVkJztcblxuLyoqXG4gKiBDbGFzcyB0aGF0IGNhbiBwbGF5IGJhY2sgYXVkaW8gZ2VuZXJhdGVkIGJ5IEFXUyBQb2xseSBhbmQgc3luY2hyb25pemVkIGVtaXRcbiAqIHNwZWVjaG1hcmsgbWVzc2FnZXMuXG4gKlxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIEFic3RyYWN0U3BlZWNoIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0ge2NvcmUvVGV4dFRvU3BlZWNoRmVhdHVyZX0gc3BlYWtlciAtIFRoZSBmZWF0dXJlIHRoYXQgb3ducyB0aGUgU3BlZWNoIGFuZFxuICAgKiB3aWxsIGVtaXQgc3BlZWNobWFyayBtZXNzYWdlcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCBvZiB0aGUgc3BlZWNoLlxuICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBbc3BlZWNobWFya3M9W11dIC0gQW4gYXJyYXkgb2Ygc3BlZWNobWFyayBvYmplY3RzIHJlcHJlc2VudGluZ1xuICAgKiB0aGUgdGV4dCBhbmQgdGltaW5nIG9mIHRoZSBzcGVlY2guXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzcGVha2VyLCB0ZXh0LCBzcGVlY2htYXJrcyA9IFtdKSB7XG4gICAgdGhpcy5fc3BlYWtlciA9IHNwZWFrZXI7XG4gICAgdGhpcy5fdGV4dCA9IHRleHQ7XG4gICAgdGhpcy5fc3BlZWNobWFya3MgPSBzcGVlY2htYXJrcztcbiAgICB0aGlzLl9zcGVlY2htYXJrT2Zmc2V0ID0gMDtcbiAgICB0aGlzLl9yZXNldCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IHRyYWNraW5nIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbY3VycmVudFRpbWU9MF0gLSBUaW1lIHRvIHVzZSBmb3IgX3N0YXJ0VGltZS5cbiAgICovXG4gIF9yZXNldChjdXJyZW50VGltZSA9IDApIHtcbiAgICB0aGlzLl9zdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB0aGlzLl9sb2NhbFRpbWUgPSAwO1xuICAgIHRoaXMuX3BhdXNlVGltZSA9IDA7XG4gICAgdGhpcy5fcGxheWluZyA9IGZhbHNlO1xuICAgIHRoaXMuX21hcmtJdGVyID0gdGhpcy5fc3BlZWNobWFya3MudmFsdWVzKCk7XG4gICAgY29uc3Qge3ZhbHVlLCBkb25lfSA9IHRoaXMuX21hcmtJdGVyLm5leHQoKTtcbiAgICB0aGlzLl9jdXJyZW50TWFyayA9IHZhbHVlO1xuICAgIHRoaXMuX2VuZFRpbWUgPSB0aGlzLl9zcGVlY2htYXJrcy5sZW5ndGhcbiAgICAgID8gdGhpcy5fc3BlZWNobWFya3NbdGhpcy5fc3BlZWNobWFya3MubGVuZ3RoIC0gMV0udGltZVxuICAgICAgOiAwO1xuICAgIHRoaXMuX2RvbmUgPSBkb25lO1xuICAgIHRoaXMuX3Byb21pc2UgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBwcm9taXNlIHRoYXQgd2lsbCBzdG9wIHBsYXliYWNrIGFuZCBlbWl0IG1lc3NhZ2VzIGZvciB0aGlzIHNwZWVjaC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uRmluaXNoIC0gRnVuY2l0b24gdG8gZXhlY3V0ZSBvbmNlIHRoZSBzcGVlY2ggc3RvcHMuXG4gICAqIEBwYXJhbSB7b25FcnJvcj19IG9uRXJyb3IgLSBGdW5jdGlvbiB0byBleGVjdXRlIGlmIHRoZSBzcGVlY2ggZW5jb3VudGVycyBhblxuICAgKiBlcnJvci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uSW50ZXJydXB0IC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBpZiB0aGUgc3BlZWNoIGlzIGNhbmNlbGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3JlYXRlUHJvbWlzZShvbkZpbmlzaCwgb25FcnJvciwgb25JbnRlcnJ1cHQpIHtcbiAgICBjb25zdCBvblJlc29sdmUgPSB2YWx1ZSA9PiB7XG4gICAgICB0aGlzLl9wbGF5aW5nID0gZmFsc2U7XG5cbiAgICAgIHRoaXMuX3NwZWFrZXIuZW1pdCh0aGlzLl9zcGVha2VyLmNvbnN0cnVjdG9yLkVWRU5UUy5zdG9wLCB0aGlzKTtcbiAgICAgIHRoaXMuX3NwZWFrZXIuY29uc3RydWN0b3IuZW1pdChcbiAgICAgICAgdGhpcy5fc3BlYWtlci5jb25zdHJ1Y3Rvci5FVkVOVFMuc3RvcCxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcblxuICAgICAgaWYgKHR5cGVvZiBvbkZpbmlzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvbkZpbmlzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IG9uUmVqZWN0ID0gZSA9PiB7XG4gICAgICB0aGlzLl9wbGF5aW5nID0gZmFsc2U7XG5cbiAgICAgIHRoaXMuX3NwZWFrZXIuZW1pdCh0aGlzLl9zcGVha2VyLmNvbnN0cnVjdG9yLkVWRU5UUy5zdG9wLCB0aGlzKTtcbiAgICAgIHRoaXMuX3NwZWFrZXIuY29uc3RydWN0b3IuZW1pdChcbiAgICAgICAgdGhpcy5fc3BlYWtlci5jb25zdHJ1Y3Rvci5FVkVOVFMuc3RvcCxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcblxuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSBlbmNvdW50ZXJlZCBhbiB1bmV4cGVjdGVkIGVycm9yOiAke2V9YFxuICAgICAgKTtcblxuICAgICAgaWYgKHR5cGVvZiBvbkVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9uRXJyb3IoZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IG9uQ2FuY2VsID0gdmFsdWUgPT4ge1xuICAgICAgdGhpcy5fcGxheWluZyA9IGZhbHNlO1xuXG4gICAgICB0aGlzLl9zcGVha2VyLmVtaXQodGhpcy5fc3BlYWtlci5jb25zdHJ1Y3Rvci5FVkVOVFMuaW50ZXJydXB0LCB0aGlzKTtcbiAgICAgIHRoaXMuX3NwZWFrZXIuY29uc3RydWN0b3IuZW1pdChcbiAgICAgICAgdGhpcy5fc3BlYWtlci5jb25zdHJ1Y3Rvci5FVkVOVFMuaW50ZXJydXB0LFxuICAgICAgICB0aGlzXG4gICAgICApO1xuXG4gICAgICBpZiAodHlwZW9mIG9uSW50ZXJydXB0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9uSW50ZXJydXB0KHZhbHVlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5fcHJvbWlzZSA9IG5ldyBEZWZlcnJlZCh1bmRlZmluZWQsIG9uUmVzb2x2ZSwgb25SZWplY3QsIG9uQ2FuY2VsKTtcblxuICAgIHJldHVybiB0aGlzLl9wcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIG9yIG5vdCB0aGUgc3BlZWNoIGhhcyByZWFjaGVkIGl0J3MgZW5kLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIF9jaGVja0ZpbmlzaGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9kb25lICYmIHRoaXMuX2xvY2FsVGltZSA+PSB0aGlzLl9lbmRUaW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHBsYXliYWNrIHN0YXRlIG9mIHRoZSBhdWRpby5cbiAgICpcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IHBsYXlpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsYXlpbmc7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdGV4dCBvZiB0aGUgc3BlZWNoLlxuICAgKlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCB0ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLl90ZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYSBzaGFsbG93IGNvcHkgb2YgdGhlIHNwZWVjaG1hcmtzIGFycmF5IGZvciB0aGUgc3BlZWNoLlxuICAgKlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxuICAgKi9cbiAgZ2V0IHNwZWVjaG1hcmtzKCkge1xuICAgIHJldHVybiBbLi4udGhpcy5fc3BlZWNobWFya3NdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW5kIHNldHMgdGhlIG51bWJlciBvZiBzZWNvbmRzIHRvIG9mZnNldCBzcGVlY2htYXJrIGVtaXNzaW9uLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHNwZWVjaG1hcmtPZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NwZWVjaG1hcmtPZmZzZXQgLyAxMDAwO1xuICB9XG5cbiAgc2V0IHNwZWVjaG1hcmtPZmZzZXQob2Zmc2V0KSB7XG4gICAgdGhpcy5fc3BlZWNobWFya09mZnNldCA9IG9mZnNldCAqIDEwMDA7IC8vIFN0b3JlIGFzIG1pbGxpc2Vjb25kc1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXQgc3BlZWNobWFyayBtZXNzYWdlcyBhcyB0aGV5IGFyZSBlbmNvdW50ZXJlZCBpbiBzeW5jIHdpdGggYXVkaW8uXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50VGltZSAtIEN1cnJlbnQgZ2xvYmFsIHRpbWUgd2hlbiB1cGRhdGUgd2FzIGNhbGxlZC5cbiAgICovXG4gIHVwZGF0ZShjdXJyZW50VGltZSkge1xuICAgIGlmICghdGhpcy5fcGxheWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBsb2NhbCBhdWRpbyB0aW1lXG4gICAgdGhpcy5fbG9jYWxUaW1lID0gY3VycmVudFRpbWUgLSB0aGlzLl9zdGFydFRpbWU7XG5cbiAgICBpZiAoIXRoaXMuX2RvbmUpIHtcbiAgICAgIC8vIEVtaXQgc3BlZWNobWFyayBtZXNzYWdlcyBmb3IgbWFya3MgdXAgdG8gdGhlIGN1cnJlbnQgdGltZVxuICAgICAgd2hpbGUgKFxuICAgICAgICAhdGhpcy5fZG9uZSAmJlxuICAgICAgICB0aGlzLl9jdXJyZW50TWFyay50aW1lICsgdGhpcy5fc3BlZWNobWFya09mZnNldCA8PSB0aGlzLl9sb2NhbFRpbWVcbiAgICAgICkge1xuICAgICAgICB0aGlzLl9zcGVha2VyLmVtaXQoXG4gICAgICAgICAgdGhpcy5fc3BlYWtlci5jb25zdHJ1Y3Rvci5FVkVOVFNbdGhpcy5fY3VycmVudE1hcmsudHlwZV0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3BlZWNoOiB0aGlzLFxuICAgICAgICAgICAgbWFyazogdGhpcy5fY3VycmVudE1hcmssXG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICBjb25zdCB7dmFsdWUsIGRvbmV9ID0gdGhpcy5fbWFya0l0ZXIubmV4dCgpO1xuXG4gICAgICAgIHRoaXMuX2N1cnJlbnRNYXJrID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX2RvbmUgPSBkb25lO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEVuZCBwbGF5YmFja1xuICAgIGlmICh0aGlzLl9jaGVja0ZpbmlzaGVkKCkpIHtcbiAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGxheSB0aGUgc3BlZWNoIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnRUaW1lIC0gQ3VycmVudCBnbG9iYWwgdGltZSB3aGVuIHBsYXkgd2FzIGNhbGxlZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uRmluaXNoIC0gT3B0aW9uYWwgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbmNlIHRoZSBzcGVlY2hcbiAgICogcHJvbWlzZSByZXNvbHZlcy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uRXJyb3IgLSBPcHRpb25hbCBmdW5jdGlvbiB0byBleGVjdXRlIGlmIHRoZSBzcGVlY2hcbiAgICogZW5jb3VudGVycyBhbmQgZXJyb3IgZHVyaW5nIHBsYXliYWNrLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25JbnRlcnJ1cHQgLSBPcHRpb25hbCBmdW5jdGlvbiB0byBleGVjdXRlIGlmIHRoZSBzcGVlY2hcbiAgICogaXMgY2FuY2VsZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH0gUmVzb2x2ZXMgb25jZSB0aGUgc3BlZWNoIHJlYWNoZXMgdGhlIGVuZCBvZiBwbGF5YmFjay5cbiAgICovXG4gIHBsYXkoY3VycmVudFRpbWUsIG9uRmluaXNoLCBvbkVycm9yLCBvbkludGVycnVwdCkge1xuICAgIHRoaXMuX3Jlc2V0KGN1cnJlbnRUaW1lKTtcbiAgICB0aGlzLl9wbGF5aW5nID0gdHJ1ZTtcblxuICAgIHRoaXMuX3NwZWFrZXIuZW1pdCh0aGlzLl9zcGVha2VyLmNvbnN0cnVjdG9yLkVWRU5UUy5wbGF5LCB0aGlzKTtcbiAgICB0aGlzLl9zcGVha2VyLmNvbnN0cnVjdG9yLmVtaXQodGhpcy5fc3BlYWtlci5jb25zdHJ1Y3Rvci5FVkVOVFMucGxheSwgdGhpcyk7XG5cbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlUHJvbWlzZShvbkZpbmlzaCwgb25FcnJvciwgb25JbnRlcnJ1cHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdXNlIHRoZSBzcGVlY2ggYXQgdGhlIGN1cnJlbnQgdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnRUaW1lIC0gQ3VycmVudCBnbG9iYWwgdGltZSB3aGVuIHBhdXNlIHdhcyBjYWxsZWQuXG4gICAqL1xuICBwYXVzZShjdXJyZW50VGltZSkge1xuICAgIHRoaXMuX3BsYXlpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9wYXVzZVRpbWUgPSBjdXJyZW50VGltZTtcblxuICAgIHRoaXMuX3NwZWFrZXIuZW1pdCh0aGlzLl9zcGVha2VyLmNvbnN0cnVjdG9yLkVWRU5UUy5wYXVzZSwgdGhpcyk7XG4gICAgdGhpcy5fc3BlYWtlci5jb25zdHJ1Y3Rvci5lbWl0KFxuICAgICAgdGhpcy5fc3BlYWtlci5jb25zdHJ1Y3Rvci5FVkVOVFMucGF1c2UsXG4gICAgICB0aGlzXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN1bWUgdGhlIHNwZWVjaCBhdCB0aGUgY3VycmVudCB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY3VycmVudFRpbWUgLSBDdXJyZW50IGdsb2JhbCB0aW1lIHdoZW4gcmVzdW1lIHdhcyBjYWxsZWQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkZpbmlzaCAtIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb25jZSB0aGUgc3BlZWNoXG4gICAqIHByb21pc2UgcmVzb2x2ZXMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkVycm9yIC0gT3B0aW9uYWwgZnVuY3Rpb24gdG8gZXhlY3V0ZSBpZiB0aGUgc3BlZWNoXG4gICAqIGVuY291bnRlcnMgYW5kIGVycm9yIGR1cmluZyBwbGF5YmFjay5cbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uSW50ZXJydXB0IC0gT3B0aW9uYWwgZnVuY3Rpb24gdG8gZXhlY3V0ZSBpZiB0aGUgc3BlZWNoXG4gICAqIGlzIGNhbmNlbGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9IFJlc29sdmVzIG9uY2UgdGhlIHNwZWVjaCByZWFjaGVzIHRoZSBlbmQgb2YgcGxheWJhY2suXG4gICAqL1xuICByZXN1bWUoY3VycmVudFRpbWUsIG9uRmluaXNoLCBvbkVycm9yLCBvbkludGVycnVwdCkge1xuICAgIC8vIFBsYXkgZnJvbSB0aGUgYmVnaW5uaW5nIGlmIHRoZSBzcGVlY2ggaGFzbid0IHBsYXllZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3Byb21pc2UpIHtcbiAgICAgIHRoaXMuX3Jlc2V0KGN1cnJlbnRUaW1lKTtcbiAgICAgIHRoaXMuX2NyZWF0ZVByb21pc2Uob25GaW5pc2gsIG9uRXJyb3IsIG9uSW50ZXJydXB0KTtcbiAgICB9XG5cbiAgICB0aGlzLl9wbGF5aW5nID0gdHJ1ZTtcbiAgICB0aGlzLl9zdGFydFRpbWUgKz0gY3VycmVudFRpbWUgLSB0aGlzLl9wYXVzZVRpbWU7XG5cbiAgICB0aGlzLl9zcGVha2VyLmVtaXQodGhpcy5fc3BlYWtlci5jb25zdHJ1Y3Rvci5FVkVOVFMucmVzdW1lLCB0aGlzKTtcbiAgICB0aGlzLl9zcGVha2VyLmNvbnN0cnVjdG9yLmVtaXQoXG4gICAgICB0aGlzLl9zcGVha2VyLmNvbnN0cnVjdG9yLkVWRU5UUy5yZXN1bWUsXG4gICAgICB0aGlzXG4gICAgKTtcblxuICAgIHJldHVybiB0aGlzLl9wcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbHMgcGxheWJhY2sgb2YgdGhlIHNwZWVjaCBhdCB0aGUgY3VycmVudCB0aW1lLiBDYW5jZWwgdGhlIHNwZWVjaCBwcm9taXNlLlxuICAgKi9cbiAgY2FuY2VsKCkge1xuICAgIGlmICh0aGlzLl9wcm9taXNlKSB7XG4gICAgICB0aGlzLl9wcm9taXNlLmNhbmNlbCgpO1xuICAgICAgdGhpcy5fcHJvbWlzZSA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5fcGxheWluZyA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgdGhlIHNwZWVjaCBhbmQgcmVzZXQgdGltZSB0byB0aGUgYmVnaW5uaW5nLiBSZXNvbHZlIHRoZSBzcGVlY2ggcHJvbWlzZS5cbiAgICovXG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMuX3Byb21pc2UpIHtcbiAgICAgIHRoaXMuX3Byb21pc2UucmVzb2x2ZSgpO1xuICAgICAgdGhpcy5fcHJvbWlzZSA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5fcGxheWluZyA9IGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEFic3RyYWN0U3BlZWNoO1xuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcbmltcG9ydCBBYnN0cmFjdFNwZWVjaCBmcm9tICcuL0Fic3RyYWN0U3BlZWNoJztcblxuLyoqXG4gKiBUaGUgYnVpbHQtaW4gY2xhc3MgZm9yIGFzeW5jaHJvbm91cyBQcm9taXNlcy5cbiAqIEBleHRlcm5hbCBBdWRpb1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTEF1ZGlvRWxlbWVudC9BdWRpb1xuICovXG5cbi8qKlxuICogQGV4dGVuZHMgQWJzdHJhY3RTcGVlY2hcbiAqIEBhbGlhcyBjb3JlL1NwZWVjaFxuICovXG5jbGFzcyBTcGVlY2ggZXh0ZW5kcyBBYnN0cmFjdFNwZWVjaCB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VG9TcGVlY2h9IHNwZWFrZXIgLSBUaGUgb3duZXIgb2YgdGhlIFNwZWVjaCB0aGF0IHdpbGwgZW1pdCBzcGVlY2htYXJrXG4gICAqIG1lc3NhZ2VzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIFRoZSB0ZXh0IG9mIHRoZSBzcGVlY2guXG4gICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IFtzcGVlY2htYXJrcz1bXV0gLSBBbiBhcnJheSBvZiBzcGVlY2htYXJrIG9iamVjdHMgcmVwcmVzZW50aW5nXG4gICAqIHRoZSB0ZXh0IGFuZCB0aW1pbmcgb2YgdGhlIHNwZWVjaC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGF1ZGlvQ29uZmlnIC0gT2JqZWN0IGNvbnRhaW5pbmcgYXVkaW8gYW5kIHVybC5cbiAgICogQHBhcmFtIHtleHRlcm5hbDpBdWRpb30gYXVkaW9Db25maWcuYXVkaW8gLSBQbGF5YWJsZSBhdWRpbyBvYmplY3QuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzcGVha2VyLCB0ZXh0LCBzcGVlY2htYXJrcyA9IFtdLCBhdWRpb0NvbmZpZykge1xuICAgIHN1cGVyKHNwZWFrZXIsIHRleHQsIHNwZWVjaG1hcmtzKTtcbiAgICB0aGlzLl9hdWRpbyA9IGF1ZGlvQ29uZmlnLmF1ZGlvO1xuXG4gICAgLy8gS2VlcCB0cmFjayBvZiB3aGV0aGVyIHRoZSBhdWRpbyBoYXMgZmluaXNoZWQgcGxheWluZyB0aHJvdWdoXG4gICAgdGhpcy5fYXVkaW8ub25lbmRlZCA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2F1ZGlvRmluaXNoZWQgPSB0cnVlO1xuICAgIH07XG4gICAgdGhpcy5fYXVkaW9GaW5pc2hlZCA9IHRydWU7XG4gIH1cblxuICBfY2hlY2tGaW5pc2hlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXVkaW9GaW5pc2hlZCAmJiBzdXBlci5fY2hlY2tGaW5pc2hlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHBsYXlhYmxlIGF1ZGlvIGZvciB0aGUgc3BlZWNoLlxuICAgKlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge2V4dGVybmFsOkF1ZGlvfVxuICAgKi9cbiAgZ2V0IGF1ZGlvKCkge1xuICAgIHJldHVybiB0aGlzLl9hdWRpbztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBhdWRpbyB2b2x1bWUgZm9yIHRoZSBzcGVlY2guXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgdm9sdW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9hdWRpby52b2x1bWU7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgYXVkaW8gdm9sdW1lIGZvciB0aGUgc3BlZWNoLlxuICAgKi9cbiAgc2V0IHZvbHVtZSh2b2x1bWUpIHtcbiAgICB0aGlzLl9hdWRpby52b2x1bWUgPSB2b2x1bWU7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBhdWRpbydzIGN1cnJlbnQgbG9jYWwgdGltZSBhbmQgcGxheSBpdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wbGF5QXVkaW8oKSB7XG4gICAgaWYgKHRoaXMuX3NwZWVjaG1hcmtPZmZzZXQgPCAwKSB7XG4gICAgICB0aGlzLl9hdWRpby5jdXJyZW50VGltZSA9IHRoaXMuX3NwZWVjaG1hcmtPZmZzZXQ7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX3BsYXlpbmcpIHtcbiAgICAgICAgICB0aGlzLl9hdWRpby5jdXJyZW50VGltZSA9XG4gICAgICAgICAgICAodGhpcy5fbG9jYWxUaW1lICsgdGhpcy5fc3BlZWNobWFya09mZnNldCkgLyAxMDAwO1xuICAgICAgICAgIHRoaXMuX2F1ZGlvLnBsYXkoKTtcbiAgICAgICAgfVxuICAgICAgfSwgLXRoaXMuX3NwZWVjaG1hcmtPZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hdWRpby5jdXJyZW50VGltZSA9IDA7XG4gICAgICB0aGlzLl9hdWRpby5wbGF5KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhdXNlIHRoZSBhdWRpbyBvbmNlIGl0IGlzIHBsYXlhYmxlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3BhdXNlQXVkaW8oKSB7XG4gICAgdGhpcy5fYXVkaW8ucGxheSgpLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9wbGF5aW5nKSB7XG4gICAgICAgIHRoaXMuX2F1ZGlvLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwbGF5KGN1cnJlbnRUaW1lLCBvbkZpbmlzaCwgb25FcnJvciwgb25JbnRlcnJ1cHQpIHtcbiAgICB0aGlzLl9hdWRpb0ZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcGxheUF1ZGlvKCk7XG5cbiAgICByZXR1cm4gc3VwZXIucGxheShjdXJyZW50VGltZSwgb25GaW5pc2gsIG9uRXJyb3IsIG9uSW50ZXJydXB0KTtcbiAgfVxuXG4gIHBhdXNlKGN1cnJlbnRUaW1lKSB7XG4gICAgdGhpcy5fcGF1c2VBdWRpbygpO1xuICAgIHN1cGVyLnBhdXNlKGN1cnJlbnRUaW1lKTtcbiAgfVxuXG4gIHJlc3VtZShjdXJyZW50VGltZSwgb25GaW5pc2gsIG9uRXJyb3IsIG9uSW50ZXJydXB0KSB7XG4gICAgdGhpcy5fYXVkaW9GaW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2F1ZGlvLnBsYXkoKTtcblxuICAgIHJldHVybiBzdXBlci5yZXN1bWUoY3VycmVudFRpbWUsIG9uRmluaXNoLCBvbkVycm9yLCBvbkludGVycnVwdCk7XG4gIH1cblxuICBjYW5jZWwoKSB7XG4gICAgdGhpcy5fcGF1c2VBdWRpbygpO1xuICAgIHN1cGVyLmNhbmNlbCgpO1xuICB9XG5cbiAgc3RvcCgpIHtcbiAgICB0aGlzLl9wYXVzZUF1ZGlvKCk7XG4gICAgdGhpcy5fYXVkaW8uY3VycmVudFRpbWUgPSAwO1xuICAgIHN1cGVyLnN0b3AoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTcGVlY2g7XG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxuaW1wb3J0IEFic3RyYWN0SG9zdEZlYXR1cmUgZnJvbSAnY29yZS9BYnN0cmFjdEhvc3RGZWF0dXJlJztcbmltcG9ydCBBbmltYXRpb25VdGlscyBmcm9tICdjb3JlL2FuaW1wYWNrL0FuaW1hdGlvblV0aWxzJztcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSAnY29yZS9NYXRoVXRpbHMnO1xuaW1wb3J0IERlZmVycmVkIGZyb20gJ2NvcmUvRGVmZXJyZWQnO1xuaW1wb3J0IFNwZWVjaCBmcm9tICcuL0Fic3RyYWN0U3BlZWNoJztcbmltcG9ydCBUZXh0VG9TcGVlY2hVdGlscyBmcm9tICcuL1RleHRUb1NwZWVjaFV0aWxzJztcblxuLyoqXG4gKiBUaGUgQW1hem9uIFBvbGx5IHNlcnZpY2Ugb2JqZWN0LlxuICogQGV4dGVybmFsIFBvbGx5XG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BV1NKYXZhU2NyaXB0U0RLL2xhdGVzdC9BV1MvUG9sbHkuaHRtbFxuICovXG5cbi8qKlxuICogVGhlIHByZXNpZ25lciBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBnZW5lcmF0ZSBwcmVzaWduZWQgdXJscyBmb3IgdGhlIFBvbGx5IHNlcnZpY2UuXG4gKiBAZXh0ZXJuYWwgUHJlc2lnbmVyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BV1NKYXZhU2NyaXB0U0RLL2xhdGVzdC9BV1MvUG9sbHkvUHJlc2lnbmVyLmh0bWxcbiAqL1xuXG4vLyBBdmFpbGFibGUgb3B0aW9ucyBmb3IgUG9sbHlcbmNvbnN0IGVuZ2luZXMgPSBbJ3N0YW5kYXJkJywgJ25ldXJhbCddO1xuY29uc3QgYXVkaW9Gb3JtYXRzID0gWydtcDMnLCAnb2dnX3ZvcmJpcycsICdwY20nXTtcbmNvbnN0IHNwZWVjaG1hcmtUeXBlcyA9IFsnc2VudGVuY2UnLCAnc3NtbCcsICd2aXNlbWUnLCAnd29yZCddO1xuY29uc3Qgc2FtcGxlUmF0ZXMgPSB7XG4gIG1wMzoge1xuICAgIHJhdGVzOiBbJzgwMDAnLCAnMTYwMDAnLCAnMjIwNTAnLCAnMjQwMDAnXSxcbiAgICBkZWZhdWx0czoge1xuICAgICAgc3RhbmRhcmQ6ICcyMDUwJyxcbiAgICAgIG5ldXJhbDogJzI0MDAnLFxuICAgIH0sXG4gIH0sXG4gIHBjbToge1xuICAgIHJhdGVzOiBbJzgwMDAnLCAnMTYwMDAnXSxcbiAgICBkZWZhdWx0czoge1xuICAgICAgc3RhbmRhcmQ6ICcxNjAwJyxcbiAgICAgIG5ldXJhbDogJzE2MDAnLFxuICAgIH0sXG4gIH0sXG59O1xuc2FtcGxlUmF0ZXMub2dnX3ZvcmJpcyA9IHNhbXBsZVJhdGVzLm1wMztcbmxldCBhd3NWZXJzaW9uO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIHR1cm5pbmcgdGV4dCBpbnB1dCBpbnRvIHBsYXlhYmxlIGF1ZGlvLiBUaGVyZSBzaG91bGQgYmUgb25lIGluc3RhbmNlXG4gKiBwZXIgc3BlYWtlciwgZWFjaCBpbnN0YW5jZSBjYW4gcGxheSBvbmx5IG9uZSBwaWVjZSBvZiB0ZXh0IGF0IGEgdGltZS5cbiAqXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEhvc3RGZWF0dXJlXG4gKiBAYWJzdHJhY3RcbiAqXG4gKiBAcHJvcGVydHkgeyhudW1iZXJ8dW5kZWZpbmVkKX0gQVdTX1ZFUlNJT04gLSBHZXRzIHRoZSB2ZXJzaW9uIG9mIEFXUyBTREsgYmVpbmdcbiAqIHVzZWQuIFdpbGwgYmUgdW5kZWZpbmVkIHVudGlsIFtpbml0aWFsaXplU2VydmljZV17QGxpbmsgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlLmluaXRpYWxpemVTZXJ2aWNlfVxuICogaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGV4ZWN1dGVkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtQT0xMWV9NSU5fTkVVUkFMX1ZFUlNJT049JzIuNTAzJ10gLSBHZXRzIHRoZSBtaW5pbXVtIHZlcnNpb25cbiAqIG9mIHRoZSBBV1MgU0RLIHRoYXQgaXMgbmVjZXNzYXJ5IHRvIHVzZSBuZXVyYWwgdm9pY2VzIHdpdGggQVdTIFBvbGx5LlxuICogQHByb3BlcnR5IHtPYmplY3R9IFBPTExZX0RFRkFVTFRTIC0gRGVmYXVsdCB2YWx1ZXMgdG8gdXNlIHdpdGggY2FsbHMgdG8ge0BsaW5rIGV4dGVybmFsOlBvbGx5fS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbUE9MTFlfREVGQVVMVFMuRW5naW5lPSdzdGFuZGFyZCddXG4gKiBAcHJvcGVydHkge0FycmF5LjxzdHJpbmc+fSBbUE9MTFlfREVGQVVMVFMuTGV4aWNvbk5hbWVzPVtdXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtQT0xMWV9ERUZBVUxUUy5PdXRwdXRGb3JtYXQ9J21wMyddXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW1BPTExZX0RFRkFVTFRTLlNhbXBsZVJhdGU9JzIyMDUwJ11cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbUE9MTFlfREVGQVVMVFMuVGV4dD0nJ11cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbUE9MTFlfREVGQVVMVFMuVGV4dFR5cGU9J3NzbWwnXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtQT0xMWV9ERUZBVUxUUy5Wb2ljZUlkPSdBbXknXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtQT0xMWV9ERUZBVUxUUy5MYW5ndWFnZUNvZGU9J2VuLUdCJ11cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbUE9MTFlfREVGQVVMVFMuTGFuZ3VhZ2VOYW1lPSdCcml0aXNoIEVuZ2xpc2gnXVxuICogQHByb3BlcnR5IHtBcnJheS48c3RyaW5nPn0gW1BPTExZX1ZPSUNFUz1bXV0gLSBBbiBhcnJheSBvZiB2b2ljZXMgYXZhaWxhYmxlIGluXG4gKiBQb2xseS4gV2lsbCBiZSBlbXB0eSB1bnRpbCBbaW5pdGlhbGl6ZVNlcnZpY2Vde0BsaW5rIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZS5pbml0aWFsaXplU2VydmljZX1cbiAqIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBleGVjdXRlZC4gU2VlIFtQb2xseSBEb2N1bWVudGF0aW9uXXtAbGluayBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vcG9sbHkvbGF0ZXN0L2RnL3ZvaWNlbGlzdC5odG1sfVxuICogZm9yIGEgZnVsbCBsaXN0IG9mIGF2YWlsYWJsZSB2b2ljZXMuXG4gKiBAcHJvcGVydHkge09iamVjdH0gW1BPTExZX0xBTkdVQUdFUz17fV0gLSBBbiBvYmplY3QgdGhhdCBtYXBzIGxhbmd1YWdlIG5hbWVzXG4gKiB0byBsYW5ndWFnZSBjb2RlcyB0aGF0IGFyZSBhdmFpbGFibGUgaW4gUG9sbHkuIFdpbGwgYmUgZW1wdHkgdW50aWxcbiAqIFtpbml0aWFsaXplU2VydmljZV17QGxpbmsgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlLmluaXRpYWxpemVTZXJ2aWNlfVxuICogaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGV4ZWN1dGVkLiBTZWUgW1BvbGx5IERvY3VtZW50YXRpb25de0BsaW5rIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9wb2xseS9sYXRlc3QvZGcvU3VwcG9ydGVkTGFuZ3VhZ2UuaHRtbH1cbiAqIGZvciBhIGZ1bGwgbGlzdCBvZiBhdmFpbGFibGUgbGFuZ3VhZ2VzIGFuZCBjb3JyZXNwb25kaW5nIGNvZGVzLlxuICogQHByb3BlcnR5IHtPYmplY3R9IFtQT0xMWV9MQU5HVUFHRV9DT0RFUz17fV0gLSBBbiBvYmplY3QgdGhhdCBtYXBzIGxhbmd1YWdlIGNvZGVzXG4gKiB0byBsYW5ndWFnZSBuYW1lcyB0aGF0IGFyZSBhdmFpbGFibGUgaW4gUG9sbHkuIFdpbGwgYmUgZW1wdHkgdW50aWxcbiAqIFtpbml0aWFsaXplU2VydmljZV17QGxpbmsgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlLmluaXRpYWxpemVTZXJ2aWNlfVxuICogaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGV4ZWN1dGVkLiBTZWUgW1BvbGx5IERvY3VtZW50YXRpb25de0BsaW5rIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9wb2xseS9sYXRlc3QvZGcvU3VwcG9ydGVkTGFuZ3VhZ2UuaHRtbH1cbiAqIGZvciBhIGZ1bGwgbGlzdCBvZiBhdmFpbGFibGUgbGFuZ3VhZ2VzIGFuZCBjb3JyZXNwb25kaW5nIGNvZGVzLlxuICogQHByb3BlcnR5IHtPYmplY3R9IEVWRU5UUyAtIEJ1aWx0LWluIG1lc3NhZ2VzIHRoYXQgdGhlIGZlYXR1cmUgZW1pdHMuIFdoZW4gdGhlXG4gKiBmZWF0dXJlIGlzIGFkZGVkIHRvIGEge0BsaW5rIGNvcmUvSG9zdE9iamVjdH0sIGV2ZW50IG5hbWVzIHdpbGwgYmUgcHJlZml4ZWQgYnkgdGhlXG4gKiBuYW1lIG9mIHRoZSBmZWF0dXJlIGNsYXNzICsgJy4nLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVFMucmVhZHk9b25SZWFkeUV2ZW50XSAtIE1lc3NhZ2UgdGhhdCBpcyBlbWl0dGVkIGFmdGVyXG4gKiBbaW5pdGlhbGl6ZVNlcnZpY2Vde0BsaW5rIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZS5pbml0aWFsaXplU2VydmljZX0gaGFzIGJlZW5cbiAqIHN1Y2Nlc3NmdWxseSBleGVjdXRlZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLnBsYXk9b25QbGF5RXZlbnRdIC0gTWVzc2FnZSB0aGF0IGlzIGVtaXR0ZWQgYWZ0ZXJcbiAqIGVhY2ggY2FsbCB0byBbcGxheV17QGxpbmsgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlI3BsYXl9LiBUaGUgc3BlZWNoIHRoYXQgd2FzIHBsYXllZFxuICogaXMgc3VwcGxpZWQgYXMgYW4gYXJndW1lbnQgdG8gbGlzdGVuZXIgZnVuY3Rpb25zLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVFMucGF1c2U9b25QYXVzZUV2ZW50XSAtIE1lc3NhZ2UgdGhhdCBpcyBlbWl0dGVkIGFmdGVyXG4gKiBlYWNoIGNhbGwgdG8gW3BhdXNlXXtAbGluayBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUjcGF1c2V9LiBUaGUgc3BlZWNoIHRoYXQgd2FzIHBhdXNlZFxuICogaXMgc3VwcGxpZWQgYXMgYW4gYXJndW1lbnQgdG8gbGlzdGVuZXIgZnVuY3Rpb25zLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVFMucmVzdW1lPW9uUmVzdW1lRXZlbnRdIC0gTWVzc2FnZSB0aGF0IGlzIGVtaXR0ZWQgYWZ0ZXJcbiAqIGVhY2ggY2FsbCB0byBbcmVzdW1lXXtAbGluayBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUjcmVzdW1lfS4gVGhlIHNwZWVjaCB0aGF0IHdhc1xuICogcmVzdW1lZCBpcyBzdXBwbGllZCBhcyBhbiBhcmd1bWVudCB0byBsaXN0ZW5lciBmdW5jdGlvbnMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UUy5pbnRlcnJ1cHQ9b25JbnRlcnJ1cHRFdmVudF0gLSBNZXNzYWdlIHRoYXQgaXMgZW1pdHRlZFxuICogaWYgdGhlcmUgaXMgYSBjdXJyZW50IHNwZWVjaCBpbiBwcm9ncmVzcyBhbmQgW3BsYXlde0BsaW5rIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSNwbGF5fVxuICogb3IgW3Jlc3VtZV17QGxpbmsgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlI3Jlc3VtZX0gYXJlIGV4ZWN1dGVkIGZvciBhIG5ldyBzcGVlY2guXG4gKiBUaGUgc3BlZWNoIHRoYXQgd2FzIGludGVycnVwdGVkIGlzIHN1cHBsaWVkIGFzIGFuIGFyZ3VtZW50IHRvIGxpc3RlbmVyIGZ1bmN0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLnN0b3A9b25TdG9wRXZlbnRdIC0gTWVzc2FnZSB0aGF0IGlzIGVtaXR0ZWQgYWZ0ZXJcbiAqIGVhY2ggY2FsbCB0byBbc3RvcF17QGxpbmsgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlI3N0b3B9IGFuZCB3aGVuIGEgc3BlZWNoIHJlYWNoZXNcbiAqIHRoZSBlbmQgb2YgcGxheWJhY2suIFRoZSBzcGVlY2ggdGhhdCB3YXMgc3RvcHBlZCBpcyBzdXBwbGllZCBhcyBhbiBhcmd1bWVudFxuICogdG8gbGlzdGVuZXIgZnVuY3Rpb25zLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVFMuc2VudGVuY2U9b25TZW50ZW5jZUV2ZW50XSAtIE1lc3NhZ2UgdGhhdCBpcyBlbWl0dGVkXG4gKiBlYWNoIHRpbWUgYSBzZW50ZW5jZSBzcGVlY2htYXJrIGlzIGVuY291bnRlcmVkIHdob3NlIHRpbWVzdGFtcCBtYXRjaGVzIHVwIHdpdGhcbiAqIHRoZSBzcGVlY2ggYXVkaW8ncyBjdXJyZW50IHRpbWUuIFRoZSBzZW50ZW5jZSBzcGVlY2htYXJrIG9iamVjdCBpcyBzdXBwbGllZCBhc1xuICogYW4gYXJndW1lbnQgdG8gbGlzdGVuZXIgZnVuY3Rpb25zLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVFMud29yZD1vbldvcmRFdmVudF0gLSBNZXNzYWdlIHRoYXQgaXMgZW1pdHRlZFxuICogZWFjaCB0aW1lIGEgd29yZCBzcGVlY2htYXJrIGlzIGVuY291bnRlcmVkIHdob3NlIHRpbWVzdGFtcCBtYXRjaGVzIHVwIHdpdGhcbiAqIHRoZSBzcGVlY2ggYXVkaW8ncyBjdXJyZW50IHRpbWUuIFRoZSB3b3JkIHNwZWVjaG1hcmsgb2JqZWN0IGlzIHN1cHBsaWVkIGFzXG4gKiBhbiBhcmd1bWVudCB0byBsaXN0ZW5lciBmdW5jdGlvbnMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UUy52aXNlbWU9b25WaXNlbWVFdmVudF0gLSBNZXNzYWdlIHRoYXQgaXMgZW1pdHRlZFxuICogZWFjaCB0aW1lIGEgdmlzZW1lIHNwZWVjaG1hcmsgaXMgZW5jb3VudGVyZWQgd2hvc2UgdGltZXN0YW1wIG1hdGNoZXMgdXAgd2l0aFxuICogdGhlIHNwZWVjaCBhdWRpbydzIGN1cnJlbnQgdGltZS4gVGhlIHZpc2VtZSBzcGVlY2htYXJrIG9iamVjdCBpcyBzdXBwbGllZCBhc1xuICogYW4gYXJndW1lbnQgdG8gbGlzdGVuZXIgZnVuY3Rpb25zLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVFMuc3NtbD1vblNzbWxFdmVudF0gLSBNZXNzYWdlIHRoYXQgaXMgZW1pdHRlZFxuICogZWFjaCB0aW1lIGEgc3NtbCBzcGVlY2htYXJrIGlzIGVuY291bnRlcmVkIHdob3NlIHRpbWVzdGFtcCBtYXRjaGVzIHVwIHdpdGhcbiAqIHRoZSBzcGVlY2ggYXVkaW8ncyBjdXJyZW50IHRpbWUuIFRoZSBzc21sIHNwZWVjaG1hcmsgb2JqZWN0IGlzIHN1cHBsaWVkIGFzXG4gKiBhbiBhcmd1bWVudCB0byBsaXN0ZW5lciBmdW5jdGlvbnMuXG4gKiBAcHJvcGVydHkge09iamVjdH0gU0VSVklDRVMgLSBBV1Mgc2VydmljZXMgdGhhdCBhcmUgbmVjZXNzYXJ5IGZvciB0aGUgZmVhdHVyZVxuICogdG8gZnVuY3Rpb24uXG4gKiBAcHJvcGVydHkge2V4dGVybmFsOlBvbGx5fSBTRVJWSUNFUy5wb2xseSAtIFRoZSBQb2xseSBzZXJ2aWNlIHRoYXQgaXMgdXNlZFxuICogdG8gc3ludGhlc2l6ZSBzcGVlY2htYXJrcy4gV2lsbCBiZSB1bmRlZmluZWQgdW50aWwgW2luaXRpYWxpemVTZXJ2aWNlXXtAbGluayBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUuaW5pdGlhbGl6ZVNlcnZpY2V9XG4gKiBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgZXhlY3V0ZWRcbiAqIEBwcm9wZXJ0eSB7ZXh0ZXJuYWw6UHJlc2lnbmVyfSBTRVJWSUNFUy5wcmVzaWduZXIgLSBUaGUgUG9sbHkgUHJlc2lnbmVyXG4gKiBvYmplY3QgdGhhdCBpcyB1c2VkIHRvIHN5bnRoZXNpemUgc3BlZWNoIGF1ZGlvLiBXaWxsIGJlIHVuZGVmaW5lZCB1bnRpbFxuICogW2luaXRpYWxpemVTZXJ2aWNlXXtAbGluayBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUuaW5pdGlhbGl6ZVNlcnZpY2V9XG4gKiBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgZXhlY3V0ZWQuXG4gKi9cbmNsYXNzIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSBleHRlbmRzIEFic3RyYWN0SG9zdEZlYXR1cmUge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7Y29yZS9Ib3N0T2JqZWN0fSBob3N0IC0gSG9zdCBvYmplY3QgbWFuYWdpbmcgdGhlIGZlYXR1cmUuXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyAtIE9wdGlvbnMgdGhhdCB3aWxsIGJlIHNlbnQgdG8gUG9sbHkgZm9yIGVhY2ggc3BlZWNoLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdGlvbnMudm9pY2UgLSBUaGUgbmFtZSBvZiB0aGUgUG9sbHkgdm9pY2UgdG8gdXNlIGZvciBhbGwgc3BlZWNoLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdGlvbnMuZW5naW5lIC0gVGhlIG5hbWUgb2YgdGhlIFBvbGx5IGVuZ2luZSB0byB1c2UgZm9yIGFsbCBzcGVlY2guXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0aW9ucy5sYW5ndWFnZSAtIFRoZSBuYW1lIG9mIHRoZSBsYW5ndWFnZSB0byB1c2UgZm9yIGFsbCBzcGVlY2guXG4gICAqIEBwYXJhbSB7YXVkaW9Gb3JtYXR9IFtvcHRpb25zLmF1ZGlvRm9ybWF0PSdtcDMnXSAtIFRoZSBmb3JtYXQgdG8gdXNlIGZvciBnZW5lcmF0ZWRcbiAgICogYXVkaW8gZm9yIGFsbCBzcGVlY2hlcy5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRpb25zLnNhbXBsZVJhdGUgLSBUaGUgc2FtcGxlIHJhdGUgZm9yIGF1ZGlvIGZpbGVzIGZvciBhbGxcbiAgICogc3BlZWNoZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zcGVlY2htYXJrT2Zmc2V0PTBdIC0gQW1vdW50IG9mIHRpbWUgaW4gc2Vjb25kcyB0b1xuICAgKiBvZmZzZXQgc3BlZWNobWFyayBldmVudCBlbWlzc2lvbiBmcm9tIHRoZSBhdWRpby5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1pbkVuZE1hcmtEdXJhdGlvbj0uMDVdIC0gVGhlIG1pbmltdW0gYW1vdW50IG9mIHRpbWVcbiAgICogaW4gc2Vjb25kcyB0aGF0IHRoZSBsYXN0IHNwZWVjaG1hcmsgb2YgZWFjaCB0eXBlIGluIGEgc3BlZWNoIGNhbiBoYXZlIGl0c1xuICAgKiBkdXJhdGlvbiBwcm9wZXJ0eSBzZXQgdG8uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy52b2x1bWU9MV0gLSBUaGUgZGVmYXVsdCB2b2x1bWUgdG8gcGxheSBzcGVlY2ggYXVkaW9cbiAgICogd2l0aC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pc0dsb2JhbD1mYWxzZV0gLSBXaGV0aGVyIHRoZSBhdWRpbyBzb3VyY2Ugc2hvdWxkIGRlZmF1bHRcbiAgICogdG8gZ2xvYmFsIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciBvciBub3QgaXQgaXMgYXR0YWNoZWQgdG8gYW4gb2JqZWN0LlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgaG9zdCxcbiAgICBvcHRpb25zID0ge1xuICAgICAgdm9pY2U6IHVuZGVmaW5lZCxcbiAgICAgIGVuZ2luZTogdW5kZWZpbmVkLFxuICAgICAgbGFuZ3VhZ2U6IHVuZGVmaW5lZCxcbiAgICAgIGF1ZGlvRm9ybWF0OiAnbXAzJyxcbiAgICAgIHNhbXBsZVJhdGU6IHVuZGVmaW5lZCxcbiAgICAgIHNwZWVjaG1hcmtPZmZzZXQ6IDAsXG4gICAgICBtaW5FbmRNYXJrRHVyYXRpb246IDAuMDUsXG4gICAgICB2b2x1bWU6IDEsXG4gICAgICBpc0dsb2JhbDogZmFsc2UsXG4gICAgfVxuICApIHtcbiAgICBzdXBlcihob3N0KTtcblxuICAgIHRoaXMuX3NwZWVjaENhY2hlID0ge307XG4gICAgdGhpcy5fY3VycmVudFNwZWVjaCA9IG51bGw7XG4gICAgdGhpcy5fY3VycmVudFByb21pc2UgPSBudWxsO1xuICAgIHRoaXMuX2lzVmFsaWRhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5zcGVlY2htYXJrT2Zmc2V0ID0gTnVtYmVyLmlzTmFOKE51bWJlcihvcHRpb25zLnNwZWVjaG1hcmtPZmZzZXQpKVxuICAgICAgPyAwXG4gICAgICA6IE51bWJlcihvcHRpb25zLnNwZWVjaG1hcmtPZmZzZXQpO1xuICAgIHRoaXMubWluRW5kTWFya0R1cmF0aW9uID0gTnVtYmVyLmlzTmFOKE51bWJlcihvcHRpb25zLm1pbkVuZE1hcmtEdXJhdGlvbikpXG4gICAgICA/IDBcbiAgICAgIDogTnVtYmVyKG9wdGlvbnMubWluRW5kTWFya0R1cmF0aW9uKTtcbiAgICB0aGlzLnZvbHVtZSA9IE51bWJlci5pc05hTihOdW1iZXIob3B0aW9ucy52b2x1bWUpKVxuICAgICAgPyAxXG4gICAgICA6IE51bWJlcihvcHRpb25zLnZvbHVtZSk7XG4gICAgdGhpcy5faXNHbG9iYWwgPSBvcHRpb25zLmlzR2xvYmFsIHx8IGZhbHNlO1xuICAgIHRoaXMuX3Byb21pc2VzID0ge1xuICAgICAgdm9sdW1lOiBEZWZlcnJlZC5yZXNvbHZlKCksXG4gICAgfTtcbiAgICB0aGlzLl92b2x1bWVQYXVzZWQgPSBmYWxzZTtcblxuICAgIC8vIFNldCBkZWZhdWx0IG9wdGlvbnMgZm9yIGVhY2ggc3BlZWNoXG4gICAgdGhpcy5fdm9pY2UgPSBvcHRpb25zLnZvaWNlIHx8IHRoaXMuY29uc3RydWN0b3IuUE9MTFlfREVGQVVMVFMuVm9pY2VJZDtcbiAgICB0aGlzLl9sYW5ndWFnZSA9XG4gICAgICBvcHRpb25zLmxhbmd1YWdlIHx8IHRoaXMuY29uc3RydWN0b3IuUE9MTFlfREVGQVVMVFMuTGFuZ3VhZ2VOYW1lO1xuICAgIHRoaXMuX2VuZ2luZSA9IGVuZ2luZXMuaW5jbHVkZXMob3B0aW9ucy5lbmdpbmUpXG4gICAgICA/IG9wdGlvbnMuZW5naW5lXG4gICAgICA6IHRoaXMuY29uc3RydWN0b3IuUE9MTFlfREVGQVVMVFMuRW5naW5lO1xuICAgIHRoaXMuX2F1ZGlvRm9ybWF0ID0gYXVkaW9Gb3JtYXRzLmluY2x1ZGVzKG9wdGlvbnMuYXVkaW9Gb3JtYXQpXG4gICAgICA/IG9wdGlvbnMuYXVkaW9Gb3JtYXRcbiAgICAgIDogdGhpcy5jb25zdHJ1Y3Rvci5QT0xMWV9ERUZBVUxUUy5PdXRwdXRGb3JtYXQ7XG4gICAgdGhpcy5fc2FtcGxlUmF0ZSA9IHNhbXBsZVJhdGVzW3RoaXMuX2F1ZGlvRm9ybWF0XS5yYXRlcy5pbmNsdWRlcyhcbiAgICAgIG9wdGlvbnMuc2FtcGxlUmF0ZVxuICAgIClcbiAgICAgID8gb3B0aW9ucy5zYW1wbGVSYXRlXG4gICAgICA6IHRoaXMuY29uc3RydWN0b3IuUE9MTFlfREVGQVVMVFMuU2FtcGxlUmF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9yZSBQb2xseSwgUHJlc2lnbmVyIGFuZCBBV1MgU0RLIFZlcnNpb24gZm9yIHVzZSBhY3Jvc3MgYWxsIGluc3RhbmNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtleHRlcm5hbDpQb2xseX0gcG9sbHkgLSBQb2xseSBpbnN0YW5jZSB0byB1c2UgdG8gZ2VuZXJhdGUgc3BlZWNobWFya3MuXG4gICAqIEBwYXJhbSB7ZXh0ZXJuYWw6UHJlc2lnbmVyfSBwcmVzaWduZXIgLSBQcmVzaWduZXIgaW5zdGFuY2UgdG8gdXNlIHRvIGdlbmVyYXRlXG4gICAqIGF1ZGlvIFVSTHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2ZXJzaW9uIC0gVmVyc2lvbiBvZiB0aGUgQVdTIFNESyB0byB1c2UgdG8gdmFsaWRhdGUgdm9pY2Ugb3B0aW9ucy5cbiAgICovXG4gIHN0YXRpYyBpbml0aWFsaXplU2VydmljZShwb2xseSwgcHJlc2lnbmVyLCB2ZXJzaW9uKSB7XG4gICAgLy8gTWFrZSBzdXJlIGFsbCB3ZXJlIGRlZmluZWRcbiAgICBpZiAoXG4gICAgICBwb2xseSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICBwcmVzaWduZXIgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdmVyc2lvbiA9PT0gdW5kZWZpbmVkXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdDYW5ub3QgaW5pdGlhbGl6ZSBUZXh0VG9TcGVlY2ggZmVhdHVyZS4gQWxsIGFyZ3VtZW50cyBtdXN0IGJlIGRlZmluZWQuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgc3VtZXJpYW4gaG9zdHMgdXNlci1hZ2VudFxuICAgIGlmIChwb2xseS5jb25maWcpIHtcbiAgICAgIHBvbGx5LmNvbmZpZy5jdXN0b21Vc2VyQWdlbnQgPSB0aGlzLl93aXRoQ3VzdG9tVXNlckFnZW50KFxuICAgICAgICBwb2xseS5jb25maWcuY3VzdG9tVXNlckFnZW50XG4gICAgICApO1xuICAgIH1cbiAgICBpZiAocHJlc2lnbmVyLnNlcnZpY2UgJiYgcHJlc2lnbmVyLnNlcnZpY2UuY29uZmlnKSB7XG4gICAgICBwcmVzaWduZXIuc2VydmljZS5jb25maWcuY3VzdG9tVXNlckFnZW50ID0gdGhpcy5fd2l0aEN1c3RvbVVzZXJBZ2VudChcbiAgICAgICAgcHJlc2lnbmVyLnNlcnZpY2UuY29uZmlnLmN1c3RvbVVzZXJBZ2VudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pc1JlYWR5ID0gZmFsc2U7XG5cbiAgICAvLyBTdG9yZSBwYXJhbWV0ZXJzXG4gICAgdGhpcy5TRVJWSUNFUy5wb2xseSA9IHBvbGx5O1xuICAgIHRoaXMuU0VSVklDRVMucHJlc2lnbmVyID0gcHJlc2lnbmVyO1xuICAgIGF3c1ZlcnNpb24gPSB2ZXJzaW9uO1xuXG4gICAgLy8gQ2xlYXIgdGhlIGN1cnJlbnQgcG9sbHkgb2JqZWN0c1xuICAgIGNvbnN0IGF2YWlsYWJsZVZvaWNlcyA9IHRoaXMuUE9MTFlfVk9JQ0VTO1xuICAgIGF2YWlsYWJsZVZvaWNlcy5sZW5ndGggPSAwO1xuXG4gICAgY29uc3QgYXZhaWxhYmxlTGFuZ3VhZ2VzID0gdGhpcy5QT0xMWV9MQU5HVUFHRVM7XG4gICAgT2JqZWN0LmtleXMoYXZhaWxhYmxlTGFuZ3VhZ2VzKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgZGVsZXRlIGF2YWlsYWJsZUxhbmd1YWdlc1tuYW1lXTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGF2YWlsYWJsZUxhbmd1YWdlQ29kZXMgPSB0aGlzLlBPTExZX0xBTkdVQUdFX0NPREVTO1xuICAgIE9iamVjdC5rZXlzKGF2YWlsYWJsZUxhbmd1YWdlQ29kZXMpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICBkZWxldGUgYXZhaWxhYmxlTGFuZ3VhZ2VDb2Rlc1tuYW1lXTtcbiAgICB9KTtcblxuICAgIC8vIFJlLXBvcHVsYXRlIGFjY29yZGluZyB0byB2ZXJzaW9uXG4gICAgY29uc3QgbWluTmV1cmFsU2RrID0gdGhpcy5QT0xMWV9NSU5fTkVVUkFMX1ZFUlNJT047XG5cbiAgICByZXR1cm4gdGhpcy5TRVJWSUNFUy5wb2xseVxuICAgICAgLmRlc2NyaWJlVm9pY2VzKClcbiAgICAgIC5wcm9taXNlKClcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgY29uc3QgYWxsQ29kZXMgPSB7fTtcblxuICAgICAgICByZXNwb25zZS5Wb2ljZXMuZm9yRWFjaCh2b2ljZSA9PiB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdm9pY2UuU3VwcG9ydGVkRW5naW5lcy5pbmNsdWRlcygnc3RhbmRhcmQnKSB8fFxuICAgICAgICAgICAgdmVyc2lvbiA+PSBtaW5OZXVyYWxTZGtcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGF2YWlsYWJsZVZvaWNlcy5wdXNoKHZvaWNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhdmFpbGFibGVWb2ljZXMuZm9yRWFjaCh2b2ljZSA9PiB7XG4gICAgICAgICAgICBhdmFpbGFibGVMYW5ndWFnZXNbdm9pY2UuTGFuZ3VhZ2VOYW1lXSA9IHZvaWNlLkxhbmd1YWdlQ29kZTtcbiAgICAgICAgICAgIGFsbENvZGVzW3ZvaWNlLkxhbmd1YWdlQ29kZV0gPSB2b2ljZS5MYW5ndWFnZU5hbWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGF2YWlsYWJsZUxhbmd1YWdlcykuZm9yRWFjaCgoW25hbWUsIGNvZGVdKSA9PiB7XG4gICAgICAgICAgYXZhaWxhYmxlTGFuZ3VhZ2VDb2Rlc1tjb2RlXSA9IG5hbWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIE5vdGlmeSB0aGF0IHdlJ3JlIHJlYWR5IHRvIGdlbmVyYXRlIHNwZWVjaGVzXG4gICAgICAgIHRoaXMuX2lzUmVhZHkgPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXQodGhpcy5FVkVOVFMucmVhZHkpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRoZSBjbGFzcyBpcyBjYXBhYmxlIG9mIGdlbmVyYXRpbmcgc3BlZWNoIGF1ZGlvLiBQb2xseSxcbiAgICogUHJlc2lnbmVyIGFuZCBBV1MgU0RLIHZlcnNpb24gbnVtYmVyIG11c3QgaGF2ZSBiZWVuIGRlZmluZWQgdXNpbmdcbiAgICogW2luaXRpYWxpemVTZXJ2aWNlXXtAbGluayBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUuaW5pdGlhbGl6ZVNlcnZpY2V9LlxuICAgKlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgZ2V0IGlzUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzUmVhZHk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdGV4dCBvZiB0aGUgY3VycmVudGx5IHBsYXlpbmcgc3BlZWNoLlxuICAgKlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBjdXJyZW50U3BlZWNoKCkge1xuICAgIGlmICh0aGlzLl9jdXJyZW50U3BlZWNoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY3VycmVudFNwZWVjaC50ZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbmQgc2V0cyB0aGUgbnVtYmVyIG9mIHNlY29uZHMgdG8gb2Zmc2V0IHNwZWVjaG1hcmsgZW1pc3Npb24uXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgc3BlZWNobWFya09mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3BlZWNobWFya09mZnNldDtcbiAgfVxuXG4gIHNldCBzcGVlY2htYXJrT2Zmc2V0KG9mZnNldCkge1xuICAgIHRoaXMuX3NwZWVjaG1hcmtPZmZzZXQgPSBvZmZzZXQ7XG5cbiAgICBpZiAodGhpcy5fY3VycmVudFNwZWVjaCkge1xuICAgICAgdGhpcy5fY3VycmVudFNwZWVjaC5zcGVlY2htYXJrT2Zmc2V0ID0gb2Zmc2V0O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuZCBzZXRzIHRoZSBUaGUgbWluaW11bSBhbW91bnQgb2YgdGltZSBpbiBzZWNvbmRzIHRoYXQgdGhlIGxhc3RcbiAgICogc3BlZWNobWFyayBvZiBlYWNoIHR5cGUgaW4gYSBzcGVlY2ggY2FuIGhhdmUgaXRzIGR1cmF0aW9uIHByb3BlcnR5IHNldCB0by5cbiAgICpcbiAgICogQHR5cGUgbnVtYmVyXG4gICAqL1xuICBnZXQgbWluRW5kTWFya0R1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9taW5FbmRNYXJrRHVyYXRpb24gLyAxMDAwO1xuICB9XG5cbiAgc2V0IG1pbkVuZE1hcmtEdXJhdGlvbihkdXJhdGlvbikge1xuICAgIHRoaXMuX21pbkVuZE1hcmtEdXJhdGlvbiA9IGR1cmF0aW9uICogMTAwMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBlbmRzIHRoZSBTdW1lcmlhbiBIb3N0cyBjdXN0b20gdXNlci1hZ2VudCB0byBhIHN0cmluZyBpZiBpdCBpcyBub3RcbiAgICogYWxyZWFkeSBwcmVzZW50LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY3VycmVudFVzZXJBZ2VudCAtIFN0cmluZyB0byBhcHBlbmQgdG8gaWYgbmVlZGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIF93aXRoQ3VzdG9tVXNlckFnZW50KGN1cnJlbnRVc2VyQWdlbnQpIHtcbiAgICBjb25zdCBzdW1lcmlhbkhvc3RzVXNlckFnZW50ID0gJ3JlcXVlc3Qtc291cmNlL1N1bWVyaWFuSG9zdHMnO1xuXG4gICAgaWYgKGN1cnJlbnRVc2VyQWdlbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHN1bWVyaWFuSG9zdHNVc2VyQWdlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRVc2VyQWdlbnQuaW5kZXhPZihzdW1lcmlhbkhvc3RzVXNlckFnZW50KSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBjdXJyZW50VXNlckFnZW50O1xuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50VXNlckFnZW50LmNvbmNhdCgnICcsIHN1bWVyaWFuSG9zdHNVc2VyQWdlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIGdpdmVuIGVuZ2luZSB0eXBlIGlzIGNvbXBhdGlibGUgd2l0aCB0aGUgQVdTIFNESyB2ZXJzaW9uLiBJZiBpdFxuICAgKiBpcywgcmV0dXJuIHRoZSBvcmlnaW5hbCB2YWx1ZS4gT3RoZXJ3aXNlIHJldHVybiBhIGRlZmF1bHQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbmdpbmUgLSBUaGUgdHlwZSBvZiBQb2xseSB2b2ljZSBlbmdpbmUgdG8gdmFsaWRhdGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBfdmFsaWRhdGVFbmdpbmUoZW5naW5lKSB7XG4gICAgLy8gRGVmYXVsdCB0byB0aGUgc3RhbmRhcmQgZW5naW5lIGlmIG5ldXJhbCBpcyBub3QgYXZhaWxhYmxlIGZvciB0aGlzIHZlcnNpb25cbiAgICBpZiAoXG4gICAgICBlbmdpbmUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5BV1NfVkVSU0lPTiA8IHRoaXMuY29uc3RydWN0b3IuUE9MTFlfTUlOX05FVVJBTF9WRVJTSU9OXG4gICAgKSB7XG4gICAgICBlbmdpbmUgPSB0aGlzLmNvbnN0cnVjdG9yLlBPTExZX0RFRkFVTFRTLkVuZ2luZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5naW5lO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIGdpdmVuIGF1ZGlvIGZvcm1hdCB0eXBlIGlzIGNvbXBhdGlibGUgd2l0aCBQb2xseS4gSWYgaXQgaXMsIHJldHVyblxuICAgKiB0aGUgb3JpZ2luYWwgdmFsdWUuIE90aGVyd2lzZSByZXR1cm4gYSBkZWZhdWx0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZW5naW5lIC0gVGhlIHR5cGUgb2YgUG9sbHkgdm9pY2UgZW5naW5lIHRvIHZhbGlkYXRlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgX3ZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCB8fCAhYXVkaW9Gb3JtYXRzLmluY2x1ZGVzKGZvcm1hdCkpIHtcbiAgICAgIGZvcm1hdCA9IHRoaXMuY29uc3RydWN0b3IuUE9MTFlfREVGQVVMVFMuT3V0cHV0Rm9ybWF0O1xuICAgIH1cblxuICAgIHJldHVybiBmb3JtYXQ7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgZ2l2ZW4gYXVkaW8gc2FtcGxpbmcgcmF0ZSBpcyBjb21wYXRpYmxlIHdpdGggdGhlIGN1cnJlbnQgYXVkaW9cbiAgICogZm9ybWF0LiBJZiBpdCBpcywgcmV0dXJuIHRoZSBvcmlnaW5hbCB2YWx1ZS4gT3RoZXJ3aXNlIHJldHVybiBhIGRlZmF1bHQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbmdpbmUgLSBUaGUgdHlwZSBvZiBQb2xseSB2b2ljZSBlbmdpbmUgdG8gdmFsaWRhdGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBfdmFsaWRhdGVSYXRlKHJhdGUpIHtcbiAgICAvLyBVc2UgZGVmYXVsdCBpZiBzcGVjaWZpZWQgc2FtcGxlIHJhdGUgaXMgbm90IHZhbGlkIGZvciB0aGUgYXVkaW8gZm9ybWF0XG4gICAgaWYgKFxuICAgICAgcmF0ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAhc2FtcGxlUmF0ZXNbdGhpcy5fYXVkaW9Gb3JtYXRdLnJhdGVzLmluY2x1ZGVzKHJhdGUpXG4gICAgKSB7XG4gICAgICByYXRlID0gc2FtcGxlUmF0ZXNbdGhpcy5fYXVkaW9Gb3JtYXRdLmRlZmF1bHRzW3RoaXMuX2VuZ2luZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhdGU7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgZ2l2ZW4gUG9sbHkgdm9pY2UgaWQgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBjdXJyZW50IFBvbGx5IGVuZ2luZS5cbiAgICogSWYgaXQgaXMsIHJldHVybiB0aGUgb3JpZ2luYWwgdmFsdWUuIE90aGVyd2lzZSByZXR1cm4gYSBkZWZhdWx0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZW5naW5lIC0gVGhlIHR5cGUgb2YgUG9sbHkgdm9pY2UgZW5naW5lIHRvIHZhbGlkYXRlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgX3ZhbGlkYXRlVm9pY2Uodm9pY2VJZCkge1xuICAgIGNvbnN0IHZvaWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5QT0xMWV9WT0lDRVMuZmluZCh2ID0+IHYuSWQgPT09IHZvaWNlSWQpO1xuXG4gICAgLy8gVXNlIHRoZSBkZWZhdWx0IHZvaWNlIGlmIHRoZSB2b2ljZSBpc24ndCBzdXBwb3J0ZWQgYnkgdGhlIGVuZ2luZVxuICAgIGlmICh2b2ljZSA9PT0gdW5kZWZpbmVkIHx8ICF2b2ljZS5TdXBwb3J0ZWRFbmdpbmVzLmluY2x1ZGVzKHRoaXMuX2VuZ2luZSkpIHtcbiAgICAgIHZvaWNlSWQgPSB0aGlzLmNvbnN0cnVjdG9yLlBPTExZX0RFRkFVTFRTLlZvaWNlSWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZvaWNlSWQ7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgZ2l2ZW4gUG9sbHkgbGFuZ3VhZ2UgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBjdXJyZW50IFBvbGx5IHZvaWNlLlxuICAgKiBJZiBpdCBpcywgcmV0dXJuIHRoZSBvcmlnaW5hbCB2YWx1ZS4gT3RoZXJ3aXNlIHJldHVybiBhIGRlZmF1bHQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbmdpbmUgLSBUaGUgdHlwZSBvZiBQb2xseSB2b2ljZSBlbmdpbmUgdG8gdmFsaWRhdGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBfdmFsaWRhdGVMYW5ndWFnZShsYW5ndWFnZSkge1xuICAgIGNvbnN0IHZvaWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5QT0xMWV9WT0lDRVMuZmluZCh2ID0+IHYuSWQgPT09IHRoaXMuX3ZvaWNlKTtcbiAgICBjb25zdCBsYW5ndWFnZUNvZGUgPSB0aGlzLmNvbnN0cnVjdG9yLlBPTExZX0xBTkdVQUdFU1tsYW5ndWFnZV07XG5cbiAgICAvLyBGaW5kIHRoZSBsYW5ndWFnZXMgYXZhaWxhYmxlIGZvciB0aGUgY3VycmVudCB2b2ljZVxuICAgIGNvbnN0IGF2YWlsYWJsZUNvZGVzID0gW3ZvaWNlLkxhbmd1YWdlQ29kZV07XG4gICAgaWYgKHZvaWNlLkFkZGl0aW9uYWxMYW5ndWFnZUNvZGVzKSB7XG4gICAgICBhdmFpbGFibGVDb2Rlcy5wdXNoKC4uLnZvaWNlLkFkZGl0aW9uYWxMYW5ndWFnZUNvZGVzKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgY3VycmVudCB2b2ljZSBkb2Vzbid0IHN1cHBvcnQgdGhlIGxhbmd1YWdlLCB1c2UgaXRzIGRlZmF1bHRcbiAgICBpZiAoIWF2YWlsYWJsZUNvZGVzLmluY2x1ZGVzKGxhbmd1YWdlQ29kZSkpIHtcbiAgICAgIGxhbmd1YWdlID0gdGhpcy5jb25zdHJ1Y3Rvci5QT0xMWV9MQU5HVUFHRV9DT0RFU1t2b2ljZS5MYW5ndWFnZUNvZGVdO1xuICAgIH1cblxuICAgIHJldHVybiBsYW5ndWFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSB0aGUgY3VycmVudCBQb2xseSBvcHRpb25zIHRvIG1ha2Ugc3VyZSB0aGV5IGFyZSBjb21wYXRpYmxlIHdpdGggZWFjaFxuICAgKiBvdGhlci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF92YWxpZGF0ZSgpIHtcbiAgICAvLyBWYWxpZGF0ZSBzcGVlY2ggcGFyYW1ldGVyc1xuICAgIHRoaXMuX2VuZ2luZSA9IHRoaXMuX3ZhbGlkYXRlRW5naW5lKHRoaXMuX2VuZ2luZSk7XG4gICAgdGhpcy5fYXVkaW9Gb3JtYXQgPSB0aGlzLl92YWxpZGF0ZUZvcm1hdCh0aGlzLl9hdWRpb0Zvcm1hdCk7XG4gICAgdGhpcy5fc2FtcGxlUmF0ZSA9IHRoaXMuX3ZhbGlkYXRlUmF0ZSh0aGlzLl9zYW1wbGVSYXRlKTtcbiAgICB0aGlzLl92b2ljZSA9IHRoaXMuX3ZhbGlkYXRlVm9pY2UodGhpcy5fdm9pY2UpO1xuICAgIHRoaXMuX2xhbmd1YWdlID0gdGhpcy5fdmFsaWRhdGVMYW5ndWFnZSh0aGlzLl9sYW5ndWFnZSk7XG4gICAgdGhpcy5faXNWYWxpZGF0ZWQgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBvYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJzIGNvbXBhdGlibGUgd2l0aCBQb2xseS5zeW50aGVzaXplU3BlZWNoLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKi9cbiAgX2dldENvbmZpZygpIHtcbiAgICAvLyBNYWtlIHN1cmUgcGFyYW1ldGVycyBoYXZlIGJlZW4gdmFsaWRhdGVkXG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IuaXNSZWFkeSAmJiAhdGhpcy5faXNWYWxpZGF0ZWQpIHtcbiAgICAgIHRoaXMuX3ZhbGlkYXRlKCk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGEgY29uZmlnIG9iamVjdCBjb21wYXRpYmxlIHdpdGggUG9sbHlcbiAgICByZXR1cm4ge1xuICAgICAgRW5naW5lOiB0aGlzLl9lbmdpbmUsXG4gICAgICBPdXRwdXRGb3JtYXQ6IHRoaXMuX2F1ZGlvRm9ybWF0LFxuICAgICAgU2FtcGxlUmF0ZTogdGhpcy5fc2FtcGxlUmF0ZSxcbiAgICAgIFZvaWNlSWQ6IHRoaXMuX3ZvaWNlLFxuICAgICAgTGFuZ3VhZ2VDb2RlOiB0aGlzLmNvbnN0cnVjdG9yLlBPTExZX0xBTkdVQUdFU1t0aGlzLl9sYW5ndWFnZV0sXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgUG9sbHkgcGFyYW1ldGVycyB3aXRoIG9wdGlvbnMgZnJvbSBhIGdpdmVuIGNvbmZpZy4gQWxsIHN0b3JlZCBzcGVlY2hlc1xuICAgKiB3aWxsIGJlIHVwZGF0ZWQgdG8gdXNlIHRoZSBuZXcgcGFyYW1ldGVycywgdW5sZXNzIHRoZSBzcGVlY2ggdGV4dCBpcyBjb250YWluZWRcbiAgICogaW4gdGhlICdza2lwU3BlZWNoZXMnIHBhcmFtZXRlci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAtIFBvbGx5IHBhcmFtZXRlciBvcHRpb25zIHRvIG92ZXJ3cml0ZS5cbiAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gc2tpcFNwZWVjaGVzIC0gVGV4dCBvZiBhbnkgc3BlZWNoZXMgdGhhdCBzaG91bGQgbm90XG4gICAqIGhhdmUgcGFyYW1ldGVycyB1cGRhdGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKi9cbiAgX3VwZGF0ZUNvbmZpZyhjb25maWcsIHNraXBTcGVlY2hlcyA9IFtdKSB7XG4gICAgY29uc3QgY3VycmVudENvbmZpZyA9IHRoaXMuX2dldENvbmZpZygpO1xuICAgIGlmICghY29uZmlnKSB7XG4gICAgICByZXR1cm4gY3VycmVudENvbmZpZztcbiAgICB9XG5cbiAgICB0aGlzLl9pc1ZhbGlkYXRlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGN1cnJlbnRDb25maWdTdHIgPSBKU09OLnN0cmluZ2lmeShjdXJyZW50Q29uZmlnKTtcblxuICAgIC8vIFVwZGF0ZSBvcHRpb25zXG4gICAgaWYgKGNvbmZpZy5FbmdpbmUpIHtcbiAgICAgIHRoaXMuX2VuZ2luZSA9IGNvbmZpZy5FbmdpbmU7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5hdWRpb0Zvcm1hdCkge1xuICAgICAgdGhpcy5fYXVkaW9Gb3JtYXQgPSBjb25maWcuYXVkaW9Gb3JtYXQ7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5TYW1wbGVSYXRlKSB7XG4gICAgICB0aGlzLl9zYW1wbGVSYXRlID0gY29uZmlnLlNhbXBsZVJhdGU7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5Wb2ljZUlkKSB7XG4gICAgICB0aGlzLl92b2ljZSA9IGNvbmZpZy5Wb2ljZUlkO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuTGFuZ3VhZ2UpIHtcbiAgICAgIHRoaXMuX2xhbmd1YWdlID0gY29uZmlnLkxhbmd1YWdlO1xuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIHRoZSBjb25maWdcbiAgICBjb25zdCB2YWxpZENvbmZpZyA9IHRoaXMuX2dldENvbmZpZygpO1xuXG4gICAgLy8gRXhpdCBpZiBub3RoaW5nIGhhcyBjaGFuZ2VkXG4gICAgY29uc3QgY29uZmlnU3RyID0gSlNPTi5zdHJpbmdpZnkodmFsaWRDb25maWcpO1xuICAgIGlmIChjdXJyZW50Q29uZmlnU3RyID09PSBjb25maWdTdHIpIHtcbiAgICAgIHRoaXMuX2lzVmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB2YWxpZENvbmZpZztcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgYWxsIGNhY2hlZCBjb25maWdzXG4gICAgT2JqZWN0LmVudHJpZXModGhpcy5fc3BlZWNoQ2FjaGUpLmZvckVhY2goKFt0ZXh0LCBzcGVlY2hdKSA9PiB7XG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgc2tpcHBlZCBzcGVlY2hcbiAgICAgIGlmIChza2lwU3BlZWNoZXMuaW5jbHVkZXModGV4dCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzcGVlY2hDb25maWdTdHIgPSBKU09OLnN0cmluZ2lmeShzcGVlY2guY29uZmlnKTtcblxuICAgICAgLy8gVXBkYXRlIHRoZSBzcGVlY2ggd2l0aCBuZXcgcGFyYW1ldGVyc1xuICAgICAgaWYgKHNwZWVjaENvbmZpZ1N0ciAhPT0gY29uZmlnU3RyKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVNwZWVjaCh0ZXh0LCB2YWxpZENvbmZpZyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdmFsaWRDb25maWc7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGFuIGV4aXN0aW5nIHNwZWVjaCwgb3IgYWRkIGEgbmV3IHNwZWVjaCB3aXRoIG5ldyBQb2xseSBwYXJhbWV0ZXJzIHdpdGhcbiAgICogb3B0aW9ucyBmcm9tIGEgZ2l2ZW4gY29uZmlnLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIFRoZSB0ZXh0IG9mIHRoZSBzcGVlY2ggdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIC0gUG9sbHkgcGFyYW1ldGVyIG9wdGlvbnMgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmb3JjZT1mYWxzZV0gLSBXaGV0aGVyIHRvIGZvcmNlIHRoZSBzcGVlY2ggdG8gYmUgdXBkYXRlZFxuICAgKiBpZiBubyBwYXJhbWV0ZXJzIGhhdmUgY2hhbmdlcy5cbiAgICpcbiAgICogQHJldHVybnMge0Fic3RyYWN0U3BlZWNofVxuICAgKi9cbiAgX3VwZGF0ZVNwZWVjaCh0ZXh0LCBjb25maWcsIGZvcmNlID0gZmFsc2UpIHtcbiAgICBjb25zdCBzcGVlY2ggPSB0aGlzLl9zcGVlY2hDYWNoZVt0ZXh0XSB8fCB7fTtcbiAgICAvLyBFeGl0IGlmIG5vdGhpbmcgaGFzIGNoYW5nZWQgYW5kIGZvcmNlIGlzIGZhbHNlXG4gICAgaWYgKFxuICAgICAgIWZvcmNlICYmXG4gICAgICBjb25maWcgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgc3BlZWNoLmNvbmZpZyAmJlxuICAgICAgSlNPTi5zdHJpbmdpZnkoY29uZmlnKSA9PT0gSlNPTi5zdHJpbmdpZnkoc3BlZWNoLmNvbmZpZylcbiAgICApIHtcbiAgICAgIHJldHVybiBzcGVlY2g7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIHNlcGFyYXRlIHBhcmFtZXRlcnMgZm9yIGF1ZGlvIGFuZCBzcGVlY2htYXJrIGdlbmVyYXRpb25cbiAgICBjb25zdCBhdWRpb1BhcmFtcyA9IHtcbiAgICAgIC4uLmNvbmZpZyxcbiAgICAgIFRleHQ6IHRleHQsXG4gICAgICBUZXh0VHlwZTogJ3NzbWwnLFxuICAgIH07XG4gICAgY29uc3Qgc3BlZWNobWFya1BhcmFtcyA9IHtcbiAgICAgIC4uLmF1ZGlvUGFyYW1zLFxuICAgICAgT3V0cHV0Rm9ybWF0OiAnanNvbicsXG4gICAgICBTcGVlY2hNYXJrVHlwZXM6IHNwZWVjaG1hcmtUeXBlcyxcbiAgICB9O1xuXG4gICAgLy8gR2VuZXJhdGUgYXVkaW8gYW5kIHNwZWVjaG1hcmtzXG4gICAgc3BlZWNoLmNvbmZpZyA9IGNvbmZpZztcbiAgICBzcGVlY2gucHJvbWlzZSA9IFByb21pc2UuYWxsKFtcbiAgICAgIHRoaXMuX3N5bnRoZXNpemVTcGVlY2htYXJrcyhzcGVlY2htYXJrUGFyYW1zKSxcbiAgICAgIHRoaXMuX3N5bnRoZXNpemVBdWRpbyhhdWRpb1BhcmFtcyksXG4gICAgXSkudGhlbihyZXN1bHRzID0+IHtcbiAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVTcGVlY2godGV4dCwgLi4ucmVzdWx0cyk7XG4gICAgfSk7XG4gICAgdGhpcy5fc3BlZWNoQ2FjaGVbdGV4dF0gPSBzcGVlY2g7XG5cbiAgICByZXR1cm4gc3BlZWNoO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBTcGVlY2ggb2JqZWN0IGZvciB0aGUgc3BlYWtlci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VG9TcGVlY2h9IHNwZWFrZXIgLSBUaGUgVGV4dFRvU3BlZWNoIGluc3RhbmNlIHRoYXQgd2lsbCBvd24gdGhlIHNwZWVjaC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUZXh0IG9mIHRoZSBzcGVlY2guXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzcGVlY2htYXJrcyAtIFNwZWVjaG1hcmtzIGZvciB0aGUgc3BlZWNoLlxuICAgKiBAcGFyYW0ge09iamVjdH0gYXVkaW9Db25maWcgLSBBdWRpbyBmb3IgdGhlIHNwZWVjaC5cbiAgICpcbiAgICogQHJldHVybnMge0Fic3RyYWN0U3BlZWNofVxuICAgKi9cbiAgX2NyZWF0ZVNwZWVjaCh0ZXh0LCBzcGVlY2htYXJrcywgYXVkaW9Db25maWcpIHtcbiAgICByZXR1cm4gbmV3IFNwZWVjaCh0aGlzLCB0ZXh0LCBzcGVlY2htYXJrcywgYXVkaW9Db25maWcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBwcmVzaWduZWQgVVJMIG9mIHNwZWVjaCBhdWRpbyBmb3IgdGhlIGdpdmVuIHNwZWVjaCB0ZXh0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gUGFyYW1ldGVycyBvYmplY3QgY29tcGF0aWJsZSB3aXRoIFBvbGx5LnN5bnRoZXNpemVTcGVlY2guXG4gICAqXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH0gUmVzb2x2ZXMgd2l0aCBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgYXVkaW8gVVJMLlxuICAgKi9cbiAgX3N5bnRoZXNpemVBdWRpbyhwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IERlZmVycmVkKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuU0VSVklDRVMucHJlc2lnbmVyLmdldFN5bnRoZXNpemVTcGVlY2hVcmwoXG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgZnVuY3Rpb24oZXJyb3IsIHVybCkge1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIHJlc29sdmUoe3VybH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYW5kIHBhcnNlcyBzcGVlY2htYXJrcyBmb3IgdGhlIGdpdmVuIHNwZWVjaCB0ZXh0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gUGFyYW1ldGVycyBvYmplY3QgY29tcGF0aWJsZSB3aXRoIFBvbGx5LnN5bnRoZXNpemVTcGVlY2guXG4gICAqXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH0gUmVzb2x2ZXMgd2l0aCBhbiBhcnJheSBvZiBzcGVlY2htYXJrIG9iamVjdHNcbiAgICovXG4gIF9zeW50aGVzaXplU3BlZWNobWFya3MocGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuU0VSVklDRVMucG9sbHlcbiAgICAgIC5zeW50aGVzaXplU3BlZWNoKHBhcmFtcylcbiAgICAgIC5wcm9taXNlKClcbiAgICAgIC50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgIC8vIENvbnZlcnQgY2hhcmNvZGVzIHRvIHN0cmluZ1xuICAgICAgICBjb25zdCBqc29uU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkocmVzdWx0LkF1ZGlvU3RyZWFtKTtcbiAgICAgICAgY29uc3QganNvbiA9IEpTT04ucGFyc2UoanNvblN0cmluZyk7XG4gICAgICAgIGNvbnN0IGRhdGFTdHIgPSBqc29uLmRhdGEubWFwKGMgPT4gU3RyaW5nLmZyb21DaGFyQ29kZShjKSkuam9pbignJyk7XG5cbiAgICAgICAgY29uc3QgbWFya1R5cGVzID0ge1xuICAgICAgICAgIHNlbnRlbmNlOiBbXSxcbiAgICAgICAgICB3b3JkOiBbXSxcbiAgICAgICAgICB2aXNlbWU6IFtdLFxuICAgICAgICAgIHNzbWw6IFtdLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlbmRNYXJrVHlwZXMgPSB7XG4gICAgICAgICAgc2VudGVuY2U6IG51bGwsXG4gICAgICAgICAgd29yZDogbnVsbCxcbiAgICAgICAgICB2aXNlbWU6IG51bGwsXG4gICAgICAgICAgc3NtbDogbnVsbCxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTcGxpdCBieSBlbmNsb3Npbmcge30gdG8gY3JlYXRlIHNwZWVjaG1hcmsgb2JqZWN0c1xuICAgICAgICBjb25zdCBzcGVlY2hNYXJrcyA9IFsuLi5kYXRhU3RyLm1hdGNoQWxsKC9cXHsuKj9cXH0oPz1cXG58JCkvZ20pXS5tYXAoXG4gICAgICAgICAgbWF0Y2ggPT4ge1xuICAgICAgICAgICAgY29uc3QgbWFyayA9IEpTT04ucGFyc2UobWF0Y2hbMF0pO1xuXG4gICAgICAgICAgICAvLyBTZXQgdGhlIGR1cmF0aW9uIG9mIHRoZSBsYXN0IHNwZWVjaG1hcmsgc3RvcmVkIG1hdGNoaW5nIHRoaXMgb25lJ3MgdHlwZVxuICAgICAgICAgICAgY29uc3QgbnVtTWFya3MgPSBtYXJrVHlwZXNbbWFyay50eXBlXS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobnVtTWFya3MgPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGxhc3RNYXJrID0gbWFya1R5cGVzW21hcmsudHlwZV1bbnVtTWFya3MgLSAxXTtcbiAgICAgICAgICAgICAgbGFzdE1hcmsuZHVyYXRpb24gPSBtYXJrLnRpbWUgLSBsYXN0TWFyay50aW1lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtYXJrVHlwZXNbbWFyay50eXBlXS5wdXNoKG1hcmspO1xuICAgICAgICAgICAgZW5kTWFya1R5cGVzW21hcmsudHlwZV0gPSBtYXJrO1xuICAgICAgICAgICAgcmV0dXJuIG1hcms7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEZpbmQgdGhlIHRpbWUgb2YgdGhlIGxhdGVzdCBzcGVlY2htYXJrXG4gICAgICAgIGNvbnN0IGVuZFRpbWVzID0gW107XG4gICAgICAgIGlmIChlbmRNYXJrVHlwZXMuc2VudGVuY2UpIHtcbiAgICAgICAgICBlbmRUaW1lcy5wdXNoKGVuZE1hcmtUeXBlcy5zZW50ZW5jZS50aW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kTWFya1R5cGVzLndvcmQpIHtcbiAgICAgICAgICBlbmRUaW1lcy5wdXNoKGVuZE1hcmtUeXBlcy53b3JkLnRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRNYXJrVHlwZXMudmlzZW1lKSB7XG4gICAgICAgICAgZW5kVGltZXMucHVzaChlbmRNYXJrVHlwZXMudmlzZW1lLnRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRNYXJrVHlwZXMuc3NtbCkge1xuICAgICAgICAgIGVuZFRpbWVzLnB1c2goZW5kTWFya1R5cGVzLnNzbWwudGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW5kVGltZSA9IE1hdGgubWF4KC4uLmVuZFRpbWVzKTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgZHVyYXRpb24gZm9yIHRoZSBlbmRpbmcgc3BlZWNoTWFya3Mgb2YgZWFjaCB0eXBlXG4gICAgICAgIGlmIChlbmRNYXJrVHlwZXMuc2VudGVuY2UpIHtcbiAgICAgICAgICBlbmRNYXJrVHlwZXMuc2VudGVuY2UuZHVyYXRpb24gPSBNYXRoLm1heChcbiAgICAgICAgICAgIHRoaXMuX21pbkVuZE1hcmtEdXJhdGlvbixcbiAgICAgICAgICAgIGVuZFRpbWUgLSBlbmRNYXJrVHlwZXMuc2VudGVuY2UudGltZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZE1hcmtUeXBlcy53b3JkKSB7XG4gICAgICAgICAgZW5kTWFya1R5cGVzLndvcmQuZHVyYXRpb24gPSBNYXRoLm1heChcbiAgICAgICAgICAgIHRoaXMuX21pbkVuZE1hcmtEdXJhdGlvbixcbiAgICAgICAgICAgIGVuZFRpbWUgLSBlbmRNYXJrVHlwZXMud29yZC50aW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kTWFya1R5cGVzLnZpc2VtZSkge1xuICAgICAgICAgIGVuZE1hcmtUeXBlcy52aXNlbWUuZHVyYXRpb24gPSBNYXRoLm1heChcbiAgICAgICAgICAgIHRoaXMuX21pbkVuZE1hcmtEdXJhdGlvbixcbiAgICAgICAgICAgIGVuZFRpbWUgLSBlbmRNYXJrVHlwZXMudmlzZW1lLnRpbWVcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRNYXJrVHlwZXMuc3NtbCkge1xuICAgICAgICAgIGVuZE1hcmtUeXBlcy5zc21sLmR1cmF0aW9uID0gTWF0aC5tYXgoXG4gICAgICAgICAgICB0aGlzLl9taW5FbmRNYXJrRHVyYXRpb24sXG4gICAgICAgICAgICBlbmRUaW1lIC0gZW5kTWFya1R5cGVzLnNzbWwudGltZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3BlZWNoTWFya3M7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgU3BlZWNoIG9iamVjdCB0aGF0IGhhcyB0aGUgZ2l2ZW4gdGV4dC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCBjb250ZW50IG9mIHRoZSBTcGVlY2guXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gY29uZmlnIC0gT3B0aW9ucyB0byB1cGRhdGUgdGhlIFNwZWVjaCB3aXRoLlxuICAgKlxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9IFJlc29sdmVzIHdpdGggU3BlZWNoIG9yIG51bGw7XG4gICAqL1xuICBfZ2V0U3BlZWNoKHRleHQsIGNvbmZpZykge1xuICAgIC8vIE1ha2Ugc3VyZSBBV1Mgc2VydmljZXMgZXhpc3RcbiAgICBpZiAoIXRoaXMuY29uc3RydWN0b3IuaXNSZWFkeSkge1xuICAgICAgY29uc3QgZSA9ICdBV1Mgc2VydmljZXMgaGF2ZSBub3QgYmVlbiBpbml0aWFsaXplZC4nO1xuICAgICAgcmV0dXJuIERlZmVycmVkLnJlamVjdChlKTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgaXRzIHBvc3NpYmxlIHRvIGdlbmVyYXRlIHNwZWVjaGVzXG4gICAgaWYgKCF0ZXh0KSB7XG4gICAgICBjb25zdCBlID0gJ0Nhbm5vdCBwbGF5IGEgc3BlZWNoIHdpdGggbm8gdGV4dC4nO1xuICAgICAgcmV0dXJuIERlZmVycmVkLnJlamVjdChlKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGhlIHNwZWVjaCB3aXRoIG9wdGlvbnNcbiAgICB0ZXh0ID0gVGV4dFRvU3BlZWNoVXRpbHMudmFsaWRhdGVUZXh0KHRleHQpO1xuICAgIGNvbmZpZyA9IHRoaXMuX3VwZGF0ZUNvbmZpZyhjb25maWcsIHRleHQpO1xuXG4gICAgcmV0dXJuIHRoaXMuX3VwZGF0ZVNwZWVjaCh0ZXh0LCBjb25maWcpLnByb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIG5hbWVzcGFjZSB0byB0aGUgaG9zdCB3aXRoIHRoZSBuYW1lIG9mIHRoZSBmZWF0dXJlIHRvIGNvbnRhaW4gcHJvcGVydGllc1xuICAgKiBhbmQgbWV0aG9kcyBmcm9tIHRoZSBmZWF0dXJlIHRoYXQgdXNlcnMgb2YgdGhlIGhvc3QgbmVlZCBhY2Nlc3MgdG8uXG4gICAqXG4gICAqIEBzZWUgVGV4dFRvU3BlZWNoRmVhdHVyZVxuICAgKi9cbiAgaW5zdGFsbEFwaSgpIHtcbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKiBAbmFtZXNwYWNlIFRleHRUb1NwZWVjaEZlYXR1cmVcbiAgICAgKi9cbiAgICBjb25zdCBhcGkgPSBzdXBlci5pbnN0YWxsQXBpKCk7XG5cbiAgICBPYmplY3QuYXNzaWduKGFwaSwge1xuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgVGV4dFRvU3BlZWNoRmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAc2VlIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSNwbGF5XG4gICAgICAgKi9cbiAgICAgIHBsYXk6IHRoaXMucGxheS5iaW5kKHRoaXMpLFxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgVGV4dFRvU3BlZWNoRmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAc2VlIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSNwYXVzZVxuICAgICAgICovXG4gICAgICBwYXVzZTogdGhpcy5wYXVzZS5iaW5kKHRoaXMpLFxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgVGV4dFRvU3BlZWNoRmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAc2VlIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSNyZXN1bWVcbiAgICAgICAqL1xuICAgICAgcmVzdW1lOiB0aGlzLnJlc3VtZS5iaW5kKHRoaXMpLFxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgVGV4dFRvU3BlZWNoRmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAc2VlIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSNzdG9wXG4gICAgICAgKi9cbiAgICAgIHN0b3A6IHRoaXMuc3RvcC5iaW5kKHRoaXMpLFxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgVGV4dFRvU3BlZWNoRmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAc2VlIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSNnZXRWb2x1bWVcbiAgICAgICAqL1xuICAgICAgZ2V0Vm9sdW1lOiB0aGlzLmdldFZvbHVtZS5iaW5kKHRoaXMpLFxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgVGV4dFRvU3BlZWNoRmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAc2VlIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSNzZXRWb2x1bWVcbiAgICAgICAqL1xuICAgICAgc2V0Vm9sdW1lOiB0aGlzLnNldFZvbHVtZS5iaW5kKHRoaXMpLFxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgVGV4dFRvU3BlZWNoRmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAc2VlIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSNwYXVzZVZvbHVtZVxuICAgICAgICovXG4gICAgICBwYXVzZVZvbHVtZTogdGhpcy5wYXVzZVZvbHVtZS5iaW5kKHRoaXMpLFxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyb2YgVGV4dFRvU3BlZWNoRmVhdHVyZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAbWV0aG9kXG4gICAgICAgKiBAc2VlIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSNyZXN1bWVWb2x1bWVcbiAgICAgICAqL1xuICAgICAgcmVzdW1lVm9sdW1lOiB0aGlzLnJlc3VtZVZvbHVtZS5iaW5kKHRoaXMpLFxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoYXBpLCB7XG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXJvZiBUZXh0VG9TcGVlY2hGZWF0dXJlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqIEBzZWUgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlI3NwZWVjaG1hcmtPZmZzZXRcbiAgICAgICAqL1xuICAgICAgc3BlZWNobWFya09mZnNldDoge1xuICAgICAgICBnZXQ6ICgpID0+IHRoaXMuc3BlZWNobWFya09mZnNldCxcbiAgICAgICAgc2V0OiBvZmZzZXQgPT4ge1xuICAgICAgICAgIHRoaXMuc3BlZWNobWFya09mZnNldCA9IG9mZnNldDtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXBpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW5kIHNldHMgdGhlIHZvbHVtZSB1c2VkIGZvciBhbGwgYXVkaW8gY2xpcHMgcGxheWVkIGJ5IHRoZSBzcGVha2VyLlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgc2V0IHZvbHVtZSh2b2x1bWUpIHtcbiAgICB0aGlzLl92b2x1bWUgPSBNYXRoVXRpbHMuY2xhbXAodm9sdW1lKTtcbiAgfVxuXG4gIGdldCB2b2x1bWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZvbHVtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHdoZXRoZXIgb3Igbm90IHRoZSBzcGVha2VyJ3Mgdm9sdW1lIHZhbHVlIGlzIGN1cnJlbnRseSBiZWluZyB0d2VlbmVkLlxuICAgKlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgdm9sdW1lUGVuZGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZXMudm9sdW1lICYmIHRoaXMuX3Byb21pc2VzLnZvbHVtZS5wZW5kaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZvbHVtZSB1c2VkIGZvciBhbGwgYXVkaW8gY2xpcHMgcGxheWVkIGJ5IHRoZSBzcGVha2VyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0Vm9sdW1lKCkge1xuICAgIHJldHVybiB0aGlzLnZvbHVtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB2b2x1bWUgdXNlZCBmb3IgYWxsIGF1ZGlvIGNsaXBzIHBsYXllZCBieSB0aGUgc3BlYWtlciBvdmVyIHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2b2x1bWUgLSBUYXJnZXQgdm9sdW1lIHZhbHVlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NlY29uZHM9MF0gLSBBbW91bnQgb2YgdGltZSBpdCB3aWxsIHRha2UgdG8gcmVhY2ggdGhlIHRhcmdldFxuICAgKiB2b2x1bWUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBlYXNpbmdGbiAtIEVhc2luZyBmdW5jdGlvbiB1c2VkIGZvciBpbnRlcnBvbGF0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9XG4gICAqL1xuICBzZXRWb2x1bWUodm9sdW1lLCBzZWNvbmRzID0gMCwgZWFzaW5nRm4pIHtcbiAgICBpZiAodGhpcy52b2x1bWVQZW5kaW5nKSB7XG4gICAgICB0aGlzLl9wcm9taXNlcy52b2x1bWUuY2FuY2VsKCk7XG4gICAgfVxuXG4gICAgdm9sdW1lID0gTWF0aFV0aWxzLmNsYW1wKHZvbHVtZSk7XG4gICAgdGhpcy5fcHJvbWlzZXMudm9sdW1lID0gQW5pbWF0aW9uVXRpbHMuaW50ZXJwb2xhdGVQcm9wZXJ0eShcbiAgICAgIHRoaXMsXG4gICAgICAndm9sdW1lJyxcbiAgICAgIHZvbHVtZSxcbiAgICAgIHtzZWNvbmRzLCBlYXNpbmdGbn1cbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VzLnZvbHVtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXVzZSBpbnRlcnBvbGF0aW9uIGhhcHBlbmluZyBvbiB0aGUgc3BlYWtlcidzIHZvbHVtZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBwYXVzZVZvbHVtZSgpIHtcbiAgICB0aGlzLl92b2x1bWVQYXVzZWQgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRoaXMudm9sdW1lUGVuZGluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN1bWUgYW55IGludGVycG9sYXRpb24gaGFwcGVuaW5nIG9uIHRoZSBzcGVha2VyJ3Mgdm9sdW1lIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHJlc3VtZVZvbHVtZSgpIHtcbiAgICB0aGlzLl92b2x1bWVQYXVzZWQgPSBmYWxzZTtcblxuICAgIHJldHVybiB0aGlzLnZvbHVtZVBlbmRpbmc7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBjdXJyZW50bHkgcGxheWluZyBzcGVlY2guXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVRpbWUgLSBUaW1lIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZS5cbiAgICovXG4gIHVwZGF0ZShkZWx0YVRpbWUpIHtcbiAgICBpZiAoIXRoaXMuX3ZvbHVtZVBhdXNlZCkge1xuICAgICAgdGhpcy5fcHJvbWlzZXMudm9sdW1lLmV4ZWN1dGUoZGVsdGFUaW1lKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY3VycmVudFNwZWVjaCAmJiB0aGlzLl9jdXJyZW50U3BlZWNoLnBsYXlpbmcpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRTcGVlY2gudm9sdW1lID0gdGhpcy5fdm9sdW1lO1xuICAgICAgdGhpcy5fY3VycmVudFNwZWVjaC51cGRhdGUodGhpcy5faG9zdC5ub3cpO1xuICAgICAgc3VwZXIudXBkYXRlKGRlbHRhVGltZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY3VycmVudCBzcGVlY2ggdG8gYSBuZXcgYXNzZXQgYW5kIHVwZGF0ZSB0aGUgc3BlZWNoJ3Mgc3BlZWNobWFya1xuICAgKiBvZmZzZXQgdmFsdWUgdG8gbWF0Y2ggdGhhdCBvZiB0aGUgZmVhdHVyZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtBYnN0cmFjdFNwZWVjaH0gc3BlZWNoIC0gU3BlZWNoIHRvIHNldCBhcyBjdXJyZW50LlxuICAgKi9cbiAgX3NldEN1cnJlbnRTcGVlY2goc3BlZWNoKSB7XG4gICAgc3BlZWNoLnNwZWVjaG1hcmtPZmZzZXQgPSB0aGlzLl9zcGVlY2htYXJrT2Zmc2V0O1xuICAgIHRoaXMuX2N1cnJlbnRTcGVlY2ggPSBzcGVlY2g7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgcHJvbWlzZSB0aGF0IHdpbGwgcGxheS9yZXN1bWUgYSBzcGVlY2ggd2l0aCB0aGUgZ2l2ZW4gdGV4dCBhZnRlclxuICAgKiB0aGUgYXVkaW8gY29udGV4dCBhdHRlbXB0cyB0byByZXN1bWUgYW5kIHNwZWVjaCBhdWRpbyBpcyByZXRyaWV2ZWQgZnJvbSBQb2xseS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCBvZiB0aGUgbmV3IHNwZWVjaCB0byBwbGF5LlxuICAgKiBAcGFyYW0ge09iamVjdD19IGNvbmZpZyAtIE9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHRoZSBzcGVlY2guXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcGxheU1ldGhvZCA9ICdwbGF5J10gLSBNZXRob2QgdG8gZXhlY3V0ZSBvbiB0aGUgcmVzdWx0aW5nXG4gICAqIFNwZWVjaCBvYmplY3QuIFZhbGlkIG9wdGlvbnMgYXJlICdwbGF5JyBhbmQgJ3Jlc3VtZScuXG4gICAqL1xuICBfc3RhcnRTcGVlY2godGV4dCwgY29uZmlnLCBwbGF5TWV0aG9kID0gJ3BsYXknKSB7XG4gICAgLy8gSWYgbm8gdGV4dCBpcyBwcm92aWRlZCwgdHJ5IHRvIHVzZSB0aGUgY3VycmVudCBzcGVlY2hcbiAgICBpZiAodGV4dCA9PT0gdW5kZWZpbmVkICYmIHBsYXlNZXRob2QgPT09ICdyZXN1bWUnICYmIHRoaXMuX2N1cnJlbnRTcGVlY2gpIHtcbiAgICAgIHRleHQgPSB0aGlzLl9jdXJyZW50U3BlZWNoLnRleHQ7XG4gICAgfVxuXG4gICAgY29uc3QgY3VycmVudFByb21pc2UgPSB0aGlzLl9jdXJyZW50UHJvbWlzZSB8fCB7XG4gICAgICBwbGF5OiBuZXcgRGVmZXJyZWQoXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIGN1cnJlbnRQcm9taXNlLnNwZWVjaC5jYW5jZWwoKTtcbiAgICAgICAgfSxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIGN1cnJlbnRQcm9taXNlLnNwZWVjaC5jYW5jZWwoKTtcbiAgICAgICAgfSxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIGN1cnJlbnRQcm9taXNlLnNwZWVjaC5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHNwZWVjaDogbmV3IERlZmVycmVkKCksXG4gICAgfTtcbiAgICB0aGlzLl9jdXJyZW50UHJvbWlzZSA9IGN1cnJlbnRQcm9taXNlO1xuXG4gICAgdGhpcy5fZ2V0U3BlZWNoKHRleHQsIGNvbmZpZylcbiAgICAgIC50aGVuKHNwZWVjaCA9PiB7XG4gICAgICAgIC8vIEV4aXQgaWYgdGhlIHByb21pc2UgaXMgbm8gbG9uZ2VyIHBlbmRpbmcgYmVjYXVzZSBvZiB1c2VyIGludGVyYWN0aW9uXG4gICAgICAgIGlmICghY3VycmVudFByb21pc2UucGxheS5wZW5kaW5nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2N1cnJlbnRQcm9taXNlICE9PSBjdXJyZW50UHJvbWlzZSkge1xuICAgICAgICAgIC8vIENhbmNlbCBpZiBhbm90aGVyIGNhbGwgdG8gcGxheSBoYXMgYWxyZWFkeSBiZWVuIG1hZGVcbiAgICAgICAgICBjdXJyZW50UHJvbWlzZS5wbGF5LmNhbmNlbCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlc2V0IGN1cnJlbnQgc3BlZWNoIHdoZW4gdGhlIHNwZWVjaCBlbmRzXG4gICAgICAgIGNvbnN0IG9uRmluaXNoID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnRTcGVlY2ggPSBudWxsO1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDYW5jZWwgdGhlIGN1cnJlbnRseSBwbGF5aW5nIHNwZWVjaFxuICAgICAgICBpZiAodGhpcy5fY3VycmVudFNwZWVjaCAmJiB0aGlzLl9jdXJyZW50U3BlZWNoLnBsYXlpbmcpIHtcbiAgICAgICAgICBpZiAocGxheU1ldGhvZCA9PT0gJ3BsYXknKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50U3BlZWNoLmNhbmNlbCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICBwbGF5TWV0aG9kID09PSAncmVzdW1lJyAmJlxuICAgICAgICAgICAgdGhpcy5fY3VycmVudFNwZWVjaC5hdWRpbyAhPT0gc3BlZWNoLmF1ZGlvXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50U3BlZWNoLmNhbmNlbCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NldEN1cnJlbnRTcGVlY2goc3BlZWNoKTtcblxuICAgICAgICAvLyBQbGF5IHRoZSBzcGVlY2hcbiAgICAgICAgY3VycmVudFByb21pc2Uuc3BlZWNoID0gc3BlZWNoW3BsYXlNZXRob2RdKFxuICAgICAgICAgIHRoaXMuX2hvc3Qubm93LFxuICAgICAgICAgIG9uRmluaXNoLFxuICAgICAgICAgIG9uRmluaXNoLFxuICAgICAgICAgIG9uRmluaXNoXG4gICAgICAgICk7XG4gICAgICAgIGN1cnJlbnRQcm9taXNlLnNwZWVjaFxuICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UHJvbWlzZS5zcGVlY2gucmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgY3VycmVudFByb21pc2UucGxheS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjdXJyZW50UHJvbWlzZS5wbGF5LmNhbmNlbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgIGN1cnJlbnRQcm9taXNlLnBsYXkucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZSA9PiB7XG4gICAgICAgIGUgPSBgQ2Fubm90ICR7cGxheU1ldGhvZH0gc3BlZWNoICR7dGV4dH0gb24gaG9zdCAke3RoaXMuaG9zdC5pZH0uICR7ZX1gO1xuICAgICAgICBjdXJyZW50UHJvbWlzZS5wbGF5LnJlamVjdChlKTtcbiAgICAgIH0pO1xuXG4gICAgcmV0dXJuIGN1cnJlbnRQcm9taXNlLnBsYXk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCBhbnkgc3BlZWNoZXMgY3VycmVudGx5IHBsYXlpbmcgYW5kIHBsYXkgYSBuZXcgc3BlZWNoIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCBvZiB0aGUgbmV3IHNwZWVjaCB0byBwbGF5LlxuICAgKiBAcGFyYW0ge09iamVjdD19IGNvbmZpZyAtIE9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHRoZSBzcGVlY2guXG4gICAqXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH1cbiAgICovXG4gIHBsYXkodGV4dCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0U3BlZWNoKHRleHQsIGNvbmZpZywgJ3BsYXknKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBhIHNwZWVjaCBpcyBjdXJyZW50bHkgcGxheWluZywgcGF1c2UgaXQgYXQgdGhlIGN1cnJlbnQgdGltZS5cbiAgICovXG4gIHBhdXNlKCkge1xuICAgIGlmICh0aGlzLl9jdXJyZW50U3BlZWNoICYmIHRoaXMuX2N1cnJlbnRTcGVlY2gucGxheWluZykge1xuICAgICAgdGhpcy5fY3VycmVudFNwZWVjaC5wYXVzZSh0aGlzLl9ob3N0Lm5vdyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYENhbm5vdCBwYXVzZSBzcGVlY2ggb24gaG9zdCAke3RoaXMuaG9zdC5pZH0uIE5vIHNwZWVjaCBpcyBjdXJyZW50bHkgcGxheWluZ2BcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgYW55IHNwZWVjaGVzIGN1cnJlbnRseSBwbGF5aW5nIGFuZCByZXN1bWUgYSBuZXcgc3BlZWNoIGZyb20gdGhlIGN1cnJlbnRcbiAgICogdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmc9fSB0ZXh0IC0gVGhlIHRleHQgb2YgdGhlIG5ldyBzcGVlY2ggdG8gcGxheS4gSWYgdW5kZWZpbmVkIGFuZFxuICAgKiB0aGVyZSBpcyBhIGN1cnJlbnQgc3BlZWNoIHRoYXQgaXMgcGF1c2VkLCB0aGUgY3VycmVudCBzcGVlY2ggd2lsbCBiZSByZXN1bWVkLlxuICAgKiBAcGFyYW0ge09iamVjdD19IGNvbmZpZyAtIE9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHRoZSBzcGVlY2guXG4gICAqXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH1cbiAgICovXG4gIHJlc3VtZSh0ZXh0LCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhcnRTcGVlY2godGV4dCwgY29uZmlnLCAncmVzdW1lJyk7XG4gIH1cblxuICAvKipcbiAgICogSWYgYSBzcGVlY2ggaXMgY3VycmVudGx5IHBsYXlpbmcsIHN0b3AgcGxheWJhY2sgYW5kIHJlc2V0IHRpbWUuXG4gICAqL1xuICBzdG9wKCkge1xuICAgIGlmICh0aGlzLl9jdXJyZW50U3BlZWNoICYmIHRoaXMuX2N1cnJlbnRTcGVlY2gucGxheWluZykge1xuICAgICAgdGhpcy5fY3VycmVudFNwZWVjaC5zdG9wKCk7XG4gICAgICB0aGlzLl9jdXJyZW50U3BlZWNoID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgQ2Fubm90IHN0b3Agc3BlZWNoIG9uIGhvc3QgJHt0aGlzLmhvc3QuaWR9LiBObyBzcGVlY2ggaXMgY3VycmVudGx5IHBsYXlpbmcuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBkaXNjYXJkKCkge1xuICAgIGlmICh0aGlzLl9jdXJyZW50U3BlZWNoICYmIHRoaXMuX2N1cnJlbnRTcGVlY2gucGxheWluZykge1xuICAgICAgdGhpcy5fY3VycmVudFNwZWVjaC5zdG9wKCk7XG4gICAgfVxuXG4gICAgZGVsZXRlIHRoaXMuX3NwZWVjaENhY2hlO1xuXG4gICAgc3VwZXIuZGlzY2FyZCgpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSwge1xuICBBV1NfVkVSU0lPTjoge1xuICAgIGdldDogKCkgPT4gYXdzVmVyc2lvbixcbiAgfSxcbiAgUE9MTFlfTUlOX05FVVJBTF9WRVJTSU9OOiB7XG4gICAgdmFsdWU6ICcyLjUwMycsXG4gICAgd3JpdGFibGU6IGZhbHNlLFxuICB9LFxuICBQT0xMWV9ERUZBVUxUUzoge1xuICAgIHZhbHVlOiB7XG4gICAgICBFbmdpbmU6ICdzdGFuZGFyZCcsXG4gICAgICBMZXhpY29uTmFtZXM6IFtdLFxuICAgICAgT3V0cHV0Rm9ybWF0OiAnbXAzJyxcbiAgICAgIFNhbXBsZVJhdGU6ICcyMjA1MCcsXG4gICAgICBUZXh0OiAnJyxcbiAgICAgIFRleHRUeXBlOiAnc3NtbCcsXG4gICAgICBWb2ljZUlkOiAnQW15JyxcbiAgICAgIExhbmd1YWdlQ29kZTogJ2VuLUdCJyxcbiAgICAgIExhbmd1YWdlTmFtZTogJ0JyaXRpc2ggRW5nbGlzaCcsXG4gICAgfSxcbiAgICB3cml0YWJsZTogZmFsc2UsXG4gIH0sXG4gIFBPTExZX1ZPSUNFUzoge1xuICAgIHZhbHVlOiBbXSxcbiAgICB3cml0YWJsZTogZmFsc2UsXG4gIH0sXG4gIFBPTExZX0xBTkdVQUdFUzoge1xuICAgIHZhbHVlOiB7fSxcbiAgICB3cml0YWJsZTogZmFsc2UsXG4gIH0sXG4gIFBPTExZX0xBTkdVQUdFX0NPREVTOiB7XG4gICAgdmFsdWU6IHt9LFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgfSxcbiAgX2lzUmVhZHk6IHtcbiAgICB2YWx1ZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gIH0sXG4gIEVWRU5UUzoge1xuICAgIHZhbHVlOiB7XG4gICAgICAuLi5PYmplY3QuZ2V0UHJvdG90eXBlT2YoQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlKS5FVkVOVFMsXG4gICAgICByZWFkeTogJ29uUmVhZHlFdmVudCcsXG4gICAgICBwbGF5OiAnb25QbGF5RXZlbnQnLFxuICAgICAgcGF1c2U6ICdvblBhdXNlRXZlbnQnLFxuICAgICAgcmVzdW1lOiAnb25SZXN1bWVFdmVudCcsXG4gICAgICBpbnRlcnJ1cHQ6ICdvbkludGVycnVwdEV2ZW50JyxcbiAgICAgIHN0b3A6ICdvblN0b3BFdmVudCcsXG4gICAgICBzZW50ZW5jZTogJ29uU2VudGVuY2VFdmVudCcsXG4gICAgICB3b3JkOiAnb25Xb3JkRXZlbnQnLFxuICAgICAgdmlzZW1lOiAnb25WaXNlbWVFdmVudCcsXG4gICAgICBzc21sOiAnb25Tc21sRXZlbnQnLFxuICAgIH0sXG4gIH0sXG4gIFNFUlZJQ0VTOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIC4uLk9iamVjdC5nZXRQcm90b3R5cGVPZihBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUpLlNFUlZJQ0VTLFxuICAgICAgcG9sbHk6IHVuZGVmaW5lZCxcbiAgICAgIHByZXNpZ25lcjogdW5kZWZpbmVkLFxuICAgIH0sXG4gIH0sXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlO1xuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcbmltcG9ydCBTcGVlY2ggZnJvbSAnLi9TcGVlY2gnO1xuaW1wb3J0IERlZmVycmVkIGZyb20gJy4uL0RlZmVycmVkJztcbmltcG9ydCBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUgZnJvbSAnLi9BYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUnO1xuXG4vKipcbiAqIEBleHRlbmRzIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZVxuICogQGFsaWFzIGNvcmUvVGV4dFRvU3BlZWNoRmVhdHVyZVxuICovXG5jbGFzcyBUZXh0VG9TcGVlY2hGZWF0dXJlIGV4dGVuZHMgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuXG4gICAgdGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3NldEF1ZGlvQ29udGV4dCgpO1xuICAgIHRoaXMuX29ic2VydmVBdWRpb0NvbnRleHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9yZSB0aGUgYXVkaW8gY29udGV4dCB0aGF0IHdpbGwgYmUgdXNlZCB0byBlbnN1cmUgYXVkaW8gY2FuIGJlIHBsYXllZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRBdWRpb0NvbnRleHQoKSB7XG4gICAgdGhpcy5fYXVkaW9Db250ZXh0ID0gbmV3IEF1ZGlvQ29udGV4dCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3RlbiBmb3Igc3RhdGUgY2hhbmdlcyBvbiB0aGUgYXVkaW8gY29udGV4dCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgZmVhdHVyZVxuICAgKiBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29ic2VydmVBdWRpb0NvbnRleHQoKSB7XG4gICAgaWYgKHRoaXMuX2F1ZGlvQ29udGV4dCkge1xuICAgICAgdGhpcy5fYXVkaW9Db250ZXh0Lm9uc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9hdWRpb0NvbnRleHQuc3RhdGUgPT09ICdydW5uaW5nJykge1xuICAgICAgICAgIHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAnVGhlIGF1ZGlvIGNvbnRleHQgaXMgbm90IHJ1bm5pbmcuIFNwZWVjaCB3aWxsIG5vdCBiZSBhYmxlIHRvIGJlIHBsYXllZCB1bnRpbCBpdCBpcyByZXN1bWVkLiBVc2UgdGhlIFwiVGV4dFRvU3BlZWNoRmVhdHVyZS5yZXN1bWVBdWRpb1wiIG1ldGhvZCB0byB0cnkgdG8gcmVzdW1lIGl0IGFmdGVyIGEgdXNlciBnZXN0dXJlLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9hdWRpb0NvbnRleHQub25zdGF0ZWNoYW5nZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gQXVkaW8gb2JqZWN0IG9mIHNwZWVjaCBhdWRpbyBmb3IgdGhlIGdpdmVuIHNwZWVjaCB0ZXh0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gUGFyYW1ldGVycyBvYmplY3QgY29tcGF0aWJsZSB3aXRoIFBvbGx5LnN5bnRoZXNpemVTcGVlY2guXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBSZXNvbHZlcyB3aXRoIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBhdWRpbyBVUkwgYW5kIEF1ZGlvXG4gICAqIG9iamVjdC5cbiAgICovXG4gIF9zeW50aGVzaXplQXVkaW8ocGFyYW1zKSB7XG4gICAgcmV0dXJuIHN1cGVyLl9zeW50aGVzaXplQXVkaW8ocGFyYW1zKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICBjb25zdCB7dXJsfSA9IHJlc3VsdDtcblxuICAgICAgLy8gQ3JlYXRlIGFuIEF1ZGlvIG9iamVjdCB0aGF0IHBvaW50cyB0byB0aGUgcHJlc2lnbmVkIHVybFxuICAgICAgY29uc3QgYXVkaW8gPSBuZXcgQXVkaW8odXJsKTtcbiAgICAgIGF1ZGlvLmxvb3AgPSB0aGlzLmxvb3A7XG4gICAgICBhdWRpby5jcm9zc09yaWdpbiA9ICdhbm9ueW1vdXMnO1xuICAgICAgYXVkaW8ucHJlbG9hZCA9ICdhdXRvJztcbiAgICAgIHJlc3VsdC5hdWRpbyA9IGF1ZGlvO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIC8vIFJlc29sdmUgb25jZSB0aGUgbWluaW11bSBhbW91bnQgaXMgbG9hZGVkXG4gICAgICAgIGF1ZGlvLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnBsYXl0aHJvdWdoJywgKCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU3RhcnQgbG9hZGluZyB0aGUgYXVkaW9cbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhdWRpbyk7XG4gICAgICAgIGF1ZGlvLmxvYWQoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBTcGVlY2ggb2JqZWN0IGZvciB0aGUgc3BlYWtlci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VG9TcGVlY2h9IHNwZWFrZXIgLSBUaGUgVGV4dFRvU3BlZWNoIGluc3RhbmNlIHRoYXQgd2lsbCBvd24gdGhlIHNwZWVjaC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUZXh0IG9mIHRoZSBzcGVlY2guXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzcGVlY2htYXJrcyAtIFNwZWVjaG1hcmtzIGZvciB0aGUgc3BlZWNoLlxuICAgKiBAcGFyYW0ge09iamVjdH0gYXVkaW9Db25maWcgLSBBdWRpbyBmb3IgdGhlIHNwZWVjaC5cbiAgICpcbiAgICogQHJldHVybnMge0Fic3RyYWN0U3BlZWNofVxuICAgKi9cbiAgX2NyZWF0ZVNwZWVjaCh0ZXh0LCBzcGVlY2htYXJrcywgYXVkaW9Db25maWcpIHtcbiAgICByZXR1cm4gbmV3IFNwZWVjaCh0aGlzLCB0ZXh0LCBzcGVlY2htYXJrcywgYXVkaW9Db25maWcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgd2hldGhlciBvciBub3QgdGhlIGF1ZGlvIGNvbnRleHQgaXMgcnVubmluZyBhbmQgc3BlZWNoIGNhbiBiZSBwbGF5ZWQuXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBlbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyeSB0byByZXN1bWUgdGhlIGF1ZGlvIGNvbnRleHQuIFRoaXMgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGV4ZWN1dGVkIGVhY2ggdGltZVxuICAgKiBzcGVlY2ggaXMgcGxheWVkIG9yIHJlc3VtZWQuIElmIHVzaW5nIG1hbnVhbGx5LCBpdCBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIGFcbiAgICogdXNlciBpbnRlcmFjdGlvbiBvY2N1cnMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH0gLSBSZXNvbHZlcyBvbmNlIHRoZSBhdWRpbyBjb250ZXh0IGhhcyByZXN1bWVkLlxuICAgKi9cbiAgcmVzdW1lQXVkaW8oKSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBEZWZlcnJlZCgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLl9hdWRpb0NvbnRleHRcbiAgICAgICAgLnJlc3VtZSgpXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlID0+IHtcbiAgICAgICAgICB0aGlzLl9lbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIF9zdGFydFNwZWVjaCh0ZXh0LCBjb25maWcsIHBsYXlNZXRob2QgPSAncGxheScpIHtcbiAgICBjb25zdCBjdXJyZW50UHJvbWlzZSA9IHtcbiAgICAgIHBsYXk6IG5ldyBEZWZlcnJlZChcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgY3VycmVudFByb21pc2Uuc3BlZWNoLmNhbmNlbCgpO1xuICAgICAgICB9LFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgY3VycmVudFByb21pc2Uuc3BlZWNoLmNhbmNlbCgpO1xuICAgICAgICB9LFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgY3VycmVudFByb21pc2Uuc3BlZWNoLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgc3BlZWNoOiBuZXcgRGVmZXJyZWQoKSxcbiAgICB9O1xuICAgIHRoaXMuX2N1cnJlbnRQcm9taXNlID0gY3VycmVudFByb21pc2U7XG5cbiAgICAvLyBUcnkgdG8gc3RhcnQgdGhlIGF1ZGlvIGNvbnRleHRcbiAgICB0aGlzLnJlc3VtZUF1ZGlvKCkudGhlbigoKSA9PiB7XG4gICAgICAvLyBFeGl0IGlmIHRoZSBwcm9taXNlIGlzIG5vIGxvbmdlciBwZW5kaW5nIGJlY2F1c2Ugb2YgdXNlciBpbnRlcmFjdGlvblxuICAgICAgaWYgKCFjdXJyZW50UHJvbWlzZS5wbGF5LnBlbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gQ2FuY2VsIGlmIGFub3RoZXIgY2FsbCB0byBwbGF5IGhhcyBhbHJlYWR5IGJlZW4gbWFkZVxuICAgICAgZWxzZSBpZiAodGhpcy5fY3VycmVudFByb21pc2UgIT09IGN1cnJlbnRQcm9taXNlKSB7XG4gICAgICAgIGN1cnJlbnRQcm9taXNlLnBsYXkuY2FuY2VsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGF1ZGlvIGNvbnRleHQgaXMgcnVubmluZyBzbyB0aGUgc3BlZWNoIGNhbiBiZSBwbGF5ZWRcbiAgICAgIGlmICh0aGlzLl9lbmFibGVkKSB7XG4gICAgICAgIHN1cGVyLl9zdGFydFNwZWVjaCh0ZXh0LCBjb25maWcsIHBsYXlNZXRob2QpO1xuICAgICAgfVxuICAgICAgLy8gUmVqZWN0IGlmIHRoZSBhdWRpbyBjb250ZXh0IGlzIG5vdCBydW5uaW5nXG4gICAgICBlbHNlIHtcbiAgICAgICAgY3VycmVudFByb21pc2UucmVqZWN0KFxuICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBDYW5ub3QgJHtwbGF5TWV0aG9kfSBzcGVlY2ggb24gaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBUaGUgYXVkaW8gY29udGV4dCBpcyBub3QgcnVubmluZy4gVXNlIHRoZSBcIlRleHRUb1NwZWVjaEZlYXR1cmUucmVzdW1lQXVkaW9cIiBtZXRob2QgdG8gdHJ5IHRvIHJlc3VtZSBpdCBhZnRlciBhIHVzZXIgZ2VzdHVyZS5gXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGN1cnJlbnRQcm9taXNlLnBsYXk7XG4gIH1cblxuICBwbGF5KHRleHQsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLl9zdGFydFNwZWVjaCh0ZXh0LCBjb25maWcsICdwbGF5Jyk7XG4gIH1cblxuICByZXN1bWUodGV4dCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0U3BlZWNoKHRleHQsIGNvbmZpZywgJ3Jlc3VtZScpO1xuICB9XG5cbiAgaW5zdGFsbEFwaSgpIHtcbiAgICBjb25zdCBhcGkgPSBzdXBlci5pbnN0YWxsQXBpKCk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhhcGksIHtcbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlcm9mIFRleHRUb1NwZWVjaEZlYXR1cmVcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQHNlZSBjb3JlL1RleHRUb1NwZWVjaEZlYXR1cmUjZW5hYmxlZFxuICAgICAgICovXG4gICAgICBlbmFibGVkOiB7XG4gICAgICAgIGdldDogKCkgPT4gdGhpcy5fZW5hYmxlZCxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXBpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRleHRUb1NwZWVjaEZlYXR1cmU7XG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxuaW1wb3J0IFRleHRUb1NwZWVjaFV0aWxzIGZyb20gJy4vVGV4dFRvU3BlZWNoVXRpbHMnO1xuaW1wb3J0IEFic3RyYWN0U3BlZWNoIGZyb20gJy4vQWJzdHJhY3RTcGVlY2gnO1xuaW1wb3J0IFNwZWVjaCBmcm9tICcuL1NwZWVjaCc7XG5pbXBvcnQgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlIGZyb20gJy4vQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlJztcbmltcG9ydCBUZXh0VG9TcGVlY2hGZWF0dXJlIGZyb20gJy4vVGV4dFRvU3BlZWNoRmVhdHVyZSc7XG4vKipcbiAqIEBtb2R1bGUgY29yZS9hd3NwYWNrXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQge1xuICAvKipcbiAgICogQHNlZSBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmVcbiAgICovXG4gIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSxcbiAgLyoqXG4gICAqIEBzZWUgY29yZS9UZXh0VG9TcGVlY2hGZWF0dXJlXG4gICAqL1xuICBUZXh0VG9TcGVlY2hGZWF0dXJlLFxuICAvKipcbiAgICogQHNlZSBUZXh0VG9TcGVlY2hVdGlsc1xuICAgKi9cbiAgVGV4dFRvU3BlZWNoVXRpbHMsXG4gIC8qKlxuICAgKiBAc2VlIEFic3RyYWN0U3BlZWNoXG4gICAqL1xuICBBYnN0cmFjdFNwZWVjaCxcbiAgLyoqXG4gICAqIEBzZWUgY29yZS9TcGVlY2hcbiAgICovXG4gIFNwZWVjaCxcbn07XG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxuXG4vKipcbiAqIEBtb2R1bGUgaG9zdHMvY29yZVxuICovXG5cbmltcG9ydCBVdGlscyBmcm9tICcuL1V0aWxzJztcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSAnLi9NYXRoVXRpbHMnO1xuaW1wb3J0IERlZmVycmVkIGZyb20gJy4vRGVmZXJyZWQnO1xuaW1wb3J0IHtlbnZ9IGZyb20gJy4vSG9zdEVudmlyb25tZW50JztcbmltcG9ydCBNZXNzZW5nZXIgZnJvbSAnLi9NZXNzZW5nZXInO1xuaW1wb3J0IEhvc3RPYmplY3QgZnJvbSAnLi9Ib3N0T2JqZWN0JztcbmltcG9ydCBMaXBzeW5jRmVhdHVyZSwge0RlZmF1bHRWaXNlbWVNYXB9IGZyb20gJy4vTGlwc3luY0ZlYXR1cmUnO1xuaW1wb3J0IEdlc3R1cmVGZWF0dXJlLCB7RGVmYXVsdEdlc3R1cmVXb3Jkc30gZnJvbSAnLi9HZXN0dXJlRmVhdHVyZSc7XG5pbXBvcnQgUG9pbnRPZkludGVyZXN0RmVhdHVyZSwge0F4aXNNYXB9IGZyb20gJy4vUG9pbnRPZkludGVyZXN0RmVhdHVyZSc7XG5cbmltcG9ydCBhbmltcGFjayBmcm9tICcuL2FuaW1wYWNrJztcbmNvbnN0IHtcbiAgRWFzaW5nLFxuICBBbmltYXRpb25GZWF0dXJlLFxuICBBbmltYXRpb25UeXBlcyxcbiAgQW5pbWF0aW9uTGF5ZXIsXG4gIExheWVyQmxlbmRNb2RlcyxcbiAgRGVmYXVsdExheWVyQmxlbmRNb2RlLFxuICBTaW5nbGVTdGF0ZSxcbiAgVHJhbnNpdGlvblN0YXRlLFxuICBGcmVlQmxlbmRTdGF0ZSxcbiAgUXVldWVTdGF0ZSxcbiAgUmFuZG9tQW5pbWF0aW9uU3RhdGUsXG4gIEJsZW5kMWRTdGF0ZSxcbiAgQmxlbmQyZFN0YXRlLFxuICBBbmltYXRpb25VdGlscyxcbn0gPSBhbmltcGFjaztcblxuaW1wb3J0IGF3cyBmcm9tICcuL2F3c3BhY2snO1xuY29uc3Qge1xuICBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUsXG4gIFRleHRUb1NwZWVjaEZlYXR1cmUsXG4gIFRleHRUb1NwZWVjaFV0aWxzLFxuICBBYnN0cmFjdFNwZWVjaCxcbiAgU3BlZWNoLFxufSA9IGF3cztcblxuZXhwb3J0IGRlZmF1bHQge1xuICAvKipcbiAgICogQHNlZSBlbnZcbiAgICovXG4gIGVudixcbiAgLyoqXG4gICAqIEBzZWUgVXRpbHNcbiAgICovXG4gIFV0aWxzLFxuICAvKipcbiAgICogQHNlZSBNYXRoVXRpbHNcbiAgICovXG4gIE1hdGhVdGlscyxcbiAgLyoqXG4gICAqIEBzZWUgRGVmZXJyZWRcbiAgICovXG4gIERlZmVycmVkLFxuICAvKipcbiAgICogQHNlZSBjb3JlL01lc3NlbmdlclxuICAgKi9cbiAgTWVzc2VuZ2VyLFxuICAvKipcbiAgICogQHNlZSBjb3JlL0hvc3RPYmplY3RcbiAgICovXG4gIEhvc3RPYmplY3QsXG4gIC8qKlxuICAgKiBAc2VlIExpcHN5bmNGZWF0dXJlXG4gICAqL1xuICBMaXBzeW5jRmVhdHVyZSxcbiAgLyoqXG4gICAqIEBzZWUgR2VzdHVyZUZlYXR1cmVcbiAgICovXG4gIEdlc3R1cmVGZWF0dXJlLFxuICAvKipcbiAgICogQHNlZSBQb2ludE9mSW50ZXJlc3RGZWF0dXJlXG4gICAqL1xuICBQb2ludE9mSW50ZXJlc3RGZWF0dXJlLFxuICAvKipcbiAgICogQHNlZSBEZWZhdWx0VmlzZW1lTWFwXG4gICAqL1xuICBEZWZhdWx0VmlzZW1lTWFwLFxuICAvKipcbiAgICogQHNlZSBEZWZhdWx0R2VzdHVyZVdvcmRzXG4gICAqL1xuICBEZWZhdWx0R2VzdHVyZVdvcmRzLFxuICAvKipcbiAgICogQHNlZSBBeGlzTWFwXG4gICAqL1xuICBBeGlzTWFwLFxuXG4gIC8vIEFtbmltcGFja1xuICAvKipcbiAgICogQHNlZSBtb2R1bGU6Y29yZS9hbmltcGFjay5FYXNpbmdcbiAgICovXG4gIEVhc2luZyxcbiAgLyoqXG4gICAqIEBzZWUgbW9kdWxlOmNvcmUvYW5pbXBhY2suQW5pbWF0aW9uRmVhdHVyZVxuICAgKi9cbiAgQW5pbWF0aW9uRmVhdHVyZSxcbiAgLyoqXG4gICAqIEBzZWUgbW9kdWxlOmNvcmUvYW5pbXBhY2suQW5pbWF0aW9uTGF5ZXJcbiAgICovXG4gIEFuaW1hdGlvbkxheWVyLFxuICAvKipcbiAgICogQHNlZSBtb2R1bGU6Y29yZS9hbmltcGFjay5TaW5nbGVTdGF0ZVxuICAgKi9cbiAgU2luZ2xlU3RhdGUsXG4gIC8qKlxuICAgKiBAc2VlIG1vZHVsZTpjb3JlL2FuaW1wYWNrLlRyYW5zaXRpb25TdGF0ZVxuICAgKi9cbiAgVHJhbnNpdGlvblN0YXRlLFxuICAvKipcbiAgICogQHNlZSBtb2R1bGU6Y29yZS9hbmltcGFjay5GcmVlQmxlbmRTdGF0ZVxuICAgKi9cbiAgRnJlZUJsZW5kU3RhdGUsXG4gIC8qKlxuICAgKiBAc2VlIG1vZHVsZTpjb3JlL2FuaW1wYWNrLlF1ZXVlU3RhdGVcbiAgICovXG4gIFF1ZXVlU3RhdGUsXG4gIC8qKlxuICAgKiBAc2VlIG1vZHVsZTpjb3JlL2FuaW1wYWNrLlJhbmRvbUFuaW1hdGlvblN0YXRlXG4gICAqL1xuICBSYW5kb21BbmltYXRpb25TdGF0ZSxcbiAgLyoqXG4gICAqIEBzZWUgbW9kdWxlOmNvcmUvYW5pbXBhY2suQmxlbmQxZFN0YXRlXG4gICAqL1xuICBCbGVuZDFkU3RhdGUsXG4gIC8qKlxuICAgKiBAc2VlIG1vZHVsZTpjb3JlL2FuaW1wYWNrLkJsZW5kMmRTdGF0ZVxuICAgKi9cbiAgQmxlbmQyZFN0YXRlLFxuICAvKipcbiAgICogQHNlZSBtb2R1bGU6Y29yZS9hbmltcGFjay5BbmltYXRpb25VdGlsc1xuICAgKi9cbiAgQW5pbWF0aW9uVXRpbHMsXG4gIC8qKlxuICAgKiBAc2VlIG1vZHVsZTpjb3JlL2FuaW1wYWNrLkxheWVyQmxlbmRNb2Rlc1xuICAgKi9cbiAgTGF5ZXJCbGVuZE1vZGVzLFxuICAvKipcbiAgICogQHNlZSBtb2R1bGU6Y29yZS9hbmltcGFjay5EZWZhdWx0TGF5ZXJCbGVuZE1vZGVcbiAgICovXG4gIERlZmF1bHRMYXllckJsZW5kTW9kZSxcbiAgLyoqXG4gICAqIEBzZWUgbW9kdWxlOmNvcmUvYW5pbXBhY2suQW5pbWF0aW9uVHlwZXNcbiAgICovXG4gIEFuaW1hdGlvblR5cGVzLFxuXG4gIC8vIEFXUyBQYWNrXG4gIC8qKlxuICAgKiBAc2VlIG1vZHVsZTpjb3JlL2F3c3BhY2suQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlXG4gICAqL1xuICBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUsXG4gIC8qKlxuICAgKiBAc2VlIG1vZHVsZTpjb3JlL2F3c3BhY2suVGV4dFRvU3BlZWNoRmVhdHVyZVxuICAgKi9cbiAgVGV4dFRvU3BlZWNoRmVhdHVyZSxcbiAgLyoqXG4gICAqIEBzZWUgbW9kdWxlOmNvcmUvYXdzcGFjay5UZXh0VG9TcGVlY2hVdGlsc1xuICAgKi9cbiAgVGV4dFRvU3BlZWNoVXRpbHMsXG4gIC8qKlxuICAgKiBAc2VlIG1vZHVsZTpjb3JlL2F3c3BhY2suQWJzdHJhY3RTcGVlY2hcbiAgICovXG4gIEFic3RyYWN0U3BlZWNoLFxuICAvKipcbiAgICogQHNlZSBtb2R1bGU6Y29yZS9hd3NwYWNrLlNwZWVjaFxuICAgKi9cbiAgU3BlZWNoLFxufTtcbiJdLCJuYW1lcyI6WyJEZWZlcnJlZCIsImV4ZWN1dGFibGUiLCJvblJlc29sdmUiLCJvblJlamVjdCIsIm9uQ2FuY2VsIiwiRXJyb3IiLCJyZXMiLCJyZWoiLCJjYW5jZWwiLCJzdGF0dXMiLCJyZXNvbHZlZCIsInJlamVjdGVkIiwiY2FuY2VsZWQiLCJwZW5kaW5nIiwicmVzb2x2ZSIsInJlamVjdCIsInZhbHVlIiwiX3N0YXR1cyIsIl9yZXNvbHZlIiwiX3JlamVjdCIsIl9jYW5jZWwiLCJfZXhlY3V0YWJsZSIsImFyZ3MiLCJpdGVyYWJsZSIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiZSIsImFycmF5IiwiZGVmZXJyZWQiLCJmaWx0ZXIiLCJpdGVtIiwicmVzdWx0IiwidW5kZWZpbmVkIiwicmVzb2x2ZVZhbHVlIiwiZm9yRWFjaCIsImxlbmd0aCIsImVycm9yIiwiY2FuY2VsVmFsdWUiLCJudW1JdGVtcyIsIml0ZW1UcmFja2VyIiwiZmFpbGVkIiwibnVtUmVzb2x2ZWQiLCJyZXNvbHV0aW9ucyIsImluZGV4IiwiUHJvbWlzZSIsInRoZW4iLCJVdGlscyIsInJlcGxhY2UiLCJjIiwicmFuZG9tTnVtYmVyIiwiTWF0aCIsImZsb29yIiwiRGF0ZSIsIm5vdyIsInJhbmRvbSIsInRvU3RyaW5nIiwibmFtZSIsIm5hbWVBcnJheSIsImluY2x1ZGVzIiwibmFtZVNldCIsIlNldCIsIm1hdGNoR3JvdXAiLCJtYXRjaCIsImJhc2VOYW1lIiwic2xpY2UiLCJpbmNyZW1lbnQiLCJOdW1iZXIiLCJzZXROYW1lIiwic2V0TWF0Y2hHcm91cCIsInNldEluY3JlbWVudCIsInNlY29uZHMiLCJvbkZpbmlzaCIsIm9uUHJvZ3Jlc3MiLCJvbkVycm9yIiwiY29uc29sZSIsIndhcm4iLCJjdXJyZW50VGltZSIsInRvdGFsVGltZSIsIm9uVXBkYXRlIiwiZGVsdGFUaW1lIiwibWluIiwibWF4IiwiY2VpbCIsIlJhZGlhblRvRGVncmVlIiwiUEkiLCJEZWdyZWVUb1JhZGlhbiIsIk1hdGhVdGlscyIsInJhZGlhbnMiLCJkZWdyZWVzIiwiZnJvbSIsInRvIiwiZmFjdG9yIiwiYSIsImIiLCJwIiwiZGlzdFNxciIsImRpc3RhbmNlU3F1YXJlZCIsInQiLCJwb2ludCIsInZlcnRpY2VzIiwibWluWCIsIlBPU0lUSVZFX0lORklOSVRZIiwibWluWSIsIm1heFgiLCJORUdBVElWRV9JTkZJTklUWSIsIm1heFkiLCJ2IiwiZFgiLCJkWSIsIm1pZFgiLCJtaWRZIiwiZE1heCIsInN1cGVySW5kaWNlcyIsInZlcnRzV2l0aFN1cGVyIiwic3VwZXJTb3J0ZWRJbmRpY2VzIiwic29ydFBvaW50c0NDVyIsInN1cGVyVHJpYW5nbGUiLCJpbmRpY2VzIiwiZWRnZXMiLCJ0cmlhbmdsZXMiLCJuZXdWZXJ0IiwibmV3SW5kZXgiLCJpbnZhbGlkVHJpYW5nbGVzIiwidHJpYW5nbGUiLCJpc1BvaW50SW5DaXJjdW1DaXJjbGUiLCJwdXNoIiwiYm91bmRpbmdQb2x5IiwiZWRnZSIsImNvdW50Iiwib3RoZXJUcmlhbmdsZSIsIm90aGVyRWRnZSIsInNwbGljZSIsImluZGV4T2YiLCJzb3J0ZWRJbmRpY2VzIiwidHJpYW5nbGVzVG9SZW1vdmUiLCJtYXAiLCJheCIsImF5IiwiYngiLCJieSIsImN4IiwiY3kiLCJkZW5vbSIsImFWYWwiLCJiVmFsIiwiY1ZhbCIsImNlbnRyb2lkIiwic29ydCIsImF0YW4yIiwiYWJzIiwidmVjdG9yIiwiQXJyYXkiLCJyZWR1Y2VyIiwiYWNjdW11bGF0b3IiLCJjdXJyZW50VmFsdWUiLCJzcXJ0IiwicmVkdWNlIiwidmVjdG9yQSIsInZlY3RvckIiLCJ2YWx1ZUEiLCJ2YWx1ZUIiLCJub3JtYWxBIiwibm9ybWFsaXplVmVjdG9yIiwibm9ybWFsQiIsImRvdCIsImdldERvdFByb2R1Y3QiLCJhY29zIiwiY2xhbXAiLCJ2ZWN0b3IzIiwibWF0cml4MyIsImV2ZXJ5IiwieCIsInkiLCJ6IiwibWFnbml0dWRlIiwiZ2V0VmVjdG9yTWFnbml0dWRlIiwiZmlsbCIsIm1hdHJpeDQiLCJzY2FsZVgiLCJzY2FsZVkiLCJzY2FsZVoiLCJyIiwidGFyZ2V0VmFsdWUiLCJ2YWx1ZVN0b3JlIiwic21vb3RoVGltZSIsIm1heFNwZWVkIiwiY2xhbXBUaW1lIiwiZGVsdGFWYWx1ZSIsImNsYW1wRGVsdGFWYWx1ZSIsImxhc3RWYWx1ZSIsImQxIiwiZDIiLCJkMyIsImQ0IiwiZW52IiwiTWVzc2VuZ2VyIiwiaWQiLCJfaWQiLCJjcmVhdGVJZCIsIl9kaXNwYXRjaGVyIiwid2luZG93IiwiX2NhbGxiYWNrcyIsIl9ldmVudExpc3RlbmVycyIsIm1lc3NhZ2UiLCJjYWxsYmFjayIsImRldGFpbCIsIkN1c3RvbUV2ZW50IiwibGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwiX2NyZWF0ZUxvY2FsTWVzc2FnZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJfY3JlYXRlTGlzdGVuZXIiLCJfYWRkTGlzdGVuZXIiLCJpIiwic3RvcExpc3RlbmluZyIsIl9yZW1vdmVMaXN0ZW5lciIsInJlZ2V4cCIsIm1lc3NhZ2VzIiwiT2JqZWN0Iiwia2V5cyIsInRlc3QiLCJldmVudCIsIl9jcmVhdGVFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJtZXNzZW5nZXIiLCJHbG9iYWxNZXNzZW5nZXIiLCJsaXN0ZW5UbyIsInN0b3BMaXN0ZW5pbmdUb0FsbCIsImVtaXQiLCJkZWZpbmVQcm9wZXJ0aWVzIiwid3JpdGFibGUiLCJFVkVOVFMiLCJBYnN0cmFjdEhvc3RGZWF0dXJlIiwiaG9zdCIsIl9ob3N0IiwiZXZlbnRzIiwiYXBpIiwiZW50cmllcyIsImNvbnN0cnVjdG9yIiwib3duZXIiLCJzdG9wTGlzdGVuaW5nQnlSZWdleHAiLCJ1cGRhdGUiLCJSZWdFeHAiLCJzb3VyY2UiLCJSZXN1bHRDbGFzcyIsIm1peGluQ2xhc3NGYWN0b3JpZXMiLCJtaXhpbkNsYXNzRmFjdG9yeSIsIlNFUlZJQ0VTIiwiSG9zdE9iamVjdCIsIl9vd25lciIsIl9mZWF0dXJlcyIsIl93YWl0cyIsIl9sYXN0VXBkYXRlIiwiZHQiLCJ3YWl0IiwiZXhlY3V0ZSIsInZhbHVlcyIsImZlYXR1cmUiLCJvbkNvbXBsZXRlIiwiRmVhdHVyZUNsYXNzIiwiZm9yY2UiLCJpbnB1dFR5cGUiLCJwcm90b3R5cGUiLCJpbnN0YWxsQXBpIiwiYWRkRmVhdHVyZSIsInR5cGVOYW1lIiwicmVtb3ZlRmVhdHVyZSIsImRpc2NhcmQiLCJkZWZpbmVQcm9wZXJ0eSIsImdldFByb3RvdHlwZU9mIiwiTGluZWFyIiwiTm9uZSIsImsiLCJJbiIsIk91dCIsIkluT3V0IiwiUXVhZHJhdGljIiwiQ3ViaWMiLCJRdWFydGljIiwiUXVpbnRpYyIsIlNpbnVzb2lkYWwiLCJjb3MiLCJzaW4iLCJFeHBvbmVudGlhbCIsIkNpcmN1bGFyIiwiRWxhc3RpYyIsInMiLCJhc2luIiwiQmFjayIsIkJvdW5jZSIsIkZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UiLCJCYXNlQ2xhc3MiLCJGZWF0dXJlRGVwZW5kZW50TWl4aW4iLCJfaW5pdGlhbGl6ZWQiLCJfb25GZWF0dXJlQWRkZWQiLCJiaW5kIiwiX29uRmVhdHVyZVJlbW92ZWQiLCJFVkVOVF9ERVBFTkRFTkNJRVMiLCJldmVudE5hbWUiLCJBbmltYXRpb25GZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlIiwib2xkTmFtZSIsIm5ld05hbWUiLCJsYXllck5hbWUiLCJhbmltYXRpb25OYW1lIiwiUGFyZW50Q2xhc3MiLCJNaXhpbiIsIkFuaW1hdGlvbkZlYXR1cmVEZXBlbmRlbnRNaXhpbiIsIkFuaW1hdGlvbkZlYXR1cmUiLCJhZGRMYXllciIsInJlbW92ZUxheWVyIiwicmVuYW1lTGF5ZXIiLCJhZGRBbmltYXRpb24iLCJyZW1vdmVBbmltYXRpb24iLCJyZW5hbWVBbmltYXRpb24iLCJNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2UiLCJvcHRpb25zIiwibmFtZUZpbHRlciIsIndlaWdodCIsImVhc2luZ0ZuIiwiTWFuYWdlZEFuaW1hdGlvbkxheWVyTWl4aW4iLCJfbWFuYWdlZExheWVycyIsImxheWVycyIsIl9vbkxheWVyQWRkZWQiLCJfb25MYXllclJlbW92ZWQiLCJpc0FjdGl2ZSIsImdldEFuaW1hdGlvbnMiLCJhbmltTmFtZSIsIl9vbkFuaW1hdGlvbkFkZGVkIiwiYW5pbWF0aW9ucyIsIl9vbkFuaW1hdGlvblJlbW92ZWQiLCJsYXllck9wdGlvbnMiLCJhbmltT3B0aW9ucyIsIkRFRkFVTFRfTEFZRVJfT1BUSU9OUyIsImFuaW1hdGlvbk9wdGlvbnMiLCJhc3NpZ24iLCJyZWdpc3RlckFuaW1hdGlvbiIsInJlZ2lzdGVyTGF5ZXIiLCJsYXllck5hbWVzIiwic2V0TGF5ZXJXZWlnaHQiLCJibGVuZFRpbWUiLCJzZXRMYXllcldlaWdodHMiLCJlbmFibGUiLCJkaXNhYmxlIiwiVGV4dFRvU3BlZWNoRmVhdHVyZURlcGVuZGVudEludGVyZmFjZSIsIlRleHRUb1NwZWVjaEZlYXR1cmVEZXBlbmRlbnRNaXhpbiIsIlRleHRUb1NwZWVjaEZlYXR1cmUiLCJwbGF5IiwicGF1c2UiLCJyZXN1bWUiLCJzdG9wIiwic2VudGVuY2UiLCJ3b3JkIiwidmlzZW1lIiwic3NtbCIsIkRlZmF1bHRWaXNlbWVNYXAiLCJzaWwiLCJvdmVycmlkZVdlaWdodCIsIlMiLCJUIiwiZiIsInUiLCJFIiwibyIsIk8iLCJMaXBzeW5jRmVhdHVyZSIsInZpc2VtZUJsZW5kVGltZSIsImRlY2F5UmF0ZSIsImFtb3VudCIsInZpc2VtZUVhc2luZ0ZuIiwidmlzZW1lTGF5ZXJzIiwidGFsa2luZ0JsZW5kVGltZSIsInRhbGtpbmdFYXNpbmdGbiIsInRhbGtpbmdMYXllcnMiLCJ2aXNlbWVMZWFkVGltZSIsIl92aXNlbWVMYXllcnMiLCJfdGFsa2luZ0xheWVycyIsImFuaW1hdGlvbiIsInZpc2VtZU1hcCIsInJlZ2lzdGVyVmlzZW1lTGF5ZXIiLCJyZWdpc3RlclRhbGtpbmdMYXllciIsImdldEFuaW1hdGlvblR5cGUiLCJ3ZWlnaHROYW1lcyIsImdldEFuaW1hdGlvbkJsZW5kTmFtZXMiLCJ2aXNlbWVPcHRpb25zIiwic3BlZWNobWFya09mZnNldCIsIl92aXNlbWVMZWFkVGltZSIsIl9yZWdpc3RlclZpc2VtZUFuaW1hdGlvbiIsInJlc3VtZUFuaW1hdGlvbiIsIl9vblN0b3AiLCJfb25QbGF5IiwicGF1c2VBbmltYXRpb24iLCJtYXJrIiwiaXNWaXNlbWVBY3RpdmUiLCJ2aXNlbWVOYW1lcyIsImR1cmF0aW9uIiwibGVycEZhY3RvciIsImxlcnAiLCJibGVuZEluVGltZSIsImhvbGRUaW1lIiwiX2FuaW1hdGVTaW1wbGVWaXNlbWUiLCJkZWNheVdlaWdodCIsIl9hbmltYXRlSGVsZFZpc2VtZSIsInZpc2VtZU5hbWUiLCJwZWFrV2VpZ2h0IiwiYmxlbmRPdXRUaW1lIiwid2VpZ2h0UHJvbWlzZSIsInNldEFuaW1hdGlvbkJsZW5kV2VpZ2h0Iiwic3RhcnRQcm9taXNlIiwiaG9sZFByb21pc2UiLCJnZXQiLCJzZXQiLCJtaXgiLCJTU01MU3BlZWNobWFya0ludGVyZmFjZSIsIlNTTUxTcGVlY2hNYXJrTWl4aW4iLCJKU09OIiwicGFyc2UiLCJtZXRob2QiLCJhcHBseSIsIkRlZmF1bHRHZXN0dXJlV29yZHMiLCJiaWciLCJoZWFydCIsIm1hbnkiLCJtb3ZlbWVudCIsIm9uZSIsImFnZ3Jlc3NpdmUiLCJ5b3UiLCJkZWZlbnNlIiwid2F2ZSIsInNlbGYiLCJHZXN0dXJlRmVhdHVyZSIsIm1pbmltdW1JbnRlcnZhbCIsImxheWVyIiwibGF5ZXJIb2xkVGltZSIsImxheWVyTWluaW11bUludGVydmFsIiwiY2FuQWR2YW5jZSIsImlzUXVldWVFbmQiLCJjdXJyZW50R2VzdHVyZSIsIl9nZXRIb2xkVGltZSIsImhvbGRUaW1lciIsInBsYXlOZXh0QW5pbWF0aW9uIiwicGxheVRpbWVyIiwiYXV0b0Rpc2FibGUiLCJhbmltIiwid29yZHMiLCJnZXN0dXJlTWFwIiwidHJhbnNpdGlvblRpbWUiLCJrZXkiLCJzdHJpbmdpZnkiLCJnZW5lcmljR2VzdHVyZXMiLCJyZWFzb24iLCJfZ2V0TWluaW11bUludGVydmFsIiwicGxheUFuaW1hdGlvbiIsImdldFBhdXNlZCIsImNyZWF0ZUdlc3R1cmVNYXAiLCJjcmVhdGVHZW5lcmljR2VzdHVyZUFycmF5IiwicGxheUdlc3R1cmUiLCJzdG9wQW5pbWF0aW9uIiwiaW50ZXJydXB0QW5pbWF0aW9uIiwiQW5pbWF0aW9uVXRpbHMiLCJwcm9wZXJ0eU93bmVyIiwicHJvcGVydHlOYW1lIiwiaXNOYU4iLCJzdGFydFZhbHVlIiwiaW50ZXJwb2xhdG9yIiwicHJvZ3Jlc3MiLCJlYXNlRmFjdG9yIiwiQWJzdHJhY3RTdGF0ZSIsIl93ZWlnaHQiLCJfaW50ZXJuYWxXZWlnaHQiLCJfcGF1c2VkIiwiX3Byb21pc2VzIiwiZmluaXNoIiwiX3BsYXlDYWxsYmFja3MiLCJpbnRlcnBvbGF0ZVByb3BlcnR5IiwicHJvbWlzZSIsImFsbCIsInVwZGF0ZUludGVybmFsV2VpZ2h0IiwiVHJhbnNpdGlvblN0YXRlIiwiX3RvIiwiX2Zyb20iLCJfd2VpZ2h0UHJvbWlzZSIsInRvdGFsV2VpZ2h0Iiwic3RhdGUiLCJjdXJyZW50U3RhdGVzIiwidGFyZ2V0U3RhdGUiLCJkZWFjdGl2YXRlIiwicmVzZXQiLCJ3ZWlnaHRQcm9taXNlcyIsInNldFdlaWdodCIsIm9uTmV4dCIsInByb21pc2VzIiwiQW5pbWF0aW9uUGxheWVySW50ZXJmYWNlIiwiZm4iLCJwbGF5TWV0aG9kIiwiQW5pbWF0aW9uUGxheWVyTWl4aW4iLCJfdHJhbnNpdGlvblN0YXRlIiwiX3N0YXRlcyIsIk1hcCIsIl9jdXJyZW50U3RhdGUiLCJfdHJhbnNpdGlvblRpbWUiLCJfZWFzaW5nRm4iLCJoYXMiLCJjdXJyZW50QW5pbWF0aW9uIiwid2VpZ2h0UGVuZGluZyIsImNvbmZpZ3VyZSIsIl9wcmVwYXJlQ3VycmVudFN0YXRlIiwiU3RhdGVDb250YWluZXJJbnRlcmZhY2UiLCJjdXJyZW50TmFtZSIsIlN0YXRlQ29udGFpbmVyTWl4aW4iLCJ1bmlxdWVOYW1lIiwiZ2V0VW5pcXVlTmFtZSIsIlF1ZXVlU3RhdGUiLCJxdWV1ZVN0YXRlcyIsImFkZFN0YXRlIiwiX3F1ZXVlIiwiX2RvbmUiLCJpbnRlcm5hbFdlaWdodCIsIm5leHQiLCJkb25lIiwid3JhcCIsImxhc3ROYW1lIiwic2l6ZSIsImdldFN0YXRlIiwibG9vcENvdW50IiwiSW5maW5pdHkiLCJpc1RyYW5zaXRpb25pbmciLCJfcmVzZXQiLCJwYXVzZWQiLCJzdG9wcGVkIiwiZGlzY2FyZFN0YXRlcyIsIkFic3RyYWN0QmxlbmRTdGF0ZSIsImJsZW5kU3RhdGVzIiwiYmxlbmRXZWlnaHRzIiwiRnJlZUJsZW5kU3RhdGUiLCJzdW1XZWlnaHRzIiwiQmxlbmQxZFN0YXRlIiwiYmxlbmRUaHJlc2hvbGRzIiwicGhhc2VNYXRjaGVzIiwiX2JsZW5kVmFsdWUiLCJibGVuZFZhbHVlIiwibm9uWmVyb0RpZmZlcmVudFNpemUiLCJjb250YWluc0R1cGxpY2F0ZXMiLCJfdGhyZXNob2xkcyIsInBoYXNlTWF0Y2giLCJfc29ydFRocmVzaG9sZHMiLCJfZm9yY2VOb1RocmVzaG9sZER1cGVzIiwiX3BoYXNlTGVhZFN0YXRlIiwiX3VwZGF0ZUJsZW5kV2VpZ2h0cyIsInRocmVzaG9sZFZhbHVlIiwic2FtZVZhbHVlIiwiZmluZCIsInRocmVzaG9sZCIsInJlbW92ZWQiLCJmaW5kSW5kZXgiLCJub3JtYWxpemVkVGltZSIsInRhcmdldEluZGV4IiwidGhyZXNob2xkQSIsInRocmVzaG9sZEIiLCJmYWN0b3JCIiwiZmFjdG9yQSIsInN0YXRlQSIsInN0YXRlQiIsIkJsZW5kMmRTdGF0ZSIsIm90aGVyVGhyZXNob2xkIiwiX2JsZW5kVmFsdWVYIiwiX2JsZW5kVmFsdWVZIiwiYmxlbmRWYWx1ZVgiLCJibGVuZFZhbHVlWSIsIl92ZXJ0aWNlcyIsIl90cmlhbmdsZXMiLCJnZXREZWxhdW5heVRyaWFuZ3VsYXRpb24iLCJwcm9wZXJ0eSIsInRvVXBwZXJDYXNlIiwiX3NldEluZmx1ZW5jZUNsb3Nlc3RQb2ludE9uTGluZSIsImlzUG9pbnRJblRyaWFuZ2xlIiwiX3NldEluZmx1ZW5jZVRyaWFuZ2xlIiwiX3NldEluZmx1ZW5jZUNsb3Nlc3RQb2ludEluVHJpYW5nbGVzIiwiYXJlYUEiLCJ0cmlhbmdsZUFyZWEiLCJhcmVhQiIsImFyZWFDIiwidG90YWxBcmVhIiwid2VpZ2h0QSIsIndlaWdodEIiLCJ3ZWlnaHRDIiwidGhyZXNob2xkQyIsInN0YXRlQyIsIl9zZXRQaGFzZUxlYWRTdGF0ZSIsImdsb2JhbENsb3Nlc3RQb2ludCIsImdsb2JhbE1pbkRpc3QiLCJjbG9zZXN0VHJpYW5nbGUiLCJwb2ludEEiLCJjbG9zZXN0UG9pbnRPbkxpbmUiLCJwb2ludEIiLCJwb2ludEMiLCJkaXN0QSIsImRpc3RCIiwiZGlzdEMiLCJsb2NhbENsb3Nlc3RQb2ludCIsImxvY2FsTWluRGlzdCIsImNsb3Nlc3RQb2ludCIsInN0YXRlcyIsInBoYXNlTWF0Y2hlZCIsIkxheWVyQmxlbmRNb2RlcyIsIk92ZXJyaWRlIiwiQWRkaXRpdmUiLCJEZWZhdWx0TGF5ZXJCbGVuZE1vZGUiLCJ2YWxpZGF0ZUJsZW5kTW9kZSIsImJsZW5kTW9kZSIsIkFuaW1hdGlvbkxheWVyIiwiX2JsZW5kTW9kZSIsIl93ZWlnaHRQYXVzZWQiLCJpc1dlaWdodEFjdGl2ZSIsImdldFN0YXRlTmFtZXMiLCJibGVuZE5hbWUiLCJzZXRCbGVuZFdlaWdodCIsImdldEJsZW5kV2VpZ2h0IiwiU2luZ2xlU3RhdGUiLCJfdGltZVNjYWxlIiwidGltZVNjYWxlIiwiX2xvb3BDb3VudCIsInRpbWUiLCJSYW5kb21BbmltYXRpb25TdGF0ZSIsInN1YlN0YXRlcyIsIl9wbGF5SW50ZXJ2YWwiLCJwbGF5SW50ZXJ2YWwiLCJnZXRSYW5kb21GbG9hdCIsInBsYXlSYW5kb21BbmltYXRpb24iLCJ0aW1lciIsIl9yZXNldFRpbWVyIiwicmFuZG9tU3RhdGUiLCJnZXRSYW5kb21JbnQiLCJjYW5jZWxBbmltYXRpb24iLCJBbmltYXRpb25UeXBlcyIsInNpbmdsZSIsImZyZWVCbGVuZCIsInF1ZXVlIiwicmFuZG9tQW5pbWF0aW9uIiwiYmxlbmQxZCIsImJsZW5kMmQiLCJfbGF5ZXJzIiwiX2xheWVyTWFwIiwiZXhpc3RpbmciLCJsYXN0SW5kZXgiLCJudW1MYXllcnMiLCJ3ZWlnaHRNdWx0aXBsaWVyIiwiY3VycmVudFN0YXRlIiwiYmxlbmRTdGF0ZU9wdGlvbnMiLCJibGVuZE9wdGlvbnMiLCJfY3JlYXRlU2luZ2xlU3RhdGUiLCJxdWV1ZU9wdGlvbnMiLCJxdWV1ZU9wdGlvbiIsImJsZW5kTWF0Y2hQaGFzZXMiLCJzdWJTdGF0ZU9wdGlvbnMiLCJsYXllckluZGV4IiwiX3ZhbGlkYXRlSW5kZXgiLCJldmVudERhdGEiLCJjdXJyZW50SW5kZXgiLCJnZXRBbmltYXRpb25CbGVuZFdlaWdodCIsInBhdXNlV2VpZ2h0IiwicmVzdW1lV2VpZ2h0IiwiYW5pbWF0aW9uVHlwZSIsIl92YWxpZGF0ZU5ld0FuaW1hdGlvbiIsInJlbW92ZVN0YXRlIiwiY3VycmVudEFuaW1hdGlvbk5hbWUiLCJuZXdBbmltYXRpb25OYW1lIiwicmVuYW1lU3RhdGUiLCJuZXh0UXVldWVkQW5pbWF0aW9uIiwibCIsInJlc3VtZWQiLCJtb3ZlTGF5ZXIiLCJnZXRMYXllcldlaWdodCIsInBhdXNlTGF5ZXJXZWlnaHQiLCJyZXN1bWVMYXllcldlaWdodCIsInBhdXNlTGF5ZXIiLCJyZXN1bWVMYXllciIsImdldFRyYW5zaXRpb25pbmciLCJnZXRDdXJyZW50QW5pbWF0aW9uIiwiX3VwZGF0ZUludGVybmFsV2VpZ2h0cyIsIkF4aXNNYXAiLCJQb3NpdGl2ZVgiLCJOZWdhdGl2ZVgiLCJQb3NpdGl2ZVkiLCJOZWdhdGl2ZVkiLCJQb3NpdGl2ZVoiLCJOZWdhdGl2ZVoiLCJGYWNlVGFyZ2V0VHlwZXMiLCJFeWVDZW50ZXIiLCJFeWVMZWZ0IiwiRXllUmlnaHQiLCJNb3V0aCIsIkZhY2VWZWN0b3JzIiwiTWljcm9TYWNjYWRlV2FpdFJhbmdlcyIsInBvc3RNYWNybyIsIk1hY3JvU2FjY2FkZVdhaXRSYW5nZXMiLCJtb3V0aFRhcmdldCIsImV5ZVRhcmdldCIsIkJsaW5rVGhyZXNob2xkIiwiTWF4RGVsdGEiLCJQb2ludE9mSW50ZXJlc3RGZWF0dXJlIiwidGFyZ2V0IiwibG9va1RyYWNrZXIiLCJzY2VuZSIsImxvb2tCbGVuZFRpbWUiLCJsb29rRWFzaW5nRm4iLCJsb29rTGF5ZXJzIiwiYmxpbmtCbGVuZFRpbWUiLCJibGlua0Vhc2luZ0ZuIiwiYmxpbmtMYXllcnMiLCJfdmFsaWRhdGVUcmFuc2Zvcm1PYmplY3QiLCJfbG9va1RyYWNrZXIiLCJfc2NlbmUiLCJfdGFyZ2V0IiwiX3ByZXZUYXJnZXRQb3MiLCJfaXNUYXJnZXRNb3ZpbmciLCJfbG9va0xheWVycyIsIl90cmFja2luZ0NvbmZpZ3MiLCJfYmxpbmtMYXllcnMiLCJyZWZlcmVuY2UiLCJmb3J3YXJkQXhpcyIsImhhc1NhY2NhZGUiLCJyZWdpc3Rlckxvb2tMYXllciIsInJlZ2lzdGVyQmxpbmtMYXllciIsIl9yZWdpc3Rlckxvb2tBbmltYXRpb24iLCJjb25maWciLCJ0cmFja2luZ0NvbmZpZyIsImFuZ2xlcyIsImgiLCJwcmV2QW5nbGVzIiwic291cmNlUG9zaXRpb24iLCJfZ2V0V29ybGRQb3NpdGlvbiIsInRhcmdldFBvc2l0aW9uIiwibG9va1ZlY3RvciIsInRhcmdldFBvcyIsInRyYWNrZXJQb3MiLCJ0YXJnZXRTcGhlcmljYWwiLCJjYXJ0ZXNpYW5Ub1NwaGVyaWNhbCIsInRhcmdldEFuZ2xlcyIsIl9zcGhlcmljYWxUb0JsZW5kVmFsdWUiLCJyZWZEaXJlY3Rpb24iLCJfZ2V0T2JqZWN0RGlyZWN0aW9uIiwicmVmU3BoZXJpY2FsIiwicmVmQW5nbGVzIiwidGFyZ2V0VHlwZSIsImRpc3RhbmNlIiwiX2dldFRhcmdldERpc3RhbmNlIiwiZmFjZVZlY3RvciIsInNwaGVyaWNhbCIsImJsZW5kVmFsdWVzIiwibWF4SFNwZWVkIiwiZXhwIiwibWF4VlNwZWVkIiwiRDAiLCJkIiwiaER1cmF0aW9uIiwidkR1cmF0aW9uIiwibWljcm9TYWNjYWRlIiwiX3VwZGF0ZUxheWVyU3BlZWQiLCJfaW5pdGlhbGl6ZU1pY3JvVGltZXIiLCJtYWNyb1NhY2NhZGUiLCJtYWNyb1NhY2NhZGVXYWl0UmFuZ2UiLCJoTGltaXQiLCJoRmFjdG9yIiwidkxpbWl0IiwidkZhY3RvciIsInNhY2NhZGVUYXJnZXQiLCJfZ2V0RmFjZVRhcmdldEFuZ2xlcyIsIl9pbml0aWFsaXplTWFjcm9UaW1lciIsIm1pbldhaXRUaW1lIiwibWF4V2FpdFRpbWUiLCJ3YWl0VGltZSIsIm1pY3JvU2FjY2FkZVRpbWVyIiwiX3NldE1pY3JvU2FjY2FkZSIsIm1hY3JvU2FjY2FkZVRpbWVyIiwiX3NldE1hY3JvU2FjY2FkZSIsIl9hZGRUcmFja2luZ0NvbmZpZyIsImhWZWxvY2l0eSIsInZWZWxvY2l0eSIsIl9zZXRMb29rQW5nbGVzIiwiX3Jlc2V0TG9va0FuZ2xlcyIsImRlbHRhU2Vjb25kcyIsInRyaWdnZXJCbGluayIsImN1cnJlbnRIIiwiY3VycmVudFYiLCJ0YXJnZXRIIiwidGFyZ2V0ViIsInByZXZUYXJnZXRIIiwicHJldlRhcmdldFYiLCJjaGFuZ2VBbW91bnQiLCJ0b0RlZ3JlZXMiLCJnZXRBbmdsZUJldHdlZW4iLCJkYW1wVmFsdWUiLCJzZXRUYXJnZXQiLCJzZXRUYXJnZXRCeU5hbWUiLCJzZXRUYXJnZXRCeUlkIiwib2JqIiwiZm9yd2FyZFZlY3RvciIsInJvdGF0aW9uIiwiZ2V0Um90YXRpb25NYXRyaXgiLCJfZ2V0V29ybGRNYXRyaXgiLCJyb3RhdGVWZWN0b3IiLCJ0aGV0YSIsInBoaSIsIkVhc2luZyIsIlRleHRUb1NwZWVjaFV0aWxzIiwidGV4dCIsInJhbmRvbU1hcmtzIiwiaW50ZXJuYWxNYXAiLCJfcHJvY2Vzc0lucHV0TWFwIiwic3BlYWtUYWdzIiwic3NtbE1hcmtSZWdleCIsInNzbWxUYWdSZWdleCIsImV4aXN0aW5nVGFncyIsImV4ZWMiLCJzdGFydCIsImVuZCIsImNodW5rcyIsInNzbWxNYXJrUmVzdWx0IiwiZHVwbGljYXRlTWFya1RvQ2hlY2siLCJleGlzdGluZ1RhZyIsInN1YnN0ciIsIl9pbnNlcnRNYXJrcyIsIm1hcmtUZXh0IiwibWFya2VkVGV4dCIsImpvaW4iLCJhZGRNYXJrc1RvVW5tYXJrZWRTZW50ZW5jZXMiLCJ2YWxpZGF0ZVRleHQiLCJtYXJrcyIsIm1hcmtJbmRpY2VzIiwibWFya1Jlc3VsdCIsInNzbWxSZXN1bHQiLCJjbGVhbmVkVGV4dCIsImV4aXN0aW5nU3NtbCIsIndoaXRlc3BhY2UiLCJzZW50ZW5jZUVuZEluZGljZXMiLCJfZ2V0U2VudGVuY2VFbmRzIiwicHJldkluZGV4IiwidGFyZ2V0SW5kaWNlcyIsImNvbnRhaW5zTWFyayIsIm1hcmtJbmRleCIsInJhbmRvbU1hcmtlZFRleHQiLCJfaW5zZXJ0UmFuZG9tTWFya3NBdCIsIm9mZnNldCIsInJhbmRvbU1hcmsiLCJzZW50ZW5jZVJlZ2V4IiwiZW5kU2VudGVuY2VSZWdleCIsInNlbnRlbmNlRW5kcyIsInB1bmN0UmVzdWx0IiwiZHVwbGljYXRlc1RvQ2hlY2siLCJ3b3JkUmVnZXgiLCJsb3dlckNhc2VXb3JkIiwiY2hlY2tEdXBsaWNhdGUiLCJtYXJrZWRXb3JkcyIsInRvTG93ZXJDYXNlIiwiZXhpc3RpbmdNYXJrcyIsImxpc3QiLCJpc0FycmF5IiwiQWJzdHJhY3RTcGVlY2giLCJzcGVha2VyIiwic3BlZWNobWFya3MiLCJfc3BlYWtlciIsIl90ZXh0IiwiX3NwZWVjaG1hcmtzIiwiX3NwZWVjaG1hcmtPZmZzZXQiLCJfc3RhcnRUaW1lIiwiX2xvY2FsVGltZSIsIl9wYXVzZVRpbWUiLCJfcGxheWluZyIsIl9tYXJrSXRlciIsIl9jdXJyZW50TWFyayIsIl9lbmRUaW1lIiwiX3Byb21pc2UiLCJvbkludGVycnVwdCIsImludGVycnVwdCIsInR5cGUiLCJzcGVlY2giLCJfY2hlY2tGaW5pc2hlZCIsIl9jcmVhdGVQcm9taXNlIiwiU3BlZWNoIiwiYXVkaW9Db25maWciLCJfYXVkaW8iLCJhdWRpbyIsIm9uZW5kZWQiLCJfYXVkaW9GaW5pc2hlZCIsInZvbHVtZSIsInNldFRpbWVvdXQiLCJfcGxheUF1ZGlvIiwiX3BhdXNlQXVkaW8iLCJlbmdpbmVzIiwiYXVkaW9Gb3JtYXRzIiwic3BlZWNobWFya1R5cGVzIiwic2FtcGxlUmF0ZXMiLCJtcDMiLCJyYXRlcyIsImRlZmF1bHRzIiwic3RhbmRhcmQiLCJuZXVyYWwiLCJwY20iLCJvZ2dfdm9yYmlzIiwiYXdzVmVyc2lvbiIsIkFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSIsInZvaWNlIiwiZW5naW5lIiwibGFuZ3VhZ2UiLCJhdWRpb0Zvcm1hdCIsInNhbXBsZVJhdGUiLCJtaW5FbmRNYXJrRHVyYXRpb24iLCJpc0dsb2JhbCIsIl9zcGVlY2hDYWNoZSIsIl9jdXJyZW50U3BlZWNoIiwiX2N1cnJlbnRQcm9taXNlIiwiX2lzVmFsaWRhdGVkIiwiX2lzR2xvYmFsIiwiX3ZvbHVtZVBhdXNlZCIsIl92b2ljZSIsIlBPTExZX0RFRkFVTFRTIiwiVm9pY2VJZCIsIl9sYW5ndWFnZSIsIkxhbmd1YWdlTmFtZSIsIl9lbmdpbmUiLCJFbmdpbmUiLCJfYXVkaW9Gb3JtYXQiLCJPdXRwdXRGb3JtYXQiLCJfc2FtcGxlUmF0ZSIsIlNhbXBsZVJhdGUiLCJfbWluRW5kTWFya0R1cmF0aW9uIiwiQVdTX1ZFUlNJT04iLCJQT0xMWV9NSU5fTkVVUkFMX1ZFUlNJT04iLCJmb3JtYXQiLCJyYXRlIiwidm9pY2VJZCIsIlBPTExZX1ZPSUNFUyIsIklkIiwiU3VwcG9ydGVkRW5naW5lcyIsImxhbmd1YWdlQ29kZSIsIlBPTExZX0xBTkdVQUdFUyIsImF2YWlsYWJsZUNvZGVzIiwiTGFuZ3VhZ2VDb2RlIiwiQWRkaXRpb25hbExhbmd1YWdlQ29kZXMiLCJQT0xMWV9MQU5HVUFHRV9DT0RFUyIsIl92YWxpZGF0ZUVuZ2luZSIsIl92YWxpZGF0ZUZvcm1hdCIsIl92YWxpZGF0ZVJhdGUiLCJfdmFsaWRhdGVWb2ljZSIsIl92YWxpZGF0ZUxhbmd1YWdlIiwiaXNSZWFkeSIsIl92YWxpZGF0ZSIsInNraXBTcGVlY2hlcyIsImN1cnJlbnRDb25maWciLCJfZ2V0Q29uZmlnIiwiY3VycmVudENvbmZpZ1N0ciIsIkxhbmd1YWdlIiwidmFsaWRDb25maWciLCJjb25maWdTdHIiLCJzcGVlY2hDb25maWdTdHIiLCJfdXBkYXRlU3BlZWNoIiwiYXVkaW9QYXJhbXMiLCJUZXh0IiwiVGV4dFR5cGUiLCJzcGVlY2htYXJrUGFyYW1zIiwiU3BlZWNoTWFya1R5cGVzIiwiX3N5bnRoZXNpemVTcGVlY2htYXJrcyIsIl9zeW50aGVzaXplQXVkaW8iLCJyZXN1bHRzIiwiX2NyZWF0ZVNwZWVjaCIsInBhcmFtcyIsInByZXNpZ25lciIsImdldFN5bnRoZXNpemVTcGVlY2hVcmwiLCJ1cmwiLCJwb2xseSIsInN5bnRoZXNpemVTcGVlY2giLCJqc29uU3RyaW5nIiwiQXVkaW9TdHJlYW0iLCJqc29uIiwiZGF0YVN0ciIsImRhdGEiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJtYXJrVHlwZXMiLCJlbmRNYXJrVHlwZXMiLCJzcGVlY2hNYXJrcyIsIm1hdGNoQWxsIiwibnVtTWFya3MiLCJsYXN0TWFyayIsImVuZFRpbWVzIiwiZW5kVGltZSIsIl91cGRhdGVDb25maWciLCJnZXRWb2x1bWUiLCJzZXRWb2x1bWUiLCJwYXVzZVZvbHVtZSIsInJlc3VtZVZvbHVtZSIsIl92b2x1bWUiLCJ2b2x1bWVQZW5kaW5nIiwicGxheWluZyIsImN1cnJlbnRQcm9taXNlIiwiX2dldFNwZWVjaCIsIl9zZXRDdXJyZW50U3BlZWNoIiwiX3N0YXJ0U3BlZWNoIiwidmVyc2lvbiIsImN1c3RvbVVzZXJBZ2VudCIsIl93aXRoQ3VzdG9tVXNlckFnZW50Iiwic2VydmljZSIsIl9pc1JlYWR5IiwiYXZhaWxhYmxlVm9pY2VzIiwiYXZhaWxhYmxlTGFuZ3VhZ2VzIiwiYXZhaWxhYmxlTGFuZ3VhZ2VDb2RlcyIsIm1pbk5ldXJhbFNkayIsImRlc2NyaWJlVm9pY2VzIiwicmVzcG9uc2UiLCJhbGxDb2RlcyIsIlZvaWNlcyIsImNvZGUiLCJyZWFkeSIsImN1cnJlbnRVc2VyQWdlbnQiLCJzdW1lcmlhbkhvc3RzVXNlckFnZW50IiwiY29uY2F0IiwiTGV4aWNvbk5hbWVzIiwiX2VuYWJsZWQiLCJfc2V0QXVkaW9Db250ZXh0IiwiX29ic2VydmVBdWRpb0NvbnRleHQiLCJfYXVkaW9Db250ZXh0IiwiQXVkaW9Db250ZXh0Iiwib25zdGF0ZWNoYW5nZSIsIkF1ZGlvIiwibG9vcCIsImNyb3NzT3JpZ2luIiwicHJlbG9hZCIsImRvY3VtZW50IiwiYm9keSIsImFwcGVuZENoaWxkIiwibG9hZCIsInJlc3VtZUF1ZGlvIiwiZW5hYmxlZCIsImFuaW1wYWNrIiwiYXdzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///437\n')}},__webpack_require__={d:(e,t)=>{for(var n in t)__webpack_require__.o(t,n)&&!__webpack_require__.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},__webpack_exports__={};return __webpack_modules__[437](0,__webpack_exports__,__webpack_require__),__webpack_exports__=__webpack_exports__.default,__webpack_exports__})()}));