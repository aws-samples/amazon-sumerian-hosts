{"version":3,"file":"host.core.js","mappings":"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","sources":["webpack://HOST_CORE/webpack/universalModuleDefinition","webpack://HOST_CORE/./src/core/Deferred.js","webpack://HOST_CORE/./src/core/Utils.js","webpack://HOST_CORE/./src/core/MathUtils.js","webpack://HOST_CORE/./src/core/Messenger.js","webpack://HOST_CORE/./src/core/AbstractHostFeature.js","webpack://HOST_CORE/./src/core/HostObject.js","webpack://HOST_CORE/./src/core/animpack/Easing.js","webpack://HOST_CORE/./src/core/FeatureDependentInterface.js","webpack://HOST_CORE/./src/core/animpack/AnimationFeatureDependentInterface.js","webpack://HOST_CORE/./src/core/animpack/ManagedAnimationLayerInterface.js","webpack://HOST_CORE/./src/core/awspack/TextToSpeechFeatureDependentInterface.js","webpack://HOST_CORE/./src/core/LipsyncFeature.js","webpack://HOST_CORE/./src/core/awspack/SSMLSpeechmarkInterface.js","webpack://HOST_CORE/./src/core/GestureFeature.js","webpack://HOST_CORE/./src/core/animpack/AnimationUtils.js","webpack://HOST_CORE/./src/core/animpack/state/AbstractState.js","webpack://HOST_CORE/./src/core/animpack/state/TransitionState.js","webpack://HOST_CORE/./src/core/animpack/AnimationPlayerInterface.js","webpack://HOST_CORE/./src/core/animpack/state/StateContainerInterface.js","webpack://HOST_CORE/./src/core/animpack/state/QueueState.js","webpack://HOST_CORE/./src/core/animpack/state/AbstractBlendState.js","webpack://HOST_CORE/./src/core/animpack/state/FreeBlendState.js","webpack://HOST_CORE/./src/core/animpack/state/Blend1dState.js","webpack://HOST_CORE/./src/core/animpack/state/Blend2dState.js","webpack://HOST_CORE/./src/core/animpack/AnimationLayer.js","webpack://HOST_CORE/./src/core/animpack/state/SingleState.js","webpack://HOST_CORE/./src/core/animpack/state/RandomAnimationState.js","webpack://HOST_CORE/./src/core/animpack/AnimationFeature.js","webpack://HOST_CORE/./src/core/PointOfInterestFeature.js","webpack://HOST_CORE/./src/core/awspack/AbstractSpeech.js","webpack://HOST_CORE/./src/core/awspack/TextToSpeechUtils.js","webpack://HOST_CORE/./src/core/awspack/AbstractTextToSpeechFeature.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"HOST_CORE\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"HOST_CORE\"] = factory();\n\telse\n\t\troot[\"HOST_CORE\"] = factory();\n})((typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : this), function() {\nreturn ","// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n// SPDX-License-Identifier: MIT-0\r\n\r\n/**\r\n * The built-in class for asynchronous Promises.\r\n * @external Promise\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\r\n */\r\n\r\n/**\r\n * A Promise object that can be resolved, rejected or canceled at any time by the\r\n * user.\r\n *\r\n * @extends external:Promise\r\n */\r\nclass Deferred extends Promise {\r\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {Function} [executable=() => {}] - The function to be executed by the\r\n   * constructor, during the process of constructing the promise. The signature\r\n   * of this is expected to be: executable(  resolutionFunc, rejectionFunc, cancellationFunc ).\r\n   * @param {Function=} onResolve - Optional function to execute once the promise\r\n   * is resolved.\r\n   * @param {Function=} onReject - Optional function to execute once the promise\r\n   * is rejected.\r\n   * @param {Function=} onCancel - Optional function to execute if the user cancels\r\n   * the promise. Canceling results in the promise having a status of 'resolved'.\r\n   */\r\n  constructor(executable = () => {}, onResolve, onReject, onCancel) {\r\n    if (typeof executable !== 'function') {\r\n      throw new Error(\r\n        `Cannot create new Deferred. Executable must be a function.`\r\n      );\r\n    }\r\n\r\n    if (typeof onResolve !== 'undefined' && typeof onResolve !== 'function') {\r\n      throw new Error(\r\n        `Cannot create new Deferred. OnResolve must be a function.`\r\n      );\r\n    }\r\n\r\n    if (typeof onReject !== 'undefined' && typeof onReject !== 'function') {\r\n      throw new Error(\r\n        `Cannot create new Deferred. OnReject must be a function.`\r\n      );\r\n    }\r\n\r\n    if (typeof onCancel !== 'undefined' && typeof onCancel !== 'function') {\r\n      throw new Error(\r\n        `Cannot create new Deferred. OnCancel must be a function.`\r\n      );\r\n    }\r\n\r\n    let res;\r\n    let rej;\r\n    let cancel;\r\n    const status = {\r\n      resolved: false,\r\n      rejected: false,\r\n      canceled: false,\r\n      pending: true,\r\n    };\r\n\r\n    super((resolve, reject) => {\r\n      // Store the resolver\r\n      res = value => {\r\n        if (status.pending) {\r\n          status.resolved = true;\r\n          status.pending = false;\r\n\r\n          if (typeof onResolve === 'function') {\r\n            value = onResolve(value);\r\n          }\r\n\r\n          return resolve(value);\r\n        }\r\n      };\r\n\r\n      // Store the rejecter\r\n      rej = value => {\r\n        if (status.pending) {\r\n          status.rejected = true;\r\n          status.pending = false;\r\n\r\n          if (typeof onReject === 'function') {\r\n            value = onReject(value);\r\n          }\r\n\r\n          return reject(value);\r\n        }\r\n      };\r\n\r\n      // Store the canceler\r\n      cancel = value => {\r\n        if (status.pending) {\r\n          status.canceled = true;\r\n          status.pending = false;\r\n\r\n          if (typeof onCancel === 'function') {\r\n            value = onCancel(value);\r\n          }\r\n\r\n          return resolve(value);\r\n        }\r\n      };\r\n\r\n      // Run the executable with custom resolver and rejecter\r\n      executable(res, rej, cancel);\r\n    });\r\n\r\n    this._status = status;\r\n    this._resolve = res;\r\n    this._reject = rej;\r\n    this._cancel = cancel;\r\n    this._executable = executable;\r\n  }\r\n\r\n  /**\r\n   * Gets the resolved state of the promise.\r\n   *\r\n   * @readonly\r\n   */\r\n  get resolved() {\r\n    return this._status.resolved;\r\n  }\r\n\r\n  /**\r\n   * Gets the rejected state of the promise.\r\n   *\r\n   * @readonly\r\n   */\r\n  get rejected() {\r\n    return this._status.rejected;\r\n  }\r\n\r\n  /**\r\n   * Gets the canceled state of the promise.\r\n   *\r\n   * @readonly\r\n   */\r\n  get canceled() {\r\n    return this._status.canceled;\r\n  }\r\n\r\n  /**\r\n   * Gets the pending state of the promise.\r\n   *\r\n   * @readonly\r\n   */\r\n  get pending() {\r\n    return this._status.pending;\r\n  }\r\n\r\n  /**\r\n   * Force the promise to resolve.\r\n   *\r\n   * @param {any=} value - Value to pass to the resolver.\r\n   *\r\n   * @returns {any} - The return value of the resolver function.\r\n   */\r\n  resolve(value) {\r\n    return this._resolve(value);\r\n  }\r\n\r\n  /**\r\n   * Force the promise to reject.\r\n   *\r\n   * @param {any=} value - Value to pass to the rejecter.\r\n   *\r\n   * @returns {any} - The return value of the rejecter function.\r\n   */\r\n  reject(value) {\r\n    return this._reject(value);\r\n  }\r\n\r\n  /**\r\n   * Force the promise to resolve and set the canceled state to true.\r\n   *\r\n   * @param {any=} value - Value to pass to the canceller.\r\n   *\r\n   * @returns {any} - The return value of the canceller function.\r\n   */\r\n  cancel(value) {\r\n    return this._cancel(value);\r\n  }\r\n\r\n  /**\r\n   * Run the promise function to try to resolve the promise. Promise must be\r\n   * pending.\r\n   *\r\n   * @param {...any} args - Optional arguments to pass after resolve and reject.\r\n   */\r\n  execute(...args) {\r\n    if (this.pending) {\r\n      this._executable(this._resolve, this._reject, this._cancel, ...args);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return a canceled deferred promise.\r\n   *\r\n   * @param {any=} value - Value to cancel the promise with.\r\n   *\r\n   * @returns {Deferred}\r\n   */\r\n  static cancel(value) {\r\n    return new Deferred((_resolve, _reject, cancel) => {\r\n      cancel(value);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Return a new Deferred promise that will resolve or reject once all promises\r\n   * in the input array have been resolved or one promise is canceled or rejected.\r\n   * Promises in the array that are Deferred promises will be manually resolved,\r\n   * rejected or canceled when calling resolve, reject or cancel on the return promise.\r\n   *\r\n   * @param {Array.<any>} iterable - An iterable such as an array.\r\n   * @param {Function=} onResolve - Optional function to execute once the promise\r\n   * is resolved.\r\n   * @param {Function=} onReject - Optional function to execute once the promise\r\n   * is rejected.\r\n   * @param {Function=} onCancel - Optional function to execute if the user cancels\r\n   * the promise. Canceling results in the promise having a status of 'canceled'.\r\n   *\r\n   * @returns Deferred\r\n   */\r\n  static all(iterable, onResolve, onReject, onCancel) {\r\n    if (iterable == null || typeof iterable[Symbol.iterator] !== 'function') {\r\n      let e = `Cannot execute Deferred.all. First argument must be iterable.`;\r\n\r\n      if (typeof onReject === 'function') {\r\n        e = onReject(e);\r\n      }\r\n\r\n      return Deferred.reject(e);\r\n    }\r\n\r\n    const array = [...iterable];\r\n    const deferred = array.filter(item => item instanceof Deferred);\r\n\r\n    const result = new Deferred(\r\n      undefined,\r\n      resolveValue => {\r\n        deferred.forEach(item => {\r\n          item.resolve(resolveValue);\r\n        });\r\n        deferred.length = 0;\r\n\r\n        if (typeof onResolve === 'function') {\r\n          return onResolve(resolveValue);\r\n        } else {\r\n          return resolveValue;\r\n        }\r\n      },\r\n      error => {\r\n        deferred.forEach(item => {\r\n          item.reject(error);\r\n        });\r\n        deferred.length = 0;\r\n\r\n        if (typeof onReject === 'function') {\r\n          return onReject(error);\r\n        } else {\r\n          return error;\r\n        }\r\n      },\r\n      cancelValue => {\r\n        deferred.forEach(item => {\r\n          item.cancel(cancelValue);\r\n        });\r\n        deferred.length = 0;\r\n\r\n        if (typeof onCancel === 'function') {\r\n          return onCancel(cancelValue);\r\n        } else {\r\n          return cancelValue;\r\n        }\r\n      }\r\n    );\r\n\r\n    const numItems = array.length;\r\n    const itemTracker = {\r\n      failed: false,\r\n      numResolved: 0,\r\n      resolutions: []\r\n    }\r\n\r\n    array.forEach((item, index) => {\r\n      if (itemTracker.failed) {\r\n        return;\r\n      } else if (!(item instanceof Promise)) {\r\n        itemTracker.resolutions[index] = item;\r\n        itemTracker.numResolved += 1;\r\n\r\n        if (itemTracker.numResolved === numItems) {\r\n          result.resolve(itemTracker.resolutions);\r\n        }\r\n        return;\r\n      }\r\n\r\n      item.then(\r\n        value => {\r\n          if (!itemTracker.failed && !item.canceled) {\r\n            itemTracker.resolutions[index] = value;\r\n            itemTracker.numResolved += 1;\r\n\r\n            if (itemTracker.numResolved === numItems) {\r\n              result.resolve(itemTracker.resolutions);\r\n            }\r\n          } else if (!itemTracker.failed) {\r\n            itemTracker.failed = true;\r\n            result.cancel(value);\r\n          }\r\n        },\r\n        error => {\r\n          if (!itemTracker.failed) {\r\n            itemTracker.failed = true;\r\n            result.reject(error);\r\n          }\r\n        }\r\n      );\r\n    });\r\n\r\n    return result;\r\n  }\r\n}\r\n\r\nexport default Deferred;\r\n","// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n// SPDX-License-Identifier: MIT-0\r\nimport Deferred from 'core/Deferred';\r\n\r\n/**\r\n * A collection of useful generic functions.\r\n *\r\n * @hideconstructor\r\n */\r\nclass Utils {\r\n  /**\r\n   * @static\r\n   *\r\n   * Generate a unique id\r\n   *\r\n   * @returns {String}\r\n   */\r\n  static createId() {\r\n    return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, c => {\r\n      const randomNumber = Math.floor((Date.now() + Math.random() * 16) % 16);\r\n      if (c === 'x') {\r\n        return randomNumber.toString(16);\r\n      }\r\n      // Set bit 6 and 7 to 0 and 1\r\n      return ((randomNumber & 0x3) | 0x8).toString(16);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @static\r\n   *\r\n   * Check a name string against an array of strings to determine if it is unique.\r\n   * If it isn't, append incremented trailing integers to the end of the name\r\n   * until it is unique.\r\n   *\r\n   * @param {string} name - String name to make unique.\r\n   * @param {Array.<string>=} nameArray - Array of string names to check agains.\r\n   *\r\n   * @returns {string}\r\n   */\r\n  static getUniqueName(name, nameArray = []) {\r\n    // If the name isn't in the array return it right away\r\n    if (!nameArray.includes(name)) {\r\n      return name;\r\n    }\r\n\r\n    const nameSet = new Set(nameArray);\r\n\r\n    // Separate the name into string and trailing numbers\r\n    const matchGroup = name.match(/\\d*$/);\r\n    const {index} = matchGroup;\r\n    const baseName = name.slice(0, index);\r\n    let increment = Number(matchGroup[0]);\r\n\r\n    // Find the highest trailing number value for the base of the name\r\n    nameSet.forEach(setName => {\r\n      const setMatchGroup = setName.match(/\\d*$/);\r\n\r\n      if (setName.slice(0, setMatchGroup.index) === baseName) {\r\n        const setIncrement = Number(setMatchGroup[0]);\r\n\r\n        if (setIncrement > increment) {\r\n          increment = setIncrement;\r\n        }\r\n      }\r\n    });\r\n\r\n    // Increment the highest trailing number and append to the name\r\n    return `${baseName}${increment + 1}`;\r\n  }\r\n\r\n  /**\r\n   * Return a deferred promise that will wait a given number of seconds before\r\n   * resolving. Pass delta time in milliseconds to the deferred promise's execute\r\n   * method in an update loop to progress time.\r\n   *\r\n   * @param {number} [seconds=0] - Number of seconds to wait before resolving.\r\n   * @param {Object=} options - Optional options object\r\n   * @param {Function} [options.onFinish] - Callback to execute once the wait time\r\n   * is met.\r\n   * @param {Function=} options.onProgress - Callback to execute each time the wait\r\n   * time progresses towards the target number of seconds. The amount of progress\r\n   * as a 0-1 percentage is passed as an argument.\r\n   * @param {Function=} options.onCancel - Callback to execute if the user cancels\r\n   * the wait before completion.\r\n   * @param {Function=} options.onError - Callback to execute if the wait stops\r\n   * because an error is encountered. The error message is passed as a parameter.\r\n   *\r\n   * @returns {Deferred}\r\n   */\r\n  static wait(seconds = 0, {onFinish, onProgress, onCancel, onError} = {}) {\r\n    // Make sure seconds is numeric\r\n    if (typeof seconds !== 'number') {\r\n      console.warn(\r\n        `Invalid seconds value ${seconds} for wait. Defaulting to 0.`\r\n      );\r\n\r\n      seconds = 0;\r\n    }\r\n\r\n    // Resolve immediately if the wait time is not greater than 0\r\n    if (seconds <= 0) {\r\n      if (typeof onFinish === 'function') {\r\n        onFinish();\r\n      }\r\n\r\n      return Deferred.resolve();\r\n    }\r\n\r\n    let currentTime = 0;\r\n    const totalTime = seconds * 1000; // convert to milliseconds\r\n\r\n    // Executable to pass to Deferred, meant to be run in an update loop\r\n    const onUpdate = (resolve, reject, _cancel, deltaTime = 0) => {\r\n      if (typeof deltaTime !== 'number') {\r\n        const e = new Error(\r\n          `Invalid property wait deltaTime. DeltaTime must be a number.`\r\n        );\r\n        reject(e);\r\n        return;\r\n      }\r\n\r\n      // Make sure time has passed\r\n      if (deltaTime === 0) {\r\n        return;\r\n      }\r\n\r\n      // Signal progress\r\n      currentTime += deltaTime;\r\n      if (currentTime < 0) {\r\n        currentTime = 0;\r\n      }\r\n\r\n      if (typeof onProgress === 'function') {\r\n        onProgress(Math.min(currentTime / totalTime, 1));\r\n      }\r\n\r\n      // Signal completion once time is up\r\n      if (currentTime >= totalTime) {\r\n        resolve();\r\n      }\r\n    };\r\n\r\n    return new Deferred(onUpdate, onFinish, onError, onCancel);\r\n  }\r\n\r\n  /**\r\n    * Get a random float number between a min (inclusive) and max (exclusive) value\r\n    * @param {number} min minimum value\r\n    * @param {number} max maximum value\r\n    * @returns {float}\r\n    */\r\n  static getRandomFloat(min, max) {\r\n    return Math.random() * (max - min) + min;\r\n  }\r\n\r\n  /**\r\n    * Get a random integer number between a min (inclusive) and max (exclusive) value\r\n    * @param {number} min minimum value\r\n    * @param {number} max maximum value\r\n    * @returns {integer}\r\n    */\r\n  static getRandomInt(min, max) {\r\n    min = Math.ceil(min);\r\n    max = Math.floor(max);\r\n    return Math.floor(Math.random() * (max - min)) + min;\r\n  }\r\n}\r\n\r\nexport default Utils;\r\n","// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n// SPDX-License-Identifier: MIT-0\r\nconst RadianToDegree = 180 / Math.PI;\r\nconst DegreeToRadian = Math.PI / 180;\r\n\r\n/**\r\n * A collection of useful math functions.\r\n *\r\n * @hideconstructor\r\n */\r\nclass MathUtils {\r\n  /**\r\n   * Convert the given angle from radians to degrees.\r\n   *\r\n   * @param {number} radians - Angle in radians.\r\n   *\r\n   * @returns {number} - Angle in degrees.\r\n   */\r\n  static toDegrees(radians) {\r\n    return radians * RadianToDegree;\r\n  }\r\n\r\n  /**\r\n   * Convert the given angle from degrees to radians.\r\n   *\r\n   * @param {number} degrees - Angle in degrees.\r\n   *\r\n   * @returns {number} - Angle in radians.\r\n   */\r\n  static toRadians(degrees) {\r\n    return degrees * DegreeToRadian;\r\n  }\r\n\r\n  /**\r\n   * Linearly interpolate between two values.\r\n   *\r\n   * @param {number} from - Start value.\r\n   * @param {number} to - Target value.\r\n   * @param {number} factor - 0-1 amount to interpolate between from and to.\r\n   *\r\n   * @returns {number}\r\n   */\r\n  static lerp(from, to, factor) {\r\n    return from + (to - from) * factor;\r\n  }\r\n\r\n  /**\r\n   * Clamp a number between 2 values.\r\n   *\r\n   * @param {number} value - Value to clamp.\r\n   * @param {number} [min=0] - Minumum value.\r\n   * @param {number} [max=1] - Maximum value.\r\n   *\r\n   * @returns {number}\r\n   */\r\n  static clamp(value, min = 0, max = 1) {\r\n    return Math.max(min, Math.min(value, max));\r\n  }\r\n\r\n  /**\r\n   * Calculates the closest point on a given 2D line segement\r\n   * from a given 2D point.\r\n   *\r\n   * @param {Array.<number>} a - First point on line segment.\r\n   * @param {Array.<number>} b - Second point on line segment.\r\n   * @param {Array.<number>} p - 2D point.\r\n   *\r\n   * @returns {Array.<number>}\r\n   */\r\n  static closestPointOnLine(a, b, p) {\r\n    const distSqr = MathUtils.distanceSquared(a, b);\r\n\r\n    // Line segment is a single point\r\n    if (distSqr === 0) {\r\n      return a;\r\n    }\r\n\r\n    const t =\r\n      ((p[0] - a[0]) * (b[0] - a[0]) + (p[1] - a[1]) * (b[1] - a[1])) / distSqr;\r\n\r\n    let point = [...a];\r\n    if (t > 1) {\r\n      point = [...b];\r\n    } else if (t > 0) {\r\n      point = [a[0] + t * (b[0] - a[0]), a[1] + t * (b[1] - a[1])];\r\n    }\r\n\r\n    return point;\r\n  }\r\n\r\n  /**\r\n   * Gets the distance squared for two 2D points.\r\n   * @param {Array.<number>} a - 2D point.\r\n   * @param {Array.<number>} b - 2D point.\r\n   *\r\n   * @returns {number}\r\n   */\r\n  static distanceSquared(a, b) {\r\n    return (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]);\r\n  }\r\n\r\n  /**\r\n   * Triangulates a set of 2D points using an implementation\r\n   * of the Bowyer-Watson incremental Delaunay triangulation.\r\n   *\r\n   * @param {Array.<Array.<number>>} vertices - Array of 2D points.\r\n   *\r\n   * @returns {Array.<Array<number>>} - Array of triangle indices.\r\n   */\r\n  static getDelaunayTriangulation(vertices) {\r\n    if (!vertices || vertices.length < 3) {\r\n      throw new Error(\r\n        `Cannot get delaunay triangulation for points ${vertices}. Input must contain at least three points.`\r\n      );\r\n    }\r\n\r\n    let minX = Number.POSITIVE_INFINITY;\r\n    let minY = Number.POSITIVE_INFINITY;\r\n    let maxX = Number.NEGATIVE_INFINITY;\r\n    let maxY = Number.NEGATIVE_INFINITY;\r\n\r\n    vertices.forEach(v => {\r\n      minX = v[0] < minX ? v[0] : minX;\r\n      minY = v[1] < minY ? v[1] : minY;\r\n      maxX = v[0] > maxX ? v[0] : maxX;\r\n      maxY = v[1] > maxY ? v[1] : maxY;\r\n    });\r\n\r\n    const dX = maxX - minX;\r\n    const dY = maxY - minY;\r\n    const midX = (minX + maxX) / 2;\r\n    const midY = (minY + maxY) / 2;\r\n    const dMax = dX > dY ? dX : dY;\r\n\r\n    const superIndices = [\r\n      vertices.length,\r\n      vertices.length + 1,\r\n      vertices.length + 2,\r\n    ];\r\n\r\n    const vertsWithSuper = [\r\n      ...vertices,\r\n      [midX - 20 * dMax, midY - dMax],\r\n      [midX, midY + 20 * dMax],\r\n      [midX + 20 * dMax, midY - dMax],\r\n    ];\r\n\r\n    const superSortedIndices = MathUtils.sortPointsCCW(\r\n      superIndices,\r\n      vertsWithSuper\r\n    );\r\n\r\n    const superTriangle = {\r\n      indices: superSortedIndices,\r\n      edges: [\r\n        [superSortedIndices[0], superSortedIndices[1]],\r\n        [superSortedIndices[1], superSortedIndices[2]],\r\n        [superSortedIndices[2], superSortedIndices[0]],\r\n      ],\r\n    };\r\n\r\n    const triangles = [superTriangle];\r\n\r\n    vertsWithSuper.forEach((newVert, newIndex) => {\r\n      const invalidTriangles = [];\r\n      triangles.forEach(triangle => {\r\n        if (\r\n          MathUtils.isPointInCircumCircle(\r\n            vertsWithSuper[triangle.indices[0]],\r\n            vertsWithSuper[triangle.indices[1]],\r\n            vertsWithSuper[triangle.indices[2]],\r\n            newVert\r\n          )\r\n        ) {\r\n          invalidTriangles.push(triangle);\r\n        }\r\n      });\r\n\r\n      const boundingPoly = [];\r\n      invalidTriangles.forEach(triangle => {\r\n        triangle.edges.forEach(edge => {\r\n          let count = 0;\r\n          invalidTriangles.forEach(otherTriangle => {\r\n            if (triangle !== otherTriangle) {\r\n              otherTriangle.edges.forEach(otherEdge => {\r\n                if (\r\n                  (edge[0] === otherEdge[0] && edge[1] === otherEdge[1]) ||\r\n                  (edge[1] === otherEdge[0] && edge[0] === otherEdge[1])\r\n                ) {\r\n                  count += 1;\r\n                }\r\n              });\r\n            }\r\n          });\r\n          if (count === 0) boundingPoly.push(edge);\r\n        });\r\n      });\r\n\r\n      invalidTriangles.forEach(triangle => {\r\n        triangles.splice(triangles.indexOf(triangle), 1);\r\n      });\r\n\r\n      boundingPoly.forEach(edge => {\r\n        const sortedIndices = MathUtils.sortPointsCCW(\r\n          [edge[0], edge[1], newIndex],\r\n          vertsWithSuper\r\n        );\r\n\r\n        triangles.push({\r\n          indices: sortedIndices,\r\n          edges: [\r\n            [sortedIndices[0], sortedIndices[1]],\r\n            [sortedIndices[1], sortedIndices[2]],\r\n            [sortedIndices[2], sortedIndices[0]],\r\n          ],\r\n        });\r\n      });\r\n    });\r\n\r\n    const trianglesToRemove = [];\r\n    triangles.forEach(triangle => {\r\n      triangle.indices.forEach(index => {\r\n        if (superIndices.includes(index)) {\r\n          trianglesToRemove.push(triangle);\r\n        }\r\n      });\r\n    });\r\n\r\n    trianglesToRemove.forEach(triangle => {\r\n      const index = triangles.indexOf(triangle);\r\n      if (index !== -1) {\r\n        triangles.splice(index, 1);\r\n      }\r\n    });\r\n\r\n    return triangles.map(triangle => triangle.indices);\r\n  }\r\n\r\n  /**\r\n   * Determines if a given 2D point is within the cicrumcircle\r\n   * defined by three 2D points. The triangle points must be in\r\n   * counter-clockwise order a -> b -> c.\r\n   *\r\n   * @param {Array.<number>} a - First triangle point.\r\n   * @param {Array.<number>} b - Second triangle point.\r\n   * @param {Array.<number>} c - Third triangle point.\r\n   * @param {Array.<number>} p - 2D point.\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n  static isPointInCircumCircle(a, b, c, p) {\r\n    const ax = a[0] - p[0];\r\n    const ay = a[1] - p[1];\r\n    const bx = b[0] - p[0];\r\n    const by = b[1] - p[1];\r\n    const cx = c[0] - p[0];\r\n    const cy = c[1] - p[1];\r\n\r\n    return (\r\n      (ax * ax + ay * ay) * (bx * cy - cx * by) -\r\n        (bx * bx + by * by) * (ax * cy - cx * ay) +\r\n        (cx * cx + cy * cy) * (ax * by - bx * ay) >\r\n      0\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Determines if a given 2D point is within a given triangle.\r\n   *\r\n   * @param {Array.<number>} a - First triangle point.\r\n   * @param {Array.<number>} b - Second triangle point.\r\n   * @param {Array.<number>} c - Third triangle point.\r\n   * @param {Array.<number>} p - 2D point.\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n  static isPointInTriangle(a, b, c, p) {\r\n    const denom = (b[1] - c[1]) * (a[0] - c[0]) + (c[0] - b[0]) * (a[1] - c[1]);\r\n    const aVal =\r\n      ((b[1] - c[1]) * (p[0] - c[0]) + (c[0] - b[0]) * (p[1] - c[1])) / denom;\r\n    const bVal =\r\n      ((c[1] - a[1]) * (p[0] - c[0]) + (a[0] - c[0]) * (p[1] - c[1])) / denom;\r\n    const cVal = 1 - aVal - bVal;\r\n\r\n    return (\r\n      aVal >= 0 && aVal <= 1 && bVal >= 0 && bVal <= 1 && cVal >= 0 && cVal <= 1\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Gets the sorted indices of a given set of 2D points in\r\n   * counter-clockwise order.\r\n   *\r\n   * @param {Array.<number>} indices - List of indices.\r\n   * @param {Array.<Array.<number>>} vertices - List of 2D points.\r\n   *\r\n   * @returns {Array.<Array.<number>>} - List of sorted indices.\r\n   */\r\n  static sortPointsCCW(indices, vertices) {\r\n    const centroid = [0, 0];\r\n    indices.forEach(index => {\r\n      centroid[0] += vertices[index][0];\r\n      centroid[1] += vertices[index][1];\r\n    });\r\n    centroid[0] /= indices.length;\r\n    centroid[1] /= indices.length;\r\n\r\n    indices.sort((a, b) => {\r\n      const bVal = Math.atan2(\r\n        vertices[b][1] - centroid[1],\r\n        vertices[b][0] - centroid[0]\r\n      );\r\n      const aVal = Math.atan2(\r\n        vertices[a][1] - centroid[1],\r\n        vertices[a][0] - centroid[0]\r\n      );\r\n\r\n      return aVal - bVal;\r\n    });\r\n\r\n    return indices;\r\n  }\r\n\r\n  /**\r\n   * Cacluates the area of a triangle\r\n   * @param {Array.<number>} a - First triangle point.\r\n   * @param {Array.<number>} b - Second triangle point.\r\n   * @param {Array.<number>} c - Third triangle point.\r\n   *\r\n   * @returns {number}\r\n   */\r\n  static triangleArea(a, b, c) {\r\n    return Math.abs(\r\n      (a[0] * (b[1] - c[1]) + b[0] * (c[1] - a[1]) + c[0] * (a[1] - b[1])) * 0.5\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return the magnitude of a given vector array.\r\n   *\r\n   * @param {Array.<number>} vector - Array consisting of numbers.\r\n   *\r\n   * @returns {number}\r\n   */\r\n  static getVectorMagnitude(vector) {\r\n    if (!(vector instanceof Array)) {\r\n      throw new Error(\r\n        `Cannot get magnitude for vector ${vector}. Input must be an Array numbers.`\r\n      );\r\n    }\r\n\r\n    const reducer = (accumulator, currentValue) => {\r\n      if (typeof currentValue !== 'number') {\r\n        throw new Error(\r\n          `Cannot get magnitude for vector ${vector}. All items in the input Array must be numbers.`\r\n        );\r\n      }\r\n\r\n      return accumulator + (currentValue ** 2);\r\n    }\r\n\r\n    return Math.sqrt(vector.reduce(reducer, 0));\r\n  }\r\n\r\n  /**\r\n   * Return the dot product between two vectors.\r\n   *\r\n   * @param {Array.<number>} vectorA - Array consisting of numbers.\r\n   * @param {Array.<number>} vectorB - Array consisting of numbers.\r\n   *\r\n   * @returns {number}\r\n   */\r\n  static getDotProduct(vectorA, vectorB) {\r\n    if (!(vectorA instanceof Array) || !(vectorB instanceof Array) || vectorA.length !== vectorB.length) {\r\n      throw new Error(`Cannot get dot product between ${vectorA} and ${vectorB}. Inputs must be vectors of the same length.`);\r\n    }\r\n\r\n    let result = 0;\r\n    vectorA.forEach((valueA, index) => {\r\n      const valueB = vectorB[index];\r\n\r\n      if (typeof valueA !== 'number' || typeof valueB !== 'number') {\r\n        throw new Error(`Cannot get dot product between ${vectorA} and ${vectorB}. Vectors must only consist of numeric values.`);\r\n      }\r\n\r\n      result += valueA * valueB;\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Return the angle in radians between vectorA and vectorB.\r\n   *\r\n   * @param {Array.<number>} vectorA - Array consisting of numbers.\r\n   * @param {Array.<number>} vectorB - Array consisting of numbers.\r\n   *\r\n   * @returns {number}\r\n   */\r\n  static getAngleBetween(vectorA, vectorB) {\r\n    const normalA = this.normalizeVector([...vectorA]);\r\n    const normalB = this.normalizeVector([...vectorB]);\r\n    const dot = this.getDotProduct(normalA, normalB);\r\n\r\n    return Math.acos(this.clamp(dot, -1, 1));\r\n  }\r\n\r\n  /**\r\n   * Multiply a 3x3 rotation matrix with a vector3.\r\n   *\r\n   * @param {Array.<number>} vector3 - Array consisting of 3 numbers representing\r\n   * a direction vector.\r\n   * @param {Array.<number>} matrix3 - An array of 9 numbers representing a row\r\n   * major rotation matrix.\r\n   *\r\n   * @returns {Array.<number>} - An array of 3 numbers representing the new direction\r\n   * of the vector.\r\n   */\r\n  static rotateVector(vector3, matrix3) {\r\n    if (!(vector3 instanceof Array)\r\n      || vector3.length !== 3\r\n      || !vector3.every(v => typeof v === 'number')) {\r\n      throw new Error(\r\n        `Cannot rotate vector ${vector3} by rotation matrix ${matrix3}. Input vector must be an array of 3 numbers.`\r\n      );\r\n    }\r\n\r\n    if (!(matrix3 instanceof Array)\r\n      || matrix3.length !== 9\r\n      || !matrix3.every(v => typeof v === 'number')) {\r\n      throw new Error(\r\n        `Cannot rotate vector ${vector3} by rotation matrix ${matrix3}. Input matrix3 must be an array of 9 numbers.`\r\n      );\r\n    }\r\n\r\n    const x = matrix3[0] * vector3[0]\r\n      + matrix3[3] * vector3[1]\r\n      + matrix3[6] * vector3[2];\r\n    const y = matrix3[1] * vector3[0]\r\n      + matrix3[4] * vector3[1]\r\n      + matrix3[7] * vector3[2];\r\n    const z = matrix3[2] * vector3[0]\r\n      + matrix3[5] * vector3[1]\r\n      + matrix3[8] * vector3[2];\r\n\r\n    return [x, y, z];\r\n  }\r\n\r\n  /**\r\n   * Normalize a given vector array.\r\n   *\r\n   * @param {Array.<number>} vector - Array consisting of numbers.\r\n   *\r\n   * @returns {Array.<number>} The original vector with normalized values, for chaining.\r\n   */\r\n  static normalizeVector(vector) {\r\n    const magnitude = this.getVectorMagnitude(vector);\r\n\r\n    if (magnitude === 0) {\r\n      vector.fill(0)\r\n    } else {\r\n      vector.forEach((value, index) => {\r\n        vector[index] = value / magnitude;\r\n      });\r\n    }\r\n\r\n    return vector;\r\n  }\r\n\r\n  /**\r\n   * Extract the 3x3 rotation matrix from a given 4x4 transformation matrix.\r\n   *\r\n   * @param {Array.<number>} matrix4 - An array of 16 numbers representing a row\r\n   * major transformation matrix.\r\n   *\r\n   * @returns {Array.<number>} - An array of 9 numbers representing a row major\r\n   * rotation matrix.\r\n   */\r\n  static getRotationMatrix(matrix4) {\r\n    if (!(matrix4 instanceof Array)\r\n      || matrix4.length !== 16\r\n      || !matrix4.every(v => typeof v === 'number')) {\r\n      throw new Error(\r\n        `Cannot convert matrix ${matrix4} to a rotation matrix. Input matrix must be an array of 16 numbers.`\r\n      );\r\n    }\r\n\r\n    // Extract scale\r\n    const scaleX = 1 / (this.getVectorMagnitude(matrix4.slice(0, 4)) || 1);\r\n    const scaleY = 1 / (this.getVectorMagnitude(matrix4.slice(4, 8)) || 1);\r\n    const scaleZ = 1 / (this.getVectorMagnitude(matrix4.slice(8, 12)) || 1);\r\n\r\n    return [\r\n      matrix4[0] * scaleX, matrix4[1] * scaleX, matrix4[2] * scaleX,\r\n      matrix4[4] * scaleY, matrix4[5] * scaleY, matrix4[6] * scaleY,\r\n      matrix4[8] * scaleZ, matrix4[9] * scaleZ, matrix4[10] * scaleZ\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Return an array containing the spherical coordinates of the given cartesian\r\n   * xyz coordinates.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {number} x - Position along the x axis.\r\n   * @param {number} y - Position along the y axis.\r\n   * @param {number} z - Position along the z axis.\r\n   *\r\n   * @returns {Array.<number>} - An array consisting of three numberes where index\r\n   * 0 represents the radius, index 1 represents the vertical/polar angle in radians\r\n   * and index 2 represents the horizontal/azimuthal angle in radians.\r\n   */\r\n  static cartesianToSpherical(x, y, z) {\r\n    const r = this.getVectorMagnitude([x, y, z]);\r\n\r\n    // Return identity if the vector has no length\r\n    if (r === 0) {\r\n      return [0, 0, 0];\r\n    }\r\n\r\n    return [\r\n      r,\r\n      Math.acos(this.clamp(y / r, - 1, 1)),\r\n      Math.atan2(x, z),\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Gradually change a value of a numeric property towards a goal over time using\r\n   * a critically damped spring function.\r\n   *\r\n   * @param {number} currentValue - The starting value.\r\n   * @param {number} targetValue- The goal value.\r\n   * @param {Array.<number>} [valueStore = [0, 0]] - An Array consisting of two\r\n   * numbers where the first number holds the result value and the second holds\r\n   * the velocity that resulted in that value. The same array should be provided\r\n   * with each call to this function.\r\n   * @param {number} [deltaTime = 1e-7] - The time since the last call to this function\r\n   * in seconds.\r\n   * @param {number} [smoothTime = 0.3] - The approximate amount of time in seconds\r\n   * it should take to reach the target value.\r\n   * @param {number} [maxSpeed = 1e7] - A clamping value for the maximum speed the\r\n   * value can change.\r\n   *\r\n   * @returns {Array.<number>} - The valueStore array.\r\n   */\r\n  static dampValue(\r\n    currentValue,\r\n    targetValue,\r\n    valueStore = [0, 0],\r\n    deltaTime = 1e-7,\r\n    smoothTime = 0.3,\r\n    maxSpeed = 1e7\r\n  ) {\r\n    smoothTime = Math.max(0.0001, smoothTime);\r\n    deltaTime = Math.max(1e-7, deltaTime);\r\n\r\n    // Find the delta between values and use it to estimate the previous value\r\n    const clampTime = maxSpeed * smoothTime;\r\n    const deltaValue = currentValue - targetValue;\r\n    const clampDeltaValue = this.clamp(deltaValue, -clampTime, clampTime);\r\n    const lastValue = currentValue - clampDeltaValue;\r\n\r\n    // Calculate damping factors\r\n    const d1 = 2 / smoothTime;\r\n    const d2 = d1 * deltaTime;\r\n    const d3 = 1 / (1 + d2 + 0.5 * d2 ** 2 + 0.25 * d2 ** 3);\r\n    const d4 = (valueStore[1] + d1 * clampDeltaValue) * deltaTime;\r\n\r\n    // Damp the target value and update the velocity\r\n    valueStore[0] = lastValue + (clampDeltaValue + d4) * d3;\r\n    valueStore[1] = (valueStore[1] - d1 * d4) * d3;\r\n\r\n    // Prevent overshooting\r\n    if (targetValue - currentValue > 0 === valueStore[0] > targetValue) {\r\n      valueStore[0] = targetValue;\r\n      valueStore[1] = (valueStore[0] - targetValue) / deltaTime;\r\n    }\r\n\r\n    return valueStore;\r\n  }\r\n}\r\n\r\nexport default MathUtils;\r\n","// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n// SPDX-License-Identifier: MIT-0\r\n/* eslint-disable no-underscore-dangle */\r\nimport Utils from './Utils';\r\n\r\n/**\r\n * Class that can execute functions when local messages are received. Local messages\r\n * are prefixed with the instance's id.\r\n *\r\n * @alias core/Messenger\r\n *\r\n * @property {core/Messenger} GlobalMessenger - A messenger that can be used for\r\n * global messaging. When using static listen and emit methods they are executed\r\n * on this messenger.\r\n * @property {Object} EVENTS - Built-in events that the Messenger emits.\r\n */\r\nclass Messenger {\r\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {any=} id - Id for the object. If none is provided a new id will\r\n   * be created. Id should be able to be represented as a string.\r\n   */\r\n  constructor(id) {\r\n    this._id = id !== undefined ? id : Utils.createId();\r\n    this._dispatcher = window;\r\n    this._callbacks = {};\r\n    this._eventListeners = {};\r\n  }\r\n\r\n  /**\r\n   * Gets the string id of the object.\r\n   *\r\n   * @readonly\r\n   * @type {string}\r\n   */\r\n  get id() {\r\n    return this._id;\r\n  }\r\n\r\n  /**\r\n   * Prefix a message with the instance id.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} message\r\n   *\r\n   * @returns {string}\r\n   */\r\n  _createLocalMessage(message) {\r\n    return `${this.id}.${message}`;\r\n  }\r\n\r\n  /**\r\n   * Return a function that will call a callback function and supply the event's\r\n   * detail property as an argument.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {Function} callback\r\n   *\r\n   * @returns {Function}\r\n   */\r\n  _createListener(callback) {\r\n    return e => {\r\n      let value;\r\n\r\n      if (e.detail !== null) {\r\n        value = e.detail;\r\n      }\r\n\r\n      callback(value);\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create an event object and send it to listeners.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} message - Event type name.\r\n   * @param {any=} value - Value to send to listeners.\r\n   *\r\n   * @returns {CustomEvent}\r\n   */\r\n  _createEvent(message, value) {\r\n    return new CustomEvent(message, {detail: value});\r\n  }\r\n\r\n  /**\r\n   * Register an event.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} message - Event type name.\r\n   * @param {Function} listener - A listener function generated using _createListener.\r\n   */\r\n  _addListener(message, listener) {\r\n    this._dispatcher.addEventListener(\r\n      this._createLocalMessage(message),\r\n      listener\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Unregister an event.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} message - Event type name.\r\n   * @param {Function} listener - A listener function generated using _createListener.\r\n   */\r\n  _removeListener(message, listener) {\r\n    this._dispatcher.removeEventListener(\r\n      this._createLocalMessage(message),\r\n      listener\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Execute a function when a message is received for this object.\r\n   *\r\n   * @param {string} message - The message to listen for.\r\n   * @param {Function} callback - Function to execute once the message is received.\r\n   */\r\n  listenTo(message, callback) {\r\n    if (typeof callback !== 'function') {\r\n      throw new Error(\r\n        `Cannot add listener for ${message} on ${this.id}. Callback must be a function.`\r\n      );\r\n    }\r\n\r\n    if (this._callbacks[message] === undefined) {\r\n      this._callbacks[message] = [];\r\n      this._eventListeners[message] = [];\r\n    }\r\n\r\n    const listener = this._createListener(callback);\r\n    this._callbacks[message].push(callback);\r\n    this._eventListeners[message].push(listener);\r\n\r\n    this._addListener(message, listener);\r\n  }\r\n\r\n  /**\r\n   * Prevent a function from being executed when a message is received for this\r\n   * object.\r\n   *\r\n   * @param {string} message - The message to stop listening for.\r\n   * @param {Function=} callback - Optional callback to remove. If none is defined,\r\n   * remove all callbacks for the message.\r\n   */\r\n  stopListening(message, callback) {\r\n    if (this._callbacks[message] === undefined) {\r\n      return;\r\n    } else if (callback === undefined) {\r\n      // If no callback was defined, call stopListening on all callbacks for the message\r\n      for (let i = this._callbacks[message].length - 1; i > -1; i--) {\r\n        this.stopListening(message, this._callbacks[message][i]);\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    // If a callback was defined, make sure it's a listener\r\n    const index = this._callbacks[message].indexOf(callback);\r\n    if (index === -1) {\r\n      return;\r\n    }\r\n\r\n    const listener = this._eventListeners[message][index];\r\n    this._removeListener(message, listener);\r\n\r\n    this._callbacks[message].splice(index, 1);\r\n    this._eventListeners[message].splice(index, 1);\r\n\r\n    if (this._callbacks[message].length === 0) {\r\n      delete this._callbacks[message];\r\n      delete this._eventListeners[message];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * De-register callback(s) from being executed when messages matching the given\r\n   * regular expression are received.\r\n   *\r\n   * @param {Regexp} regexp - regexp - The regular expression to filter messages with.\r\n   * @param {Function=} callback - Optional callback to remove. If none is defined,\r\n   * remove all callbacks for messages matching the regular expression.\r\n   */\r\n  stopListeningByRegexp(regexp, callback) {\r\n    const messages = Object.keys(this._callbacks).filter(message => regexp.test(message));\r\n\r\n    messages.forEach(message => {\r\n      this.stopListening(message, callback);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Prevent any functions from being executed when any message is received for\r\n   * this object.\r\n   */\r\n  stopListeningToAll() {\r\n    const messages = Object.keys(this._callbacks);\r\n\r\n    for (let i = messages.length - 1; i > -1; i--) {\r\n      this.stopListening(messages[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Send a message, causing listener functions for the message on this object\r\n   * to be executed.\r\n   *\r\n   * @param {string} message - The message to emit.\r\n   * @param {any=} value - Optional argument to pass to listener callbacks.\r\n   */\r\n  emit(message, value) {\r\n    if (this._callbacks[message] === undefined) {\r\n      return;\r\n    }\r\n\r\n    message = this._createLocalMessage(message);\r\n    const event = this._createEvent(message, value);\r\n    this._dispatcher.dispatchEvent(event);\r\n  }\r\n\r\n  /**\r\n   * Execute a function when a message is received for the global Messenger instance.\r\n   *\r\n   * @static\r\n   *\r\n   * @param {string} message - The message to listen for.\r\n   * @param {Function} callback - Function to execute once the message is received.\r\n   */\r\n  static listenTo(message, callback, messenger) {\r\n    this.GlobalMessenger.listenTo(message, callback, messenger);\r\n  }\r\n\r\n  /**\r\n   * Prevent a function from being executed when a message is received for the\r\n   * global Messenger instance.\r\n   *\r\n   * @static\r\n   *\r\n   * @param {string} message - The message to stop listening for.\r\n   * @param {Function=} callback - Optional callback to remove. If none is defined,\r\n   * remove all callbacks for the message.\r\n   */\r\n  static stopListening(message, callback) {\r\n    this.GlobalMessenger.stopListening(message, callback);\r\n  }\r\n\r\n  /**\r\n   * De-register callback(s) from being executed on the global messengerr instance\r\n   * when messages matching the given regular expression are received.\r\n   *\r\n   * @param {Regexp} regexp - regexp - The regular expression to filter messages with.\r\n   * @param {Function=} callback - Optional callback to remove. If none is defined,\r\n   * remove all callbacks for messages matching the regular expression.\r\n   */\r\n  static stopListeningByRegexp(regexp, callback) {\r\n    const messages = Object.keys(this.GlobalMessenger._callbacks).filter(\r\n      message => regexp.test(message)\r\n    );\r\n\r\n    messages.forEach(message => {\r\n      this.stopListening(message, callback);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Prevent any functions from being executed when any message is received for\r\n   * the global Messenger instance.\r\n   *\r\n   * @static\r\n   */\r\n  static stopListeningToAll() {\r\n    this.GlobalMessenger.stopListeningToAll();\r\n  }\r\n\r\n  /**\r\n   * Send a message, causing listener functions for the message on the global Messenger\r\n   * instance to be executed.\r\n   *\r\n   * @static\r\n   *\r\n   * @param {string} message - The message to emit.\r\n   * @param {any=} value - Optional argument to pass to listener callbacks.\r\n   */\r\n  static emit(message, value) {\r\n    this.GlobalMessenger.emit(message, value);\r\n  }\r\n}\r\n\r\nObject.defineProperties(Messenger, {\r\n  GlobalMessenger: {\r\n    value: new Messenger(),\r\n    writable: false,\r\n  },\r\n  EVENTS: {\r\n    value: {},\r\n    writable: false,\r\n  },\r\n});\r\n\r\nexport default Messenger;\r\n","// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n// SPDX-License-Identifier: MIT-0\r\nimport Messenger from 'app/Messenger';\r\n\r\n/**\r\n * Base class for all host features. Keeps a reference to the host object managing\r\n * the feature.\r\n *\r\n * @abstract\r\n *\r\n * @property {Object} EVENTS - Built-in messages that the feature emits. When the\r\n * feature is added to a {@link core/HostObject}, event names will be prefixed by the\r\n * name of the feature class + '.'.\r\n * @property {string} [EVENTS.update=onUpdate] - Message that is emitted after\r\n * each call to [update]{@link AbstractHostFeature#update}.\r\n * @property {Object} SERVICES - Any AWS services that are necessary for the\r\n * feature to function.\r\n */\r\nclass AbstractHostFeature {\r\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {core/HostObject} host - The HostObject managing the feature.\r\n   */\r\n  constructor(host) {\r\n    this._host = host;\r\n  }\r\n\r\n  /**\r\n   * Adds a namespace to the host with the name of the feature to contain properties\r\n   * and methods from the feature that users of the host need access to.\r\n   */\r\n  installApi() {\r\n    const events = {};\r\n    const api = {EVENTS: events};\r\n\r\n    // Add the class name to event names\r\n    Object.entries(this.constructor.EVENTS).forEach(([name, value]) => {\r\n      events[name] = `${this.constructor.name}.${value}`;\r\n    });\r\n\r\n    this._host[this.constructor.name] = api;\r\n\r\n    return api;\r\n  }\r\n\r\n  /**\r\n   * Gets the host that manages the feature.\r\n   *\r\n   * @readonly\r\n   */\r\n  get host() {\r\n    return this._host;\r\n  }\r\n\r\n  /**\r\n   * Gets the engine owner object of the host.\r\n   *\r\n   * @readonly\r\n   */\r\n  get owner() {\r\n    return this._host.owner;\r\n  }\r\n\r\n  /**\r\n   * Listen to a feature message from the host object.\r\n   *\r\n   * @param {string} message - Message to listen for.\r\n   * @param {Function} callback - The callback to execute when the message is received.\r\n   */\r\n  listenTo(message, callback) {\r\n    this._host.listenTo(message, callback);\r\n  }\r\n\r\n  /**\r\n   * Listen to a feature message from the global messenger. Feature messages will\r\n   * be prefixed with the class name of the feature.\r\n   *\r\n   * @param {string} message - Message to listen for.\r\n   * @param {Function} callback - The callback to execute when the message is received.\r\n   */\r\n  static listenTo(message, callback) {\r\n    message = `${this.name}.${message}`;\r\n    Messenger.listenTo(message, callback);\r\n  }\r\n\r\n  /**\r\n   * Stop listening to a message from the host object.\r\n   *\r\n   * @param {string} message - Message to stop listening for.\r\n   * @param {Function=} callback - Optional callback to remove. If none is defined,\r\n   * remove all callbacks for the message.\r\n   */\r\n  stopListening(message, callback) {\r\n    this._host.stopListening(message, callback);\r\n  }\r\n\r\n  /**\r\n   * Stop listening to a message from the global messenger.\r\n   *\r\n   * @param {string} message - Message to stop listening for.\r\n   * @param {Function=} callback - Optional callback to remove. If none is defined,\r\n   * remove all callbacks for the message.\r\n   */\r\n  static stopListening(message, callback) {\r\n    message = `${this.name}.${message}`;\r\n    Messenger.stopListening(message, callback);\r\n  }\r\n\r\n  /**\r\n   * Stop listening to a message matching the given regular expression from the\r\n   * host object.\r\n   *\r\n   * @param {Regexp} regexp - The regular expression to stop listening for.\r\n   * @param {Function=} callback - Optional callback to remove. If none is defined,\r\n   * remove all callbacks for the message.\r\n   */\r\n  stopListeningByRegexp(regexp, callback) {\r\n    this._host.stopListeningByRegexp(regexp, callback);\r\n  }\r\n\r\n  /**\r\n   * Stop listening to a message matching the given regular expression from the\r\n   * global messenger.\r\n   *\r\n   * @param {Regexp} regexp - The regular expression to stop listening for.\r\n   * @param {Function=} callback - Optional callback to remove. If none is defined,\r\n   * remove all callbacks for the message.\r\n   */\r\n  static stopListeningByRegexp(regexp, callback) {\r\n    regexp = new RegExp(`^${this.name}.${regexp.source.replace(/\\^/, '')}`);\r\n    Messenger.stopListeningByRegexp(regexp, callback);\r\n  }\r\n\r\n  /**\r\n   * Stop listening to all messages.\r\n   */\r\n  stopListeningToAll() {\r\n    this._host.stopListeningToAll();\r\n  }\r\n\r\n  /**\r\n   * Stop listening to all feature messages.\r\n   */\r\n  static stopListeningToAll() {\r\n    Messenger.stopListeningByRegexp(new RegExp(`^${this.name}.`));\r\n  }\r\n\r\n  /**\r\n   * Emit feature messages from the host. Feature messages will be prefixed with\r\n   * the class name of the feature.\r\n   *\r\n   * @param {string} message - The message to emit.\r\n   * @param {any=} value - Optional parameter to pass to listener callbacks.\r\n   */\r\n  emit(message, value) {\r\n    message = `${this.constructor.name}.${message}`;\r\n    this._host.emit(message, value);\r\n  }\r\n\r\n  /**\r\n   * Emit feature messages from the global messenger. Feature messages will be prefixed\r\n   * with the class name of the feature.\r\n   *\r\n   * @param {string} message - The message to emit.\r\n   * @param {any=} value - Optional parameter to pass to listener callbacks.\r\n   */\r\n  static emit(message, value) {\r\n    message = `${this.name}.${message}`;\r\n    Messenger.emit(message, value);\r\n  }\r\n\r\n  /**\r\n   * Executes each time the host is updated.\r\n   *\r\n   * @param {number} deltaTime - Amount of time since the last host update was\r\n   * called.\r\n   */\r\n  update(deltaTime) {\r\n    this.emit(this.constructor.EVENTS.update, deltaTime);\r\n  }\r\n\r\n  /**\r\n   * Clean up once the feature is no longer in use. Remove the feature namespace\r\n   * from the host and remove reference to the host.\r\n   */\r\n  discard() {\r\n    Object.keys(this._host[this.constructor.name]).forEach(name => {\r\n      delete this._host[this.constructor.name][name];\r\n    });\r\n\r\n    delete this._host[this.constructor.name];\r\n    delete this._host;\r\n  }\r\n\r\n  /**\r\n   * Applies a sequence of mixin class factory functions to this class and\r\n   * returns the result. Each function is expected to return a class that\r\n   * extends the class it was given. The functions are applied in the order\r\n   * that parameters are given, meaning that the first factory will\r\n   * extend this base class.\r\n   *\r\n   * @param {...Function} mixinClassFactories Class factory functions that will\r\n   * be applied.\r\n   *\r\n   * @returns {Class} A class that is the result of applying the factory functions.\r\n   * The resulting class will always inherit from AbstractHostFeature.\r\n   */\r\n  static mix(...mixinClassFactories) {\r\n    let ResultClass = this;\r\n\r\n    mixinClassFactories.forEach(mixinClassFactory => {\r\n      ResultClass = mixinClassFactory(ResultClass);\r\n    });\r\n\r\n    return ResultClass;\r\n  }\r\n}\r\n\r\nObject.defineProperties(AbstractHostFeature, {\r\n  EVENTS: {\r\n    value: {\r\n      update: 'onUpdate',\r\n    },\r\n    writable: false,\r\n  },\r\n  SERVICES: {\r\n    value: {},\r\n    writable: false,\r\n  },\r\n});\r\n\r\nexport default AbstractHostFeature;\r\n","// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n// SPDX-License-Identifier: MIT-0\r\nimport Messenger from 'app/Messenger';\r\nimport AbstractHostFeature from './AbstractHostFeature';\r\nimport Utils from './Utils';\r\n\r\n/**\r\n * Object that manages access to all Host features. Contains a reference to\r\n * engine-specific visuals if applicable.\r\n *\r\n * @extends core/Messenger\r\n * @alias core/HostObject\r\n *\r\n * @property {Object} EVENTS - Built-in messages that the Messenger emits.\r\n * @property {string} [EVENTS.update='onUpdate'] - Message that is emitted after\r\n * each call to [update]{@link core/HostObject#update}.\r\n * @property {string} [EVENTS.addFeature='onAddFeature'] - Message that is emitted\r\n * after each call to [addFeature]{@link core/HostObject#addFeature}.\r\n * @property {string} [EVENTS.removeFeature='onRemoveFeature'] - Message that is emitted\r\n * after each call to [removeFeature]{@link core/HostObject#removeFeature}.\r\n */\r\nclass HostObject extends Messenger {\r\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {Object=} options - Options for the host.\r\n   * @param {Object=} options.owner - Optional engine-specific owner of the host.\r\n   */\r\n  constructor({owner = {}} = {}) {\r\n    // If an owner is specified, use its id for messaging\r\n    super(owner.id);\r\n\r\n    this._owner = owner;\r\n    this._features = {};\r\n    this._waits = [];\r\n    this._lastUpdate = this.now;\r\n  }\r\n\r\n  /**\r\n   * Gets the engine owner object of the host.\r\n   *\r\n   * @readonly\r\n   * @type {Object}\r\n   */\r\n  get owner() {\r\n    return this._owner;\r\n  }\r\n\r\n  /**\r\n   * Gets the current time in milliseconds.\r\n   *\r\n   * @readonly\r\n   * @type {number}\r\n   */\r\n  get now() {\r\n    return Date.now();\r\n  }\r\n\r\n  /**\r\n   * Gets the amount of time in milliseconds since update was last called.\r\n   *\r\n   * @readonly\r\n   * @type {number}\r\n   */\r\n  get deltaTime() {\r\n    return this.now - this._lastUpdate;\r\n  }\r\n\r\n  /**\r\n   * This function should be called in the engine's render loop. Executes update\r\n   * loops for all features.\r\n   */\r\n  update() {\r\n    const currentTime = this.now;\r\n    const dt = this.deltaTime;\r\n\r\n    // Progress stored waits\r\n    this._waits.forEach(wait => {\r\n      wait.execute(dt);\r\n    });\r\n\r\n    // Update all features\r\n    Object.values(this._features).forEach(feature => {\r\n      feature.update(dt);\r\n    });\r\n\r\n    // Notify listeners an update occured\r\n    this.emit(this.constructor.EVENTS.update, dt);\r\n\r\n    this._lastUpdate = currentTime;\r\n  }\r\n\r\n  /**\r\n   * Return a deferred promise that will wait a given number of seconds before\r\n   * resolving. The host will continuously update the wait promise during the\r\n   * update loop until it resolves.\r\n   *\r\n   * @param {number} [seconds=0] - Number of seconds to wait before resolving.\r\n   * @param {Object=} options - Optional options object\r\n   * @param {Function} [options.onFinish] - Callback to execute once the wait time\r\n   * is met.\r\n   * @param {Function=} options.onProgress - Callback to execute each time the wait\r\n   * time progresses towards the target number of seconds. The amount of progress\r\n   * as a 0-1 percentage is passed as an argument.\r\n   * @param {Function=} options.onCancel - Callback to execute if the user cancels\r\n   * the wait before completion.\r\n   * @param {Function=} options.onError - Callback to execute if the wait stops\r\n   * because an error is encountered. The error message is passed as a parameter.\r\n   *\r\n   * @returns {Deferred}\r\n   */\r\n  wait(seconds, {onFinish, onProgress, onCancel, onError} = {}) {\r\n    const wait = Utils.wait(seconds, {onFinish, onProgress, onCancel, onError});\r\n    this._waits.push(wait);\r\n\r\n    // Once the wait promise is no longer pending remove it from the waits array\r\n    const onComplete = () => {\r\n      this._waits.splice(this._waits.indexOf(wait), 1);\r\n    };\r\n    wait.then(onComplete, onComplete);\r\n\r\n    return wait;\r\n  }\r\n\r\n  /**\r\n   * Instantiate a new Host feature and store it. Features must inherit from\r\n   * AbstractHostFeature.\r\n   *\r\n   * @param {Class} FeatureClass - Class that will instantiate the feature. Must\r\n   * extend {@link AbstractHostFeature}.\r\n   * @param {boolean} [force=false] - Whether or not to overwrite an existing\r\n   * feature if one of this type already exists on the object.\r\n   * @param  {...any} args - Additional arguments to pass to the FeatureClass\r\n   * constructor. The HostObject will always be passed as the first argument.\r\n   *\r\n   * @returns {boolean} - Whether or not a feature was successfully added.\r\n   */\r\n  addFeature(FeatureClass, force = false, ...args) {\r\n    const inputType = typeof FeatureClass;\r\n\r\n    // Make sure the FeatureClass can be executed\r\n    if (inputType !== 'function') {\r\n      throw new Error(\r\n        `Cannot add feature to host ${this.id}. FeatureClass must be a class.`\r\n      );\r\n    }\r\n    // Make sure the feature is a host feature\r\n    else if (!(FeatureClass.prototype instanceof AbstractHostFeature)) {\r\n      throw new Error(\r\n        `Cannot add feature ${FeatureClass.name} to host ${this.id}. FeatureClass must extend AbstractHostFeature.`\r\n      );\r\n    }\r\n\r\n    // Check if the FeatureClass already exists on this object\r\n    if (this._features[FeatureClass.name] !== undefined) {\r\n      if (force) {\r\n        console.warn(\r\n          `Feature ${FeatureClass.name} already exists on host ${this.id}. Existing feature will be overwritten.`\r\n        );\r\n      } else {\r\n        throw new Error(\r\n          `Feature ${FeatureClass.name} already exists on host ${this.id}. Use 'force' argument to overwrite the feature.`\r\n        );\r\n      }\r\n    }\r\n\r\n    // Initialize the feature\r\n    const feature = new FeatureClass(this, ...args);\r\n    feature.installApi();\r\n\r\n    this._features[FeatureClass.name] = feature;\r\n    this.emit(this.constructor.EVENTS.addFeature, FeatureClass.name);\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Remove a feature from the object.\r\n   *\r\n   * @param {string} typeName - Name of the type of feature to remove.\r\n   *\r\n   * @returns {boolean} - Whether or not a feature was successfully removed.\r\n   */\r\n  removeFeature(typeName) {\r\n    if (this._features[typeName] === undefined) {\r\n      console.warn(\r\n        `Feature of type ${typeName} does not exist on host ${this.id}. No feature will be removed.`\r\n      );\r\n      return false;\r\n    } else {\r\n      // Remove the feature\r\n      this.emit(this.constructor.EVENTS.removeFeature, typeName);\r\n      this._features[typeName].discard();\r\n      delete this._features[typeName];\r\n\r\n      return true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Indicate whether a specified feature is installed on the host.\r\n   *\r\n   * @param {string} typeName - Name of the type of feature to look for.\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n  hasFeature(typeName) {\r\n    return !!this._features[typeName];\r\n  }\r\n\r\n  /**\r\n   * List the names of the features installed on the host.\r\n   *\r\n   * @returns {Array.<string>}\r\n   */\r\n  listFeatures() {\r\n    return Object.keys(this._features);\r\n  }\r\n}\r\n\r\nObject.defineProperty(HostObject, 'EVENTS', {\r\n  value: {\r\n    ...Object.getPrototypeOf(HostObject).EVENTS,\r\n    update: 'onUpdate',\r\n    addFeature: 'onAddFeature',\r\n    removeFeature: 'onRemoveFeature',\r\n  },\r\n  writable: false,\r\n});\r\n\r\nexport default HostObject;\r\n","// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n// SPDX-License-Identifier: MIT-0\r\n/**\r\n * @typedef {Object} EasingObject Object containing easing functions\r\n * @property {Function} In - Easing 'In' function. Should use the signature (k:number):number.\r\n * @property {Function} Out - Easing 'Out' function. Should use the signature (k:number):number.\r\n * @property {Function} InOut - Easing 'InOut' function. Should use the signature (k:number):number.\r\n */\r\n\r\n/**\r\n * Linear Easing\r\n * @type {EasingObject}\r\n */\r\nexport const Linear = {\r\n  None(k) {\r\n    return k;\r\n  },\r\n  In(k) {\r\n    return k;\r\n  },\r\n  Out(k) {\r\n    return k;\r\n  },\r\n  InOut(k) {\r\n    return k;\r\n  },\r\n};\r\n\r\n/**\r\n * Quadratic Easing\r\n * @type {EasingObject}\r\n */\r\nexport const Quadratic = {\r\n  In(k) {\r\n    return k * k;\r\n  },\r\n  Out(k) {\r\n    return k * (2 - k);\r\n  },\r\n  InOut(k) {\r\n    k *= 2;\r\n    if (k < 1) {\r\n      return 0.5 * k * k;\r\n    }\r\n    return -0.5 * (--k * (k - 2) - 1);\r\n  },\r\n};\r\n\r\n/**\r\n * Cubic Easing\r\n * @type {EasingObject}\r\n */\r\nexport const Cubic = {\r\n  In(k) {\r\n    return k * k * k;\r\n  },\r\n  Out(k) {\r\n    return --k * k * k + 1;\r\n  },\r\n  InOut(k) {\r\n    k *= 2;\r\n    if (k < 1) {\r\n      return 0.5 * k * k * k;\r\n    }\r\n\r\n    k -= 2;\r\n    return 0.5 * (k * k * k + 2);\r\n  },\r\n};\r\n\r\n/**\r\n * Quartic Easing\r\n * @type {EasingObject}\r\n */\r\nexport const Quartic = {\r\n  In(k) {\r\n    return k * k * k * k;\r\n  },\r\n  Out(k) {\r\n    return 1 - --k * k * k * k;\r\n  },\r\n  InOut(k) {\r\n    k *= 2;\r\n    if (k < 1) {\r\n      return 0.5 * k * k * k * k;\r\n    }\r\n\r\n    k -= 2;\r\n    return -0.5 * (k * k * k * k - 2);\r\n  },\r\n};\r\n\r\n/**\r\n * Quintic Easing\r\n * @type {EasingObject}\r\n */\r\nexport const Quintic = {\r\n  In(k) {\r\n    return k * k * k * k * k;\r\n  },\r\n  Out(k) {\r\n    return --k * k * k * k * k + 1;\r\n  },\r\n  InOut(k) {\r\n    k *= 2;\r\n    if (k < 1) {\r\n      return 0.5 * k * k * k * k * k;\r\n    }\r\n\r\n    k -= 2;\r\n    return 0.5 * (k * k * k * k * k + 2);\r\n  },\r\n};\r\n\r\n/**\r\n * Sinusoidal Easing\r\n * @type {EasingObject}\r\n */\r\nexport const Sinusoidal = {\r\n  In(k) {\r\n    return 1 - Math.cos((k * Math.PI) / 2);\r\n  },\r\n  Out(k) {\r\n    return Math.sin((k * Math.PI) / 2);\r\n  },\r\n  InOut(k) {\r\n    return 0.5 * (1 - Math.cos(Math.PI * k));\r\n  },\r\n};\r\n\r\n/**\r\n * Exponential Easing\r\n * @type {EasingObject}\r\n */\r\nexport const Exponential = {\r\n  In(k) {\r\n    return k === 0 ? 0 : 1024 ** (k - 1);\r\n  },\r\n  Out(k) {\r\n    return k === 1 ? 1 : 1 - 2 ** (-10 * k);\r\n  },\r\n  InOut(k) {\r\n    if (k === 0) {\r\n      return 0;\r\n    }\r\n    if (k === 1) {\r\n      return 1;\r\n    }\r\n\r\n    k *= 2;\r\n    if (k < 1) {\r\n      return 0.5 * 1024 ** (k - 1);\r\n    }\r\n    return 0.5 * (-(2 ** (-10 * (k - 1))) + 2);\r\n  },\r\n};\r\n\r\n/**\r\n * Circular Easing\r\n * @type {EasingObject}\r\n */\r\nexport const Circular = {\r\n  In(k) {\r\n    return 1 - Math.sqrt(1 - k * k);\r\n  },\r\n  Out(k) {\r\n    return Math.sqrt(1 - --k * k);\r\n  },\r\n  InOut(k) {\r\n    k *= 2;\r\n    if (k < 1) {\r\n      return -0.5 * (Math.sqrt(1 - k * k) - 1);\r\n    }\r\n\r\n    k -= 2;\r\n    return 0.5 * (Math.sqrt(1 - k * k) + 1);\r\n  },\r\n};\r\n\r\n/**\r\n * Elastic Easing\r\n * @type {EasingObject}\r\n */\r\nexport const Elastic = {\r\n  In(k) {\r\n    let s;\r\n    let a = 0.1;\r\n    const p = 0.4;\r\n\r\n    if (k === 0) {\r\n      return 0;\r\n    }\r\n\r\n    if (k === 1) {\r\n      return 1;\r\n    }\r\n\r\n    if (!a || a < 1) {\r\n      a = 1;\r\n      s = p / 4;\r\n    } else {\r\n      s = (p * Math.asin(1 / a)) / (2 * Math.PI);\r\n    }\r\n\r\n    k -= 1;\r\n    return -(a * 2 ** (10 * k) * Math.sin(((k - s) * (2 * Math.PI)) / p));\r\n  },\r\n  Out(k) {\r\n    let s;\r\n    let a = 0.1;\r\n    const p = 0.4;\r\n\r\n    if (k === 0) {\r\n      return 0;\r\n    }\r\n\r\n    if (k === 1) {\r\n      return 1;\r\n    }\r\n\r\n    if (!a || a < 1) {\r\n      a = 1;\r\n      s = p / 4;\r\n    } else {\r\n      s = (p * Math.asin(1 / a)) / (2 * Math.PI);\r\n    }\r\n\r\n    return a * 2 ** (-10 * k) * Math.sin(((k - s) * (2 * Math.PI)) / p) + 1;\r\n  },\r\n  InOut(k) {\r\n    let s;\r\n    let a = 0.1;\r\n    const p = 0.4;\r\n\r\n    if (k === 0) {\r\n      return 0;\r\n    }\r\n\r\n    if (k === 1) {\r\n      return 1;\r\n    }\r\n\r\n    if (!a || a < 1) {\r\n      a = 1;\r\n      s = p / 4;\r\n    } else {\r\n      s = (p * Math.asin(1 / a)) / (2 * Math.PI);\r\n    }\r\n\r\n    k *= 2;\r\n    if (k < 1) {\r\n      k -= 1;\r\n      return (\r\n        -0.5 * (a * 2 ** (10 * k) * Math.sin(((k - s) * (2 * Math.PI)) / p))\r\n      );\r\n    }\r\n\r\n    k -= 1;\r\n    return (\r\n      a * 2 ** (-10 * k) * Math.sin(((k - s) * (2 * Math.PI)) / p) * 0.5 + 1\r\n    );\r\n  },\r\n};\r\n\r\n/**\r\n * Back Easing\r\n * @type {EasingObject}\r\n */\r\nexport const Back = {\r\n  In(k) {\r\n    const s = 1.70158;\r\n    return k * k * ((s + 1) * k - s);\r\n  },\r\n  Out(k) {\r\n    const s = 1.70158;\r\n    return --k * k * ((s + 1) * k + s) + 1;\r\n  },\r\n  InOut(k) {\r\n    const s = 1.70158 * 1.525;\r\n    k *= 2;\r\n    if (k < 1) {\r\n      return 0.5 * (k * k * ((s + 1) * k - s));\r\n    }\r\n\r\n    k -= 2;\r\n    return 0.5 * (k * k * ((s + 1) * k + s) + 2);\r\n  },\r\n};\r\n\r\n/**\r\n * Bounce Easing\r\n * @type {EasingObject}\r\n */\r\nexport const Bounce = {\r\n  In(k) {\r\n    return 1 - Bounce.Out(1 - k);\r\n  },\r\n  Out(k) {\r\n    if (k < 1 / 2.75) {\r\n      return 7.5625 * k * k;\r\n    } else if (k < 2 / 2.75) {\r\n      k -= 1.5;\r\n      return 7.5625 * (k / 2.75) * k + 0.75;\r\n    } else if (k < 2.5 / 2.75) {\r\n      k -= 2.25;\r\n      return 7.5625 * (k / 2.75) * k + 0.9375;\r\n    }\r\n    k -= 2.625;\r\n    return 7.5625 * (k / 2.75) * k + 0.984375;\r\n  },\r\n  InOut(k) {\r\n    if (k < 0.5) {\r\n      return Bounce.In(k * 2) * 0.5;\r\n    }\r\n    return Bounce.Out(k * 2 - 1) * 0.5 + 0.5;\r\n  },\r\n};\r\n","// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n// SPDX-License-Identifier: MIT-0\r\n\r\n/* eslint-disable no-unused-vars */\r\n/* eslint-disable max-classes-per-file */\r\nimport HostObject from 'app/HostObject';\r\n\r\n/**\r\n * Class factory interface for features that are dependent on other features being\r\n * present on the host. Event dependencies will be listened for when a feature of\r\n * matching type is added to the host and will stop being listened for when one\r\n * is removed. If the feature is already present when constructed, events will\r\n * be listened for right away.\r\n *\r\n * @interface\r\n *\r\n * @property {Object} EVENT_DEPENDENCIES - Events that the feature should start/stop\r\n * listening for when a feature of type FeatureName is added/removed from the host.\r\n * Event dependencies should follow the signature:\r\n *  { FeatureName: { eventName: callbackName, ... }, ... }\r\n */\r\nclass FeatureDependentInterface {\r\n  /**\r\n   * Start listening for event dependencies that match the given feature type.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} typeName - type of feature to listen for.\r\n   */\r\n  _onFeatureAdded(typeName) {}\r\n\r\n  /**\r\n   * Stop listening for event dependencies that match the given feature type.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} typeName - type of feature to stop listening for.\r\n   */\r\n  _onFeatureRemoved(typeName) {}\r\n\r\n  /**\r\n   * @augments {@link AbstractHostFeature#discard}\r\n   */\r\n  discard() {}\r\n\r\n  /**\r\n   * Creates a class that implements {@link FeatureDependentInterface} and extends\r\n   * a specified base class.\r\n   *\r\n   * @param {Class} BaseClass - The class to extend.\r\n   *\r\n   * @return {Class} A class that extends `BaseClass` and implements {@link FeatureDependentInterface}.\r\n   */\r\n  static Mixin(BaseClass) {\r\n    const FeatureDependentMixin = class extends BaseClass {\r\n      constructor(host) {\r\n        super(host);\r\n        this._host = host;\r\n\r\n        // No need to listen for events if the mixin is in the prototype chain multiple times\r\n        if (!this._initialized) {\r\n          this._initialized = true;\r\n\r\n          // Start listening for feature events\r\n          this._onFeatureAdded = this._onFeatureAdded.bind(this);\r\n          this._onFeatureRemoved = this._onFeatureRemoved.bind(this);\r\n\r\n          this._host.listenTo(\r\n            HostObject.EVENTS.addFeature,\r\n            this._onFeatureAdded\r\n          );\r\n          this._host.listenTo(\r\n            HostObject.EVENTS.removeFeature,\r\n            this._onFeatureRemoved\r\n          );\r\n\r\n          // Register features that already exist\r\n          Object.keys(this.constructor.EVENT_DEPENDENCIES).forEach(typeName => {\r\n            if (this._host[typeName] !== undefined) {\r\n              this._onFeatureAdded(typeName);\r\n            }\r\n          });\r\n        }\r\n      }\r\n\r\n      _onFeatureAdded(typeName) {\r\n        if (this.constructor.EVENT_DEPENDENCIES[typeName] !== undefined) {\r\n          const events = this.constructor.EVENT_DEPENDENCIES[typeName];\r\n\r\n          Object.entries(events).forEach(([eventName, callback]) => {\r\n            this[callback] = this[callback].bind(this);\r\n            this._host.listenTo(\r\n              this._host[typeName].EVENTS[eventName],\r\n              this[callback]\r\n            );\r\n          });\r\n        }\r\n      }\r\n\r\n      _onFeatureRemoved(typeName) {\r\n        if (this.constructor.EVENT_DEPENDENCIES[typeName] !== undefined) {\r\n          const events = this.constructor.EVENT_DEPENDENCIES[typeName];\r\n\r\n          Object.entries(events).forEach(([eventName, callback]) => {\r\n            this._host.stopListening(\r\n              this._host[typeName].EVENTS[eventName],\r\n              this[callback]\r\n            );\r\n          });\r\n        }\r\n      }\r\n\r\n      discard() {\r\n        // Stop listening for feature events\r\n        this._host.stopListening(\r\n          HostObject.EVENTS.addFeature,\r\n          this._onFeatureAdded\r\n        );\r\n        this._host.stopListening(\r\n          HostObject.EVENTS.removeFeature,\r\n          this._onFeatureRemoved\r\n        );\r\n\r\n        // Stop listening to feature-specific events\r\n        Object.keys(this.constructor.EVENT_DEPENDENCIES).forEach(typeName => {\r\n          if (this._host[typeName] !== undefined) {\r\n            this._onFeatureRemoved(typeName);\r\n          }\r\n        });\r\n\r\n        super.discard();\r\n      }\r\n    };\r\n\r\n    const EVENT_DEPENDENCIES = BaseClass.EVENT_DEPENDENCIES || {};\r\n\r\n    Object.defineProperties(FeatureDependentMixin, {\r\n      EVENT_DEPENDENCIES: {\r\n        value: {\r\n          ...EVENT_DEPENDENCIES,\r\n        },\r\n        writable: false,\r\n      },\r\n    });\r\n\r\n    return FeatureDependentMixin;\r\n  }\r\n}\r\n\r\n/**\r\n * Event dependencies should follow the signature:\r\n * {\r\n *  FeatureName: {\r\n *    // Events that the feature should start/stop listening for when a feature\r\n *    // of type FeatureName is added/removed from the host\r\n *    {\r\n *      eventName: callbackName,\r\n *      ...\r\n *    },\r\n *  }\r\n * }\r\n */\r\nObject.defineProperties(FeatureDependentInterface, {\r\n  EVENT_DEPENDENCIES: {\r\n    value: {},\r\n    writable: false,\r\n  },\r\n});\r\n\r\nexport default FeatureDependentInterface;\r\n","// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n// SPDX-License-Identifier: MIT-0\r\n\r\n/* eslint-disable no-unused-vars */\r\n/* eslint-disable max-classes-per-file */\r\nimport FeatureDependentInterface from 'core/FeatureDependentInterface';\r\n\r\n/**\r\n * Class factory interface for features that are dependent on the AnimationFeature\r\n * being present on the host. Layer and animation events will automatically be\r\n * listened for once a AnimationFeature is added to the host and stopped once it\r\n * is removed.\r\n *\r\n * @interface\r\n * @extends FeatureDependentInterface\r\n *\r\n * @property {Object} EVENT_DEPENDENCIES - Events that the feature should start/stop\r\n * listening for when a feature of type FeatureName is added/removed from the host.\r\n * @property {Object} EVENT_DEPENDENCIES.AnimationFeature - Events that are\r\n * specific to the AnimationFeature.\r\n * @property {string} [EVENT_DEPENDENCIES.AnimationFeature.addLayer='_onLayerAdded'] -\r\n * The name of the method that will be executed when AnimationFeature addLayer\r\n * events are emitted.\r\n * @property {string} [EVENT_DEPENDENCIES.AnimationFeature.removeLayer='_onLayerRemoved'] -\r\n * The name of the method that will be executed when AnimationFeature removeLayer\r\n * events are emitted.\r\n * @property {string} [EVENT_DEPENDENCIES.AnimationFeature.renameLayer='_onLayerRenamed'] -\r\n * The name of the method that will be executed when AnimationFeature renameLayer\r\n * events are emitted.\r\n * @property {string} [EVENT_DEPENDENCIES.AnimationFeature.addAnimation='_onAnimationAdded'] -\r\n * The name of the method that will be executed when AnimationFeature addAnimation\r\n * events are emitted.\r\n * @property {string} [EVENT_DEPENDENCIES.AnimationFeature.removeAnimation='_onAnimationRemoved'] -\r\n * The name of the method that will be executed when AnimationFeature removeAnimation\r\n * events are emitted.\r\n * @property {string} [EVENT_DEPENDENCIES.AnimationFeature.renameAnimation='_onAnimationRenamed'] -\r\n * The name of the method that will be executed when AnimationFeature renameAnimation\r\n * events are emitted.\r\n */\r\nclass AnimationFeatureDependentInterface extends FeatureDependentInterface {\r\n  /**\r\n   * Executed when animation layer added events are caught.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} name - Name of the layer that was added.\r\n   */\r\n  _onLayerAdded({name}) {}\r\n\r\n  /**\r\n   * Executed when animation layer removed events are caught.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} name - Name of the layer that was removed.\r\n   */\r\n  _onLayerRemoved({name}) {}\r\n\r\n  /**\r\n   * Executed when animation layer renamed events are caught.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} oldName - Name of the layer that was renamed.\r\n   * @param {string} newName - New name of the layer.\r\n   */\r\n  _onLayerRenamed({oldName, newName}) {}\r\n\r\n  /**\r\n   * Executed when animation added events are caught.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} layerName - Name of the layer that an animation was added to.\r\n   * @param {string} animationName - Name of the animation that was added.\r\n   */\r\n  _onAnimationAdded({layerName, animationName}) {}\r\n\r\n  /**\r\n   * Executed when animation removed events are caught.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} layerName - Name of the layer that an animation was removed from.\r\n   * @param {string} animationName - Name of the animation that was removed.\r\n   */\r\n  _onAnimationRemoved({layerName, animationName}) {}\r\n\r\n  /**\r\n   * Executed when animation renamed events are caught.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} layerName - Name of the layer that an animation belongs to.\r\n   * @param {string} oldName - Name of the animation that was renamed.\r\n   * @param {string} newName - New name of the animation.\r\n   */\r\n  _onAnimationRenamed({layerName, oldName, newName}) {}\r\n\r\n  /**\r\n   * Creates a class that implements {@link AnimationFeatureDependentInterface}\r\n   * and extends a specified base class.\r\n   *\r\n   * @param {Class} BaseClass - The class to extend.\r\n   *\r\n   * @return {Class} A class that extends `BaseClass` and implements {@link AnimationFeatureDependentInterface}.\r\n   */\r\n  static Mixin(BaseClass) {\r\n    const ParentClass = FeatureDependentInterface.Mixin(BaseClass);\r\n    const AnimationFeatureDependentMixin = class extends ParentClass {\r\n      _onLayerAdded({name}) {}\r\n\r\n      _onLayerRemoved({name}) {}\r\n\r\n      _onLayerRenamed({oldName, newName}) {}\r\n\r\n      _onAnimationAdded({layerName, animationName}) {}\r\n\r\n      _onAnimationRemoved({layerName, animationName}) {}\r\n\r\n      _onAnimationRenamed({layerName, oldName, newName}) {}\r\n    };\r\n\r\n    Object.defineProperties(AnimationFeatureDependentMixin, {\r\n      EVENT_DEPENDENCIES: {\r\n        value: {\r\n          ...ParentClass.EVENT_DEPENDENCIES,\r\n          ...AnimationFeatureDependentInterface.EVENT_DEPENDENCIES,\r\n        },\r\n        writable: false,\r\n      },\r\n    });\r\n\r\n    return AnimationFeatureDependentMixin;\r\n  }\r\n}\r\n\r\nObject.defineProperties(AnimationFeatureDependentInterface, {\r\n  EVENT_DEPENDENCIES: {\r\n    value: {\r\n      AnimationFeature: {\r\n        addLayer: '_onLayerAdded',\r\n        removeLayer: '_onLayerRemoved',\r\n        renameLayer: '_onLayerRenamed',\r\n        addAnimation: '_onAnimationAdded',\r\n        removeAnimation: '_onAnimationRemoved',\r\n        renameAnimation: '_onAnimationRenamed',\r\n      },\r\n    },\r\n    writable: false,\r\n  },\r\n});\r\n\r\nexport default AnimationFeatureDependentInterface;\r\n","// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n// SPDX-License-Identifier: MIT-0\r\n\r\n/* eslint-disable no-unused-vars */\r\n/* eslint-disable max-classes-per-file */\r\nimport AnimationFeatureDependentInterface from 'core/animpack/AnimationFeatureDependentInterface';\r\n\r\n/**\r\n * Class factory interface for that keeps track of layers and animations on a host.\r\n * Tracked assets are marked as inactive until layers and animations with matching\r\n * names are detected as present on the host.\r\n *\r\n * @interface\r\n * @extends AnimationFeatureDependentInterface\r\n *\r\n * @property {Object} DEFAULT_LAYER_OPTIONS - Default options to use when executing\r\n * {@link AnimationLayer} methods.\r\n * @property {number} [DEFAULT_LAYER_OPTIONS.blendTime=0.5] - Default time in seconds\r\n * to use when executing {@link AnimationLayer.setBlendWeight}.\r\n * @property {Object} [DEFAULT_LAYER_OPTIONS.animations={}] - Maps animation names\r\n * to default options objects to use for managed animations.\r\n */\r\nclass ManagedAnimationLayerInterface extends AnimationFeatureDependentInterface {\r\n  /**\r\n   * Start tracking keeping track of whether a layer with the given name is present\r\n   * on the host.\r\n   *\r\n   * @param {string} name - Name of the layer to keep track of.\r\n   * @param {Object=} options - Options for the layer.\r\n   * @param {number=} options.blendTime - Default amount of time to use when\r\n   * manipulating layer weights on this layer.\r\n   * @param {Function=} options.easingFn - Default easing function to use when\r\n   * manipulating layer weights on this layer.\r\n   * @param {Object=} options.animations - Animations to keep track of on the layer.\r\n   * Animations are represented as key/value pairs of animation names and their\r\n   * options.\r\n   */\r\n  registerLayer(name, options = {}) {}\r\n\r\n  /**\r\n   * Start tracking keeping track of whether an animation with the given name is\r\n   * present on the host.\r\n   *\r\n   * @param {string} layerName - Name of the layer that will own the animation.\r\n   * @param {string} animationName - Name of the animation to keep track of.\r\n   * @param {Object=} options - Options for the animation.\r\n   */\r\n  registerAnimation(layerName, animationName, options = {}) {}\r\n\r\n  /**\r\n   * Set layer weights on tracked layers.\r\n   *\r\n   * @param {Function=} nameFilter - Predicate function to test each tracked layer\r\n   * with. By default all layers will pass.\r\n   * @param {number} weight - Weight value to set on layers.\r\n   * @param {number=} seconds - Number of seconds it will take to reach the weight\r\n   * on each layer. If undefined, each layers' blendTime option is used.\r\n   * @param {Function=} easingFn - Easing function to use when setting weight\r\n   * on each layer. If undefined, each layers' easingFn option is used.\r\n   */\r\n  setLayerWeights(nameFilter = () => true, weight, seconds, easingFn) {}\r\n\r\n  /**\r\n   * Set all tracked layers' weights to 1.\r\n   *\r\n   * @param {number=} seconds - Number of seconds it will take to reach the weight\r\n   * on each layer. If undefined, each layers' blendTime option is used.\r\n   * @param {Function=} easingFn - Easing function to use when setting weight\r\n   * on each layer. If undefined, each layers' easingFn option is used.\r\n   */\r\n  enable(seconds, easingFn) {}\r\n\r\n  /**\r\n   * Set all tracked layers' weights to 0.\r\n   *\r\n   * @param {number=} seconds - Number of seconds it will take to reach the weight\r\n   * on each layer. If undefined, each layers' blendTime option is used.\r\n   * @param {Function=} easingFn - Easing function to use when setting weight\r\n   * on each layer. If undefined, each layers' easingFn option is used.\r\n   */\r\n  disable(seconds, easingFn) {}\r\n\r\n  /**\r\n   * Creates a class that implements {@link ManagedAnimationLayerInterface}\r\n   * and extends a specified base class.\r\n   *\r\n   * @param {Class} BaseClass - The class to extend.\r\n   *\r\n   * @return {Class} A class that extends `BaseClass` and implements {@link ManagedAnimationLayerInterface}.\r\n   */\r\n  static Mixin(BaseClass) {\r\n    const ParentClass = AnimationFeatureDependentInterface.Mixin(BaseClass);\r\n    const ManagedAnimationLayerMixin = class extends ParentClass {\r\n      constructor(...args) {\r\n        super(...args);\r\n\r\n        this._managedLayers = {};\r\n      }\r\n\r\n      _onFeatureAdded(typeName) {\r\n        super._onFeatureAdded(typeName);\r\n\r\n        if (typeName !== 'AnimationFeature') {\r\n          return;\r\n        }\r\n\r\n        this._managedLayers = this._managedLayers || {};\r\n\r\n        // Detect new layers\r\n        this._host.AnimationFeature.layers.forEach(name => {\r\n          this._onLayerAdded({name});\r\n        });\r\n      }\r\n\r\n      _onFeatureRemoved(typeName) {\r\n        super._onFeatureRemoved(typeName);\r\n\r\n        if (typeName !== 'AnimationFeature') {\r\n          return;\r\n        }\r\n\r\n        this._managedLayers = this._managedLayers || {};\r\n\r\n        // Deactivate the layers\r\n        Object.keys(this._managedLayers).forEach(name => {\r\n          this._onLayerRemoved({name});\r\n        });\r\n      }\r\n\r\n      _onLayerAdded({name}) {\r\n        // Mark the layer as active if it is managed\r\n        if (this._managedLayers[name] !== undefined) {\r\n          this._managedLayers[name].isActive = true;\r\n\r\n          // Detect new animations\r\n          this._host.AnimationFeature.getAnimations(name).forEach(animName => {\r\n            this._onAnimationAdded({layerName: name, animationName: animName});\r\n          });\r\n        }\r\n      }\r\n\r\n      _onLayerRemoved({name}) {\r\n        // Deactivate the layer if it is managed\r\n        if (this._managedLayers[name] !== undefined) {\r\n          this._managedLayers[name].isActive = false;\r\n\r\n          // Deactivate the animations\r\n          Object.keys(this._managedLayers[name].animations).forEach(\r\n            animName => {\r\n              this._onAnimationRemoved({\r\n                layerName: name,\r\n                animationName: animName,\r\n              });\r\n            }\r\n          );\r\n        }\r\n      }\r\n\r\n      _onLayerRenamed({oldName, newName}) {\r\n        const layerOptions = this._managedLayers[oldName];\r\n\r\n        // Replace the layer key with the new name\r\n        if (layerOptions !== undefined) {\r\n          delete this._managedLayers[oldName];\r\n          this._managedLayers[newName] = layerOptions;\r\n        }\r\n      }\r\n\r\n      _onAnimationAdded({layerName, animationName}) {\r\n        // Mark the animation as active if it is managed\r\n        if (\r\n          this._managedLayers[layerName] !== undefined &&\r\n          this._managedLayers[layerName].animations[animationName] !== undefined\r\n        ) {\r\n          this._managedLayers[layerName].animations[\r\n            animationName\r\n          ].isActive = true;\r\n        }\r\n      }\r\n\r\n      _onAnimationRemoved({layerName, animationName}) {\r\n        // Deactivate the animation if it is managed\r\n        if (\r\n          this._managedLayers[layerName] !== undefined &&\r\n          this._managedLayers[layerName].animations[animationName] !== undefined\r\n        ) {\r\n          this._managedLayers[layerName].animations[\r\n            animationName\r\n          ].isActive = false;\r\n        }\r\n      }\r\n\r\n      _onAnimationRenamed({layerName, oldName, newName}) {\r\n        if (\r\n          this._managedLayers[layerName] !== undefined &&\r\n          this._managedLayers[layerName].animations[oldName] !== undefined\r\n        ) {\r\n          // Replace the animation key with the new name\r\n          const animOptions = this._managedLayers[layerName].animations[\r\n            oldName\r\n          ];\r\n          delete this._managedLayers[layerName].animations[oldName];\r\n          this._managedLayers[layerName].animations[newName] = animOptions;\r\n        }\r\n      }\r\n\r\n      registerLayer(name, options = {}) {\r\n        // Start with default options for each new layer\r\n        if (this._managedLayers[name] === undefined) {\r\n          this._managedLayers[name] = {\r\n            ...this.constructor.DEFAULT_LAYER_OPTIONS,\r\n            animations: {},\r\n          };\r\n        }\r\n\r\n        // Update all options except animations\r\n        const layerOptions = this._managedLayers[name];\r\n        options = {...options};\r\n        const animationOptions = options.animations || {};\r\n        delete options.animations;\r\n        Object.assign(layerOptions, options);\r\n\r\n        // Check whether the layer can be manipulated now\r\n        layerOptions.isActive =\r\n          this._host.AnimationFeature !== undefined &&\r\n          this._host.AnimationFeature.layers.includes(name);\r\n\r\n        // Register the animations\r\n        Object.entries(animationOptions).forEach(([animName, animOptions]) => {\r\n          this.registerAnimation(name, animName, animOptions);\r\n        });\r\n      }\r\n\r\n      registerAnimation(layerName, animationName, options = {}) {\r\n        // Register the layer if it hasn't been registered yet\r\n        if (this._managedLayers[layerName] === undefined) {\r\n          this.registerLayer(layerName);\r\n        }\r\n\r\n        // Update animation options\r\n        const animOptions =\r\n          this._managedLayers[layerName].animations[animationName] || {};\r\n        Object.assign(animOptions, options);\r\n        this._managedLayers[layerName].animations[animationName] = animOptions;\r\n\r\n        // Check whether the animation can be manipulated now\r\n        this._managedLayers[layerName].animations[animationName].isActive =\r\n          this._managedLayers[layerName].isActive &&\r\n          this._host.AnimationFeature.getAnimations(layerName).includes(\r\n            animationName\r\n          );\r\n      }\r\n\r\n      setLayerWeights(nameFilter = () => true, weight, seconds, easingFn) {\r\n        const layerNames = Object.keys(this._managedLayers).filter(nameFilter);\r\n\r\n        layerNames.forEach(name => {\r\n          const layerOptions = this._managedLayers[name];\r\n\r\n          if (layerOptions.isActive) {\r\n            this._host.AnimationFeature.setLayerWeight(\r\n              name,\r\n              weight,\r\n              seconds !== undefined ? seconds : layerOptions.blendTime,\r\n              easingFn || layerOptions.easingFn\r\n            );\r\n          }\r\n        });\r\n      }\r\n\r\n      enable(seconds, easingFn) {\r\n        this.setLayerWeights(undefined, 1, seconds, easingFn);\r\n      }\r\n\r\n      disable(seconds, easingFn) {\r\n        this.setLayerWeights(undefined, 0, seconds, easingFn);\r\n      }\r\n\r\n      installApi() {\r\n        const api = super.installApi();\r\n\r\n        Object.assign(api, {\r\n          registerLayer: this.registerLayer.bind(this),\r\n          registerAnimation: this.registerAnimation.bind(this),\r\n          setLayerWeights: this.setLayerWeights.bind(this),\r\n          enable: this.enable.bind(this),\r\n          disable: this.disable.bind(this),\r\n        });\r\n\r\n        return api;\r\n      }\r\n    };\r\n\r\n    Object.defineProperties(ManagedAnimationLayerMixin, {\r\n      DEFAULT_LAYER_OPTIONS: {\r\n        value: ManagedAnimationLayerInterface.DEFAULT_LAYER_OPTIONS,\r\n        writable: false,\r\n      },\r\n    });\r\n\r\n    return ManagedAnimationLayerMixin;\r\n  }\r\n}\r\n\r\nObject.defineProperties(ManagedAnimationLayerInterface, {\r\n  DEFAULT_LAYER_OPTIONS: {\r\n    value: {blendTime: 0.5, animations: {}},\r\n    writable: false,\r\n  },\r\n});\r\n\r\nexport default ManagedAnimationLayerInterface;\r\n","// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n// SPDX-License-Identifier: MIT-0\r\n\r\n/* eslint-disable max-classes-per-file */\r\nimport FeatureDependentInterface from 'core/FeatureDependentInterface';\r\n\r\n/**\r\n * Class factory interface for features that are dependent on the TextToSpeechFeature\r\n * being present on the host. Speech events will automatically be listened for once a\r\n * TextToSpeechFeature is added to the host and stopped once it is removed.\r\n *\r\n * @interface\r\n * @extends FeatureDependentInterface\r\n *\r\n * @property {Object} EVENT_DEPENDENCIES - Events that the feature should start/stop\r\n * listening for when a feature of type FeatureName is added/removed from the host.\r\n * @property {Object} EVENT_DEPENDENCIES.TextToSpeechFeature - Events that are\r\n * specific to the TextToSpeechFeature.\r\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.play='_onPlay'] -\r\n * The name of the method that will be executed when TextToSpeechFeature play\r\n * events are emitted.\r\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.pause='_onPause'] -\r\n * The name of the method that will be executed when TextToSpeechFeature pause\r\n * events are emitted.\r\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.resume='_onResume'] -\r\n * The name of the method that will be executed when TextToSpeechFeature resume\r\n * events are emitted.\r\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.stop='_onStop'] -\r\n * The name of the method that will be executed when TextToSpeechFeature stop\r\n * events are emitted.\r\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.sentence='_onSentence'] -\r\n * The name of the method that will be executed when TextToSpeechFeature sentence\r\n * events are emitted.\r\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.word='_onWord'] -\r\n * The name of the method that will be executed when TextToSpeechFeature word\r\n * events are emitted.\r\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.viseme='_onViseme'] -\r\n * The name of the method that will be executed when TextToSpeechFeature viseme\r\n * events are emitted.\r\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.ssml='_onSsml'] -\r\n * The name of the method that will be executed when TextToSpeechFeature ssml\r\n * events are emitted.\r\n */\r\nclass TextToSpeechFeatureDependentInterface extends FeatureDependentInterface {\r\n  /**\r\n   * Executed when speech play events are caught.\r\n   *\r\n   * @private\r\n   */\r\n  _onPlay() {}\r\n\r\n  /**\r\n   * Executed when speech pause events are caught.\r\n   *\r\n   * @private\r\n   */\r\n  _onPause() {}\r\n\r\n  /**\r\n   * Executed when speech resume events are caught.\r\n   *\r\n   * @private\r\n   */\r\n  _onResume() {}\r\n\r\n  /**\r\n   * Executed when speech stop events are caught.\r\n   *\r\n   * @private\r\n   */\r\n  _onStop() {}\r\n\r\n  /**\r\n   * Executed when speech sentence events are caught.\r\n   *\r\n   * @private\r\n   */\r\n  _onSentence() {}\r\n\r\n  /**\r\n   * Executed when speech word events are caught.\r\n   *\r\n   * @private\r\n   */\r\n  _onWord() {}\r\n\r\n  /**\r\n   * Executed when speech viseme events are caught.\r\n   *\r\n   * @private\r\n   */\r\n  _onViseme() {}\r\n\r\n  /**\r\n   * Executed when speech ssml events are caught.\r\n   *\r\n   * @private\r\n   */\r\n  _onSsml() {}\r\n\r\n  /**\r\n   * Creates a class that implements {@link TextToSpeechFeatureDependentInterface}\r\n   * and extends a specified base class.\r\n   *\r\n   * @param {Class} BaseClass - The class to extend.\r\n   *\r\n   * @return {Class} A class that extends `BaseClass` and implements {@link TextToSpeechFeatureDependentInterface}.\r\n   */\r\n  static Mixin(BaseClass) {\r\n    const ParentClass = FeatureDependentInterface.Mixin(BaseClass);\r\n    const TextToSpeechFeatureDependentMixin = class extends ParentClass {\r\n      _onPlay() {}\r\n\r\n      _onPause() {}\r\n\r\n      _onResume() {}\r\n\r\n      _onStop() {}\r\n\r\n      _onSentence() {}\r\n\r\n      _onWord() {}\r\n\r\n      _onViseme() {}\r\n\r\n      _onSsml() {}\r\n    };\r\n\r\n    Object.defineProperties(TextToSpeechFeatureDependentMixin, {\r\n      EVENT_DEPENDENCIES: {\r\n        value: {\r\n          ...ParentClass.EVENT_DEPENDENCIES,\r\n          ...TextToSpeechFeatureDependentInterface.EVENT_DEPENDENCIES,\r\n        },\r\n        writable: false,\r\n      },\r\n    });\r\n\r\n    return TextToSpeechFeatureDependentMixin;\r\n  }\r\n}\r\n\r\nObject.defineProperties(TextToSpeechFeatureDependentInterface, {\r\n  EVENT_DEPENDENCIES: {\r\n    value: {\r\n      TextToSpeechFeature: {\r\n        play: '_onPlay',\r\n        pause: '_onPause',\r\n        resume: '_onResume',\r\n        stop: '_onStop',\r\n        sentence: '_onSentence',\r\n        word: '_onWord',\r\n        viseme: '_onViseme',\r\n        ssml: '_onSsml',\r\n      },\r\n    },\r\n    writable: false,\r\n  },\r\n});\r\n\r\nexport default TextToSpeechFeatureDependentInterface;\r\n","// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n// SPDX-License-Identifier: MIT-0\r\nimport MathUtils from './MathUtils';\r\nimport {Quadratic} from './animpack/Easing';\r\nimport ManagedAnimationLayerInterface from './animpack/ManagedAnimationLayerInterface';\r\nimport TextToSpeechFeatureDependentInterface from './awspack/TextToSpeechFeatureDependentInterface';\r\nimport AbstractHostFeature from './AbstractHostFeature';\r\n\r\n/**\r\n * Default mapping of Polly viseme names to animation options objects.\r\n *\r\n * @property {Object} [sil={name: 'sil'}]\r\n * @property {Object} [p={name: 'p', overrideWeight: 0.9}]\r\n * @property {Object} [t={name: 't', blendTime: 0.2}]\r\n * @property {Object} [S={name: 'S'}]\r\n * @property {Object} [T={name: 'T'}]\r\n * @property {Object} [f={name: 'f', overrideWeight: 0.75}]\r\n * @property {Object} [k={name: 'k'}]\r\n * @property {Object} [i={name: 'i'}]\r\n * @property {Object} [r={name: 'r'}]\r\n * @property {Object} [s={name: 's', blendTime: 0.25}]\r\n * @property {Object} [u={name: 'u'}]\r\n * @property {Object} [@={name: '@'}]\r\n * @property {Object} [a={name: 'a'}]\r\n * @property {Object} [e={name: 'e', blendTime: 0.2}]\r\n * @property {Object} [E={name: 'E'}]\r\n * @property {Object} [o={name: 'o'}]\r\n * @property {Object} [O={name: 'O'}]\r\n */\r\nconst DefaultVisemeMap = {\r\n  sil: {name: 'sil'},\r\n  p: {name: 'p', overrideWeight: 0.9},\r\n  t: {name: 't', blendTime: 0.2},\r\n  S: {name: 'S'},\r\n  T: {name: 'T'},\r\n  f: {name: 'f', overrideWeight: 0.75},\r\n  k: {name: 'k'},\r\n  i: {name: 'i'},\r\n  r: {name: 'r'},\r\n  s: {name: 's', blendTime: 0.25},\r\n  u: {name: 'u'},\r\n  '@': {name: '@'},\r\n  a: {name: 'a'},\r\n  e: {name: 'e', blendTime: 0.2},\r\n  E: {name: 'E'},\r\n  o: {name: 'o'},\r\n  O: {name: 'O'},\r\n};\r\n\r\n/**\r\n * Lipsync controls two types of movement: idle animation that should play while\r\n * speech is playing and viseme animations corresponding to Polly visemes whose\r\n * weights should be turned on and off as they are encountered in the Polly SSML\r\n * transcript. Layers owned by this feature will be enabled while speech is playing\r\n * and disabled once it stops.\r\n *\r\n * @extends AbstractHostFeature\r\n * @alias core/LipsyncFeature\r\n * @implements TextToSpeechFeatureDependentInterface\r\n * @implements ManagedAnimationLayerInterface\r\n */\r\nclass LipsyncFeature extends AbstractHostFeature.mix(\r\n  TextToSpeechFeatureDependentInterface.Mixin,\r\n  ManagedAnimationLayerInterface.Mixin\r\n) {\r\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {core/HostObject} host - Host that owns the feature.\r\n   * @param {Object=} visemeOptions - Options for the viseme layers.\r\n   * @param {number} [visemeOptions.blendTime=0.15] - Default amount of time it\r\n   * will take to manipulate each freeBlend weight on the viseme states.\r\n   * @param {Object} [visemeOptions.decayRate={amount: .5, seconds: .5}] - An object\r\n   * describing the 0-1 factor viseme weight will decay if the viseme duration is\r\n   * longer than the blendTime and the number of seconds it would take to decay\r\n   * by that factor.\r\n   * @param {number} [visemeOptions.easingFn=Quadratic.InOut] - Default easing function\r\n   * to use when manipulating viseme freeBlend weights.\r\n   * @param {Array.<Object>} [visemeOptions..layers=[]] - An array of layer options\r\n   * objects to register as viseme layers.\r\n   * @param {Object=} talkingOptions - Options for the talking layers.\r\n   * @param {number} [talkingOptions.blendTime=0.75] - Default amount of time to\r\n   * enable and disable the talking idle layers\r\n   * @param {number} [talkingOptions.easingFn=Quadratic.InOut] - Default easing\r\n   * function to use when manipulating weights on the talking idle layers.\r\n   * @param {Array.<Object>} [talkingOptions.layers=[]] - An array of layer options\r\n   * objects to register as talking layers.\r\n   * @param {number} [visemeLeadTime=.067] - The amount of time to instruct the\r\n   * TextToSpeechFeature to emit speechmarks before each one's actual timestamp\r\n   * is reached. This will set the 'speechMarkOffset' variable on the TextToSpeechFeature.\r\n   */\r\n  constructor(\r\n    host,\r\n    {\r\n      blendTime: visemeBlendTime = 0.15,\r\n      decayRate: {amount = 0.5, seconds = 0.5} = {},\r\n      easingFn: visemeEasingFn = Quadratic.InOut,\r\n      layers: visemeLayers = [],\r\n    } = {},\r\n    {\r\n      blendTime: talkingBlendTime = 0.75,\r\n      easingFn: talkingEasingFn = Quadratic.InOut,\r\n      layers: talkingLayers = [],\r\n    } = {},\r\n    visemeLeadTime = 0.067\r\n  ) {\r\n    super(host);\r\n\r\n    this._visemeLayers = {};\r\n    this._talkingLayers = {};\r\n    this.visemeLeadTime = visemeLeadTime;\r\n\r\n    // Register the viseme layers\r\n    visemeLayers.forEach(({name, animation, visemeMap = DefaultVisemeMap}) => {\r\n      this.registerVisemeLayer(name, {\r\n        animation,\r\n        visemeMap,\r\n        decayRate: {amount, seconds},\r\n        blendTime: visemeBlendTime,\r\n        easingFn: visemeEasingFn,\r\n      });\r\n    });\r\n\r\n    // Register the talking layers\r\n    talkingLayers.forEach(({name, animation}) => {\r\n      this.registerTalkingLayer(name, {\r\n        animation,\r\n        blendTime: talkingBlendTime,\r\n        easingFn: talkingEasingFn,\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Ensure that registered viseme animations are FreeBlendStates.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} layerName - Name of the layer that contains the viseme animation.\r\n   * @param {string} animationName - Name of the animation.\r\n   */\r\n  _registerVisemeAnimation(layerName, animationName) {\r\n    if (this._managedLayers[layerName].animations[animationName].isActive) {\r\n      if (\r\n        this._host.AnimationFeature.getAnimationType(\r\n          layerName,\r\n          animationName\r\n        ) !== 'freeBlend'\r\n      ) {\r\n        // Warn and deactivate if the registered state is not freeBlend\r\n        console.warn(\r\n          `Cannot register Lipsync viseme animation ${animationName} on layer ${layerName} for host ${this._host.id}. Viseme animations must be of type 'freeBlend'.`\r\n        );\r\n        this._managedLayers[layerName].animations[\r\n          animationName\r\n        ].isActive = false;\r\n      } else {\r\n        // Check if the blendWeights can be manipulated now\r\n        const weightNames = this._host.AnimationFeature.getAnimationBlendNames(\r\n          layerName,\r\n          animationName\r\n        );\r\n        const {visemeMap} = this._managedLayers[layerName].animations[\r\n          animationName\r\n        ];\r\n\r\n        Object.values(visemeMap).forEach(visemeOptions => {\r\n          visemeOptions.isActive = weightNames.includes(visemeOptions.name);\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * If the added feature is TextToSpeech, update its speechMarkOffset variable.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} typeName - Name of the type of feature that was added.\r\n   */\r\n  _onFeatureAdded(typeName) {\r\n    this._visemeLayers = this._visemeLayers || {};\r\n    this._talkingLayers = this._talkingLayers || {};\r\n\r\n    super._onFeatureAdded(typeName);\r\n\r\n    if (typeName === 'TextToSpeechFeature') {\r\n      this._host.TextToSpeechFeature.speechmarkOffset =\r\n        -this._visemeLeadTime || 0;\r\n    }\r\n  }\r\n\r\n  _onLayerAdded({name}) {\r\n    super._onLayerAdded({name});\r\n\r\n    // Validate the viseme animation\r\n    if (this._visemeLayers[name] !== undefined) {\r\n      this._registerVisemeAnimation(name, this._visemeLayers[name]);\r\n    }\r\n  }\r\n\r\n  _onAnimationAdded({layerName, animationName}) {\r\n    super._onAnimationAdded({layerName});\r\n\r\n    // Validate the viseme animation\r\n    if (this._visemeLayers[layerName] === animationName) {\r\n      this._registerVisemeAnimation(layerName, this._visemeLayers[layerName]);\r\n    }\r\n  }\r\n\r\n  _onPlay() {\r\n    // Turn on the layer weights\r\n    this.enable();\r\n\r\n    // Set the current animations\r\n    [this._visemeLayers, this._talkingLayers].forEach(layers => {\r\n      Object.entries(layers).forEach(([layerName, animationName]) => {\r\n        if (this._managedLayers[layerName].animations[animationName].isActive) {\r\n          this._host.AnimationFeature.resumeAnimation(layerName, animationName);\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  _onPause() {\r\n    this._onStop();\r\n  }\r\n\r\n  _onResume() {\r\n    this._onPlay();\r\n  }\r\n\r\n  _onStop() {\r\n    // Turn off the layer weights\r\n    this.disable();\r\n\r\n    // Pause the current animations\r\n    [this._visemeLayers, this._talkingLayers].forEach(layers => {\r\n      Object.entries(layers).forEach(([layerName, animationName]) => {\r\n        if (this._managedLayers[layerName].animations[animationName].isActive) {\r\n          this._host.AnimationFeature.pauseAnimation(layerName, animationName);\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * When viseme events are caught, turn on weight of the new viseme for the duration\r\n   * of the speech mark, then turn weight back off.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {Object} event - Event data passed from the speech.\r\n   * @param {Object} event.mark - Speechmark object.\r\n   */\r\n  async _onViseme({mark}) {\r\n    Object.entries(this._visemeLayers).forEach(([layerName, animName]) => {\r\n      // Make sure the layer can be manipulated\r\n      const {isActive, visemeMap} = this._managedLayers[layerName].animations[\r\n        animName\r\n      ];\r\n\r\n      if (!isActive) {\r\n        return;\r\n      }\r\n\r\n      // Take variables from the viseme if they exist and default to the layer\r\n      const {\r\n        name: viseme,\r\n        isActive: isVisemeActive,\r\n        decayRate,\r\n        blendTime,\r\n        easingFn,\r\n        overrideWeight,\r\n      } = {\r\n        ...this._managedLayers[layerName],\r\n        ...visemeMap[mark.value],\r\n      };\r\n\r\n      const visemeNames = this._host.AnimationFeature.getAnimationBlendNames(\r\n        layerName,\r\n        animName\r\n      );\r\n\r\n      // Make sure the new viseme has an active freeBlend weight\r\n      if (!isVisemeActive || !visemeNames.includes(viseme)) {\r\n        return;\r\n      }\r\n\r\n      // Find the peak weight for the viseme and the amount of time it should\r\n      // take to reach it\r\n      let weight = 1;\r\n      const duration = mark.duration / 1000;\r\n      if (duration < blendTime) {\r\n        const lerpFactor = blendTime > 0 ? duration / blendTime : 1;\r\n        weight =\r\n          overrideWeight !== undefined\r\n            ? overrideWeight\r\n            : MathUtils.lerp(0, 1, lerpFactor);\r\n      }\r\n      const blendInTime = Math.min(duration, blendTime);\r\n\r\n      // Find the amount and time viseme will be held for\r\n      const holdTime = duration - blendTime;\r\n\r\n      if (holdTime < 0) {\r\n        // Perform in -> out animation\r\n        this._animateSimpleViseme(\r\n          layerName,\r\n          animName,\r\n          viseme,\r\n          weight,\r\n          blendInTime,\r\n          blendTime,\r\n          easingFn\r\n        );\r\n      } else {\r\n        const lerpFactor =\r\n          decayRate.seconds > 0 ? holdTime / decayRate.seconds : 1;\r\n        // Perform in -> hold -> out animation\r\n        const decayWeight = MathUtils.lerp(\r\n          weight,\r\n          weight * decayRate.amount,\r\n          Math.min(1, lerpFactor)\r\n        );\r\n        this._animateHeldViseme(\r\n          layerName,\r\n          animName,\r\n          viseme,\r\n          weight,\r\n          decayWeight,\r\n          blendInTime,\r\n          holdTime,\r\n          blendTime,\r\n          easingFn\r\n        );\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Animate a viseme blend weight towards a value and then back to zero.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} layerName - Name of the layer that contains the viseme.\r\n   * @param {string} animName - Name of the freeblend animation that contains\r\n   * the viseme.\r\n   * @param {string} visemeName - Name of the blend weight to manipulate.\r\n   * @param {number} weight - Peak weight to animate towards.\r\n   * @param {number} blendInTime - Amount of time it should take to reach the\r\n   * peak weight.\r\n   * @param {number} blendOutTime - Amount of time it should take to animate back\r\n   * to zero after reaching the peak weight.\r\n   * @param {Function} easingFn - Easing function to use during animation.\r\n   */\r\n  _animateSimpleViseme(\r\n    layerName,\r\n    animName,\r\n    visemeName,\r\n    peakWeight,\r\n    blendInTime,\r\n    blendOutTime,\r\n    easingFn\r\n  ) {\r\n    // Animate towards the peak value\r\n    const weightPromise = this._host.AnimationFeature.setAnimationBlendWeight(\r\n      layerName,\r\n      animName,\r\n      visemeName,\r\n      peakWeight,\r\n      blendInTime,\r\n      easingFn\r\n    );\r\n\r\n    // Animate back to zero if there was no weight interruption\r\n    weightPromise.then(() => {\r\n      if (!weightPromise.canceled) {\r\n        this._host.AnimationFeature.setAnimationBlendWeight(\r\n          layerName,\r\n          animName,\r\n          visemeName,\r\n          0,\r\n          blendOutTime,\r\n          easingFn\r\n        );\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Animate a viseme blend weight towards a value and then back to zero.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} layerName - Name of the layer that contains the viseme.\r\n   * @param {string} animName - Name of the freeblend animation that contains\r\n   * the viseme.\r\n   * @param {string} visemeName - Name of the blend weight to manipulate.\r\n   * @param {number} peakWeight - Peak weight to animate towards.\r\n   * @param {number} decayWeight - Weight to animate towards after reaching the\r\n   * peak weight.\r\n   * @param {number} blendInTime - Amount of time it should take to reach the\r\n   * peak weight.\r\n   * @param {number} holdTime - Amount of time it should take to reach the decay\r\n   * weight after the peak weight has been reached.\r\n   * @param {number} blendOutTime - Amount of time it should take to animate back\r\n   * to zero after reaching the decay weight.\r\n   * @param {Function} easingFn - Easing function to use during animation.\r\n   */\r\n  async _animateHeldViseme(\r\n    layerName,\r\n    animName,\r\n    visemeName,\r\n    peakWeight,\r\n    decayWeight,\r\n    blendInTime,\r\n    holdTime,\r\n    blendOutTime,\r\n    easingFn\r\n  ) {\r\n    // Animate towards the peak value\r\n    const startPromise = this._host.AnimationFeature.setAnimationBlendWeight(\r\n      layerName,\r\n      animName,\r\n      visemeName,\r\n      peakWeight,\r\n      blendInTime,\r\n      easingFn\r\n    );\r\n\r\n    await startPromise;\r\n\r\n    if (!startPromise.canceled) {\r\n      // Animate towards the decay value if there was no weight interruption\r\n      const holdPromise = this._host.AnimationFeature.setAnimationBlendWeight(\r\n        layerName,\r\n        animName,\r\n        visemeName,\r\n        decayWeight,\r\n        holdTime,\r\n        easingFn\r\n      );\r\n\r\n      await holdPromise;\r\n\r\n      if (!holdPromise.canceled) {\r\n        // Animate back to zero if there was no weight interruption\r\n        this._host.AnimationFeature.setAnimationBlendWeight(\r\n          layerName,\r\n          animName,\r\n          visemeName,\r\n          0,\r\n          blendOutTime,\r\n          easingFn\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets and sets the amount of time in seconds to negatively offset speechmark\r\n   * emission by.\r\n   *\r\n   * @type {number}\r\n   */\r\n  get visemeLeadTime() {\r\n    return this._visemeLeadTime;\r\n  }\r\n\r\n  set visemeLeadTime(seconds) {\r\n    this._visemeLeadTime = seconds;\r\n\r\n    if (this._host.TextToSpeechFeature) {\r\n      this._host.TextToSpeechFeature.speechmarkOffset = -seconds;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start keeping track of an animation layer that owns a freeBlend animation\r\n   * with blendWeights corresponding to visemes.\r\n   *\r\n   * @param {string} layerName - Name of the layer to keep track of.\r\n   * @param {Object=} options - Options for the layer.\r\n   * @param {string} [options.animation='visemes'] - Name of the animation on the\r\n   * layer that will be played during speech. This animation must be of type\r\n   * freeBlend.\r\n   * @param {Object=} decayRate\r\n   * @param {number} [decayRate.amount=0.5] - The percentage to decrease the viseme's\r\n   * peak value by over time once the peak value has been reached.\r\n   * @param {number} [decayRate.seconds=0.5] - The amount of time in seconds to\r\n   * decrease the viseme's weight once it has reached its peak value.\r\n   * @param {number=} [options.blendTime=[LipsyncFeature.DEFAULT_LAYER_OPTIONS.blendTime]{@link LipsyncFeature#DEFAULT_LAYER_OPTIONS#blendTime}] -\r\n   * Default amount of time to use when manipulating animation blendWeights.\r\n   * @param {Function=} options.easingFn - Default easing function to use when\r\n   * manipulating animation blendWeights.\r\n   * @param {Object} [options.visemeMap=DefaultVisemeMap] - Object containing key/value pairs of\r\n   * Polly viseme names mapped to objects containing the name of the corresponding\r\n   * animation blendWeight and any other animation options to use such as viseme\r\n   * specific blend times and easing functions.\r\n   */\r\n  registerVisemeLayer(\r\n    layerName,\r\n    {\r\n      animation = 'visemes',\r\n      decayRate = {amount: 0.5, seconds: 0.5},\r\n      blendTime = LipsyncFeature.DEFAULT_LAYER_OPTIONS.blendTime,\r\n      easingFn,\r\n      visemeMap = DefaultVisemeMap,\r\n    } = {}\r\n  ) {\r\n    // Register the layer and animation\r\n    this.registerLayer(layerName, {\r\n      decayRate,\r\n      blendTime,\r\n      easingFn,\r\n      animations: {[animation]: {visemeMap}},\r\n    });\r\n    this._visemeLayers[layerName] = animation;\r\n\r\n    // Validate the viseme animation\r\n    this._registerVisemeAnimation(layerName, animation);\r\n  }\r\n\r\n  /**\r\n   * Start keeping track of an animation layer that contains a looping animation\r\n   * to be played during speech.\r\n   *\r\n   * @param {string} layerName - Name of the layer to keep track of.\r\n   * @param {Object=} options - Options for the layer.\r\n   * @param {string} [options.animation='stand_talk'] - Name of the animation on the\r\n   * layer that will be played during speech.\r\n   * @param {number} [options.blendTime=[LipsyncFeature.DEFAULT_LAYER_OPTIONS.blendTime]{@link LipsyncFeature#DEFAULT_LAYER_OPTIONS#blendTime}] -\r\n   * Default amount of time to use when manipulating the layer's weights.\r\n   * @param {Function=} options.easingFn - Default easing function to use when\r\n   * manipulating the layer's weights.\r\n   */\r\n  registerTalkingLayer(\r\n    layerName,\r\n    {\r\n      animation = 'stand_talk',\r\n      blendTime = LipsyncFeature.DEFAULT_LAYER_OPTIONS.blendTime,\r\n      easingFn,\r\n    } = {}\r\n  ) {\r\n    // Register the layer and animation\r\n    this.registerLayer(layerName, {\r\n      blendTime,\r\n      easingFn,\r\n      animations: {[animation]: {}},\r\n    });\r\n    this._talkingLayers[layerName] = animation;\r\n  }\r\n\r\n  /**\r\n   * Adds a namespace to the host with the name of the feature to contain properties\r\n   * and methods from the feature that users of the host need access to.\r\n   *\r\n   * @see LipsyncFeature\r\n   */\r\n  installApi() {\r\n    /**\r\n     * @inner\r\n     * @namespace LipsyncFeature\r\n     */\r\n    const api = super.installApi();\r\n\r\n    /**\r\n     * @memberof LipsyncFeature\r\n     * @name registerLayer\r\n     * @instance\r\n     * @method\r\n     * @see ManagedAnimationLayerInterface#registerLayer\r\n     */\r\n\r\n    /**\r\n     * @memberof LipsyncFeature\r\n     * @name registerAnimation\r\n     * @instance\r\n     * @method\r\n     * @see ManagedAnimationLayerInterface#registerAnimation\r\n     */\r\n\r\n    /**\r\n     * @memberof LipsyncFeature\r\n     * @name setLayerWeights\r\n     * @instance\r\n     * @method\r\n     * @see ManagedAnimationLayerInterface#setLayerWeights\r\n     */\r\n\r\n    /**\r\n     * @memberof LipsyncFeature\r\n     * @name enable\r\n     * @instance\r\n     * @method\r\n     * @see ManagedAnimationLayerInterface#enable\r\n     */\r\n\r\n    /**\r\n     * @memberof LipsyncFeature\r\n     * @name disable\r\n     * @instance\r\n     * @method\r\n     * @see ManagedAnimationLayerInterface#disable\r\n     */\r\n\r\n    Object.assign(api, {\r\n      /**\r\n       * @memberof LipsyncFeature\r\n       * @instance\r\n       * @method\r\n       * @see core/LipsyncFeature#registerVisemeLayer\r\n       */\r\n      registerVisemeLayer: this.registerVisemeLayer.bind(this),\r\n      /**\r\n       * @memberof LipsyncFeature\r\n       * @instance\r\n       * @method\r\n       * @see core/LipsyncFeature#registerTalkingLayer\r\n       */\r\n      registerTalkingLayer: this.registerTalkingLayer.bind(this),\r\n    });\r\n\r\n    /**\r\n     * @memberof LipsyncFeature\r\n     * @instance\r\n     * @name visemeLeadTime\r\n     * @see core/LipsyncFeature#visemeLeadTime\r\n     */\r\n    Object.defineProperty(api, 'visemeLeadTime', {\r\n      get: () => this.visemeLeadTime,\r\n      set: seconds => {\r\n        this.visemeLeadTime = seconds;\r\n      },\r\n    });\r\n\r\n    return api;\r\n  }\r\n}\r\n\r\nexport default LipsyncFeature;\r\nexport {DefaultVisemeMap};\r\n","/* eslint-disable no-unused-vars */\r\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n// SPDX-License-Identifier: MIT-0\r\n\r\n/* eslint-disable max-classes-per-file */\r\n/* eslint-disable no-empty */\r\nimport TextToSpeechFeatureDependentInterface from 'core/awspack/TextToSpeechFeatureDependentInterface';\r\n\r\n/**\r\n * Class factory interface for that registers callback method when a ssml speechmark event is emitted.\r\n *\r\n * @interface\r\n * @extends TextToSpeechFeatureDependentInterface\r\n */\r\nclass SSMLSpeechmarkInterface extends TextToSpeechFeatureDependentInterface {\r\n  /**\r\n   * When ssml events are caught, this will try to parse the speech mark value and execute any function which meets criteria defined in the value.\r\n   * Speech mark value will be treated as stringified json format containing required feature name, function name and argument array to pass in.\r\n   * Example speech mark value might look like: '{\"feature\":\"GestureFeature\", \"method\":\"switchToGesture\", \"args\":[\"genricA\", 0.5]}'\r\n   *\r\n   * @private\r\n   *\r\n   * @param {Object} event - Event data passed from the speech.\r\n   * @param {Object} event.mark - Speechmark object.\r\n   */\r\n  _onSsml({mark}) {}\r\n\r\n  /**\r\n   * Creates a class that implements {@link SSMLSpeechmarkInterface}\r\n   * and extends a specified base class.\r\n   *\r\n   * @param {Class} BaseClass - The class to extend.\r\n   *\r\n   * @return {Class} A class that extends `BaseClass` and implements {@link SSMLSpeechmarkInterface}.\r\n   */\r\n  static Mixin(BaseClass) {\r\n    const ParentClass = TextToSpeechFeatureDependentInterface.Mixin(BaseClass);\r\n    const SSMLSpeechMarkMixin = class extends ParentClass {\r\n      _onSsml({mark}) {\r\n        try {\r\n          const {feature, method, args} = JSON.parse(mark.value);\r\n          if (this.constructor.name === feature) {\r\n            const callback = this[method];\r\n            if (callback && typeof callback === 'function') {\r\n              callback.apply(this, args)\r\n            } else {\r\n              console.warn(`Function ${method} does not exist within feature ${feature}`)\r\n            }\r\n          }\r\n        } catch(e) {}\r\n      }\r\n    };\r\n\r\n    return SSMLSpeechMarkMixin;\r\n  }\r\n}\r\n\r\nexport default SSMLSpeechmarkInterface;\r\n","// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n// SPDX-License-Identifier: MIT-0\r\nimport ManagedAnimationLayerInterface from './animpack/ManagedAnimationLayerInterface';\r\nimport SSMLSpeechmarkInterface from './awspack/SSMLSpeechmarkInterface';\r\nimport AbstractHostFeature from './AbstractHostFeature';\r\nimport Deferred from './Deferred';\r\nimport Utils from './Utils';\r\n\r\nconst DefaultGestureWords = {\r\n  big: [\r\n    'add',\r\n    'above',\r\n    'authority',\r\n    'big',\r\n    'cover',\r\n    'full',\r\n    'fly',\r\n    'grow',\r\n    'growth',\r\n    'high',\r\n    'huge',\r\n    'increase',\r\n    'major',\r\n    'majority',\r\n    'large',\r\n    'leader',\r\n    'lot',\r\n    'raise',\r\n    'rise',\r\n    'tall',\r\n  ],\r\n  heart: [\r\n    'accept',\r\n    'admit',\r\n    'believe',\r\n    'care',\r\n    'feeling',\r\n    'feel',\r\n    'friend',\r\n    'grateful',\r\n    'happy',\r\n    'heart',\r\n    'human',\r\n    'pain',\r\n    'save',\r\n    'safe',\r\n    'kind',\r\n    'love',\r\n  ],\r\n  in: [\r\n    'include',\r\n    'including',\r\n    'inside',\r\n    'into',\r\n    'now',\r\n    'near',\r\n    'nearest',\r\n    'closest',\r\n    'therein',\r\n    'within',\r\n  ],\r\n  many: [\r\n    'all',\r\n    'always',\r\n    'any',\r\n    'anyone',\r\n    'among',\r\n    'area',\r\n    'around',\r\n    'beautiful',\r\n    'entire',\r\n    'environment',\r\n    'environments',\r\n    'environmental',\r\n    'everybody',\r\n    'everyone',\r\n    'everything',\r\n    'audience',\r\n    'total',\r\n    'group',\r\n    'groups',\r\n    'million',\r\n    'millions',\r\n    'others',\r\n    'billion',\r\n    'billions',\r\n    'hundred',\r\n    'hundreds',\r\n    'many',\r\n    'thousand',\r\n    'thousands',\r\n    'world',\r\n    'worlds',\r\n    'outside',\r\n    'reveal',\r\n  ],\r\n  movement: [\r\n    'away',\r\n    'across',\r\n    'ahead',\r\n    'along',\r\n    'far',\r\n    'fast',\r\n    'follow',\r\n    'go',\r\n    'leave',\r\n    'move',\r\n    'movement',\r\n    'through',\r\n    'throughout',\r\n    'toward',\r\n    'travel',\r\n    'turned',\r\n    'passed',\r\n  ],\r\n  one: [\r\n    'single',\r\n    'one',\r\n    'once',\r\n    'first',\r\n    'firstly',\r\n    'only',\r\n    'solo',\r\n    'warned',\r\n    'truly',\r\n    'up',\r\n    'alone',\r\n  ],\r\n  aggressive: [\r\n    'power',\r\n    'powers',\r\n    'powerful',\r\n    'assert',\r\n    'assertive',\r\n    'strong',\r\n    'stronger',\r\n    'strongest',\r\n    'strength',\r\n    'flex',\r\n    'dang',\r\n    'damn',\r\n    'damnit',\r\n    'darn',\r\n    'shucks',\r\n    'doh',\r\n    'drat',\r\n    'angry',\r\n    'angrier',\r\n    'angriest',\r\n    'aggressive',\r\n    'annoyed',\r\n    'annoying',\r\n    'attack',\r\n    'attacking',\r\n    'offense',\r\n    'offensive',\r\n    'battle',\r\n  ],\r\n  you: ['you', 'yall', \"y'all\", 'your', 'yours', 'thou', 'thy'],\r\n  defense: [\r\n    'defense',\r\n    'fear',\r\n    'repulsed',\r\n    'scared',\r\n    'scary',\r\n    'scarier',\r\n    'scariest',\r\n    'fearful',\r\n    'afraid',\r\n    'cower',\r\n    'cowers',\r\n    'cowering',\r\n    'hideous',\r\n    'doomed',\r\n    'terrified',\r\n    'terrify',\r\n    'terrifying',\r\n    'terrifies',\r\n    'spooky',\r\n    'spookier',\r\n    'spookiest',\r\n  ],\r\n  wave: [\r\n    'hello',\r\n    'hi',\r\n    'hiya',\r\n    'howdy',\r\n    'welcome',\r\n    'aloha',\r\n    'heya',\r\n    'hey',\r\n    'bye',\r\n    'goodbye',\r\n    'hola',\r\n    'adios',\r\n    'chao',\r\n  ],\r\n  self: ['my', 'I', 'myself', 'self', \"I've\", 'Ive', 'me', 'mine', 'own'],\r\n};\r\n\r\n/**\r\n * Gesture allows you to play animations on demand on one or more layers from script\r\n * or ssml. If gesture is played that is a QueueState, the queue will automatically\r\n * be progressed after a given hold time if a looping queued state is reached. Gesture\r\n * layers can optionally be automatically disabled when no gesture animation is\r\n * in progress.\r\n *\r\n * @extends AbstractHostFeature\r\n * @implements SSMLSpeechmarkInterface\r\n * @implements ManagedAnimationLayerInterface\r\n */\r\nclass GestureFeature extends AbstractHostFeature.mix(\r\n  SSMLSpeechmarkInterface.Mixin,\r\n  ManagedAnimationLayerInterface.Mixin\r\n) {\r\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {core/HostObject} host - Host object that owns the feature.\r\n   * @param {Object=} options - Optional options for the feature.\r\n   * @param {number} [options.holdTime = 3] - Amount of time in seconds that must\r\n   * elapse before advancing a gesture that's a {@link QueueState} when the current\r\n   * state in the queue is set to loop infinitely.\r\n   * @param {number} [options.minimumInterval = 0.25] - The minimum amount of time\r\n   * in seconds that must elapse before another gesture can be played.\r\n   * @param  {Object} layers - An object that maps layer names to layer options.\r\n   * These are the layers that will be registered as tracked gesture layers. See\r\n   * {@link ManagedAnimationLayerInterface#registerLayer} for more information\r\n   * on expected format for each layer options object.\r\n   */\r\n  constructor(host, {holdTime = 3, minimumInterval = 1, layers = {}} = {}) {\r\n    super(host);\r\n\r\n    this.holdTime = holdTime;\r\n    this.minimumInterval = minimumInterval;\r\n\r\n    // Register the gesture layers\r\n    Object.entries(layers).forEach(([name, options = {}]) => {\r\n      this.registerLayer(name, options);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Return a valid hold time value. If hold time isn't defined for the animation,\r\n   * try to use the hold time for the layer. If that's not defined, fall back to\r\n   * the hold time for the feature.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {Object} layer - Managed layer options object.\r\n   * @param {Object} animation - Managed animation options object.\r\n   *\r\n   * @returns {number}\r\n   */\r\n  _getHoldTime(layer, animation) {\r\n    const layerHoldTime =\r\n      layer.holdTime !== undefined ? layer.holdTime : this.holdTime;\r\n\r\n    return animation.holdTime !== undefined\r\n      ? animation.holdTime\r\n      : layerHoldTime;\r\n  }\r\n\r\n  /**\r\n   * Return a valid minimum interval value. If minimum interval isn't defined for\r\n   * the animation, try to use the minimum interval for the layer. If that's not\r\n   * defined, fall back to the minimum interval for the feature.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {Object} layer - Managed layer options object.\r\n   * @param {Object} animation - Managed animation options object.\r\n   *\r\n   * @returns {number}\r\n   */\r\n  _getMinimumInterval(layer, animation) {\r\n    const layerMinimumInterval =\r\n      layer.minimumInterval !== undefined\r\n        ? layer.minimumInterval\r\n        : this.minimumInterval;\r\n\r\n    return animation.minimumInterval !== undefined\r\n      ? animation.minimumInterval\r\n      : layerMinimumInterval;\r\n  }\r\n\r\n  /**\r\n   * Callback for {@link core/AnimationFeature#playNextAnimation} event. If the\r\n   * event is emitted for a managed animation and the new queued state cannot\r\n   * advance on its own, start a new timer promise that will advance the queue\r\n   * once it resolves.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {Object} options - Options object passed from playNextAnimation event.\r\n   * @param {string} layerName - Name of the layer that owns the queue state.\r\n   * @param {string} animationName - Name of the queue state animation.\r\n   * @param {boolean} canAdvance - Whether or not the current state in the queue\r\n   * can advance on its own.\r\n   * @param {boolean} isQueueEnd - Whether the current state in the queue is the last\r\n   * state in the queue.\r\n   */\r\n  _onNext({layerName, animationName, canAdvance, isQueueEnd}) {\r\n    // Exit if this isn't a managed layer\r\n    const layer = this._managedLayers[layerName];\r\n    if (layer === undefined) {\r\n      return;\r\n    }\r\n\r\n    // Exit if it isn't a managed animation\r\n    const animation = layer.animations[animationName];\r\n    if (animation === undefined) {\r\n      return;\r\n    }\r\n\r\n    // Start a new timer for looping states that aren't the end of the queue\r\n    if (!canAdvance && !isQueueEnd && layer.currentGesture === animationName) {\r\n      const holdTime = this._getHoldTime(layer, animation);\r\n      layer.holdTimer.cancel();\r\n\r\n      // Skip to the next animation right away if hold time is zero\r\n      if (holdTime <= 0) {\r\n        this._host.AnimationFeature.playNextAnimation(layerName, animationName);\r\n      }\r\n\r\n      // Wait for the given hold time before progressing\r\n      else {\r\n        layer.holdTimer = Utils.wait(holdTime, {\r\n          onFinish: () => {\r\n            // Advance the queue to the next state\r\n            if (layer.currentGesture === animationName) {\r\n              this._host.AnimationFeature.playNextAnimation(\r\n                layerName,\r\n                animationName\r\n              );\r\n            }\r\n          },\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Callback for {@link core/AnimationFeature#stopAnimation} event. If the\r\n   * event is emitted for a managed animation cancel the layer's stored timers.\r\n   * If the layer is set to auto-disable set its weight to 0.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {Object} options - Options object passed from playNextAnimation event.\r\n   * @param {string} layerName - Name of the layer that owns the stopped animation.\r\n   * @param {string} animationName - Name of the animation that was stopped.\r\n   */\r\n  _onStop({layerName, animationName}) {\r\n    // Make sure the layer is managed\r\n    const layer = this._managedLayers[layerName];\r\n    if (layer === undefined) {\r\n      return;\r\n    }\r\n\r\n    // Make sure the animation is managed\r\n    const animation = layer.animations[animationName];\r\n    if (animation !== undefined && animationName === layer.currentGesture) {\r\n      layer.currentGesture = null;\r\n      layer.playTimer = null;\r\n      layer.holdTimer.cancel();\r\n\r\n      // Turn off layer weight\r\n      if (layer.autoDisable) {\r\n        this.setLayerWeights(name => name === layerName, 0);\r\n      }\r\n    }\r\n  }\r\n\r\n  _onAnimationAdded({layerName, animationName}) {\r\n    const layer = this._managedLayers[layerName];\r\n\r\n    if (layer !== undefined) {\r\n      const animation = layer.animations[animationName];\r\n\r\n      // Register the animation as active if it is unmanaged\r\n      if (animation === undefined) {\r\n        this.registerAnimation(layerName, animationName);\r\n      }\r\n      // Mark the animation as active if it is managed\r\n      else {\r\n        animation.isActive = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  registerLayer(name, options = {}) {\r\n    super.registerLayer(name, {\r\n      ...options,\r\n      holdTimer: Deferred.resolve(),\r\n      playTimer: null,\r\n      currentGesture: null,\r\n    });\r\n\r\n    if (this._managedLayers[name].isActive) {\r\n      this._host.AnimationFeature.getAnimations(name).forEach(anim => {\r\n        // Automatically register all animations on the layer\r\n        if (this._managedLayers[name].animations[anim] === undefined) {\r\n          this.registerAnimation(\r\n            name,\r\n            anim,\r\n            this._managedLayers[name].animations[anim]\r\n          );\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  registerAnimation(layerName, animationName, options = {}) {\r\n    // Try to fall back to a default word array\r\n    if (!(options.words instanceof Array) && !(options.words instanceof Set)) {\r\n      options.words = DefaultGestureWords[animationName] || [];\r\n    }\r\n\r\n    super.registerAnimation(layerName, animationName, options);\r\n  }\r\n\r\n  /**\r\n   * Create an object that maps ssml mark syntax required to play each gesture to\r\n   * the words array associated with each gesture. Words arrays are defined at when\r\n   * the gesture animation is registered. Gestures without associated words will\r\n   * be excluded from the result. The resulting object can be used as an input\r\n   * for {@link TextToSpeechUtils.autoGenerateSSMLMarks} to update a speech string\r\n   * with the markup required to play gestures timed with their associated words.\r\n   *\r\n   * @returns {Object}\r\n   */\r\n  createGestureMap() {\r\n    const gestureMap = {};\r\n\r\n    Object.entries(this._managedLayers).forEach(([layerName, {animations}]) => {\r\n      Object.entries(animations).forEach(\r\n        ([\r\n          animationName,\r\n          {holdTime, minimumInterval, words, transitionTime},\r\n        ]) => {\r\n          // Only store gestures that have any associated words\r\n          if (words.length) {\r\n            const options = {\r\n              ...(holdTime && { holdTime }),\r\n              ...(minimumInterval && { minimumInterval }),\r\n              ...(transitionTime && { transitionTime }),\r\n            };\r\n            const key = {\r\n              feature: this.constructor.name,\r\n              method: 'playGesture',\r\n              args: [layerName, animationName, options],\r\n            };\r\n\r\n            gestureMap[JSON.stringify(key)] = words;\r\n          }\r\n        }\r\n      );\r\n    });\r\n\r\n    return gestureMap;\r\n  }\r\n\r\n  /**\r\n   * Create an array that contains ssml mark syntax required to play each gesture\r\n   * that does not have any associated words. The resulting array can be used as\r\n   * an input for {@link TextToSpeechUtils.autoGenerateSSMLMarks} or\r\n   * {@link TextToSpeechUtils.addMarksToUnmarkedSentences} to update a speech\r\n   * string with the markup required to play random gestures at each unmarked\r\n   * sentence in the string.\r\n   *\r\n   * @param {Array.<string>=} layers - An array of names of managed layers to generate\r\n   * marks for. If undefined, use all managed layers.\r\n   *\r\n   * @returns {Array.<string>}\r\n   */\r\n  createGenericGestureArray(layers) {\r\n    const genericGestures = [];\r\n    layers = layers || Object.keys(this._managedLayers);\r\n\r\n    layers.forEach(layerName => {\r\n      const layer = this._managedLayers[layerName];\r\n\r\n      // Make sure the layer is managed\r\n      if (!layer) {\r\n        return;\r\n      }\r\n\r\n      Object.entries(layer.animations).forEach(\r\n        ([\r\n          animationName,\r\n          { holdTime, minimumInterval, words, transitionTime },\r\n        ]) => {\r\n          // Only store gestures that don't have any associated words\r\n          if (!words.length) {\r\n            const options = {\r\n              ...(holdTime && { holdTime }),\r\n              ...(minimumInterval && { minimumInterval }),\r\n              ...(transitionTime && { transitionTime }),\r\n            };\r\n            const key = JSON.stringify({\r\n              feature: this.constructor.name,\r\n              method: 'playGesture',\r\n              args: [layerName, animationName, options],\r\n            });\r\n\r\n            if (!genericGestures.includes(key)) {\r\n              genericGestures.push(key);\r\n            }\r\n          }\r\n        }\r\n      );\r\n    });\r\n\r\n    return genericGestures;\r\n  }\r\n\r\n  /**\r\n   * Play a managed gesture animation.\r\n   *\r\n   * @param {string} layerName - The name of the layer that contains the gesture\r\n   * animation.\r\n   * @param {string} animationName - The name of the gesture animation.\r\n   * @param {Object=} options - Optional gesture options.\r\n   * @param {number=} options.holdTime - This option only applies to {@link QueueState}\r\n   * gestures. When a QueueState gesture progresses to a looping state, this option\r\n   * defines how many seconds should elapse before moving the queue forward. If\r\n   * undefined, it will fall back first to the holdTime defined in the options when\r\n   * the gesture animation was registered and then to the holdTime defined on the\r\n   * feature.\r\n   * @param {number=} options.minimumInterval - The minimum amount of time that\r\n   * must have elapsed since the last time a gesture was played.\r\n   */\r\n  playGesture(\r\n    layerName,\r\n    animationName,\r\n    {holdTime, minimumInterval, transitionTime, force = false} = {}\r\n  ) {\r\n    // Make sure the animation is registered\r\n    if (\r\n      this._managedLayers[layerName] === undefined ||\r\n      this._managedLayers[layerName].animations[animationName] === undefined\r\n    ) {\r\n      this.registerAnimation(layerName, animationName, {\r\n        holdTime,\r\n        minimumInterval,\r\n        transitionTime,\r\n      });\r\n    }\r\n\r\n    const layer = this._managedLayers[layerName];\r\n    const animation = layer.animations[animationName];\r\n\r\n    // Make sure the animation is active\r\n    if (!animation.isActive) {\r\n      // Create warning message based on which object doesn't exist yet\r\n      const typeName = layer.isActive ? 'animation' : 'layer';\r\n      const message = `Skipping gesture ${animationName} on layer ${layerName} for host ${this._host.id}. No ${typeName} exists with this name yet.`;\r\n\r\n      console.warn(message);\r\n      return Deferred.cancel({reason: 'inactive', value: typeName});\r\n    }\r\n\r\n    // Check if the gesture is already playing\r\n    const {currentGesture} = layer;\r\n    if (currentGesture === animationName && !force) {\r\n      const message = `Skipping gesture ${animationName} on layer ${layerName} for host ${this._host.id}. The gesture is already playing. Use options.force to force the gesture replay, which may result in a hard transition.`;\r\n\r\n      console.warn(message);\r\n      return Deferred.cancel({reason: 'playing', value: animationName});\r\n    }\r\n\r\n    // Update animation options\r\n    if (holdTime !== undefined) {\r\n      animation.holdTime = holdTime;\r\n    }\r\n\r\n    if (minimumInterval !== undefined) {\r\n      animation.minimumInterval = minimumInterval;\r\n    } else {\r\n      minimumInterval = this._getMinimumInterval(layer, animation);\r\n    }\r\n\r\n    // Check the interval\r\n    if (!force && layer.playTimer !== null && layer.playTimer < minimumInterval) {\r\n      console.warn(\r\n        `Skipping gesture ${animationName} on layer ${layerName} for host ${this._host.id}. Minimum interval ${minimumInterval} has not been met.`\r\n      );\r\n      return Deferred.cancel({\r\n        reason: 'minimumInterval',\r\n        value: minimumInterval - layer.playTimer,\r\n      });\r\n    }\r\n\r\n    // Play the animation\r\n    layer.currentGesture = animationName;\r\n    layer.playTimer = 0;\r\n    layer.holdTimer.cancel();\r\n    if (layer.autoDisable) {\r\n      this.setLayerWeights(name => name === layerName, 1);\r\n    }\r\n\r\n    return this._host.AnimationFeature.playAnimation(\r\n      layerName,\r\n      animationName,\r\n      transitionTime\r\n    );\r\n  }\r\n\r\n  update(deltaTime) {\r\n    super.update(deltaTime);\r\n\r\n    // Increment the timers\r\n    Object.entries(this._managedLayers).forEach(([name, options]) => {\r\n      if (options.isActive && !this._host.AnimationFeature.getPaused(name)) {\r\n        options.holdTimer.execute(deltaTime);\r\n\r\n        if (options.playTimer !== null) {\r\n          options.playTimer += deltaTime / 1000;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  installApi() {\r\n    /**\r\n     * @inner\r\n     * @namespace GestureFeature\r\n     */\r\n    const api = super.installApi();\r\n\r\n    Object.assign(api, {\r\n      /**\r\n       * @memberof GestureFeature\r\n       * @instance\r\n       * @method\r\n       * @see GestureFeature#createGestureMap\r\n       */\r\n      createGestureMap: this.createGestureMap.bind(this),\r\n      /**\r\n       * @memberof GestureFeature\r\n       * @instance\r\n       * @method\r\n       * @see GestureFeature#createGenericGestureArray\r\n       */\r\n      createGenericGestureArray: this.createGenericGestureArray.bind(this),\r\n      /**\r\n       * @memberof GestureFeature\r\n       * @instance\r\n       * @method\r\n       * @see GestureFeature#playGesture\r\n       */\r\n      playGesture: this.playGesture.bind(this),\r\n    });\r\n  }\r\n}\r\n\r\nObject.defineProperties(GestureFeature, {\r\n  DEFAULT_LAYER_OPTIONS: {\r\n    value: {\r\n      ...GestureFeature.DEFAULT_LAYER_OPTIONS,\r\n      autoDisable: true,\r\n    },\r\n    writable: false,\r\n  },\r\n  EVENT_DEPENDENCIES: {\r\n    value: {\r\n      ...GestureFeature.EVENT_DEPENDENCIES,\r\n      AnimationFeature: {\r\n        ...GestureFeature.EVENT_DEPENDENCIES.AnimationFeature,\r\n        playNextAnimation: '_onNext',\r\n        stopAnimation: '_onStop',\r\n        interruptAnimation: '_onStop'\r\n      },\r\n    },\r\n  },\r\n});\r\n\r\nexport default GestureFeature;\r\nexport {DefaultGestureWords};\r\n","// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n// SPDX-License-Identifier: MIT-0\r\nimport Deferred from 'core/Deferred';\r\nimport Utils from 'core/Utils';\r\nimport MathUtils from 'core/MathUtils';\r\nimport {Linear} from './Easing';\r\n\r\n/**\r\n * A collection of useful animation functions.\r\n *\r\n * @hideconstructor\r\n */\r\nclass AnimationUtils {\r\n  static lerp(from, to, factor) {\r\n    console.warn(`AnimationUtils.lerp is being deprecated. Use MathUtils.lerp instead.`);\r\n\r\n    return MathUtils.lerp(from, to, factor);\r\n  }\r\n\r\n  /**\r\n   * Clamp a number between 2 values.\r\n   *\r\n   * @param {number} value - Value to clamp.\r\n   * @param {number} [min=0] - Minumum value.\r\n   * @param {number} [max=1] - Maximum value.\r\n   *\r\n   * @returns {number}\r\n   */\r\n  static clamp(value, min = 0, max = 1) {\r\n    console.warn(`AnimationUtils.clamp is being deprecated. Use MathUtils.clamp instead.`);\r\n\r\n    return MathUtils.clamp(value, min, max);\r\n  }\r\n\r\n  /**\r\n   * Return a deferred promise that can be used to update the value of a numeric\r\n   * property of this object over time. Pass delta time in milliseconds to the\r\n   * deferred promise's execute method in an update loop to animate the property\r\n   * towards the target value.\r\n   *\r\n   * @param {Object} propertyOwner - Object that contains the property to animation.\r\n   * @param {string} propertyName - Name of the property to animate.\r\n   * @param {number} targetValue - Target value to reach.\r\n   * @param {Object=} options - Optional options object\r\n   * @param {number} [options.seconds=0] - Number of seconds it will take to reach\r\n   * the target value.\r\n   * @param {Function} [options.easingFn=Linear.InOut] - Easing function to use for animation.\r\n   * @param {Function} [options.onFinish] - Callback to execute once the animation completes.\r\n   * The target value is passed as a parameter.\r\n   * @param {Function=} options.onProgress - Callback to execute each time the animation\r\n   * property is updated during the animation. The property's value at the time of\r\n   * the update is passed as a parameter.\r\n   * @param {Function=} options.onCancel - Callback to execute if the user cancels the\r\n   * animation before completion. The animation property's value at the time of\r\n   * cancel is passed as a parameter.\r\n   * @param {Function=} options.onError - Callback to execute if the animation stops\r\n   * because an error is encountered. The error message is passed as a parameter.\r\n   *\r\n   * @returns {Deferred} Resolves with the property's value once it reaches the\r\n   * target value.\r\n   */\r\n  static interpolateProperty(\r\n    propertyOwner,\r\n    propertyName,\r\n    targetValue,\r\n    {seconds = 0, easingFn, onFinish, onProgress, onCancel, onError} = {}\r\n  ) {\r\n    // Make sure property is an object\r\n    if (!(propertyOwner instanceof Object)) {\r\n      const e = new Error(\r\n        `Cannot interpolate property ${propertyName}. Property owner must be an object.`\r\n      );\r\n\r\n      if (typeof onError === 'function') {\r\n        onError(e);\r\n      }\r\n\r\n      return Deferred.reject(e);\r\n    }\r\n\r\n    // Make sure property is numeric\r\n    if (Number.isNaN(Number(propertyOwner[propertyName]))) {\r\n      const e = new Error(\r\n        `Cannot interpolate property ${propertyName}. Property must be numeric.`\r\n      );\r\n\r\n      if (typeof onError === 'function') {\r\n        onError(e);\r\n      }\r\n\r\n      return Deferred.reject(e);\r\n    }\r\n\r\n    // Make sure the target value is numeric\r\n    if (Number.isNaN(Number(targetValue))) {\r\n      const e = new Error(\r\n        `Cannot interpolate property ${propertyName} to value ${targetValue}. Target value must be numeric.`\r\n      );\r\n\r\n      if (typeof onError === 'function') {\r\n        onError(e);\r\n      }\r\n\r\n      return Deferred.reject(e);\r\n    }\r\n\r\n    // Resolve immediately if the target has already been reached\r\n    const startValue = propertyOwner[propertyName];\r\n\r\n    if (startValue === targetValue) {\r\n      if (typeof onFinish === 'function') {\r\n        onFinish(targetValue);\r\n      }\r\n\r\n      return Deferred.resolve(targetValue);\r\n    }\r\n\r\n    // Default to linear interpolation\r\n    if (typeof easingFn !== 'function') {\r\n      if (easingFn !== undefined) {\r\n        console.warn(\r\n          `Invalid property interpolation easingFn. Defaulting to linear interpolation.`\r\n        );\r\n      }\r\n\r\n      easingFn = Linear.InOut;\r\n    }\r\n\r\n    const interpolator = Utils.wait(seconds, {\r\n      onFinish: () => {\r\n        propertyOwner[propertyName] = targetValue;\r\n\r\n        if (typeof onFinish === 'function') {\r\n          onFinish(targetValue);\r\n        }\r\n      },\r\n      onCancel: () => {\r\n        if (typeof onCancel === 'function') {\r\n          onCancel(propertyOwner[propertyName]);\r\n        }\r\n      },\r\n      onProgress: progress => {\r\n        if (propertyOwner[propertyName] !== targetValue) {\r\n          // Calculate the lerp factor\r\n          const easeFactor = easingFn(progress);\r\n\r\n          if (typeof easeFactor !== 'number') {\r\n            const e = new Error(\r\n              `Invalid property interpolation easingFn. EasingFn must return a number.`\r\n            );\r\n            interpolator.reject(e);\r\n            return;\r\n          }\r\n\r\n          // Update the value\r\n          propertyOwner[propertyName] = MathUtils.lerp(\r\n            startValue,\r\n            targetValue,\r\n            easeFactor\r\n          );\r\n        }\r\n\r\n        // Signal progress\r\n        if (typeof onProgress === 'function') {\r\n          onProgress(propertyOwner[propertyName]);\r\n        }\r\n\r\n        // Signal completion once time is up\r\n        if (progress === 1) {\r\n          propertyOwner[propertyName] = targetValue;\r\n          interpolator.resolve(targetValue);\r\n        }\r\n      },\r\n      onError,\r\n    });\r\n\r\n    return interpolator;\r\n  }\r\n}\r\n\r\nexport default AnimationUtils;\r\n","// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n// SPDX-License-Identifier: MIT-0\r\nimport Deferred from 'core/Deferred';\r\nimport MathUtils from 'core/MathUtils';\r\nimport AnimationUtils from '../AnimationUtils';\r\n\r\n/**\r\n * Base class for a state in our animation system.\r\n *\r\n * @abstract\r\n */\r\nclass AbstractState {\r\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {Object=} options - Options for the animation state.\r\n   * @param {string=} options.name - Name for the animation state. Names must be\r\n   * unique for the container the state is applied to and should be validated at\r\n   * the container level. If no name is given it will default to the constructor\r\n   * name.\r\n   * @param {weight} [options.weight=0] - The 0-1 amount of influence the state will have.\r\n   */\r\n  constructor(options = {}) {\r\n    this.name =\r\n      options.name !== undefined ? options.name : this.constructor.name;\r\n    this._weight =\r\n      options.weight !== undefined\r\n        ? MathUtils.clamp(options.weight, 0, 1)\r\n        : 0;\r\n    this._internalWeight = this._weight;\r\n    this._paused = false;\r\n\r\n    this._promises = {\r\n      finish: Deferred.resolve(),\r\n      weight: Deferred.resolve(),\r\n      play: Deferred.resolve(),\r\n    };\r\n\r\n    this._playCallbacks = {\r\n      onFinish: undefined,\r\n      onError: undefined,\r\n      onCancel: undefined,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Gets whether or not the state is currently paused.\r\n   *\r\n   * @type {number}\r\n   */\r\n  get paused() {\r\n    return this._paused;\r\n  }\r\n\r\n  /**\r\n   * Gets and sets the user defined weight.\r\n   *\r\n   * @type {number}\r\n   */\r\n  get weight() {\r\n    return this._weight;\r\n  }\r\n\r\n  set weight(weight) {\r\n    this._weight = MathUtils.clamp(weight, 0, 1);\r\n  }\r\n\r\n  /**\r\n   * Gets whether or not the weight is currently being animated.\r\n   *\r\n   * @readonly\r\n   * @type {boolean}\r\n   */\r\n  get weightPending() {\r\n    return this._promises.weight && this._promises.weight.pending;\r\n  }\r\n\r\n  /**\r\n   * Updates the user defined weight over time.\r\n   *\r\n   * @param {number} weight - The target weight value.\r\n   * @param {number} [seconds=0] - The amount of time it will take to reach the\r\n   * target weight.\r\n   * @param {Function=} easingFn - The easing function to use for interpolation.\r\n   *\r\n   * @returns {Deferred}\r\n   */\r\n  setWeight(weight, seconds = 0, easingFn) {\r\n    this._promises.weight.cancel();\r\n    weight = MathUtils.clamp(weight);\r\n\r\n    this._promises.weight = AnimationUtils.interpolateProperty(\r\n      this,\r\n      'weight',\r\n      weight,\r\n      {seconds, easingFn}\r\n    );\r\n\r\n    return this._promises.weight;\r\n  }\r\n\r\n  /**\r\n   * Gets the internal weight.\r\n   *\r\n   * @readonly\r\n   * @type {number}\r\n   */\r\n  get internalWeight() {\r\n    return this._internalWeight;\r\n  }\r\n\r\n  /**\r\n   * Multiplies the user weight by a factor to determine the internal weight.\r\n   *\r\n   * @param {number} factor - 0-1 multiplier to apply to the user weight.\r\n   */\r\n  updateInternalWeight(factor) {\r\n    this._internalWeight = this._weight * factor;\r\n  }\r\n\r\n  /**\r\n   * Update any values that need to be evaluated every frame.\r\n   *\r\n   * @param {number} deltaTime - Time in milliseconds since the last update.\r\n   */\r\n  update(deltaTime) {\r\n    if (!this._paused) {\r\n      Object.values(this._promises).forEach(promise => {\r\n        promise.execute(deltaTime);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start playback of the state from the beginning.\r\n   *\r\n   * @param {Function=} onFinish - Function to execute when the state finishes.\r\n   * @param {Function=} onError - Function to execute if the state encounters\r\n   * an error during playback.\r\n   * @param {Function=} onCancel - Function to execute if playback is canceled.\r\n   *\r\n   * @returns {Deferred}\r\n   */\r\n  play(onFinish, onError, onCancel) {\r\n    this._paused = false;\r\n    this._playCallbacks.onFinish = onFinish;\r\n    this._playCallbacks.onError = onError;\r\n    this._playCallbacks.onCancel = onCancel;\r\n\r\n    this._promises.play = new Deferred(undefined, onFinish, onError, onCancel);\r\n    this._promises.finish = Deferred.all([\r\n      this._promises.play,\r\n      this._promises.weight,\r\n    ]);\r\n\r\n    return this._promises.finish;\r\n  }\r\n\r\n  /**\r\n   * Pause playback of the state. This prevents pending promises from being executed.\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n  pause() {\r\n    this._paused = true;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Resume playback of the state.\r\n   *\r\n   * @param {Function=} onFinish - Function to execute when the state finishes.\r\n   * @param {Function=} onError - Function to execute if the state encounters\r\n   * an error during playback.\r\n   * @param {Function=} onCancel - Function to execute if playback is canceled.\r\n   *\r\n   * @returns {Deferred}\r\n   */\r\n  resume(onFinish, onError, onCancel) {\r\n    this._paused = false;\r\n\r\n    if (!this._promises.play.pending) {\r\n      this._playCallbacks.onFinish = onFinish || this._playCallbacks.onFinish;\r\n      this._playCallbacks.onError = onError || this._playCallbacks.onError;\r\n      this._playCallbacks.onCancel = onCancel || this._playCallbacks.onCancel;\r\n\r\n      this._promises.play = new Deferred(\r\n        undefined,\r\n        this._playCallbacks.onFinish,\r\n        this._playCallbacks.onError,\r\n        this._playCallbacks.onCancel\r\n      );\r\n      this._promises.finish = Deferred.all([\r\n        this._promises.play,\r\n        this._promises.weight,\r\n      ]);\r\n    }\r\n\r\n    return this._promises.finish;\r\n  }\r\n\r\n  /**\r\n   * Cancel playback of the state and cancel any pending promises.\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n  cancel() {\r\n    this._paused = true;\r\n\r\n    Object.values(this._promises).forEach(promise => {\r\n      promise.cancel();\r\n    });\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Stop playback of the state and resolve any pending promises.\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n  stop() {\r\n    this._paused = true;\r\n\r\n    Object.values(this._promises).forEach(promise => {\r\n      promise.resolve();\r\n    });\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Cancel any pending promises and remove reference to them.\r\n   */\r\n  discard() {\r\n    this.cancel();\r\n\r\n    delete this._promises;\r\n  }\r\n\r\n  /**\r\n   * Force the internal weight to 0. Should be called before switching or transitioning\r\n   * to a new state.\r\n   */\r\n  deactivate() {\r\n    this.updateInternalWeight(0);\r\n  }\r\n}\r\n\r\nexport default AbstractState;\r\n","// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n// SPDX-License-Identifier: MIT-0\r\nimport Deferred from 'core/Deferred';\r\nimport AbstractState from './AbstractState';\r\n\r\n/**\r\n * Class for smooth transitioning between states on an animation layer.\r\n *\r\n * @extends AbstractState\r\n */\r\nclass TransitionState extends AbstractState {\r\n  constructor(options = {}) {\r\n    super(options);\r\n\r\n    this._to = null;\r\n    this._from = [];\r\n    this._weightPromise = Deferred.resolve();\r\n  }\r\n\r\n  get internalWeight() {\r\n    // Find the combined weight of all sub-states\r\n    let totalWeight = 0;\r\n\r\n    if (this._to) {\r\n      totalWeight += this._to.weight;\r\n    }\r\n\r\n    this._from.forEach(state => {\r\n      totalWeight += state.weight;\r\n    });\r\n\r\n    return totalWeight * this._internalWeight;\r\n  }\r\n\r\n  updateInternalWeight(factor) {\r\n    super.updateInternalWeight(factor);\r\n\r\n    this._from.forEach(state => {\r\n      state.updateInternalWeight(this._internalWeight);\r\n    });\r\n\r\n    if (this._to) {\r\n      this._to.updateInternalWeight(this._internalWeight);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update sub-states the transition is controlling and start new weight\r\n   * animations on each one. This should be called each time the current state of\r\n   * an animation layer gets updated to a new value and a transition time greater\r\n   * that zero is specified.\r\n   *\r\n   * @param {Array.<AbstractState>} [currentStates=[]] - States whose weight values\r\n   * will be animated to 0.\r\n   * @param {AbstractState=} targetState - State whose weight will be animated\r\n   * to 1.\r\n   * @param {number} transitionTime - Amount of time it will in seconds take for\r\n   * weight animations to complete.\r\n   * @param {Function=} easingFn - Easing function to use for weight animations.\r\n   * Default is Easing.Linear.InOut.\r\n   * @param {Function=} onComplete - Function to execute once all weight animations\r\n   * complete.\r\n   */\r\n  configure(\r\n    currentStates = [],\r\n    targetState,\r\n    transitionTime,\r\n    easingFn,\r\n    onComplete\r\n  ) {\r\n    // Deactivate any states that aren't in the new configuration\r\n    if (this._to === targetState || currentStates.includes(this._to)) {\r\n      this._to = null;\r\n    }\r\n    this._from = this._from.filter(\r\n      state => state !== targetState && !currentStates.includes(state)\r\n    );\r\n    this.deactivate();\r\n\r\n    this._from = currentStates;\r\n    this._to = targetState;\r\n    this.reset(transitionTime, easingFn, onComplete);\r\n  }\r\n\r\n  /**\r\n   * Start new weight animations state the transition controls. This should be called\r\n   * if an animation is played with a transition time greater than zero and a transtion\r\n   * to that animation was already in progress.\r\n   *\r\n   * @param {number} transitionTime - Amount of time it will in seconds take for\r\n   * weight animations to complete.\r\n   * @param {Function=} easingFn - Easing function to use for weight animations.\r\n   * Default is Easing.Linear.InOut.\r\n   * @param {Function=} onComplete - Function to execute once all weight animations\r\n   * complete.\r\n   */\r\n  reset(transitionTime, easingFn, onComplete) {\r\n    // Stop any pending promises\r\n    this._weightPromise.cancel();\r\n\r\n    // Start tweening weight to 0 for the current states\r\n    const weightPromises = this._from.map(state =>\r\n      state.setWeight(0, transitionTime, easingFn)\r\n    );\r\n\r\n    // Start tweening weight to 1 for the target state\r\n    if (this._to) {\r\n      weightPromises.push(this._to.setWeight(1, transitionTime, easingFn));\r\n      this.name = this._to.name;\r\n    } else {\r\n      this.name = null;\r\n    }\r\n\r\n    this._weightPromise = Deferred.all(weightPromises, () => {\r\n      this._from.forEach(state => {\r\n        state.cancel();\r\n        state.deactivate();\r\n      });\r\n      if (typeof onComplete === 'function') {\r\n        onComplete();\r\n      }\r\n    });\r\n  }\r\n\r\n  play(onFinish, onError, onCancel, onNext) {\r\n    this._paused = false;\r\n    this._playCallbacks.onFinish = onFinish;\r\n    this._playCallbacks.onError = onError;\r\n    this._playCallbacks.onCancel = onCancel;\r\n\r\n    const promises = [this._weightPromise];\r\n\r\n    this._from.forEach(state => {\r\n      state.resume();\r\n    });\r\n\r\n    if (this._to) {\r\n      this._promises.play = this._to.play(\r\n        undefined,\r\n        undefined,\r\n        undefined,\r\n        onNext\r\n      );\r\n      promises.push(this._promises.play);\r\n    }\r\n\r\n    this._promises.finish = Deferred.all(promises, onFinish, onError, onCancel);\r\n    return this._promises.finish;\r\n  }\r\n\r\n  pause() {\r\n    this._from.forEach(state => {\r\n      state.pause();\r\n    });\r\n\r\n    if (this._to) {\r\n      this._to.pause();\r\n    }\r\n\r\n    return super.pause();\r\n  }\r\n\r\n  resume(onFinish, onError, onCancel, onNext) {\r\n    this._paused = false;\r\n\r\n    if (!this._promises.play.pending) {\r\n      this._playCallbacks.onFinish = onFinish || this._playCallbacks.onFinish;\r\n      this._playCallbacks.onError = onError || this._playCallbacks.onError;\r\n      this._playCallbacks.onCancel = onCancel || this._playCallbacks.onCancel;\r\n    }\r\n\r\n    const promises = [this._weightPromise];\r\n\r\n    this._from.forEach(state => {\r\n      state.resume();\r\n    });\r\n\r\n    if (this._to) {\r\n      this._promises.play = this._to.resume(\r\n        undefined,\r\n        undefined,\r\n        undefined,\r\n        onNext\r\n      );\r\n      promises.push(this._promises.play);\r\n    }\r\n\r\n    this._promises.finish = Deferred.all(\r\n      promises,\r\n      this._playCallbacks.onFinish,\r\n      this._playCallbacks.onError,\r\n      this._playCallbacks.onCancel\r\n    );\r\n    return this._promises.finish;\r\n  }\r\n\r\n  cancel() {\r\n    this._from.forEach(state => {\r\n      state.pause();\r\n    });\r\n\r\n    if (this._to) {\r\n      this._to.cancel();\r\n    }\r\n\r\n    this._weightPromise.cancel();\r\n\r\n    return super.cancel();\r\n  }\r\n\r\n  stop() {\r\n    this._from.forEach(state => {\r\n      state.pause();\r\n    });\r\n\r\n    if (this._to) {\r\n      this._to.stop();\r\n    }\r\n\r\n    return super.stop();\r\n  }\r\n\r\n  update(deltaTime) {\r\n    super.update(deltaTime);\r\n\r\n    this._from.forEach(state => {\r\n      state.update(deltaTime);\r\n    });\r\n\r\n    if (this._to) {\r\n      this._to.update(deltaTime);\r\n    }\r\n  }\r\n\r\n  discard() {\r\n    super.discard();\r\n\r\n    this._weightPromise.cancel();\r\n    delete this._weightPromise;\r\n    this._to = null;\r\n    this._from.length = 0;\r\n  }\r\n\r\n  deactivate() {\r\n    if (this._to) {\r\n      this._to.deactivate();\r\n    }\r\n\r\n    this._from.forEach(state => {\r\n      state.deactivate();\r\n    });\r\n  }\r\n}\r\n\r\nexport default TransitionState;\r\n","// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n// SPDX-License-Identifier: MIT-0\r\n/* eslint-disable max-classes-per-file */\r\n/* eslint-disable no-unused-vars */\r\n/* eslint-disable no-empty-function */\r\n/* eslint-disable getter-return */\r\n/* eslint-disable no-useless-constructor */\r\nimport TransitionState from './state/TransitionState';\r\nimport Deferred from '../Deferred';\r\n\r\n/**\r\n * Class factory interface for controlling playback of a collection of animations.\r\n * One animation can be played at any given time, crossfading between animations\r\n * will result in playing a {@link TransitionState}.\r\n *\r\n * @interface\r\n */\r\nclass AnimationPlayerInterface {\r\n  /**\r\n   * Gets whether or not the player is updating states.\r\n   *\r\n   * @readonly\r\n   * @type {boolean}\r\n   */\r\n  get paused() {\r\n    return this._paused;\r\n  }\r\n\r\n  /**\r\n   * Gets and sets the default number of seconds it takes to transition to a new\r\n   * animation.\r\n   *\r\n   * @type {number}\r\n   */\r\n  get transitionTime() {}\r\n\r\n  set transitionTime(seconds) {}\r\n\r\n  /**\r\n   * Gets and sets the default easing function to use when transitioning and\r\n   * setting weights.\r\n   *\r\n   * @type {Function}\r\n   */\r\n  get easingFn() {}\r\n\r\n  set easingFn(fn) {}\r\n\r\n  /**\r\n   * Gets the state the layer is currently in control of.\r\n   *\r\n   * @readonly\r\n   * @type {AbstractState}\r\n   */\r\n  get currentState() {}\r\n\r\n  /**\r\n   * Gets the name of the state the layer is currently in control of.\r\n   *\r\n   * @readonly\r\n   * @type {string}\r\n   */\r\n  get currentAnimation() {}\r\n\r\n  /**\r\n   * Gets whether or not the layer is currently transitioning to a new animation.\r\n   *\r\n   * @readonly\r\n   * @type {boolean}\r\n   */\r\n  get isTransitioning() {}\r\n\r\n  /**\r\n   * Update the layer's current state to a new value. If transitionTime is defined\r\n   * and greater than zero, perform a smooth blend between any states that currently\r\n   * have non-zero weight values and the new state.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {(string|null)} name - Name of the state to transition to.\r\n   * @param {string} playMethod - Name of the operation being prepared for, to be\r\n   * used in error messaging.\r\n   * @param {number=} transitionTime - Amount of time in seconds it will take to\r\n   * switch to the new state.\r\n   * @param {Function=} easingFn - Easing function to use when transitioning to a\r\n   * new state over time.\r\n   * @param {Function=} onError - Function to execute if an error is encountered.\r\n   */\r\n  _prepareCurrentState(name, playMethod, transitionTime, easingFn, onError) {}\r\n\r\n  /**\r\n   * Start playback an animation from the beginning.\r\n   *\r\n   * @param {string} name - Name of the animation to play.\r\n   * @param {number=} transitionTime - Amount of time it will take before the\r\n   * new state has full influence for the layer.\r\n   * @param {Function=} easingFn - Easing function to use for blending if transitionTime\r\n   * is greater than zero.\r\n   * @param {Function=} onFinish - Function to execute when the animation finishes.\r\n   * @param {Function=} onError - Function to execute if the animation encounters\r\n   * an error during playback.\r\n   * @param {Function=} onCancel - Function to execute if playback is canceled.\r\n   * @param {Function=} onNext - Function to execute if an animation queue is\r\n   * played and it advances to the next animation.\r\n   *\r\n   * @returns {Deferred}\r\n   */\r\n  playAnimation(\r\n    name,\r\n    transitionTime,\r\n    easingFn,\r\n    onFinish,\r\n    onError,\r\n    onCancel,\r\n    onNext\r\n  ) {}\r\n\r\n  /**\r\n   * Cancel playback of the current animation.\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n  cancelAnimation() {}\r\n\r\n  /**\r\n   * Pause playback of the current animation.\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n  pauseAnimation() {}\r\n\r\n  /**\r\n   * Resume playback of an animation.\r\n   *\r\n   * @param {string=} name - Name of the animation to resume playback for. Default\r\n   * is the layer's current animation name.\r\n   * @param {number=} transitionTime - Amount of time it will take before the\r\n   * new state has full influence for the layer.\r\n   * @param {Function=} onFinish - Function to execute when the state finishes.\r\n   * @param {Function=} onError - Function to execute if the state encounters\r\n   * an error during playback.\r\n   * @param {Function=} onCancel - Function to execute if playback is canceled.\r\n   * @param {Function=} onNext - Function to execute if an animation queue is\r\n   * played and it advances to the next animation.\r\n   *\r\n   * @returns {Deferred}\r\n   */\r\n  resumeAnimation(\r\n    name,\r\n    transitionTime,\r\n    easingFn,\r\n    onFinish,\r\n    onError,\r\n    onCancel,\r\n    onNext\r\n  ) {}\r\n\r\n  /**\r\n   * Stop playback of the current animation.\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n  stopAnimation() {}\r\n\r\n  /**\r\n   * Update the current animation.\r\n   *\r\n   * @param {number} deltaTime - Time in milliseconds since the last update.\r\n   */\r\n  update(deltaTime) {}\r\n\r\n  /**\r\n   * Discard the transition state.\r\n   */\r\n  discard() {}\r\n\r\n  /**\r\n   * Creates a class that implements {@link AnimationPlayerInterface} and extends\r\n   * a specified base class.\r\n   *\r\n   * @param {Class} [BaseClass = class{}] - The class to extend.\r\n   *\r\n   * @return {Class} A class that extends `BaseClass` and implements {@link AnimationPlayerInterface}.\r\n   */\r\n  static Mixin(BaseClass = class {}) {\r\n    const AnimationPlayerMixin = class extends BaseClass {\r\n      constructor(options = {}, ...args) {\r\n        super(options, ...args);\r\n\r\n        this._transitionState = new TransitionState();\r\n        this._states = this._states !== undefined ? this._states : new Map();\r\n        this._currentState = null;\r\n        this._paused = false;\r\n\r\n        this._transitionTime =\r\n          Number(options.transitionTime) >= 0\r\n            ? Number(options.transitionTime)\r\n            : 0;\r\n\r\n        this._easingFn =\r\n          typeof options.easingFn === 'function' ? options.easingFn : undefined;\r\n      }\r\n\r\n      get paused() {\r\n        return this._paused;\r\n      }\r\n\r\n      get transitionTime() {\r\n        return this._transitionTime;\r\n      }\r\n\r\n      set transitionTime(seconds) {\r\n        seconds = Number(seconds);\r\n\r\n        if (!(seconds >= 0)) {\r\n          throw new Error(\r\n            `Cannot set transition time for ${this.constructor.name} to ${seconds}. Seconds must be a numeric value greather than or equal to zero.`\r\n          );\r\n        }\r\n\r\n        this._transitionTime = seconds;\r\n      }\r\n\r\n      get easingFn() {\r\n        return this._easingFn;\r\n      }\r\n\r\n      set easingFn(fn) {\r\n        this._easingFn = fn;\r\n      }\r\n\r\n      get currentState() {\r\n        return this._currentState;\r\n      }\r\n\r\n      get currentAnimation() {\r\n        if (this._currentState) {\r\n          return this._currentState.name;\r\n        }\r\n\r\n        return null;\r\n      }\r\n\r\n      get isTransitioning() {\r\n        return this._currentState === this._transitionState;\r\n      }\r\n\r\n      _prepareCurrentState(\r\n        name,\r\n        playMethod,\r\n        transitionTime,\r\n        easingFn,\r\n        onError\r\n      ) {\r\n        if (name !== null && !this._states.has(name)) {\r\n          const e = new Error(\r\n            `Cannot ${playMethod} animation ${name}. No animation exists with this name.`\r\n          );\r\n\r\n          if (typeof onError === 'function') {\r\n            onError(e);\r\n          }\r\n\r\n          throw e;\r\n        }\r\n\r\n        const targetState = name !== null ? this._states.get(name) : null;\r\n\r\n        // Make sure the new state isn't already playing\r\n        if (this.currentAnimation !== name) {\r\n          // Switch to the new state immediately\r\n          if (transitionTime <= 0) {\r\n            // Cancel the current state and set its weight to 0\r\n            if (this._currentState) {\r\n              this._currentState.cancel();\r\n              this._currentState.weight = 0;\r\n              this._currentState.deactivate();\r\n            }\r\n\r\n            this._currentState = targetState;\r\n          }\r\n          // Blend to the new state over time\r\n          else {\r\n            // Make sure to transition out of any states with non-zero weight\r\n            const currentStates = [...this._states.values()].filter(\r\n              s => s !== targetState && (s.weight || s.weightPending)\r\n            );\r\n\r\n            // Update the transition state with new inputs\r\n            this._transitionState.configure(\r\n              currentStates,\r\n              targetState,\r\n              transitionTime,\r\n              easingFn,\r\n              () => {\r\n                this._currentState = targetState;\r\n                this._transitionState.weight = 0;\r\n              }\r\n            );\r\n\r\n            this._currentState = this._transitionState;\r\n          }\r\n        } else if (playMethod === 'play') {\r\n          this._currentState.cancel();\r\n\r\n          if (this._currentState === this._transitionState) {\r\n            this._transitionState.reset(transitionTime, easingFn, () => {\r\n              this._currentState = targetState;\r\n              this._transitionState.weight = 0;\r\n            });\r\n          }\r\n        }\r\n\r\n        // Update weight for the new current state so it has full influence for the player\r\n        this._currentState.weight = 1;\r\n        this._currentState.updateInternalWeight(this._internalWeight);\r\n      }\r\n\r\n      playAnimation(\r\n        name,\r\n        transitionTime,\r\n        easingFn,\r\n        onFinish,\r\n        onError,\r\n        onCancel,\r\n        onNext\r\n      ) {\r\n        let error;\r\n        let reject = false;\r\n        try {\r\n          this._prepareCurrentState(\r\n            name,\r\n            'play',\r\n            transitionTime !== undefined\r\n              ? transitionTime\r\n              : this._transitionTime,\r\n            easingFn !== undefined ? easingFn : this._easingFn,\r\n            onError\r\n          );\r\n        } catch (e) {\r\n          error = e;\r\n          reject = true;\r\n        }\r\n\r\n        if (reject) {\r\n          return Deferred.reject(error);\r\n        }\r\n\r\n        return this._currentState.play(onFinish, onError, onCancel, onNext);\r\n      }\r\n\r\n      pauseAnimation() {\r\n        if (this._currentState) {\r\n          return this._currentState.pause();\r\n        } else {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      resumeAnimation(\r\n        name,\r\n        transitionTime,\r\n        easingFn,\r\n        onFinish,\r\n        onError,\r\n        onCancel,\r\n        onNext\r\n      ) {\r\n        if (name === undefined && this._currentState) {\r\n          name = this._currentState.name;\r\n        }\r\n\r\n        let error;\r\n        let reject = false;\r\n        try {\r\n          this._prepareCurrentState(\r\n            name,\r\n            'resume',\r\n            transitionTime !== undefined\r\n              ? transitionTime\r\n              : this._transitionTime,\r\n            easingFn !== undefined ? easingFn : this._easingFn,\r\n            onError\r\n          );\r\n        } catch (e) {\r\n          error = e;\r\n          reject = true;\r\n        }\r\n\r\n        if (reject) {\r\n          return Deferred.reject(error);\r\n        }\r\n\r\n        return this._currentState.resume(onFinish, onError, onCancel, onNext);\r\n      }\r\n\r\n      cancelAnimation() {\r\n        if (this._currentState) {\r\n          return this._currentState.cancel();\r\n        } else {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      stopAnimation() {\r\n        if (this._currentState) {\r\n          return this._currentState.stop();\r\n        } else {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      update(deltaTime) {\r\n        if (super.update) {\r\n          super.update(deltaTime);\r\n        }\r\n\r\n        if (this._currentState) {\r\n          this._currentState.update(deltaTime);\r\n        }\r\n      }\r\n\r\n      discard() {\r\n        if (super.discard) {\r\n          super.discard();\r\n        }\r\n\r\n        this._transitionState.discard();\r\n        delete this._transitionState;\r\n      }\r\n    };\r\n\r\n    return AnimationPlayerMixin;\r\n  }\r\n}\r\n\r\nexport default AnimationPlayerInterface;\r\n","// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n// SPDX-License-Identifier: MIT-0\r\n/* eslint-disable max-classes-per-file */\r\n/* eslint-disable no-unused-vars */\r\n/* eslint-disable no-empty-function */\r\n/* eslint-disable getter-return */\r\n\r\nimport Utils from '../../Utils';\r\n\r\n/**\r\n * Class factory interface for manipulating a collection of {@link AbstractState}.\r\n *\r\n * @interface\r\n */\r\nclass StateContainerInterface {\r\n  /**\r\n   * Return the state with the given name.\r\n   *\r\n   * @param {string} name - Name of the state.\r\n   *\r\n   * @returns {AbstractState}\r\n   */\r\n  getState(name) {}\r\n\r\n  /**\r\n   * Gets an array of the names of all states in the container.\r\n   *\r\n   * @type {Array.<string>}\r\n   */\r\n  getStateNames() {}\r\n\r\n  /**\r\n   * Add a new state to be controlled by the container. States are stored keyed\r\n   * by their name property, which must be unique. If it isn't, a number will\r\n   * be added or incremented until a unique key is generated.\r\n   *\r\n   * @param {AbstractState} state - State to add to the container.\r\n   *\r\n   * @returns {string} - Unique name of the state.\r\n   */\r\n  addState(state) {}\r\n\r\n  /**\r\n   * Removes a state with the given name from the container.\r\n   *\r\n   * @param {string} name - Name of the state to remove.\r\n   *\r\n   * @returns {boolean} - Whether or not a state was removed.\r\n   */\r\n  removeState(name) {}\r\n\r\n  /**\r\n   * Renames a state with the given name in the container. Name must be unique\r\n   * to the container, if it isn't the name will be incremented until it is unique.\r\n   *\r\n   * @param {string} currentName - Name of the state to rename.\r\n   * @param {string} newName - Name to update the state with.\r\n   *\r\n   * @returns {string} - Updated name for the state.\r\n   */\r\n  renameState(currentName, newName) {}\r\n\r\n  /**\r\n   * Discards all states.\r\n   */\r\n  discardStates() {}\r\n\r\n  /**\r\n   * Creates a class that implements {@link StateContainerInterface} and extends\r\n   * a specified base class.\r\n   *\r\n   * @param {Class} [BaseClass = class{}] - The class to extend.\r\n   *\r\n   * @return {Class} A class that extends `BaseClass` and implements {@link StateContainerInterface}.\r\n   */\r\n  static Mixin(BaseClass = class {}) {\r\n    /**\r\n     * This mixin adds functionality for manipulating uniquely-named animation states in\r\n     * a map.\r\n     */\r\n    const StateContainerMixin = class extends BaseClass {\r\n      constructor(options = {}, ...args) {\r\n        super(options, ...args);\r\n\r\n        this._states = this._states !== undefined ? this._states : new Map();\r\n      }\r\n\r\n      getState(name) {\r\n        return this._states.get(name);\r\n      }\r\n\r\n      getStateNames() {\r\n        return [...this._states.keys()];\r\n      }\r\n\r\n      addState(state) {\r\n        // Make sure the state is not already in this container\r\n        if ([...this._states.values()].includes(state)) {\r\n          console.warn(\r\n            `Cannot add animation to state ${this.name}. Animation was already added.`\r\n          );\r\n          return state.name;\r\n        }\r\n\r\n        // Make sure the state name is unique\r\n        const uniqueName = Utils.getUniqueName(state.name, [\r\n          ...this._states.keys(),\r\n        ]);\r\n\r\n        if (state.name !== uniqueName) {\r\n          console.warn(\r\n            `Animation name ${state.name} is not unique for state ${this.name}. New animation will be added with name ${uniqueName}.`\r\n          );\r\n          state.name = uniqueName;\r\n        }\r\n\r\n        this._states.set(state.name, state);\r\n\r\n        return state.name;\r\n      }\r\n\r\n      removeState(name) {\r\n        // Check if the state is in this container\r\n        if (!this._states || !this._states.has(name)) {\r\n          console.warn(\r\n            `Did not remove animation ${name} from state ${this.name}. No animation exists with this name.`\r\n          );\r\n          return false;\r\n        }\r\n\r\n        this._states.get(name).discard();\r\n        this._states.delete(name);\r\n        return true;\r\n      }\r\n\r\n      renameState(currentName, newName) {\r\n        // Make sure the state is in this container\r\n        if (!this._states || !this._states.has(currentName)) {\r\n          throw new Error(\r\n            `Cannot rename animation ${currentName} in ${this.name}. No animation exists with this name.`\r\n          );\r\n        }\r\n\r\n        const state = this._states.get(currentName);\r\n\r\n        // Exit if the names are the same\r\n        if (currentName === newName) {\r\n          return currentName;\r\n        }\r\n\r\n        // Make sure the name is unique\r\n        const uniqueName = Utils.getUniqueName(\r\n          newName,\r\n          [...this._states.keys()].filter(s => s.name !== currentName)\r\n        );\r\n\r\n        if (newName !== uniqueName) {\r\n          console.warn(\r\n            `Animation name ${newName} is not unique in state ${this.name}. Animation will be renamed to ${uniqueName}.`\r\n          );\r\n          newName = uniqueName;\r\n        }\r\n\r\n        state.name = newName;\r\n        this._states.delete(currentName);\r\n        this._states.set(state.name, state);\r\n\r\n        return state.name;\r\n      }\r\n\r\n      discardStates() {\r\n        this._states.forEach(state => {\r\n          state.discard();\r\n        });\r\n\r\n        delete this._states;\r\n      }\r\n    };\r\n    return StateContainerMixin;\r\n  }\r\n}\r\nexport default StateContainerInterface;\r\n","// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n// SPDX-License-Identifier: MIT-0\r\nimport AbstractState from './AbstractState';\r\nimport AnimationPlayerInterface from '../AnimationPlayerInterface';\r\nimport StateContainerInterface from './StateContainerInterface';\r\n\r\n/**\r\n * Class for playing an ordered array of animation states in sequence.\r\n *\r\n * @extends AbstractState\r\n * @implements @AnimationPlayerInterface\r\n */\r\nclass QueueState extends AnimationPlayerInterface.Mixin(\r\n  StateContainerInterface.Mixin(AbstractState)\r\n) {\r\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {Object} [options={}] - Options for the state.\r\n   * @param {boolean} [options.autoAdvance=true] - Whether to autmatically advance\r\n   * to the next state in the queue as each state completes.\r\n   * @param {Array.<AbstractState>} [queueStates=[]] - Array of states to be played\r\n   * in order.\r\n   */\r\n  constructor(options = {}, queueStates = []) {\r\n    super(options);\r\n\r\n    queueStates.forEach(state => {\r\n      this.addState(state);\r\n    });\r\n\r\n    this._queue = this._states.keys();\r\n    this._done = true;\r\n  }\r\n\r\n  /**\r\n   * Gets whether the animation queue has reached the end.\r\n   */\r\n  get done() {\r\n    return this._done;\r\n  }\r\n\r\n  /**\r\n   * Gets the internal weight.\r\n   *\r\n   * @readonly\r\n   * @type {number}\r\n   */\r\n  get internalWeight() {\r\n    return this._currentState\r\n      ? this._currentState.internalWeight * this._internalWeight\r\n      : 0;\r\n  }\r\n\r\n  /**\r\n   * Restart the queue iterator.\r\n   *\r\n   * @private\r\n   */\r\n  _reset() {\r\n    this._queue = this._states.keys();\r\n    const {value, done} = this._queue.next();\r\n    this._done = done;\r\n\r\n    return value || null;\r\n  }\r\n\r\n  /**\r\n   * Multiplies the user weight by a factor to determine the internal weight.\r\n   *\r\n   * @param {number} factor - 0-1 multiplier to apply to the user weight.\r\n   */\r\n  updateInternalWeight(factor) {\r\n    super.updateInternalWeight(factor);\r\n\r\n    if (this._currentState) {\r\n      this._currentState.updateInternalWeight(this._internalWeight);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start the next animation in the queue.\r\n   *\r\n   * @param {Function=} onNext - Function to execute each time an animation completes\r\n   * and the queue moves to the next animation.\r\n   * @param {boolean} [wrap=false] - Whether or not to start the queue from the\r\n   * beginning again if the end has been reached.\r\n   *\r\n   * @returns {Deferred}\r\n   */\r\n  next(onNext, wrap = false) {\r\n    // Move the queue forward\r\n    const {value: name, done} = this._queue.next();\r\n    this._done = done;\r\n    this._paused = false;\r\n\r\n    // The queue has reached the end\r\n    if (done) {\r\n      // Start the queue over\r\n      if (wrap) {\r\n        return this.play(\r\n          this._playCallbacks.onFinish,\r\n          this._playCallbacks.onError,\r\n          this._playCallbacks.onCancel,\r\n          onNext\r\n        );\r\n      }\r\n      // Stop the queue\r\n      else {\r\n        this._promises.finish.resolve();\r\n        return this._promises.finish;\r\n      }\r\n    }\r\n\r\n    // Signal the next animation is starting\r\n    if (typeof onNext === 'function') {\r\n      const lastName = [...this._states.keys()][this._states.size - 1];\r\n      const isQueueEnd = name === lastName;\r\n      onNext({\r\n        name,\r\n        canAdvance: this.getState(name).loopCount !== Infinity && !isQueueEnd,\r\n        isQueueEnd,\r\n      });\r\n    }\r\n\r\n    // Start the next animation\r\n    this.playAnimation(\r\n      name,\r\n      this._transitionTime,\r\n      this._easingFn,\r\n      () => {\r\n        if (!this._paused && !this.isTransitioning) {\r\n          this.next(onNext);\r\n        }\r\n      },\r\n      this._playCallbacks.onError\r\n    );\r\n\r\n    return this._promises.finish;\r\n  }\r\n\r\n  play(onFinish, onError, onCancel, onNext) {\r\n    const name = this._reset();\r\n    super.play(onFinish, onError, onCancel);\r\n\r\n    if (this._done) {\r\n      this._promises.finish.resolve();\r\n    } else {\r\n      // Signal the next animation is starting\r\n      if (name !== this.currentAnimation && typeof onNext === 'function') {\r\n        const lastName = [...this._states.keys()][this._states.size - 1];\r\n        const isQueueEnd = name === lastName;\r\n        onNext({\r\n          name,\r\n          canAdvance: name\r\n            ? this.getState(name).loopCount !== Infinity && !isQueueEnd\r\n            : true,\r\n          isQueueEnd: !name || isQueueEnd,\r\n        });\r\n      }\r\n\r\n      // Start the next animation\r\n      this.playAnimation(\r\n        name,\r\n        this._currentState ? this._transitionTime : 0,\r\n        this._easingFn,\r\n        () => {\r\n          if (!this._paused && !this.isTransitioning) {\r\n            this.next(onNext);\r\n          }\r\n        },\r\n        onError\r\n      );\r\n    }\r\n\r\n    return this._promises.finish;\r\n  }\r\n\r\n  pause() {\r\n    const paused = super.pause();\r\n    this.pauseAnimation();\r\n\r\n    return paused;\r\n  }\r\n\r\n  resume(onFinish, onError, onCancel, onNext) {\r\n    if (this._done) {\r\n      return this.play(onFinish, onError, onCancel, onNext);\r\n    } else {\r\n      super.resume(onFinish, onError, onCancel);\r\n\r\n      this.resumeAnimation(\r\n        this._currentState.name,\r\n        this._transitionTime,\r\n        this._easingFn,\r\n        () => {\r\n          if (!this._paused && !this.isTransitioning) {\r\n            this.next(onNext);\r\n          }\r\n        },\r\n        onError\r\n      );\r\n\r\n      return this._promises.finish;\r\n    }\r\n  }\r\n\r\n  cancel() {\r\n    const canceled = super.cancel();\r\n\r\n    if (this._currentState) {\r\n      this._currentState.cancel();\r\n    }\r\n\r\n    return canceled;\r\n  }\r\n\r\n  stop() {\r\n    const stopped = super.stop();\r\n    this.stopAnimation();\r\n    this._done = true;\r\n\r\n    return stopped;\r\n  }\r\n\r\n  discard() {\r\n    super.discard();\r\n\r\n    this.discardStates();\r\n  }\r\n}\r\n\r\nexport default QueueState;\r\n","// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n// SPDX-License-Identifier: MIT-0\r\nimport Deferred from 'core/Deferred';\r\nimport MathUtils from 'core/MathUtils';\r\nimport AbstractState from './AbstractState';\r\nimport StateContainerInterface from './StateContainerInterface';\r\n\r\n/**\r\n * Base class for a state that blends a collection of {@link AbstractState}.\r\n *\r\n * @abstract\r\n * @implements StateContainerInterface\r\n */\r\nclass AbstractBlendState extends StateContainerInterface.Mixin(AbstractState) {\r\n  constructor(options = {}, blendStates = [], ...args) {\r\n    super(options, ...args);\r\n    blendStates.forEach(state => {\r\n      this.addState(state);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Gets the sum of internal weights of the sub-states.\r\n   *\r\n   * @readonly\r\n   * @type {number}\r\n   */\r\n  get internalWeight() {\r\n    let blendWeights = 0;\r\n    this._states.forEach(state => {\r\n      blendWeights += state.internalWeight;\r\n    });\r\n    return blendWeights;\r\n  }\r\n\r\n  /**\r\n   * Returns the weight of a state controlled by the container.\r\n   *\r\n   * @param {string} name - Name of the state to return the weight from.\r\n   *\r\n   * @returns {number} - Weight of the state.\r\n   */\r\n  getBlendWeight(name) {\r\n    // Make sure the name is valid\r\n    const state = this.getState(name);\r\n    if (state === undefined) {\r\n      throw new Error(\r\n        `Cannot get weight of state ${name} from BlendState ${this.name}. No state exists with this name.`\r\n      );\r\n    }\r\n\r\n    return state.weight;\r\n  }\r\n\r\n  /**\r\n   * Sets the weight of a state controlled by the container.\r\n   *\r\n   * @param {string} name - Name of the state to set the weight of.\r\n   * @param {number} weight - Weight value to set on the state.\r\n   *\r\n   * @returns {Deferred}\r\n   */\r\n  setBlendWeight(name, weight, seconds = 0, easingFn) {\r\n    // Make sure the name is valid\r\n    const state = this.getState(name);\r\n\r\n    if (state === undefined) {\r\n      throw new Error(\r\n        `Cannot set weight of state ${name} from BlendState ${this.name}. No state exists with this name.`\r\n      );\r\n    }\r\n\r\n    weight = MathUtils.clamp(weight);\r\n    return state.setWeight(weight, seconds, easingFn);\r\n  }\r\n\r\n  /**\r\n   * Multiplies the weight of each sub-state by a factor to determine the internal weight.\r\n   *\r\n   * @param {number} factor - 0-1 multiplier to apply to the user weight.\r\n   */\r\n  updateInternalWeight(factor) {\r\n    super.updateInternalWeight(factor);\r\n\r\n    this._states.forEach(state => {\r\n      state.updateInternalWeight(this._internalWeight);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update any values of the sub-states that need to be evaluated every frame.\r\n   *\r\n   * @param {number} deltaTime - Time in milliseconds since the last update.\r\n   */\r\n  update(deltaTime) {\r\n    super.update(deltaTime);\r\n\r\n    this._states.forEach(state => {\r\n      state.update(deltaTime);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Start playback of the sub-states from the beginning.\r\n   *\r\n   * @param {Function=} onFinish - Function to execute when the state finishes.\r\n   * @param {Function=} onError - Function to execute if the state encounters\r\n   * an error during playback.\r\n   * @param {Function=} onCancel - Function to execute if playback is canceled.\r\n   *\r\n   * @returns {Deferred}\r\n   */\r\n  play(onFinish, onError, onCancel) {\r\n    const promises = [super.play()];\r\n\r\n    this._states.forEach(state => {\r\n      promises.push(state.play());\r\n    });\r\n    return Deferred.all(promises, onFinish, onError, onCancel);\r\n  }\r\n\r\n  /**\r\n   * Pause playback of the sub-states. This prevents pending promises from being executed.\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n  pause() {\r\n    this._states.forEach(state => {\r\n      state.pause();\r\n    });\r\n    return super.pause();\r\n  }\r\n\r\n  /**\r\n   * Resume playback of the sub-states.\r\n   *\r\n   * @param {Function=} onFinish - Function to execute when the state finishes.\r\n   * @param {Function=} onError - Function to execute if the state encounters\r\n   * an error during playback.\r\n   * @param {Function=} onCancel - Function to execute if playback is canceled.\r\n   *\r\n   * @returns {Deferred}\r\n   */\r\n  resume(onFinish, onError, onCancel) {\r\n    const promises = [super.resume()];\r\n\r\n    this._states.forEach(state => {\r\n      promises.push(state.resume());\r\n    });\r\n    return Deferred.all(promises, onFinish, onError, onCancel);\r\n  }\r\n\r\n  /**\r\n   * Cancel playback of the sub-states and cancel any pending promises.\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n  cancel() {\r\n    this._states.forEach(state => {\r\n      state.cancel();\r\n    });\r\n    return super.cancel();\r\n  }\r\n\r\n  /**\r\n   * Stop playback of the sub-states and resolve any pending promises.\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n  stop() {\r\n    this._states.forEach(state => {\r\n      state.stop();\r\n    });\r\n    return super.stop();\r\n  }\r\n\r\n  /**\r\n   * Discards all sub-state resources.\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n  discard() {\r\n    super.discard();\r\n\r\n    this.discardStates();\r\n  }\r\n}\r\n\r\nexport default AbstractBlendState;\r\n","// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n// SPDX-License-Identifier: MIT-0\r\nimport AbstractBlendState from './AbstractBlendState';\r\n\r\n/**\r\n * Class for blending N number of blend states.\r\n *\r\n * @extends AbstractBlendState\r\n */\r\nclass FreeBlendState extends AbstractBlendState {\r\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {Object} [options={}] - Options for the container state.\r\n   * @param {Array.<AbstractState>} [blendStates=[]] - Blend states to be controlled by\r\n   * this container.\r\n   */\r\n  constructor(options = {}, blendStates = []) {\r\n    super(options, blendStates);\r\n  }\r\n\r\n  updateInternalWeight(factor) {\r\n    super.updateInternalWeight(factor);\r\n\r\n    // Determine the total active weight of blend states\r\n    let sumWeights = 0;\r\n\r\n    this._states.forEach(state => {\r\n      sumWeights += state.weight;\r\n    });\r\n\r\n    // Ensure the sum of blend state internal weights does not exceed container internal weight\r\n    factor /= Math.max(sumWeights, 1);\r\n\r\n    // Sum of blend state internal weights should not exceed container internal weight\r\n    this._states.forEach(state => {\r\n      state.updateInternalWeight(factor * this._weight);\r\n    });\r\n  }\r\n}\r\n\r\nexport default FreeBlendState;\r\n","// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n// SPDX-License-Identifier: MIT-0\r\nimport Deferred from 'core/Deferred';\r\nimport AbstractBlendState from './AbstractBlendState';\r\nimport AnimationUtils from '../AnimationUtils';\r\n\r\n/**\r\n * Class for blending N number of blend states based on a single\r\n * parameter.\r\n *\r\n * @extends AbstractBlendState\r\n */\r\nclass Blend1dState extends AbstractBlendState {\r\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {Object} [options] - Options for the container state\r\n   * @param {Array.<AbstractBlendState>} [blendStates=[]] - Blend states to be\r\n   * controlled by this container.\r\n   * @param {Array.<number>} [blendThresholds=[]] - Threshold values for activating\r\n   * each blend state.\r\n   * @param {Array.<boolean>} [phaseMatches=[]] - Booleans indicating whether or not\r\n   * each blend state should be phase matched.\r\n   */\r\n  constructor(\r\n    options = {},\r\n    blendStates = [],\r\n    blendThresholds = [],\r\n    phaseMatches = []\r\n  ) {\r\n    super(options, blendStates);\r\n\r\n    this._blendValue = 0;\r\n    this._promises = {\r\n      ...this._promises,\r\n      blendValue: Deferred.resolve(),\r\n    };\r\n\r\n    // Validate there are no duplicate thresholds\r\n    const nonZeroDifferentSize =\r\n      blendStates.length !== 0 && blendStates.length !== blendThresholds.length;\r\n    if (nonZeroDifferentSize) {\r\n      throw new Error(\r\n        `Cannot create Blend1dState with blendThresholds ${blendThresholds}. BlendThresholds count does not match blendStates count.`\r\n      );\r\n    }\r\n\r\n    const containsDuplicates =\r\n      new Set(blendThresholds).size !== blendThresholds.length;\r\n    if (containsDuplicates) {\r\n      throw new Error(\r\n        `Cannot create Blend1dState with blendThresholds ${blendThresholds}. BlendThresholds contains duplicate values`\r\n      );\r\n    }\r\n\r\n    // Initialize the thresholds map\r\n    this._thresholds = [];\r\n    [...this._states.values()].forEach((state, index) => {\r\n      this._thresholds.push({\r\n        value: blendThresholds[index],\r\n        name: state.name,\r\n        phaseMatch: phaseMatches[index] || false,\r\n      });\r\n    });\r\n\r\n    this._sortThresholds();\r\n    this._forceNoThresholdDupes = true;\r\n\r\n    this._phaseLeadState = null;\r\n\r\n    this._updateBlendWeights();\r\n  }\r\n\r\n  /**\r\n   * Gets and sets the blend parameter value.\r\n   */\r\n  get blendValue() {\r\n    return this._blendValue;\r\n  }\r\n\r\n  set blendValue(value) {\r\n    this._blendValue = value;\r\n  }\r\n\r\n  /**\r\n   * Gets whether or not the blend value is currently being animated.\r\n   */\r\n  get blendValuePending() {\r\n    return this._promises.blendValue && this._promises.blendValue.pending;\r\n  }\r\n\r\n  /**\r\n   * Updates the user defined weight over time.\r\n   *\r\n   * @param {null} name - Unused parameter.\r\n   * @param {number} weight - The target weight value.\r\n   * @param {number} [seconds=0] - The amount of time it will take to reach the\r\n   * target weight.\r\n   * @param {Function=} easingFn - The easing function to use for interpolation.\r\n   *\r\n   * @returns {Deferred}\r\n   */\r\n  setBlendWeight(name, value, seconds = 0, easingFn) {\r\n    this._promises.blendValue.cancel();\r\n\r\n    this._promises.blendValue = AnimationUtils.interpolateProperty(\r\n      this,\r\n      'blendValue',\r\n      value,\r\n      {\r\n        seconds,\r\n        easingFn,\r\n        onProgress: () => {\r\n          this._updateBlendWeights();\r\n        },\r\n        onFinish: () => {\r\n          this._updateBlendWeights();\r\n        },\r\n      }\r\n    );\r\n\r\n    return this._promises.blendValue;\r\n  }\r\n\r\n  /**\r\n   * Gets the user defined weight.\r\n   *\r\n   * @returns {number}\r\n   */\r\n  getBlendWeight() {\r\n    return this.blendValue;\r\n  }\r\n\r\n  addState(state, thresholdValue = 0, phaseMatch = false) {\r\n    this._thresholds = this._thresholds || [];\r\n\r\n    // Make sure there is not already a state with this threshold\r\n    const sameValue = this._thresholds.find(\r\n      threshold => threshold.value === thresholdValue\r\n    );\r\n    if (this._forceNoThresholdDupes && sameValue !== undefined) {\r\n      throw new Error(\r\n        `Cannot set blend threshold of ${thresholdValue} for state ${state.name} on ${this.name}. A state already exists with that threshold.`\r\n      );\r\n    }\r\n\r\n    super.addState(state);\r\n    this._thresholds.push({\r\n      value: thresholdValue,\r\n      name: state.name,\r\n      phaseMatch: phaseMatch || false,\r\n    });\r\n\r\n    this._sortThresholds();\r\n\r\n    return state.name;\r\n  }\r\n\r\n  removeState(name) {\r\n    const removed = super.removeState(name);\r\n\r\n    if (removed) {\r\n      const index = this._thresholds.findIndex(\r\n        threshold => threshold.name === name\r\n      );\r\n      this._thresholds.splice(index, 1);\r\n    }\r\n\r\n    return removed;\r\n  }\r\n\r\n  renameState(currentName, newName) {\r\n    newName = super.renameState(currentName, newName);\r\n\r\n    const threshold = this._thresholds.find(\r\n      threshold => threshold.name === currentName\r\n    );\r\n    threshold.name = newName;\r\n\r\n    return newName;\r\n  }\r\n\r\n  /**\r\n   * Gets the threshold value of a blend with the corresponding name.\r\n   *\r\n   * @param {string} name - Name of the blend to get the threshold of.\r\n   *\r\n   * @returns {number} Threhold value.\r\n   */\r\n  getBlendThreshold(name) {\r\n    const threshold = this._thresholds.find(\r\n      threshold => threshold.name === name\r\n    );\r\n\r\n    if (threshold === undefined) {\r\n      throw new Error(\r\n        `Cannot get blend threshold of state ${name} on ${this.name}. No state exists with that name.`\r\n      );\r\n    }\r\n\r\n    return threshold.value;\r\n  }\r\n\r\n  /**\r\n   * Sets the threshold value of a blend with the corresponding name.\r\n   *\r\n   * @param {string} name - Name of the blend to set the threshold.\r\n   * @param {number} value - Value of the threshold to set.\r\n   *\r\n   * @returns {number} Set threshold value.\r\n   */\r\n  setBlendThreshold(name, value) {\r\n    // Make sure there is not already a state with this threshold\r\n    const sameValue = this._thresholds.find(\r\n      threshold => threshold.value === value\r\n    );\r\n    if (sameValue !== undefined) {\r\n      throw new Error(\r\n        `Cannot set blend threshold of ${value} for state ${name} on ${this.name}. A state already exists with that threshold.`\r\n      );\r\n    }\r\n\r\n    const threshold = this._thresholds.find(\r\n      threshold => threshold.name === name\r\n    );\r\n\r\n    if (threshold === undefined) {\r\n      throw new Error(\r\n        `Cannot set blend threshold of state ${name} on ${this.name}. No state exists with that name.`\r\n      );\r\n    }\r\n\r\n    threshold.value = value;\r\n\r\n    this._sortThresholds();\r\n\r\n    return threshold.value;\r\n  }\r\n\r\n  updateInternalWeight(factor) {\r\n    super.updateInternalWeight(factor);\r\n\r\n    if (this._phaseLeadState) {\r\n      this._states.forEach(state => {\r\n        if (state.weight !== 0) {\r\n          state.normalizedTime = this._phaseLeadState.normalizedTime;\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates the blend weights based on their corresponding threshold values\r\n   * and the current blendValue. Additionally, sets a lead phase state if the\r\n   * conditions for phase-matching have been satisfied.\r\n   *\r\n   * @private\r\n   */\r\n  _updateBlendWeights() {\r\n    if (this._thresholds.length === 0) return;\r\n\r\n    if (this._thresholds.length === 1) {\r\n      const state = this._states.get(this._thresholds[0].name);\r\n      state.setWeight(1);\r\n      return;\r\n    }\r\n\r\n    // Initially set all sub-state weights to zero\r\n    this._states.forEach(state => {\r\n      state.setWeight(0);\r\n    });\r\n\r\n    this._phaseLeadState = null;\r\n\r\n    // Find the first threshold that is greater than or equal to the parameter value\r\n    let targetIndex = this._thresholds.findIndex(threshold => {\r\n      return threshold.value >= this._blendValue;\r\n    });\r\n\r\n    if (targetIndex === 0 || targetIndex === -1) {\r\n      // Give one state full influence\r\n      targetIndex = targetIndex === -1 ? this._thresholds.length - 1 : 0;\r\n      const state = this._states.get(this._thresholds[targetIndex].name);\r\n      state.setWeight(1);\r\n    } else {\r\n      // Linear interpolate influence between two states\r\n      const thresholdA = this._thresholds[targetIndex - 1];\r\n      const thresholdB = this._thresholds[targetIndex];\r\n\r\n      const factorB =\r\n        (this.blendValue - thresholdA.value) /\r\n        (thresholdB.value - thresholdA.value);\r\n      const factorA = 1 - factorB;\r\n\r\n      const stateA = this._states.get(thresholdA.name);\r\n      const stateB = this._states.get(thresholdB.name);\r\n\r\n      stateA.setWeight(factorA);\r\n      stateB.setWeight(factorB);\r\n\r\n      // Set phase-matching if needed\r\n      if (thresholdA.phaseMatch && thresholdB.phaseMatch) {\r\n        this._phaseLeadState = factorA > factorB ? stateA : stateB;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sorts the thresholds from low to high based on value.\r\n   *\r\n   * @private\r\n   */\r\n  _sortThresholds() {\r\n    this._thresholds.sort((a, b) => a.value - b.value);\r\n  }\r\n}\r\n\r\nexport default Blend1dState;\r\n","// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n// SPDX-License-Identifier: MIT-0\r\n/* eslint-disable no-underscore-dangle */\r\nimport Deferred from 'core/Deferred';\r\nimport MathUtils from 'core/MathUtils';\r\nimport AbstractBlendState from './AbstractBlendState';\r\nimport AnimationUtils from '../AnimationUtils';\r\n\r\n/**\r\n * Class for blending N number of blend states based on two\r\n * paramters.\r\n *\r\n * @extends AbstractBlendState\r\n */\r\nclass Blend2dState extends AbstractBlendState {\r\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {Object} [options] - Options for the container state\r\n   * @param {Array.<AbstractBlendState>} [blendStates=[]] - Blend states to be\r\n   * controlled by this container.\r\n   * @param {Array.<Array.<number>>} [blendThresholds=[]] - Threshold values for activating\r\n   * each blend state.\r\n   * @param {Array.<boolean>} [phaseMatches=[]] - Booleans indicating whether or not\r\n   * each blend state should be phase matched.\r\n   */\r\n  constructor(\r\n    options = {},\r\n    blendStates = [],\r\n    blendThresholds = [],\r\n    phaseMatches = []\r\n  ) {\r\n    super(options, blendStates);\r\n\r\n    if (blendStates.length !== blendThresholds.length) {\r\n      throw new Error(\r\n        `Cannot create Blend2dState with blendStates ${blendStates} and blendThresholds ${blendThresholds}. Count of blendStates must match count of blendThresholds.`\r\n      );\r\n    }\r\n\r\n    blendThresholds\r\n      .slice(0, blendThresholds.length - 1)\r\n      .forEach((threshold, index) => {\r\n        blendThresholds.slice(index + 1).forEach(otherThreshold => {\r\n          if (\r\n            threshold[0] === otherThreshold[0] &&\r\n            threshold[1] === otherThreshold[1]\r\n          ) {\r\n            throw new Error(\r\n              `Cannot create Blend2dState with blendThresholds ${blendThresholds}. No duplicate values allowed in blendThresholds.`\r\n            );\r\n          }\r\n        });\r\n      });\r\n\r\n    this._blendValueX = 0;\r\n    this._blendValueY = 0;\r\n\r\n    this._promises = {\r\n      ...this._promises,\r\n      blendValueX: Deferred.resolve(),\r\n      blendValueY: Deferred.resolve(),\r\n    };\r\n\r\n    this._thresholds = [];\r\n    [...this._states.values()].forEach((state, index) => {\r\n      this._thresholds.push({\r\n        name: state.name,\r\n        phaseMatch: phaseMatches[index] || false,\r\n      });\r\n    });\r\n\r\n    this._vertices = blendThresholds;\r\n\r\n    if (this._vertices.length >= 3) {\r\n      this._triangles = MathUtils.getDelaunayTriangulation(this._vertices);\r\n    }\r\n\r\n    this._phaseLeadState = null;\r\n\r\n    this._updateBlendWeights();\r\n  }\r\n\r\n  /**\r\n   * Updates the user defined weight over time.\r\n   *\r\n   * @param {string} name - Name of blend weight to update.\r\n   * @param {number} weight - Target weight value.\r\n   * @param {number} [seconds=0] - The amount of time it will take to reach the\r\n   * target value.\r\n   * @param {Function=} easingFn - The easing function to use for interpolation.\r\n   *\r\n   * @returns {Deferred}\r\n   */\r\n  setBlendWeight(name, value, seconds = 0, easingFn) {\r\n    const property = `blendValue${name.toUpperCase()}`;\r\n    if (property !== 'blendValueX' && property !== 'blendValueY') {\r\n      throw new Error(\r\n        `Cannot set blend weight for ${name} on ${this.name}. Blend2dState only accepts 'X' or 'Y' for setBlendWeight`\r\n      );\r\n    }\r\n\r\n    this._promises[property].cancel();\r\n\r\n    this._promises[property] = AnimationUtils.interpolateProperty(\r\n      this,\r\n      property,\r\n      value,\r\n      {\r\n        seconds,\r\n        easingFn,\r\n        onProgress: () => {\r\n          this._updateBlendWeights();\r\n        },\r\n        onFinish: () => {\r\n          this._updateBlendWeights();\r\n        },\r\n      }\r\n    );\r\n\r\n    return this._promises[property];\r\n  }\r\n\r\n  /**\r\n   * Gets the user defined weight.\r\n   *\r\n   * @param {string} name - Name of blend weight.\r\n   *\r\n   * @returns {number}\r\n   */\r\n  getBlendWeight(name) {\r\n    const property = name.toUpperCase();\r\n    if (property !== 'X' && property !== 'Y') {\r\n      throw new Error(\r\n        `Cannot get blend weight for ${name} on ${this.name}. Blend2dState only accepts 'X' or 'Y' for getBlendWeight`\r\n      );\r\n    }\r\n\r\n    return property === 'X' ? this._blendValueX : this._blendValueY;\r\n  }\r\n\r\n  /**\r\n   * Gets and sets the x blend weight.\r\n   */\r\n  get blendValueX() {\r\n    return this._blendValueX;\r\n  }\r\n\r\n  set blendValueX(value) {\r\n    this._blendValueX = value;\r\n  }\r\n\r\n  /**\r\n   * Gets and sets the y blend weight.\r\n   */\r\n  get blendValueY() {\r\n    return this._blendValueY;\r\n  }\r\n\r\n  set blendValueY(value) {\r\n    this._blendValueY = value;\r\n  }\r\n\r\n  /**\r\n   * Gets whether or not the x blend value is currently being animated.\r\n   */\r\n  get blendValueXPending() {\r\n    return this._promises.blendValueX && this._promises.blendValueX.pending;\r\n  }\r\n\r\n  /**\r\n   * Gets whether or not the y blend value is currently being animated.\r\n   */\r\n  get blendValueYPending() {\r\n    return this._promises.blendValueY && this._promises.blendValueY.pending;\r\n  }\r\n\r\n  updateInternalWeight(factor) {\r\n    super.updateInternalWeight(factor);\r\n\r\n    if (this._phaseLeadState) {\r\n      [...this._states.values()].forEach((state, index) => {\r\n        if (state.weight !== 0 && this._thresholds[index].phaseMatch) {\r\n          state.normalizedTime = this._phaseLeadState.normalizedTime;\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates the blend weights based on their corresponding threshold values\r\n   * and the current [x,y] blendValue. Additionally, sets a lead phase state if the\r\n   * conditions for phase-matching have been satisfied.\r\n   *\r\n   * @private\r\n   */\r\n  _updateBlendWeights() {\r\n    if (!this._vertices || this._vertices.length === 0) return;\r\n\r\n    if (this._vertices.length === 1) {\r\n      [...this._states.values()][0].weight = 1;\r\n      return;\r\n    }\r\n\r\n    // Initially set all sub-state weights to zero\r\n    this._states.forEach(state => {\r\n      state.setWeight(0);\r\n    });\r\n    this._phaseLeadState = null;\r\n\r\n    const p = [this._blendValueX, this._blendValueY];\r\n\r\n    if (this._vertices.length === 2) {\r\n      this._setInfluenceClosestPointOnLine(p);\r\n    } else {\r\n      const triangle = this._triangles.find(triangle => {\r\n        return MathUtils.isPointInTriangle(\r\n          this._vertices[triangle[0]],\r\n          this._vertices[triangle[1]],\r\n          this._vertices[triangle[2]],\r\n          p\r\n        );\r\n      });\r\n\r\n      if (triangle) {\r\n        this._setInfluenceTriangle(triangle, p);\r\n      } else {\r\n        this._setInfluenceClosestPointInTriangles(p);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets blend weights for states corresponding to a\r\n   * triangle of thresholds and a given [x,y] blendValues.\r\n   *\r\n   * @param {Array.<Array.<number>>} triangle - Set of triangluated indices\r\n   * that correspond to blend thresholds.\r\n   * @param {Array.<number>} p - Given [x,y] blendValue.\r\n   *\r\n   * @private\r\n   */\r\n  _setInfluenceTriangle(triangle, p) {\r\n    const areaA = MathUtils.triangleArea(\r\n      this._vertices[triangle[1]],\r\n      this._vertices[triangle[2]],\r\n      p\r\n    );\r\n\r\n    const areaB = MathUtils.triangleArea(\r\n      this._vertices[triangle[0]],\r\n      this._vertices[triangle[2]],\r\n      p\r\n    );\r\n\r\n    const areaC = MathUtils.triangleArea(\r\n      this._vertices[triangle[0]],\r\n      this._vertices[triangle[1]],\r\n      p\r\n    );\r\n\r\n    const totalArea = areaA + areaB + areaC;\r\n\r\n    const weightA = areaA / totalArea;\r\n    const weightB = areaB / totalArea;\r\n    const weightC = areaC / totalArea;\r\n\r\n    const thresholdA = this._thresholds[triangle[0]];\r\n    const thresholdB = this._thresholds[triangle[1]];\r\n    const thresholdC = this._thresholds[triangle[2]];\r\n\r\n    const stateA = this._states.get(thresholdA.name);\r\n    const stateB = this._states.get(thresholdB.name);\r\n    const stateC = this._states.get(thresholdC.name);\r\n\r\n    stateA.setWeight(weightA);\r\n    stateB.setWeight(weightB);\r\n    stateC.setWeight(weightC);\r\n\r\n    this._setPhaseLeadState(\r\n      [stateA, stateB, stateC],\r\n      [thresholdA.phaseMatch, thresholdB.phaseMatch, thresholdC.phaseMatch]\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Determines the closest point within a triangle of\r\n   * thresholds based on the current [x,y] blendValues and\r\n   * then sets blend weights for the corresponding states.\r\n   *\r\n   * @param {Array.<number>} p - Given [x,y] blendValue.\r\n   *\r\n   * @private\r\n   */\r\n  _setInfluenceClosestPointInTriangles(p) {\r\n    let globalClosestPoint = null;\r\n    let globalMinDist = Number.POSITIVE_INFINITY;\r\n    let closestTriangle = -1;\r\n\r\n    this._triangles.forEach((triangle, index) => {\r\n      const pointA = MathUtils.closestPointOnLine(\r\n        this._vertices[triangle[0]],\r\n        this._vertices[triangle[1]],\r\n        p\r\n      );\r\n      const pointB = MathUtils.closestPointOnLine(\r\n        this._vertices[triangle[1]],\r\n        this._vertices[triangle[2]],\r\n        p\r\n      );\r\n      const pointC = MathUtils.closestPointOnLine(\r\n        this._vertices[triangle[2]],\r\n        this._vertices[triangle[0]],\r\n        p\r\n      );\r\n\r\n      const distA = MathUtils.distanceSquared(pointA, p);\r\n      const distB = MathUtils.distanceSquared(pointB, p);\r\n      const distC = MathUtils.distanceSquared(pointC, p);\r\n\r\n      let localClosestPoint = pointC;\r\n      let localMinDist = distC;\r\n\r\n      if (distA < localMinDist) {\r\n        localClosestPoint = pointA;\r\n        localMinDist = distA;\r\n      }\r\n      if (distB < localMinDist) {\r\n        localClosestPoint = pointB;\r\n        localMinDist = distB;\r\n      }\r\n\r\n      if (localMinDist < globalMinDist) {\r\n        globalMinDist = localMinDist;\r\n        globalClosestPoint = [...localClosestPoint];\r\n        closestTriangle = index;\r\n      }\r\n    });\r\n\r\n    this._setInfluenceTriangle(\r\n      this._triangles[closestTriangle],\r\n      globalClosestPoint\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Determines the closest point on the line formed between the\r\n   * two blend thresholds based on the current [x,y] blendValues and\r\n   * then sets blend weights for the corresponding states.\r\n   *\r\n   * @param {Array.<number>} p - Given [x,y] blendValue.\r\n   *\r\n   * @private\r\n   */\r\n  _setInfluenceClosestPointOnLine(p) {\r\n    const closestPoint = MathUtils.closestPointOnLine(\r\n      this._vertices[[0]],\r\n      this._vertices[[1]],\r\n      p\r\n    );\r\n\r\n    const distA = MathUtils.distanceSquared(this._vertices[0], closestPoint);\r\n    const distB = MathUtils.distanceSquared(this._vertices[1], closestPoint);\r\n\r\n    const weightA = distB / (distA + distB);\r\n    const weightB = distA / (distA + distB);\r\n\r\n    const thresholdA = this._thresholds[0];\r\n    const thresholdB = this._thresholds[1];\r\n\r\n    const stateA = this._states.get(thresholdA.name);\r\n    const stateB = this._states.get(thresholdB.name);\r\n\r\n    stateA.setWeight(weightA);\r\n    stateB.setWeight(weightB);\r\n\r\n    this._setPhaseLeadState(\r\n      [stateA, stateB],\r\n      [thresholdA.phaseMatch, thresholdB.phaseMatch]\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Sets a lead phase state if the conditions\r\n   * for phase-matching are satisfied.\r\n   *\r\n   * @param {Array.<AbstractBlendState>} states - States to\r\n   * check phase-matching criteria.\r\n   * @param {Array.<boolean>} phaseMatched - List of phase-match booleans.\r\n   *\r\n   * @private\r\n   */\r\n  _setPhaseLeadState(states, phaseMatched) {\r\n    let max = 0;\r\n    states.forEach((state, index) => {\r\n      if (phaseMatched[index] && state.weight > max) {\r\n        this._phaseLeadState = state;\r\n        max = state.weight;\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nexport default Blend2dState;\r\n","// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n// SPDX-License-Identifier: MIT-0\r\nimport AbstractBlendState from './state/AbstractBlendState';\r\nimport AnimationPlayerInterface from './AnimationPlayerInterface';\r\nimport AnimationUtils from './AnimationUtils';\r\nimport MathUtils from '../MathUtils';\r\nimport Deferred from '../Deferred';\r\nimport StateContainerInterface from './state/StateContainerInterface';\r\n\r\n/**\r\n * Enum for types of {@link AnimationLayer} blending.\r\n *\r\n * @readonly\r\n * @enum {string}\r\n */\r\nexport const LayerBlendModes = {Override: 'Override', Additive: 'Additive'};\r\n\r\n/**\r\n * The default blending mode {@link AnimationLayer}.\r\n *\r\n * @readonly\r\n * @type {string}\r\n */\r\nexport const DefaultLayerBlendMode = 'Override';\r\n\r\n/**\r\n * Checks if a given blendMode is present in the values of {@link LayerBlendModes}.\r\n * If it is, return the original value, otherwise return {@link DefaultLayerBlendMode}.\r\n *\r\n * @param {string} blendMode - The name of the type of blending.\r\n *\r\n * @returns {(string|DefaultLayerBlendMode)}\r\n */\r\nexport function validateBlendMode(blendMode) {\r\n  if (Array.from(Object.values(LayerBlendModes)).includes(blendMode)) {\r\n    return blendMode;\r\n  } else {\r\n    return DefaultLayerBlendMode;\r\n  }\r\n}\r\n\r\n/**\r\n * Class for managing a set of animations where only one state can be active at\r\n * any given time.\r\n *\r\n * @implements AnimationPlayerInterface\r\n * @implements StateContainerInterface\r\n */\r\nclass AnimationLayer extends AnimationPlayerInterface.Mixin(\r\n  StateContainerInterface.Mixin()\r\n) {\r\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {Object=} options -  Options for the animation layer.\r\n   * @param {string} options.name - Name of the layer. Names must be unique to the\r\n   * animation feature that contains the layer.\r\n   * @param {LayerBlendModes} [options.blendMode=DefaultLayerBlendMode] -\r\n   * Type of blending to use for all states controlled by the layer.\r\n   * @param {number} [options.weight=1] - The amount of influence the layer's current\r\n   * animation has over the result for the host.\r\n   * @param {number} [options.transitionTime=0] - The default amount of time to use when\r\n   * playing and resuming animations.\r\n   * @param {Function=} options.easingFn - The default easing function to use when\r\n   * transitioning between animations and setting layer weight.\r\n   */\r\n  constructor(options = {}) {\r\n    super(options);\r\n\r\n    this.name = options.name === undefined ? 'AnimationLayer' : options.name;\r\n    this._blendMode = Array.from(Object.values(LayerBlendModes)).includes(\r\n      options.blendMode\r\n    )\r\n      ? options.blendMode\r\n      : DefaultLayerBlendMode;\r\n    this._promises = {\r\n      weight: Deferred.resolve(),\r\n    };\r\n    this._weightPaused = false;\r\n\r\n    this.weight = typeof options.weight === 'number' ? options.weight : 1;\r\n    this._internalWeight = this._weight;\r\n  }\r\n\r\n  /**\r\n   * Gets the type of blending used for states controlled by the layer.\r\n   *\r\n   * @readonly\r\n   * @type {string}\r\n   */\r\n  get blendMode() {\r\n    return this._blendMode;\r\n  }\r\n\r\n  /**\r\n   * Gets and sets the amount of influence the layer's current animation has over\r\n   * the result for the host.\r\n   *\r\n   * @type {number}\r\n   */\r\n  set weight(weight) {\r\n    this._weight = MathUtils.clamp(weight, 0, 1);\r\n  }\r\n\r\n  get weight() {\r\n    return this._weight;\r\n  }\r\n\r\n  /**\r\n   * Gets whether or not the layer's weight value is currently being animated.\r\n   *\r\n   * @readonly\r\n   * @type {boolean}\r\n   */\r\n  get weightPending() {\r\n    return this._promises.weight && this._promises.weight.pending;\r\n  }\r\n\r\n  /**\r\n   * Pause the current animation state and any interpolation happening on the layer's\r\n   * weight property.\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n  pause() {\r\n    this._paused = true;\r\n    this._weightPaused = true;\r\n\r\n    return this.pauseAnimation() || this.weightPending;\r\n  }\r\n\r\n  /**\r\n   * Resume the current animation state and any interpolation happening on the layer's\r\n   * weight property.\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n  resume() {\r\n    this._paused = false;\r\n    this._weightPaused = false;\r\n\r\n    const isWeightActive = this.weightPending;\r\n\r\n    if (this._currentState) {\r\n      return this.resumeAnimation() || isWeightActive;\r\n    } else {\r\n      return isWeightActive;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates the user defined weight over time.\r\n   *\r\n   * @param {number} weight - The target weight value.\r\n   * @param {number} [seconds=0] - The amount of time it will take to reach the\r\n   * target weight.\r\n   * @param {Function=} easingFn - The easing function to use for interpolation.\r\n   *\r\n   * @returns {Deferred}\r\n   */\r\n  setWeight(weight, seconds = 0, easingFn) {\r\n    if (this.weightPending) {\r\n      this._promises.weight.cancel();\r\n    }\r\n\r\n    weight = MathUtils.clamp(weight);\r\n    this._promises.weight = AnimationUtils.interpolateProperty(\r\n      this,\r\n      'weight',\r\n      weight,\r\n      {\r\n        seconds,\r\n        easingFn: easingFn !== undefined ? easingFn : this._easingFn,\r\n      }\r\n    );\r\n\r\n    return this._promises.weight;\r\n  }\r\n\r\n  /**\r\n   * Pause any interpolation happening on the layer's weight property.\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n  pauseWeight() {\r\n    this._weightPaused = true;\r\n\r\n    return this.weightPending;\r\n  }\r\n\r\n  /**\r\n   * Resume any interpolation happening on the layer's weight property.\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n  resumeWeight() {\r\n    this._weightPaused = false;\r\n\r\n    return this.weightPending;\r\n  }\r\n\r\n  /**\r\n   * Multiplies the user weight by a factor to determine the internal weight.\r\n   *\r\n   * @param {number} factor - 0-1 multiplier to apply to the user weight.\r\n   */\r\n  updateInternalWeight(factor) {\r\n    this._internalWeight = this._weight * factor;\r\n\r\n    if (this._currentState) {\r\n      this._currentState.updateInternalWeight(this._internalWeight);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the names of blend states in an animation.\r\n   *\r\n   * @param {string} animationName - Name of the animation.\r\n   *\r\n   * @returns {Array.<string>} - Names of blend states.\r\n   */\r\n  getAnimationBlendNames(animationName) {\r\n    const state = this.getState(animationName);\r\n\r\n    if (state === undefined) {\r\n      throw new Error(\r\n        `Cannot get blend names of animation ${animationName} on layer ${this.name}. No animation exists with this name.`\r\n      );\r\n    }\r\n\r\n    if (state instanceof AbstractBlendState) {\r\n      return state.getStateNames();\r\n    }\r\n\r\n    throw new Error(\r\n      `Cannot get blend names of animation ${animationName} on layer ${this.name}. Animation is not an instance of AbstractBlendState.`\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Update the weight for a blend state of an animation.\r\n   *\r\n   * @param {string} animationName - Name of the animation containing the blend state\r\n   * to update.\r\n   * @param {string} blendName - Name of the blend state to update.\r\n   * @param {number} weight - Weight value to set on the animation. This number shoudld be\r\n   * in the 0-1 range.\r\n   * @param {number=} seconds - Number of seconds it should take to reach the new weight.\r\n   * Default is zero and will set immediately.\r\n   * @param {Function=} easingFn - Easing function to use while interpolating the new\r\n   * weight. Default is Easing.Linear.InOut.\r\n   *\r\n   * @returns {Deferred} - Promise that will resolve once the animation's weight reaches\r\n   * the target value.\r\n   */\r\n  setAnimationBlendWeight(\r\n    animationName,\r\n    blendName,\r\n    weight,\r\n    seconds = 0,\r\n    easingFn\r\n  ) {\r\n    const state = this.getState(animationName);\r\n\r\n    if (state === undefined) {\r\n      throw new Error(\r\n        `Cannot set blend weight of animation ${animationName} on layer ${this.name}. No animation exists with this name.`\r\n      );\r\n    }\r\n\r\n    if (state instanceof AbstractBlendState) {\r\n      return state.setBlendWeight(blendName, weight, seconds, easingFn);\r\n    }\r\n\r\n    throw new Error(\r\n      `Cannot set blend weight of animation ${animationName} on layer ${this.name}. Animation is not an instance of AbstractBlendState.`\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Returns the weight for a blend state of an animation.\r\n   *\r\n   * @param {string} animationName - Name of the animation containing the blend state\r\n   * to update.\r\n   * @param {string} blendName - Name of the blend state to retrieve the weight of.\r\n   *\r\n   * @returns {number} - Weight of the blend state.\r\n   */\r\n  getAnimationBlendWeight(animationName, blendName) {\r\n    const state = this.getState(animationName);\r\n\r\n    if (state === undefined) {\r\n      throw new Error(\r\n        `Cannot get blend weight of animation ${animationName} on layer ${this.name}. No animation exists with this name.`\r\n      );\r\n    }\r\n\r\n    if (state instanceof AbstractBlendState) {\r\n      return state.getBlendWeight(blendName);\r\n    }\r\n\r\n    throw new Error(\r\n      `Cannot get blend weight of animation ${animationName} on layer ${this.name}. Animation is not an instance of AbstractBlendState.`\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Update any weight interpolators and the current animation.\r\n   *\r\n   * @param {number} deltaTime - Time in milliseconds since the last update.\r\n   */\r\n  update(deltaTime) {\r\n    super.update(deltaTime);\r\n\r\n    if (!this._paused && !this._weightPaused) {\r\n      this._promises.weight.execute(deltaTime);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cancel any pending promises and discard states controlled by the layer.\r\n   */\r\n  discard() {\r\n    super.discard();\r\n\r\n    this.discardStates();\r\n\r\n    this._promises.weight.cancel();\r\n    delete this._promises;\r\n  }\r\n}\r\n\r\nexport default AnimationLayer;\r\n","// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n// SPDX-License-Identifier: MIT-0\r\nimport Deferred from 'core/Deferred';\r\nimport AbstractState from './AbstractState';\r\nimport {validateBlendMode} from '../AnimationLayer';\r\nimport AnimationUtils from '../AnimationUtils';\r\n\r\n/**\r\n * Class for playing a single animation clip.\r\n *\r\n * @extends AbstractState\r\n * @alias core/SingleState\r\n */\r\nclass SingleState extends AbstractState {\r\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {Object=} options - Options for the animation state.\r\n   * @param {string=} options.name - Name for the animation state. Names must be\r\n   * unique for the layer the state is applied to.\r\n   * @param {weight} [options.weight=0] - The 0-1 amount of influence the state will have.\r\n   * @param {timeScale} [options.timeScale=1] - Factor to scale the playback speed of the\r\n   * animation.\r\n   * @param {number} [options.loopCount=Infinity] - Number of times the animation should\r\n   * repeat before finishing.\r\n   * @param {string} [options.blendMode=DefaultLayerBlendMode] - Type of\r\n   * blending the animation should use.\r\n   */\r\n  constructor(options = {}) {\r\n    super(options);\r\n\r\n    this._timeScale = options.timeScale !== undefined ? options.timeScale : 1;\r\n    this._promises.timeScale = Deferred.resolve();\r\n    this._loopCount =\r\n      options.loopCount !== undefined ? options.loopCount : Infinity;\r\n    this._blendMode = validateBlendMode(options.blendMode);\r\n  }\r\n\r\n  /**\r\n   * Gets and sets the normalized playing time of the current animation\r\n   *\r\n   * @type {number}\r\n   */\r\n  get normalizedTime() {\r\n    return 0;\r\n  }\r\n\r\n  set normalizedTime(time) {\r\n  }\r\n\r\n  /**\r\n   * Gets and sets the a factor to scale animation playback speed with.\r\n   *\r\n   * @type {number}\r\n   */\r\n  get timeScale() {\r\n    return this._timeScale;\r\n  }\r\n\r\n  set timeScale(timeScale) {\r\n    this._timeScale = timeScale;\r\n  }\r\n\r\n  /**\r\n   * Gets whether or not the timeScale is currently being animated.\r\n   *\r\n   * @readonly\r\n   * @type {boolean}\r\n   */\r\n  get timeScalePending() {\r\n    return this._promises.timeScale.pending;\r\n  }\r\n\r\n  /**\r\n   * Updates the timeScale value over time.\r\n   *\r\n   * @param {number} weight - The target timeScale value.\r\n   * @param {number} [seconds=0] - The amount of time it will take to reach the\r\n   * target timeScale.\r\n   * @param {Function=} easingFn - The easing function to use for interpolation.\r\n   *\r\n   * @returns {Deferred}\r\n   */\r\n  setTimeScale(timeScale, seconds = 0, easingFn) {\r\n    this._promises.timeScale.cancel();\r\n\r\n    this._promises.timeScale = AnimationUtils.interpolateProperty(\r\n      this,\r\n      'timeScale',\r\n      timeScale,\r\n      {seconds, easingFn}\r\n    );\r\n\r\n    return this._promises.timeScale;\r\n  }\r\n\r\n  /**\r\n   * Gets and sets the number of times the animation will repeat before finishing.\r\n   *\r\n   * @type {number}\r\n   */\r\n  get loopCount() {\r\n    return this._loopCount;\r\n  }\r\n\r\n  set loopCount(loopCount) {\r\n    this._loopCount = loopCount;\r\n  }\r\n\r\n  /**\r\n   * Gets the type of blending used for the animation.\r\n   *\r\n   * @readonly\r\n   * @type {string}\r\n   */\r\n  get blendMode() {\r\n    return this._blendMode;\r\n  }\r\n}\r\n\r\nexport default SingleState;\r\n","// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n// SPDX-License-Identifier: MIT-0\r\nimport AbstractState from './AbstractState';\r\nimport StateContainerInterface from './StateContainerInterface';\r\nimport AnimationPlayerInterface from '../AnimationPlayerInterface';\r\nimport Utils from '../../Utils';\r\n\r\n/**\r\n * Class for playing random animations at random intervals within this state.\r\n *\r\n * @extends AbstractState\r\n * @implements AnimationPlayerInterface\r\n * @implements StateContainerInterface\r\n */\r\nclass RandomAnimationState extends AnimationPlayerInterface.Mixin(StateContainerInterface.Mixin(AbstractState)) {\r\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {Object} [options={}] - Options for the container state.\r\n   * @param {number} [options.playInterval=3] - The base animation playback interval.\r\n   * @param {Array.<AbstractState>} [subStates=[]] - states to be randomly picked to play\r\n   */\r\n  constructor(options = {}, subStates = []) {\r\n    super(options);\r\n\r\n    this._playInterval = options.playInterval ? options.playInterval : 3;\r\n\r\n    subStates.forEach(state => {\r\n      this.addState(state);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Gets and sets the base animation play interval\r\n   *\r\n   * @type {float}\r\n   */\r\n  get playInterval() {\r\n    return this._playInterval;\r\n  }\r\n\r\n  set playInterval(playInterval) {\r\n    this._playInterval = playInterval;\r\n  }\r\n\r\n  /**\r\n   * Reset the internal timer for animation play interval\r\n   *\r\n   * @private\r\n   */\r\n  _resetTimer() {\r\n    const playTimer = Utils.getRandomFloat(this._playInterval / 4, this._playInterval * 2);\r\n    const onFinish = () => {\r\n      this.playRandomAnimation(this._playCallbacks.onError);\r\n    }\r\n    this._promises.timer = Utils.wait(playTimer, {onFinish});\r\n  }\r\n\r\n  updateInternalWeight(factor) {\r\n    super.updateInternalWeight(factor);\r\n\r\n    if (this._currentState) {\r\n      this._currentState.updateInternalWeight(this._internalWeight);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Pick a random animation and utilize AnimationPlayerInterface to play that animation\r\n   *\r\n   * @param {Function=} onError - Function to execute if the state encounters\r\n   * an error during playback.\r\n   */\r\n  playRandomAnimation(onError) {\r\n    this._resetTimer();\r\n\r\n    const states = this.getStateNames();\r\n    if (this._currentState) {\r\n      states.splice(states.indexOf(this._currentState.name), 1);\r\n    }\r\n    const randomState =  states[Utils.getRandomInt(0, states.length)];\r\n\r\n    this.playAnimation(randomState, this._transitionTime, this._easingFn, undefined, onError, undefined);\r\n  }\r\n\r\n  play(onFinish, onError, onCancel) {\r\n    this.playRandomAnimation(onError);\r\n    return super.play(onFinish, onError, onCancel);\r\n  }\r\n\r\n  pause() {\r\n    return super.pause() && this.pauseAnimation();\r\n  }\r\n\r\n  resume(onFinish, onError, onCancel) {\r\n    if (this._currentState) {\r\n      this.resumeAnimation(this._currentState.name, this._transitionTime, this._easingFn, undefined, onError, undefined);\r\n    }\r\n    return super.resume(onFinish, onError, onCancel);\r\n  }\r\n\r\n  cancel() {\r\n    return super.cancel() && this.cancelAnimation();\r\n  }\r\n\r\n  stop() {\r\n    return super.stop() && this.stopAnimation();\r\n  }\r\n\r\n  discard() {\r\n    super.discard();\r\n    this.discardStates();\r\n  }\r\n}\r\n\r\nexport default RandomAnimationState;\r\n","// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n// SPDX-License-Identifier: MIT-0\r\nimport AbstractHostFeature from 'core/AbstractHostFeature';\r\nimport Utils from 'core/Utils';\r\nimport QueueState from './state/QueueState';\r\nimport FreeBlendState from './state/FreeBlendState';\r\nimport Blend1dState from './state/Blend1dState';\r\nimport Blend2dState from './state/Blend2dState';\r\nimport SingleState from './state/SingleState';\r\nimport RandomAnimationState from './state/RandomAnimationState';\r\nimport AnimationLayer, {LayerBlendModes} from './AnimationLayer';\r\nimport Deferred from '../Deferred';\r\n\r\n/**\r\n * Enum for animation state classes.\r\n *\r\n * @readonly\r\n * @enum {Class}\r\n */\r\nexport const AnimationTypes = {\r\n  single: SingleState,\r\n  freeBlend: FreeBlendState,\r\n  queue: QueueState,\r\n  randomAnimation: RandomAnimationState,\r\n  blend1d: Blend1dState,\r\n  blend2d: Blend2dState,\r\n};\r\n\r\n/**\r\n * Feature for managing animations on an object.\r\n *\r\n * @extends AbstractHostFeature\r\n * @alias core/AnimationFeature\r\n *\r\n * @property {Object} EVENTS - Built-in messages that the feature emits. When the\r\n * feature is added to a {@link core/HostObject}, event names will be prefixed by the\r\n * name of the feature class + '.'.\r\n * @property {string} [EVENTS.addLayer=onAddLayerEvent] - Message that is emitted after\r\n * [addLayer]{@link core/AnimationFeature#addLayer} has been successfully executed.\r\n * An object representing the name of the layer that was added and its index in\r\n * the layer stack with the signature {name: string, index: number} is supplied\r\n * as an argument to listener functions.\r\n * @property {string} [EVENTS.removeLayer=onRemoveLayerEvent] - Message that is\r\n * emitted after [removeLayer]{@link core/AnimationFeature#removeLayer} has been\r\n * successfully executed. An object representing the name of the layer that was\r\n * removed and its index in the layer stack with the signature {name: string, index: number}\r\n * is supplied as an argument to listener functions.\r\n * @property {string} [EVENTS.renameLayer=onRenameLayerEvent] - Message that is\r\n * emitted after [renameLayer]{@link core/AnimationFeature#renameLayer} has been\r\n * successfully executed. An object representing the original name of the layer\r\n * that was renamed and its updated name with the signature {oldName: string, newName: string}\r\n * is supplied as an argument to listener functions.\r\n * @property {string} [EVENTS.addAnimation=onAddAnimationEvent] - Message that is\r\n * emitted after [addAnimation]{@link core/AnimationFeature#addAnimation} has been\r\n * successfully executed. An object representing the name of the layer that the\r\n * animation was added to and the name of the animation that was added with the\r\n * signature {layerName: string, animationName: string} is supplied as an argument\r\n * to listener functions.\r\n * @property {string} [EVENTS.removeAnimation=onRemovedAnimationEvent] - Message\r\n * that is emitted after [removeAnimation]{@link core/AnimationFeature#removeAnimation}\r\n * has been successfully executed. An object representing the name of the layer\r\n * that the animation was removed from and the name of the animation that was removed\r\n * with the signature {layerName: string, animationName: string} is supplied as\r\n * an argument to listener functions.\r\n * @property {string} [EVENTS.renameAnimation=onRenameAnimationEvent] - Message\r\n * that is emitted after [renameAnimation]{@link core/AnimationFeature#renameAnimation}\r\n * has been successfully executed. An object representing the name of the layer\r\n * that contains the animation that was renamed, the original name of the animation\r\n * that was renamed and its updated name with the signature {layerName: string, oldName: string, newName: string}\r\n * is supplied as an argument to listener functions.\r\n * @property {string} [EVENTS.play=onPlayEvent] - Message that is emitted after\r\n * each call to [play]{@link core/AnimationFeature#playAnimation}. An object representing\r\n * the name of the layer contains the animation that was played and the name of\r\n * the animation that was played with the signature {layerName: string, animationName: string}\r\n * is supplied as an argument to listener functions.\r\n * @property {string} [EVENTS.pause=onPauseEvent] - Message that is emitted after\r\n * each call to [pause]{@link core/AnimationFeature#pauseAnimation}. An object representing\r\n * the name of the layer contains the animation that was paused and the name of\r\n * the animation that was paused with the signature {layerName: string, animationName: string}\r\n * is supplied as an argument to listener functions.\r\n * @property {string} [EVENTS.resume=onResumeEvent] - Message that is emitted after\r\n * each call to [resume]{@link core/AnimationFeature#resumeAnimation}. An object representing\r\n * the name of the layer contains the animation that was resumed and the name of\r\n * the animation that was resumed with the signature {layerName: string, animationName: string}\r\n * is supplied as an argument to listener functions.\r\n * @property {string} [EVENTS.interrupt=onInterruptEvent] - Message that is emitted\r\n * if there is a current speech in progress and [play]{@link core/AnimationFeature#playAnimation}\r\n * or [resume]{@link core/AnimationFeature#resumeAnimation} are executed for a new speech.\r\n * An object representing the name of the layer contains the animation that was\r\n * interrupted and the name of the animation that was interrupted with the signature\r\n * {layerName: string, animationName: string} is supplied as an argument to listener\r\n * functions.\r\n * @property {string} [EVENTS.stop=onStopEvent] - Message that is emitted after\r\n * each call to [stop]{@link core/AnimationFeature#stopAnimation} and when a speech reaches\r\n * the end of playback. An object representing\r\n * the name of the layer contains the animation that was stopped and the name of\r\n * the animation that was stopped with the signature {layerName: string, animationName: string}\r\n * is supplied as an argument to listener functions.\r\n */\r\nclass AnimationFeature extends AbstractHostFeature {\r\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {core/HostObject} host - Host object that owns the feature.\r\n   */\r\n  constructor(host) {\r\n    super(host);\r\n\r\n    this._layers = [];\r\n    this._layerMap = {};\r\n    this._paused = false;\r\n  }\r\n\r\n  /**\r\n   * Make sure a supplied layer index is within the range of layers.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {number} index\r\n   * @param {boolean} [existing=true] - Whether the index represents and existing\r\n   * layer or a new layer to be added.\r\n   *\r\n   * @returns {number=}\r\n   */\r\n  _validateIndex(index, existing = true) {\r\n    // Index is invalid if there are no layers and we're checking for an existing layer index\r\n    if (this._layers.length === 0 && existing) {\r\n      return undefined;\r\n    }\r\n\r\n    const lastIndex = existing ? this._layers.length - 1 : this._layers.length;\r\n\r\n    // Count from the end of the array for negative indices\r\n    if (index < 0) {\r\n      index = lastIndex + index + 1;\r\n    }\r\n\r\n    if (index < 0 || index > lastIndex) {\r\n      return undefined;\r\n    } else {\r\n      return index;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Re-evaluate internal weight values of layers starting from the top of the\r\n   * stack. Override layers' weights affect the values of all layers lower in the\r\n   * stack.\r\n   *\r\n   * @private\r\n   */\r\n  _updateInternalWeights() {\r\n    const numLayers = this._layers.length;\r\n    let weightMultiplier = 1;\r\n\r\n    // Update internal weight values on layers in reverse order\r\n    for (let i = numLayers - 1; i >= 0; i--) {\r\n      const layer = this._layers[i];\r\n      layer.updateInternalWeight(weightMultiplier);\r\n\r\n      // If the layer is override, update the multiplier with the remainder of the full weight\r\n      if (layer.blendMode === LayerBlendModes.Override && layer.currentState) {\r\n        weightMultiplier *= 1 - layer.currentState.internalWeight;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return a new instance of a SingleState.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {Object} options - Options to pass to the SingleState constructor.\r\n   * @param {string=} options.name - Name for the animation state. Names must be\r\n   * unique for the layer the state is applied to.\r\n   * @param {weight} [options.weight=0] - The 0-1 amount of influence the state will have.\r\n   * @param {timeScale} [options.timeScale=1] - Factor to scale the playback speed of the\r\n   * animation.\r\n   * @param {number} [options.loopCount=Infinity] - Number of times the animation should\r\n   * repeat before finishing.\r\n   * @param {string} [options.blendMode=LayerBlendModes[DefaultLayerBlendMode]] - Type of\r\n   * blending the animation should use.\r\n   *\r\n   * @returns {core/SingleState}\r\n   */\r\n  _createSingleState(options) {\r\n    return new SingleState(options);\r\n  }\r\n\r\n  /**\r\n   * Return a new instance of a FreeBlendState.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {Object} options - Options to pass to the FreeBlendState constructor.\r\n   * @param {string=} options.name - Name for the animation state. Names must be\r\n   * unique for the layer the state is applied to.\r\n   * @param {weight} [options.weight=0] - The 0-1 amount of influence the state will have.\r\n   * @param {timeScale} [options.timeScale=1] - Factor to scale the playback speed of the\r\n   * animation.\r\n   * @param {number} [options.loopCount=Infinity] - Number of times the animation should\r\n   * repeat before finishing.\r\n   * @param {string} [options.blendMode=LayerBlendModes[DefaultLayerBlendMode]] - Type of\r\n   * blending the animation should use.\r\n   * @param {Array.<Object>} [options.blendStateOptions] - Array of options used to create the\r\n   * blend states for this container.\r\n   *\r\n   * @returns {FreeBlendState}\r\n   */\r\n  _createFreeBlendState(options) {\r\n    const {blendStateOptions = []} = options;\r\n\r\n    const blendStates = [];\r\n    blendStateOptions.forEach(blendOptions => {\r\n      blendStates.push(\r\n        this._createSingleState({...blendOptions, blendMode: options.blendMode})\r\n      );\r\n    });\r\n\r\n    return new FreeBlendState(options, blendStates);\r\n  }\r\n\r\n  /**\r\n   * Return a new instance of a QueueState.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {Object} options - Options to pass to the QueueState constructor.\r\n   * @param {string=} options.name - Name for the animation state. Names must be\r\n   * unique for the layer the state is applied to.\r\n   * @param {number} [options.weight=0] - The 0-1 amount of influence the state will have.\r\n   * @param {number=} options.transitionTime - The amount of time it takes to transition\r\n   * between queued states.\r\n   * @param {string} [options.blendMode=LayerBlendModes[DefaultLayerBlendMode]] - Type of\r\n   * blending the animation should use.\r\n   * @param {Array.<Object>} [options.queueOptions] - Array of options used to create the\r\n   * queue states for this container.\r\n   *\r\n   * @returns {QueueState}\r\n   */\r\n  _createQueueState(options) {\r\n    const {queueOptions = []} = options;\r\n\r\n    const queueStates = queueOptions.map(queueOption =>\r\n      this._createSingleState({\r\n        transitionTime: options.transitionTime,\r\n        ...queueOption,\r\n        blendMode: options.blendMode,\r\n      })\r\n    );\r\n\r\n    return new QueueState(options, queueStates);\r\n  }\r\n\r\n  /**\r\n   * Return a new instance of a Blend1dState.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {Object} options - Options to pass to the Blend1dState constructor.\r\n   * @param {string=} options.name - Name for the animation state. Names must be\r\n   * unique for the layer the state is applied to.\r\n   * @param {weight} [options.weight=0] - The 0-1 amount of influence the state will have.\r\n   * @param {timeScale} [options.timeScale=1] - Factor to scale the playback speed of the\r\n   * animation.\r\n   * @param {number} [options.loopCount=Infinity] - Number of times the animation should\r\n   * repeat before finishing.\r\n   * @param {string} [options.blendMode=LayerBlendModes[DefaultLayerBlendMode]] - Type of\r\n   * blending the animation should use.\r\n   * @param {Array.<Object>} [options.blendStateOptions] - Array of options used to create the\r\n   * blend states for this container.\r\n   * @param {Array.<number>} [options.blendThresholds] - Array of numbers used to set the\r\n   * thresholds for each blend state in this container.\r\n   * @param {Array.<boolean>} [options.blendMatchPhases=[]] - Optional array of booleans used to\r\n   * set whether or not each blend state in this container will match phases.\r\n   *\r\n   * @returns {Blend1dState}\r\n   */\r\n  _createBlend1dState(options) {\r\n    const {blendStateOptions = []} = options;\r\n    const {blendThresholds = []} = options;\r\n    const {blendMatchPhases = []} = options;\r\n\r\n    const blendStates = [];\r\n    blendStateOptions.forEach(blendOptions => {\r\n      blendStates.push(\r\n        this._createSingleState({...blendOptions, blendMode: options.blendMode})\r\n      );\r\n    });\r\n\r\n    return new Blend1dState(\r\n      options,\r\n      blendStates,\r\n      blendThresholds,\r\n      blendMatchPhases\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return a new instance of a Blend2dState.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {Object} options - Options to pass to the Blend1dState constructor.\r\n   * @param {string=} options.name - Name for the animation state. Names must be\r\n   * unique for the layer the state is applied to.\r\n   * @param {weight} [options.weight=0] - The 0-1 amount of influence the state will have.\r\n   * @param {timeScale} [options.timeScale=1] - Factor to scale the playback speed of the\r\n   * animation.\r\n   * @param {number} [options.loopCount=Infinity] - Number of times the animation should\r\n   * repeat before finishing.\r\n   * @param {string} [options.blendMode=LayerBlendModes[DefaultLayerBlendMode]] - Type of\r\n   * blending the animation should use.\r\n   * @param {Array.<Object>} [options.blendStateOptions] - Array of options used to create the\r\n   * blend states for this container.\r\n   * @param {Array.<Array.<number>>} [options.blendThresholds] - Array of Array of numbers used to set the\r\n   * thresholds for each blend state in this container.\r\n   * @param {Array.<boolean>} [options.blendMatchPhases=[]] - Optional array of booleans used to\r\n   * set whether or not each blend state in this container will match phases.\r\n   *\r\n   * @returns {Blend1dState}\r\n   */\r\n  _createBlend2dState(options) {\r\n    const {blendStateOptions = []} = options;\r\n    const {blendThresholds = []} = options;\r\n    const {blendMatchPhases = []} = options;\r\n\r\n    const blendStates = [];\r\n    blendStateOptions.forEach(blendOptions => {\r\n      blendStates.push(\r\n        this._createSingleState({...blendOptions, blendMode: options.blendMode})\r\n      );\r\n    });\r\n\r\n    return new Blend2dState(\r\n      options,\r\n      blendStates,\r\n      blendThresholds,\r\n      blendMatchPhases\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return a new instance of a RandomAnimationState.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {Object} options - Options to pass to the RandomAnimationState constructor.\r\n   * @param {string=} options.name - Name for the animation state. Names must be\r\n   * unique for the layer the state is applied to.\r\n   * @param {number} [options.playInterval=3] - The base animation playback interval.\r\n   * @param {Array.<Object>} [options.subStateOptions] - Array of options used to create the\r\n   * sub states for this container.\r\n   *\r\n   * @returns {RandomAnimationState}\r\n   */\r\n  _createRandomAnimationState(options) {\r\n    const {subStateOptions = []} = options;\r\n\r\n    const subStates = [];\r\n    subStateOptions.forEach(subStateOptions => {\r\n      subStates.push(\r\n        this._createSingleState({\r\n          ...subStateOptions,\r\n          blendMode: options.blendMode,\r\n        })\r\n      );\r\n    });\r\n\r\n    return new RandomAnimationState(options, subStates);\r\n  }\r\n\r\n  /**\r\n   * Make sure the layer with the given name exists and return a unique version\r\n   * of the animation name supplied for that layer.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} layerName - Name of the layer to check against.\r\n   * @param {string} animationName - Name of the animation to validate.\r\n   *\r\n   * @returns {string} Validated animation name.\r\n   */\r\n  _validateNewAnimation(layerName, animationName) {\r\n    // Make sure the layerName is valid\r\n    const layer = this._layerMap[layerName];\r\n\r\n    if (layer === undefined) {\r\n      throw new Error(\r\n        `Cannot add animation to layer ${layerName} from host ${this._host.id}. No layer exists with this name.`\r\n      );\r\n    }\r\n\r\n    // Make sure the animationName is unique\r\n    const name = Utils.getUniqueName(animationName, layer.getStateNames());\r\n\r\n    if (name !== animationName) {\r\n      console.warn(\r\n        `Animation name ${animationName} is not unique for layer ${layer.name}. Animation will be renamed to ${name}.`\r\n      );\r\n    }\r\n\r\n    return name;\r\n  }\r\n\r\n  /**\r\n   * Gets whether or not all animations are paused.\r\n   *\r\n   * @readonly\r\n   * @type {boolean}\r\n   */\r\n  get paused() {\r\n    return this._paused;\r\n  }\r\n\r\n  /**\r\n   * Gets an array of names of animation layers.\r\n   *\r\n   * @readonly\r\n   * @type {Array.<string>}\r\n   */\r\n  get layers() {\r\n    return this._layers.map(layer => layer.name);\r\n  }\r\n\r\n  /**\r\n   * Create and store a new animation layer.\r\n   *\r\n   * @param {string} [name='NewLayer'] - Name for the layer.\r\n   * @param {Object} [options={}] - Options to pass to {@link AnimationLayer#constructor}\r\n   * @param {index=} index - Index to insert the new layer at. If none is provided\r\n   * it will be added to the end of the stack.\r\n   *\r\n   * @returns {number} Index of the new layer.\r\n   */\r\n  addLayer(name = 'NewLayer', options = {}, index) {\r\n    const numLayers = this._layers.length;\r\n    let layerIndex = index;\r\n\r\n    // Make sure the given index is within the range of layers\r\n    if (index === undefined || index === -1) {\r\n      layerIndex = this._layers.length;\r\n    } else {\r\n      layerIndex = this._validateIndex(index, false);\r\n\r\n      if (layerIndex === undefined) {\r\n        // Insert at the beginning if the user passed in a negative index\r\n        if (index < 0) {\r\n          layerIndex = 0;\r\n        }\r\n        // Otherwise append to the end\r\n        else {\r\n          layerIndex = this._layers.length;\r\n        }\r\n\r\n        console.warn(\r\n          `Index ${index} is invalid for host ${this._host.id}. New layer will be added at the closest valid index: ${layerIndex}.`\r\n        );\r\n      }\r\n    }\r\n\r\n    // Make sure the layer name is unique\r\n    const layerName = Utils.getUniqueName(name, Object.keys(this._layerMap));\r\n\r\n    if (name !== layerName) {\r\n      console.warn(\r\n        `Layer name ${name} is not unique. New layer will be added with the name ${layerName}.`\r\n      );\r\n    }\r\n\r\n    const layer = new AnimationLayer({...options, name: layerName});\r\n    this._layerMap[layerName] = layer;\r\n\r\n    if (layerIndex === numLayers) {\r\n      this._layers.push(layer);\r\n    } else {\r\n      this._layers.splice(layerIndex, 0, layer);\r\n    }\r\n\r\n    // Notify that a layer has been added to the feature\r\n    const eventData = {name: layerName, index: layerIndex};\r\n    this.emit(this.constructor.EVENTS.addLayer, eventData);\r\n\r\n    return eventData;\r\n  }\r\n\r\n  /**\r\n   * Remove an animation layer from the stack. Animations on this layer will no\r\n   * longer be evaluated.\r\n   *\r\n   * @param {string} name - Name for the layer to remove.\r\n   *\r\n   * @returns {boolean} Whether or not removal was successful.\r\n   */\r\n  removeLayer(name) {\r\n    const layer = this._layerMap[name];\r\n\r\n    if (layer === undefined) {\r\n      console.warn(\r\n        `Did not remove layer ${name} from host ${this._host.id}. No layer exists with this name.`\r\n      );\r\n      return false;\r\n    }\r\n\r\n    layer.discard();\r\n\r\n    const index = this._layers.indexOf(layer);\r\n    this._layers.splice(index, 1);\r\n    delete this._layerMap[name];\r\n\r\n    // Notify that a layer has been removed from the feature\r\n    this.emit(this.constructor.EVENTS.removeLayer, {name, index});\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Re-order the layer stack so that the layer with the given name is positioned\r\n   * at the given index.\r\n   *\r\n   * @param {string} name - Name of the layer to move.\r\n   * @param {number} index - New index to position the layer at.\r\n   *\r\n   * @returns {number} The new index of the layer\r\n   */\r\n  moveLayer(name, index) {\r\n    // Make sure the name is valid\r\n    const layer = this._layerMap[name];\r\n\r\n    if (layer === undefined) {\r\n      throw new Error(\r\n        `Cannot move layer ${name} from host ${this._host.id}. No layer exists with this name.`\r\n      );\r\n    }\r\n\r\n    // Make sure the index falls in the range of existing layers\r\n    const layerIndex = this._validateIndex(index, true);\r\n    const lastIndex = this._layers.length - 1;\r\n\r\n    if (layerIndex === undefined) {\r\n      throw new Error(\r\n        `Cannot move layer ${name} from host ${this._host.id} to index ${index}. Index must be in the 0 - ${lastIndex} range.`\r\n      );\r\n    }\r\n\r\n    const currentIndex = this._layers.indexOf(layer);\r\n    if (currentIndex === layerIndex) {\r\n      return;\r\n    }\r\n\r\n    // Remove from the current position\r\n    this._layers.splice(currentIndex, 1);\r\n\r\n    // Insert at the new position\r\n    if (layerIndex === lastIndex) {\r\n      this._layers.push(layer);\r\n    } else {\r\n      this._layers.splice(layerIndex, 0, layer);\r\n    }\r\n\r\n    return layerIndex;\r\n  }\r\n\r\n  /**\r\n   * Update the name of a layer. Names must be unique, if the new name is not\r\n   * unique it will have trailing numbers appended until it is unique.\r\n   *\r\n   * @param {string} currentName - Current name of the layer.\r\n   * @param {string} newName - New name to set on the layer.\r\n   *\r\n   * @returns {string} The new name of the layer\r\n   */\r\n  renameLayer(currentName, newName) {\r\n    // Make sure the name is valid\r\n    const layer = this._layerMap[currentName];\r\n\r\n    if (layer === undefined) {\r\n      throw new Error(\r\n        `Cannot rename layer ${currentName} from host ${this._host.id}. No layer exists with this name.`\r\n      );\r\n    }\r\n\r\n    // Make sure the layer name is unique\r\n    const name = Utils.getUniqueName(newName, Object.keys(this._layerMap));\r\n\r\n    if (name !== newName) {\r\n      console.warn(\r\n        `Layer name ${newName} is not unique. Layer will be renamed to ${name}.`\r\n      );\r\n    }\r\n\r\n    delete this._layerMap[currentName];\r\n    this._layerMap[name] = layer;\r\n    layer.name = name;\r\n\r\n    // Notify that a layer has been renamed on the feature\r\n    this.emit(this.constructor.EVENTS.renameLayer, {\r\n      oldName: currentName,\r\n      newName: name,\r\n    });\r\n\r\n    return name;\r\n  }\r\n\r\n  /**\r\n   * Return the weight of an animation layer.\r\n   *\r\n   * @param {string} name - Name of the layer to return weight from.\r\n   *\r\n   * @returns {number}\r\n   */\r\n  getLayerWeight(name) {\r\n    // Make sure the name is valid\r\n    const layer = this._layerMap[name];\r\n\r\n    if (layer === undefined) {\r\n      throw new Error(\r\n        `Cannot get weight on layer ${name} from host ${this._host.id}. No layer exists with this name.`\r\n      );\r\n    }\r\n\r\n    return layer.weight;\r\n  }\r\n\r\n  /**\r\n   * Update the weight of an animation layer.\r\n   *\r\n   * @param {string} name - The name of the layer to update.\r\n   * @param {number} weight - The weight value to set on the layer. This number\r\n   * should be in the 0-1 range.\r\n   * @param {number=} seconds - The number of seconds it should take to reach the\r\n   * new weight. Default is zero and will set immediately.\r\n   * @param {Function=} easingFn - The easing function to use while interpolating\r\n   * the weight. Default is Easing.Linear.InOut.\r\n   *\r\n   * @returns {Deferred} A promise that will resolve once the layer's weight reaches\r\n   * the target value.\r\n   */\r\n  setLayerWeight(name, weight, seconds, easingFn) {\r\n    // Make sure the name is valid\r\n    const layer = this._layerMap[name];\r\n\r\n    if (layer === undefined) {\r\n      const e = `Cannot set weight on layer ${name} from host ${this._host.id}. No layer exists with this name.`;\r\n      return Deferred.reject(e);\r\n    }\r\n\r\n    return layer.setWeight(weight, seconds, easingFn);\r\n  }\r\n\r\n  /**\r\n   * Returns the names of blend states in an animation in a layer.\r\n   *\r\n   * @param {string} layerName - Name of the layer containing the animation containing\r\n   * the blend state to update.\r\n   * @param {string} animationName - Name of the animation containing the blend state\r\n   * to update.\r\n   *\r\n   * @returns {Array.<string>} - Names of blend states.\r\n   */\r\n  getAnimationBlendNames(layerName, animationName) {\r\n    const layer = this._layerMap[layerName];\r\n\r\n    if (layer === undefined) {\r\n      throw new Error(\r\n        `Cannot get blend names on layer ${layerName} from host ${this._host.id}. No layer exists with this name.`\r\n      );\r\n    }\r\n\r\n    return layer.getAnimationBlendNames(animationName);\r\n  }\r\n\r\n  /**\r\n   * Update the weight for a blend state in an animation in a layer.\r\n   *\r\n   * @param {string} layerName - Name of the layer containing the animation containing\r\n   * the blend state to update.\r\n   * @param {string} animationName - Name of the animation containing the blend state\r\n   * to update.\r\n   * @param {string} blendName - Name of the blend state to update.\r\n   * @param {number} weight - Weight value to set on the animation. This number shoudld be\r\n   * in the 0-1 range.\r\n   * @param {number=} seconds - Number of seconds it should take to reach the new weight.\r\n   * Default is zero and will set immediately.\r\n   * @param {Function=} easingFn - Easing function to use while interpolating the new\r\n   * weight. Default is Easing.Linear.InOut.\r\n   *\r\n   * @returns {Deferred} - Promise that will resolve once the animation's weight reaches\r\n   * the target value.\r\n   */\r\n  setAnimationBlendWeight(\r\n    layerName,\r\n    animationName,\r\n    blendName,\r\n    weight,\r\n    seconds,\r\n    easingFn\r\n  ) {\r\n    const layer = this._layerMap[layerName];\r\n\r\n    if (layer === undefined) {\r\n      const e = `Cannot set blend weight on layer ${layerName} from host ${this._host.id}. No layer exists with this name.`;\r\n      return Deferred.reject(e);\r\n    }\r\n\r\n    return layer.setAnimationBlendWeight(\r\n      animationName,\r\n      blendName,\r\n      weight,\r\n      seconds,\r\n      easingFn\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Returns the weight for a blend state in an animation in a layer.\r\n   *\r\n   * @param {string} layerName - Name of the layer containing the animation containing\r\n   * the blend state to update.\r\n   * @param {string} animationName - Name of the animation containing the blend state\r\n   * to update.\r\n   * @param {string} blendName - Name of the blend state to update.\r\n   *\r\n   * @returns {number} - Weight of the blend state.\r\n   */\r\n  getAnimationBlendWeight(layerName, animationName, blendName) {\r\n    const layer = this._layerMap[layerName];\r\n\r\n    if (layer === undefined) {\r\n      throw new Error(\r\n        `Cannot get blend weight on layer ${layerName} from host ${this._host.id}. No layer exists with this name.`\r\n      );\r\n    }\r\n\r\n    return layer.getAnimationBlendWeight(animationName, blendName);\r\n  }\r\n\r\n  /**\r\n   * Pause weight interpolation animation on a layer with the given name.\r\n   *\r\n   * @param {string} name - Name of the layer to pause.\r\n   *\r\n   * @returns {boolean} - Whether or not there was an existing interpolation to pause.\r\n   */\r\n  pauseLayerWeight(name) {\r\n    // Make sure the name is valid\r\n    const layer = this._layerMap[name];\r\n\r\n    if (layer === undefined) {\r\n      throw new Error(\r\n        `Cannot pause weight interpolation on layer ${name} from host ${this._host.id}. No layer exists with this name.`\r\n      );\r\n    }\r\n\r\n    return layer.pauseWeight();\r\n  }\r\n\r\n  /**\r\n   * Resume weight interpolation animation on a layer with the given name.\r\n   *\r\n   * @param {string} name - Name of the layer to resume.\r\n   *\r\n   * @returns {Deferred} - Resolves once the layer's weight reaches its target value.\r\n   */\r\n  resumeLayerWeight(name) {\r\n    // Make sure the name is valid\r\n    const layer = this._layerMap[name];\r\n\r\n    if (layer === undefined) {\r\n      const e = `Cannot resume weight interpolation on layer ${name} from host ${this._host.id}. No layer exists with this name.`;\r\n      return Deferred.reject(e);\r\n    }\r\n\r\n    return layer.resumeWeight();\r\n  }\r\n\r\n  /**\r\n   * Pause current animation and weight interpolation animation on a layer with\r\n   * the given name.\r\n   *\r\n   * @param {string} name - Name of the layer to pause.\r\n   *\r\n   * @returns {boolean} - Whether or not there was an existing interpolation or\r\n   * current animation to pause.\r\n   */\r\n  pauseLayer(name) {\r\n    // Make sure the name is valid\r\n    const layer = this._layerMap[name];\r\n\r\n    if (layer === undefined) {\r\n      throw new Error(\r\n        `Cannot pause layer ${name} from host ${this._host.id}. No layer exists with this name.`\r\n      );\r\n    }\r\n\r\n    return layer.pause();\r\n  }\r\n\r\n  /**\r\n   * Resume current animation and weight interpolation animation on a layer with\r\n   * the given name.\r\n   *\r\n   * @param {string} name - Name of the layer to resume.\r\n   *\r\n   * @returns {Deferred} - Resolves once the layer's weight reaches its target value\r\n   * and it's current animation finishes playing.\r\n   */\r\n  resumeLayer(name) {\r\n    // Make sure the name is valid\r\n    const layer = this._layerMap[name];\r\n\r\n    if (layer === undefined) {\r\n      const e = `Cannot resume layer ${name} from host ${this._host.id}. No layer exists with this name.`;\r\n      return Deferred.reject(e);\r\n    }\r\n\r\n    return layer.resume();\r\n  }\r\n\r\n  /**\r\n   * Return whether or not the animation layer with the given name is currently\r\n   * transitioning between animations.\r\n   *\r\n   * @param {string} layerName - Name of the layer to check.\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n  getTransitioning(layerName) {\r\n    // Make sure the layerName is valid\r\n    const layer = this._layerMap[layerName];\r\n\r\n    if (layer === undefined) {\r\n      throw new Error(\r\n        `Get transitioning on layer ${layerName} from host ${this._host.id}. No layer exists with this name.`\r\n      );\r\n    }\r\n\r\n    return layer.isTransitioning;\r\n  }\r\n\r\n  /**\r\n   * Return an array of the names of all states the layer with the given name controls.\r\n   *\r\n   * @param {string} layerName - Name of the layer to search.\r\n   *\r\n   * @returns {Array.<string>}\r\n   */\r\n  getAnimations(layerName) {\r\n    // Make sure the layerName is valid\r\n    const layer = this._layerMap[layerName];\r\n\r\n    if (layer === undefined) {\r\n      throw new Error(\r\n        `Get animations on layer ${layerName} from host ${this._host.id}. No layer exists with this name.`\r\n      );\r\n    }\r\n\r\n    return layer.getStateNames();\r\n  }\r\n\r\n  /**\r\n   * Return the name of the state currently active on the layer with the given name.\r\n   * Return null if there is no current animation for the layer.\r\n   *\r\n   * @param {string} layerName - Name of the layer.\r\n   *\r\n   * @returns {(string|null)}\r\n   */\r\n  getCurrentAnimation(layerName) {\r\n    // Make sure the layerName is valid\r\n    const layer = this._layerMap[layerName];\r\n\r\n    if (layer === undefined) {\r\n      throw new Error(\r\n        `Get current animation on layer ${layerName} from host ${this._host.id}. No layer exists with this name.`\r\n      );\r\n    }\r\n\r\n    return layer.currentAnimation;\r\n  }\r\n\r\n  /**\r\n   * Return whether or not a layer with the given name is currently playing an\r\n   * animation and that animation is paused.\r\n   *\r\n   * @param {string} layerName - Name of the layer.\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n  getPaused(layerName) {\r\n    // Make sure the layerName is valid\r\n    const layer = this._layerMap[layerName];\r\n\r\n    if (layer === undefined) {\r\n      throw new Error(\r\n        `Get paused on layer ${layerName} from host ${this._host.id}. No layer exists with this name.`\r\n      );\r\n    }\r\n\r\n    return layer.currentState && layer.currentState.paused;\r\n  }\r\n\r\n  /**\r\n   * Return the type name of the given animation. @see AnimationTypes.\r\n   *\r\n   * @param {string} layerName - Name of the layer that contains the animation.\r\n   * @param {string} animationName - Name of the animation to check.\r\n   *\r\n   * @returns {string}\r\n   */\r\n  getAnimationType(layerName, animationName) {\r\n    // Make sure the layerName is valid\r\n    const layer = this._layerMap[layerName];\r\n\r\n    if (layer === undefined) {\r\n      throw new Error(\r\n        `Get animation type on layer ${layerName} from host ${this._host.id}. No layer exists with this name.`\r\n      );\r\n    }\r\n\r\n    const state = layer.getState(animationName);\r\n\r\n    if (state === undefined) {\r\n      throw new Error(\r\n        `Get animation type for animation ${animationName} on layer ${layerName} from host ${this._host.id}. No animation exists with this name.`\r\n      );\r\n    }\r\n\r\n    const {constructor} = state;\r\n\r\n    return Object.keys(AnimationTypes).find(\r\n      typeName => AnimationTypes[typeName] === constructor\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Add a new animation to an animation layer.\r\n   *\r\n   * @param {string} layerName - Name of the layer to add the animation to.\r\n   * @param {string} animationName - Name to use when calling the animation.\r\n   * @param {Object=} options - Options to pass to the constructor for the new\r\n   * SingleState animation.\r\n   *\r\n   * @returns {string} - The name of the animation that was added\r\n   */\r\n  addAnimation(\r\n    layerName,\r\n    animationName,\r\n    animationType = AnimationTypes.single,\r\n    options = {}\r\n  ) {\r\n    options.name = this._validateNewAnimation(layerName, animationName);\r\n\r\n    // Make sure the animation type is valid\r\n    if (!Object.values(AnimationTypes).includes(animationType)) {\r\n      throw new Error(\r\n        `Cannot add animation ${animationName} to layer ${layerName} on host ${this._host.id}. Invalid animation type.`\r\n      );\r\n    }\r\n\r\n    const layer = this._layerMap[layerName];\r\n    options.blendMode = layer.blendMode;\r\n    options.transitionTime = layer.transitionTime;\r\n    const state = this[`_create${animationType.name}`](options);\r\n\r\n    const name = layer.addState(state);\r\n\r\n    // Notify that an animation has been added to the feature\r\n    this.emit(this.constructor.EVENTS.addAnimation, {\r\n      layerName,\r\n      animationName: name,\r\n    });\r\n\r\n    return name;\r\n  }\r\n\r\n  /**\r\n   * Remove an animation from an animation layer.\r\n   *\r\n   * @param {string} layerName - Name of the layer to remove the animation from.\r\n   * @param {string} name - Name of the animation to remove.\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n  removeAnimation(layerName, animationName) {\r\n    // Make sure the name is valid\r\n    const layer = this._layerMap[layerName];\r\n\r\n    if (layer === undefined) {\r\n      throw new Error(\r\n        `Cannot remove animation from layer ${layerName} from host ${this._host.id}. No layer exists with this name.`\r\n      );\r\n    }\r\n\r\n    const removed = layer.removeState(animationName);\r\n\r\n    // Notify that an animation has been removed from the feature\r\n    if (removed === true) {\r\n      this.emit(this.constructor.EVENTS.removeAnimation, {\r\n        layerName,\r\n        animationName,\r\n      });\r\n    }\r\n\r\n    return removed;\r\n  }\r\n\r\n  /**\r\n   * Update the name of an animation. Names must be unique on each layer, if the new\r\n   * name is not unique it will have trailing numbers appended until it is unique.\r\n   *\r\n   * @param {string} layerName - Name of the layer that contains the animation that\r\n   * will be renamed,\r\n   * @param {string} currentAnimationName - Current name of the animation.\r\n   * @param {string} newAnimationName - New name to set on the animation.\r\n   *\r\n   * @returns {string} - The new name of the animation\r\n   */\r\n  renameAnimation(layerName, currentAnimationName, newAnimationName) {\r\n    const layer = this._layerMap[layerName];\r\n\r\n    if (layer === undefined) {\r\n      throw new Error(\r\n        `Cannot rename animation ${currentAnimationName} on layer ${layerName} for host ${this._host.id}. No layer exists with this name.`\r\n      );\r\n    }\r\n\r\n    const name = layer.renameState(currentAnimationName, newAnimationName);\r\n\r\n    // Notify that an animation has been renamed on the feature\r\n    this.emit(this.constructor.EVENTS.renameAnimation, {\r\n      layerName,\r\n      oldName: currentAnimationName,\r\n      newName: name,\r\n    });\r\n\r\n    return name;\r\n  }\r\n\r\n  /**\r\n   * Pause the currently playing animation and play a new animation from the beginning.\r\n   *\r\n   * @param {string} layerName - Name of the layer that contains the animation.\r\n   * @param {string} animationName - Name of the animation state to play.\r\n   * @param {number=} seconds - The number of seconds it should take to transition\r\n   * to the new animation. Default is zero and will set immediately.\r\n   * @param {Function=} easingFn - The easing function to use while transitioning\r\n   * between animations. Default is Easing.Linear.InOut.\r\n   *\r\n   * @returns {Deferred} - Resolves once the animation reaches the end of its\r\n   * timeline. Looping animations can only resolve if they are interrupted or\r\n   * manually stopped.\r\n   */\r\n  playAnimation(layerName, animationName, seconds, easingFn) {\r\n    const layer = this._layerMap[layerName];\r\n\r\n    if (layer === undefined) {\r\n      const e = `Cannot play animation ${animationName} on layer ${layerName} for host ${this._host.id}. No layer exists with this name.`;\r\n      return Deferred.reject(e);\r\n    }\r\n\r\n    // Notify that a new animation has begun\r\n    this.emit(this.constructor.EVENTS.playAnimation, {\r\n      layerName,\r\n      animationName,\r\n    });\r\n\r\n    return layer.playAnimation(\r\n      animationName,\r\n      seconds,\r\n      easingFn,\r\n      () => {\r\n        // Notify that an animation has stopped\r\n        this.emit(this.constructor.EVENTS.stopAnimation, {\r\n          layerName,\r\n          animationName,\r\n        });\r\n      },\r\n      undefined,\r\n      () => {\r\n        // Notify that an animation has been interrupted\r\n        this.emit(this.constructor.EVENTS.interruptAnimation, {\r\n          layerName,\r\n          animationName,\r\n        });\r\n      },\r\n      ({name, canAdvance, isQueueEnd}) => {\r\n        if (layer.currentAnimation === animationName) {\r\n          // Notify that a new animation has begun\r\n          this.emit(this.constructor.EVENTS.playNextAnimation, {\r\n            layerName,\r\n            animationName,\r\n            nextQueuedAnimation: name,\r\n            canAdvance,\r\n            isQueueEnd,\r\n          });\r\n        }\r\n      }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Play the next animation in the queue of a QueueState animation.\r\n   *\r\n   * @param {string} layerName - Name of the layer that contains the queue animation.\r\n   * @param {string=} animationName - Name of the animation queue animation. Defaults\r\n   * to the name of the current animation for the layer.\r\n   * @param {number=} seconds - The number of seconds it should take to transition\r\n   * to the queue animation if it's not already currently playing. Default is zero\r\n   * and will set immediately.\r\n   * @param {Function=} easingFn - The easing function to use while transitioning\r\n   * to the queue animation if it isn't already playing. Default is Easing.Linear.InOut.\r\n   *\r\n   * @returns {Deferred} - Resolves once the last animation in the queue finishes\r\n   * playing.\r\n   */\r\n  playNextAnimation(layerName, animationName, transitionTime, easingFn) {\r\n    const layer = this._layerMap[layerName];\r\n\r\n    if (layer === undefined) {\r\n      const e = `Cannot play next animation on layer ${layerName} for host ${this._host.id}. No layer exists with this name.`;\r\n      return Deferred.reject(e);\r\n    }\r\n\r\n    if (animationName === undefined) {\r\n      animationName = layer.currentAnimation;\r\n    }\r\n\r\n    const animation = layer.getState(layer.currentAnimation);\r\n\r\n    if (animation === null) {\r\n      const e = `Cannot play next animation on layer ${layerName} for host ${this._host.id}. No animation exists with name ${animationName}.`;\r\n      return Deferred.reject(e);\r\n    } else if (this.getAnimationType(layerName, animationName) !== 'queue') {\r\n      const e = `Cannot play next animation on layer ${layerName} for host ${this._host.id}. ${animationName} is not a queue state.`;\r\n      return Deferred.reject(e);\r\n    }\r\n\r\n    const onNext = ({name, canAdvance, isQueueEnd}) => {\r\n      if (layer.currentAnimation === animationName) {\r\n        // Notify that a new animation has begun\r\n        this.emit(this.constructor.EVENTS.playNextAnimation, {\r\n          layerName,\r\n          animationName,\r\n          nextQueuedAnimation: name,\r\n          canAdvance,\r\n          isQueueEnd,\r\n        });\r\n      }\r\n    };\r\n\r\n    // Make the queue animation current if it wasn't already\r\n    if (layer.currentAnimation === null) {\r\n      layer.resumeAnimation(\r\n        animation.name,\r\n        transitionTime,\r\n        easingFn,\r\n        undefined,\r\n        undefined,\r\n        undefined,\r\n        onNext\r\n      );\r\n    }\r\n\r\n    return animation.next(onNext, true);\r\n  }\r\n\r\n  /**\r\n   * Pause the current animation on a layer.\r\n   *\r\n   * @param {string} name - Name of the layer to pause.\r\n   *\r\n   * @returns {boolean} Whether or not an animation was successfully paused.\r\n   */\r\n  pauseAnimation(name) {\r\n    const layer = this._layerMap[name];\r\n\r\n    if (layer === undefined) {\r\n      console.warn(\r\n        `Did not pause animation on layer ${name} for host ${this._host.id}. No layer exists with this name.`\r\n      );\r\n      return false;\r\n    }\r\n\r\n    const paused = layer.pauseAnimation();\r\n\r\n    // Notify that an animation was paused\r\n    if (paused) {\r\n      const animationName = layer.currentAnimation;\r\n      this.emit(this.constructor.EVENTS.pauseAnimation, {\r\n        layerName: name,\r\n        animationName,\r\n      });\r\n    }\r\n\r\n    return paused;\r\n  }\r\n\r\n  /**\r\n   * Pause the currently playing animation and play a new animation from where it\r\n   * last left off.\r\n   *\r\n   * @param {string} layerName - Name of the layer that contains the animation.\r\n   * @param {string=} animationName - Name of the animation state to resume. Defaults\r\n   * to the name of the current animation for the layer.\r\n   * @param {number=} seconds - The number of seconds it should take to transition\r\n   * to the new animation. Default is zero and will set immediately.\r\n   * @param {Function=} easingFn - The easing function to use while transitioning\r\n   * between animations. Default is Easing.Linear.InOut.\r\n   *\r\n   * @returns {Deferred} - Resolves once the animation reaches the end of its\r\n   * timeline. Looping animations can only resolve if they are interrupted or\r\n   * manually stopped.\r\n   */\r\n  resumeAnimation(layerName, animationName, seconds, easingFn) {\r\n    const layer = this._layerMap[layerName];\r\n\r\n    if (layer === undefined) {\r\n      const e = `Cannot resume animation ${animationName} on layer ${layerName} for host ${this._host.id}. No layer exists with this name.`;\r\n      return Deferred.reject(e);\r\n    }\r\n\r\n    // Notify that an animation was resumed\r\n    this.emit(this.constructor.EVENTS.resumeAnimation, {\r\n      layerName,\r\n      animationName,\r\n    });\r\n\r\n    return layer.resumeAnimation(\r\n      animationName,\r\n      seconds,\r\n      easingFn,\r\n      () => {\r\n        // Notify that an animation has stopped\r\n        this.emit(this.constructor.EVENTS.stopAnimation, {\r\n          layerName,\r\n          animationName,\r\n        });\r\n      },\r\n      undefined,\r\n      () => {\r\n        // Notify that an animation has been interrupted\r\n        this.emit(this.constructor.EVENTS.interruptAnimation, {\r\n          layerName,\r\n          animationName,\r\n        });\r\n      },\r\n      ({name, canAdvance, isQueueEnd}) => {\r\n        if (layer.currentAnimation === animationName) {\r\n          // Notify that a new animation has begun\r\n          this.emit(this.constructor.EVENTS.playNextAnimation, {\r\n            layerName,\r\n            animationName,\r\n            nextQueuedAnimation: name,\r\n            canAdvance,\r\n            isQueueEnd,\r\n          });\r\n        }\r\n      }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Stop the current animation on a layer. Stop rewinds the animation to the\r\n   * beginning and prevents it from progressing forward.\r\n   *\r\n   * @param {string} name - Name of the layer that contains the animation.\r\n   *\r\n   * @returns {boolean} Whether or not an animation was successfully stopped.\r\n   */\r\n  stopAnimation(name) {\r\n    const layer = this._layerMap[name];\r\n\r\n    if (layer === undefined) {\r\n      console.warn(\r\n        `Did not stop animation on layer ${name} for host ${this._host.id}. No layer exists with this name.`\r\n      );\r\n      return false;\r\n    }\r\n\r\n    return layer.stopAnimation();\r\n  }\r\n\r\n  /**\r\n   * Pause current animation and weight interpolation animation on all layers.\r\n\r\n   * @returns {boolean} - Whether or not there was an existing interpolation or\r\n   * current animations to pause.\r\n   */\r\n  pause() {\r\n    this._paused = true;\r\n\r\n    let paused = false;\r\n    this._layers.forEach(l => {\r\n      if (l.pause()) {\r\n        paused = true;\r\n      }\r\n    });\r\n\r\n    return paused;\r\n  }\r\n\r\n  /**\r\n   * Resume current animation and weight interpolation animation on all layers.\r\n\r\n   * @returns {boolean} - Whether or not there was an existing interpolation or\r\n   * current animations to resume.\r\n   */\r\n  resume() {\r\n    this._paused = false;\r\n\r\n    let resumed = false;\r\n    this._layers.forEach(l => {\r\n      if (l.resume()) {\r\n        resumed = true;\r\n      }\r\n    });\r\n\r\n    return resumed;\r\n  }\r\n\r\n  /**\r\n   * Adds a namespace to the host with the name of the feature to contain properties\r\n   * and methods from the feature that users of the host need access to.\r\n   *\r\n   * @see AnimationFeature\r\n   */\r\n  installApi() {\r\n    /**\r\n     * @inner\r\n     * @namespace AnimationFeature\r\n     */\r\n    const api = super.installApi();\r\n\r\n    Object.defineProperties(api, {\r\n      /**\r\n       * @memberof AnimationFeature\r\n       * @instance\r\n       * @see core/AnimationFeature#paused\r\n       */\r\n      paused: {\r\n        get: () => this.paused,\r\n      },\r\n      /**\r\n       * @memberof AnimationFeature\r\n       * @instance\r\n       * @see core/AnimationFeature#layers\r\n       */\r\n      layers: {\r\n        get: () => this.layers,\r\n      },\r\n    });\r\n\r\n    Object.assign(api, {\r\n      /**\r\n       * @memberof AnimationFeature\r\n       * @instance\r\n       * @method\r\n       * @see core/AnimationFeature#addLayer\r\n       */\r\n      addLayer: this.addLayer.bind(this),\r\n      /**\r\n       * @memberof AnimationFeature\r\n       * @instance\r\n       * @method\r\n       * @see core/AnimationFeature#removeLayer\r\n       */\r\n      removeLayer: this.removeLayer.bind(this),\r\n      /**\r\n       * @memberof AnimationFeature\r\n       * @instance\r\n       * @method\r\n       * @see core/AnimationFeature#moveLayer\r\n       */\r\n      moveLayer: this.moveLayer.bind(this),\r\n      /**\r\n       * @memberof AnimationFeature\r\n       * @instance\r\n       * @method\r\n       * @see core/AnimationFeature#renameLayer\r\n       */\r\n      renameLayer: this.renameLayer.bind(this),\r\n\r\n      /**\r\n       * @memberof AnimationFeature\r\n       * @instance\r\n       * @method\r\n       * @see core/AnimationFeature#getLayerWeight\r\n       */\r\n      getLayerWeight: this.getLayerWeight.bind(this),\r\n      /**\r\n       * @memberof AnimationFeature\r\n       * @instance\r\n       * @method\r\n       * @see core/AnimationFeature#setLayerWeight\r\n       */\r\n      setLayerWeight: this.setLayerWeight.bind(this),\r\n      /**\r\n       * @memberof AnimationFeature\r\n       * @instance\r\n       * @method\r\n       * @see core/AnimationFeature#pauseLayerWeight\r\n       */\r\n      pauseLayerWeight: this.pauseLayerWeight.bind(this),\r\n      /**\r\n       * @memberof AnimationFeature\r\n       * @instance\r\n       * @method\r\n       * @see core/AnimationFeature#resumeLayerWeight\r\n       */\r\n      resumeLayerWeight: this.resumeLayerWeight.bind(this),\r\n      /**\r\n       * @memberof AnimationFeature\r\n       * @instance\r\n       * @method\r\n       * @see core/AnimationFeature#pauseLayer\r\n       */\r\n      pauseLayer: this.pauseLayer.bind(this),\r\n      /**\r\n       * @memberof AnimationFeature\r\n       * @instance\r\n       * @method\r\n       * @see core/AnimationFeature#resumeLayer\r\n       */\r\n      resumeLayer: this.resumeLayer.bind(this),\r\n\r\n      /**\r\n       * @memberof AnimationFeature\r\n       * @instance\r\n       * @method\r\n       * @see core/AnimationFeature#getTransitioning\r\n       */\r\n      getTransitioning: this.getTransitioning.bind(this),\r\n      /**\r\n       * @memberof AnimationFeature\r\n       * @instance\r\n       * @method\r\n       * @see core/AnimationFeature#getAnimations\r\n       */\r\n      getAnimations: this.getAnimations.bind(this),\r\n      /**\r\n       * @memberof AnimationFeature\r\n       * @instance\r\n       * @method\r\n       * @see core/AnimationFeature#getCurrentAnimation\r\n       */\r\n      getCurrentAnimation: this.getCurrentAnimation.bind(this),\r\n      /**\r\n       * @memberof AnimationFeature\r\n       * @instance\r\n       * @method\r\n       * @see core/AnimationFeature#getPaused\r\n       */\r\n      getPaused: this.getPaused.bind(this),\r\n      /**\r\n       * @memberof AnimationFeature\r\n       * @instance\r\n       * @method\r\n       * @see core/AnimationFeature#getAnimationType\r\n       */\r\n      getAnimationType: this.getAnimationType.bind(this),\r\n      /**\r\n       * @memberof AnimationFeature\r\n       * @instance\r\n       * @method\r\n       * @see core/AnimationFeature#addAnimation\r\n       */\r\n      addAnimation: this.addAnimation.bind(this),\r\n      /**\r\n       * @memberof AnimationFeature\r\n       * @instance\r\n       * @method\r\n       * @see core/AnimationFeature#removeAnimation\r\n       */\r\n      removeAnimation: this.removeAnimation.bind(this),\r\n      /**\r\n       * @memberof AnimationFeature\r\n       * @instance\r\n       * @method\r\n       * @see core/AnimationFeature#renameAnimation\r\n       */\r\n      renameAnimation: this.renameAnimation.bind(this),\r\n\r\n      /**\r\n       * @memberof AnimationFeature\r\n       * @instance\r\n       * @method\r\n       * @see core/AnimationFeature#getAnimationBlendNames\r\n       */\r\n      getAnimationBlendNames: this.getAnimationBlendNames.bind(this),\r\n      /**\r\n       * @memberof AnimationFeature\r\n       * @instance\r\n       * @method\r\n       * @see core/AnimationFeature#getAnimationBlendWeight\r\n       */\r\n      getAnimationBlendWeight: this.getAnimationBlendWeight.bind(this),\r\n      /**\r\n       * @memberof AnimationFeature\r\n       * @instance\r\n       * @method\r\n       * @see core/AnimationFeature#setAnimationBlendWeight\r\n       */\r\n      setAnimationBlendWeight: this.setAnimationBlendWeight.bind(this),\r\n\r\n      /**\r\n       * @memberof AnimationFeature\r\n       * @instance\r\n       * @method\r\n       * @see core/AnimationFeature#playAnimation\r\n       */\r\n      playAnimation: this.playAnimation.bind(this),\r\n\r\n      /**\r\n       * @memberof AnimationFeature\r\n       * @instance\r\n       * @method\r\n       * @see core/AnimationFeature#playNextAnimation\r\n       */\r\n      playNextAnimation: this.playNextAnimation.bind(this),\r\n\r\n      /**\r\n       * @memberof AnimationFeature\r\n       * @instance\r\n       * @method\r\n       * @see core/AnimationFeature#pauseAnimation\r\n       */\r\n      pauseAnimation: this.pauseAnimation.bind(this),\r\n      /**\r\n       * @memberof AnimationFeature\r\n       * @instance\r\n       * @method\r\n       * @see core/AnimationFeature#resumeAnimation\r\n       */\r\n      resumeAnimation: this.resumeAnimation.bind(this),\r\n      /**\r\n       * @memberof AnimationFeature\r\n       * @instance\r\n       * @method\r\n       * @see core/AnimationFeature#stopAnimation\r\n       */\r\n      stopAnimation: this.stopAnimation.bind(this),\r\n\r\n      /**\r\n       * @memberof AnimationFeature\r\n       * @instance\r\n       * @method\r\n       * @see core/AnimationFeature#pause\r\n       */\r\n      pause: this.pause.bind(this),\r\n      /**\r\n       * @memberof AnimationFeature\r\n       * @instance\r\n       * @method\r\n       * @see core/AnimationFeature#resume\r\n       */\r\n      resume: this.resume.bind(this),\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update each animation layer.\r\n   *\r\n   * @param {number} deltaTime - Time since the last update.\r\n   */\r\n  update(deltaTime) {\r\n    if (!this._layers.length) {\r\n      return;\r\n    }\r\n\r\n    if (this._paused) {\r\n      deltaTime = 0;\r\n    }\r\n\r\n    // Re-evaluate internal weights for layers\r\n    this._updateInternalWeights();\r\n\r\n    // Update layers\r\n    this._layers.forEach(layer => {\r\n      layer.update(deltaTime);\r\n    });\r\n\r\n    super.update(deltaTime);\r\n  }\r\n\r\n  discard() {\r\n    this._layers.forEach(layer => {\r\n      layer.discard();\r\n    });\r\n\r\n    delete this._layers;\r\n    delete this._layerMap;\r\n\r\n    super.discard();\r\n  }\r\n}\r\n\r\nObject.defineProperty(AnimationFeature, 'EVENTS', {\r\n  value: {\r\n    ...Object.getPrototypeOf(AbstractHostFeature).EVENTS,\r\n    addLayer: 'onAddLayerEvent',\r\n    removeLayer: 'onRemoveLayerEvent',\r\n    renameLayer: 'onRenameLayerEvent',\r\n    addAnimation: 'onAddAnimationEvent',\r\n    removeAnimation: 'onRemovedAnimationEvent',\r\n    renameAnimation: 'onRenameAnimationEvent',\r\n    playAnimation: 'onPlayEvent',\r\n    playNextAnimation: 'onNextEvent',\r\n    pauseAnimation: 'onPauseEvent',\r\n    resumeAnimation: 'onResumeEvent',\r\n    interruptAnimation: 'onInterruptEvent',\r\n    stopAnimation: 'onStopEvent',\r\n  },\r\n});\r\n\r\nexport default AnimationFeature;\r\n","// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n// SPDX-License-Identifier: MIT-0\r\n/* eslint-disable no-underscore-dangle */\r\n/* eslint-disable no-unused-vars */\r\nimport ManagedAnimationLayerInterface from './animpack/ManagedAnimationLayerInterface';\r\nimport { AnimationTypes } from './animpack/AnimationFeature';\r\nimport SSMLSpeechmarkInterface from './awspack/SSMLSpeechmarkInterface';\r\nimport AbstractHostFeature from './AbstractHostFeature';\r\nimport { Quadratic } from './animpack/Easing';\r\nimport MathUtils from './MathUtils';\r\nimport Utils from './Utils';\r\n\r\n/**\r\n * Enum for axis directions.\r\n *\r\n * @readonly\r\n * @enum {Class}\r\n */\r\nconst AxisMap = {\r\n  PositiveX: [1, 0, 0],\r\n  NegativeX: [-1, 0, 0],\r\n  PositiveY: [0, 1, 0],\r\n  NegativeY: [0, -1, 0],\r\n  PositiveZ: [0, 0, 1],\r\n  NegativeZ: [0, 0, -1],\r\n};\r\n\r\nconst FaceTargetTypes = {\r\n  EyeCenter: 0,\r\n  EyeLeft: 1,\r\n  EyeRight: 2,\r\n  Mouth: 3,\r\n}\r\n\r\n// Average distance between pupils is .064m, golden ratio says that the distance\r\n// from center of the pupils to the center of the mouth should be about the same.\r\nconst FaceVectors = [\r\n  [0, 0, 0],\r\n  [-.032, 0, 0],\r\n  [.032, 0, 0],\r\n  [0, -.064, 0]\r\n];\r\n\r\n// Time ranges to use when choosing a new random wait time between saccades\r\nconst MicroSaccadeWaitRanges = {\r\n  default: [0.8, 1.75],\r\n  postMacro: [0.6, 1.3125],\r\n};\r\n\r\nconst MacroSaccadeWaitRanges = {\r\n  default: [5.0, 8.0],\r\n  mouthTarget: [0.2, 0.75], // Look away from a mouth target the fastest\r\n  eyeTarget: [1.5, 4.0]\r\n};\r\n\r\n// Minimum angle in degrees the eye direction must change to trigger a blink animation\r\nconst BlinkThreshold = 35;\r\n\r\n// Maximum number of milliseconds to use for calculating look speed\r\nconst MaxDelta = 100 / 3;\r\n\r\n/**\r\n * PointOfInterest controls the gaze direction of the host. Given one or more\r\n * animations of type Blend2dState, it calculates the angles between the lookTracker\r\n * object (generally a joint in the host's skeleton) and the lookTarget (the object\r\n * the host should look at) and drives the managed Blend2dStates' X and Y blend\r\n * values using the result. You can optionally add saccadic movement to any managed\r\n * animation to help make the host's eyes appear alive when focused on the same\r\n * point for exteded periods of time. If blink animations are specified, a blink\r\n * will be played during large changes in gaze direction.\r\n *\r\n * @extends AbstractHostFeature\r\n * @alias core/PointOfInterestFeature\r\n * @implements SSMLSpeechmarkInterface\r\n * @implements ManagedAnimationLayerInterface\r\n */\r\nclass PointOfInterestFeature extends AbstractHostFeature.mix(\r\n  SSMLSpeechmarkInterface.Mixin,\r\n  ManagedAnimationLayerInterface.Mixin\r\n) {\r\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {core/HostObject} host - Host that owns the feature.\r\n   * @param {Object=} options - Options for the feature.\r\n   * @param {Object=} target - 3D transformation node that the host should try to\r\n   * look at.\r\n   * @param {Object} options.lookTracker - 3D transformation node that represents\r\n   * the direction the host is currently looking during animation.\r\n   * @param {Object=} options.scene - Engine-specific scene object that contains\r\n   * the host. This object must be defined if using 'setTargetByName' or 'SetTargetById'\r\n   * methods.\r\n   * @param {Object=} lookOptions - Options for the look animation layers.\r\n   * @param {number} [lookOptions.blendTime=0.1] - Default amount of time it will\r\n   * take to manipulate the weights of the look layers.\r\n   * @param {number} [lookOptions.easingFn=Quadratic.InOut] - Default easing function\r\n   * to use when manipulating look layer weights.\r\n   * @param {Array.<Object>} [lookOptions.layers=[]] - An array of layer options\r\n   * objects to register as look layers.\r\n   * @param {Object=} blinkOptions - Options for the blink animation layers.\r\n   * @param {number} [blinkOptions.blendTime=0.075] - Default amount of time it\r\n   * will take to manipulate the weights of the blink layers.\r\n   * @param {number} [blinkOptions.easingFn=Quadratic.InOut] - Default easing function\r\n   * to use when manipulating blink layer weights.\r\n   * @param {Array.<Object>} [blinkOptions.layers=[]] - An array of layer options\r\n   * objects to register as blink layers.\r\n   */\r\n  constructor(\r\n    host,\r\n    {\r\n      target,\r\n      lookTracker,\r\n      scene\r\n    } = {},\r\n    {\r\n      blendTime: lookBlendTime = 0.1,\r\n      easingFn: lookEasingFn = Quadratic.InOut,\r\n      layers: lookLayers = [],\r\n    } = {},\r\n    {\r\n      blendTime: blinkBlendTime = 0.075,\r\n      easingFn: blinkEasingFn = Quadratic.InOut,\r\n      layers: blinkLayers = [],\r\n    } = {}\r\n  ) {\r\n    super(host);\r\n\r\n    if (!this.constructor._validateTransformObject(lookTracker)) {\r\n      throw new Error(`Cannot initialize PointOfInterestFeature on host ${this._host.id}. LookTracker must be defined as a valid transformation object.`);\r\n    }\r\n    this._lookTracker = lookTracker;\r\n\r\n    this._scene = scene;\r\n    this._target = target || null;\r\n    this._prevTargetPos = [0, 0, 0];\r\n    this._isTargetMoving = false;\r\n    this._lookLayers = this._lookLayers || {};\r\n    this._trackingConfigs = this._trackingConfigs || [];\r\n    this._blinkLayers = this._blinkLayers || {};\r\n\r\n    // Register the look layers\r\n    lookLayers.forEach(({\r\n      name,\r\n      animation,\r\n      maxSpeed,\r\n      reference,\r\n      forwardAxis,\r\n      hasSaccade,\r\n      blendTime,\r\n      easingFn\r\n    }) => {\r\n      this.registerLookLayer(name, {\r\n        animation,\r\n        maxSpeed,\r\n        reference,\r\n        forwardAxis,\r\n        hasSaccade,\r\n        blendTime: blendTime !== undefined ? blendTime : lookBlendTime,\r\n        easingFn: easingFn !== undefined ? easingFn : lookEasingFn,\r\n      });\r\n    });\r\n\r\n    // Register the blink layers\r\n    blinkLayers.forEach(({ name, animation, blendTime, easingFn }) => {\r\n      this.registerBlinkLayer(name, {\r\n        animation,\r\n        blendTime: blendTime !== undefined ? blendTime : blinkBlendTime,\r\n        easingFn: easingFn !== undefined ? easingFn : blinkEasingFn,\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Gets and sets the target object the host should look at.\r\n   *\r\n   * @type {Object|null}\r\n   */\r\n  get target() {\r\n    return this._target;\r\n  }\r\n\r\n  set target(target) {\r\n    this._target = target || null;\r\n  }\r\n\r\n  /**\r\n   * Return a vector representing the global position of an object. Should be\r\n   * overloaded for each rendering engine implementation.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {any} _obj - Engine-specific 3D transform object.\r\n   *\r\n   * @returns {Array.<number>} - An array consisting of three numbers representing\r\n   * x, y and z coordinates.\r\n   */\r\n  static _getWorldPosition(obj) {\r\n    return [0, 0, 0];\r\n  }\r\n\r\n  /**\r\n   * Return a matrix representing the global transformation matrix of an object.\r\n   * Should be overloaded for each rendering engine implementation.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {any} obj - Engine-specific 3D transform object.\r\n   *\r\n   * @returns {Array.<number>} - An array consisting of 16 numbers representing\r\n   * the 3d transformation.\r\n   */\r\n  static _getWorldMatrix(obj) {\r\n    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\r\n  }\r\n\r\n  /**\r\n   * Rotate the given local direction vector by the object's world rotation matrix.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {any} obj - Engine-specific 3D transform object.\r\n   * @param {Array.<number>} forwardVector - Unit vector representing the local\r\n   * forward direction of the object.\r\n   *\r\n   * @returns {Array.<number>}\r\n   */\r\n  static _getObjectDirection(obj, forwardVector = AxisMap.PositiveZ) {\r\n    const rotation = MathUtils.getRotationMatrix(this._getWorldMatrix(obj));\r\n\r\n    return MathUtils.rotateVector(forwardVector, rotation);\r\n  }\r\n\r\n  /**\r\n   * Calculate horizontal and vertical look angles in degrees given spherical theta\r\n   * and phi angles in radians.\r\n   *\r\n   * @param {number} theta - Vertical/polar angle in radians where 0 points directly\r\n   * along positive Y axis.\r\n   * @param {number} phi - Horizontal/azimuthal angle in radians.\r\n   *\r\n   * @returns {Object} - An object with the signature {h: number, v: number} where\r\n   * h represents horizontal rotation in degrees and v represents vertical rotation\r\n   * in degrees.\r\n   */\r\n  static _sphericalToBlendValue(theta, phi) {\r\n    const h = MathUtils.toDegrees(phi);\r\n\r\n    // Offset the vertical angle so 0 is pointing forward instead of up\r\n    const v = MathUtils.toDegrees(theta) - 90;\r\n\r\n    // Convert vertical angle to -180, 180 range\r\n    return { h, v }\r\n  }\r\n\r\n  _onLayerAdded({ name }) {\r\n    this._lookLayers = this._lookLayers || {};\r\n    this._blinkLayers = this._blinkLayers || {};\r\n\r\n    super._onLayerAdded({ name });\r\n\r\n    // Validate the look animation\r\n    if (this._lookLayers[name] !== undefined) {\r\n      this._registerLookAnimation(name, this._lookLayers[name]);\r\n    }\r\n  }\r\n\r\n  _onAnimationAdded({ layerName, animationName }) {\r\n    this._lookLayers = this._lookLayers || {};\r\n    this._blinkLayers = this._blinkLayers || {};\r\n\r\n    super._onAnimationAdded({ layerName });\r\n\r\n    // Validate the look animation\r\n    if (this._lookLayers[layerName] === animationName) {\r\n      this._registerLookAnimation(layerName, animationName);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure that registered look animations are Blend2dStates.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} layerName - Name of the layer that contains the look animation.\r\n   * @param {string} animationName - Name of the animation.\r\n   */\r\n  _registerLookAnimation(layerName, animationName) {\r\n    if (this._managedLayers[layerName].animations[animationName].isActive) {\r\n      if (\r\n        AnimationTypes[this._host.AnimationFeature.getAnimationType(\r\n          layerName,\r\n          animationName\r\n        )] !== AnimationTypes.blend2d\r\n      ) {\r\n        // Warn and deactivate if the registered state is not blend2d\r\n        console.warn(\r\n          `Cannot register Point of Interest look animation ${animationName} on layer ${layerName} for host ${this._host.id}. Look animations must be of type 'blend2d'.`\r\n        );\r\n        this._managedLayers[layerName].animations[\r\n          animationName\r\n        ].isActive = false;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if the given object is not of an engine-specific type. Should\r\n   * be overloaded for each rendering engine implementation.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {any} obj - Object to validate.\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n  static _validateTransformObject(obj) {\r\n    return obj instanceof Object;\r\n  }\r\n\r\n  /**\r\n   * Check if the given configuration object has already been stored as a tracking\r\n   * config. If it has, return the stored configuration. Otherwise, store and\r\n   * return it.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {Object} config - Object containing tracker, reference and forwardAxis\r\n   * properties.\r\n   *\r\n   * @returns {Object}\r\n   */\r\n  _addTrackingConfig(config) {\r\n    const trackingConfig = this._trackingConfigs.find(c =>\r\n      c.reference === config.reference && c.forwardAxis === config.forwardAxis\r\n    );\r\n\r\n    if (trackingConfig) {\r\n      return trackingConfig;\r\n    } else {\r\n      config.angles = { h: 0, v: 0 };\r\n      config.prevAngles = { h: 0, v: 0 };\r\n      this._trackingConfigs.push(config);\r\n      return config;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return the distance between the look tracker and the look target.\r\n   *\r\n   * @private\r\n   *\r\n   * @returns {number}\r\n   */\r\n  _getTargetDistance() {\r\n    // Find the vector between the global positions of tracker and target\r\n    const sourcePosition = this.constructor._getWorldPosition(this._lookTracker);\r\n    const targetPosition = this.constructor._getWorldPosition(this._target);\r\n    const lookVector = [\r\n      targetPosition[0] - sourcePosition[0],\r\n      targetPosition[1] - sourcePosition[1],\r\n      targetPosition[2] - sourcePosition[2]\r\n    ];\r\n\r\n    return MathUtils.getVectorMagnitude(lookVector);\r\n  }\r\n\r\n  /**\r\n   * Reset all stored tracking angles to 0.\r\n   *\r\n   * @private\r\n   */\r\n  _resetLookAngles() {\r\n    this._trackingConfigs.forEach(({ angles }) => {\r\n      angles.h = 0;\r\n      angles.v = 0;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Store the difference in horizontal and vertical rotation for the tracker's\r\n   * reference rotation and the direction of the target from the tracker.\r\n   *\r\n   * @private\r\n   */\r\n  _setLookAngles() {\r\n    // Get the current positions of the tracker and target objects\r\n    const targetPos = this.constructor._getWorldPosition(this._target);\r\n    const trackerPos = this.constructor._getWorldPosition(this._lookTracker);\r\n\r\n    // Check if the target has moved\r\n    this._isTargetMoving = MathUtils.getVectorMagnitude([\r\n      targetPos[0] - this._prevTargetPos[0],\r\n      targetPos[1] - this._prevTargetPos[1],\r\n      targetPos[2] - this._prevTargetPos[2]]\r\n    ) > 0;\r\n    Object.assign(this._prevTargetPos, targetPos);\r\n\r\n\r\n    // Calculate the horizontal and vertical angles to rotate to the target\r\n    const targetSpherical = MathUtils.cartesianToSpherical(\r\n      targetPos[0] - trackerPos[0],\r\n      targetPos[1] - trackerPos[1],\r\n      targetPos[2] - trackerPos[2]\r\n    );\r\n    const targetAngles = this.constructor._sphericalToBlendValue(\r\n      targetSpherical[1],\r\n      targetSpherical[2]\r\n    );\r\n\r\n    // Calculate angles relative to the reference objects\r\n    this._trackingConfigs.forEach(({\r\n      reference,\r\n      forwardAxis,\r\n      angles\r\n    }) => {\r\n      // Calculate the horizontal and vertical angles to rotate to the direction of the tracker\r\n      const refDirection = this.constructor._getObjectDirection(\r\n        reference,\r\n        forwardAxis,\r\n      );\r\n      const refSpherical = MathUtils.cartesianToSpherical(...refDirection);\r\n      const refAngles = this.constructor._sphericalToBlendValue(\r\n        refSpherical[1],\r\n        refSpherical[2]\r\n      );\r\n\r\n      // Store the difference\r\n      angles.h = targetAngles.h - refAngles.h;\r\n      angles.v = targetAngles.v - refAngles.v;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Return the horizontal and vertical angles it would require to simulate looking\r\n   * at the given type of face target\r\n   *\r\n   * @private\r\n   *\r\n   * @param {number} targetType - Integer representing the FaceTargetType.\r\n   *\r\n   * @returns {Object}- An object with signature {r: number, h: number, v: number}\r\n   * where 'r' represents radius, h represents the horizontal/azimuthal angle and\r\n   * v represents the vertical/polar angle.\r\n   */\r\n  _getFaceTargetAngles(targetType) {\r\n    // No offset when the target is the center of the eyes\r\n    if (targetType === 0) {\r\n      return { h: 0, v: 0 };\r\n    }\r\n\r\n    // Build a vector to the face target type using the current distance to the target\r\n    const distance = this._getTargetDistance(this._lookTracker);\r\n    const faceVector = [...FaceVectors[targetType]];\r\n    faceVector[2] = distance;\r\n    const spherical = MathUtils.cartesianToSpherical(...faceVector);\r\n\r\n    // Make sure values are clamped within the range of motion of the human eye, in case the target is very close\r\n    const blendValues = this.constructor._sphericalToBlendValue(spherical[1], spherical[2]);\r\n    blendValues.h = MathUtils.clamp(blendValues.h, -35, 35);\r\n    blendValues.v = MathUtils.clamp(blendValues.v, -25, 30);\r\n\r\n    return blendValues;\r\n  }\r\n\r\n  /**\r\n   * Updated the stored speed and duration variables for a layer based on the\r\n   * change in horizontal and vertical angles of the tracker.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} layerName - Name of the layer to store values on.\r\n   * @param {number} h - Change in horizontal angle, in degrees.\r\n   * @param {number} v - Change in vertical angle, in degrees.\r\n   */\r\n  _updateLayerSpeed(layerName, h, v) {\r\n    const layer = this._managedLayers[layerName];\r\n\r\n    // From \"Realistic Avatar and head Animation Using a Neurobiological Model of Visual Attention\", Itti, Dhavale, Pighin\r\n    layer.maxHSpeed = 473 * (1 - Math.exp(-h / 7.8));\r\n    layer.maxVSpeed = 473 * (1 - Math.exp(-v / 7.8));\r\n\r\n    // From \"Eyes Alive\", Lee, Badler\r\n    const D0 = 0.025;\r\n    const d = 0.00235;\r\n    layer.hDuration = D0 + d * h;\r\n    layer.vDuration = D0 + d * v;\r\n  }\r\n\r\n  /**\r\n   * Set the microSaccade object with new randomized values.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} layerName - Name of the layer that owns the saccade motion.\r\n   */\r\n  _setMicroSaccade(layerName) {\r\n    const layer = this._managedLayers[layerName];\r\n    const { microSaccade } = layer;\r\n\r\n    if (this._target) {\r\n      // Micro movements should be smaller when focused on a target\r\n      microSaccade.h = Utils.getRandomFloat(.01, .15);\r\n      microSaccade.v = Utils.getRandomFloat(.01, .15);\r\n    } else {\r\n      // Microsaccades. Encyclopedia of Neuroscience. (2009) Springer, Berlin, Heidelberg. https://doi.org/10.1007/978-3-540-29678-2_3492\r\n      microSaccade.h = Utils.getRandomFloat(.01, .3);\r\n      microSaccade.v = Utils.getRandomFloat(.01, .3);\r\n    }\r\n\r\n    this._updateLayerSpeed(layerName, microSaccade.h, microSaccade.v);\r\n\r\n    // Restart the timer\r\n    this._initializeMicroTimer(layerName, ...MicroSaccadeWaitRanges.default);\r\n  }\r\n\r\n  /**\r\n   * Set the macroSaccade object with new randomized values.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} layerName - Name of the layer that owns the saccade motion.\r\n   */\r\n  _setMacroSaccade(layerName) {\r\n    const layer = this._managedLayers[layerName];\r\n    const { macroSaccade } = layer;\r\n    let macroSaccadeWaitRange;\r\n\r\n    // Increase random value range when not focused on a target\r\n    if (!this._target) {\r\n      macroSaccadeWaitRange = MacroSaccadeWaitRanges.default;\r\n\r\n      // Normal human horizontal eye rotation limit is about 35 degrees\r\n      const hLimit = Utils.getRandomFloat(.143, .286);\r\n      const hFactor = Utils.getRandomFloat(-hLimit, hLimit);\r\n      macroSaccade.h = hFactor * 35;\r\n\r\n      // Normal human vertical eye rotation limit is about 25 degrees upward and 30 degrees downward\r\n      const vLimit = Utils.getRandomFloat(.093, .186);\r\n      const vFactor = Utils.getRandomFloat(-vLimit, vLimit);\r\n      macroSaccade.v = vFactor > 0 ? vFactor * 25 : vFactor * 30;\r\n    }\r\n\r\n    // Pick a new face target\r\n    else {\r\n      // Social triangle - saccade between eyes and mouth, weighted to look at eyes more often\r\n      switch (layer.saccadeTarget) {\r\n        case 1:\r\n          macroSaccadeWaitRange = MacroSaccadeWaitRanges.eyeTarget;\r\n          layer.saccadeTarget = Math.random() < 0.75 ? FaceTargetTypes.EyeRight\r\n            : FaceTargetTypes.Mouth;\r\n          break;\r\n        case 2:\r\n          macroSaccadeWaitRange = MacroSaccadeWaitRanges.eyeTarget;\r\n          layer.saccadeTarget = Math.random() < 0.75 ? FaceTargetTypes.EyeLeft\r\n            : FaceTargetTypes.Mouth;\r\n          break;\r\n        case 3:\r\n          macroSaccadeWaitRange = MacroSaccadeWaitRanges.mouthTarget;\r\n          layer.saccadeTarget = Math.random() < 0.5 ? FaceTargetTypes.EyeLeft\r\n            : FaceTargetTypes.EyeRight;\r\n          break;\r\n        case 0:\r\n        default:\r\n          macroSaccadeWaitRange = MacroSaccadeWaitRanges.eyeTarget;\r\n          layer.saccadeTarget = Math.random() < 0.5 ? FaceTargetTypes.EyeLeft\r\n            : FaceTargetTypes.EyeRight;\r\n          break;\r\n      }\r\n\r\n      const { h, v } = this._getFaceTargetAngles(layer.saccadeTarget);\r\n      macroSaccade.h = h;\r\n      macroSaccade.v = v;\r\n    }\r\n\r\n    this._updateLayerSpeed(layerName, macroSaccade.h, macroSaccade.v);\r\n\r\n    // Restart the timers\r\n    this._initializeMicroTimer(layerName, ...MicroSaccadeWaitRanges.postMacro);\r\n    this._initializeMacroTimer(layerName, ...macroSaccadeWaitRange);\r\n  }\r\n\r\n  /**\r\n   * Start a new wait timer that will set a new micro saccade movement when it\r\n   * resolves.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} layerName - Name of the layer that owns the saccade motion.\r\n   * @param {number} minWaitTime - Minimum number of seconds before a new saccade\r\n   * will be triggered.\r\n   * @param {number} maxWaitTime - Maximum number of seconds before a new saccade\r\n   * will be triggered.\r\n   */\r\n  _initializeMicroTimer(layerName, minWaitTime, maxWaitTime) {\r\n    const layer = this._managedLayers[layerName];\r\n    const waitTime = Utils.getRandomFloat(minWaitTime, maxWaitTime);\r\n\r\n    if (layer.microSaccadeTimer) {\r\n      layer.microSaccadeTimer.cancel();\r\n    }\r\n    layer.microSaccadeTimer = Utils.wait(waitTime, {\r\n      onFinish: () => { this._setMicroSaccade(layerName) }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Start a new wait timer that will set a new macro saccade movement when it\r\n   * resolves.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} layerName - Name of the layer that owns the saccade motion.\r\n   * @param {number} minWaitTime - Minimum number of seconds before a new saccade\r\n   * will be triggered.\r\n   * @param {number} maxWaitTime - Maximum number of seconds before a new saccade\r\n   * will be triggered.\r\n   */\r\n  _initializeMacroTimer(layerName, minWaitTime, maxWaitTime) {\r\n    const layer = this._managedLayers[layerName];\r\n    const waitTime = Utils.getRandomFloat(minWaitTime, maxWaitTime);\r\n\r\n    if (layer.macroSaccadeTimer) {\r\n      layer.macroSaccadeTimer.cancel();\r\n    }\r\n    layer.macroSaccadeTimer = Utils.wait(waitTime, {\r\n      onFinish: () => { this._setMacroSaccade(layerName) }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Sets a new target to look at.\r\n   *\r\n   * @param {Object|null} target - The new target to look at.\r\n   */\r\n  setTarget(target) {\r\n    this.target = target;\r\n  }\r\n\r\n  /**\r\n   * Finds an object given its name and sets it as the new target to look at.\r\n   * Should be overloaded for each rendering engine implementation.\r\n   *\r\n   * @param {string} target - Name to search for.\r\n   */\r\n  setTargetByName(name) {\r\n    if (!name) {\r\n      this._target = null;\r\n    }\r\n\r\n    if (!this._scene) {\r\n      throw new Error(`Cannot set PointOfInterestFeature target using name ${name} on host ${this._host.id}. Scene must be defined.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Finds an object given its id and sets it as the new target to look at.\r\n   * Should be overloaded for each rendering engine implementation.\r\n   *\r\n   * @param {string|number} target - Id to search for.\r\n   */\r\n  setTargetById(id) {\r\n    if (!id) {\r\n      this._target = null;\r\n    }\r\n\r\n    if (!this._scene) {\r\n      throw new Error(`Cannot set PointOfInterestFeature target using id ${id} on host ${this._host.id}. Scene must be defined.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start keeping track of an animation layer that owns a blend2d animation with\r\n   * blendWeights corresponding to horizontal and vertical look angles.\r\n   *\r\n   * @param {string} layerName - Name of the layer to keep track of.\r\n   * @param {Object=} options - Options for the layer.\r\n   * @param {string} [options.animation = 'look'] - Name of the animation on the\r\n   * layer whose blendWeights will be driven based on the angle between the lookTracker\r\n   * and the lookTarget. This animation must be of type blend2d.\r\n   * @param {number} [options.maxSpeed = 25] - The maximum speed at which the blend2d\r\n   * blendWeights can be manipulated.\r\n   * @param {string} [options.forwardAxis = 'PositiveZ'] - Axis pointing from the\r\n   * front of the lookReference object. Valid options are 'PositiveX', 'NegativeX',\r\n   * 'PositiveY', 'NegativeY', 'PositiveZ', 'NegativeZ'.\r\n   * @param {Object=} options.lookReference - 3D transformation node that the lookTracker\r\n   * rotation limits should be calculated relative to. Defaults to the host owner.\r\n   * @param {number} [options.hasSaccade = false] - Whether or not to include\r\n   * saccadic motion onto the blendWeight animation. This should only be set to\r\n   * true for blend2d animations representing eye animation.\r\n   * @param {number=} [options.blendTime=[PointOfInterestFeature.DEFAULT_LAYER_OPTIONS.blendTime]{@link PointOfInterestFeature#DEFAULT_LAYER_OPTIONS#blendTime}] -\r\n   * Default amount of time to use when manipulating layer weight.\r\n   * @param {Function=} options.easingFn - Default easing function to use when\r\n   * manipulating layer weight.\r\n   */\r\n  registerLookLayer(\r\n    layerName,\r\n    {\r\n      animation = 'look',\r\n      maxSpeed = 25,\r\n      reference,\r\n      forwardAxis = 'PositiveZ',\r\n      hasSaccade = false,\r\n      blendTime = PointOfInterestFeature.DEFAULT_LAYER_OPTIONS.blendTime,\r\n      easingFn\r\n    } = {}\r\n  ) {\r\n    // Validate reference object\r\n    reference = reference || this._host.owner;\r\n\r\n    if (!this.constructor._validateTransformObject(reference)) {\r\n      throw new Error(`Cannot initialize register look layer ${layerName} for PointOfInterestFeature on host ${this._host.id}. Reference must be defined as a valid transformation object.`);\r\n    }\r\n\r\n    // Find vector associated with axis string\r\n    forwardAxis = AxisMap[forwardAxis] !== undefined\r\n      ? AxisMap[forwardAxis]\r\n      : AxisMap.PositiveZ;\r\n\r\n    // Store tracking configuration\r\n    const trackingConfig = this._addTrackingConfig({\r\n      reference,\r\n      forwardAxis\r\n    });\r\n\r\n    // Register the layer and animation\r\n    this.registerLayer(layerName, {\r\n      trackingConfig,\r\n      maxSpeed,\r\n      maxHSpeed: undefined,\r\n      maxVSpeed: undefined,\r\n      hDuration: undefined,\r\n      vDuration: undefined,\r\n      hVelocity: [0, 0],\r\n      vVelocity: [0, 0],\r\n      hasSaccade,\r\n      blendTime,\r\n      easingFn,\r\n      microSaccade: { h: 0, v: 0 },\r\n      macroSaccade: { h: 0, v: 0 },\r\n      saccadeTarget: FaceTargetTypes.EyeCenter,\r\n      animations: { [animation]: {} },\r\n    });\r\n    this._lookLayers[layerName] = animation;\r\n\r\n    // Validate the look animation\r\n    this._registerLookAnimation(layerName, animation);\r\n\r\n    // Initialize saccade timers\r\n    if (hasSaccade) {\r\n      const macroSaccadeWaitRange = this._target\r\n        ? MacroSaccadeWaitRanges.eyeTarget\r\n        : MacroSaccadeWaitRanges.default;\r\n      this._initializeMicroTimer(layerName, ...MicroSaccadeWaitRanges.default);\r\n      this._initializeMacroTimer(layerName, ...macroSaccadeWaitRange);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start keeping track of an animation layer that owns a blink animation. Blink\r\n   * animations can be of any type, but if it is of type randomAnimation then a\r\n   * it will be randomized each time a blink is called.\r\n   *\r\n   * @param {string} layerName - Name of the layer to keep track of.\r\n   * @param {Object=} options - Options for the layer.\r\n   * @param {string} [options.animation = 'blink'] - Name of the blink animation\r\n   * on the layer.\r\n   * @param {number} [options.blendTime=[PointOfInterestFeature.DEFAULT_LAYER_OPTIONS.blendTime]{@link PointOfInterestFeature#DEFAULT_LAYER_OPTIONS#blendTime}] -\r\n   * Default amount of time to use when manipulating the layer's weight.\r\n   * @param {Function=} options.easingFn - Default easing function to use when\r\n   * manipulating the layer's weight.\r\n   */\r\n  registerBlinkLayer(\r\n    layerName,\r\n    {\r\n      animation = 'blink',\r\n      blendTime = PointOfInterestFeature.DEFAULT_LAYER_OPTIONS.blendTime,\r\n      easingFn\r\n    } = {}\r\n  ) {\r\n    // Register the layer and animation\r\n    this.registerLayer(layerName, {\r\n      blendTime,\r\n      easingFn,\r\n      animations: { [animation]: {} },\r\n    });\r\n    this._blinkLayers[layerName] = animation;\r\n  }\r\n\r\n  update(deltaTime) {\r\n    super.update(deltaTime);\r\n\r\n    // Update the look angles\r\n    if (this._target) {\r\n      this._setLookAngles();\r\n    } else {\r\n      this._resetLookAngles();\r\n    }\r\n\r\n    const deltaSeconds = Math.min(deltaTime, MaxDelta) / 1000;\r\n    let triggerBlink = false;\r\n\r\n    // Set look blend values\r\n    Object.entries(this._lookLayers).forEach(([layerName, animName]) => {\r\n      const options = this._managedLayers[layerName];\r\n\r\n      // Increment the saccade timers\r\n      if (options.isActive && options.hasSaccade) {\r\n        options.microSaccadeTimer.execute(deltaTime);\r\n        options.macroSaccadeTimer.execute(deltaTime);\r\n      }\r\n\r\n      // Set the blend values\r\n      if (options.animations[animName].isActive) {\r\n        const currentH = this._host.AnimationFeature.getAnimationBlendWeight(\r\n          layerName, animName, 'X'\r\n        );\r\n        const currentV = this._host.AnimationFeature.getAnimationBlendWeight(\r\n          layerName, animName, 'Y'\r\n        );\r\n\r\n        let targetH = options.trackingConfig.angles.h;\r\n        let targetV = options.trackingConfig.angles.v;\r\n\r\n        // Check if the look angle has changed enough to trigger a blink\r\n        if (this._isTargetMoving && !triggerBlink) {\r\n          const prevTargetH = options.trackingConfig.prevAngles.h;\r\n          const prevTargetV = options.trackingConfig.prevAngles.v;\r\n          const changeAmount = MathUtils.toDegrees(\r\n            MathUtils.getAngleBetween(\r\n              [prevTargetH, prevTargetV],\r\n              [targetH, targetV]\r\n            )\r\n          );\r\n\r\n          if (changeAmount >= BlinkThreshold) {\r\n            triggerBlink = true;\r\n          }\r\n        }\r\n\r\n        options.trackingConfig.prevAngles.h = targetH;\r\n        options.trackingConfig.prevAngles.v = targetV;\r\n\r\n        // Add in the saccade movement\r\n        if (options.hasSaccade) {\r\n          MathUtils.dampValue(\r\n            0,\r\n            options.macroSaccade.h + options.macroSaccade.h,\r\n            options.hVelocity,\r\n            options.hDuration,\r\n            options.maxHSpeed\r\n          );\r\n          targetH += options.hVelocity[0];\r\n          MathUtils.dampValue(\r\n            0,\r\n            options.macroSaccade.v + options.macroSaccade.v,\r\n            options.vVelocity,\r\n            options.vDuration,\r\n            options.maxVSpeed\r\n          );\r\n          targetV += options.vVelocity[0];\r\n        }\r\n\r\n        // Clamp to max speed\r\n        const factor = MathUtils.clamp(deltaSeconds * options.maxSpeed, 0, 1);\r\n        targetH = MathUtils.lerp(currentH, targetH, factor);\r\n        targetV = MathUtils.lerp(currentV, targetV, factor);\r\n\r\n        // Update the blend values\r\n        this._host.AnimationFeature.setAnimationBlendWeight(\r\n          layerName,\r\n          animName,\r\n          'X',\r\n          targetH\r\n        );\r\n        this._host.AnimationFeature.setAnimationBlendWeight(\r\n          layerName,\r\n          animName,\r\n          'Y',\r\n          targetV\r\n        );\r\n      }\r\n    });\r\n\r\n    if (!triggerBlink || !this._isTargetMoving) {\r\n      return;\r\n    }\r\n\r\n    // Execute blink\r\n    Object.entries(this._blinkLayers).forEach(([layerName, animName]) => {\r\n      const animation = this._managedLayers[layerName].animations[animName];\r\n\r\n      if (animation.isActive) {\r\n        this._host.AnimationFeature.playAnimation(layerName, animName);\r\n      }\r\n    })\r\n  }\r\n\r\n  installApi() {\r\n    /**\r\n     * @inner\r\n     * @namespace PointOfInterestFeature\r\n     */\r\n    const api = super.installApi();\r\n\r\n    Object.defineProperties(api, {\r\n      /**\r\n       * @memberof PointOfInterestFeature\r\n       * @instance\r\n       * @see core/PointOfInterestFeature#target\r\n       */\r\n      target: {\r\n        get: () => this.target,\r\n        set: target => { this.target = target },\r\n      },\r\n    });\r\n\r\n    Object.assign(api, {\r\n      /**\r\n       * @memberof PointOfInterestFeature\r\n       * @instance\r\n       * @method\r\n       * @see core/PointOfInterestFeature#registerLookLayer\r\n       */\r\n      registerLookLayer: this.registerLookLayer.bind(this),\r\n      /**\r\n       * @memberof PointOfInterestFeature\r\n       * @instance\r\n       * @method\r\n       * @see core/PointOfInterestFeature#registerBlinkLayer\r\n       */\r\n      registerBlinkLayer: this.registerBlinkLayer.bind(this),\r\n      /**\r\n       * @memberof PointOfInterestFeature\r\n       * @instance\r\n       * @method\r\n       * @see core/PointOfInterestFeature#setTarget\r\n       */\r\n      setTarget: this.setTarget.bind(this),\r\n      /**\r\n       * @memberof PointOfInterestFeature\r\n       * @instance\r\n       * @method\r\n       * @see core/PointOfInterestFeature#setTargetByName\r\n       */\r\n      setTargetByName: this.setTargetByName.bind(this),\r\n      /**\r\n       * @memberof PointOfInterestFeature\r\n       * @instance\r\n       * @method\r\n       * @see core/PointOfInterestFeature#setTargetById\r\n       */\r\n      setTargetById: this.setTargetById.bind(this),\r\n    });\r\n\r\n    return api;\r\n  }\r\n}\r\n\r\nexport default PointOfInterestFeature;\r\nexport { AxisMap };","// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n// SPDX-License-Identifier: MIT-0\r\nimport Deferred from 'core/Deferred';\r\n\r\n/**\r\n * Class that can play back audio generated by AWS Polly and synchronized emit\r\n * speechmark messages.\r\n *\r\n * @abstract\r\n */\r\nclass AbstractSpeech {\r\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {core/TextToSpeechFeature} speaker - The feature that owns the Speech and\r\n   * will emit speechmark messages.\r\n   * @param {string} text - The text of the speech.\r\n   * @param {Array.<Object>} [speechmarks=[]] - An array of speechmark objects representing\r\n   * the text and timing of the speech.\r\n   */\r\n  constructor(speaker, text, speechmarks = []) {\r\n    this._speaker = speaker;\r\n    this._text = text;\r\n    this._speechmarks = speechmarks;\r\n    this._speechmarkOffset = 0;\r\n    this._reset();\r\n  }\r\n\r\n  /**\r\n   * Reset tracking properties.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {number} [currentTime=0] - Time to use for _startTime.\r\n   */\r\n  _reset(currentTime = 0) {\r\n    this._startTime = currentTime;\r\n    this._localTime = 0;\r\n    this._pauseTime = 0;\r\n    this._playing = false;\r\n    this._markIter = this._speechmarks.values();\r\n    const {value, done} = this._markIter.next();\r\n    this._currentMark = value;\r\n    this._endTime = this._speechmarks.length\r\n      ? this._speechmarks[this._speechmarks.length - 1].time\r\n      : 0;\r\n    this._done = done;\r\n    this._promise = null;\r\n  }\r\n\r\n  /**\r\n   * Create a new promise that will stop playback and emit messages for this speech.\r\n   *\r\n   * @param {Function=} onFinish - Funciton to execute once the speech stops.\r\n   * @param {onError=} onError - Function to execute if the speech encounters an\r\n   * error.\r\n   * @param {Function=} onInterrupt - Function to execute if the speech is canceled.\r\n   *\r\n   * @returns {Deferred}\r\n   *\r\n   * @private\r\n   */\r\n  _createPromise(onFinish, onError, onInterrupt) {\r\n    const onResolve = value => {\r\n      this._playing = false;\r\n\r\n      this._speaker.emit(this._speaker.constructor.EVENTS.stop, this);\r\n      this._speaker.constructor.emit(\r\n        this._speaker.constructor.EVENTS.stop,\r\n        this\r\n      );\r\n\r\n      if (typeof onFinish === 'function') {\r\n        onFinish(value);\r\n      }\r\n    };\r\n\r\n    const onReject = e => {\r\n      this._playing = false;\r\n\r\n      this._speaker.emit(this._speaker.constructor.EVENTS.stop, this);\r\n      this._speaker.constructor.emit(\r\n        this._speaker.constructor.EVENTS.stop,\r\n        this\r\n      );\r\n\r\n      console.error(\r\n        `${this.constructor.name} encountered an unexpected error: ${e}`\r\n      );\r\n\r\n      if (typeof onError === 'function') {\r\n        onError(e);\r\n      }\r\n    };\r\n\r\n    const onCancel = value => {\r\n      this._playing = false;\r\n\r\n      this._speaker.emit(this._speaker.constructor.EVENTS.interrupt, this);\r\n      this._speaker.constructor.emit(\r\n        this._speaker.constructor.EVENTS.interrupt,\r\n        this\r\n      );\r\n\r\n      if (typeof onInterrupt === 'function') {\r\n        onInterrupt(value);\r\n      }\r\n    };\r\n\r\n    this._promise = new Deferred(undefined, onResolve, onReject, onCancel);\r\n\r\n    return this._promise;\r\n  }\r\n\r\n  /**\r\n   * Return whether or not the speech has reached it's end.\r\n   *\r\n   * @private\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n  _checkFinished() {\r\n    return this._done && this._localTime >= this._endTime;\r\n  }\r\n\r\n  /**\r\n   * Gets the playback state of the audio.\r\n   *\r\n   * @readonly\r\n   * @type {boolean}\r\n   */\r\n  get playing() {\r\n    return this._playing;\r\n  }\r\n\r\n  /**\r\n   * Gets the text of the speech.\r\n   *\r\n   * @readonly\r\n   * @type {string}\r\n   */\r\n  get text() {\r\n    return this._text;\r\n  }\r\n\r\n  /**\r\n   * Gets a shallow copy of the speechmarks array for the speech.\r\n   *\r\n   * @readonly\r\n   * @type {Array.<Object>}\r\n   */\r\n  get speechmarks() {\r\n    return [...this._speechmarks];\r\n  }\r\n\r\n  /**\r\n   * Gets and sets the number of seconds to offset speechmark emission.\r\n   * @type {number}\r\n   */\r\n  get speechmarkOffset() {\r\n    return this._speechmarkOffset / 1000;\r\n  }\r\n\r\n  set speechmarkOffset(offset) {\r\n    this._speechmarkOffset = offset * 1000; // Store as milliseconds\r\n  }\r\n\r\n  /**\r\n   * Emit speechmark messages as they are encountered in sync with audio.\r\n   *\r\n   * @param {number} currentTime - Current global time when update was called.\r\n   */\r\n  update(currentTime) {\r\n    if (!this._playing) {\r\n      return;\r\n    }\r\n\r\n    // Update local audio time\r\n    this._localTime = currentTime - this._startTime;\r\n\r\n    if (!this._done) {\r\n      // Emit speechmark messages for marks up to the current time\r\n      while (\r\n        !this._done &&\r\n        this._currentMark.time + this._speechmarkOffset <= this._localTime\r\n      ) {\r\n        this._speaker.emit(\r\n          this._speaker.constructor.EVENTS[this._currentMark.type],\r\n          {\r\n            speech: this,\r\n            mark: this._currentMark,\r\n          }\r\n        );\r\n        const {value, done} = this._markIter.next();\r\n\r\n        this._currentMark = value;\r\n        this._done = done;\r\n      }\r\n    }\r\n\r\n    // End playback\r\n    if (this._checkFinished()) {\r\n      this.stop();\r\n      this._reset();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Play the speech from the beginning.\r\n   *\r\n   * @param {number} currentTime - Current global time when play was called.\r\n   * @param {Function=} onFinish - Optional function to execute once the speech\r\n   * promise resolves.\r\n   * @param {Function=} onError - Optional function to execute if the speech\r\n   * encounters and error during playback.\r\n   * @param {Function=} onInterrupt - Optional function to execute if the speech\r\n   * is canceled.\r\n   *\r\n   * @returns {Deferred} Resolves once the speech reaches the end of playback.\r\n   */\r\n  play(currentTime, onFinish, onError, onInterrupt) {\r\n    this._reset(currentTime);\r\n    this._playing = true;\r\n\r\n    this._speaker.emit(this._speaker.constructor.EVENTS.play, this);\r\n    this._speaker.constructor.emit(this._speaker.constructor.EVENTS.play, this);\r\n\r\n    return this._createPromise(onFinish, onError, onInterrupt);\r\n  }\r\n\r\n  /**\r\n   * Pause the speech at the current time.\r\n   *\r\n   * @param {number} currentTime - Current global time when pause was called.\r\n   */\r\n  pause(currentTime) {\r\n    this._playing = false;\r\n    this._pauseTime = currentTime;\r\n\r\n    this._speaker.emit(this._speaker.constructor.EVENTS.pause, this);\r\n    this._speaker.constructor.emit(\r\n      this._speaker.constructor.EVENTS.pause,\r\n      this\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Resume the speech at the current time.\r\n   *\r\n   * @param {number} currentTime - Current global time when resume was called.\r\n   * @param {Function=} onFinish - Optional function to execute once the speech\r\n   * promise resolves.\r\n   * @param {Function=} onError - Optional function to execute if the speech\r\n   * encounters and error during playback.\r\n   * @param {Function=} onInterrupt - Optional function to execute if the speech\r\n   * is canceled.\r\n   *\r\n   * @returns {Deferred} Resolves once the speech reaches the end of playback.\r\n   */\r\n  resume(currentTime, onFinish, onError, onInterrupt) {\r\n    // Play from the beginning if the speech hasn't played yet\r\n    if (!this._promise) {\r\n      this._reset(currentTime);\r\n      this._createPromise(onFinish, onError, onInterrupt);\r\n    }\r\n\r\n    this._playing = true;\r\n    this._startTime += currentTime - this._pauseTime;\r\n\r\n    this._speaker.emit(this._speaker.constructor.EVENTS.resume, this);\r\n    this._speaker.constructor.emit(\r\n      this._speaker.constructor.EVENTS.resume,\r\n      this\r\n    );\r\n\r\n    return this._promise;\r\n  }\r\n\r\n  /**\r\n   * Cancels playback of the speech at the current time. Cancel the speech promise.\r\n   */\r\n  cancel() {\r\n    if (this._promise) {\r\n      this._promise.cancel();\r\n      this._promise = null;\r\n    }\r\n\r\n    this._playing = false;\r\n  }\r\n\r\n  /**\r\n   * Stop the speech and reset time to the beginning. Resolve the speech promise.\r\n   */\r\n  stop() {\r\n    if (this._promise) {\r\n      this._promise.resolve();\r\n      this._promise = null;\r\n    }\r\n\r\n    this._playing = false;\r\n  }\r\n}\r\n\r\nexport default AbstractSpeech;\r\n","// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n// SPDX-License-Identifier: MIT-0\r\n\r\nimport Utils from 'core/Utils';\r\n\r\n/**\r\n * A collection of useful text-to-speech functions.\r\n *\r\n * @hideconstructor\r\n */\r\nclass TextToSpeechUtils {\r\n  /**\r\n   * Returns a new string with SSML marks inserted based on\r\n   * matches between the input string and the input map. The\r\n   * word matches are case-insensitive. Words within existing\r\n   * SSML tags will not be affected. Input text will be surrounded\r\n   * by <speak></speak> tags if needed.\r\n   *\r\n   * @param {string} text - Input string.\r\n   * @param {object} map - Input object that maps mark keys\r\n   * to arrays of words. Example:\r\n   *\r\n   *  {\r\n   *    'mark:sad' : ['sad', 'blue', 'down'],\r\n   *    'mark:happy' : ['joy', 'glad', 'great'],\r\n   *    'mark:no' : ['no', 'nah', 'nay', 'sure']\r\n   *  }\r\n   * @param {Array.<string>} [randomMarks = []] - If there are sentences that don't\r\n   * match any words from the map object, marks from this array will be randomly\r\n   * chosen and inserted.\r\n   *\r\n   * @returns {string} - Updated input string.\r\n   */\r\n  static autoGenerateSSMLMarks(text, map, randomMarks = []) {\r\n    if (typeof map !== 'object' || map === null) {\r\n      throw new Error(\r\n        `Cannot generate SSML marks for text \"${text}\" because map is not an object.`\r\n      );\r\n    }\r\n\r\n    // process the input map into an internal format\r\n    const internalMap = this._processInputMap(map);\r\n\r\n    const speakTags = ['<speak>', '</speak>'];\r\n    const ssmlMarkRegex = /<mark name=(?:\"|')(.*?)(?:\"|')\\/>/;\r\n    const ssmlTagRegex = /<[^>]*>/g;\r\n\r\n    // Identify any existing SSML tags\r\n    const existingTags = [];\r\n    let result = ssmlTagRegex.exec(text);\r\n\r\n    while (result !== null) {\r\n      existingTags.push({\r\n        start: result.index,\r\n        end: result.index + result[0].length,\r\n        text: result[0],\r\n      });\r\n\r\n      result = ssmlTagRegex.exec(text);\r\n    }\r\n\r\n    const chunks = [];\r\n    let index = 0;\r\n    let ssmlMarkResult;\r\n    let duplicateMarkToCheck = [];\r\n    existingTags.forEach(existingTag => {\r\n      const substr = text.slice(index, existingTag.start);\r\n\r\n      if (substr !== '') {\r\n        // auto-mark non-tag text\r\n        chunks.push(\r\n          this._insertMarks(substr, internalMap, duplicateMarkToCheck)\r\n        );\r\n\r\n        duplicateMarkToCheck = [];\r\n      }\r\n\r\n      ssmlMarkResult = ssmlMarkRegex.exec(existingTag.text);\r\n\r\n      if (ssmlMarkResult !== null) {\r\n        const markText = ssmlMarkResult[1];\r\n        duplicateMarkToCheck.push(markText);\r\n      } else if (!speakTags.includes(existingTag.text)) {\r\n        chunks.push(existingTag.text);\r\n      }\r\n\r\n      // advance the index\r\n      index = existingTag.end;\r\n    });\r\n\r\n    chunks.push(\r\n      this._insertMarks(text.slice(index), internalMap, duplicateMarkToCheck)\r\n    );\r\n\r\n    let markedText = chunks.join('');\r\n\r\n    if (randomMarks && randomMarks.length > 0) {\r\n      // add random marks to any unmarked sentences\r\n      markedText = this.addMarksToUnmarkedSentences(\r\n        markedText,\r\n        randomMarks\r\n      );\r\n    }\r\n\r\n    return TextToSpeechUtils.validateText(markedText);\r\n  }\r\n\r\n  /**\r\n   * Returns a new string with a random SSML mark inserted at each sentence that\r\n   * does not already contain an SSML mark.\r\n   *\r\n   * @param {string} text - Input string.\r\n   * @param {Array.<string>} marks - Any array of random SSML marks to choose from\r\n   * when modifying the text.\r\n   *\r\n   * @returns {string}\r\n   */\r\n  static addMarksToUnmarkedSentences(text, marks) {\r\n    if (!marks || marks.length === 0) return text;\r\n\r\n    const ssmlMarkRegex = /<mark name=(?:\"|')(.*?)(?:\"|')\\/>/g;\r\n    const ssmlTagRegex = /<[^>]*>/g;\r\n\r\n    // Find the indices of any marks in the text\r\n    const markIndices = [];\r\n    let markResult = ssmlMarkRegex.exec(text);\r\n\r\n    while (markResult !== null) {\r\n      markIndices.push(markResult.index);\r\n      markResult = ssmlMarkRegex.exec(text);\r\n    }\r\n\r\n    // Find all SSML tags in the text\r\n    const existingTags = [];\r\n    let ssmlResult = ssmlTagRegex.exec(text);\r\n    while (ssmlResult !== null) {\r\n      existingTags.push({\r\n        start: ssmlResult.index,\r\n        end: ssmlResult.index + ssmlResult[0].length,\r\n        text: ssmlResult[0],\r\n      });\r\n      ssmlResult = ssmlTagRegex.exec(text);\r\n    }\r\n\r\n    // Create a copy of the text with all SSML marks replaces with whitespace\r\n    let cleanedText = text.slice();\r\n    existingTags.forEach(existingSsml => {\r\n      const whitespace = new Array(existingSsml.text.length + 1).join(' ');\r\n      cleanedText = [\r\n        cleanedText.slice(0, existingSsml.start),\r\n        whitespace,\r\n        cleanedText.slice(existingSsml.end),\r\n      ].join('');\r\n    });\r\n\r\n    const sentenceEndIndices = this._getSentenceEnds(cleanedText);\r\n\r\n    // Only insert random marks into sentences that don't already have any\r\n    let prevIndex = 0;\r\n    const targetIndices = sentenceEndIndices.filter(index => {\r\n      const containsMark =\r\n        markIndices.findIndex(markIndex => {\r\n          return prevIndex <= markIndex && index > markIndex;\r\n        }) !== -1;\r\n      prevIndex = index;\r\n      return !containsMark;\r\n    });\r\n\r\n    const randomMarkedText = this._insertRandomMarksAt(\r\n      text,\r\n      targetIndices,\r\n      marks\r\n    );\r\n\r\n    return randomMarkedText;\r\n  }\r\n\r\n  /**\r\n   * Generate a version of given text that is enclosed by Polly ssml speak tags.\r\n   *\r\n   * @param {string} text - The text to validate.\r\n   *\r\n   * @returns {string} - Updated input string.\r\n   */\r\n  static validateText(text) {\r\n    if (!text) {\r\n      text = '<speak></speak>';\r\n    } else {\r\n      text = text\r\n        .replace(/(^\\s*<\\s*speak\\s*)>\\s*|(^\\s*)/, '<speak>')\r\n        .replace(/(\\s*<\\s*\\/\\s*speak\\s*>\\s*$|\\s*$)/, '</speak>');\r\n    }\r\n\r\n    return text;\r\n  }\r\n\r\n  /**\r\n   * Parse an input string and insert SSML marks based on\r\n   * word matches in a map.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} text - Input string.\r\n   * @param {Array.<number>} [indices = []] - An array of indices in the text input\r\n   * where random marks should be inserted.\r\n   * @param {Array.<string>} [marks = []] - An array of mark strings to choose\r\n   * from when inserting random marks.\r\n   *\r\n   * @returns {string} - Updated input string.\r\n   */\r\n  static _insertRandomMarksAt(text, indices = [], marks = []) {\r\n    if (!marks || marks.length === 0 || !indices || indices.length === 0) {\r\n      return text;\r\n    }\r\n\r\n    let offset = 0;\r\n    indices.forEach(index => {\r\n      const randomMark = `<mark name='${\r\n        marks[Utils.getRandomInt(0, marks.length)]\r\n      }'/>`;\r\n      text = [\r\n        text.slice(0, index + offset),\r\n        randomMark,\r\n        text.slice(index + offset),\r\n      ].join('');\r\n      offset += randomMark.length;\r\n    });\r\n\r\n    return text;\r\n  }\r\n\r\n  /**\r\n   * Parses a string of text and returns an array containing the indices\r\n   * of the last character in a sentence that is not in the following list:\r\n   *  ('.', '?', '!')\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} text - Text to process for end of sentence\r\n   * indices.\r\n   *\r\n   * @returns {Array.<number>} - Array of end of sentence indices.\r\n   */\r\n  static _getSentenceEnds(text) {\r\n    const sentenceRegex = /[^.!?]+[.!?]+/g;\r\n    const endSentenceRegex = /[.!?]+/;\r\n\r\n    let result = sentenceRegex.exec(text);\r\n    const sentenceEnds = [];\r\n    while (result !== null) {\r\n      // find the last non-punctuation character\r\n      const punctResult = endSentenceRegex.exec(result[0]);\r\n      sentenceEnds.push(\r\n        result.index + result[0].length - punctResult[0].length\r\n      );\r\n      result = sentenceRegex.exec(text);\r\n    }\r\n\r\n    return sentenceEnds;\r\n  }\r\n\r\n  /**\r\n   * Parse an input string and insert SSML marks based on\r\n   * word matches in a map.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} text - Input string.\r\n   * @param {Map} map - Mapping of words to mark values that\r\n   * will be inserted as the value for a mark's 'name' attribute.\r\n   * @param {Array} duplicatesToCheck - A list of mark values to check for duplicate against the first word\r\n   *\r\n   * @returns {string} - Updated input string.\r\n   */\r\n  static _insertMarks(text, map, duplicatesToCheck) {\r\n    if (text === '') return text;\r\n\r\n    const wordRegex = /\\w+|\\s+|[^\\s\\w]+/g;\r\n\r\n    let lowerCaseWord;\r\n    let checkDuplicate = true;\r\n    const markedWords = text.match(wordRegex).map(word => {\r\n      lowerCaseWord = word.toLowerCase();\r\n\r\n      if (map.has(lowerCaseWord)) {\r\n        const marks = map.get(lowerCaseWord).map(mark => {\r\n          if (checkDuplicate) {\r\n            checkDuplicate = false;\r\n            return duplicatesToCheck.includes(mark)\r\n              ? ''\r\n              : `<mark name='${mark}'/>`;\r\n          } else {\r\n            return `<mark name='${mark}'/>`;\r\n          }\r\n        });\r\n        return `${marks.join('')}${word}`;\r\n      } else {\r\n        checkDuplicate = false;\r\n        return word;\r\n      }\r\n    });\r\n\r\n    const existingMarks = duplicatesToCheck.map(mark => {\r\n      return `<mark name='${mark}'/>`;\r\n    });\r\n\r\n    return `${existingMarks.join('')}${markedWords.join('')}`;\r\n  }\r\n\r\n  /**\r\n   * Processes an input object for mapping an array\r\n   * of words to specific mark keys. Converts the input\r\n   * map into a Map with a more efficient format for\r\n   * performing mark injection.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {object} map - Input object that maps mark keys\r\n   * to arrays of words.\r\n   *\r\n   * @returns {Map} - Map for internal use.\r\n   */\r\n  static _processInputMap(map) {\r\n    const internalMap = new Map();\r\n\r\n    let list = [];\r\n    Object.entries(map).forEach(([key, value]) => {\r\n      if (!Array.isArray(value)) {\r\n        throw new Error(\r\n          `Cannot generate SSML marks from map \"${map}\" because value for key '${key}' is not an array.`\r\n        );\r\n      }\r\n\r\n      value.forEach(word => {\r\n        const lowerCaseWord = word.toLowerCase();\r\n        list = internalMap.get(lowerCaseWord);\r\n\r\n        if (list !== undefined && !list.includes(key)) {\r\n          internalMap.set(lowerCaseWord, [...list, key]);\r\n        } else {\r\n          internalMap.set(lowerCaseWord, [key]);\r\n        }\r\n      });\r\n    });\r\n\r\n    return internalMap;\r\n  }\r\n}\r\n\r\nexport default TextToSpeechUtils;\r\n","// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n// SPDX-License-Identifier: MIT-0\r\nimport AbstractHostFeature from 'core/AbstractHostFeature';\r\nimport AnimationUtils from 'core/animpack/AnimationUtils';\r\nimport MathUtils from 'core/MathUtils';\r\nimport Deferred from 'core/Deferred';\r\nimport Speech from './AbstractSpeech';\r\nimport TextToSpeechUtils from './TextToSpeechUtils';\r\n\r\n/**\r\n * The Amazon Polly service object.\r\n * @external Polly\r\n * @see https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/Polly.html\r\n */\r\n\r\n/**\r\n * The presigner object that can be used to generate presigned urls for the Polly service.\r\n * @external Presigner\r\n * @see https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/Polly/Presigner.html\r\n */\r\n\r\n// Available options for Polly\r\nconst engines = ['standard', 'neural'];\r\nconst audioFormats = ['mp3', 'ogg_vorbis', 'pcm'];\r\nconst speechmarkTypes = ['sentence', 'ssml', 'viseme', 'word'];\r\nconst sampleRates = {\r\n  mp3: {\r\n    rates: ['8000', '16000', '22050', '24000'],\r\n    defaults: {\r\n      standard: '2050',\r\n      neural: '2400',\r\n    },\r\n  },\r\n  pcm: {\r\n    rates: ['8000', '16000'],\r\n    defaults: {\r\n      standard: '1600',\r\n      neural: '1600',\r\n    },\r\n  },\r\n};\r\nsampleRates.ogg_vorbis = sampleRates.mp3;\r\nlet awsVersion;\r\n\r\n/**\r\n * Base class for turning text input into playable audio. There should be one instance\r\n * per speaker, each instance can play only one piece of text at a time.\r\n *\r\n * @extends AbstractHostFeature\r\n * @abstract\r\n *\r\n * @property {(number|undefined)} AWS_VERSION - Gets the version of AWS SDK being\r\n * used. Will be undefined until [initializeService]{@link AbstractTextToSpeechFeature.initializeService}\r\n * has been successfully executed.\r\n * @property {string} [POLLY_MIN_NEURAL_VERSION='2.503'] - Gets the minimum version\r\n * of the AWS SDK that is necessary to use neural voices with AWS Polly.\r\n * @property {Object} POLLY_DEFAULTS - Default values to use with calls to {@link external:Polly}.\r\n * @property {string} [POLLY_DEFAULTS.Engine='standard']\r\n * @property {Array.<string>} [POLLY_DEFAULTS.LexiconNames=[]]\r\n * @property {string} [POLLY_DEFAULTS.OutputFormat='mp3']\r\n * @property {string} [POLLY_DEFAULTS.SampleRate='22050']\r\n * @property {string} [POLLY_DEFAULTS.Text='']\r\n * @property {string} [POLLY_DEFAULTS.TextType='ssml']\r\n * @property {string} [POLLY_DEFAULTS.VoiceId='Amy']\r\n * @property {string} [POLLY_DEFAULTS.LanguageCode='en-GB']\r\n * @property {string} [POLLY_DEFAULTS.LanguageName='British English']\r\n * @property {Array.<string>} [POLLY_VOICES=[]] - An array of voices available in\r\n * Polly. Will be empty until [initializeService]{@link AbstractTextToSpeechFeature.initializeService}\r\n * has been successfully executed. See [Polly Documentation]{@link https://docs.aws.amazon.com/polly/latest/dg/voicelist.html}\r\n * for a full list of available voices.\r\n * @property {Object} [POLLY_LANGUAGES={}] - An object that maps language names\r\n * to language codes that are available in Polly. Will be empty until\r\n * [initializeService]{@link AbstractTextToSpeechFeature.initializeService}\r\n * has been successfully executed. See [Polly Documentation]{@link https://docs.aws.amazon.com/polly/latest/dg/SupportedLanguage.html}\r\n * for a full list of available languages and corresponding codes.\r\n * @property {Object} [POLLY_LANGUAGE_CODES={}] - An object that maps language codes\r\n * to language names that are available in Polly. Will be empty until\r\n * [initializeService]{@link AbstractTextToSpeechFeature.initializeService}\r\n * has been successfully executed. See [Polly Documentation]{@link https://docs.aws.amazon.com/polly/latest/dg/SupportedLanguage.html}\r\n * for a full list of available languages and corresponding codes.\r\n * @property {Object} EVENTS - Built-in messages that the feature emits. When the\r\n * feature is added to a {@link core/HostObject}, event names will be prefixed by the\r\n * name of the feature class + '.'.\r\n * @property {string} [EVENTS.ready=onReadyEvent] - Message that is emitted after\r\n * [initializeService]{@link AbstractTextToSpeechFeature.initializeService} has been\r\n * successfully executed.\r\n * @property {string} [EVENTS.play=onPlayEvent] - Message that is emitted after\r\n * each call to [play]{@link AbstractTextToSpeechFeature#play}. The speech that was played\r\n * is supplied as an argument to listener functions.\r\n * @property {string} [EVENTS.pause=onPauseEvent] - Message that is emitted after\r\n * each call to [pause]{@link AbstractTextToSpeechFeature#pause}. The speech that was paused\r\n * is supplied as an argument to listener functions.\r\n * @property {string} [EVENTS.resume=onResumeEvent] - Message that is emitted after\r\n * each call to [resume]{@link AbstractTextToSpeechFeature#resume}. The speech that was\r\n * resumed is supplied as an argument to listener functions.\r\n * @property {string} [EVENTS.interrupt=onInterruptEvent] - Message that is emitted\r\n * if there is a current speech in progress and [play]{@link AbstractTextToSpeechFeature#play}\r\n * or [resume]{@link AbstractTextToSpeechFeature#resume} are executed for a new speech.\r\n * The speech that was interrupted is supplied as an argument to listener functions.\r\n * @property {string} [EVENTS.stop=onStopEvent] - Message that is emitted after\r\n * each call to [stop]{@link AbstractTextToSpeechFeature#stop} and when a speech reaches\r\n * the end of playback. The speech that was stopped is supplied as an argument\r\n * to listener functions.\r\n * @property {string} [EVENTS.sentence=onSentenceEvent] - Message that is emitted\r\n * each time a sentence speechmark is encountered whose timestamp matches up with\r\n * the speech audio's current time. The sentence speechmark object is supplied as\r\n * an argument to listener functions.\r\n * @property {string} [EVENTS.word=onWordEvent] - Message that is emitted\r\n * each time a word speechmark is encountered whose timestamp matches up with\r\n * the speech audio's current time. The word speechmark object is supplied as\r\n * an argument to listener functions.\r\n * @property {string} [EVENTS.viseme=onVisemeEvent] - Message that is emitted\r\n * each time a viseme speechmark is encountered whose timestamp matches up with\r\n * the speech audio's current time. The viseme speechmark object is supplied as\r\n * an argument to listener functions.\r\n * @property {string} [EVENTS.ssml=onSsmlEvent] - Message that is emitted\r\n * each time a ssml speechmark is encountered whose timestamp matches up with\r\n * the speech audio's current time. The ssml speechmark object is supplied as\r\n * an argument to listener functions.\r\n * @property {Object} SERVICES - AWS services that are necessary for the feature\r\n * to function.\r\n * @property {external:Polly} SERVICES.polly - The Polly service that is used\r\n * to synthesize speechmarks. Will be undefined until [initializeService]{@link AbstractTextToSpeechFeature.initializeService}\r\n * has been successfully executed\r\n * @property {external:Presigner} SERVICES.presigner - The Polly Presigner\r\n * object that is used to synthesize speech audio. Will be undefined until\r\n * [initializeService]{@link AbstractTextToSpeechFeature.initializeService}\r\n * has been successfully executed.\r\n */\r\nclass AbstractTextToSpeechFeature extends AbstractHostFeature {\r\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {core/HostObject} host - Host object managing the feature.\r\n   * @param {Object=} options - Options that will be sent to Polly for each speech.\r\n   * @param {string=} options.voice - The name of the Polly voice to use for all speech.\r\n   * @param {string=} options.engine - The name of the Polly engine to use for all speech.\r\n   * @param {string=} options.language - The name of the language to use for all speech.\r\n   * @param {audioFormat} [options.audioFormat='mp3'] - The format to use for generated\r\n   * audio for all speeches.\r\n   * @param {string=} options.sampleRate - The sample rate for audio files for all\r\n   * speeches.\r\n   * @param {number} [options.speechmarkOffset=0] - Amount of time in seconds to\r\n   * offset speechmark event emission from the audio.\r\n   * @param {number} [options.minEndMarkDuration=.05] - The minimum amount of time\r\n   * in seconds that the last speechmark of each type in a speech can have its\r\n   * duration property set to.\r\n   * @param {number} [options.volume=1] - The default volume to play speech audio\r\n   * with.\r\n   * @param {boolean} [options.isGlobal=false] - Whether the audio source should default\r\n   * to global regardless of whether or not it is attached to an object.\r\n   */\r\n  constructor(\r\n    host,\r\n    options = {\r\n      voice: undefined,\r\n      engine: undefined,\r\n      language: undefined,\r\n      audioFormat: 'mp3',\r\n      sampleRate: undefined,\r\n      speechmarkOffset: 0,\r\n      minEndMarkDuration: 0.05,\r\n      volume: 1,\r\n      isGlobal: false,\r\n    }\r\n  ) {\r\n    super(host);\r\n\r\n    this._speechCache = {};\r\n    this._currentSpeech = null;\r\n    this._currentPromise = null;\r\n    this._isValidated = false;\r\n    this.speechmarkOffset = Number.isNaN(Number(options.speechmarkOffset))\r\n      ? 0\r\n      : Number(options.speechmarkOffset);\r\n    this.minEndMarkDuration = Number.isNaN(Number(options.minEndMarkDuration))\r\n      ? 0\r\n      : Number(options.minEndMarkDuration);\r\n    this.volume = Number.isNaN(Number(options.volume))\r\n      ? 1\r\n      : Number(options.volume);\r\n    this._isGlobal = options.isGlobal || false;\r\n    this._promises = {\r\n      volume: Deferred.resolve(),\r\n    };\r\n    this._volumePaused = false;\r\n\r\n    // Set default options for each speech\r\n    this._voice = options.voice || this.constructor.POLLY_DEFAULTS.VoiceId;\r\n    this._language =\r\n      options.language || this.constructor.POLLY_DEFAULTS.LanguageName;\r\n    this._engine = engines.includes(options.engine)\r\n      ? options.engine\r\n      : this.constructor.POLLY_DEFAULTS.Engine;\r\n    this._audioFormat = audioFormats.includes(options.audioFormat)\r\n      ? options.audioFormat\r\n      : this.constructor.POLLY_DEFAULTS.OutputFormat;\r\n    this._sampleRate = sampleRates[this._audioFormat].rates.includes(\r\n      options.sampleRate\r\n    )\r\n      ? options.sampleRate\r\n      : this.constructor.POLLY_DEFAULTS.SampleRate;\r\n  }\r\n\r\n  /**\r\n   * Store Polly, Presigner and AWS SDK Version for use across all instances.\r\n   *\r\n   * @param {external:Polly} polly - Polly instance to use to generate speechmarks.\r\n   * @param {external:Presigner} presigner - Presigner instance to use to generate\r\n   * audio URLs.\r\n   * @param {string} version - Version of the AWS SDK to use to validate voice options.\r\n   */\r\n  static initializeService(polly, presigner, version) {\r\n    // Make sure all were defined\r\n    if (\r\n      polly === undefined ||\r\n      presigner === undefined ||\r\n      version === undefined\r\n    ) {\r\n      throw new Error(\r\n        'Cannot initialize TextToSpeech feature. All arguments must be defined.'\r\n      );\r\n    }\r\n\r\n    // Add sumerian hosts user-agent\r\n    if (polly.config) {\r\n      polly.config.customUserAgent = this._withCustomUserAgent(\r\n        polly.config.customUserAgent\r\n      );\r\n    }\r\n    if (presigner.service && presigner.service.config) {\r\n      presigner.service.config.customUserAgent = this._withCustomUserAgent(\r\n        presigner.service.config.customUserAgent\r\n      );\r\n    }\r\n\r\n    this._isReady = false;\r\n\r\n    // Store parameters\r\n    this.SERVICES.polly = polly;\r\n    this.SERVICES.presigner = presigner;\r\n    awsVersion = version;\r\n\r\n    // Clear the current polly objects\r\n    const availableVoices = this.POLLY_VOICES;\r\n    availableVoices.length = 0;\r\n\r\n    const availableLanguages = this.POLLY_LANGUAGES;\r\n    Object.keys(availableLanguages).forEach(name => {\r\n      delete availableLanguages[name];\r\n    });\r\n\r\n    const availableLanguageCodes = this.POLLY_LANGUAGE_CODES;\r\n    Object.keys(availableLanguageCodes).forEach(name => {\r\n      delete availableLanguageCodes[name];\r\n    });\r\n\r\n    // Re-populate according to version\r\n    const minNeuralSdk = this.POLLY_MIN_NEURAL_VERSION;\r\n\r\n    return this.SERVICES.polly\r\n      .describeVoices()\r\n      .promise()\r\n      .then(response => {\r\n        const allCodes = {};\r\n\r\n        response.Voices.forEach(voice => {\r\n          if (\r\n            voice.SupportedEngines.includes('standard') ||\r\n            version >= minNeuralSdk\r\n          ) {\r\n            availableVoices.push(voice);\r\n          }\r\n\r\n          availableVoices.forEach(voice => {\r\n            availableLanguages[voice.LanguageName] = voice.LanguageCode;\r\n            allCodes[voice.LanguageCode] = voice.LanguageName;\r\n          });\r\n        });\r\n\r\n        Object.entries(availableLanguages).forEach(([name, code]) => {\r\n          availableLanguageCodes[code] = name;\r\n        });\r\n\r\n        // Notify that we're ready to generate speeches\r\n        this._isReady = true;\r\n        this.emit(this.EVENTS.ready);\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Indicates whether or not the class is capable of generating speech audio. Polly,\r\n   * Presigner and AWS SDK version number must have been defined using\r\n   * [initializeService]{@link AbstractTextToSpeechFeature.initializeService}.\r\n   *\r\n   * @readonly\r\n   * @type {boolean}\r\n   */\r\n  static get isReady() {\r\n    return this._isReady;\r\n  }\r\n\r\n  /**\r\n   * Gets the text of the currently playing speech.\r\n   *\r\n   * @readonly\r\n   * @type {string}\r\n   */\r\n  get currentSpeech() {\r\n    if (this._currentSpeech) {\r\n      return this._currentSpeech.text;\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets and sets the number of seconds to offset speechmark emission.\r\n   *\r\n   * @type {number}\r\n   */\r\n  get speechmarkOffset() {\r\n    return this._speechmarkOffset;\r\n  }\r\n\r\n  set speechmarkOffset(offset) {\r\n    this._speechmarkOffset = offset;\r\n\r\n    if (this._currentSpeech) {\r\n      this._currentSpeech.speechmarkOffset = offset;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets and sets the The minimum amount of time in seconds that the last\r\n   * speechmark of each type in a speech can have its duration property set to.\r\n   *\r\n   * @type number\r\n   */\r\n  get minEndMarkDuration() {\r\n    return this._minEndMarkDuration / 1000;\r\n  }\r\n\r\n  set minEndMarkDuration(duration) {\r\n    this._minEndMarkDuration = duration * 1000;\r\n  }\r\n\r\n  /**\r\n   * Appends the Sumerian Hosts custom user-agent to a string if it is not\r\n   * already present.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} currentUserAgent - String to append to if needed.\r\n   *\r\n   * @returns {string}\r\n   */\r\n  static _withCustomUserAgent(currentUserAgent) {\r\n    const sumerianHostsUserAgent = 'request-source/SumerianHosts';\r\n\r\n    if (currentUserAgent == null) {\r\n      return sumerianHostsUserAgent;\r\n    }\r\n\r\n    if (currentUserAgent.indexOf(sumerianHostsUserAgent) !== -1) {\r\n      return currentUserAgent;\r\n    }\r\n\r\n    return currentUserAgent.concat(' ', sumerianHostsUserAgent);\r\n  }\r\n\r\n  /**\r\n   * Checks if a given engine type is compatible with the AWS SDK version. If it\r\n   * is, return the original value. Otherwise return a default.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} engine - The type of Polly voice engine to validate.\r\n   *\r\n   * @returns {string}\r\n   */\r\n  _validateEngine(engine) {\r\n    // Default to the standard engine if neural is not available for this version\r\n    if (\r\n      engine === undefined ||\r\n      this.constructor.AWS_VERSION < this.constructor.POLLY_MIN_NEURAL_VERSION\r\n    ) {\r\n      engine = this.constructor.POLLY_DEFAULTS.Engine;\r\n    }\r\n\r\n    return engine;\r\n  }\r\n\r\n  /**\r\n   * Checks if a given audio format type is compatible with Polly. If it is, return\r\n   * the original value. Otherwise return a default.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} engine - The type of Polly voice engine to validate.\r\n   *\r\n   * @returns {string}\r\n   */\r\n  _validateFormat(format) {\r\n    if (format === undefined || !audioFormats.includes(format)) {\r\n      format = this.constructor.POLLY_DEFAULTS.OutputFormat;\r\n    }\r\n\r\n    return format;\r\n  }\r\n\r\n  /**\r\n   * Checks if a given audio sampling rate is compatible with the current audio\r\n   * format. If it is, return the original value. Otherwise return a default.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} engine - The type of Polly voice engine to validate.\r\n   *\r\n   * @returns {string}\r\n   */\r\n  _validateRate(rate) {\r\n    // Use default if specified sample rate is not valid for the audio format\r\n    if (\r\n      rate === undefined ||\r\n      !sampleRates[this._audioFormat].rates.includes(rate)\r\n    ) {\r\n      rate = sampleRates[this._audioFormat].defaults[this._engine];\r\n    }\r\n\r\n    return rate;\r\n  }\r\n\r\n  /**\r\n   * Checks if a given Polly voice id is compatible with the current Polly engine.\r\n   * If it is, return the original value. Otherwise return a default.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} engine - The type of Polly voice engine to validate.\r\n   *\r\n   * @returns {string}\r\n   */\r\n  _validateVoice(voiceId) {\r\n    const voice = this.constructor.POLLY_VOICES.find(v => v.Id === voiceId);\r\n\r\n    // Use the default voice if the voice isn't supported by the engine\r\n    if (voice === undefined || !voice.SupportedEngines.includes(this._engine)) {\r\n      voiceId = this.constructor.POLLY_DEFAULTS.VoiceId;\r\n    }\r\n\r\n    return voiceId;\r\n  }\r\n\r\n  /**\r\n   * Checks if a given Polly language is compatible with the current Polly voice.\r\n   * If it is, return the original value. Otherwise return a default.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} engine - The type of Polly voice engine to validate.\r\n   *\r\n   * @returns {string}\r\n   */\r\n  _validateLanguage(language) {\r\n    const voice = this.constructor.POLLY_VOICES.find(v => v.Id === this._voice);\r\n    const languageCode = this.constructor.POLLY_LANGUAGES[language];\r\n\r\n    // Find the languages available for the current voice\r\n    const availableCodes = [voice.LanguageCode];\r\n    if (voice.AdditionalLanguageCodes) {\r\n      availableCodes.push(...voice.AdditionalLanguageCodes);\r\n    }\r\n\r\n    // If the current voice doesn't support the language, use its default\r\n    if (!availableCodes.includes(languageCode)) {\r\n      language = this.constructor.POLLY_LANGUAGE_CODES[voice.LanguageCode];\r\n    }\r\n\r\n    return language;\r\n  }\r\n\r\n  /**\r\n   * Validate the current Polly options to make sure they are compatible with each\r\n   * other.\r\n   *\r\n   * @private\r\n   */\r\n  _validate() {\r\n    // Validate speech parameters\r\n    this._engine = this._validateEngine(this._engine);\r\n    this._audioFormat = this._validateFormat(this._audioFormat);\r\n    this._sampleRate = this._validateRate(this._sampleRate);\r\n    this._voice = this._validateVoice(this._voice);\r\n    this._language = this._validateLanguage(this._language);\r\n    this._isValidated = true;\r\n  }\r\n\r\n  /**\r\n   * Return an object containing parameters compatible with Polly.synthesizeSpeech.\r\n   *\r\n   * @private\r\n   *\r\n   * @returns {Object}\r\n   */\r\n  _getConfig() {\r\n    // Make sure parameters have been validated\r\n    if (this.constructor.isReady && !this._isValidated) {\r\n      this._validate();\r\n    }\r\n\r\n    // Create a config object compatible with Polly\r\n    return {\r\n      Engine: this._engine,\r\n      OutputFormat: this._audioFormat,\r\n      SampleRate: this._sampleRate,\r\n      VoiceId: this._voice,\r\n      LanguageCode: this.constructor.POLLY_LANGUAGES[this._language],\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Update Polly parameters with options from a given config. All stored speeches\r\n   * will be updated to use the new parameters, unless the speech text is contained\r\n   * in the 'skipSpeeches' parameter.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {Object} config - Polly parameter options to overwrite.\r\n   * @param {Array.<string>} skipSpeeches - Text of any speeches that should not\r\n   * have parameters updated.\r\n   *\r\n   * @returns {Object}\r\n   */\r\n  _updateConfig(config, skipSpeeches = []) {\r\n    const currentConfig = this._getConfig();\r\n    if (!config) {\r\n      return currentConfig;\r\n    }\r\n\r\n    this._isValidated = false;\r\n    const currentConfigStr = JSON.stringify(currentConfig);\r\n\r\n    // Update options\r\n    if (config.Engine) {\r\n      this._engine = config.Engine;\r\n    }\r\n\r\n    if (config.audioFormat) {\r\n      this._audioFormat = config.audioFormat;\r\n    }\r\n\r\n    if (config.SampleRate) {\r\n      this._sampleRate = config.SampleRate;\r\n    }\r\n\r\n    if (config.VoiceId) {\r\n      this._voice = config.VoiceId;\r\n    }\r\n\r\n    if (config.Language) {\r\n      this._language = config.Language;\r\n    }\r\n\r\n    // Validate the config\r\n    const validConfig = this._getConfig();\r\n\r\n    // Exit if nothing has changed\r\n    const configStr = JSON.stringify(validConfig);\r\n    if (currentConfigStr === configStr) {\r\n      this._isValidated = true;\r\n      return validConfig;\r\n    }\r\n\r\n    // Update all cached configs\r\n    Object.entries(this._speechCache).forEach(([text, speech]) => {\r\n      // Check if this is a skipped speech\r\n      if (skipSpeeches.includes(text)) {\r\n        return;\r\n      }\r\n\r\n      const speechConfigStr = JSON.stringify(speech.config);\r\n\r\n      // Update the speech with new parameters\r\n      if (speechConfigStr !== configStr) {\r\n        this._updateSpeech(text, validConfig);\r\n      }\r\n    });\r\n\r\n    return validConfig;\r\n  }\r\n\r\n  /**\r\n   * Update an existing speech, or add a new speech with new Polly parameters with\r\n   * options from a given config.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} text - The text of the speech to update.\r\n   * @param {Object} config - Polly parameter options to update.\r\n   * @param {boolean} [force=false] - Whether to force the speech to be updated\r\n   * if no parameters have changes.\r\n   *\r\n   * @returns {AbstractSpeech}\r\n   */\r\n  _updateSpeech(text, config, force = false) {\r\n    const speech = this._speechCache[text] || {};\r\n    // Exit if nothing has changed and force is false\r\n    if (\r\n      !force &&\r\n      config !== undefined &&\r\n      speech.config &&\r\n      JSON.stringify(config) === JSON.stringify(speech.config)\r\n    ) {\r\n      return speech;\r\n    }\r\n\r\n    // Create separate parameters for audio and speechmark generation\r\n    const audioParams = {\r\n      ...config,\r\n      Text: text,\r\n      TextType: 'ssml',\r\n    };\r\n    const speechmarkParams = {\r\n      ...audioParams,\r\n      OutputFormat: 'json',\r\n      SpeechMarkTypes: speechmarkTypes,\r\n    };\r\n\r\n    // Generate audio and speechmarks\r\n    speech.config = config;\r\n    speech.promise = Promise.all([\r\n      this._synthesizeSpeechmarks(speechmarkParams),\r\n      this._synthesizeAudio(audioParams),\r\n    ]).then(results => {\r\n      return this._createSpeech(text, ...results);\r\n    });\r\n    this._speechCache[text] = speech;\r\n\r\n    return speech;\r\n  }\r\n\r\n  /**\r\n   * Create a new Speech object for the speaker.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {TextToSpeech} speaker - The TextToSpeech instance that will own the speech.\r\n   * @param {string} text - Text of the speech.\r\n   * @param {Object} speechmarks - Speechmarks for the speech.\r\n   * @param {Object} audioConfig - Audio for the speech.\r\n   *\r\n   * @returns {AbstractSpeech}\r\n   */\r\n  _createSpeech(text, speechmarks, audioConfig) {\r\n    return new Speech(this, text, speechmarks, audioConfig);\r\n  }\r\n\r\n  /**\r\n   * Create presigned URL of speech audio for the given speech text.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {Object} params - Parameters object compatible with Polly.synthesizeSpeech.\r\n   *\r\n   * @returns {Deferred} Resolves with an object containing the audio URL.\r\n   */\r\n  _synthesizeAudio(params) {\r\n    return new Deferred((resolve, reject) => {\r\n      this.constructor.SERVICES.presigner.getSynthesizeSpeechUrl(\r\n        params,\r\n        function(error, url) {\r\n          if (!error) {\r\n            resolve({url});\r\n          } else {\r\n            reject(error);\r\n          }\r\n        }\r\n      );\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Retrieves and parses speechmarks for the given speech text.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {Object} params - Parameters object compatible with Polly.synthesizeSpeech.\r\n   *\r\n   * @returns {Deferred} Resolves with an array of speechmark objects\r\n   */\r\n  _synthesizeSpeechmarks(params) {\r\n    return this.constructor.SERVICES.polly\r\n      .synthesizeSpeech(params)\r\n      .promise()\r\n      .then(result => {\r\n        // Convert charcodes to string\r\n        const jsonString = JSON.stringify(result.AudioStream);\r\n        const json = JSON.parse(jsonString);\r\n        const dataStr = json.data.map(c => String.fromCharCode(c)).join('');\r\n\r\n        const markTypes = {\r\n          sentence: [],\r\n          word: [],\r\n          viseme: [],\r\n          ssml: [],\r\n        };\r\n        const endMarkTypes = {\r\n          sentence: null,\r\n          word: null,\r\n          viseme: null,\r\n          ssml: null,\r\n        };\r\n\r\n        // Split by enclosing {} to create speechmark objects\r\n        const speechMarks = [...dataStr.matchAll(/\\{.*?\\}(?=\\n|$)/gm)].map(\r\n          match => {\r\n            const mark = JSON.parse(match[0]);\r\n\r\n            // Set the duration of the last speechmark stored matching this one's type\r\n            const numMarks = markTypes[mark.type].length;\r\n            if (numMarks > 0) {\r\n              const lastMark = markTypes[mark.type][numMarks - 1];\r\n              lastMark.duration = mark.time - lastMark.time;\r\n            }\r\n\r\n            markTypes[mark.type].push(mark);\r\n            endMarkTypes[mark.type] = mark;\r\n            return mark;\r\n          }\r\n        );\r\n\r\n        // Find the time of the latest speechmark\r\n        const endTimes = [];\r\n        if (endMarkTypes.sentence) {\r\n          endTimes.push(endMarkTypes.sentence.time);\r\n        }\r\n        if (endMarkTypes.word) {\r\n          endTimes.push(endMarkTypes.word.time);\r\n        }\r\n        if (endMarkTypes.viseme) {\r\n          endTimes.push(endMarkTypes.viseme.time);\r\n        }\r\n        if (endMarkTypes.ssml) {\r\n          endTimes.push(endMarkTypes.ssml.time);\r\n        }\r\n        const endTime = Math.max(...endTimes);\r\n\r\n        // Calculate duration for the ending speechMarks of each type\r\n        if (endMarkTypes.sentence) {\r\n          endMarkTypes.sentence.duration = Math.max(\r\n            this._minEndMarkDuration,\r\n            endTime - endMarkTypes.sentence.time\r\n          );\r\n        }\r\n        if (endMarkTypes.word) {\r\n          endMarkTypes.word.duration = Math.max(\r\n            this._minEndMarkDuration,\r\n            endTime - endMarkTypes.word.time\r\n          );\r\n        }\r\n        if (endMarkTypes.viseme) {\r\n          endMarkTypes.viseme.duration = Math.max(\r\n            this._minEndMarkDuration,\r\n            endTime - endMarkTypes.viseme.time\r\n          );\r\n        }\r\n        if (endMarkTypes.ssml) {\r\n          endMarkTypes.ssml.duration = Math.max(\r\n            this._minEndMarkDuration,\r\n            endTime - endMarkTypes.ssml.time\r\n          );\r\n        }\r\n\r\n        return speechMarks;\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Returns a Speech object that has the given text.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} text - The text content of the Speech.\r\n   * @param {Object=} config - Options to update the Speech with.\r\n   *\r\n   * @returns {Deferred} Resolves with Speech or null;\r\n   */\r\n  _getSpeech(text, config) {\r\n    // Make sure AWS services exist\r\n    if (!this.constructor.isReady) {\r\n      const e = 'AWS services have not been initialized.';\r\n      return Deferred.reject(e);\r\n    }\r\n\r\n    // Make sure its possible to generate speeches\r\n    if (!text) {\r\n      const e = 'Cannot play a speech with no text.';\r\n      return Deferred.reject(e);\r\n    }\r\n\r\n    // Update the speech with options\r\n    text = TextToSpeechUtils.validateText(text);\r\n    config = this._updateConfig(config, text);\r\n\r\n    return this._updateSpeech(text, config).promise;\r\n  }\r\n\r\n  /**\r\n   * Adds a namespace to the host with the name of the feature to contain properties\r\n   * and methods from the feature that users of the host need access to.\r\n   *\r\n   * @see TextToSpeechFeature\r\n   */\r\n  installApi() {\r\n    /**\r\n     * @inner\r\n     * @namespace TextToSpeechFeature\r\n     */\r\n    const api = super.installApi();\r\n\r\n    Object.assign(api, {\r\n      /**\r\n       * @memberof TextToSpeechFeature\r\n       * @instance\r\n       * @method\r\n       * @see AbstractTextToSpeechFeature#play\r\n       */\r\n      play: this.play.bind(this),\r\n      /**\r\n       * @memberof TextToSpeechFeature\r\n       * @instance\r\n       * @method\r\n       * @see AbstractTextToSpeechFeature#pause\r\n       */\r\n      pause: this.pause.bind(this),\r\n      /**\r\n       * @memberof TextToSpeechFeature\r\n       * @instance\r\n       * @method\r\n       * @see AbstractTextToSpeechFeature#resume\r\n       */\r\n      resume: this.resume.bind(this),\r\n      /**\r\n       * @memberof TextToSpeechFeature\r\n       * @instance\r\n       * @method\r\n       * @see AbstractTextToSpeechFeature#stop\r\n       */\r\n      stop: this.stop.bind(this),\r\n      /**\r\n       * @memberof TextToSpeechFeature\r\n       * @instance\r\n       * @method\r\n       * @see AbstractTextToSpeechFeature#getVolume\r\n       */\r\n      getVolume: this.getVolume.bind(this),\r\n      /**\r\n       * @memberof TextToSpeechFeature\r\n       * @instance\r\n       * @method\r\n       * @see AbstractTextToSpeechFeature#setVolume\r\n       */\r\n      setVolume: this.setVolume.bind(this),\r\n      /**\r\n       * @memberof TextToSpeechFeature\r\n       * @instance\r\n       * @method\r\n       * @see AbstractTextToSpeechFeature#pauseVolume\r\n       */\r\n      pauseVolume: this.pauseVolume.bind(this),\r\n      /**\r\n       * @memberof TextToSpeechFeature\r\n       * @instance\r\n       * @method\r\n       * @see AbstractTextToSpeechFeature#resumeVolume\r\n       */\r\n      resumeVolume: this.resumeVolume.bind(this),\r\n    });\r\n\r\n    Object.defineProperties(api, {\r\n      /**\r\n       * @memberof TextToSpeechFeature\r\n       * @instance\r\n       * @see AbstractTextToSpeechFeature#speechmarkOffset\r\n       */\r\n      speechmarkOffset: {\r\n        get: () => this.speechmarkOffset,\r\n        set: offset => {\r\n          this.speechmarkOffset = offset;\r\n        },\r\n      },\r\n    });\r\n\r\n    return api;\r\n  }\r\n\r\n  /**\r\n   * Gets and sets the volume used for all audio clips played by the speaker.\r\n   *\r\n   * @type {number}\r\n   */\r\n  set volume(volume) {\r\n    this._volume = MathUtils.clamp(volume);\r\n  }\r\n\r\n  get volume() {\r\n    return this._volume;\r\n  }\r\n\r\n  /**\r\n   * Gets whether or not the speaker's volume value is currently being tweened.\r\n   *\r\n   * @readonly\r\n   * @type {boolean}\r\n   */\r\n  get volumePending() {\r\n    return this._promises.volume && this._promises.volume.pending;\r\n  }\r\n\r\n  /**\r\n   * Gets the volume used for all audio clips played by the speaker.\r\n   *\r\n   * @returns {number}\r\n   */\r\n  getVolume() {\r\n    return this.volume;\r\n  }\r\n\r\n  /**\r\n   * Updates the volume used for all audio clips played by the speaker over time.\r\n   *\r\n   * @param {number} volume - Target volume value.\r\n   * @param {number} [seconds=0] - Amount of time it will take to reach the target\r\n   * volume.\r\n   * @param {Function=} easingFn - Easing function used for interpolation.\r\n   *\r\n   * @returns {Deferred}\r\n   */\r\n  setVolume(volume, seconds = 0, easingFn) {\r\n    if (this.volumePending) {\r\n      this._promises.volume.cancel();\r\n    }\r\n\r\n    volume = MathUtils.clamp(volume);\r\n    this._promises.volume = AnimationUtils.interpolateProperty(\r\n      this,\r\n      'volume',\r\n      volume,\r\n      {seconds, easingFn}\r\n    );\r\n\r\n    return this._promises.volume;\r\n  }\r\n\r\n  /**\r\n   * Pause interpolation happening on the speaker's volume property.\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n  pauseVolume() {\r\n    this._volumePaused = true;\r\n\r\n    return this.volumePending;\r\n  }\r\n\r\n  /**\r\n   * Resume any interpolation happening on the speaker's volume property.\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n  resumeVolume() {\r\n    this._volumePaused = false;\r\n\r\n    return this.volumePending;\r\n  }\r\n\r\n  /**\r\n   * Update the currently playing speech.\r\n   *\r\n   * @param {number} deltaTime - Time since the last update.\r\n   */\r\n  update(deltaTime) {\r\n    if (!this._volumePaused) {\r\n      this._promises.volume.execute(deltaTime);\r\n    }\r\n\r\n    if (this._currentSpeech && this._currentSpeech.playing) {\r\n      this._currentSpeech.volume = this._volume;\r\n      this._currentSpeech.update(this._host.now);\r\n      super.update(deltaTime);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the current speech to a new asset and update the speech's speechmark\r\n   * offset value to match that of the feature.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {AbstractSpeech} speech - Speech to set as current.\r\n   */\r\n  _setCurrentSpeech(speech) {\r\n    speech.speechmarkOffset = this._speechmarkOffset;\r\n    this._currentSpeech = speech;\r\n  }\r\n\r\n  /**\r\n   * Create a promise that will play/resume a speech with the given text after\r\n   * the audio context attempts to resume and speech audio is retrieved from Polly.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} text - The text of the new speech to play.\r\n   * @param {Object=} config - Optional parameters for the speech.\r\n   * @param {string} [playMethod = 'play'] - Method to execute on the resulting\r\n   * Speech object. Valid options are 'play' and 'resume'.\r\n   */\r\n  _startSpeech(text, config, playMethod = 'play') {\r\n    // If no text is provided, try to use the current speech\r\n    if (text === undefined && playMethod === 'resume' && this._currentSpeech) {\r\n      text = this._currentSpeech.text;\r\n    }\r\n\r\n    const currentPromise = this._currentPromise || {\r\n      play: new Deferred(\r\n        undefined,\r\n        () => {\r\n          currentPromise.speech.cancel();\r\n        },\r\n        () => {\r\n          currentPromise.speech.cancel();\r\n        },\r\n        () => {\r\n          currentPromise.speech.cancel();\r\n        }\r\n      ),\r\n      speech: new Deferred(),\r\n    };\r\n    this._currentPromise = currentPromise;\r\n\r\n    this._getSpeech(text, config)\r\n      .then(speech => {\r\n        // Exit if the promise is no longer pending because of user interaction\r\n        if (!currentPromise.play.pending) {\r\n          return;\r\n        } else if (this._currentPromise !== currentPromise) {\r\n          // Cancel if another call to play has already been made\r\n          currentPromise.play.cancel();\r\n          return;\r\n        }\r\n\r\n        // Reset current speech when the speech ends\r\n        const onFinish = () => {\r\n          this._currentSpeech = null;\r\n          this._currentPromise = null;\r\n        };\r\n\r\n        // Cancel the currently playing speech\r\n        if (this._currentSpeech && this._currentSpeech.playing) {\r\n          if (playMethod === 'play') {\r\n            this._currentSpeech.cancel();\r\n          } else if (\r\n            playMethod === 'resume' &&\r\n            this._currentSpeech.audio !== speech.audio\r\n          ) {\r\n            this._currentSpeech.cancel();\r\n          }\r\n        }\r\n\r\n        this._setCurrentSpeech(speech);\r\n\r\n        // Play the speech\r\n        currentPromise.speech = speech[playMethod](\r\n          this._host.now,\r\n          onFinish,\r\n          onFinish,\r\n          onFinish\r\n        );\r\n        currentPromise.speech\r\n          .then(() => {\r\n            if (currentPromise.speech.resolved) {\r\n              currentPromise.play.resolve();\r\n            } else {\r\n              currentPromise.play.cancel();\r\n            }\r\n          })\r\n          .catch(error => {\r\n            currentPromise.play.reject(error);\r\n          });\r\n      })\r\n      .catch(e => {\r\n        e = `Cannot ${playMethod} speech ${text} on host ${this.host.id}. ${e}`;\r\n        currentPromise.play.reject(e);\r\n      });\r\n\r\n    return currentPromise.play;\r\n  }\r\n\r\n  /**\r\n   * Stop any speeches currently playing and play a new speech from the beginning.\r\n   *\r\n   * @param {string} text - The text of the new speech to play.\r\n   * @param {Object=} config - Optional parameters for the speech.\r\n   *\r\n   * @returns {Deferred}\r\n   */\r\n  play(text, config) {\r\n    return this._startSpeech(text, config, 'play');\r\n  }\r\n\r\n  /**\r\n   * If a speech is currently playing, pause it at the current time.\r\n   */\r\n  pause() {\r\n    if (this._currentSpeech && this._currentSpeech.playing) {\r\n      this._currentSpeech.pause(this._host.now);\r\n    } else {\r\n      console.warn(\r\n        `Cannot pause speech on host ${this.host.id}. No speech is currently playing`\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Stop any speeches currently playing and resume a new speech from the current\r\n   * time.\r\n   *\r\n   * @param {string=} text - The text of the new speech to play. If undefined and\r\n   * there is a current speech that is paused, the current speech will be resumed.\r\n   * @param {Object=} config - Optional parameters for the speech.\r\n   *\r\n   * @returns {Deferred}\r\n   */\r\n  resume(text, config) {\r\n    return this._startSpeech(text, config, 'resume');\r\n  }\r\n\r\n  /**\r\n   * If a speech is currently playing, stop playback and reset time.\r\n   */\r\n  stop() {\r\n    if (this._currentSpeech && this._currentSpeech.playing) {\r\n      this._currentSpeech.stop();\r\n      this._currentSpeech = null;\r\n    } else {\r\n      console.warn(\r\n        `Cannot stop speech on host ${this.host.id}. No speech is currently playing.`\r\n      );\r\n    }\r\n  }\r\n\r\n  discard() {\r\n    if (this._currentSpeech && this._currentSpeech.playing) {\r\n      this._currentSpeech.stop();\r\n    }\r\n\r\n    delete this._speechCache;\r\n\r\n    super.discard();\r\n  }\r\n}\r\n\r\nObject.defineProperties(AbstractTextToSpeechFeature, {\r\n  AWS_VERSION: {\r\n    get: () => awsVersion,\r\n  },\r\n  POLLY_MIN_NEURAL_VERSION: {\r\n    value: '2.503',\r\n    writable: false,\r\n  },\r\n  POLLY_DEFAULTS: {\r\n    value: {\r\n      Engine: 'standard',\r\n      LexiconNames: [],\r\n      OutputFormat: 'mp3',\r\n      SampleRate: '22050',\r\n      Text: '',\r\n      TextType: 'ssml',\r\n      VoiceId: 'Amy',\r\n      LanguageCode: 'en-GB',\r\n      LanguageName: 'British English',\r\n    },\r\n    writable: false,\r\n  },\r\n  POLLY_VOICES: {\r\n    value: [],\r\n    writable: false,\r\n  },\r\n  POLLY_LANGUAGES: {\r\n    value: {},\r\n    writable: false,\r\n  },\r\n  POLLY_LANGUAGE_CODES: {\r\n    value: {},\r\n    writable: false,\r\n  },\r\n  _isReady: {\r\n    value: false,\r\n    writable: true,\r\n  },\r\n  EVENTS: {\r\n    value: {\r\n      ...Object.getPrototypeOf(AbstractTextToSpeechFeature).EVENTS,\r\n      ready: 'onReadyEvent',\r\n      play: 'onPlayEvent',\r\n      pause: 'onPauseEvent',\r\n      resume: 'onResumeEvent',\r\n      interrupt: 'onInterruptEvent',\r\n      stop: 'onStopEvent',\r\n      sentence: 'onSentenceEvent',\r\n      word: 'onWordEvent',\r\n      viseme: 'onVisemeEvent',\r\n      ssml: 'onSsmlEvent',\r\n    },\r\n  },\r\n  SERVICES: {\r\n    value: {\r\n      ...Object.getPrototypeOf(AbstractTextToSpeechFeature).SERVICES,\r\n      polly: undefined,\r\n      presigner: undefined,\r\n    },\r\n  },\r\n});\r\n\r\nexport default AbstractTextToSpeechFeature;\r\n"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","define","amd","self","global","this","Deferred","res","rej","cancel","executable","onResolve","onReject","onCancel","Error","status","resolved","rejected","canceled","pending","resolve","reject","value","_status","_resolve","_reject","_cancel","_executable","get","execute","args","iterable","Symbol","iterator","e","array","deferred","filter","item","result","undefined","resolveValue","forEach","length","error","cancelValue","numItems","itemTracker","failed","numResolved","resolutions","index","Promise","then","Utils","replace","c","randomNumber","Math","floor","Date","now","random","toString","name","nameArray","includes","nameSet","Set","matchGroup","match","baseName","slice","increment","Number","setName","setMatchGroup","setIncrement","seconds","onFinish","onProgress","onError","console","warn","currentTime","totalTime","onUpdate","deltaTime","min","max","ceil","RadianToDegree","PI","DegreeToRadian","MathUtils","radians","degrees","from","to","factor","a","b","p","distSqr","distanceSquared","t","point","vertices","minX","POSITIVE_INFINITY","minY","maxX","NEGATIVE_INFINITY","maxY","v","dX","dY","midX","midY","dMax","superIndices","vertsWithSuper","superSortedIndices","sortPointsCCW","triangles","indices","edges","newVert","newIndex","invalidTriangles","triangle","isPointInCircumCircle","push","boundingPoly","edge","count","otherTriangle","otherEdge","splice","indexOf","sortedIndices","trianglesToRemove","map","ax","ay","bx","by","cx","cy","denom","aVal","bVal","cVal","centroid","sort","atan2","abs","vector","Array","sqrt","reduce","reducer","accumulator","currentValue","vectorA","vectorB","valueA","valueB","normalA","normalizeVector","normalB","dot","getDotProduct","acos","clamp","vector3","matrix3","every","magnitude","getVectorMagnitude","fill","matrix4","scaleX","scaleY","scaleZ","x","y","z","r","targetValue","valueStore","smoothTime","maxSpeed","clampTime","deltaValue","clampDeltaValue","lastValue","d1","d2","d3","d4","Messenger","id","_id","_dispatcher","window","_callbacks","_eventListeners","_createLocalMessage","message","_createListener","callback","detail","_createEvent","CustomEvent","_addListener","listener","addEventListener","_removeListener","removeEventListener","listenTo","stopListening","i","stopListeningByRegexp","regexp","Object","keys","test","stopListeningToAll","messages","emit","event","dispatchEvent","messenger","GlobalMessenger","defineProperties","writable","EVENTS","AbstractHostFeature","host","_host","installApi","events","api","entries","constructor","owner","update","discard","RegExp","source","ResultClass","mixinClassFactories","mixinClassFactory","SERVICES","HostObject","_owner","_features","_waits","_lastUpdate","dt","wait","values","feature","onComplete","addFeature","FeatureClass","force","inputType","prototype","removeFeature","typeName","hasFeature","listFeatures","defineProperty","getPrototypeOf","Linear","None","k","In","Out","InOut","Quadratic","FeatureDependentInterface","_onFeatureAdded","_onFeatureRemoved","BaseClass","FeatureDependentMixin","_initialized","bind","EVENT_DEPENDENCIES","eventName","AnimationFeatureDependentInterface","_onLayerAdded","_onLayerRemoved","_onLayerRenamed","oldName","newName","_onAnimationAdded","layerName","animationName","_onAnimationRemoved","_onAnimationRenamed","ParentClass","AnimationFeatureDependentMixin","AnimationFeature","addLayer","removeLayer","renameLayer","addAnimation","removeAnimation","renameAnimation","ManagedAnimationLayerInterface","registerLayer","registerAnimation","setLayerWeights","enable","easingFn","disable","ManagedAnimationLayerMixin","_managedLayers","layers","isActive","getAnimations","animName","animations","layerOptions","animOptions","options","DEFAULT_LAYER_OPTIONS","animationOptions","assign","nameFilter","weight","layerNames","setLayerWeight","blendTime","TextToSpeechFeatureDependentInterface","_onPlay","_onPause","_onResume","_onStop","_onSentence","_onWord","_onViseme","_onSsml","TextToSpeechFeatureDependentMixin","TextToSpeechFeature","play","pause","resume","stop","sentence","word","viseme","ssml","DefaultVisemeMap","sil","overrideWeight","S","T","f","s","u","E","o","O","SSMLSpeechmarkInterface","mark","SSMLSpeechMarkMixin","JSON","parse","method","apply","DefaultGestureWords","big","heart","in","many","movement","one","aggressive","you","defense","wave","GestureFeature","holdTime","minimumInterval","_getHoldTime","layer","animation","layerHoldTime","_getMinimumInterval","layerMinimumInterval","_onNext","canAdvance","isQueueEnd","currentGesture","holdTimer","playNextAnimation","playTimer","autoDisable","anim","words","createGestureMap","gestureMap","transitionTime","key","stringify","createGenericGestureArray","genericGestures","playGesture","reason","playAnimation","getPaused","stopAnimation","interruptAnimation","AnimationUtils","propertyOwner","propertyName","isNaN","startValue","interpolator","progress","easeFactor","AbstractState","_weight","_internalWeight","_paused","_promises","finish","_playCallbacks","set","setWeight","updateInternalWeight","promise","deactivate","TransitionState","_to","_from","_weightPromise","totalWeight","state","configure","currentStates","targetState","reset","weightPromises","onNext","promises","AnimationPlayerInterface","fn","_prepareCurrentState","playMethod","cancelAnimation","pauseAnimation","resumeAnimation","AnimationPlayerMixin","_transitionState","_states","Map","_currentState","_transitionTime","_easingFn","has","currentAnimation","weightPending","StateContainerInterface","getState","getStateNames","addState","removeState","renameState","currentName","discardStates","StateContainerMixin","uniqueName","QueueState","queueStates","_queue","_done","internalWeight","_reset","next","done","wrap","lastName","size","loopCount","Infinity","isTransitioning","paused","stopped","AbstractBlendState","blendStates","blendWeights","getBlendWeight","setBlendWeight","FreeBlendState","sumWeights","Blend1dState","blendThresholds","phaseMatches","_blendValue","blendValue","nonZeroDifferentSize","containsDuplicates","_thresholds","phaseMatch","_sortThresholds","_forceNoThresholdDupes","_phaseLeadState","_updateBlendWeights","thresholdValue","sameValue","find","threshold","removed","findIndex","getBlendThreshold","setBlendThreshold","normalizedTime","targetIndex","thresholdA","thresholdB","factorB","factorA","stateA","stateB","Blend2dState","otherThreshold","_blendValueX","_blendValueY","blendValueX","blendValueY","_vertices","_triangles","property","toUpperCase","_setInfluenceClosestPointOnLine","_setInfluenceTriangle","_setInfluenceClosestPointInTriangles","areaA","areaB","areaC","totalArea","weightA","weightB","weightC","thresholdC","stateC","_setPhaseLeadState","globalClosestPoint","globalMinDist","closestTriangle","pointA","pointB","pointC","distA","distB","localClosestPoint","localMinDist","closestPoint","states","phaseMatched","LayerBlendModes","Override","Additive","DefaultLayerBlendMode","validateBlendMode","blendMode","AnimationLayer","_blendMode","_weightPaused","isWeightActive","pauseWeight","resumeWeight","getAnimationBlendNames","setAnimationBlendWeight","blendName","getAnimationBlendWeight","SingleState","_timeScale","timeScale","_loopCount","time","setTimeScale","RandomAnimationState","subStates","_playInterval","playInterval","_resetTimer","timer","playRandomAnimation","randomState","AnimationTypes","single","freeBlend","queue","randomAnimation","blend1d","blend2d","_layers","_layerMap","_validateIndex","existing","lastIndex","_updateInternalWeights","weightMultiplier","currentState","_createSingleState","_createFreeBlendState","blendStateOptions","blendOptions","_createQueueState","queueOptions","queueOption","_createBlend1dState","blendMatchPhases","_createBlend2dState","_createRandomAnimationState","subStateOptions","_validateNewAnimation","numLayers","layerIndex","eventData","moveLayer","currentIndex","getLayerWeight","pauseLayerWeight","resumeLayerWeight","pauseLayer","resumeLayer","getTransitioning","getCurrentAnimation","getAnimationType","animationType","currentAnimationName","newAnimationName","nextQueuedAnimation","l","resumed","AxisMap","PositiveX","NegativeX","PositiveY","NegativeY","PositiveZ","NegativeZ","FaceTargetTypes","FaceVectors","MicroSaccadeWaitRanges","MacroSaccadeWaitRanges","default","mouthTarget","eyeTarget","AbstractSpeech","speaker","text","speechmarks","_speaker","_text","_speechmarks","_speechmarkOffset","_startTime","_localTime","_pauseTime","_playing","_markIter","_currentMark","_endTime","_promise","_createPromise","onInterrupt","interrupt","_checkFinished","offset","type","speech","TextToSpeechUtils","randomMarks","internalMap","_processInputMap","speakTags","ssmlMarkRegex","ssmlTagRegex","existingTags","exec","start","end","ssmlMarkResult","chunks","duplicateMarkToCheck","existingTag","substr","_insertMarks","markText","markedText","join","addMarksToUnmarkedSentences","validateText","marks","markIndices","markResult","ssmlResult","cleanedText","existingSsml","whitespace","sentenceEndIndices","_getSentenceEnds","prevIndex","targetIndices","containsMark","markIndex","_insertRandomMarksAt","randomMark","sentenceRegex","endSentenceRegex","sentenceEnds","punctResult","duplicatesToCheck","lowerCaseWord","checkDuplicate","markedWords","toLowerCase","existingMarks","list","isArray","awsVersion","engines","audioFormats","speechmarkTypes","sampleRates","mp3","rates","defaults","standard","neural","pcm","ogg_vorbis","AbstractTextToSpeechFeature","voice","engine","language","audioFormat","sampleRate","speechmarkOffset","minEndMarkDuration","volume","isGlobal","_speechCache","_currentSpeech","_currentPromise","_isValidated","_isGlobal","_volumePaused","_voice","POLLY_DEFAULTS","VoiceId","_language","LanguageName","_engine","Engine","_audioFormat","OutputFormat","_sampleRate","SampleRate","_minEndMarkDuration","duration","_validateEngine","AWS_VERSION","POLLY_MIN_NEURAL_VERSION","_validateFormat","format","_validateRate","rate","_validateVoice","voiceId","POLLY_VOICES","Id","SupportedEngines","_validateLanguage","languageCode","POLLY_LANGUAGES","availableCodes","LanguageCode","AdditionalLanguageCodes","POLLY_LANGUAGE_CODES","_validate","_getConfig","isReady","_updateConfig","config","skipSpeeches","currentConfig","currentConfigStr","Language","validConfig","configStr","_updateSpeech","audioParams","Text","TextType","speechmarkParams","SpeechMarkTypes","all","_synthesizeSpeechmarks","_synthesizeAudio","results","_createSpeech","audioConfig","Speech","params","presigner","getSynthesizeSpeechUrl","url","polly","synthesizeSpeech","jsonString","AudioStream","dataStr","data","String","fromCharCode","markTypes","endMarkTypes","speechMarks","matchAll","numMarks","lastMark","endTimes","endTime","_getSpeech","getVolume","setVolume","pauseVolume","resumeVolume","_volume","volumePending","playing","_setCurrentSpeech","_startSpeech","currentPromise","audio","version","customUserAgent","_withCustomUserAgent","service","_isReady","availableVoices","availableLanguages","availableLanguageCodes","minNeuralSdk","describeVoices","response","allCodes","Voices","code","ready","currentUserAgent","sumerianHostsUserAgent","concat","LexiconNames"],"sourceRoot":""}